[Int.negOfNat_mul_ofNat,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Int.negOfNat, Int.ofNat, Int.mul_comm, of_eq_true, Eq.trans, congrFun, congrArg, Int.ofNat_mul_negOfNat, Nat.mul_comm, eq_self],[Eq, HMul.hMul, Int.negOfNat, Int.ofNat]]
[Lean.HeadIndex.HeadIndex.hash,[Unit.unit, UInt64, mixHash, OfNat.ofNat, Hashable.hash],[UInt64]]
[Lean.Parser.mkAtomicInfo,[Lean.Parser.ParserInfo.mk, Lean.Parser.FirstTokens.tokens, List.cons, List.nil],[Lean.Parser.ParserInfo]]
[Lean.Parser.InputContext.mk.inj,[And.intro],[And, Eq]]
[Lean.Widget.getInteractiveDiagnostics,[Bind.bind, Lean.Server.RequestM.readDoc, Pure.pure, Option.map, Lean.FileMap.lspPosToUtf8Pos, Lean.Server.DocumentMeta.text, Lean.Server.FileWorker.EditableDocument.meta, Lean.Lsp.Position.mk, Lean.Lsp.LineRange.end, OfNat.ofNat, Lean.Widget.GetInteractiveDiagnosticsParams.lineRange?, liftM, IO.AsyncList.waitAll, Option.all, Decidable.decide, LT.lt, Lean.Server.Snapshots.Snapshot.beginPos, Lean.Server.FileWorker.EditableDocument.cmdSnaps, Task.map, Except, Lean.Server.RequestError, Array, Lean.Widget.InteractiveDiagnostic, Option.getD, List.toArray, List.nil, Task.Priority.default],[Lean.Server.RequestM, Lean.Server.RequestTask, Array, Lean.Widget.InteractiveDiagnostic]]
[Lean.Elab.Term.Quotation.MatchResult.covered.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Quotation.MatchResult.covered, HAdd.hAdd, OfNat.ofNat]]
[Lean.Name.instToStringName,[ToString.mk, Lean.Name.toString, Bool.true],[ToString, Lean.Name]]
[Nat.lt_ge_by_cases,[dite, LT.lt, Nat.lt_ge_by_cases.proof_1],[]]
[Nat.div_self,[Eq.mp, Eq.refl, Eq, HDiv.hDiv, Nat.succ, OfNat.ofNat, Nat.zero_div, HAdd.hAdd, Nat.zero_add],[Eq, HDiv.hDiv, OfNat.ofNat]]
[«term_×__1»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.bracketedExplicitBinders, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Term.trailing_parser.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.optExprPrecedence.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.ServerCapabilities.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.ServerCapabilities.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.ServerCapabilities.mk, And]]
[Lean.Meta.AbstractNestedProofs.State.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.AbstractNestedProofs.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.AbstractNestedProofs.State.mk]]
[heq_of_eq_rec_left,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, HEq, HEq.rfl],[HEq]]
[Lean.ConstantInfo.toConstantVal,[Lean.ConstantVal],[Lean.ConstantVal]]
[instToStringUInt16,[ToString.mk, ToString.toString, UInt16.toNat],[ToString, UInt16]]
[Lean.Elab.Term.Do.mkReassignCore,[ite, Eq, Array.any, not, Lean.NameSet.contains, OfNat.ofNat, Array.size, Bool.true, Bind.bind, Lean.Elab.Term.Do.extendUpdatedVarsAux, Lean.Elab.Term.Do.CodeBlock.code, Pure.pure],[Lean.Elab.Term.TermElabM, Lean.Elab.Term.Do.CodeBlock]]
[Lean.Expr.updateSort,[Lean.mkSort],[Lean.Expr]]
[Lean.Parser.ParserExtension.OLeanEntry.category.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserExtension.OLeanEntry.category, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.ParserExtension.OLeanEntry.category, And]]
[Lean.Meta.SynthInstance.checkMaxHeartbeats,[Bind.bind, MonadReader.read, liftM, Lean.Core.checkMaxHeartbeatsCore, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.SynthInstance.Context.maxHeartbeats],[Lean.Meta.SynthInstance.SynthM, Unit]]
[Std.Format.join,[List.foldl, HAppend.hAppend, Std.Format.text],[Std.Format]]
[Lean.AttributeKind.noConfusionType,[noConfusionTypeEnum, Lean.AttributeKind.toCtorIdx],[]]
[Lean.Parser.Tactic.casesTarget,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[Lean.Elab.Structural.EqnInfo.noConfusionType,[],[]]
[Lean.Lsp.ServerCapabilities.noConfusionType,[],[]]
[Lean.Elab.Term.Do.CodeBlock.code,[],[Lean.Elab.Term.Do.Code]]
[Mathlib.Tactic.Lint.simpComm,[Mathlib.Tactic.Lint.Linter.mk, Lean.Meta.withReducible, Bind.bind, Mathlib.Tactic.Lint.isSimpLemma, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Option.none, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format],[Mathlib.Tactic.Lint.Linter]]
[Lean.Elab.Structural.RecArgInfo.indIndices,[],[Array, Lean.Expr]]
[Array.instReprArray,[Repr.mk, Std.Format, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Std.Format.text, Std.Format.bracketFill, Std.Format.joinSep, Array.toList, HAppend.hAppend, Std.Format.line],[Repr, Array]]
[IsAddLeftCancel.noConfusionType,[],[]]
[Lean.Parser.Command.moduleDoc,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.ppDedent, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.commentBody, Lean.Parser.ppLine],[Lean.Parser.Parser]]
[Lean.Elab.InfoTree.smallestInfo?,[Option.map, Prod, Lean.Elab.ContextInfo, Lean.Elab.Info, Prod.mk, Array.getMax?, List.toArray, Decidable.decide, GT.gt, Prod.fst],[Option, Prod, Lean.Elab.ContextInfo, Lean.Elab.Info]]
[Lean.Expr.updateConst!.proof_1,[rfl],[Eq, Lean.Expr.isConst, Lean.Expr.const]]
[Lean.ExternAttrData.noConfusionType,[],[]]
[Array.findSomeRev?,[Id.run, Array.findSomeRevM?],[Option]]
[Lean.Parser.Tactic.failIfSuccess,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Lsp.Position.character,[],[Nat]]
[Nat.pred_le,[Unit.unit, LE.le, Nat.pred, Nat.le.refl, Nat.le_succ, Nat.succ],[LE.le, Nat.pred]]
[Decidable.not_and_distrib,[Iff.intro, dite, Or.inr, And.intro, Or.inl, not_and_of_not_or_not],[Iff, Not, And, Or]]
[exists_false,[False],[Not, Exists, False]]
[unexpandSigma,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[instAddSemigroupFin.proof_1,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, congrFun, HAdd.hAdd, Fin.add_def, Fin.mk, HMod.hMod, Nat.mod_lt, Fin.size_positive, Nat.mod_add_mod, Nat.add_assoc, Nat.add_mod_mod, eq_self],[Eq, HAdd.hAdd]]
[Lean.Elab.Term.ExtractMonadResult.expectedType,[],[Lean.Expr]]
[Lean.Parser.ppLine,[Lean.Parser.skip],[Lean.Parser.Parser]]
[Lean.IR.IRType.isUnion,[Lean.IR.IRType.float, Lean.IR.IRType.uint8, Lean.IR.IRType.uint16, Lean.IR.IRType.uint32, Lean.IR.IRType.uint64, Lean.IR.IRType.usize, Lean.IR.IRType.irrelevant, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.struct, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Parser.ParserExtension.Entry.category.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.ParserExtension.Entry.category, HAdd.hAdd, OfNat.ofNat]]
[ex_of_PSigma,[Exists, Exists.intro],[Exists]]
[Lean.Parser.Term.show.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.fromTerm.parenthesizer, Lean.Parser.Term.byTactic.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.casesOnStuckLHS,[Bind.bind, Lean.Meta.getMVarType, Lean.Meta.matchEq?, Option.none, Lean.Meta.MetaM, Array, Lean.MVarId, Lean.Meta.cases, List.toArray, List.nil, Pure.pure, Array.map, Lean.Meta.InductionSubgoal.mvarId, Lean.Meta.CasesSubgoal.toInductionSubgoal, PUnit.unit, Lean.Meta.casesOnStuckLHS.findFVar?],[Lean.Meta.MetaM, Array, Lean.MVarId]]
[instMonadFunctorT,[MonadFunctorT.mk, MonadFunctor.monadMap, MonadFunctorT.monadMap],[MonadFunctorT]]
[Lean.Elab.Term.Do.Code.break.inj,[],[Eq]]
[Lean.expandExternPatternAux,[String, ite, Not, Eq, String.Iterator.hasNext, Bool.true, Ne, Char.ofNat, PProd.fst, String.Iterator.next, String.push, HAppend.hAppend, List.getD],[String]]
[Nat.le_of_add_le_add_left,[Nat.le.intro, Eq.mp, Eq.refl, Eq, HAdd.hAdd, propext, Nat.add_left_cancel_iff, Nat.add_assoc],[LE.le]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk, And]]
[String.toNat?,[ite, Eq, String.isNat, Bool.true, Option.some, String.foldl, HAdd.hAdd, HMul.hMul, OfNat.ofNat, HSub.hSub, Char.toNat, Char.ofNat, Option.none],[Option, Nat]]
[Lean.Server.FileWorker.handleReferences.identOf,[Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofCompletionInfo, Option, Prod, Lean.Server.FileWorker.RefIdent, Bool, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Elab.TermInfo.expr, Option.some, Prod.mk, Lean.Server.FileWorker.RefIdent.const, Lean.Elab.TermInfo.isBinder, Lean.Server.FileWorker.RefIdent.fvar, Option.none, Lean.Elab.FieldInfo.projName, Bool.false],[Option, Prod, Lean.Server.FileWorker.RefIdent, Bool]]
[Lean.IR.Expr.isShared.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Expr.isShared, HAdd.hAdd, OfNat.ofNat]]
[IO.FS.Stream.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FS.Stream.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.FS.Stream.mk, And]]
[Classical.epsilon_singleton,[Classical.epsilon_spec, Exists.intro, rfl],[Eq, Classical.epsilon]]
[Lean.Parser.Tactic.reassoc!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Parser.Command.optKind.formatter,[Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Term.binderIdent.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.Term.hole.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Char.utf8Size_pos,[Classical.em, LE.le, Char.val, UInt32.ofNatCore, OfNat.ofNat, Char.utf8Size.proof_1, Eq.mpr, congrArg, LT.lt, if_pos, of_decide_eq_true, Eq.refl, Bool.true, if_neg, Char.utf8Size.proof_3, Char.utf8Size.proof_5],[LT.lt, OfNat.ofNat, Char.utf8Size]]
[Lean.Elab.InfoState.mk.inj,[And.intro],[And, Eq]]
[Lean.maxSmallNat,[Lean.maxSmallNatFn, Unit.unit],[Nat]]
[Lean.Elab.Term.ToParserDescrContext.catName,[],[Lean.Name]]
[UInt64.mk_val_eq,[Eq, UInt64.mk, UInt64.val, rfl],[Eq, UInt64.mk, UInt64.val]]
[Lean.Meta.SynthInstance.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SynthInstance.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SynthInstance.State.mk, And]]
[Lean.Widget.Lean.Widget.InteractiveGoal.instToJsonRpcEncodingPacket,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil, Lean.Json.opt],[Lean.ToJson]]
[Std.HashMap.size,[Nat],[Nat]]
[Lean.MonadQuotation.getMainModule,[],[Lean.Name]]
[Std.PersistentHashMap.noConfusionType,[],[]]
[Lean.evalConstCheck,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, Lean.ofExcept, Lean.Environment.evalConstCheck],[]]
[Int.natAbs_ofNat,[rfl],[Eq, Int.natAbs, Int.ofNat]]
[Lean.Syntax.TopDown.mk.inj,[And.intro],[And, Eq]]
[FloatArray.uset,[FloatArray, FloatArray.mk, Array.uset],[FloatArray]]
[Tactic.instInhabitedDeclCache,[inferInstanceAs, Inhabited, Prod, Tactic.Cache, Lean.Meta.MetaM],[Inhabited, Tactic.DeclCache]]
[System.Platform.numBits,[Subtype.val, System.Platform.getNumBits, Unit.unit],[Nat]]
[Lean.Parser.Term.doSeqBracketed.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.withoutPosition.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.doSeqItem.formatter, Lean.ppLine.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Tactic.Conv.paren,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.Conv.convSeq, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Lsp.instFileSourceRpcReleaseParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.RpcReleaseParams.uri],[Lean.Lsp.FileSource, Lean.Lsp.RpcReleaseParams]]
[Functor.mapConst,[],[]]
[Mathlib.Prelude.Rename.lookup3,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Parser.Term.prec.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.precedenceParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.Match.Extension.Entry.name,[],[Lean.Name]]
[Array.toArrayLit_eq'.aux,[Eq, Array.toListLitAux, List.drop, Array.data, rfl],[Eq, Array.toListLitAux, List.drop, Array.data]]
[Lean.Elab.Command.ElabHeaderResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Command.ElabHeaderResult.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.symbolFnAux,[Lean.Parser.satisfySymbolFn, BEq.beq, List.cons, List.nil],[Lean.Parser.ParserFn]]
[Lean.Elab.Command.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Command.Context.mk, And]]
[Nat.div,[WellFounded.fix, Nat.div.proof_1, dite, And, LT.lt, OfNat.ofNat, LE.le, HAdd.hAdd, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le, Nat.zero],[Nat]]
[Char.utf8Size.proof_4,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[List.card,[Unit.unit, Nat, OfNat.ofNat, ite, Mem.mem, PProd.fst, HAdd.hAdd],[Nat]]
[Lean.Elab.Term.Do.eraseOptVar,[Unit.unit, Lean.NameSet, Lean.NameSet.insert],[Lean.NameSet]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.noConfusionType,[],[]]
[Nat.coprime.coprime_dvd_left,[Nat.eq_one_of_dvd_one],[Nat.coprime]]
[Lean.setEnv,[Lean.MonadEnv.modifyEnv],[Unit]]
[Lean.MessageData.withNamingContext.inj,[And.intro],[And, Eq]]
[String.toAsciiByteArray,[String.toAsciiByteArray.loop, ByteArray.empty, OfNat.ofNat],[ByteArray]]
[Lean.Lsp.ReferenceParams.context,[],[Lean.Lsp.ReferenceContext]]
[Functor.map_equiv_apply,[rfl],[Eq, Equiv.toFun, Functor.map_equiv, Functor.map]]
[Subarray.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Command.Context.macroStack,[],[Lean.Elab.MacroStack]]
[Lean.Elab.Command.StructFieldView.declName,[],[Lean.Name]]
[lt_trans,[LT.lt, le_not_le_of_lt, lt_of_le_not_le, le_trans],[LT.lt]]
[Lean.Parser.Tactic.case',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.caseArg, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Message.data,[],[Lean.MessageData]]
[Lean.PrettyPrinter.Delaborator.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PrettyPrinter.Delaborator.Context.mk, And]]
[Lean.Elab.Term.LetRecToLift.attrs,[],[Array, Lean.Elab.Attribute]]
[Lean.IR.NormalizeIds.normExpr,[Lean.IR.Expr.lit, Id, Lean.IR.Expr, Lean.IR.Expr.ctor, Lean.IR.NormalizeIds.normArgs, Lean.IR.Expr.reset, Lean.IR.NormalizeIds.normVar, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.fap, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr],[Lean.IR.NormalizeIds.M, Lean.IR.Expr]]
[Lean.Elab.Term.FunBinders.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.FunBinders.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Widget.InfoWithCtx.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.instInhabitedJoinPointId,[Inhabited.mk, Lean.IR.JoinPointId.mk, arbitrary],[Inhabited, Lean.IR.JoinPointId]]
[Lean.Meta.Context.localInstances,[],[Lean.LocalInstances]]
[le_min,[dite, LE.le, Eq.mpr, congrArg, if_pos, if_neg],[LE.le, min]]
[Nat.dvd_of_mul_dvd_mul_left,[Exists.elim, Exists.intro, Nat.eq_of_mul_eq_mul_left, Eq.mp, Eq.refl, Eq, HMul.hMul, Nat.mul_assoc],[Dvd.dvd]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.rhs,[],[Lean.Expr]]
[List.init,[Unit.unit, List.cons, List, List.nil, PProd.fst],[List]]
[Lean.Meta.Context.noConfusionType,[],[]]
[Lean.Name.mkSimple,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Name]]
[Lean.Parser.Command.attribute.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.eraseAttr.formatter, Lean.Parser.Term.attrInstance.formatter, Bool.false, Lean.Parser.many1.formatter, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.testParseFile,[Bind.bind, IO.FS.readFile, Lean.Parser.testParseModule, System.FilePath.toString],[IO, Lean.Syntax]]
[Lean.IR.ExplicitBoxing.getLocalContext,[Functor.map, Lean.IR.ExplicitBoxing.BoxingContext.localCtx, MonadReader.read],[Lean.IR.ExplicitBoxing.M, Lean.IR.LocalContext]]
[Lean.MonadWithOptions.noConfusionType,[],[]]
[Lean.Elab.Term.Do.ToTerm.mkJmp,[Lean.Syntax.mkApp, Lean.mkIdentFrom],[Lean.Syntax]]
[Lean.PrefixTreeNode.empty,[Lean.PrefixTreeNode.Node, Option.none, Std.RBNode.leaf],[Lean.PrefixTreeNode]]
[Nat.gcd_comm,[Nat.dvd_antisymm, Nat.dvd_gcd, Nat.gcd_dvd_right, Nat.gcd_dvd_left],[Eq, Nat.gcd]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM,[ReaderT, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context, StateT, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM],[]]
[UInt32.land,[UInt32.mk, Fin.land, UInt32.val],[UInt32]]
[Function.has_uncurry.noConfusionType,[],[]]
[Lean.Lsp.CompletionOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.CompletionOptions.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.VarId.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.VarId.mk, HAdd.hAdd, OfNat.ofNat]]
[Fin.checkedMul,[Option, Fin, Fin.overflowingMul, Option.none, Option.some],[Option, Fin]]
[imp_imp_imp,[Function.comp],[]]
[Lean.Meta.sortFVarIds,[Bind.bind, Lean.MonadLCtx.getLCtx, Pure.pure, Array.qsort, Unit.unit, Bool, Lean.LocalContext.find?, Decidable.decide, LT.lt, Lean.LocalDecl.index, Bool.false, Bool.true, Lean.Name.quickLt, Lean.FVarId.name, OfNat.ofNat, HSub.hSub, Array.size],[Lean.Meta.MetaM, Array, Lean.FVarId]]
[Lean.Server.Watchdog.handleNotification,[dite, Eq, Unit.unit, Eq.symm, Lean.Server.Watchdog.ServerM, Unit, Lean.Lsp.DidOpenTextDocumentParams, Lean.Lsp.instFromJsonDidOpenTextDocumentParams, Lean.Server.Watchdog.handleDidOpen, Lean.Lsp.DidCloseTextDocumentParams, Lean.Lsp.instFromJsonDidCloseTextDocumentParams, Lean.Server.Watchdog.handleDidClose, Lean.Lsp.CancelParams, Lean.Lsp.instFromJsonCancelParams, Lean.Server.Watchdog.handleCancelRequest, Lean.Lsp.RpcConnectParams, Lean.Lsp.instFromJsonRpcConnectParams, Lean.Server.Watchdog.forwardNotification, Lean.Lsp.RpcReleaseParams, Lean.Lsp.instFromJsonRpcReleaseParams, Lean.Lsp.RpcKeepAliveParams, Lean.Lsp.instFromJsonRpcKeepAliveParams, ite, not, String.isPrefixOf, Bool.true, Bind.bind, MonadReader.read, liftM, IO.FS.Stream.putStrLn, Lean.Server.Watchdog.ServerContext.hLog, HAppend.hAppend, ToString.toString, Pure.pure, PUnit.unit],[Lean.Server.Watchdog.ServerM, Unit]]
[Lean.Declaration.isUnsafeInductiveDeclEx,[Lean.Declaration.axiomDecl, Lean.Declaration.defnDecl, Lean.Declaration.thmDecl, Lean.Declaration.opaqueDecl, Lean.Declaration.quotDecl, Lean.Declaration.mutualDefnDecl, Bool, Bool.false],[Bool]]
[Lean.ParserCompiler.instInhabitedCombinatorAttribute,[Inhabited.mk, Lean.ParserCompiler.CombinatorAttribute.mk, arbitrary],[Inhabited, Lean.ParserCompiler.CombinatorAttribute]]
[Lean.Meta.assumption,[Bind.bind, Lean.Meta.assumptionCore, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing],[Lean.Meta.MetaM, Unit]]
[Lean.ParametricAttribute.setParam,[ite, Eq, Option.isSome, Lean.Environment.getModuleIdxFor?, Bool.true, Except.error, HAppend.hAppend, ToString.toString, Lean.AttributeImplCore.name, Lean.AttributeImpl.toAttributeImplCore, Lean.ParametricAttribute.attr, Lean.NameMap.find?, Lean.PersistentEnvExtension.getState, Lean.ParametricAttribute.ext, Except.ok, Lean.PersistentEnvExtension.addEntry, Prod.mk],[Except, String, Lean.Environment]]
[Lean.Meta.DiscrTree.Key.lt,[Lean.Meta.DiscrTree.Key.const, Lean.Meta.DiscrTree.Key.fvar, Lean.Meta.DiscrTree.Key.lit, Lean.Meta.DiscrTree.Key.star, Lean.Meta.DiscrTree.Key.other, Lean.Meta.DiscrTree.Key.arrow, Lean.Meta.DiscrTree.Key.proj, Bool, Decidable.decide, LT.lt, or, Lean.Name.quickLt, Lean.FVarId.name, and, BEq.beq, Lean.Meta.DiscrTree.Key.ctorIdx],[Bool]]
[Lean.Meta.IndPredBelow.BrecOnVariables.indHyps,[],[Array, Lean.FVarId]]
[«term_=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Parser.Command.openRenamingItem.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.Parser.unicodeSymbol.formatter, Lean.PrettyPrinter.Formatter.checkColGt.formatter],[Lean.PrettyPrinter.Formatter]]
[Nat.sub_lt_left_of_lt_add,[],[LT.lt, HSub.hSub]]
[Lean.Server.Watchdog.ServerContext.workerPath,[],[System.FilePath]]
[Lean.Option.set,[Lean.KVMap.set, Lean.Option.name],[Lean.Options]]
[Lean.Meta.Config.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.instInhabitedPostponedEntry,[Inhabited.mk, Lean.Meta.PostponedEntry.mk, arbitrary],[Inhabited, Lean.Meta.PostponedEntry]]
[Function.involutive,[Eq],[]]
[congr,[rfl],[Eq]]
[Stream.noConfusionType,[],[]]
[Lean.Meta.NormNum.LawfulOne.isNat_one,[],[Lean.Meta.NormNum.isNat, One.one]]
[Lean.Elab.Command.Scope.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.Scope.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Command.Scope.mk, And]]
[Lean.LocalContext.getAt?,[Std.PersistentArray.get!, Lean.LocalContext.decls],[Option, Lean.LocalDecl]]
[Lean.KeyedDeclsAttribute.Def.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KeyedDeclsAttribute.Def.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Syntax.decodeNatLitVal?,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Option.none, Char.ofNat, Option.some, or, Char.isDigit],[Option, Nat]]
[Prod.lt_def,[rfl],[Eq, LT.lt, Or, Prod.fst, And, Prod.snd]]
[Ring.toNeg,[],[Neg]]
[Lean.Meta.matchMatcherApp?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Meta.MatcherApp, Lean.Expr.getAppFn, Bind.bind, Lean.Meta.getMatcherInfo?, Unit.unit, Pure.pure, Option.none, ite, LT.lt, Array.size, Lean.Meta.Match.MatcherInfo.arity, Option.some, Lean.Meta.MatcherApp.mk, List.toArray, Lean.Meta.Match.MatcherInfo.uElimPos?, Array.extract, OfNat.ofNat, Lean.Meta.Match.MatcherInfo.numParams, Array.getOp, Lean.Meta.Match.MatcherInfo.getMotivePos, Array.ofSubarray, Array.toSubarray, HAdd.hAdd, Lean.Meta.Match.MatcherInfo.numDiscrs, Lean.Meta.Match.MatcherInfo.altNumParams, Lean.Meta.Match.MatcherInfo.numAlts],[Option, Lean.Meta.MatcherApp]]
[Lean.LocalContext.allM,[Std.PersistentArray.allM, Lean.LocalContext.decls, Unit.unit, Bool, Pure.pure, Bool.true],[Bool]]
[BEq.beq,[],[Bool]]
[Lean.withImporting,[tryFinally, Bind.bind, ST.Ref.set, Bool.true, Bool.false],[IO]]
[Lean.Elab.Term.StructInst.DefaultFields.State.mk.inj,[],[Eq]]
[Lean.Elab.Term.StructInst.DefaultFields.Context.maxDistance,[],[Nat]]
[instHAdd,[HAdd.mk, Add.add],[HAdd]]
[instInhabitedUInt64.proof_1,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt64.size]]
[Lean.Meta.SortLocalDecls.State.result,[],[Array, Lean.LocalDecl]]
[Lean.Xml.Parser.Name,[Bind.bind, Lean.Xml.Parser.NameStartChar, Lean.Parsec.manyCharsCore, Lean.Xml.Parser.NameChar, Char.toString],[Lean.Parsec, String]]
[Lean.Parser.Term.doExpr.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.notFollowedByRedefinedTermToken.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.PrettyPrinter.Parenthesizer.notFollowedBy.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Server.FileWorker.RefIdent.noConfusionType,[],[]]
[Fin.mk.inj,[],[Eq]]
[Lean.Parser.Term.prio.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.priorityParser],[Lean.Parser.Parser]]
[Std.PersistentArray.anyM,[orM, Std.PersistentArray.anyMAux, Std.PersistentArray.root, Array.anyM, Std.PersistentArray.tail, OfNat.ofNat, Array.size],[Bool]]
[StdGen.noConfusionType,[],[]]
[Lean.Elab.deltaLHS,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getMVarType', Pure.pure, Lean.Expr.eq?, Option.none, Lean.Meta.MetaM, Lean.MVarId, liftM, Lean.Meta.delta?, Bool.true, Lean.Meta.mkEq, Lean.Meta.replaceTargetDefEq, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing],[Lean.Meta.MetaM, Lean.MVarId]]
[Nat.succ_pos,[Nat.zero_lt_succ],[LT.lt, OfNat.ofNat, Nat.succ]]
[Lean.Meta.matchNe?,[Lean.Meta.matchHelper?, Option.none, Lean.Meta.MetaM, Option, Prod, Lean.Expr, Lean.Expr.ne?, Pure.pure, Option.some, Bind.bind, Lean.Meta.matchNot?, Lean.Meta.matchEq?],[Lean.Meta.MetaM, Option, Prod, Lean.Expr]]
[UInt8.div,[UInt8.mk, HDiv.hDiv, UInt8.val],[UInt8]]
[WellFoundedRelation.wf,[],[WellFounded, WellFoundedRelation.rel]]
[Lean.instEmptyCollectionNameTrie,[EmptyCollection.mk, Lean.NameTrie.empty],[EmptyCollection, Lean.NameTrie]]
[Semiring.one_mul,[],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Meta.applyRefl,[Lean.Meta.withMVarContext, Bind.bind, Lean.observing?, Lean.Meta.mkFreshLevelMVar, Lean.Meta.apply, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil, Option.none, Unit.unit, Option.some, Lean.Meta.MetaM, Unit, Pure.pure, PUnit.unit, Lean.Meta.throwTacticEx, Lean.Syntax.missing],[Lean.Meta.MetaM, Unit]]
[Std.PersistentHashSet.foldM,[Std.PersistentHashMap.foldlM, Std.PersistentHashSet.set],[]]
[Lean.HeadIndex.mvar.injEq,[Eq.propIntro, Eq.refl, Lean.HeadIndex.mvar, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.HeadIndex.mvar]]
[Lean.Compiler.SpecInfo.noConfusionType,[],[]]
[Lean.Lsp.SymbolKind.variable.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.variable, OfNat.ofNat]]
[Lean.Elab.Term.registerMVarErrorCustomInfo,[Lean.Elab.Term.registerMVarErrorInfo, Lean.Elab.Term.MVarErrorInfo.mk, Lean.Elab.Term.MVarErrorKind.custom],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Parser.Term.structInst,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ppHardSpace, Lean.Parser.optional, Lean.Parser.atomic, Lean.Parser.sepBy1, Lean.Parser.termParser, Bool.false, Lean.Parser.manyIndent, Lean.Parser.group, HOrElse.hOrElse, Lean.Parser.Term.structInstFieldAbbrev, Lean.Parser.Term.structInstField, Lean.Parser.Term.optEllipsis],[Lean.Parser.Parser]]
[Lean.Meta.getLocalDecl,[Bind.bind, Lean.MonadLCtx.getLCtx, Unit.unit, Lean.Meta.MetaM, Lean.LocalDecl, Lean.LocalContext.find?, Pure.pure, Lean.Meta.throwUnknownFVar],[Lean.Meta.MetaM, Lean.LocalDecl]]
[Lean.Lsp.instFromJsonReferenceContext,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Bool, Pure.pure, Lean.Lsp.ReferenceContext.mk],[Lean.FromJson, Lean.Lsp.ReferenceContext]]
[Array.filterMap,[Id.run, Array.filterMapM],[Array]]
[System.FilePath.pathExists,[Bind.bind, EIO.toBaseIO, System.FilePath.metadata, Pure.pure, Except.toBool],[BaseIO, Bool]]
[Lean.Parser.Term.forall.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.unicodeSymbol.formatter, Lean.Parser.many1.formatter, Lean.ppSpace.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.simpleBinder.formatter, Lean.Parser.Term.bracketedBinder.formatter, Bool.false, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Char.toUInt8,[UInt32.toUInt8, Char.val],[UInt8]]
[mul_left_inj,[Iff.intro, mul_right_cancel, rfl],[Iff, Eq, HMul.hMul]]
[Lean.Name.toStringWithSep,[Unit.unit, Lean.Name.str, Lean.Name.num, String, Lean.Name.toStringWithSep.maybeEscape, ToString.toString, HAppend.hAppend, PProd.fst, Nat.repr],[String]]
[Fin.val_eq_of_lt,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Nat.mod_eq_of_lt, eq_self],[Eq, Fin.val, Fin.ofNat', zero_lt_of_lt]]
[Lean.Parser.ParserModuleContext.mk.inj,[And.intro],[And, Eq]]
[Lean.PrettyPrinter.Formatter.withAntiquot.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.registerOption,[Bind.bind, Lean.initializing, ite, Eq, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, IO.userError],[IO, Unit]]
[Lean.Level.mvar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Level.mvar, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.inductionAlt,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[And.comm,[Iff.intro, And.symm],[Iff, And]]
[Lean.Elab.Command.elabMutual,[ite, Eq, Array.all, Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Array.size, Bool.true, Option.none, Lean.Elab.Command.CommandElabM, Unit, Lean.Elab.TerminationHints.terminationBy?, Bind.bind, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Elab.Command.isDefLike, ForIn.forIn, ForInStep, PUnit, Lean.Elab.Command.elabMutualDef, Lean.throwError],[Lean.Elab.Command.CommandElab]]
[Lean.Elab.Term.Do.pullExitPoints,[ite, Eq, Lean.Elab.Term.Do.hasExitPoint, Bool.true, Bind.bind, StateRefT'.run, Lean.Elab.Term.Do.pullExitPointsAux, EmptyCollection.emptyCollection, List.toArray, List.nil, Lean.Elab.Term.TermElabM, Lean.Elab.Term.Do.Code, Pure.pure, Lean.Elab.Term.Do.attachJPs],[Lean.Elab.Term.TermElabM, Lean.Elab.Term.Do.Code]]
[Lean.Lsp.WaitForDiagnostics.toCtorIdx,[OfNat.ofNat],[Nat]]
[Std.HashMap.find!,[Unit.unit, Std.HashMap.find?, panicWithPosWithDecl, OfNat.ofNat],[]]
[Lean.NameSSet.empty,[Lean.SSet.empty],[Lean.NameSSet]]
[Lean.Parser.Term.isIdent,[or, Lean.Syntax.isAntiquot, Lean.Syntax.isIdent],[Bool]]
[Lean.Meta.Match.InjectionAnyResult.solved.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.Match.InjectionAnyResult.solved, OfNat.ofNat]]
[Lean.Parser.Term.trueVal.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.MarkupKind.markdown.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.MarkupKind.markdown, OfNat.ofNat]]
[instSemiringFin.proof_9,[Eq.mpr, Eq.refl, Eq, HMul.hMul, OfNat.ofNat, instSemiringFin.proof_4, instSemiringFin.proof_2],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Server.FileWorker.handleWaitForDiagnostics,[Bind.bind, Lean.Server.RequestM.asTask, Lean.Server.RequestM.bindTask, liftExcept, liftM, IO.AsyncList.waitAll, Bool.true, Lean.Server.FileWorker.EditableDocument.cmdSnaps, Pure.pure, Task.map, Lean.Lsp.WaitForDiagnostics.mk, Task.Priority.default, Lean.Server.FileWorker.handleWaitForDiagnostics.waitLoop],[Lean.Server.RequestM, Lean.Server.RequestTask, Lean.Lsp.WaitForDiagnostics]]
[Lean.Elab.TacticInfo.goalsAfter,[],[List, Lean.MVarId]]
[Lean.Elab.Tactic.Conv.getRhs,[Bind.bind, Lean.Elab.Tactic.Conv.getLhsRhs, Pure.pure, Prod.snd],[Lean.Elab.Tactic.TacticM, Lean.Expr]]
[Lean.Compiler.NumScalarTypeInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Compiler.NumScalarTypeInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Compiler.NumScalarTypeInfo.mk, And]]
[Lean.Meta.Match.Extension.State.map,[],[Lean.SMap, Lean.Name, Lean.Meta.Match.MatcherInfo]]
[Lean.IR.EmitC.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.KVMap.Value.ofDataValue?,[],[Option]]
[EStateM.instMonadEStateM,[Monad.mk],[Monad, EStateM]]
[String.extract,[String, ite, GE.ge, String.mk, List.nil, List.cons, List, Char, Eq, PProd.fst, HAdd.hAdd, String.csize, OfNat.ofNat],[String]]
[Lean.Meta.mkEqRec,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.eq?, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr, Lean.Meta.getLevel, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.mkAppN, Lean.mkConst, List.cons, List.nil, List.toArray],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Lsp.InitializedParams.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.InitializedParams.mk, OfNat.ofNat]]
[Lean.Parser.Term.scoped.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.writeModule,[Bind.bind, Lean.mkModuleData, Lean.saveModuleData, Lean.Environment.mainModule],[IO, Unit]]
[Lean.NameSSet.instInhabitedNameSSet,[Inhabited.mk, Lean.NameSSet.empty],[Inhabited, Lean.NameSSet]]
[Lean.Lsp.LeanFileProgressProcessingInfo.noConfusionType,[],[]]
[Int.ofNat_add_negSucc_ofNat,[rfl],[Eq, HAdd.hAdd, Int.ofNat, Int.negSucc, Int.subNatNat, Nat.succ]]
[instHashableNat,[Hashable.mk, UInt64.ofNat],[Hashable, Nat]]
[Lean.Meta.DiscrTree.Key.lit.inj,[],[Eq]]
[Lean.IR.IRType.isScalar,[Unit.unit, Lean.IR.IRType.irrelevant, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.struct, Lean.IR.IRType.union, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Lsp.RpcReleaseParams.noConfusionType,[],[]]
[Set.«term{_|_}»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Mathlib.ExtendedBinder.extBinder, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Expr.isHeadBetaTargetFn,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Bool, Bool.true, PProd.fst, Bool.false],[Bool]]
[Tactic.Ring.HornerExpr.const.inj,[And.intro],[And, Eq]]
[List.decidableBall,[Unit.unit, Decidable, Decidable.isTrue, List.decidableBall.proof_1, Decidable.isFalse, List.decidableBall.proof_2, PProd.fst, List.decidableBall.proof_3, List.decidableBall.proof_4],[Decidable]]
[Except.orElseLazy,[Except, Except.ok, Unit.unit],[Except]]
[Lean.IR.ExplicitRC.instInhabitedVarInfo,[Inhabited.mk, Lean.IR.ExplicitRC.VarInfo.mk, arbitrary],[Inhabited, Lean.IR.ExplicitRC.VarInfo]]
[Lean.instEvalUnit,[Lean.Eval.mk, ite, Eq, Bool.true, Pure.pure, Unit.unit, IO.println, repr],[Lean.Eval, Unit]]
[Lean.updateEnvAttributesImpl,[Bind.bind, ST.Ref.get, Lean.attributeMapRef, Pure.pure, Lean.PersistentEnvExtension.getState, Lean.attributeExtension, Lean.PersistentEnvExtension.setState],[IO, Lean.Environment]]
[Lean.Server.Completion.State.itemsMain,[],[Array, Lean.Lsp.CompletionItem]]
[Lean.Elab.Structural.M,[StateRefT', IO.RealWorld, Lean.Elab.Structural.State, Lean.Meta.MetaM],[]]
[instReprString,[Repr.mk, Std.Format.text, String.quote],[Repr, String]]
[Lean.Elab.Term.Do.CodeBlock.uvars,[],[Lean.NameSet]]
[Lean.Elab.Term.declareTacticSyntax,[Lean.MonadQuotation.withFreshMacroScope, Bind.bind, Lean.MonadQuotation.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.Term.quoteAutoTactic, Lean.Elab.Term.elabTerm, Option.some, Bool.true, liftM, Lean.Meta.instantiateMVars, Lean.isTracingEnabledFor, ite, Eq, Lean.addTrace, Lean.MessageData.ofExpr, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElabM, Lean.Name]]
[Lean.Meta.Simp.Context.mkDefault,[Bind.bind, liftM, Lean.Meta.getSimpLemmas, Lean.Meta.getCongrLemmas, Pure.pure, Lean.Meta.Simp.Context.mk, Lean.Meta.Simp.Config.mk],[Lean.Meta.MetaM, Lean.Meta.Simp.Context]]
[Lean.Server.FileWorker.GoToKind.noConfusionType,[noConfusionTypeEnum, Lean.Server.FileWorker.GoToKind.toCtorIdx],[]]
[Fin.checked_add_spec,[Decidable.em, LE.le, HAdd.hAdd, Fin.val, of_eq_true, Eq.trans, congrFun, congrArg, Iff, Eq, Unit.unit, Bool, Option, Fin, Prod.mk, decide_eq_true, eq_true, Option.none, Option.some, Bool.true, Bool.false, eq_false', LT.lt, false_iff, propext, not_lt, Eq.symm, congr, decide_eq_false, Not, eq_false, eq_true_of_decide, Eq.refl, Eq.mp, not_le],[Iff, Eq, Option.isSome, Fin.checkedAdd, Bool.true, LT.lt, HAdd.hAdd, Fin.val]]
[Lean.instInhabitedTagAttribute,[Inhabited.mk, Lean.TagAttribute.mk, arbitrary],[Inhabited, Lean.TagAttribute]]
[Lean.Expr.fvar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Expr.fvar, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.instToJsonVersionedTextDocumentIdentifier,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.VersionedTextDocumentIdentifier.uri, List.nil, Lean.Json.opt, Lean.Lsp.VersionedTextDocumentIdentifier.version?],[Lean.ToJson, Lean.Lsp.VersionedTextDocumentIdentifier]]
[Lean.Meta.getDelayedAssignment?,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.getDelayedAssignment?],[Lean.Meta.MetaM, Option, Lean.DelayedMetavarAssignment]]
[Lean.Parser.Command.macroTailTactic.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.identEq.formatter, Lean.Name.mkSimple, Lean.Parser.darrow.formatter, Lean.Parser.Command.macroRhs.formatter, Lean.Parser.Tactic.seq1.formatter],[Lean.PrettyPrinter.Formatter]]
[Decidable.not_and_not_right,[Iff.intro, Not.decidable_imp_symm, And.intro, False],[Iff, Not, And]]
[Lean.Server.RequestError.methodNotFound,[Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.methodNotFound, HAppend.hAppend, ToString.toString],[Lean.Server.RequestError]]
[Lean.Elab.Term.StructInst.DefaultFields.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.StructInst.DefaultFields.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.StructInst.instInhabitedStruct,[Inhabited.mk, Lean.Elab.Term.StructInst.Struct.mk, arbitrary],[Inhabited, Lean.Elab.Term.StructInst.Struct]]
[Mathlib.Tactic.Ext.withExtHyps,[Bind.bind, Lean.MonadEnv.getEnv, ite, Eq, Lean.isStructure, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM]]
[Lean.Parser.lookahead,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.lookaheadFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.Constructor.noConfusionType,[],[]]
[Lean.PersistentEnvExtension.addEntry,[Lean.EnvExtension.modifyState, Lean.PersistentEnvExtension.toEnvExtension, Lean.PersistentEnvExtensionState.mk, Lean.PersistentEnvExtensionState.importedEntries],[Lean.Environment]]
[Lean.IR.EmitC.emitAllocCtor,[Bind.bind, Lean.IR.EmitC.emit, Lean.IR.CtorInfo.cidx, Lean.IR.CtorInfo.size, Lean.IR.EmitC.emitCtorScalarSize, Lean.IR.CtorInfo.usize, Lean.IR.CtorInfo.ssize, Lean.IR.EmitC.emitLn],[Lean.IR.EmitC.M, Unit]]
[Lean.Server.Watchdog.WorkerState.crashed.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.Watchdog.WorkerState.crashed, HAdd.hAdd, OfNat.ofNat]]
[IO.Error.invalidArgument.inj,[And.intro],[And, Eq]]
[Lean.Meta.mkHCongrWithArity,[Bind.bind, Lean.Meta.inferType, Lean.Meta.forallBoundedTelescope, Option.some, ite, Eq, bne, Array.size, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.MonadLCtx.getLCtx, Lean.Meta.getLocalInstances, Lean.Meta.withLCtx, Lean.Meta.CongrTheorem, ForIn.forIn, MProd.mk, Unit.unit, Lean.Meta.MetaM, ForInStep, MProd, Subarray, Lean.Expr, Array, Stream.next?, Pure.pure, ForInStep.done, PUnit.unit, ForInStep.yield, BEq.beq, Lean.Meta.mkEq, Lean.Meta.mkHEq, Lean.Meta.mkHCongrWithArity.withNewEqs, Lean.Meta.mkHCongrWithArity.mkProof],[Lean.Meta.MetaM, Lean.Meta.CongrTheorem]]
[Lean.Xml.Parser.EntityRef,[Lean.Parsec.attempt, SeqLeft.seqLeft, SeqRight.seqRight, Lean.Parsec.skipChar, Char.ofNat, Functor.map, Lean.Xml.Parser.predefinedEntityToChar, Lean.Xml.Parser.Name],[Lean.Parsec, Option, Lean.Xml.Parser.LeanChar]]
[USize.val,[],[Fin, USize.size]]
[Lean.Elab.Term.MkInstResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.MkInstResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.MkInstResult.mk, And]]
[Lean.Meta.IndPredBelow.proveBrecOn.applyCtors,[Bind.bind, Array.mapIdxM, List.toArray, Lean.Meta.IndPredBelow.proveBrecOn.introNPRec, Lean.Meta.getMVarType, Lean.Expr.withApp, Lean.Meta.withMVarContext, Array.back, Lean.getConstInfoCtor, Lean.Meta.forallMetaTelescope, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, Lean.MetavarKind.natural, Lean.Meta.MetaM, List, Lean.MVarId, Lean.Meta.apply, Pure.pure, Array.foldr, List.append, List.nil, Array.size, OfNat.ofNat],[Lean.Meta.MetaM, List, Lean.MVarId]]
[Nat.zero_mod,[Eq.mpr, Eq.refl, Eq, HMod.hMod, OfNat.ofNat, Nat.mod_eq],[Eq, HMod.hMod, OfNat.ofNat]]
[DivInvMonoid.gpow,[],[]]
[Lean.Server.Watchdog.WorkerEvent.ioError.inj,[],[Eq]]
[Lean.Parser.Command.optKind.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Expr.isHeadBetaTarget,[Lean.Expr.isHeadBetaTargetFn, Lean.Expr.getAppFn],[Bool]]
[Lean.ToMessageData.noConfusionType,[],[]]
[USize.decEq,[Decidable, Eq, dite, Decidable.isTrue, USize.decEq.proof_1, Decidable.isFalse, USize.decEq.proof_2],[Decidable, Eq]]
[Lean.Parser.Term.matchAlts.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.ppDedent.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.many1Indent.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.ppLine.formatter, Lean.Parser.Term.matchAlt.formatter],[Lean.PrettyPrinter.Formatter]]
[Quot.hrecOn.proof_1,[eq_of_heq],[Eq, Quot.sound]]
[Lean.Parsec.many1,[Bind.bind, Lean.Parsec.manyCore, List.toArray, List.cons, List.nil],[Lean.Parsec, Array]]
[Lean.Meta.getConfig,[Bind.bind, MonadReader.read, Pure.pure, Lean.Meta.Context.config],[Lean.Meta.MetaM, Lean.Meta.Config]]
[Lean.Server.RpcEncoding.DerivingParams.mk.inj,[],[Eq]]
[Lean.instMonadEnv,[Lean.MonadEnv.mk, liftM, Lean.MonadEnv.getEnv, Lean.MonadEnv.modifyEnv],[Lean.MonadEnv]]
[inferInstanceAs,[],[]]
[Lean.Parser.Syntax.numPrec,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.numLit],[Lean.Parser.Parser]]
[Lean.Parser.Command.declValSimple.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.whereDecls.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Tactic.appendGoals,[modify, Lean.Elab.Tactic.State.mk, HAppend.hAppend, Lean.Elab.Tactic.State.goals],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.IR.getSorryDep,[Option.none, Option.some, Lean.IR.Decl.extern, Option, Lean.Name, Lean.SMap.find?, Lean.SimplePersistentEnvExtension.getState, Lean.IR.declMapExt],[Option, Lean.Name]]
[and_congr_right',[and_congr, Iff.rfl],[Iff, And]]
[Lean.Server.Watchdog.FileWorker.stdout,[IO.FS.Stream.ofHandle, IO.Process.Child.stdout, Lean.Server.Watchdog.FileWorker.proc],[IO.FS.Stream]]
[Lean.Server.Watchdog.FileWorker.state,[],[Lean.Server.Watchdog.WorkerState]]
[Lean.Meta.isAuxDef,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, or, Lean.isAuxRecursor, Lean.isNoConfusion],[Lean.Meta.MetaM, Bool]]
[Lean.mkGroupNode,[Lean.mkNode, Lean.groupKind],[Lean.Syntax]]
[Substring.isNat,[Substring.all, Char.isDigit],[Bool]]
[Lean.TraceState.mk.inj,[And.intro],[And, Eq]]
[Prod.foldI,[Nat.foldAux, Prod.snd, HSub.hSub, Prod.fst],[]]
[Int.negSucc_ofNat_mul_negOfNat,[Unit.unit, Eq, HMul.hMul, Int.negSucc, Int.negOfNat, Int.ofNat, Nat.succ, rfl],[Eq, HMul.hMul, Int.negSucc, Int.negOfNat, Int.ofNat, Nat.succ]]
[Char.lt,[LT.lt, Char.val],[]]
[Lean.IR.UnreachableBranches.InterpContext.currFnIdx,[],[Nat]]
[Lean.LocalContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.LocalContext.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.ParametricAttribute.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ParametricAttribute.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.simpleBinder,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.many1, Lean.Parser.Term.binderIdent, Lean.Parser.Term.optType],[Lean.Parser.Parser]]
[Lean.Elab.Term.addAutoBoundImplicits,[Bind.bind, MonadReader.read, ForIn.forIn, PUnit.unit, liftM, Lean.Meta.getLocalDecl, Lean.Expr.fvarId!, Lean.MonadMCtx.getMCtx, ite, Eq, Lean.MetavarContext.localDeclDependsOn, Bool.true, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, ForInStep.yield, Std.PersistentArray.toArray],[Lean.Elab.Term.TermElabM, Array, Lean.Expr]]
[Std.RBNode.del,[Unit.unit, Std.RBNode, Std.RBNode.leaf, ite, Eq, Std.RBNode.isBlack, Bool.true, Std.RBNode.balLeft, PProd.fst, Std.RBNode.node, Std.Rbcolor.red, Std.RBNode.balRight, PProd.snd, Std.RBNode.appendTrees],[Std.RBNode]]
[Lean.Elab.Term.TermElabM.run,[Lean.Meta.withConfig, Lean.Elab.Term.setElabConfig, StateRefT'.run],[Lean.Meta.MetaM, Prod, Lean.Elab.Term.State]]
[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.noConfusionType,[],[]]
[Array.concatMap,[Array.foldl, HAppend.hAppend, Array.empty, OfNat.ofNat, Array.size],[Array]]
[Lean.Elab.Term.TermElab,[Lean.Elab.Term.TermElabM, Lean.Expr],[]]
[Lean.IR.LocalContext.eraseJoinPointDecl,[Std.RBMap.erase, Lean.IR.JoinPointId.idx],[Lean.IR.LocalContext]]
[Std.HashSetImp.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.HashSetImp.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.HashSetImp.mk, And]]
[Lean.Parser.decimalNumberFn,[ite, Eq, or, BEq.beq, Char.ofNat, Bool.true, Lean.Parser.mkNodeToken, Lean.scientificLitKind, Lean.numLitKind, Lean.Parser.decimalNumberFn.parseOptDot, Lean.Parser.decimalNumberFn.parseOptExp],[Lean.Parser.ParserState]]
[Lean.PrettyPrinter.Parenthesizer.optionalNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitArgs],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.PrettyPrinter.Formatter.lookahead.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[Lean.Json.Structured.obj.inj,[],[Eq]]
[Lean.Elab.Term.Do.Code.seq.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Code.seq, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.Code.seq, And]]
[Lean.Meta.SimpAll.Entry.id,[],[Lean.Name]]
[Lean.isIdFirst,[or, Char.isAlpha, Decidable.decide, Eq, Char.ofNat, Lean.isLetterLike],[Bool]]
[Lean.instToExprChar,[Lean.ToExpr.mk, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.ToExpr.toExpr, Char.toNat],[Lean.ToExpr, Char]]
[Lean.Parser.Term.binderTactic.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Tactic.tacticSeq.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.DefViewElabHeader.modifiers,[],[Lean.Elab.Modifiers]]
[Lean.privatePrefix?,[ite, Eq, Lean.isPrivateName, Bool.true, Option.some, Lean.Name.anonymous, Lean.Name.num, Lean.Name, PProd.fst, Option.none],[Option, Lean.Name]]
[Lean.Lsp.TypeDefinitionParams.mk.inj,[],[Eq]]
[Lean.JsonRpc.RequestID.noConfusionType,[],[]]
[Lean.Parser.Tactic.clearExcept,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Nat.gcd_dvd_right,[And.right, Nat.gcd_dvd],[Dvd.dvd, Nat.gcd]]
[Lean.ProjectionFunctionInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ProjectionFunctionInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Array.insertAt,[ite, GT.gt, Array.size, panicWithPosWithDecl, OfNat.ofNat, Array.insertAtAux],[Array]]
[Subtype.coind_surjective,[Exists, Eq, Subtype.coind, Exists.intro, Subtype.coe_injective],[Function.surjective, Subtype.coind]]
[Lean.Meta.instInhabitedGeneralizeArg,[Inhabited.mk, Lean.Meta.GeneralizeArg.mk, arbitrary],[Inhabited, Lean.Meta.GeneralizeArg]]
[Function.involutive.comp_self,[funext],[Eq, Function.comp, id]]
[Lean.Meta.Cache.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Cache.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Cache.mk, And]]
[Array.insertionSort.swapLoop,[Array, Eq.refl],[Array]]
[Std.PersistentArray.mod2Shift,[USize.land, HSub.hSub, USize.shiftLeft, OfNat.ofNat],[USize]]
[Lean.IR.Borrow.ParamMap.instBEqKey,[BEq.mk, Lean.IR.Borrow.ParamMap.Key.decl, Lean.IR.Borrow.ParamMap.Key.jp, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.IR.Borrow.ParamMap.Key]]
[Lean.Elab.Tactic.getMainTag,[Bind.bind, Lean.Elab.Tactic.getMainDecl, Pure.pure, Lean.MetavarDecl.userName],[Lean.Elab.Tactic.TacticM, Lean.Name]]
[Lean.Parser.instReprLeadingIdentBehavior,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone],[Repr, Lean.Parser.LeadingIdentBehavior]]
[Lean.KernelException.declHasFVars.inj,[And.intro],[And, Eq]]
[Lean.Expr.FoldConstsImpl.visited,[Bind.bind, MonadState.get, ite, Eq, BEq.beq, ptrAddrUnsafe, Bool.true, Pure.pure, modify, Lean.Expr.FoldConstsImpl.State.mk, Array.uset, Lean.Expr.FoldConstsImpl.State.visitedTerms, Lean.Expr.FoldConstsImpl.visited.proof_2, Lean.Expr.FoldConstsImpl.State.visitedConsts, Bool.false],[Lean.Expr.FoldConstsImpl.FoldM, Bool]]
[Lean.Lsp.Location.uri,[],[Lean.Lsp.DocumentUri]]
[Lean.Message.noConfusionType,[],[]]
[Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.noConfusionType,[],[]]
[Array.find?,[Id.run, Array.findM?],[Option]]
[IO.AsyncList.nil.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.AsyncList.nil, OfNat.ofNat]]
[Lean.MVarId.mk.inj,[],[Eq]]
[Lean.Meta.withNewLocalInstances,[Lean.Meta.mapMetaM],[]]
[Lean.Server.Watchdog.GroupedEdits.applyTime,[],[Nat]]
[Lean.Meta.instBEqTransparencyMode,[BEq.mk, BEq.beq, Lean.Meta.TransparencyMode.toCtorIdx],[BEq, Lean.Meta.TransparencyMode]]
[Lean.mkIBelow,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.MonadEnv.modifyEnv, Lean.throwKernelException, Lean.mkIBelowImp],[Unit]]
[instDecidableEqBool.proof_2,[],[Bool.noConfusionType, False, Bool.true, Bool.false]]
[Lean.IR.CtorFieldInfo.noConfusionType,[],[]]
[Or.symm,[Or, Or.inr, Or.inl],[Or]]
[Nat.gcd_gcd_self_right_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, Nat.gcd_comm, Nat.gcd_gcd_self_right_left, rfl],[Eq, Nat.gcd]]
[Tactic.Ring.horner_mul_horner_zero,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Tactic.Ring.horner, OfNat.ofNat, Eq.symm, of_eq_true, Eq.trans, congr, congrArg, HAdd.hAdd, HPow.hPow, add_zero, add_mul, congrFun, mul_assoc, eq_self],[Eq, HMul.hMul, Tactic.Ring.horner, OfNat.ofNat]]
[Lean.findDeclarationRanges?,[Bind.bind, liftM, ST.Ref.get, Lean.builtinDeclRanges, Option.none, Option, Lean.DeclarationRanges, Lean.NameMap.find?, Pure.pure, Option.some, PUnit.unit],[Option, Lean.DeclarationRanges]]
[Lean.PrettyPrinter.Formatter.symbolNoAntiquot.formatter,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, Lean.Syntax.isToken, Bool.true, Pure.pure, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Lean.PrettyPrinter.FormatterM, Unit, Lean.PrettyPrinter.Formatter.pushToken, Lean.Syntax.MonadTraverser.goLeft, panicWithPosWithDecl, OfNat.ofNat, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Std.ToFormat.format, PUnit.unit],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.longestMatchFn,[Unit.unit, List.cons, Lean.Parser.ParserFn, Lean.Parser.ParserState.mkError, Lean.Parser.runLongestMatchParser, Lean.Parser.ParserState.lhsPrec, Lean.Parser.Parser.fn, Prod.fst, Lean.Parser.longestMatchFnAux, Prod.snd],[Lean.Parser.ParserFn]]
[Nat.pos_pow_of_pos,[Nat.pow_le_pow_of_le_right, Nat.zero_le],[LT.lt, OfNat.ofNat, HPow.hPow]]
[Std.PersistentArray.findSomeRevM?,[Bind.bind, Array.findSomeRevM?, Std.PersistentArray.tail, Unit.unit, Option, Std.PersistentArray.findSomeRevMAux, Std.PersistentArray.root, Pure.pure, Option.some],[Option]]
[Lean.Meta.CheckAssignment.Context.noConfusionType,[],[]]
[Lean.Meta.Match.Pattern.val.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Pattern.val, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.Pattern.val]]
[Lean.SimpleScopedEnvExtension,[Lean.ScopedEnvExtension],[]]
[Lean.Elab.logInfo,[Lean.Elab.log, Lean.MessageSeverity.information],[Unit]]
[prioHigh,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.mkSimpleThunk,[Lean.mkLambda, Lean.Name.mkStr, Lean.Name.anonymous, Lean.BinderInfo.default, Lean.mkConst, List.nil],[Lean.Expr]]
[Lean.Parser.Term.doNested.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.doSeq.formatter],[Lean.PrettyPrinter.Formatter]]
[instReprAtomUInt64,[ReprAtom.mk],[ReprAtom, UInt64]]
[Lean.Meta.SizeOfSpecNested.Context.recMap,[],[Lean.NameMap, Lean.Name]]
[Lean.QuotVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.QuotVal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.QuotVal.mk, And]]
[HAndThen.noConfusionType,[],[]]
[Lean.Compiler.unreachableExpr,[Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.Expr]]
[Subarray.any,[Id.run, Subarray.anyM],[Bool]]
[Lean.TheoremVal.mk.inj,[And.intro],[And, Eq]]
[ForIn.noConfusionType,[],[]]
[Std.ShareCommon.ObjectMap.find?,[Std.HashMap.find?],[Option, Std.ShareCommon.Object]]
[Lean.Elab.Tactic.evalInduction.checkTargets,[Bind.bind, ForIn.forIn, PUnit.unit, Pure.pure],[Lean.Meta.MetaM, Unit]]
[Lean.Parser.Term.optEllipsis.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.optional.formatter, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.forallTelescopeReducing,[Lean.Meta.map2MetaM, Option.none],[]]
[Lean.Parser.Tactic.Conv.normNum,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg],[Lean.ParserDescr]]
[Lean.LocalContext.mkForall,[Lean.LocalContext.mkBinding, Bool.false],[Lean.Expr]]
[Lean.Parser.Term.sufficesDecl.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.optIdent.formatter, Lean.Parser.termParser.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.fromTerm.formatter, Lean.Parser.Term.byTactic.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Tactic.Conv.convSeq1Indented,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Parsec.many,[Lean.Parsec.manyCore, List.toArray, List.nil],[Lean.Parsec, Array]]
[Lean.Elab.Frontend.FrontendM,[ReaderT, Lean.Elab.Frontend.Context, StateRefT', IO.RealWorld, Lean.Elab.Frontend.State, IO],[]]
[Lean.mkApp4,[Lean.mkAppB],[Lean.Expr]]
[Nat.le_sub_iff_add_le,[Eq.mpr, Eq.refl, Iff, LE.le, HSub.hSub, HAdd.hAdd, Eq.symm, Nat.add_sub_cancel, propext, Nat.sub_le_sub_right_iff, Iff.rfl],[Iff, LE.le, HSub.hSub, HAdd.hAdd]]
[Lean.MVarId.mk.injEq,[Eq.propIntro, Eq.refl, Lean.MVarId.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MVarId.mk]]
[Lean.IR.ExplicitRC.Context.noConfusionType,[],[]]
[Lean.Meta.Config.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Config.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Closure.MkValueTypeClosureResult.levelArgs,[],[Array, Lean.Level]]
[MonadWithReaderOf.withReader,[],[]]
[Lean.Parser.Term.byTactic.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Tactic.tacticSeq.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.IR.Expr.pap.inj,[And.intro],[And, Eq]]
[Lean.Parser.checkColGt,[Lean.Parser.Parser.mk, Lean.Parser.checkColGtFn],[Lean.Parser.Parser]]
[Lean.Expr.toHeadIndex,[Unit.unit, Lean.HeadIndex, Lean.Expr.bvar, Option, Option.some, Lean.HeadIndex.mvar, Lean.HeadIndex.fvar, Lean.HeadIndex.const, Lean.HeadIndex.proj, Lean.HeadIndex.sort, Lean.HeadIndex.lam, Lean.HeadIndex.forallE, Lean.HeadIndex.lit, PProd.fst, PProd.snd, Option.none],[Lean.HeadIndex]]
[Lean.ExternEntry.inline.inj,[And.intro],[And, Eq]]
[Lean.Meta.RecursorUnivLevelPos.majorType.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.RecursorUnivLevelPos.majorType, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.RecursorUnivLevelPos.majorType]]
[Lean.Meta.SimpEntry.lemma.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.SimpEntry.lemma, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SimpEntry.lemma]]
[Lean.PrettyPrinter.ParenthesizerM.orElse,[Bind.bind, MonadState.get, Lean.catchInternalId, Lean.PrettyPrinter.backtrackExceptionId, MonadStateOf.set, Unit.unit],[Lean.PrettyPrinter.ParenthesizerM]]
[Lean.Meta.SynthInstance.TableEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SynthInstance.TableEntry.mk, HAdd.hAdd, OfNat.ofNat]]
[Or.by_cases,[dite, False.elim, Or.elim],[]]
[PProd.fst,[],[]]
[Lean.PrettyPrinter.Formatter.withoutInfo.formatter,[],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.ReduceEval.noConfusionType,[],[]]
[Lean.Elab.Term.ElabAppArgs.State.mk.inj,[And.intro],[And, Eq]]
[Lean.PrettyPrinter.Delaborator.isStructureInstance,[Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.Meta.MetaM, Bool, Lean.Expr.isConstructorApp?, Pure.pure, Lean.isStructure, Lean.ConstructorVal.induct, Bool.false],[Lean.Meta.MetaM, Bool]]
[FloatArray.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, FloatArray.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.Diagnostic,[Lean.Lsp.DiagnosticWith, String],[]]
[Lean.Parser.Tactic.rwModCast,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[instSubsingletonEmpty,[instSubsingletonEmpty.proof_1],[Subsingleton, Empty]]
[Lean.Meta.applySimpResultToTarget,[Unit.unit, Lean.Meta.MetaM, Lean.MVarId, Lean.Meta.Simp.Result.proof?, Lean.Meta.replaceTargetEq, Lean.Meta.Simp.Result.expr, ite, Eq, bne, Bool.true, Lean.Meta.replaceTargetDefEq, Pure.pure],[Lean.Meta.MetaM, Lean.MVarId]]
[and_false,[propext, Iff.intro, And.right, False.elim],[Eq, And, False]]
[Lean.instQuoteProd,[Lean.Quote.mk, Lean.Syntax, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Quote.quote, List.nil],[Lean.Quote, Prod]]
[Lean.Parser.Term.fun.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.maxPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.unicodeSymbol.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.basicFun.formatter, Lean.Parser.Term.matchAlts.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[HAdd.hAdd,[],[]]
[Lean.Parser.Term.strictImplicitBinder.parenthesizer,[Lean.Parser.ppGroup.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.strictImplicitLeftBracket.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.Parser.Term.binderType.parenthesizer, Lean.Parser.Term.strictImplicitRightBracket.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.stringToMessageData,[Lean.MessageData.joinSep, Lean.MessageData.ofFormat, Std.Format.line],[Lean.MessageData]]
[Lean.Meta.Instances.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Instances.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Instances.mk, And]]
[instDecidableLt_2,[UInt16.decLt],[Decidable, LT.lt]]
[UInt16.instRingUInt16.proof_3,[congrArg, UInt16.mk, Ring.gsmul_succ', UInt16.val],[Eq, UInt16.mk, Ring.gsmul, Int.ofNat, Nat.succ, UInt16.val]]
[List.filterMapM,[List.reverse, List.nil, List.filterMapM.loop],[List]]
[Lean.getProjFnForField?,[Option.none, Option, Lean.Name, Lean.getFieldInfo?, Option.some, Lean.StructureFieldInfo.projFn],[Option, Lean.Name]]
[Lean.IR.addDeclAux,[Lean.PersistentEnvExtension.addEntry, Lean.IR.declMapExt],[Lean.Environment]]
[Lean.Parser.Command.elabArg,[Lean.Parser.Command.macroArg],[Lean.Parser.Parser]]
[Std.Rbcolor.red.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Std.Rbcolor.red, OfNat.ofNat]]
[Lean.Parsec.ParseResult.error.inj,[And.intro],[And, Eq]]
[Lean.Server.FileWorker.instBEqReference,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Server.FileWorker.Reference]]
[Lean.Option.«commandRegister_builtin_option__:_:=_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Command.notationItem.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.ppSpace.formatter, Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.strLit.formatter, Lean.Parser.Command.identPrec.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer,[Bind.bind, Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.PrettyPrinter.Parenthesizer.addPrecCheck, modify, Lean.PrettyPrinter.Parenthesizer.State.mk, Lean.PrettyPrinter.Parenthesizer.State.stxTrav, Option.some, Nat.min, HSub.hSub, Lean.Parser.maxPrec, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.State.contCat, Lean.PrettyPrinter.Parenthesizer.State.minPrec, Lean.PrettyPrinter.Parenthesizer.State.trailPrec, Lean.PrettyPrinter.Parenthesizer.State.trailCat, Lean.PrettyPrinter.Parenthesizer.State.visitedToken],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Export.exportLevel,[Bind.bind, MonadState.get, Unit.unit, Lean.ExportM, Nat, Std.HashMap.find?, Lean.Export.Alloc.map, Lean.Export.State.levels, Pure.pure, OfNat.ofNat, Lean.Export.alloc, PProd.fst, liftM, IO.println, HAppend.hAppend, ToString.toString, PProd.snd, Lean.Export.exportName, panicWithPosWithDecl],[Lean.ExportM, Nat]]
[USize.instRingUSize.proof_1,[congrArg, USize.mk, Ring.sub_eq_add_neg, USize.val],[Eq, USize.mk]]
[Lean.MetavarContext.MkBinding.State.ngen,[],[Lean.NameGenerator]]
[coeOfHeafOfTCOfTail,[CoeHTCT.mk, coeTail, coeTC, coeHead],[CoeHTCT]]
[Lean.mkBoolDataValueEx,[Lean.DataValue.ofBool],[Lean.DataValue]]
[Lean.KernelException.appTypeMismatch.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KernelException.appTypeMismatch, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.syntax.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.docComment.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optPrecedence.formatter, Lean.Parser.Command.optNamedName.formatter, Lean.Parser.Command.optNamedPrio.formatter, Lean.Parser.many1.formatter, Lean.Parser.syntaxParser.formatter, Lean.Parser.argPrec, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.MessageData.instCoeStringMessageData,[Coe.mk, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format],[Coe, String, Lean.MessageData]]
[instInhabitedArrow_1,[Inhabited.mk, Pure.pure],[Inhabited]]
[Lean.Meta.forallTelescopeCompatibleAux,[Lean.Meta.MetaM, Bind.bind, Lean.Meta.whnf, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, ite, Eq, BEq.beq, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM]]
[Lean.Parser.Term.scientific,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.scientificLit],[Lean.Parser.Parser]]
[Lean.ReducibilityHints.lt,[Lean.ReducibilityHints.opaque, Unit.unit, Lean.ReducibilityHints.regular, Lean.ReducibilityHints.abbrev, Bool, Bool.false, Bool.true, Decidable.decide, LT.lt],[Bool]]
[Lean.Parser.ParserExtension.Entry.noConfusionType,[],[]]
[Lean.IR.UnreachableBranches.instInhabitedValue,[Inhabited.mk, Lean.IR.UnreachableBranches.Value.bot],[Inhabited, Lean.IR.UnreachableBranches.Value]]
[StateM,[StateT, Id],[]]
[peirce',[id],[]]
[instMulFloat,[Mul.mk, Float.mul],[Mul, Float]]
[Lean.Compiler.atMostOnce.Visitor,[Lean.Compiler.atMostOnce.AtMostOnceData],[]]
[Lean.Elab.Term.MutualClosure.FixPoint.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.MutualClosure.FixPoint.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.PersistentEnvExtensionState.state,[],[]]
[true_and,[propext, Iff.intro, And.right, And.intro, trivial],[Eq, And, True]]
[Lean.Meta.instBEqSimpLemma,[BEq.mk, BEq.beq, Lean.Meta.SimpLemma.proof],[BEq, Lean.Meta.SimpLemma]]
[Lean.Parser.Tactic.rcasesPat.paren,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.Parser.Tactic.rcasesPatLo],[Lean.ParserDescr]]
[Lean.Expr.ReplaceImpl.State.keys,[],[Array, Lean.Expr]]
[List.append_ne_nil_of_left_ne_nil,[of_eq_true, Eq.trans, ne_eq, HAppend.hAppend, List.nil, congrArg, Not, propext, List.append_eq_nil, congrFun, And, eq_false, Eq, false_and, eq_true_of_decide, Eq.refl, Bool.true],[Ne, HAppend.hAppend, List.nil]]
[Lean.Parser.Command.optDeclSig.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.many.formatter, Lean.ppSpace.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.simpleBinderWithoutType.formatter, Lean.Parser.Term.bracketedBinder.formatter, Bool.false, Lean.Parser.Term.optType.formatter],[Lean.PrettyPrinter.Formatter]]
[getThe,[MonadStateOf.get],[]]
[Lean.StructureInfo.fieldNames,[],[Array, Lean.Name]]
[Lean.Elab.Deriving.BEq.mkBEqHeader,[Lean.Elab.Deriving.mkHeader, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat],[Lean.Elab.Term.TermElabM, Lean.Elab.Deriving.Header]]
[Nat.coprime.gcd_mul_right_cancel,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.mul_comm, Nat.coprime.gcd_mul_left_cancel, rfl],[Eq, Nat.gcd, HMul.hMul]]
[IO.Process.Child.stdout,[],[IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdout]]
[Std.HashMapImp.foldM,[Std.HashMapImp.foldBucketsM, Std.HashMapImp.buckets],[]]
[Lean.IR.EmitC.isIf,[ite, Eq, bne, Array.size, OfNat.ofNat, Bool.true, Option.none, Lean.IR.AltCore.default, Option, Prod, Nat, Lean.IR.FnBody, Array.getOp, Option.some, Prod.mk, Lean.IR.CtorInfo.cidx, Lean.IR.AltCore.body],[Option, Prod, Nat, Lean.IR.FnBody]]
[Lean.Xml.Parser.EntityDef,[HOrElse.hOrElse, SeqRight.seqRight, Lean.Xml.Parser.EntityValue, Pure.pure, Unit.unit, SeqLeft.seqLeft, Lean.Xml.Parser.ExternalID, optional, Lean.Xml.Parser.NDataDecl],[Lean.Parsec, Unit]]
[Lean.addProtected,[Lean.TagDeclarationExtension.tag, Lean.protectedExt],[Lean.Environment]]
[UInt16.instSemiringUInt16.proof_7,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt16.one_def, UInt16.mul_def, UInt16.mk, OfNat.ofNat, one_mul, UInt16.val, UInt16.mk_val_eq, eq_self, propext, forall_const, UInt16],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Meta.replaceTargetEq,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarTag, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.getMVarType, Lean.Meta.getLevel, Lean.Meta.mkEq, Lean.Meta.mkExpectedTypeHint, Lean.Meta.assignExprMVar, Pure.pure, Lean.Expr.mvarId!],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.IR.FnBody.sset.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.FnBody.sset, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.instInhabitedPosition,[Inhabited.mk, Lean.Lsp.Position.mk, arbitrary],[Inhabited, Lean.Lsp.Position]]
[Lean.Meta.mkSmartUnfoldingNameFor,[Lean.Name.mkStr, Lean.Meta.smartUnfoldingSuffix],[Lean.Name]]
[Lean.Expr.isMVar,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Server.Watchdog.startFileWorker,[Bind.bind, MonadReader.read, liftM, Lean.Server.publishProgressAtPos, OfNat.ofNat, Lean.Server.Watchdog.ServerContext.hOut, Lean.Parser.parseHeader, IO, Lean.Syntax, Pure.pure, Lean.FileMap.source, Lean.Server.DocumentMeta.text, IO.Process.spawn, IO.Process.SpawnArgs.mk, Lean.Server.Watchdog.workerCfg, System.FilePath.toString, Lean.Server.Watchdog.ServerContext.workerPath, HAppend.hAppend, List.toArray, List.cons, List.nil, Lean.Server.Watchdog.ServerContext.args, IO.mkRef, Std.RBMap.empty, Option.none, IO.asTask, Task.Priority.dedicated, Task.map, Lean.Server.Watchdog.WorkerEvent, Lean.Server.Watchdog.WorkerEvent.ioError, Task.Priority.default, IO.FS.Stream.writeLspRequest, Lean.Server.Watchdog.FileWorker.stdin, Lean.JsonRpc.Request.mk, Lean.Server.Watchdog.ServerContext.initParams, IO.FS.Stream.writeLspNotification, Lean.JsonRpc.Notification.mk, Lean.Lsp.DidOpenTextDocumentParams.mk, Lean.Lsp.TextDocumentItem.mk, Lean.Server.DocumentMeta.uri, Lean.Server.DocumentMeta.version, Lean.Server.Watchdog.updateFileWorkers],[Lean.Server.Watchdog.ServerM, Unit]]
[Lean.Lsp.instToJsonTextDocumentSyncOptions,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentSyncOptions.openClose, List.nil, Lean.Lsp.TextDocumentSyncOptions.change, Lean.Lsp.TextDocumentSyncOptions.willSave, Lean.Lsp.TextDocumentSyncOptions.willSaveWaitUntil, Lean.Json.opt, Lean.Lsp.TextDocumentSyncOptions.save?],[Lean.ToJson, Lean.Lsp.TextDocumentSyncOptions]]
[Lean.Parser.Tactic.Conv.whnf,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Meta.SimpAll.State.entries,[],[Array, Lean.Meta.SimpAll.Entry]]
[Lean.Meta.SizeOfSpecNested.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SizeOfSpecNested.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SizeOfSpecNested.Context.mk, And]]
[Lean.Meta.findLocalDecl?,[Bind.bind, Lean.MonadLCtx.getLCtx, Pure.pure, Lean.LocalContext.find?],[Lean.Meta.MetaM, Option, Lean.LocalDecl]]
[Lean.MonadStateCacheT.instMonadControlMonadStateCacheT,[inferInstanceAs, MonadControl, StateT, Std.HashMap],[MonadControl, Lean.MonadStateCacheT]]
[List.getLast.proof_1,[rfl],[Eq, List.nil]]
[Lean.LocalDecl.setIndex,[Lean.LocalDecl, Lean.LocalDecl.cdecl, Lean.LocalDecl.ldecl],[Lean.LocalDecl]]
[Except.ok.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Except.ok, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.LiveVarSet,[Lean.IR.VarIdSet],[]]
[Lean.Parser.ParserAttributeHook.mk.inj,[],[Eq]]
[instAddSemigroupFin,[AddSemigroup.mk, instAddSemigroupFin.proof_1],[AddSemigroup, Fin]]
[Lean.MessageLog.empty,[Lean.MessageLog.mk, Std.PersistentArray.mk],[Lean.MessageLog]]
[Id.instLawfulMonadId,[Id.instLawfulMonadId.proof_1],[LawfulMonad, Id]]
[Lean.Syntax.MonadTraverser.goUp,[modify, Lean.Syntax.Traverser.up],[Unit]]
[Lean.Elab.Term.MVarErrorKind.custom.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.MVarErrorKind.custom, HAdd.hAdd, OfNat.ofNat]]
[instOrOpUInt32,[OrOp.mk, UInt32.lor],[OrOp, UInt32]]
[Lean.Elab.Command.StructView.params,[],[Array, Lean.Expr]]
[Nat.coprime.pow,[Nat.coprime.pow_right, Nat.coprime.pow_left],[Nat.coprime, HPow.hPow]]
[Function.left_inverse.comp,[],[Function.left_inverse, Function.comp]]
[Lean.Lsp.TextDocumentSyncOptions.willSaveWaitUntil,[],[Bool]]
[Lean.NameSanitizerState.mk.inj,[And.intro],[And, Eq]]
[Std.HashMapImp.foldBucketsM,[Array.foldlM, Std.AssocList.foldlM, Subtype.val, OfNat.ofNat, Array.size],[]]
[Lean.DataValue.ofName.inj,[],[Eq]]
[Lean.Elab.tryURefl,[Lean.MonadWithOptions.withOptions, Lean.Option.set, Lean.Meta.smartUnfolding, Bool.false, Bind.bind, MonadExcept.tryCatch, Lean.Meta.applyRefl, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Pure.pure, Bool.true],[Lean.Meta.MetaM, Bool]]
[Std.PersistentArray.shift,[],[USize]]
[Nat.eq_or_lt_of_le,[Or, Eq, LT.lt, Or.inl, rfl, Or.inr, Nat.succ_le_succ, Nat.zero_le, absurd, Nat.not_succ_le_zero],[Or, Eq, LT.lt]]
[Lean.Elab.DefView.value,[],[Lean.Syntax]]
[Lean.Elab.Tactic.withTacticInfoContext,[Bind.bind, Lean.Elab.Tactic.mkInitialTacticInfo, Lean.Elab.withInfoContext],[Lean.Elab.Tactic.TacticM]]
[ofNat_pow,[Eq.mpr, Eq.refl, Eq, Numeric.ofNat, HPow.hPow, Nat.zero, pow_zero, OfNat.ofNat, Nat.pow_zero, rfl, Nat.succ, pow_succ, HMul.hMul, Nat.pow_succ, ofNat_mul],[Eq, Numeric.ofNat, HPow.hPow]]
[Lean.MessageData.ofExpr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MessageData.ofExpr, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.addHintTactic,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Tactic.tacticSeq.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Tactic.tacticSeqBracketed.formatter, Lean.Parser.Tactic.tacticSeq1Indented.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.CaseValueSubgoal.mvarId,[],[Lean.MVarId]]
[Std.RBNode.node.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.RBNode.node, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.RBNode.node, And, HEq]]
[Lean.Meta.setMCtx,[modify, Lean.Meta.State.mk, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed],[Lean.Meta.MetaM, Unit]]
[instShiftRightUInt64,[ShiftRight.mk, UInt64.shiftRight],[ShiftRight, UInt64]]
[Lean.MonadCacheT.instMonadMonadCacheT,[inferInstanceAs, Monad, StateRefT', Std.HashMap],[Monad, Lean.MonadCacheT]]
[Lean.Json.getObj?,[Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Lean.Json.arr, Except, String, Std.RBNode, Lean.Json, Pure.pure, MonadExcept.throw],[Except, String, Std.RBNode, Lean.Json]]
[FloatSpec.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, FloatSpec.mk, Eq.symm, eq_of_heq, DecidableRel, HEq.refl],[Eq, FloatSpec.mk, And, HEq]]
[Lean.Elab.Term.Do.Code.joinpoint.inj,[And.intro],[And, Eq]]
[Lean.Elab.Tactic.saveState,[Bind.bind, liftM, Lean.Elab.Term.saveState, MonadState.get, Pure.pure, Lean.Elab.Tactic.SavedState.mk],[Lean.Elab.Tactic.TacticM, Lean.Elab.Tactic.SavedState]]
[instHSub,[HSub.mk, Sub.sub],[HSub]]
[One.one,[],[]]
[UInt8.toChar.proof_1,[UInt8.toChar_aux, Fin.val, UInt8.val, Fin.isLt],[Nat.isValidChar, Fin.val, UInt32.val, UInt32.ofNat, UInt8.val]]
[Lean.Elab.Term.Do.eraseVars,[Array.foldl, Std.RBTree.erase, OfNat.ofNat, Array.size],[Lean.NameSet]]
[Lean.Elab.Term.Do.ToTerm.run,[Bind.bind, Lean.Elab.Term.Do.ToTerm.toTerm, Lean.Elab.Term.Do.ToTerm.Context.mk, Pure.pure],[Lean.MacroM, Lean.Syntax]]
[Std.ShareCommon.mkObjectPersistentMap,[Std.PersistentHashMap.empty],[Std.ShareCommon.ObjectPersistentMap]]
[Lean.Parser.Command.notation.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optPrecedence.formatter, Lean.Parser.Command.optNamedName.formatter, Lean.Parser.Command.optNamedPrio.formatter, Lean.Parser.many.formatter, Lean.Parser.Command.notationItem.formatter, Lean.Parser.darrow.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[UInt16.decEq.proof_2,[absurd],[False]]
[Lean.Parser.precedenceParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.SynthInstance.ConsumerNode.subgoals,[],[List, Lean.Expr]]
[ExceptT.instMonadFunctorExceptT,[MonadFunctor.mk, Except],[MonadFunctor, ExceptT]]
[Lean.instInhabitedOption,[Inhabited.mk, Lean.Option.mk, arbitrary],[Inhabited, Lean.Option]]
[Lean.Parser.Command.structCtor.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Command.declModifiers.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.inferMod.parenthesizer, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.registerScopedEnvExtensionUnsafe,[Bind.bind, Lean.registerPersistentEnvExtension, Lean.PersistentEnvExtensionDescr.mk, Lean.ScopedEnvExtension.Descr.name, Lean.ScopedEnvExtension.mkInitial, Lean.ScopedEnvExtension.addImportedFn, Lean.ScopedEnvExtension.addEntryFn, Lean.ScopedEnvExtension.exportEntriesFn, HAppend.hAppend, Std.ToFormat.format, List.length, Lean.ScopedEnvExtension.StateStack.newEntries, ST.Ref.modify, Lean.scopedEnvExtensionsRef, Array.push, unsafeCast, Pure.pure],[IO, Lean.ScopedEnvExtension]]
[Decidable.not_or_iff_and_not,[Iff.intro, And, Not, False.elim, Or.inl, Or.inr, And.intro, False, Or.elim],[Iff, Not, Or, And]]
[Lean.InductiveVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.InductiveVal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.InductiveVal.mk, And]]
[leOfOrd,[LE.mk, Eq, Ordering.isLE, Ord.compare, Bool.true],[LE]]
[Nat.lcm_comm,[],[Eq, Nat.lcm]]
[Lean.QuotKind.ind.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.QuotKind.ind, OfNat.ofNat]]
[Lean.Lsp.instToJsonCommand,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.Command.title, List.nil, Lean.Lsp.Command.command, Lean.Json.opt, Lean.Lsp.Command.arguments?],[Lean.ToJson, Lean.Lsp.Command]]
[Std.PersistentHashMap.size,[],[Nat]]
[WellFoundedRelation.mk.injEq,[Eq.propIntro, Eq.refl, WellFoundedRelation.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, WellFoundedRelation.mk]]
[Lean.Elab.Term.LValResolution.projIdx.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LValResolution.projIdx, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.LValResolution.projIdx, And]]
[Lean.Lsp.InitializeParams.initializationOptions?,[],[Option, Lean.Lsp.InitializationOptions]]
[Lean.NameGenerator.mkChild,[Prod.mk, Lean.NameGenerator.mk, Lean.Name.mkNum, Lean.NameGenerator.namePrefix, Lean.NameGenerator.idx, OfNat.ofNat, HAdd.hAdd],[Prod, Lean.NameGenerator]]
[Lean.IR.EmitC.emitExternCall,[Option.none, Option.some, Lean.ExternEntry.adhoc, Lean.IR.EmitC.M, Unit, Lean.getExternEntryFor, Lean.Name.mkStr, Lean.Name.anonymous, Lean.IR.EmitC.emitSimpleExternalCall, Bind.bind, Lean.IR.EmitC.emit, Lean.expandExternPattern, Lean.IR.EmitC.toStringArgs, Lean.IR.EmitC.emitLn, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.IR.EmitC.M, Unit]]
[List.ball_nil,[False.elim],[]]
[Lean.Meta.Match.MatcherInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.InductionSubgoal.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.darrow.parenthesizer,[Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Command.ElabHeaderResult.localInsts,[],[Lean.LocalInstances]]
[Lean.Parser.Tactic.eConstructor,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[List.eq_nil_iff_forall_not_mem,[],[Iff, Eq, List.nil, Not, Mem.mem]]
[Lean.Parser.Term.doNested.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Term.do.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.argPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.doSeq.formatter],[Lean.PrettyPrinter.Formatter]]
[List.le,[Not, LT.lt],[]]
[Lean.instToMessageDataList,[Lean.ToMessageData.mk, Lean.MessageData.ofList, List.map, Lean.ToMessageData.toMessageData],[Lean.ToMessageData, List]]
[Lean.Parser.Tactic.unitInterval,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.PrettyPrinter.Delaborator.SubExpr.noConfusionType,[],[]]
[Lean.MonadCacheT.instMonadHashMapCacheAdapterMonadCacheT,[Lean.MonadHashMapCacheAdapter.mk, MonadState.get, modify],[Lean.MonadHashMapCacheAdapter, Lean.MonadCacheT]]
[ExceptCpsT.runCatch_throw,[rfl],[Eq, ExceptCpsT.runCatch, MonadExcept.throw, Pure.pure]]
[UInt8.instNegUInt8,[Neg.mk, UInt8.mk, Neg.neg, UInt8.val],[Neg, UInt8]]
[Lean.Lsp.LocationLink.noConfusionType,[],[]]
[Lean.IR.ExplicitBoxing.withVDecl,[MonadWithReader.withReader, Lean.IR.ExplicitBoxing.BoxingContext.mk, Lean.IR.ExplicitBoxing.BoxingContext.f, Lean.IR.LocalContext.addLocal, Lean.IR.ExplicitBoxing.BoxingContext.localCtx, Lean.IR.ExplicitBoxing.BoxingContext.resultType, Lean.IR.ExplicitBoxing.BoxingContext.decls, Lean.IR.ExplicitBoxing.BoxingContext.env],[Lean.IR.ExplicitBoxing.M]]
[Ne.irrefl,[rfl],[False]]
[HEq.elim,[eq_of_heq],[]]
[List.isPrefix,[Exists, Eq, HAppend.hAppend],[]]
[Lean.Name.num.inj,[And.intro],[And, Eq]]
[Lean.Lsp.CompletionParams.toTextDocumentPositionParams,[],[Lean.Lsp.TextDocumentPositionParams]]
[Lean.Parser.Tactic.induction',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.casesTarget, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.binderIdent],[Lean.ParserDescr]]
[Std.PersistentHashMap.instInhabitedPersistentHashMap,[Inhabited.mk, Std.PersistentHashMap.mk],[Inhabited, Std.PersistentHashMap]]
[Lean.Elab.Command.ElabStructResult.mctx,[],[Lean.MetavarContext]]
[Lean.Parser.Term.elseIf.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.group.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkLineEq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Functor.map_equiv,[Equiv.mk, Functor.map, Equiv.toFun, Equiv.symm, Functor.map_equiv.proof_1, Functor.map_equiv.proof_2],[Equiv]]
[Lean.Expr.letE.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.letE, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Expr.letE, And]]
[Lean.Meta.withLocalDecl,[Lean.Meta.map1MetaM, Bind.bind, Lean.mkFreshFVarId, MonadReader.read, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.localInstances, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth, Lean.Meta.isClass?, Unit.unit, Lean.Meta.MetaM, Lean.Meta.withNewLocalInstance],[]]
[Lean.Meta.isExprDefEq,[Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.lctx, Lean.Meta.Context.localInstances, Option.some, Lean.Meta.DefEqContext.mk, Lean.Meta.Context.synthPendingDepth, Bind.bind, Lean.Meta.checkpointDefEq, Lean.Meta.isExprDefEqAux, Bool.true, Lean.isTracingEnabledFor, ite, Eq, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Bool]]
[ExceptCpsT.runCatch_bind_lift,[rfl],[Eq, ExceptCpsT.runCatch, Bind.bind, ExceptCpsT.lift]]
[Lean.Compiler.instInhabitedSpecEntry,[Inhabited.mk, Lean.Compiler.SpecEntry.info, arbitrary],[Inhabited, Lean.Compiler.SpecEntry]]
[Lean.Parser.Tactic.cases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.casesTarget, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlts],[Lean.ParserDescr]]
[Lean.Elab.Command.MkInstanceName.main,[Bind.bind, Lean.Elab.liftMacroM, Lean.expandMacros, StateRefT'.run, Lean.Elab.Command.MkInstanceName.collect, Lean.Elab.Command.CommandElabM, Lean.Name, ite, Eq, String.isEmpty, Bool.true, Lean.Elab.Command.MkInstanceName.mkFreshInstanceName, Lean.Elab.mkUnusedBaseName, Lean.Name.mkSimple, HAppend.hAppend],[Lean.Elab.Command.CommandElabM, Lean.Name]]
[List.disjoint_of_disjoint_cons_right,[List.disjoint_of_subset_right, List.subset_cons],[List.disjoint]]
[Lean.Widget.InteractiveDiagnostic.toDiagnostic,[Lean.Lsp.DiagnosticWith.mk, Lean.Lsp.DiagnosticWith.range, Lean.Lsp.DiagnosticWith.fullRange, Lean.Lsp.DiagnosticWith.severity?, Lean.Lsp.DiagnosticWith.code?, Lean.Lsp.DiagnosticWith.source?, Lean.Lsp.DiagnosticWith.message, Lean.Lsp.DiagnosticWith.tags?, Lean.Lsp.DiagnosticWith.relatedInformation?, Lean.Widget.InteractiveDiagnostic.toDiagnostic.prettyTt],[Lean.Lsp.Diagnostic]]
[Std.PersistentHashMap.Entry.entry.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.squeezeDSimp?!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Elab.mkAttrKindGlobal,[Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkNullNode, List.nil],[Lean.Syntax]]
[Lean.KernelException.declHasFVars.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.declHasFVars, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KernelException.declHasFVars, And]]
[Lean.Elab.Tactic.ElimApp.Result.mk.inj,[And.intro],[And, Eq]]
[Array.«term__[:_]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Parser.Command.reduce.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.PersistentEnvExtensionDescr.addEntryFn,[],[]]
[Lean.Meta.Match.Example.ctor.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.Example.ctor, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.Example.ctor, And]]
[Lean.Meta.ElimAltInfo.mk.inj,[And.intro],[And, Eq]]
[UInt64.mul,[UInt64.mk, HMul.hMul, UInt64.val],[UInt64]]
[Lean.nullKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Lean.Meta.RecursorInfo.numMinors,[HSub.hSub, HAdd.hAdd, Lean.Meta.RecursorInfo.majorPos, OfNat.ofNat, Lean.Meta.RecursorInfo.firstIndexPos],[Nat]]
[Lean.Meta.Match.Problem.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.Problem.mk, HAdd.hAdd, OfNat.ofNat]]
[UInt8.instSemigroupUInt8.proof_1,[congrArg, UInt8.mk, Semigroup.mul_assoc, UInt8.val],[Eq, UInt8.mk]]
[Lean.Lsp.DocumentHighlightKind.read.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.DocumentHighlightKind.read, OfNat.ofNat]]
[String.intercalate,[Unit.unit, String, String.intercalate.go],[String]]
[Lean.IR.ExplicitRC.Context.jpLiveVarMap,[],[Lean.IR.JPLiveVarMap]]
[Lean.Meta.Match.Extension.State.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Extension.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.Extension.State.mk]]
[Lean.Position.instToFormatPosition,[Std.ToFormat.mk, Std.Format, HAppend.hAppend, Std.Format.text, Std.ToFormat.format],[Std.ToFormat, Lean.Position]]
[Lean.Parser.Tactic.right,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[ST.mkRef,[liftM, ST.Prim.mkRef],[ST.Ref]]
[Lean.Meta.DefaultInstanceEntry.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.TacticInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.TacticInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Function.uncurry_bicompr,[rfl],[Eq, Function.uncurry, Function.bicompr, Function.comp]]
[Lean.Parser.Tactic.introMatch.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.Tactic.matchAlts.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.PrettyPrinter.Parenthesizer.checkNoImmediateColon.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.ScopedEnvExtension.Descr.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.simpa?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[instDecidableLt_5,[LinearOrder.decidable_lt],[Decidable, LT.lt]]
[Lean.Elab.Command.runTermElabM,[Bind.bind, Lean.Elab.Command.getScope, Lean.Elab.Command.liftTermElabM, Lean.Elab.Term.withAutoBoundImplicit, Lean.Elab.Term.elabBinders, Lean.Elab.Command.Scope.varDecls, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Bool.false, ForIn.forIn, MProd.mk, Unit.unit, Lean.Elab.Term.TermElabM, ForInStep, MProd, Subarray, Lean.Expr, Lean.NameMap, Stream.next?, Pure.pure, ForInStep.done, PUnit.unit, ForInStep.yield, MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.Context.declName?, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.currMacroScope, Lean.Elab.Term.Context.mayPostpone, Lean.Elab.Term.Context.errToSorry, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.Term.Context.autoBoundImplicits, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection, Lean.Elab.Term.resetMessageLog, Lean.Elab.Term.addAutoBoundImplicits, Lean.Elab.Term.withoutAutoBoundImplicit],[Lean.Elab.Command.CommandElabM]]
[Nat.eq_zero_of_gcd_eq_zero_right,[Nat.eq_zero_of_gcd_eq_zero_left, Eq.mp, Eq.refl, Eq, Nat.gcd, OfNat.ofNat, Nat.gcd_comm],[Eq, OfNat.ofNat]]
[Std.AssocList.forM,[Unit.unit, PUnit, Pure.pure, PUnit.unit, Bind.bind, PProd.fst],[PUnit]]
[Lean.Lsp.DiagnosticSeverity.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.PrettyPrinter.Delaborator.Context.optionsPerPos,[],[Lean.PrettyPrinter.Delaborator.OptionsPerPos]]
[lt_of_le_of_ne,[lt_of_le_not_le, mt, le_antisymm],[LT.lt]]
[Lean.PrettyPrinter.Formatter.scientificLitNoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.visitAtom, Lean.scientificLitKind],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.containsPendingMVar,[Bind.bind, OptionT.run, Lean.MonadCacheT.run, Lean.Elab.Term.ContainsPendingMVar.visit, Unit.unit, Lean.Elab.Term.TermElabM, Bool, Pure.pure, Bool.false, Bool.true],[Lean.Elab.Term.TermElabM, Bool]]
[Std.PersistentHashSet.noConfusionType,[],[]]
[Lean.Parser.Command.section.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.Simp.tryRewriteUsingDecide,[Bind.bind, MonadReader.read, ite, Eq, Lean.Meta.Simp.Config.decide, Lean.Meta.Simp.Context.config, Bool.true, liftM, Lean.Meta.Simp.rewriteUsingDecide?, Unit.unit, Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step, Pure.pure, Lean.Meta.Simp.Step.done],[Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step]]
[Eq.to_iff,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Iff, Iff.rfl],[Iff]]
[Lean.Meta.CheckAssignment.State.noConfusionType,[],[]]
[Lean.Elab.Tactic.MkSimpContextResult.mk.inj,[And.intro],[And, Eq]]
[AddMonoid.add_zero,[],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.CheckAssignment.throwCheckAssignmentFailure,[MonadExcept.throw, Lean.Exception.internal, Lean.Meta.CheckAssignment.checkAssignmentExceptionId, Lean.KVMap.mk],[Lean.Meta.CheckAssignment.CheckAssignmentM]]
[Lean.Meta.SimpLemmas.post,[],[Lean.Meta.DiscrTree, Lean.Meta.SimpLemma]]
[Lean.Elab.Deriving.FromToJson.mkFromJsonInstanceHandler,[ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.isStructure, Array.getOp, Lean.Elab.Command.liftTermElabM, Option.none, Lean.Elab.Deriving.mkContext, Lean.Elab.Deriving.mkHeader, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.Deriving.Context.typeInfos, Lean.Elab.Deriving.mkInductiveApp, Lean.Elab.Deriving.Header.argNames, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, List.nil, Lean.Syntax.atom, Lean.mkIdent, Lean.Elab.Deriving.Context.auxFunNames, Array.push, Array.append, Lean.Elab.Deriving.Header.binders, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Array.map, Lean.Syntax, Array.zip, Lean.Elab.Deriving.mkInstanceCmds, HAppend.hAppend, Array.forM, Lean.Elab.Command.elabCommand, Lean.getConstInfoInduct, Lean.Elab.Deriving.mkDiscrs, Array.foldrM, Lean.Elab.Deriving.Context.usePartial, Lean.Elab.Deriving.mkLocalInstanceLetDecls, Lean.Elab.Deriving.mkLet, PUnit.unit, Bool.false, Lean.Elab.Deriving.FromToJson.mkFromJsonInstanceHandler.mkAlts],[Lean.Elab.Command.CommandElabM, Bool]]
[Array.foldrM.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure],[]]
[Lean.KernelException.declTypeMismatch.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KernelException.declTypeMismatch, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.SynthInstance.Waiter.consumerNode.inj,[],[Eq]]
[Lean.Parser.leadingNode,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.node, Lean.Parser.setLhsPrec],[Lean.Parser.Parser]]
[Lean.Elab.Modifiers.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Modifiers.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Modifiers.mk, And]]
[Lean.Elab.Term.Do.getLetPatDeclVars,[Lean.Elab.Term.Do.getPatternVarsEx],[Lean.Elab.Term.TermElabM, Array, Lean.Name]]
[Lean.Lsp.LocationLink.targetRange,[],[Lean.Lsp.Range]]
[Lean.SourceInfo.noConfusionType,[],[]]
[instMonadEST,[inferInstanceAs, Monad, EStateM],[Monad, EST]]
[Lean.Parser.Tactic.tauto,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[termWithout_expected_type_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[instBEqProd,[BEq.mk, Bool, and, BEq.beq],[BEq, Prod]]
[Nat.le_or_le,[Or.imp_left, Nat.le_of_lt, Nat.lt_or_ge],[Or, LE.le]]
[Lean.JsonRpc.instBEqResponseError,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.JsonRpc.ResponseError]]
[Lean.PrettyPrinter.Formatter.State.leadWord,[],[String]]
[Lean.AxiomVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.AxiomVal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.AxiomVal.mk, And]]
[Lean.mkLevelIMaxEx,[Lean.mkLevelIMax],[Lean.Level]]
[Lean.OpaqueVal.toConstantVal,[],[Lean.ConstantVal]]
[Lean.MetavarContext.getDecl,[Unit.unit, Lean.MetavarDecl, Std.PersistentHashMap.find?, Lean.MetavarContext.decls, panicWithPosWithDecl, OfNat.ofNat],[Lean.MetavarDecl]]
[UInt8.toChar_aux,[Eq.mpr, Eq.refl, Nat.isValidChar, Fin.val, UInt32.val, UInt32.ofNat, UInt32.val_eq_of_lt, Nat.lt_trans, of_decide_eq_true, Bool.true, Or.inl],[Nat.isValidChar, Fin.val, UInt32.val, UInt32.ofNat]]
[Lean.Parser.Level.imax,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.nonReservedSymbol, Lean.Parser.many1, Lean.Parser.ppSpace, Lean.Parser.levelParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[Lean.Expr.instantiateLevelParams,[Lean.Expr.instantiateLevelParamsCore, List.nil, List.cons, Option, Lean.Level, ite, Eq, BEq.beq, Bool.true, Option.some, PProd.fst, Option.none],[Lean.Expr]]
[Nat.eq_zero_or_pos,[Unit.unit, Or, Eq, OfNat.ofNat, GT.gt, Or.inl, rfl, Or.inr, Nat.succ_pos],[Or, Eq, OfNat.ofNat, GT.gt]]
[List.card_insert_of_mem,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.card, List.insert_of_mem, eq_true, eq_self],[Eq, List.card, List.insert]]
[Lean.Literal.hash,[UInt64, Hashable.hash],[UInt64]]
[Lean.Server.Completion.HoverInfo.noConfusionType,[],[]]
[Lean.JsonNumber.fromNat,[Lean.JsonNumber.mk, Int.ofNat, OfNat.ofNat],[Lean.JsonNumber]]
[Lean.Meta.SimpLemmas.add,[ite, Eq, Lean.Expr.isConst, Bool.true, Lean.Meta.SimpLemmas.addConst, Lean.Expr.constName!, Bind.bind, Lean.Meta.mkSimpLemmas, Pure.pure, Array.foldl, Lean.Meta.addSimpLemmaEntry, OfNat.ofNat, Array.size, Lean.Meta.SimpLemmas.add.getName?],[Lean.Meta.MetaM, Lean.Meta.SimpLemmas]]
[Lean.Lsp.instFromJsonSemanticTokensParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Pure.pure, Lean.Lsp.SemanticTokensParams.mk],[Lean.FromJson, Lean.Lsp.SemanticTokensParams]]
[Lean.ExprMap,[Std.HashMap, Lean.Expr],[]]
[Lean.getPPPrivateNames,[Lean.KVMap.get, Lean.Option.name, Lean.pp.privateNames, Lean.getPPAll],[Bool]]
[List.bind,[List.join, List.map],[List]]
[Lean.Meta.SynthInstance.TableEntry.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.Match.MatchEqns.noConfusionType,[],[]]
[List.erasep_map,[Unit.unit, Eq, List.erasep, List.map, Function.comp, rfl, Classical.em, of_eq_true, Eq.trans, congr, congrArg, List.map_cons, List.erasep_cons_of_pos, eq_true, Function.comp_apply, eq_self, Eq.symm, List.erasep_cons_of_neg, Not, eq_false, eq_true_of_decide, Eq.refl, Bool.true, List.cons, PProd.fst],[Eq, List.erasep, List.map, Function.comp]]
[Nat.not_le,[Iff.intro, Nat.lt_of_not_le, Nat.not_le_of_lt],[Iff, Not, LE.le, LT.lt]]
[Lean.JsonRpc.Message.response.inj,[And.intro],[And, Eq]]
[Lean.Parser.TokenCacheEntry.stopPos,[],[String.Pos]]
[Lean.Parser.Command.structInstBinder.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Command.declModifiers.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.inferMod.formatter, Lean.Parser.Command.declSig.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.instFromJsonTextDocumentContentChangeEvent,[Lean.FromJson.mk, HOrElse.hOrElse, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.Range, String, Pure.pure, Lean.Lsp.TextDocumentContentChangeEvent.rangeChange, Functor.map, Lean.Lsp.TextDocumentContentChangeEvent.fullChange],[Lean.FromJson, Lean.Lsp.TextDocumentContentChangeEvent]]
[List.«term_~_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Macro.Methods.noConfusionType,[],[]]
[Fin.xor.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, Nat.xor]]
[Lean.Widget.MsgEmbed.goal.inj,[],[Eq]]
[Lean.Meta.SimpLemma.perm,[],[Bool]]
[String.join,[List.foldl, HAppend.hAppend],[String]]
[Lean.Meta.RecursorInfo.typeName,[],[Lean.Name]]
[Lean.MessageData.compose.inj,[And.intro],[And, Eq]]
[Lean.Lsp.SemanticTokens.mk.inj,[],[Eq]]
[Lean.ParserCompiler.Context.varName,[],[Lean.Name]]
[Lean.Syntax.isAntiquotSplice,[Option.isSome, Lean.Syntax.antiquotSpliceKind?],[Bool]]
[Nat.ble,[Unit.unit, Bool, Bool.true, Bool.false, PProd.fst],[Bool]]
[Lean.IR.FnBody.collectFreeIndices,[Lean.IR.FreeIndices.collectFnBody, EmptyCollection.emptyCollection],[Lean.IR.IndexSet]]
[Decidable.lt_or_eq_of_le,[dite, LE.le, Or.inr, le_antisymm, Or.inl, lt_of_le_not_le],[Or, LT.lt, Eq]]
[List.append',[List, List.cons, PProd.fst],[List]]
[dif_ctx_congr,[Eq, dite, absurd, Iff.mp, not_iff_not_of_iff, Iff.mpr],[Eq, dite]]
[Nat.zero_sub,[Unit.unit, Eq, HSub.hSub, OfNat.ofNat, rfl, congr_arg, Nat.pred, PProd.fst],[Eq, HSub.hSub, OfNat.ofNat]]
[Lean.Compiler.CSimp.Entry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Compiler.CSimp.Entry.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.sepByNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.sepByInfo, Lean.Parser.Parser.info, Lean.Parser.sepByFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[IO.mkRef,[ST.mkRef],[BaseIO, IO.Ref]]
[Option.filter,[Unit.unit, Option, ite, Eq, Bool.true, Option.some, Option.none],[Option]]
[UInt8.instSemiringUInt8.proof_11,[Eq.mpr, congr, congrArg, Eq, Eq.trans, HMul.hMul, UInt8.add_def, UInt8.mul_def, UInt8.mk, HAdd.hAdd, UInt8.val, UInt8.eq_of_val_eq, Semiring.mul_add],[Eq, HMul.hMul, HAdd.hAdd]]
[Option.some.inj,[],[Eq]]
[Lean.Parser.Tactic.uniqueDiffWithinAt_Ici_Iic_univ,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Meta.withNatValue,[Bind.bind, Lean.Meta.whnf, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Name.anonymous, Lean.Name.str, dite, Eq, Eq.symm, Lean.Name.num, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.strVal, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Option, OfNat.ofNat, Pure.pure, Option.none],[Lean.Meta.MetaM, Option]]
[Lean.Elab.Tactic.SavedState.tactic,[],[Lean.Elab.Tactic.State]]
[Lean.Meta.mkAppOptM',[Bind.bind, Lean.Meta.inferType, Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.withNewMCtxDepth, OfNat.ofNat, List.toArray, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Meta.getResetPostponed,[Bind.bind, Lean.Meta.getPostponed, Lean.Meta.setPostponed, Std.PersistentArray.mk, Pure.pure],[Lean.Meta.MetaM, Std.PersistentArray, Lean.Meta.PostponedEntry]]
[Nat.prod_dvd_and_dvd_of_dvd_prod.proof_3,[Nat.zero_lt_succ, Eq.symm],[LT.lt, OfNat.ofNat, Nat.gcd]]
[Lean.IR.LogEntry.message.injEq,[Eq.propIntro, Eq.refl, Lean.IR.LogEntry.message, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.LogEntry.message]]
[Lean.ScopedEnvExtension.ScopedEntries.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ScopedEnvExtension.ScopedEntries.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.Checker.checkJP,[Bind.bind, MonadReader.read, ite, Eq, Lean.IR.LocalContext.isJP, Lean.IR.Checker.CheckerContext.localCtx, Lean.IR.JoinPointId.idx, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.IR.Checker.M, Unit]]
[Lean.Elab.Term.Do.Code.jmp.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.Code.jmp, HAdd.hAdd, OfNat.ofNat]]
[String.isPrefixOf,[String.substrEq, OfNat.ofNat, String.bsize],[Bool]]
[instDecidableEqOption,[Unit.unit, Decidable, Eq, Decidable.isTrue, rfl, Decidable.isFalse, dite],[DecidableEq, Option]]
[pure_id_seq,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, LawfulApplicative.pure_seq, id, LawfulFunctor.id_map, eq_self],[Eq, Seq.seq, Pure.pure, id]]
[Lean.NameSet.instInhabitedNameSet,[Inhabited.mk, Lean.NameSet.empty],[Inhabited, Lean.NameSet]]
[IO.Error.permissionDenied.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.expandFunBinders,[OfNat.ofNat, List.toArray, List.nil, Lean.Elab.Term.expandFunBinders.loop],[Lean.MacroM, Prod, Array, Lean.Syntax, Bool]]
[Lean.Compiler.SpecState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Compiler.SpecState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Compiler.SpecState.mk, And]]
[Lean.Xml.Element.ibelow,[And, True],[]]
[type_eq_of_heq,[type_eq_of_heq.proof_1],[Eq]]
[Char.utf8Size.proof_7,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[Lean.Widget.MsgEmbed.rpcPacketFor,[],[outParam]]
[Std.PersistentArray.set,[ite, GE.ge, Std.PersistentArray.tailOff, Std.PersistentArray.mk, Std.PersistentArray.root, Array.set!, Std.PersistentArray.tail, HSub.hSub, Std.PersistentArray.size, Std.PersistentArray.shift, Std.PersistentArray.setAux, USize.ofNat],[Std.PersistentArray]]
[Lean.Meta.ApplyNewGoals.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.getPPStructureProjections,[Lean.KVMap.get, Lean.Option.name, Lean.pp.structureProjections, not, Lean.getPPAll],[Bool]]
[Lean.IR.Borrow.updateParamSet,[Lean.IR.Borrow.BorrowInfCtx.mk, Lean.IR.Borrow.BorrowInfCtx.env, Lean.IR.Borrow.BorrowInfCtx.decls, Lean.IR.Borrow.BorrowInfCtx.currFn, Array.foldl, Std.RBTree.insert, Lean.IR.VarId.idx, Lean.IR.Param.x, Lean.IR.Borrow.BorrowInfCtx.paramSet, OfNat.ofNat, Array.size],[Lean.IR.Borrow.BorrowInfCtx]]
[Lean.KVMap.subsetAux,[Bool, Bool.true, Unit.unit, Lean.KVMap.find, and, BEq.beq, PProd.fst, Bool.false],[Bool]]
[Lean.Parser.Term.precheckedQuot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.quot.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.AttributeImplCore.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.AttributeImplCore.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Level.isSucc,[Lean.Level.zero, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Meta.CongrLemma.priority,[],[Nat]]
[instToStringUInt32,[ToString.mk, ToString.toString, UInt32.toNat],[ToString, UInt32]]
[Lean.MacroScopesView.format,[Std.ToFormat.format, ite, Eq, List.isEmpty, Lean.MacroScopesView.scopes, Bool.true, Lean.MacroScopesView.name, BEq.beq, Lean.MacroScopesView.mainModule, List.foldl, Lean.Name.mkNum, HAppend.hAppend, Lean.MacroScopesView.imported],[Std.Format]]
[Lean.PrettyPrinter.Delaborator.Delab,[Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax],[]]
[Lean.Parser.ParserState.setError,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Option.some, Lean.Parser.Error.mk, List.cons, List.nil],[Lean.Parser.ParserState]]
[Nat.le_step,[Nat.le.step],[LE.le, Nat.succ]]
[Lean.Widget.GetInteractiveDiagnosticsParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Widget.GetInteractiveDiagnosticsParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Widget.GetInteractiveDiagnosticsParams.mk]]
[Lean.SCC.State.data,[],[Std.HashMap, Lean.SCC.Data]]
[Lean.Lsp.TextDocumentContentChangeEvent.hasToJson,[Lean.ToJson.mk, Lean.Json.mkObj, List, Prod, String, Lean.Json, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil],[Lean.ToJson, Lean.Lsp.TextDocumentContentChangeEvent]]
[Lean.Parser.Term.doIfLetBind.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.TextDocumentPositionParams.position,[],[Lean.Lsp.Position]]
[Lean.IR.Arg.noConfusionType,[],[]]
[Lean.Parser.Term.doBreak.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Command.bindersItem,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Lsp.instToJsonLocationLink,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Lsp.LocationLink.originSelectionRange?, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.LocationLink.targetUri, List.nil, Lean.Lsp.LocationLink.targetRange, Lean.Lsp.LocationLink.targetSelectionRange],[Lean.ToJson, Lean.Lsp.LocationLink]]
[Lean.MetavarContext.renameMVar,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Std.PersistentHashMap.insert, Lean.MetavarContext.decls, Lean.MetavarDecl.mk, Lean.MetavarDecl.lctx, Lean.MetavarDecl.type, Lean.MetavarDecl.depth, Lean.MetavarDecl.localInstances, Lean.MetavarDecl.kind, Lean.MetavarDecl.numScopeArgs, Lean.MetavarDecl.index, ite, Eq, Lean.Name.isAnonymous, Bool.true, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment],[Lean.MetavarContext]]
[Lean.Parser.Command.inductive.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.Command.optDeclSig.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.many.formatter, Lean.Parser.Command.ctor.formatter, Lean.Parser.Command.optDeriving.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Term.arrayRef.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Ring.gsmul_succ',[],[Eq, Ring.gsmul, Int.ofNat, Nat.succ, HAdd.hAdd]]
[Lean.Elab.Tactic.evalIntroMatch,[Bind.bind, Lean.Elab.liftMacroM, Lean.Elab.Term.expandMatchAltsIntoMatchTactic, Lean.Elab.Tactic.withMacroExpansion, Lean.Elab.Tactic.evalTactic],[Lean.Elab.Tactic.Tactic]]
[Lean.SearchPath,[System.SearchPath],[]]
[Lean.JsonNumber.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.JsonNumber.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.instBEqOccurrences,[BEq.mk, Unit.unit, Lean.Occurrences.all, Lean.Occurrences.pos, Lean.Occurrences.neg, Bool, Bool.true, and, BEq.beq, Bool.false],[BEq, Lean.Occurrences]]
[Lean.ClassEntry.name,[],[Lean.Name]]
[Seq.noConfusionType,[],[]]
[Lean.IR.ExplicitRC.VarInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.ExplicitRC.VarInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.macro.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.suppressInsideQuot.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.docComment.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optPrecedence.formatter, Lean.Parser.Command.optNamedName.formatter, Lean.Parser.Command.optNamedPrio.formatter, Lean.Parser.many1.formatter, Lean.Parser.Command.macroArg.formatter, Lean.Parser.Command.macroTail.formatter],[Lean.PrettyPrinter.Formatter]]
[instStreamSubarray.proof_1,[Nat.succ_le_of_lt],[LE.le, Nat.succ, Subarray.start, Subarray.stop]]
[Lean.ParserCompiler.CombinatorAttribute.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ParserCompiler.CombinatorAttribute.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Name.str.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Name.str, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Name.str, And]]
[forall_not_of_not_exists,[Exists.intro],[Not]]
[Lean.Elab.Modifiers.isNonrec,[Lean.Elab.Modifiers.mk, Lean.Elab.RecKind.partial, Lean.Elab.RecKind.default, Bool, Bool.true, Bool.false],[Bool]]
[String.utf16PosToCodepointPosFrom,[OfNat.ofNat],[Nat]]
[Lean.PrettyPrinter.Parenthesizer.instCoeArrowParenthesizerArrowParenthesizerParenthesizerParenthesizerAliasValue,[Coe.mk, Lean.Parser.AliasValue.binary],[Coe, Lean.PrettyPrinter.Parenthesizer, Lean.PrettyPrinter.Parenthesizer.ParenthesizerAliasValue]]
[not_and_self_iff,[Iff.intro, False, False.elim],[Iff, And, Not, False]]
[Nat.mul_comm,[Eq, HMul.hMul, rfl, Eq.symm, Nat.mul_zero, Nat.zero_mul, PProd.fst, Nat.succ_mul, Nat.mul_succ],[Eq, HMul.hMul]]
[Function.injective.eq_iff,[Iff.intro, congr_arg],[Iff, Eq]]
[Lean.Parser.notFollowedBy,[Lean.Parser.Parser.mk, Lean.Parser.notFollowedByFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.Import.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Import.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.setReducibleAttribute,[Lean.setReducibilityStatus, Lean.ReducibilityStatus.reducible],[Unit]]
[Lean.Option.mk.inj,[And.intro],[And, Eq]]
[EIO.mapTasks,[BaseIO.mapTasks, EIO.toBaseIO],[BaseIO, Task, Except]]
[Lean.Meta.resettingSynthInstanceCache,[Lean.Meta.mapMetaM, Bind.bind, Lean.Meta.saveAndResetSynthInstanceCache, tryFinally, Lean.Meta.restoreSynthInstanceCache],[]]
[Lean.Elab.Term.Quotation.MatchResult.undecided.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Quotation.MatchResult.undecided, OfNat.ofNat]]
[Lean.Expr.updateLambdaE!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateLambda, Lean.Expr.lam, Lean.Expr.Data.binderInfo, Lean.Expr.updateLambdaE!.proof_1, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[ExceptT.instMonadExceptT,[Monad.mk],[Monad, ExceptT]]
[Lean.Elab.Term.Do.Code.below,[PProd, PUnit],[]]
[Lean.term_Matches_,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.instInhabitedMessageSeverity,[Inhabited.mk, Lean.MessageSeverity.information],[Inhabited, Lean.MessageSeverity]]
[Std.RBNode.singleton,[Std.RBNode.node, Std.Rbcolor.red, Std.RBNode.leaf],[Std.RBNode]]
[instDivUInt32,[Div.mk, UInt32.div],[Div, UInt32]]
[Std.PersistentHashMap.getCollisionNodeSize,[Nat, Array.size, False.elim, Std.PersistentHashMap.getCollisionNodeSize.proof_2],[Nat]]
[Lean.Parser.Tactic.tfaeFinish,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Compiler.foldUIntDiv,[Lean.Compiler.foldBinUInt, Div.div],[Option, Lean.Expr]]
[instDecidableEqUSize,[USize.decEq],[DecidableEq, USize]]
[Lean.Parser.ParserInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.ParserInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Command.accLevelAtCtor,[Lean.Level.succ, Nat.zero, Lean.Level.param, Lean.Level.mvar, Lean.Elab.Term.TermElabM, Array, Lean.Level, Bind.bind, PProd.fst, PProd.snd, Pure.pure, ite, Eq, and, BEq.beq, OfNat.ofNat, Bool.true, Lean.Level.occurs, Lean.throwError, Lean.ToMessageData.toMessageData, GT.gt, Array.contains, Array.push],[Lean.Elab.Term.TermElabM, Array, Lean.Level]]
[and_comm,[And.comm],[Iff, And]]
[Lean.Elab.Tactic.Conv.evalRhs,[Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Elab.Tactic.Conv.congr, ite, GE.ge, OfNat.ofNat, dite, LT.lt, List.length, ForIn.forIn, Unit.unit, Lean.Elab.Tactic.TacticM, ForInStep, Std.Range, Stream.next?, Pure.pure, ForInStep.done, Eq, bne, Bool.true, Lean.Meta.applyRefl, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, ForInStep.yield, PUnit.unit, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.get, List.nil, HSub.hSub, Int.ofNat],[Lean.Elab.Tactic.Tactic]]
[Lean.MessageData.ibelow,[True, And],[]]
[Lean.Meta.DiscrTree.getMatch,[Lean.Meta.withReducible, Bind.bind, ite, Eq, Bool.true, Lean.Expr.bvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.mdata, Lean.Meta.MetaM, Prod, Lean.Meta.DiscrTree.Key, Array, Lean.Expr, Lean.Expr.getAppFn, Pure.pure, Prod.mk, Lean.Meta.DiscrTree.Key.lit, List.toArray, List.nil, Lean.Meta.DiscrTree.Key.const, Lean.Expr.getAppRevArgs, Lean.Meta.DiscrTree.Key.fvar, Lean.Meta.DiscrTree.Key.other, MonadReader.read, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Context.config, Lean.Meta.DiscrTree.Key.star, Lean.Meta.isReadOnlyOrSyntheticOpaqueExprMVar, Lean.Meta.DiscrTree.Key.proj, List.cons, Lean.Expr.hasLooseBVars, Lean.Meta.DiscrTree.Key.arrow, Unit.unit, Std.PersistentHashMap.find?, Lean.Meta.DiscrTree.root],[Lean.Meta.MetaM, Array]]
[Lean.Elab.Command.StructFieldInfo.isSubobject,[Lean.Elab.Command.StructFieldKind.newField, Lean.Elab.Command.StructFieldKind.copiedField, Lean.Elab.Command.StructFieldKind.fromParent, Unit.unit, Bool, Lean.Elab.Command.StructFieldInfo.kind, Bool.true, Bool.false],[Bool]]
[Fin.mulOverflows?,[Decidable.decide, LE.le, HMul.hMul, Fin.val],[Bool]]
[Lean.Parser.Term.liftMethod,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.minPrec, HAndThen.hAndThen, Lean.Parser.Term.leftArrow, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.Syntax.isFieldIdx?,[Option.none, Option, Nat, Lean.Syntax.isLit?, Lean.Syntax.decodeNatLitVal?, Lean.fieldIdxKind],[Option, Nat]]
[UInt32.instSemiringUInt32.proof_6,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, HMul.hMul, UInt32.zero_def, UInt32.mul_def, UInt32.mk, OfNat.ofNat, MonoidWithZero.mul_zero, UInt32.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt32],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Lsp.RpcCallParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.RpcCallParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.RpcCallParams.mk, And]]
[Lean.Elab.Command.CtorView.mk.inj,[And.intro],[And, Eq]]
[ReaderT.instMonadFunctorReaderT,[MonadFunctor.mk],[MonadFunctor, ReaderT]]
[Lean.PrettyPrinter.Delaborator.annotatePos,[Lean.Syntax.setInfo, Lean.SourceInfo.synthetic],[Lean.Syntax]]
[MProd.noConfusionType,[],[]]
[Lean.Parser.Term.set_option.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.ppSpace.formatter, Lean.Parser.Command.optionValue.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.withFreshMacroScope,[Bind.bind, modifyGetThe, Lean.Core.State, Prod.mk, Lean.Core.State.nextMacroScope, Lean.Core.State.mk, Lean.Core.State.env, HAdd.hAdd, OfNat.ofNat, Lean.Core.State.ngen, Lean.Core.State.traceState, MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.Context.declName?, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.mayPostpone, Lean.Elab.Term.Context.errToSorry, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.Term.Context.autoBoundImplicits, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection],[Lean.Elab.Term.TermElabM]]
[Lean.Meta.CheckAssignment.Context.fvars,[],[Array, Lean.Expr]]
[ne_eq,[rfl],[Eq, Ne, Not]]
[Lean.HeadIndex.fvar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.HeadIndex.fvar, HAdd.hAdd, OfNat.ofNat]]
[Std.Format.text.injEq,[Eq.propIntro, Eq.refl, Std.Format.text, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.Format.text]]
[Lean.PrettyPrinter.Parenthesizer.interpolatedStr.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.PrettyPrinter.Parenthesizer.visitArgs, Array.forM, Array.reverse, Lean.Syntax.getArgs, OfNat.ofNat, Array.size],[Lean.PrettyPrinter.Parenthesizer]]
[instReprSSet,[Repr.mk, Repr.addAppParen, HAppend.hAppend, reprArg, Lean.SSet.toList, Std.Format.text],[Repr, Lean.SSet]]
[Lean.Parser.Term.funBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.funStrictImplicitBinder.parenthesizer, Lean.Parser.Term.funImplicitBinder.parenthesizer, Lean.Parser.Term.instBinder.parenthesizer, Lean.Parser.Term.funSimpleBinder.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.SyntheticMVarKind.postponed.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.SyntheticMVarKind.postponed, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.SyntheticMVarKind.postponed]]
[Subtype.instHasEquivSubtype,[HasEquiv.mk, HasEquiv.Equiv, Subtype.val],[HasEquiv, Subtype]]
[Lean.Elab.Term.StructInst.expandStructInstFieldAbbrev,[ite, Eq, Array.any, Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Array.size, Bool.true, Bind.bind, Array.mapM, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, List.nil, Lean.Syntax.atom, Lean.Syntax.setArg, Lean.mkNullNode, Lean.Macro.throwUnsupported],[Lean.Macro]]
[heq_of_eq_of_heq,[HEq.trans, heq_of_eq],[HEq]]
[Lean.Elab.Command.ElabHeaderResult.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Command.instMonadEnvCommandElabM,[Lean.MonadEnv.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Command.State.env, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState],[Lean.MonadEnv, Lean.Elab.Command.CommandElabM]]
[Lean.Meta.ToHide.unmark,[modify, Lean.Meta.ToHide.State.mk, Std.RBTree.erase, Lean.Meta.ToHide.State.hiddenInaccessibleProp, Lean.Meta.ToHide.State.hiddenInaccessible, Bool.true],[Lean.Meta.ToHide.M, Unit]]
[Lean.Meta.SynthInstance.step,[Bind.bind, Lean.Meta.SynthInstance.checkMaxHeartbeats, MonadState.get, ite, Eq, not, Array.isEmpty, Lean.Meta.SynthInstance.State.resumeStack, Bool.true, Lean.Meta.SynthInstance.resume, Pure.pure, Lean.Meta.SynthInstance.State.generatorStack, Lean.Meta.SynthInstance.generate, Bool.false],[Lean.Meta.SynthInstance.SynthM, Bool]]
[Array.filterMapM,[Array.foldlM, Bind.bind, Unit.unit, Array, Pure.pure, Array.push, List.toArray, List.nil],[Array]]
[Lean.Meta.DiscrTree.Key.noConfusionType,[],[]]
[Lean.IR.FnBody.isTerminal,[Lean.IR.FnBody.vdecl, Lean.IR.FnBody.jdecl, Lean.IR.FnBody.set, Lean.IR.FnBody.setTag, Lean.IR.FnBody.uset, Lean.IR.FnBody.sset, Lean.IR.FnBody.inc, Lean.IR.FnBody.dec, Lean.IR.FnBody.del, Lean.IR.FnBody.mdata, Unit.unit, Bool, Bool.true, Bool.false],[Bool]]
[Std.PersistentArray.initShift,[OfNat.ofNat],[USize]]
[Lean.IR.Decl.fdecl.inj,[And.intro],[And, Eq]]
[Lean.PrettyPrinter.Parenthesizer.checkStackTop.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.ServerCapabilities.documentSymbolProvider,[],[Bool]]
[Lean.IR.Borrow.ParamMap.Key.jp.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Borrow.ParamMap.Key.jp, HAdd.hAdd, OfNat.ofNat]]
[StateT.tryFinally,[MonadFinally.mk, Bind.bind, MonadFinally.tryFinally', Unit.unit, Prod, Option.some, Option.none, Pure.pure, Prod.mk],[MonadFinally, StateT]]
[Lean.Lsp.WorkDoneProgressEnd.mk.inj,[And.intro],[And, Eq]]
[Lean.instCoeStringName,[Coe.mk, Lean.Name.mkSimple],[Coe, String, Lean.Name]]
[Char.utf8Size.proof_3,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[Lean.Name.sizeOf,[Unit.unit, Nat, OfNat.ofNat, HAdd.hAdd, PProd.fst, SizeOf.sizeOf],[Nat]]
[Lean.Parser.setLhsPrecFn,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Parser.ParserState.mk, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.pos, Lean.Parser.ParserState.cache, Lean.Parser.ParserState.errorMsg],[Lean.Parser.ParserFn]]
[Lean.Syntax.Traverser.fromSyntax,[Lean.Syntax.Traverser.mk, List.toArray, List.nil],[Lean.Syntax.Traverser]]
[IO.FS.instLESystemTime,[leOfOrd],[LE, IO.FS.SystemTime]]
[Lean.Elab.Term.setMessageLog,[modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.NameGenerator.curr,[Lean.Name.mkNum, Lean.NameGenerator.namePrefix, Lean.NameGenerator.idx],[Lean.Name]]
[Std.Rbcolor.noConfusionType,[noConfusionTypeEnum, Std.Rbcolor.toCtorIdx],[]]
[Lean.MonadTrace.noConfusionType,[],[]]
[Std.RBNode.ins,[Std.RBNode, Std.RBNode.node, Std.Rbcolor.red, Std.RBNode.leaf, Unit.unit, PProd.fst, PProd.snd, ite, Eq, Std.RBNode.isRed, Bool.true, Std.RBNode.balance1, Std.Rbcolor.black, Std.RBNode.balance2],[Std.RBNode]]
[instDecidableEqSum.proof_2,[absurd],[False]]
[Lean.Expr.isBinding,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Elab.Term.LetRecToLift.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LetRecToLift.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.LetRecToLift.mk, And]]
[Lean.Elab.Term.elabAnonymousCtor,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Term.tryPostponeIfNoneOrMVar, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, liftM, Lean.Meta.whnf, Lean.matchConstInduct, Lean.Expr.getAppFn, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, List.nil, List.cons, Lean.InductiveVal.ctors, Lean.getConstInfoCtor, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, ForIn.forIn, Lean.Meta.getFVarLocalDecl, Array.getOp, Lean.BinderInfo.isExplicit, Lean.LocalDecl.binderInfo, Pure.pure, PUnit.unit, ForInStep.yield, LT.lt, Array.size, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElab]]
[Lean.Elab.Tactic.Conv.remarkAsConvGoal,[Bind.bind, Lean.Elab.Tactic.getUnsolvedGoals, List.mapM, Lean.Meta.withMVarContext, liftM, Lean.Meta.getMVarType, Lean.Meta.matchEq?, Option.none, Lean.Elab.Tactic.TacticM, Lean.MVarId, ite, Eq, Lean.Expr.isMVar, Lean.Expr.getAppFn, Bool.true, Lean.Meta.replaceTargetDefEq, Lean.mkLHSGoal, Pure.pure, Lean.Elab.Tactic.setGoals],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.compileDecl,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, Lean.KernelException.unknownConstant, Lean.KernelException.alreadyDeclared, Lean.KernelException.declTypeMismatch, Lean.KernelException.declHasMVars, Lean.KernelException.declHasFVars, Lean.KernelException.funExpected, Lean.KernelException.typeExpected, Lean.KernelException.letTypeMismatch, Lean.KernelException.exprTypeMismatch, Lean.KernelException.appTypeMismatch, Lean.KernelException.invalidProj, Unit, Lean.Environment.compileDecl, Lean.setEnv, Lean.Declaration.forExprM, Option.none, Option.some, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, Unit.unit, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.throwKernelException],[Unit]]
[List.mem_append_right,[Iff.mpr, List.mem_append, Or.inr],[Mem.mem, HAppend.hAppend]]
[Lean.IR.Checker.checkEqTypes,[ite, Eq, BEq.beq, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw],[Lean.IR.Checker.M, Unit]]
[Lean.Elab.Deriving.BEq.mkMatch.mkElseAlt,[Bind.bind, ForIn.forIn, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, PUnit.unit, ForInStep.yield, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Subarray.stop,[],[Nat]]
[Lean.Meta.CheckAssignment.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.CheckAssignment.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.basicFun,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.many1, Lean.Parser.ppSpace, Lean.Parser.Term.funBinder, Lean.Parser.darrow, Lean.Parser.termParser, OfNat.ofNat, Bool.false],[Lean.Parser.Parser]]
[Lean.MonadFileMap.getFileMap,[],[Lean.FileMap]]
[UInt32.toUSize,[Nat.toUSize, UInt32.toNat],[USize]]
[instInhabitedSubstring,[Inhabited.mk, Substring.mk, OfNat.ofNat],[Inhabited, Substring]]
[Lean.Meta.mkLe,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[IO.FS.Stream.Buffer.mk.inj,[And.intro],[And, Eq]]
[Lean.PrettyPrinter.Parenthesizer.nameLitNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.gcd_dvd_gcd_mul_left,[Nat.gcd_dvd_gcd_of_dvd_left, Nat.dvd_mul_left],[Dvd.dvd, Nat.gcd, HMul.hMul]]
[Lean.Compiler.InlineAttributeKind.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.PrettyPrinter.Parenthesizer.State.contPrec,[],[Option, Nat]]
[Lean.instInhabitedOccurrences,[Inhabited.mk, Lean.Occurrences.all],[Inhabited, Lean.Occurrences]]
[Lean.IR.Expr.fap.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Expr.fap, HAdd.hAdd, OfNat.ofNat]]
[Lean.registerStructure,[Lean.PersistentEnvExtension.addEntry, Lean.structureExt, Lean.StructureInfo.mk, Lean.StructureDescr.structName, Array.map, Lean.StructureFieldInfo.fieldName, Lean.StructureDescr.fields, Array.qsort, Lean.StructureFieldInfo.lt, OfNat.ofNat, HSub.hSub, Array.size],[Lean.Environment]]
[Lean.Lsp.TextDocumentContentChangeEvent.fullChange.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.TextDocumentContentChangeEvent.fullChange, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.Do.Alt.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.Match.AltLHS.ref,[],[Lean.Syntax]]
[Lean.Elab.elabAttr,[Bind.bind, Lean.Elab.liftMacroM, Lean.Elab.toAttributeKind, Lean.Syntax.getOp, OfNat.ofNat, Lean.expandMacros, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Lean.Name.eraseMacroScopes, Lean.Syntax.getId, Lean.Name.num, Lean.Elab.Attribute, Lean.Name.mkSimple, Lean.throwErrorAt, Lean.ToMessageData.toMessageData],[Lean.Elab.Attribute]]
[Lean.Meta.Simp.mkCongr,[Unit.unit, Lean.Meta.MetaM, Lean.Meta.Simp.Result, Lean.Meta.Simp.Result.proof?, Pure.pure, Lean.Meta.Simp.Result.mk, Option.none, Bind.bind, Lean.Meta.mkCongrFun, Lean.Meta.Simp.Result.expr, Option.some, Lean.Meta.mkCongrArg, Lean.Meta.mkCongr],[Lean.Meta.MetaM, Lean.Meta.Simp.Result]]
[Lean.Lsp.TextDocumentChangeRegistrationOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.TextDocumentChangeRegistrationOptions.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Tactic.AuxMatchTermState.cases,[],[Array, Lean.Syntax]]
[Lean.IR.ExplicitBoxing.requiresBoxedVersion,[or, and, Decidable.decide, GT.gt, Array.size, OfNat.ofNat, Lean.IR.IRType.isScalar, Lean.IR.Decl.resultType, Array.any, Lean.IR.Param.ty, Lean.IR.Param.borrow, Lean.isExtern, Lean.IR.Decl.name, Lean.closureMaxArgs],[Bool]]
[List.erase_cons,[Classical.em, Eq, of_eq_true, Eq.trans, congr, congrArg, congrFun, Unit.unit, List, Iff.mp, EqIffBeqTrue, Eq.symm, List.cons, List.erase, if_pos, eq_self, NeqIffBeqFalse, Ne.symm, if_neg, Eq.refl],[Eq, List.erase, List.cons, ite]]
[Lean.Level.isNeverZero,[Bool, Bool.false, Bool.true, or, PProd.fst, PProd.snd],[Bool]]
[UInt8.instSemiringUInt8.proof_12,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HMul.hMul, UInt8.add_def, UInt8.mul_def, UInt8.mk, HAdd.hAdd, UInt8.val, UInt8.eq_of_val_eq, Semiring.add_mul],[Eq, HMul.hMul, HAdd.hAdd]]
[Lean.Meta.AbstractMVars.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.AbstractMVars.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.AbstractMVars.State.mk, And]]
[Lean.Elab.Modifiers.docString?,[],[Option, String]]
[Equiv.symm,[Equiv.mk, Equiv.invFun, Equiv.toFun, Equiv.rightInv, Equiv.leftInv],[Equiv]]
[IO.withStdout,[Bind.bind, liftM, IO.setStdout, tryFinally, Functor.discard],[]]
[Lean.Server.FileWorker.RpcSession.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.FileWorker.RpcSession.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.FileWorker.RpcSession.mk, And]]
[Lean.HeadIndex.lam.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.HeadIndex.lam, OfNat.ofNat]]
[Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer,[Bind.bind, modify, Lean.PrettyPrinter.Parenthesizer.State.mk, Lean.PrettyPrinter.Parenthesizer.State.stxTrav, Option.none, Lean.PrettyPrinter.Parenthesizer.State.contCat, Lean.PrettyPrinter.Parenthesizer.State.minPrec, Lean.PrettyPrinter.Parenthesizer.State.trailPrec, Lean.PrettyPrinter.Parenthesizer.State.trailCat, Lean.PrettyPrinter.Parenthesizer.State.visitedToken],[Lean.PrettyPrinter.Parenthesizer]]
[Int.ofNat_mul_ofNat,[rfl],[Eq, HMul.hMul, Int.ofNat]]
[Lean.Parser.Command.structureTk.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Server.RequestM.asTask,[Bind.bind, liftM, EIO.asTask, Task.Priority.default, Pure.pure, Task.map, liftExcept],[Lean.Server.RequestM, Lean.Server.RequestTask]]
[UInt64.xor,[UInt64.mk, Fin.xor, UInt64.val],[UInt64]]
[Std.ToFormat.format,[],[Std.Format]]
[Lean.Parser.Tactic.rfl',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Lsp.TextDocumentRegistrationOptions.mk.inj,[],[Eq]]
[Xor.xor,[],[]]
[Lean.Parser.mkParserState,[Lean.Parser.ParserState.mk, Lean.Parser.initCacheForInput],[Lean.Parser.ParserState]]
[termMax_prec,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.SMap.fold,[Std.PersistentHashMap.foldl, Lean.SMap.map₂, Std.HashMap.fold, Lean.SMap.map₁],[]]
[instToStringOption,[ToString.mk, Unit.unit, String, HAppend.hAppend, addParenHeuristic, ToString.toString],[ToString, Option]]
[Lean.Parser.Term.app.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.leadPrec, Lean.Parser.maxPrec, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.argument.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.CheckAssignment.Context.mvarId,[],[Lean.MVarId]]
[Lean.Parser.Command.terminationHint1.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[List.exists_of_mem_map,[Exists, And, Mem.mem, List.nil, Eq, Eq.refl, List.eq_or_mem_of_mem_cons, Exists.intro, And.intro, List.mem_cons_self, Eq.symm, List.cons, List.mem_cons_of_mem],[Exists, And, Mem.mem, Eq]]
[Lean.Parser.ppGroup.parenthesizer,[],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Json.num.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Json.num, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.universe,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.ident],[Lean.Parser.Parser]]
[le_iff_lt_or_eq,[Decidable.le_iff_lt_or_eq],[Iff, LE.le, Or, LT.lt, Eq]]
[Lean.MetavarContext.LevelMVarToParam.State.noConfusionType,[],[]]
[Lean.PrettyPrinter.Formatter.indent,[Bind.bind, Lean.PrettyPrinter.Formatter.concat, MonadReader.read, modify, Lean.PrettyPrinter.Formatter.State.mk, Lean.PrettyPrinter.Formatter.State.stxTrav, Lean.PrettyPrinter.Formatter.State.leadWord, Array.modify, Lean.PrettyPrinter.Formatter.State.stack, HSub.hSub, Array.size, OfNat.ofNat, Std.Format.nest],[Lean.PrettyPrinter.Formatter]]
[UInt8.val_eq_of_lt,[Fin.val_eq_of_lt],[Eq, Fin.val, UInt8.val, UInt8.ofNat]]
[Lean.Elab.Command.elabExport,[Bind.bind, Lean.resolveNamespace, Lean.MonadResolveName.getCurrNamespace, ite, Eq, BEq.beq, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Elab.Command.CommandElab]]
[Array.indexOf?,[Array.indexOfAux, OfNat.ofNat],[Option, Fin, Array.size]]
[Lean.QuotKind.type.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.QuotKind.type, OfNat.ofNat]]
[Lean.Meta.Closure.visitExpr,[ite, Eq, and, not, Lean.Expr.hasLevelParam, Lean.Expr.hasFVar, Lean.Expr.hasMVar, Bool.true, Pure.pure, Bind.bind, MonadState.get, Unit.unit, Lean.Meta.Closure.ClosureM, Lean.Expr, Std.HashMap.find?, Lean.Meta.Closure.State.visitedExpr, Lean.ExprStructEq.mk, modify, Lean.Meta.Closure.State.mk, Lean.Meta.Closure.State.visitedLevel, Std.HashMap.insert, Lean.Meta.Closure.State.levelParams, Lean.Meta.Closure.State.nextLevelIdx, Lean.Meta.Closure.State.levelArgs, Lean.Meta.Closure.State.newLocalDecls, Lean.Meta.Closure.State.newLocalDeclsForMVars, Lean.Meta.Closure.State.newLetDecls, Lean.Meta.Closure.State.nextExprIdx, Lean.Meta.Closure.State.exprMVarArgs, Lean.Meta.Closure.State.exprFVarArgs, Lean.Meta.Closure.State.toProcess],[Lean.Meta.Closure.ClosureM, Lean.Expr]]
[Iff.refl,[Iff.intro],[Iff]]
[Lean.KeyedDeclsAttribute.ExtensionState.noConfusionType,[],[]]
[of_heq_true,[of_eq_true, eq_of_heq],[]]
[Nat.gcd_le_right,[Nat.le_of_dvd, Nat.gcd_dvd_right],[LE.le, Nat.gcd]]
[Lean.Parser.Tactic.clean,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Semiring.add_zero,[],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Char.utf8Size.proof_6,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[Lean.Elab.Term.elabOpen,[tryFinally, Bind.bind, Lean.pushScope, Lean.Elab.OpenDecl.elabOpenDecl, Lean.Syntax.getOp, OfNat.ofNat, withTheReader, Lean.Core.Context, Lean.Core.Context.mk, Lean.Core.Context.options, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats, Lean.Elab.Term.elabTerm, Bool.true, Lean.popScope],[Lean.Elab.Term.TermElab]]
[Lean.Meta.SimpLemmas.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SimpLemmas.mk, HAdd.hAdd, OfNat.ofNat]]
[ReaderT.map,[Functor.map],[ReaderT]]
[Std.PersistentHashMap.stats,[Std.PersistentHashMap.collectStats, Std.PersistentHashMap.root, Std.PersistentHashMap.Stats.mk, OfNat.ofNat],[Std.PersistentHashMap.Stats]]
[Lean.Lsp.TextEdit.newText,[],[String]]
[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, bne, Lean.Syntax.getKind, Bool.true, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Syntax.ident.inj,[And.intro],[And, Eq]]
[Lean.MetavarContext.isDelayedAssigned,[Std.PersistentHashMap.contains, Lean.MetavarContext.dAssignment],[Bool]]
[Tactic.Ring.HornerExpr.reflConv,[Bind.bind, liftM, Lean.Meta.mkEqRefl, Tactic.Ring.HornerExpr.e, Pure.pure, Prod.mk],[Tactic.Ring.RingM, Prod, Tactic.Ring.HornerExpr, Lean.Expr]]
[Lean.Meta.CongrLemmas.noConfusionType,[],[]]
[Functor.map_equiv_symm_apply,[rfl],[Eq, Equiv.toFun, Equiv.symm, Functor.map_equiv, Functor.map]]
[Lean.MetavarContext.getExprAssignment?,[Std.PersistentHashMap.find?, Lean.MetavarContext.eAssignment],[Option, Lean.Expr]]
[FloatArray.instInhabitedFloatArray,[Inhabited.mk, FloatArray.empty],[Inhabited, FloatArray]]
[Lean.InternalExceptionId.mk.inj,[],[Eq]]
[Lean.RecursorRule.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.RecursorRule.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.initRing,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Meta.SynthInstance.GeneratorNode.mvar,[],[Lean.Expr]]
[Lean.IR.collectLiveVars,[Lean.IR.LiveVars.collectFnBody],[Lean.IR.LiveVarSet]]
[Lean.Elab.Tactic.instMonadExceptExceptionTacticM,[MonadExcept.mk, MonadExcept.throw, Lean.Elab.Tactic.tryCatch],[MonadExcept, Lean.Exception, Lean.Elab.Tactic.TacticM]]
[Lean.enableTracing,[Bind.bind, Lean.MonadTrace.getTraceState, Lean.MonadTrace.modifyTraceState, Lean.TraceState.mk, Lean.TraceState.traces, Pure.pure],[Bool]]
[Lean.Elab.Term.BinOp.elabBinOpLazy,[Lean.Elab.Term.BinOp.elabBinOp],[Lean.Elab.Term.TermElab]]
[Lean.Parser.FirstTokens.tokens.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.FirstTokens.tokens, HAdd.hAdd, OfNat.ofNat]]
[Int.add_left_cancel,[],[Eq]]
[Lean.Meta.replaceLocalDecl.findMaxFVar,[Lean.Expr.forEach', ite, Eq, Lean.Expr.isFVar, Bool.true, Bind.bind, liftM, Lean.Meta.getLocalDecl, Lean.Expr.fvarId!, modify, GT.gt, Lean.LocalDecl.index, Pure.pure, Bool.false, Lean.Expr.hasFVar],[StateRefT', IO.RealWorld, Lean.LocalDecl, Lean.Meta.MetaM, Unit]]
[Lean.Meta.SimpLemmas.isLemma,[Std.PersistentHashSet.contains, Lean.Meta.SimpLemmas.lemmaNames],[Bool]]
[Lean.Parser.unicodeSymbolNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.unicodeSymbolInfo, Lean.Parser.unicodeSymbolFn],[Lean.Parser.Parser]]
[Lean.instInhabitedNameGenerator,[Inhabited.mk, Lean.NameGenerator.mk, arbitrary],[Inhabited, Lean.NameGenerator]]
[Prod.map_mk,[rfl],[Eq, Prod.map, Prod.mk]]
[Lean.Parser.Term.syntheticHole.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.Term.hole.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.lambdaTelescope,[Lean.Meta.map2MetaM, Bind.bind, Lean.MonadLCtx.getLCtx, List.toArray, List.nil, OfNat.ofNat, Bool.false],[]]
[Lean.Name.ibelow,[True, And],[]]
[Lean.Parser.Term.borrowed.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.leadPrec],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Term.doIfLetBind,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser],[Lean.Parser.Parser]]
[MonadControlT.liftWith,[],[]]
[Lean.IR.LogEntry.step.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.LogEntry.step, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.LogEntry.step, And]]
[Lean.Macro.resolveGlobalName,[Bind.bind, Lean.Macro.getMethods, Lean.Macro.Methods.resolveGlobalName],[Lean.MacroM, List, Prod, Lean.Name, String]]
[Lean.Meta.withPPInaccessibleNames,[Lean.Meta.mapMetaM, Lean.Meta.withPPInaccessibleNamesImp],[]]
[Or.elim3,[Or.elim],[]]
[Lean.Elab.Command.elabStructure,[Bind.bind, Lean.Elab.Command.checkValidInductiveModifier, Lean.Elab.getOptDerivingClasses, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, Lean.Syntax.isNone, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.Elab.Command.CommandElabM, Unit]]
[Lean.Parser.Term.letrec.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.group.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.Term.letRecDecls.formatter, Lean.Parser.Term.optSemicolon.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Lean.Server.toFileUri,[HAppend.hAppend, String.dropWhile, BEq.beq, Char.ofNat],[Lean.Lsp.DocumentUri]]
[Lean.EnvExtensionInterface.ensureExtensionsSize,[],[IO, Lean.Environment]]
[Lean.MetavarContext.LevelMVarToParam.State.nextParamIdx,[],[Nat]]
[Lean.OpenDecl.explicit.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.State.mk.inj,[And.intro],[And, Eq]]
[Lean.instInhabitedEnvExtensionState,[Inhabited.mk, PointedType.val, Lean.EnvExtensionStateSpec],[Inhabited, Lean.EnvExtensionState]]
[Mathlib.Tactic.Lint.isSimpLemma,[Bind.bind, liftM, Lean.Meta.getSimpLemmas, Pure.pure, Std.PersistentHashSet.contains, Lean.Meta.SimpLemmas.lemmaNames],[Lean.Meta.MetaM, Bool]]
[Fin.mod_def,[Eq, HMod.hMod, Fin.mk, Fin.val, Nat.mod_lt, Fin.size_positive, rfl],[Eq, HMod.hMod, Fin.mk, Fin.val, Nat.mod_lt, Fin.size_positive]]
[Nat.div_div_eq_div_mul,[Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, OfNat.ofNat, Nat.mul_zero, Nat.div_zero, rfl, Eq.symm, Nat.zero_mul, Nat.zero_div, Nat.le_antisymm, Iff.mpr, Nat.le_div_iff_mul_le, Nat.mul_pos, LE.le, Nat.mul_comm, Nat.mul_assoc, Iff.mp, Nat.le_refl],[Eq, HDiv.hDiv, HMul.hMul]]
[Eq.mpr,[Eq.symm],[]]
[Lean.MessageData.ofLevel.injEq,[Eq.propIntro, Eq.refl, Lean.MessageData.ofLevel, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MessageData.ofLevel]]
[Lean.Parser.Tactic.set!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.OpenDecl.simple.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.OpenDecl.simple, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.OpenDecl.simple, And]]
[Lean.PrettyPrinter.Parenthesizer.parenthesizerForKindUnsafe,[ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Unit.unit, Bind.bind, liftM, Lean.PrettyPrinter.runForNodeKind, Lean.PrettyPrinter.parenthesizerAttribute, Lean.PrettyPrinter.Parenthesizer.interpretParserDescr'],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Level.PP.Result.num.inj,[],[Eq]]
[instToStringNat,[ToString.mk, Nat.repr],[ToString, Nat]]
[instSemiringFin.proof_7,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.mul_def, Fin.mk, HMod.hMod, OfNat.ofNat, Nat.mod_lt, Fin.size_positive, congrFun, HMul.hMul, Nat.zero_mod, MonoidWithZero.zero_mul, Fin.zero_def, eq_true_of_decide, Eq.refl, Bool.true],[Eq, HMul.hMul, Fin.ofNat', Fin.size_positive, OfNat.ofNat]]
[Lean.IR.CompilerState.env,[],[Lean.Environment]]
[Lean.Server.FileWorker.handleSemanticTokensRange,[Bind.bind, Lean.Server.RequestM.readDoc, Lean.Server.FileWorker.handleSemanticTokens],[Lean.Server.RequestM, Lean.Server.RequestTask, Lean.Lsp.SemanticTokens]]
[Lean.Compiler.atMostOnce.AtMostOnceData.found,[],[Bool]]
[Lean.Elab.Tactic.ElimApp.State.targetPos,[],[Nat]]
[Lean.Meta.NormNum.isNat_mul,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, OfNat.ofNat, Lean.Meta.NormNum.isNat, HMul.hMul, ofNat_mul],[Lean.Meta.NormNum.isNat, HMul.hMul]]
[Lean.Parser.Term.structInstField.formatter,[Lean.ppGroup.formatter, Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.structInstLVal.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[not_not_of_not_imp,[mt, Not.elim],[Not]]
[Lean.Parser.Term.explicit.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Server.FileWorker.handleSemanticTokens.highlightKeyword,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, ReaderT, Lean.Server.FileWorker.SemanticTokensContext, StateT, Lean.Server.FileWorker.SemanticTokensState, Lean.Server.RequestM, PUnit, ite, Eq, and, Decidable.decide, GT.gt, String.bsize, OfNat.ofNat, Char.isAlpha, String.getOp, Bool.true, Lean.Server.FileWorker.handleSemanticTokens.addToken, Lean.Lsp.SemanticTokenType.keyword, Pure.pure, PUnit.unit],[ReaderT, Lean.Server.FileWorker.SemanticTokensContext, StateT, Lean.Server.FileWorker.SemanticTokensState, Lean.Server.RequestM, PUnit]]
[Lean.Parser.FirstTokens.unknown.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Parser.FirstTokens.unknown, OfNat.ofNat]]
[Lean.Server.Snapshots.compileNextCmd.withNewInteractiveDiags,[Bind.bind, ForIn.forIn, Lean.Widget.msgToInteractiveDiagnostic, Pure.pure, PUnit.unit, ForInStep.yield],[IO, Std.PersistentArray, Lean.Widget.InteractiveDiagnostic]]
[Lean.PrettyPrinter.Delaborator.getParamKinds,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, MonadExcept.tryCatch, Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.all, Lean.Expr.getAppFn, Lean.Expr.getAppArgs, Array.mapM, liftM, Lean.Meta.getLocalDecl, Lean.Expr.fvarId!, Pure.pure, Lean.PrettyPrinter.Delaborator.ParamKind.mk, Lean.LocalDecl.userName, Lean.LocalDecl.binderInfo, Lean.Expr.getOptParamDefault?, Lean.LocalDecl.type, Lean.Expr.isAutoParam, List.toArray, List.nil, Lean.PrettyPrinter.Delaborator.getParamKinds.forallTelescopeArgs],[Lean.PrettyPrinter.Delaborator.DelabM, Array, Lean.PrettyPrinter.Delaborator.ParamKind]]
[Lean.ParametricAttribute.ext,[],[Lean.PersistentEnvExtension, Prod, Lean.Name, Lean.NameMap]]
[Lean.Lsp.RpcReleaseParams.refs,[],[Array, Lean.Lsp.RpcRef]]
[Lean.Lsp.instToJsonDeclarationParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.DeclarationParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position],[Lean.ToJson, Lean.Lsp.DeclarationParams]]
[Lean.Meta.SortLocalDecls.M,[ReaderT, Lean.Meta.SortLocalDecls.Context, StateRefT', IO.RealWorld, Lean.Meta.SortLocalDecls.State, Lean.Meta.MetaM],[]]
[Lean.Widget.TaggedText.instMonadPrettyFormatStateMTaggedState,[Std.Format.MonadPrettyFormat.mk, modify, Lean.Widget.TaggedText.appendText, HAdd.hAdd, String.length, String.pushn, Char.ofNat, Bind.bind, MonadState.get, Pure.pure, Lean.Widget.TaggedText.text, List.cons, Prod.mk],[Std.Format.MonadPrettyFormat, StateM]]
[Lean.Elab.Term.instInhabitedMVarErrorInfo,[Inhabited.mk, Lean.Elab.Term.MVarErrorInfo.mk, arbitrary],[Inhabited, Lean.Elab.Term.MVarErrorInfo]]
[Lean.IR.modifyJPs,[Array.map, Lean.IR.FnBody.vdecl, Lean.IR.FnBody.set, Lean.IR.FnBody.setTag, Lean.IR.FnBody.uset, Lean.IR.FnBody.sset, Lean.IR.FnBody.inc, Lean.IR.FnBody.dec, Lean.IR.FnBody.del, Lean.IR.FnBody.mdata, Lean.IR.FnBody.case, Lean.IR.FnBody.ret, Lean.IR.FnBody.jmp, Lean.IR.FnBody.unreachable, Lean.IR.FnBody, Lean.IR.FnBody.jdecl],[Array, Lean.IR.FnBody]]
[instToStringByteArray,[ToString.mk, List.toString, ByteArray.toList],[ToString, ByteArray]]
[Lean.Meta.SizeOfSpecNested.throwUnexpected,[Bind.bind, MonadReader.read, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.SizeOfSpecNested.Context.ctorName],[Lean.Meta.SizeOfSpecNested.M]]
[Lean.Meta.mkFreshExprMVarAt,[Bind.bind, Lean.mkFreshMVarId, Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.addExprMVarDecl, Pure.pure, Lean.mkMVar],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Parser.Command.init_quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.PPFns.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.PPFns.mk, OfNat.ofNat]]
[Lean.Meta.SynthInstance.getEntry,[Bind.bind, Lean.Meta.SynthInstance.findEntry?, Unit.unit, Lean.Meta.SynthInstance.SynthM, Lean.Meta.SynthInstance.TableEntry, panicWithPosWithDecl, OfNat.ofNat, Pure.pure],[Lean.Meta.SynthInstance.SynthM, Lean.Meta.SynthInstance.TableEntry]]
[Lean.Environment.getProjectionStructureName?,[Unit.unit, Option, Lean.Name, Lean.Environment.getProjectionFnInfo?, Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo, Lean.Environment.find?, Lean.ProjectionFunctionInfo.ctorName, Lean.ConstructorVal.induct],[Option, Lean.Name]]
[Lean.AttributeApplicationTime.noConfusion,[noConfusionEnum, Lean.AttributeApplicationTime.toCtorIdx],[Lean.AttributeApplicationTime.noConfusionType]]
[dbgSleep,[Unit.unit],[]]
[PSigma.eta,[rfl],[Eq, PSigma.mk]]
[String.singleton,[String.push],[String]]
[Lean.Elab.Term.addDotCompletionInfo,[Bind.bind, Lean.MonadLCtx.getLCtx, Lean.Elab.addCompletionInfo, Lean.Elab.CompletionInfo.dot, Lean.Elab.TermInfo.mk, Lean.Elab.ElabInfo.mk, Lean.Name.anonymous],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Expr.FindImpl.visited.proof_1,[lcProof],[LT.lt, USize.toNat, HMod.hMod, ptrAddrUnsafe, Array.size, Lean.Expr.FindImpl.State.keys]]
[Lean.TransformStep.done.injEq,[Eq.propIntro, Eq.refl, Lean.TransformStep.done, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.TransformStep.done]]
[instCommMonoid_1.proof_4,[Semiring.npow_succ'],[Eq, Semiring.npow, Nat.succ, HMul.hMul]]
[Lean.LocalDecl.cdecl.inj,[And.intro],[And, Eq]]
[Lean.Parser.ParserExtension.Entry.token.inj,[],[Eq]]
[StateT.run,[],[Prod]]
[instDecidableEqString,[String.decEq],[DecidableEq, String]]
[List.decidableBall.proof_4,[Iff.mp, List.mem_cons, Eq.symm],[]]
[Lean.Lsp.PlainTermGoal.range,[],[Lean.Lsp.Range]]
[Lean.SMap.find?,[Option, Std.HashMap.find?, Option.orElse, Std.PersistentHashMap.find?],[Option]]
[Lean.Parser.notFollowedByFn,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Parser.ParserState.restore, Lean.Parser.ParserState.mkUnexpectedError, HAppend.hAppend, ToString.toString, List.nil],[Lean.Parser.ParserFn]]
[Lean.Name.modifyBase,[ite, Eq, Lean.Name.hasMacroScopes, Bool.true, Lean.MacroScopesView.review, Lean.MacroScopesView.mk, Lean.MacroScopesView.name, Lean.MacroScopesView.imported, Lean.MacroScopesView.mainModule, Lean.MacroScopesView.scopes],[Lean.Name]]
[Function.injective_of_subsingleton,[Subsingleton.elim],[Function.injective]]
[IO.Process.SpawnArgs.cmd,[],[String]]
[Function.injective.of_comp_iff',[Iff.intro, Eq, rfl, Function.injective.comp, Function.bijective.injective],[Iff, Function.injective, Function.comp]]
[Lean.Lsp.instFileSourceRpcKeepAliveParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.RpcKeepAliveParams.uri],[Lean.Lsp.FileSource, Lean.Lsp.RpcKeepAliveParams]]
[List.leftpad_prefix,[Exists.intro, rfl],[List.isPrefix, List.repeat, HSub.hSub, List.length, List.leftpad]]
[Lean.Parser.CategoryParserFn,[Lean.Parser.ParserFn],[]]
[CoeDep.coe,[],[]]
[Nat.add_lt_add,[Nat.lt_trans, Nat.add_lt_add_right, Nat.add_lt_add_left],[LT.lt, HAdd.hAdd]]
[Lean.Meta.AuxLemmas.idx,[],[Nat]]
[Lean.Lsp.DocumentSymbol.mk.inj,[],[Eq]]
[Lean.Meta.IndPredBelow.mkContext.mkHeader,[Bind.bind, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.InductiveVal.toConstantVal, Lean.Meta.mkArrow, Lean.mkAppN, Lean.Meta.IndPredBelow.mkContext.mkIndValConst, Lean.Meta.withNewBinderInfos, Array.map, Prod.mk, Lean.Expr.fvarId!, Lean.BinderInfo.implicit, Lean.Meta.mkForallFVars, Bool.false, Bool.true, Lean.Meta.IndPredBelow.mkContext.addMotives],[Lean.Meta.MetaM, Lean.Expr]]
[Classical.propComplete,[Or, Eq, True, False, Classical.em, Or.inl, propext, Iff.intro, True.intro, Or.inr, False.elim],[Or, Eq, True, False]]
[Lean.Meta.Simp.simp.simpLit,[Unit.unit, Lean.Meta.Simp.M, Lean.Meta.Simp.Result, Lean.Expr.natLit?, Bind.bind, Lean.Meta.Simp.getSimpLemmas, ite, Eq, Lean.Meta.SimpLemmas.isDeclToUnfold, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Lean.Meta.Simp.Result.mk, liftM, Lean.Meta.mkNumeral, Lean.mkConst, List.nil],[Lean.Meta.Simp.M, Lean.Meta.Simp.Result]]
[Lean.MetavarContext.MkBinding.preserveOrder,[MonadReader.read],[Lean.MetavarContext.MkBinding.M, Bool]]
[Lean.Elab.logUnknownDecl,[Lean.Elab.logError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Unit]]
[Lean.Meta.Match.MatcherInfo.getMotivePos,[Lean.Meta.Match.MatcherInfo.numParams],[Nat]]
[Lean.Parser.Parser.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.Parser.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.Parser.mk, And]]
[IO.Error.mkInvalidArgument,[IO.Error.invalidArgument, Option.none],[IO.Error]]
[Lean.ClassState.mk.injEq,[Eq.propIntro, Eq.refl, Lean.ClassState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ClassState.mk]]
[USize.instSemiringUSize.proof_6,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, HMul.hMul, USize.zero_def, USize.mul_def, USize.mk, OfNat.ofNat, MonoidWithZero.mul_zero, USize.val, eq_self, propext, forall_const, USize],[Eq, HMul.hMul, OfNat.ofNat]]
[Std.Format.getUnicode,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Std.Format.defUnicode],[Bool]]
[IO.FS.Handle.mk,[IO.FS.Handle.mkPrim, HAppend.hAppend],[IO, IO.FS.Handle]]
[Lean.Elab.Term.StructInst.defaultMissing?,[Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous],[Option, Lean.Expr]]
[Subtype.refl,[Setoid.refl, Subtype.val],[HasEquiv.Equiv]]
[UInt16.decEq,[Decidable, Eq, dite, Decidable.isTrue, UInt16.decEq.proof_1, Decidable.isFalse, UInt16.decEq.proof_2],[Decidable, Eq]]
[Lean.isExport,[or, Option.isSome, Lean.getExportNameFor, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous],[Bool]]
[Lean.Meta.Rewrite.Config.offsetCnstrs,[],[Bool]]
[Lean.Elab.Term.mkNoImplicitLambdaAnnotation,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Expr]]
[Lean.Lsp.instFromJsonPlainTermGoalParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.PlainTermGoalParams.mk, Lean.Lsp.TextDocumentPositionParams.mk],[Lean.FromJson, Lean.Lsp.PlainTermGoalParams]]
[Lean.Meta.caseArraySizes,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getArrayArgType, Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Lean.Meta.assertExt, Lean.mkConst, Lean.Meta.intro1, Lean.Meta.MetaM, Array, Lean.Meta.CaseArraySizesSubgoal, Lean.Meta.caseValues, Array.map, Lean.mkRawNatLit, Array.mapIdxM, dite, LT.lt, Fin.val, Array.size, Lean.Meta.clear, Array.getOp, Lean.Meta.CaseValuesSubgoal.newHs, OfNat.ofNat, Lean.Expr.fvarId!, Lean.Meta.FVarSubst.get, Lean.Meta.mkEqSymm, Lean.mkFVar, Lean.MVarId, Lean.Meta.getMVarTag, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.assignExprMVar, Lean.mkAppN, Pure.pure, Lean.Expr.mvarId!, Lean.Meta.introN, Bool.false, Lean.Meta.substCore, Bool.true, Lean.Meta.CaseArraySizesSubgoal.mk],[Lean.Meta.MetaM, Array, Lean.Meta.CaseArraySizesSubgoal]]
[StateT.run_map,[of_eq_true, Eq.trans, congrArg, Eq, Bind.bind, Pure.pure, Prod.mk, map_eq_pure_bind, Prod.fst, Prod.snd, eq_self],[Eq, StateT.run, Functor.map, Prod.mk, Prod.fst, Prod.snd]]
[Lean.Meta.restoreSynthInstanceCache,[Lean.Meta.modifyCache, Lean.Meta.Cache.mk, Lean.Meta.Cache.inferType, Lean.Meta.Cache.funInfo, Lean.Meta.Cache.whnfDefault, Lean.Meta.Cache.whnfAll, Lean.Meta.Cache.defEqDefault, Lean.Meta.Cache.defEqAll],[Lean.Meta.MetaM, Unit]]
[Lean.Parser.Tactic.deriveReassocProof,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Environment.getProjectionFnInfo?,[Lean.MapDeclarationExtension.find?, Lean.projectionFnInfoExt],[Option, Lean.ProjectionFunctionInfo]]
[Lean.KeyedDeclsAttribute.init,[Bind.bind, liftM, IO.mkRef, Lean.SMap.mk, Lean.registerScopedEnvExtension, Lean.ScopedEnvExtension.Descr.mk, Lean.KeyedDeclsAttribute.Def.name, ST.Ref.get, Pure.pure, Lean.KeyedDeclsAttribute.mkStateOfTable, MonadReader.read, Lean.ImportM, Lean.KeyedDeclsAttribute.AttributeEntry, Lean.Environment.evalConstCheck, Lean.ImportM.Context.env, Lean.ImportM.Context.opts, Lean.KeyedDeclsAttribute.Def.valueTypeName, Lean.KeyedDeclsAttribute.OLeanEntry.declName, Lean.KeyedDeclsAttribute.AttributeEntry.mk, MonadExcept.throw, IO.userError, Lean.KeyedDeclsAttribute.AttributeEntry.toOLeanEntry, Lean.KeyedDeclsAttribute.ExtensionState.insert, ite, Eq, Lean.Name.isAnonymous, Lean.KeyedDeclsAttribute.Def.builtinName, Bool.true, PUnit.unit, Lean.registerBuiltinAttribute, Lean.AttributeImpl.mk, Lean.AttributeImplCore.mk, HAppend.hAppend, Lean.KeyedDeclsAttribute.Def.descr, Lean.AttributeApplicationTime.afterCompilation, BEq.beq, Lean.AttributeKind.global, Lean.throwError, Lean.ToMessageData.toMessageData],[IO, Lean.KeyedDeclsAttribute]]
[instNegFloat,[Neg.mk, Float.neg],[Neg, Float]]
[Lean.Parser.Command.macro.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.suppressInsideQuot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.docComment.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optPrecedence.parenthesizer, Lean.Parser.Command.optNamedName.parenthesizer, Lean.Parser.Command.optNamedPrio.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Command.macroArg.parenthesizer, Lean.Parser.Command.macroTail.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[System.Platform.isWindows,[System.Platform.getIsWindows, Unit.unit],[Bool]]
[«term_∉_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.PrefixTree.forM,[Lean.PrefixTree.forMatchingM, List.nil],[Unit]]
[OptionT.tryCatch,[OptionT.mk, Bind.bind, Option.none, Option, Pure.pure, Option.some, Unit.unit],[OptionT]]
[plift.up_down,[Eq, plift.up, plift.down, rfl],[Eq, plift.up, plift.down]]
[Lean.Elab.Deriving.mkHeader,[Bind.bind, Lean.Elab.Deriving.mkInductArgNames, Lean.Elab.Deriving.mkImplicitBinders, Lean.Elab.Deriving.mkInductiveApp, ForIn.forIn, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Elab.Deriving.mkInstImplicitBinders, Array.mapM, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Lean.mkIdent, List.nil, Lean.Elab.Deriving.Header.mk],[Lean.Elab.Term.TermElabM, Lean.Elab.Deriving.Header]]
[Lean.Parser.Command.structInstBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Command.declModifiers.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.inferMod.parenthesizer, Lean.Parser.Command.declSig.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.SymbolKind.object.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.object, OfNat.ofNat]]
[Lean.Elab.Term.PatternElabException.pathToIndex,[],[List, Nat]]
[Lean.Quote.noConfusionType,[],[]]
[«term_>>=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Meta.SynthInstance.mapMetaM,[MonadFunctorT.monadMap],[Lean.Meta.SynthInstance.SynthM]]
[Lean.Elab.Term.Do.mkAuxDeclFor,[Lean.withRef, Lean.MonadQuotation.withFreshMacroScope, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Lean.Elab.Term.Do.Code.decl],[Lean.Elab.Term.Do.Code]]
[eq_min,[le_antisymm, le_min, min, min_le_left, min_le_right],[Eq, min]]
[not_iff_self,[iff_not_self, Iff.symm],[Not, Iff]]
[Lean.IR.UnreachableBranches.findArgValue,[Lean.IR.Arg.irrelevant, Lean.IR.UnreachableBranches.M, Lean.IR.UnreachableBranches.Value, Lean.IR.UnreachableBranches.findVarValue, Pure.pure, Lean.IR.UnreachableBranches.Value.top],[Lean.IR.UnreachableBranches.M, Lean.IR.UnreachableBranches.Value]]
[Lean.Parser.Command.check.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Tactic.Ring.State.noConfusionType,[],[]]
[Lean.Parser.numLit.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.numLitKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.numLitNoAntiquot.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Server.routeLspRequest,[Bind.bind, ST.Ref.get, Lean.Server.requestHandlers, Pure.pure, Std.PersistentHashMap.find?, Unit.unit, IO, Except, Lean.Server.RequestError, Lean.Lsp.DocumentUri, Except.error, Lean.Server.RequestError.methodNotFound],[IO, Except, Lean.Server.RequestError, Lean.Lsp.DocumentUri]]
[Lean.Parser.Term.binderIdent.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.Term.hole.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.IR.UnreachableBranches.InterpContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.UnreachableBranches.InterpContext.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Attr.macro.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.FieldInfo.lctx,[],[Lean.LocalContext]]
[StdGen.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, StdGen.mk, HAdd.hAdd, OfNat.ofNat]]
[List.inj_on_of_subset,[],[List.inj_on]]
[Nat.lcm_zero_left,[],[Eq, Nat.lcm, OfNat.ofNat]]
[Lean.Elab.Tactic.evalSpecialize,[Lean.Elab.Tactic.withMainContext, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Tactic.elabTermWithHoles, Option.none, Lean.Elab.Tactic.TacticM, Unit, Lean.Expr.isFVar, liftM, Lean.Meta.getLocalDecl, Lean.Expr.fvarId!, Lean.Elab.Tactic.getMainGoal, Lean.Meta.inferType, Lean.Meta.assert, Lean.LocalDecl.userName, Lean.Expr.headBeta, Lean.Meta.intro1P, Lean.Meta.tryClear, Lean.Elab.Tactic.replaceMainGoal, List.cons, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[Lean.instInhabitedPersistentEnvExtensionState,[Inhabited.mk, Lean.PersistentEnvExtensionState.mk, List.toArray, List.nil, arbitrary],[Inhabited, Lean.PersistentEnvExtensionState]]
[Mathlib.ExtendedBinder.extBinderCollection,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.unary, Mathlib.ExtendedBinder.extBinderParenthesized],[Lean.ParserDescr]]
[Lean.LocalDecl.ldecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.LocalDecl.ldecl, HAdd.hAdd, OfNat.ofNat]]
[Lean.Rat.instDecidableLe,[inferInstanceAs, Decidable, Not, LT.lt],[Decidable, LE.le]]
[Lean.Syntax.getAntiquotTerm,[ite, Eq, Lean.Syntax.isIdent, Bool.true, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Syntax]]
[Lean.Parser.longestMatchFnAux.parse,[Unit.unit, Lean.Parser.ParserFn, Lean.Parser.longestMatchMkResult, Lean.Parser.ParserState, PProd.fst],[Lean.Parser.ParserFn]]
[Lean.Elab.Term.isAtomicDiscr?,[cond, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.Term.isLocalIdent?, ite, Eq, Bool.true, Lean.Syntax.isMissing, Lean.Elab.throwAbortTerm, Pure.pure, Option.none],[Lean.Elab.Term.TermElabM, Option, Lean.Expr]]
[Lean.Meta.Closure.State.mk.inj,[And.intro],[And, Eq]]
[Lean.getBuiltinAttributeApplicationTime,[Bind.bind, Lean.getBuiltinAttributeImpl, Pure.pure, Lean.AttributeImplCore.applicationTime, Lean.AttributeImpl.toAttributeImplCore],[IO, Lean.AttributeApplicationTime]]
[USize.decLt,[Decidable, LT.lt, inferInstanceAs],[Decidable, LT.lt]]
[Nat.iterate,[PProd.fst],[]]
[Std.Format.below,[PUnit, PProd],[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.nameNotRoundtrippable,[or, Lean.Name.hasMacroScopes, Lean.isPrivateName, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.nameNotRoundtrippable.containsNum],[Bool]]
[Lean.Core.CoreM.toIO,[Bind.bind, liftM, IO.getNumHeartbeats, EIO.toIO', Lean.Core.CoreM.run, Lean.Core.Context.mk, Lean.Core.Context.options, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.maxHeartbeats, IO, Prod, Lean.Core.State, Lean.MessageData.toString, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Lean.InternalExceptionId.idx, Pure.pure],[IO, Prod, Lean.Core.State]]
[Lean.Parsec.ParseResult.noConfusionType,[],[]]
[Lean.KeyedDeclsAttribute.AttributeEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KeyedDeclsAttribute.AttributeEntry.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KeyedDeclsAttribute.AttributeEntry.mk, And]]
[Lean.LevelMap,[Std.HashMap, Lean.Level],[]]
[Lean.PrettyPrinter.Formatter.withoutForbidden.formatter,[],[Lean.PrettyPrinter.Formatter]]
[Lean.printTraces,[Bind.bind, Lean.MonadTrace.getTraceState, Std.PersistentArray.forM, Lean.TraceState.traces, liftM, Lean.MessageData.format, Lean.TraceElem.msg, IO.println],[Unit]]
[Lean.Meta.Match.Alt.rhs,[],[Lean.Expr]]
[Std.HashMap.findD,[Option.getD, Std.HashMap.find?],[]]
[Lean.LocalInstance.fvar,[],[Lean.Expr]]
[Lean.Meta.addCongrLemmaEntry,[Lean.Meta.CongrLemmas.mk, Unit.unit, Lean.SMap, Lean.Name, List, Lean.Meta.CongrLemma, Lean.SMap.find?, Lean.Meta.CongrLemmas.lemmas, Lean.Meta.CongrLemma.funName, Lean.SMap.insert, List.cons, List.nil, Lean.Meta.addCongrLemmaEntry.insert],[Lean.Meta.CongrLemmas]]
[Lean.IR.instInhabitedLiveVarSet,[Inhabited.mk, EmptyCollection.emptyCollection],[Inhabited, Lean.IR.LiveVarSet]]
[Lean.MetavarContext.getLevelDepth,[Unit.unit, Nat, Lean.MetavarContext.findLevelDepth?, panicWithPosWithDecl, OfNat.ofNat],[Nat]]
[Lean.Lsp.SaveOptions.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.SaveOptions.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.SaveOptions.mk]]
[Lean.Lsp.ServerCapabilities.declarationProvider,[],[Bool]]
[Lean.Elab.Term.resolveName',[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Elab.Term.TermElabM, List, Prod, Lean.Expr, Lean.Syntax, Bind.bind, Lean.Elab.Term.resolveName, List.mapM, Pure.pure, Prod.mk, List.head!, List.tail!, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.TermElabM, List, Prod, Lean.Expr, Lean.Syntax]]
[Lean.Meta.mkFreshTypeMVar,[Bind.bind, Lean.Meta.mkFreshLevelMVar, Lean.Meta.mkFreshExprMVar, Option.some, Lean.mkSort],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Elab.Deriving.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Deriving.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Deriving.Context.mk, And]]
[Sum.inr.inj,[],[Eq]]
[UInt64.decLt,[Decidable, LT.lt, inferInstanceAs],[Decidable, LT.lt]]
[Lean.instBEqHeadIndex,[BEq.mk, Lean.HeadIndex.fvar, Lean.HeadIndex.mvar, Lean.HeadIndex.const, Lean.HeadIndex.proj, Lean.HeadIndex.lit, Lean.HeadIndex.sort, Lean.HeadIndex.lam, Lean.HeadIndex.forallE, Unit.unit, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.HeadIndex]]
[Lean.AttrM,[Lean.Core.CoreM],[]]
[UInt16.instSemiringUInt16.proof_2,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt16.zero_def, UInt16.add_def, UInt16.mk, OfNat.ofNat, zero_add, UInt16.val, UInt16.mk_val_eq, eq_self, propext, forall_const, UInt16],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Subtype.ext_val,[Subtype.ext],[Eq]]
[Nat.le_of_le_of_sub_le_sub_right,[Nat.zero_le, Eq.symm, LE.le, Nat.succ, Nat.zero, Nat.not_succ_le_zero, Eq.refl, Nat.succ_le_succ, Nat.le_of_succ_le_succ, Eq.mp, congr, congrArg, Nat.succ_sub_succ],[LE.le]]
[Lean.Elab.Term.MatchAltView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.MatchAltView.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.Parenthesizer.many1NoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.manyNoAntiquot.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.AttributeExtensionOLeanEntry.decl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.AttributeExtensionOLeanEntry.decl, HAdd.hAdd, OfNat.ofNat]]
[Lean.Core.restore,[modify, Lean.Core.State.mk, Lean.Core.State.env, Lean.Core.State.nextMacroScope, Lean.Core.State.ngen, Lean.Core.State.traceState],[Lean.Core.CoreM, Unit]]
[Lean.Elab.Term.commitIfDidNotPostpone,[Bind.bind, Lean.Elab.Term.observing, Lean.Elab.Term.applyResult],[Lean.Elab.Term.TermElabM]]
[Lean.Lsp.Ipc.readMessage,[Bind.bind, Lean.Lsp.Ipc.stdout, liftM, IO.FS.Stream.readLspMessage],[Lean.Lsp.Ipc.IpcM, Lean.JsonRpc.Message]]
[«tacticBy_cases__:_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Lsp.Command.noConfusionType,[],[]]
[Lean.Compiler.mkNatEq,[Lean.mkAppN, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.levelOne, List.nil, List.toArray],[Lean.Expr]]
[Nat.gcd_dvd_left,[And.left, Nat.gcd_dvd],[Dvd.dvd, Nat.gcd]]
[Lean.Lsp.WaitForDiagnosticsParams.noConfusionType,[],[]]
[Std.RBTree,[Std.RBMap, Unit],[]]
[Lean.Parser.Term.doForDecl,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.termParser, Lean.Parser.symbol, Lean.Parser.withForbidden],[Lean.Parser.Parser]]
[Std.RBNode.balance2,[Std.RBNode.leaf, Std.RBNode.node, Std.Rbcolor.black, Std.Rbcolor.red, Std.RBNode],[Std.RBNode]]
[Lean.Parser.ParserState.setCache,[Lean.Parser.ParserState.mk, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.pos, Lean.Parser.ParserState.errorMsg],[Lean.Parser.ParserState]]
[Lean.Lsp.instFileSourceDidCloseTextDocumentParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.DidCloseTextDocumentParams.textDocument],[Lean.Lsp.FileSource, Lean.Lsp.DidCloseTextDocumentParams]]
[Semiring.toAddCommSemigroup,[],[AddCommSemigroup]]
[Lean.Elab.MonadLog.logMessage,[],[Unit]]
[Lean.Lsp.StaticRegistrationOptions.mk.inj,[],[Eq]]
[Lean.JsonRpc.instCoeStringRequestID,[Coe.mk, Lean.JsonRpc.RequestID.str],[Coe, String, Lean.JsonRpc.RequestID]]
[Lean.PrefixTree.forMatchingM,[Lean.PrefixTreeNode.foldMatchingM, Subtype.val, Unit.unit],[Unit]]
[Lean.getParentStructures,[Array.foldl, Unit.unit, Array, Lean.Name, Lean.isSubobjectField?, Array.push, List.toArray, List.nil, OfNat.ofNat, Array.size],[Array, Lean.Name]]
[Option.any,[Unit.unit, Bool, Bool.false],[Bool]]
[Lean.Meta.NormNum.instLawfulZero.proof_1,[Lean.Meta.NormNum.LawfulZero.mk, rfl],[Lean.Meta.NormNum.LawfulZero]]
[Lean.Parser.registerBuiltinDynamicParserAttribute,[Lean.registerBuiltinAttribute, Lean.Parser.mkParserAttributeImpl],[IO, Unit]]
[Lean.TraceState.traces,[],[Std.PersistentArray, Lean.TraceElem]]
[Lean.Meta.Closure.State.visitedLevel,[],[Lean.LevelMap, Lean.Level]]
[Lean.Meta.RecursorInfo.recursive,[],[Bool]]
[Lean.Parser.Term.bracketedBinder.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.PrettyPrinter.Parenthesizer.evalInsideQuot.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Option.Decl.descr,[],[String]]
[Mathlib.Eval.evalTerm,[Bind.bind, Lean.Elab.Term.elabTermEnsuringType, Option.some, Bool.true, Option.none, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Bool.false, liftM, Lean.Meta.instantiateMVars, Lean.Meta.getMVars, Lean.Elab.Term.logUnassignedUsingErrorInfos, ite, Eq, Lean.Elab.throwAbortTerm, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElabM]]
[IsAddLeftCancel.add_left_cancel,[],[Eq]]
[Lean.Parser.Command.printAxioms,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.ident],[Lean.Parser.Parser]]
[Lean.Elab.Deriving.Header.mk.inj,[And.intro],[And, Eq]]
[Lean.PrettyPrinter.Parenthesizer.notFollowedBy.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.LineRange.end,[],[Nat]]
[Lean.IR.EmitC.emitVDecl,[Lean.IR.EmitC.M, Unit, Lean.IR.EmitC.emitCtor, Lean.IR.EmitC.emitReset, Lean.IR.EmitC.emitReuse, Lean.IR.EmitC.emitProj, Lean.IR.EmitC.emitUProj, Lean.IR.EmitC.emitSProj, Lean.IR.EmitC.emitFullApp, Lean.IR.EmitC.emitPartialApp, Lean.IR.EmitC.emitApp, Lean.IR.EmitC.emitBox, Lean.IR.EmitC.emitUnbox, Lean.IR.EmitC.emitIsShared, Lean.IR.EmitC.emitIsTaggedPtr, Lean.IR.EmitC.emitLit],[Lean.IR.EmitC.M, Unit]]
[iff_false_right,[Iff.trans, Iff.comm, iff_false_left],[Iff, Not]]
[Lean.Parser.Term.cdot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HOrElse.hOrElse, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Parser.numLit.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.numLitKind, Bool.true, Lean.PrettyPrinter.Formatter.numLitNoAntiquot.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.NameSanitizerState.noConfusionType,[],[]]
[Lean.Parser.Command.macro_rules.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.suppressInsideQuot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.docComment.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.optKind.parenthesizer, Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[IO.Process.StdioConfig.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Process.StdioConfig.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Process.StdioConfig.mk, And]]
[Lean.Meta.Match.Example.underscore.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.Match.Example.underscore, OfNat.ofNat]]
[Lean.Elab.Term.Do.Code.ite.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.Code.ite, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.doSeqIndent.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.many1Indent.parenthesizer, Lean.Parser.Term.doSeqItem.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Server.Snapshots.parseAhead,[Lean.Server.Snapshots.Snapshot.mpState, List.toArray, List.nil, Lean.Server.Snapshots.parseAhead.go],[IO, Array, Lean.Syntax]]
[Lean.IR.Decl.uniqueIds,[StateT.run', Lean.IR.UniqueIds.checkDecl, EmptyCollection.emptyCollection],[Bool]]
[instReprIterator,[Repr.mk, Std.Format, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg],[Repr, String.Iterator]]
[Lean.Server.Watchdog.FileWorker.groupedEditsRef,[],[IO.Ref, Option, Lean.Server.Watchdog.GroupedEdits]]
[Array.qsort,[Array.qsort.sort],[Array]]
[Lean.Elab.Info.range?,[Lean.Syntax.getRange?, Lean.Elab.Info.stx, Bool.true],[Option, String.Range]]
[Lean.MessageLog.add,[Lean.MessageLog.mk, Std.PersistentArray.push, Lean.MessageLog.msgs],[Lean.MessageLog]]
[Lean.Lsp.SemanticTokensOptions.legend,[],[Lean.Lsp.SemanticTokensLegend]]
[Lean.Parser.satisfyFn,[ite, Eq, String.atEnd, Lean.Parser.InputContext.input, Lean.Parser.ParserContext.toInputContext, Bool.true, Lean.Parser.ParserState.mkEOIError, List.nil, String.get, Lean.Parser.ParserState.next, Lean.Parser.ParserState.mkUnexpectedError],[Lean.Parser.ParserFn]]
[Lean.AxiomVal.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.implicitBinder,[Lean.Parser.ppGroup, Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.Term.binderIdent, Lean.Parser.Term.binderType],[Lean.Parser.Parser]]
[Lean.Parser.Tactic.guardExprEq',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Elab.Term.Quotation.withNewLocal,[MonadWithReader.withReader, Lean.Elab.Term.Quotation.Precheck.Context.mk, Lean.NameSet.insert, Lean.Elab.Term.Quotation.Precheck.Context.quotLCtx],[Lean.Elab.Term.Quotation.PrecheckM]]
[Lean.Parser.Command.«termExpandBinders%(__=>_)_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.cat, Lean.explicitBinders],[Lean.ParserDescr]]
[USize.instSemiringUSize.proof_7,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, USize.one_def, USize.mul_def, USize.mk, OfNat.ofNat, one_mul, USize.val, USize.mk_val_eq, eq_self, propext, forall_const, USize],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Meta.DiscrTree.Key.const.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.DiscrTree.Key.const, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.DiscrTree.Key.const, And]]
[Lean.Lsp.CompletionOptions.resolveProvider,[],[Bool]]
[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.mk, HAdd.hAdd, OfNat.ofNat]]
[Id.instMonadId,[Monad.mk],[Monad, Id]]
[Std.PersistentArray.mul2Shift,[USize.shiftLeft],[USize]]
[Lean.MetavarKind.noConfusionType,[noConfusionTypeEnum, Lean.MetavarKind.toCtorIdx],[]]
[List.card_append_disjoint,[Eq, List.card, HAppend.hAppend, HAdd.hAdd, of_eq_true, Eq.trans, congr, congrArg, List.nil_append, congrFun, List.card_nil, Nat.zero_add, eq_self],[Eq, List.card, HAppend.hAppend, HAdd.hAdd]]
[Std.RBMap.toList,[List, Prod, Std.RBNode.revFold, List.cons, Prod.mk, List.nil],[List, Prod]]
[«term{__:_//_}»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Nat.prod_dvd_and_dvd_of_dvd_prod,[Nat.gcd, Nat.prod_dvd_and_dvd_of_dvd_prod.proof_1, Nat.prod_dvd_and_dvd_of_dvd_prod.proof_2, Nat.prod_dvd_and_dvd_of_dvd_prod.proof_4],[Subtype, Eq, HMul.hMul, Subtype.val, Prod.fst, Prod.snd]]
[Lean.MetavarKind.syntheticOpaque.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.MetavarKind.syntheticOpaque, OfNat.ofNat]]
[Mathlib.Tactic.Lint.isSimpEq,[Lean.Meta.withReducible, ite, Eq, Bool.true, Bind.bind, Lean.Meta.whnf, Pure.pure],[Lean.Meta.MetaM, Bool]]
[Nat.sub_add_cancel,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HSub.hSub, Nat.add_comm, Nat.add_sub_of_le, rfl],[Eq, HAdd.hAdd, HSub.hSub]]
[Lean.Parser.Term.ident.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.many,[Lean.Parser.manyNoAntiquot, Lean.Parser.withAntiquotSpliceAndSuffix, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Parser.Term.doUnless.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.withForbidden.formatter, Lean.Parser.termParser.formatter, Lean.Parser.Term.doSeq.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Command.noncomputable.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Nat.mul_le_mul,[Nat.le_trans, Nat.mul_le_mul_right, Nat.mul_le_mul_left],[LE.le, HMul.hMul]]
[Lean.Elab.syntaxNodeKindOfAttrParam,[Bind.bind, Lean.Attribute.Builtin.getId, HOrElse.hOrElse, Lean.Elab.checkSyntaxNodeKindAtCurrentNamespaces, Lean.Elab.checkSyntaxNodeKind, HAppend.hAppend, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.AttrM, Lean.SyntaxNodeKind]]
[Lean.Elab.Tactic.Conv.evalDelta,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.resolveGlobalConstNoOverload, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.Conv.getLhs, liftM, Lean.Meta.deltaExpand, BEq.beq, Lean.Elab.Tactic.Conv.changeLhs],[Lean.Elab.Tactic.Tactic]]
[Lean.KVMap.instForInKVMapProdNameDataValue,[ForIn.mk, Lean.KVMap.forIn],[ForIn, Lean.KVMap, Prod, Lean.Name, Lean.DataValue]]
[List.not_bex_nil,[False],[Not, Exists, And, Mem.mem, List.nil]]
[Lean.Meta.ReduceMatcherResult.stuck.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.ReduceMatcherResult.stuck, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.AliasValue.binary.inj,[],[Eq]]
[Lean.Meta.Simp.simp.cacheResult,[ite, Eq, Lean.Meta.Simp.Config.memoize, Bool.true, Bind.bind, modify, Lean.Meta.Simp.State.mk, Std.HashMap.insert, Lean.Meta.Simp.State.cache, Lean.Meta.Simp.State.numSteps, Pure.pure, PUnit.unit],[Lean.Meta.Simp.M, Lean.Meta.Simp.Result]]
[Lean.DeclarationRanges.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.DeclarationRanges.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.DataValue.ofInt.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.DataValue.ofInt, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.declValEqns,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.Term.matchAltsWhereDecls],[Lean.Parser.Parser]]
[Std.ShareCommon.PersistentState.inhabited,[Inhabited.mk, Std.ShareCommon.PersistentState.empty],[Inhabited, Std.ShareCommon.PersistentState]]
[Lean.strLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Lean.Syntax.node.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, Eq.refl, List.nil, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Syntax.node, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.SymbolKind.array.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.array, OfNat.ofNat]]
[Lean.IR.instInhabitedParam,[Inhabited.mk, Lean.IR.Param.mk, arbitrary],[Inhabited, Lean.IR.Param]]
[Lean.Expr.getAppRevArgs,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Array, Lean.Expr, PProd.fst, Array.push, Array.mkEmpty, Lean.Expr.getAppNumArgs],[Array, Lean.Expr]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk.inj,[And.intro],[And, Eq]]
[HEq.rfl.proof_1,[HEq.refl],[HEq]]
[Lean.modToFilePath,[System.FilePath.withExtension, Lean.modToFilePath.go],[System.FilePath]]
[Lean.Lsp.PlainGoal.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.SimpEntry.toUnfold.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.SimpEntry.toUnfold, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SimpEntry.toUnfold]]
[left_neg_eq_right_neg,[Eq.mpr, Eq.refl, Eq, Eq.symm, zero_add, HAdd.hAdd, OfNat.ofNat, add_assoc, add_zero, rfl],[Eq]]
[Nat.mul_mod_mul_right,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HMul.hMul, Nat.mul_comm, Nat.mul_mod_mul_left],[Eq, HMod.hMod, HMul.hMul]]
[Function.injective_of_partial_inv,[Option.some.inj, Eq.trans, Eq.symm, Iff.mpr, rfl],[Function.injective]]
[Lean.Parser.sepBy1Fn,[Bool.false],[Lean.Parser.ParserFn]]
[Lean.Meta.IndPredBelow.mkContext.mkIndValConst,[Lean.mkConst, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, List.map, Lean.mkLevelParam, Lean.ConstantVal.levelParams],[Lean.Expr]]
[IO.Process.StdioConfig.noConfusionType,[],[]]
[IO.setRandSeed,[ST.Ref.set, IO.stdGenRef, mkStdGen],[IO, Unit]]
[Lean.Parser.argPrec,[OfNat.ofNat],[Nat]]
[tacticTransitivity__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Meta.SimpLemma.proof,[],[Lean.Expr]]
[Lean.Meta.SynthInstance.getResult,[Bind.bind, MonadState.get, Pure.pure, Lean.Meta.SynthInstance.State.result?],[Lean.Meta.SynthInstance.SynthM, Option, Lean.Meta.AbstractMVarsResult]]
[Array.toArrayLit,[List.toArray, Array.toListLitAux, Array.toArrayLit.proof_1, List.nil],[Array]]
[Lean.Elab.Command.expandDeclIdNamespace?,[Option, Prod, Lean.Name, Lean.Syntax, Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Lean.MacroScopesView.name, Option.none, ite, Eq, Lean.Syntax.isIdent, Bool.true, Option.some, Prod.mk, Lean.mkIdentFrom, Lean.Syntax.setArg, OfNat.ofNat],[Option, Prod, Lean.Name, Lean.Syntax]]
[Lean.Meta.Config.trackZeta,[],[Bool]]
[OptionT.orElse,[OptionT.mk, Bind.bind, Option.none, Option, Pure.pure, Option.some, Unit.unit],[OptionT]]
[Lean.Elab.Term.elabCompletion,[ite, Eq, Lean.Syntax.isIdent, Lean.Syntax.getOp, OfNat.ofNat, Bool.true, Bind.bind, Lean.MonadBacktrack.saveState, MonadExcept.tryCatch, Lean.Elab.Term.elabTerm, Option.none, Lean.Elab.Term.addDotCompletionInfo, Lean.Elab.Term.SavedState.restore, Bool.false, Lean.MonadLCtx.getLCtx, Lean.Elab.addCompletionInfo, Lean.Elab.CompletionInfo.id, Lean.Syntax.getId, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, Lean.Elab.Term.elabPipeCompletion],[Lean.Elab.Term.TermElab]]
[Lean.Meta.IndPredBelow.mkBelowDecl,[Bind.bind, Array.mapIdxM, Lean.Meta.IndPredBelow.Context.typeInfos, Lean.Meta.IndPredBelow.mkInductiveType, Pure.pure, Lean.Declaration.inductDecl, HAdd.hAdd, Lean.Meta.IndPredBelow.Context.numParams, Array.size, Lean.Meta.IndPredBelow.Context.motives, Array.toList, Lean.InductiveVal.isUnsafe, Array.getOp, OfNat.ofNat],[Lean.Meta.MetaM, Lean.Declaration]]
[instDecidableXor.proof_1,[False],[False]]
[Lean.Parser.Term.doReassignArrow.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.notFollowedByRedefinedTermToken.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.doIdDecl.formatter, Lean.Parser.Term.doPatDecl.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Term.falseVal,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.nonReservedSymbol, Bool.false],[Lean.Parser.Parser]]
[List.forall_mem_of_forall_mem_cons,[And.right, Iff.mp, List.forall_mem_cons],[]]
[instOfNatNat,[OfNat.mk],[OfNat, Nat]]
[Lean.instInhabitedConstructorVal,[Inhabited.mk, Lean.ConstructorVal.mk, arbitrary],[Inhabited, Lean.ConstructorVal]]
[instShiftLeftUInt16,[ShiftLeft.mk, UInt16.shiftLeft],[ShiftLeft, UInt16]]
[Std.rbtreeOf,[Std.RBTree.fromList],[Std.RBTree]]
[Lean.Parser.Term.argument.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkWsBefore.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.namedArgument.parenthesizer, Lean.Parser.Term.ellipsis.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.argPrec],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Syntax.SepArray.elemsAndSeps,[],[Array, Lean.Syntax]]
[Lean.Parser.Term.show.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.fromTerm.formatter, Lean.Parser.Term.byTactic.formatter],[Lean.PrettyPrinter.Formatter]]
[floatDecLt,[Float.decLt],[Decidable, LT.lt]]
[Lean.PrettyPrinter.Formatter.interpretParserDescr,[Lean.Core.CoreM, Lean.PrettyPrinter.Formatter, liftM, Lean.Parser.getConstAlias, Lean.PrettyPrinter.Formatter.formatterAliasesRef, Bind.bind, Lean.Parser.getUnaryAlias, Lean.PrettyPrinter.Formatter.interpretParserDescr, Pure.pure, Lean.Parser.getBinaryAlias, Lean.PrettyPrinter.Formatter.node.formatter, Lean.Parser.sepBy.formatter, Lean.Parser.sepBy1.formatter, Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.ParserCompiler.CombinatorAttribute.runDeclFor, Lean.PrettyPrinter.combinatorFormatterAttribute, Lean.PrettyPrinter.Formatter.categoryParser.formatter],[Lean.Core.CoreM, Lean.PrettyPrinter.Formatter]]
[Lean.mkNode,[Lean.Syntax.node, Lean.SourceInfo.none],[Lean.Syntax]]
[Lean.Xml.Parser.ETag,[SeqRight.seqRight, Lean.Parsec.skipString, Lean.Xml.Parser.Name, optional, Lean.Xml.Parser.S, Lean.Parsec.skipChar, Char.ofNat],[Lean.Parsec, Unit]]
[Lean.Server.FileWorker.handleRpcKeepAlive,[Bind.bind, MonadState.get, Unit.unit, Lean.Server.FileWorker.WorkerM, Unit, Std.RBMap.find?, Lean.Server.FileWorker.WorkerState.rpcSessions, Lean.Lsp.RpcKeepAliveParams.sessionId, Pure.pure, PUnit.unit, ST.Ref.get, liftM, Lean.Server.FileWorker.RpcSession.keptAlive, ST.Ref.set],[Lean.Server.FileWorker.WorkerM, Unit]]
[UInt64.sub,[UInt64.mk, HSub.hSub, UInt64.val],[UInt64]]
[forall_and_distrib,[Iff.intro, And.intro, And.left, And.right, And],[Iff, And]]
[Nat.mul_pred_left,[Eq, HMul.hMul, Nat.pred, HSub.hSub, of_eq_true, Eq.trans, congr, congrArg, congrFun, Nat.pred_zero, Nat.zero_mul, Nat.zero_sub, eq_true_of_decide, Eq.refl, Bool.true, Eq.mpr, HAdd.hAdd, OfNat.ofNat, Nat.pred_succ, Nat.succ_mul, Nat.add_sub_cancel, rfl],[Eq, HMul.hMul, Nat.pred, HSub.hSub]]
[Lean.Parser.Term.doSeqItem,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.ppLine, Lean.Parser.doElemParser, Lean.Parser.optional, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.instToExprNat,[Lean.ToExpr.mk, Lean.mkNatLit, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.ToExpr, Nat]]
[Int.neg_inj,[Eq.mpr, Eq.refl, Eq, Eq.symm, Int.neg_neg, Neg.neg, rfl],[Eq]]
[Nat.succ_mul,[rfl, Eq.mpr, Eq.refl, Eq, HMul.hMul, Nat.succ, HAdd.hAdd, Nat.mul_succ, Nat.add_succ, Nat.add_right_comm],[Eq, HMul.hMul, Nat.succ, HAdd.hAdd]]
[Lean.HeadIndex.noConfusionType,[],[]]
[Lean.Elab.Term.withSavedContext,[MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.SavedContext.declName?, Lean.Elab.Term.SavedContext.macroStack, Lean.Elab.Term.Context.currMacroScope, Lean.Elab.Term.Context.mayPostpone, Lean.Elab.Term.SavedContext.errToSorry, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.Term.Context.autoBoundImplicits, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection, withTheReader, Lean.Core.Context, Lean.Core.Context.mk, Lean.Elab.Term.SavedContext.options, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Elab.Term.SavedContext.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats],[Lean.Elab.Term.TermElabM]]
[Lean.Elab.Term.MVarErrorInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.MVarErrorInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Level.Context.noConfusionType,[],[]]
[Lean.Parser.Term.binop.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[optParam_eq,[rfl],[Eq, optParam]]
[Tactic.Ring.evalAtom,[Bind.bind, Tactic.Ring.addAtom, MonadReader.read, liftM, Lean.Meta.mkAppOptM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Option.some, Tactic.Ring.Cache.α, Lean.mkRawNatLit, OfNat.ofNat, Option.none, List.nil, Pure.pure, Tactic.Ring.HornerExpr.const, Tactic.Ring.HornerExpr.xadd', Prod.mk, Tactic.Ring.mkAppCS],[Tactic.Ring.RingM, Prod, Tactic.Ring.HornerExpr, Lean.Expr]]
[PNonScalar.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, PNonScalar.mk, HAdd.hAdd, OfNat.ofNat]]
[not_not_intro,[],[Not]]
[Lean.IR.Expr.uproj.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Expr.uproj, HAdd.hAdd, OfNat.ofNat]]
[Lean.Widget.formatExplicitInfos,[Bind.bind, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, Lean.MonadOptions.getOptions, Lean.Meta.instantiateMVars, Lean.PrettyPrinter.delabCore, Lean.Meta.MetaM, Prod, Std.Format, Std.RBMap, Nat, Lean.Elab.Info, Ord.compare, liftM, Lean.PrettyPrinter.parenthesizeTerm, Lean.PrettyPrinter.formatTerm, Pure.pure, Prod.mk],[Lean.Meta.MetaM, Prod, Std.Format, Std.RBMap, Nat, Lean.Elab.Info, Ord.compare]]
[Lean.Parser.Command.identPrec.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.Parser.optPrecedence.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.Location.mk.inj,[And.intro],[And, Eq]]
[List.decidablePairwise.proof_1,[Eq.refl],[Eq]]
[Lean.replaceFVarIdAtLocalDecl,[ite, Eq, BEq.beq, Lean.LocalDecl.fvarId, Bool.true, Lean.LocalDecl, Lean.LocalDecl.cdecl, Lean.Expr.replaceFVarId, Lean.LocalDecl.ldecl],[Lean.LocalDecl]]
[Lean.Meta.ForEachExpr.M,[Lean.MonadCacheT, Lean.Expr, Unit, Lean.Meta.MetaM],[]]
[ReaderT.instMonadLiftReaderT,[MonadLift.mk],[MonadLift, ReaderT]]
[UInt8.decEq,[Decidable, Eq, dite, Decidable.isTrue, UInt8.decEq.proof_1, Decidable.isFalse, UInt8.decEq.proof_2],[Decidable, Eq]]
[Lean.Parser.satisfySymbolFn,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Lean.Parser.ParserState, Array.back, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.mkErrorsAt, Option.some],[Lean.Parser.ParserFn]]
[Nat.gcd_div,[Eq, Nat.gcd, HDiv.hDiv, Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, OfNat.ofNat, Nat.div_zero, Nat.gcd_zero_right, rfl, Nat.eq_of_mul_eq_mul_right, HMul.hMul, Nat.div_mul_cancel, Nat.dvd_gcd, Eq.symm, Nat.gcd_mul_right],[Eq, Nat.gcd, HDiv.hDiv]]
[Lean.Meta.SynthInstance.Context.maxResultSize,[],[Nat]]
[List.getLast?,[Unit.unit, Option, Option.none, Option.some, List.getLast, List.cons, List.getLast?.proof_1],[Option]]
[«term_&&&_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.MonadMCtx.noConfusionType,[],[]]
[Lean.Meta.Config.assignSyntheticOpaque,[],[Bool]]
[List.not_mem_cons_of_ne_of_not_mem,[absurd, List.eq_or_mem_of_mem_cons, Iff.mpr, not_or, Eq, Mem.mem, And.intro],[Not, Mem.mem, List.cons]]
[Lean.Level.occurs,[Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Bool, or, BEq.beq, PProd.fst, PProd.snd],[Bool]]
[instSemiringFin.proof_3,[Fin.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, Fin.val, Eq.trans, HMul.hMul, Fin.add_def, Fin.mul_def, Fin.mk, HMod.hMod, HAdd.hAdd, Nat.mod_lt, Fin.size_positive, Nat.add_mod_mod, Nat.mod_add_mod, Eq.refl, Eq.symm, Eq.mp, Nat.mul_mod, Nat.mod_eq_of_lt, Fin.isLt, Semiring.mul_add, rfl],[Eq, HMul.hMul, HAdd.hAdd]]
[Lean.Meta.DiscrTree.instInhabitedTrie,[Inhabited.mk, Lean.Meta.DiscrTree.Trie.node, List.toArray, List.nil],[Inhabited, Lean.Meta.DiscrTree.Trie]]
[Lean.SimplePersistentEnvExtensionDescr.noConfusionType,[],[]]
[Lean.mkNoConfusionEnum.mkNoConfusion,[Lean.Meta.withLocalDecl, Lean.Name.mkStr, Lean.Name.anonymous, Lean.BinderInfo.implicit, Bind.bind, Lean.Meta.mkEq, Lean.Meta.withLocalDeclD, Lean.Meta.mkForallFVars, List.toArray, List.cons, List.nil, Lean.mkApp3, Bool.false, Bool.true, Lean.Meta.mkAppOptM, Option.none, Option.some, Lean.Meta.mkLambdaFVars, Lean.addAndCompile, Lean.Declaration.defnDecl, Lean.DefinitionVal.mk, Lean.ConstantVal.mk, Lean.ReducibilityHints.abbrev, Lean.DefinitionSafety.safe],[Lean.Meta.MetaM, Unit]]
[String.revPosOf,[ite, Eq, BEq.beq, String.bsize, OfNat.ofNat, Bool.true, Option.none, String.revPosOfAux, String.prev],[Option, String.Pos]]
[Lean.Parser.Tactic.unfoldAux,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Core.State.nextMacroScope,[],[Lean.MacroScope]]
[Char.instLTChar,[LT.mk, Char.lt],[LT, Char]]
[Nat.add_sub_cancel_left,[],[Eq, HSub.hSub, HAdd.hAdd]]
[EStateM,[EStateM.Result],[]]
[Lean.Elab.Term.levelMVarToParam',[Bind.bind, MonadState.get, liftM, Lean.Elab.Term.levelMVarToParam, StateRefT', IO.RealWorld, Nat, Lean.Elab.Term.TermElabM, Lean.Expr, MonadStateOf.set, Pure.pure],[StateRefT', IO.RealWorld, Nat, Lean.Elab.Term.TermElabM, Lean.Expr]]
[Lean.mkPrivateName,[HAppend.hAppend, Lean.Name.mkNum, Lean.privateHeader, Lean.Environment.mainModule, OfNat.ofNat],[Lean.Name]]
[Lean.Parser.Command.structExplicitBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Command.declModifiers.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.inferMod.parenthesizer, Lean.Parser.Command.optDeclSig.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.binderTactic.parenthesizer, Lean.Parser.Term.binderDefault.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Int.gcd,[Nat.gcd, Int.natAbs],[Nat]]
[Lean.Meta.Simp.tryLemma?,[Lean.Meta.withNewMCtxDepth, Bind.bind, liftM, Lean.Meta.SimpLemma.getValue, Lean.Meta.inferType, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.Simp.SimpM, Option, Lean.Meta.Simp.Result, Lean.Meta.instantiateMVars, Lean.Meta.whnf, ForIn.forIn, MProd.mk, Pure.pure, PUnit.unit, ForInStep.yield, Unit.unit, Option.some, Lean.Meta.Simp.Result.mk, Lean.mkAppN, Lean.Meta.mkCongrFun, Lean.Meta.isDefEq, ite, Eq, Bool.true, Lean.Meta.Simp.synthesizeArgs, Lean.Meta.SimpLemma.getName, Lean.Expr.isMVar, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, OfNat.ofNat, GT.gt, HSub.hSub],[Lean.Meta.Simp.SimpM, Option, Lean.Meta.Simp.Result]]
[Lean.Elab.Command.ElabHeaderResult.noConfusionType,[],[]]
[Lean.IR.EmitC.isTailCall,[Bind.bind, MonadReader.read, Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.fap, Lean.IR.FnBody.vdecl, Lean.IR.FnBody.jdecl, Lean.IR.FnBody.set, Lean.IR.FnBody.setTag, Lean.IR.FnBody.uset, Lean.IR.FnBody.sset, Lean.IR.FnBody.inc, Lean.IR.FnBody.dec, Lean.IR.FnBody.del, Lean.IR.FnBody.mdata, Lean.IR.FnBody.case, Lean.IR.FnBody.ret, Lean.IR.Arg.irrelevant, Lean.IR.FnBody.jmp, Lean.IR.FnBody.unreachable, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Lean.IR.EmitC.M, Bool, Pure.pure, and, BEq.beq, Lean.IR.EmitC.Context.mainFn, Bool.false],[Lean.IR.EmitC.M, Bool]]
[Lean.Elab.FieldInfo.fieldName,[],[Lean.Name]]
[Std.HashMapImp.WellFormed.brecOn,[Std.HashMapImp.WellFormed.below.mkWff, Std.HashMapImp.WellFormed.below.insertWff, Std.HashMapImp.WellFormed.below.eraseWff],[]]
[Nat.decLt,[Nat.decLe, Nat.succ],[Decidable, LT.lt]]
[Lean.IR.HasIndex.visitVar,[BEq.beq, Lean.IR.VarId.idx],[Bool]]
[Lean.Elab.Term.MutualClosure.getModifiersForLetRecs,[Lean.Elab.Modifiers.mk, Array.any, Lean.Elab.Modifiers.isNoncomputable, Lean.Elab.DefViewElabHeader.modifiers, OfNat.ofNat, Array.size, ite, Eq, Lean.Elab.Modifiers.isPartial, Bool.true, Lean.Elab.RecKind.partial, Lean.Elab.RecKind.default, Lean.Elab.Modifiers.isUnsafe],[Lean.Elab.Modifiers]]
[Lean.Parser.ParserContext.toInputContext,[],[Lean.Parser.InputContext]]
[Lean.Parser.Command.elab.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.suppressInsideQuot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.docComment.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optPrecedence.parenthesizer, Lean.Parser.Command.optNamedName.parenthesizer, Lean.Parser.Command.optNamedPrio.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Command.elabArg.parenthesizer, Lean.Parser.Command.elabTail.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.AltCore.ctor.inj,[And.intro],[And, Eq]]
[Lean.Level.param.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Level.param, HAdd.hAdd, OfNat.ofNat]]
[Monad.toBind,[],[Bind]]
[Lean.Meta.Cache.noConfusionType,[],[]]
[Lean.KeyedDeclsAttribute.Def.name,[],[Lean.Name]]
[Lean.Parser.Term.ellipsis.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.SynthInstance.State.tableEntries,[],[Std.HashMap, Lean.Expr, Lean.Meta.SynthInstance.TableEntry]]
[Std.PersistentHashSet.insert,[Std.PersistentHashSet.mk, Std.PersistentHashMap.insert, Std.PersistentHashSet.set, Unit.unit],[Std.PersistentHashSet]]
[FloatArray.instForInFloatArrayFloat,[ForIn.mk, FloatArray.forIn],[ForIn, FloatArray, Float]]
[Lean.Meta.SynthInstance.SubgoalsResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SynthInstance.SubgoalsResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SynthInstance.SubgoalsResult.mk, And]]
[Lean.RecursorRule.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.RecursorRule.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.RecursorRule.mk, And]]
[ExistsUnique.exists,[Exists, Exists.intro],[Exists]]
[Std.RBTree.isEmpty,[Std.RBMap.isEmpty],[Bool]]
[Lean.Option.Decl.noConfusionType,[],[]]
[Lean.Lsp.DocumentSymbol.mk.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.trans, HAdd.hAdd, SizeOf.sizeOf, Eq.refl, Option.none, List.nil, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec, Option.some.sizeOf_spec, Lean.Lsp.DocumentSymbolAux.mk.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Lsp.DocumentSymbol.mk, HAdd.hAdd, OfNat.ofNat]]
[Std.PersistentHashMap.Stats.numNodes,[],[Nat]]
[Lean.ExternEntry.inline.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ExternEntry.inline, HAdd.hAdd, OfNat.ofNat]]
[Ne.elim,[],[False]]
[Lean.KernelException.appTypeMismatch.inj,[And.intro],[And, Eq]]
[Lean.Parser.InputContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.InputContext.mk, HAdd.hAdd, OfNat.ofNat]]
[instToStringSigma,[ToString.mk, String, HAppend.hAppend, ToString.toString],[ToString, Sigma]]
[Lean.Parser.tokenWithAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.tokenWithAntiquotFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.Meta.getCtorNumPropFields,[Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, Bind.bind, ForIn.forIn, Lean.Meta.inferType, Array.getOp, HAdd.hAdd, Lean.ConstructorVal.numParams, Lean.Meta.isProp, ite, Eq, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield],[Lean.Meta.MetaM, Nat]]
[Lean.choiceKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Lean.Expr.isDIte,[Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat],[Bool]]
[Lean.JsonRpc.Message.notification.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonRpc.Message.notification, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.JsonRpc.Message.notification, And]]
[Lean.Lsp.instBEqLocation,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Lsp.Location]]
[Lean.Level.max.inj,[And.intro],[And, Eq]]
[Std.ShareCommon.ObjectPersistentMap,[Std.PersistentHashMap, Std.ShareCommon.Object],[]]
[Lean.Parser.Syntax.atom.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.strLit.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Bind.noConfusionType,[],[]]
[Lean.PrettyPrinter.Parenthesizer.withoutForbidden.parenthesizer,[],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.LazyInitExtension.mk.inj,[And.intro],[And, Eq]]
[Lean.NameMap.insert,[Std.RBMap.insert],[Std.RBMap, Lean.Name, Lean.Name.quickCmp]]
[Function.comp_update,[funext, Function.apply_update],[Eq, Function.comp, Function.update]]
[Lean.Elab.Modifiers.isProtected,[Lean.Elab.Modifiers.mk, Lean.Elab.Visibility.regular, Lean.Elab.Visibility.private, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Syntax.SepArray.noConfusionType,[],[]]
[Lean.Elab.Term.StructInst.CtorHeaderResult.noConfusionType,[],[]]
[Lean.Elab.Modifiers.isPrivate,[Lean.Elab.Modifiers.mk, Lean.Elab.Visibility.regular, Lean.Elab.Visibility.protected, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Elab.Structural.EqnInfo.type,[],[Lean.Expr]]
[Lean.IR.Expr.isTaggedPtr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Expr.isTaggedPtr, HAdd.hAdd, OfNat.ofNat]]
[Nat.div_eq_of_eq_mul_left,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, Nat.mul_div_cancel, rfl],[Eq, HDiv.hDiv]]
[Lean.Parser.ParserExtension.OLeanEntry.kind.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.ParserExtension.OLeanEntry.kind, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.ParserExtension.OLeanEntry.kind]]
[Lean.Parser.Term.doIdDecl.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.Term.optType.parenthesizer, Lean.Parser.Term.leftArrow.parenthesizer, Lean.Parser.doElemParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.KeyedDeclsAttribute.Extension,[Lean.ScopedEnvExtension, Lean.KeyedDeclsAttribute.OLeanEntry, Lean.KeyedDeclsAttribute.AttributeEntry, Lean.KeyedDeclsAttribute.ExtensionState],[]]
[Prod.lexAccessible.proof_1,[Acc.intro, Prod.mk, Eq.symm, eq_of_heq, Eq.refl, HEq.refl],[Acc, Prod.Lex, Prod.mk]]
[Function.left_inverse.surjective,[Function.right_inverse.surjective, Function.left_inverse.right_inverse],[Function.surjective]]
[Lean.instToMessageDataSubarray,[Lean.ToMessageData.mk, Lean.ToMessageData.toMessageData, Array.toList, Subarray.toArray],[Lean.ToMessageData, Subarray]]
[Lean.ppSpace.formatter,[Lean.PrettyPrinter.Formatter.pushLine],[Lean.PrettyPrinter.Formatter]]
[instInhabitedBool,[Inhabited.mk, Bool.false],[Inhabited, Bool]]
[UInt8.ofNatCore,[UInt8.mk, Fin.mk],[UInt8]]
[Lean.Lsp.instBEqDiagnosticCode,[BEq.mk, Lean.Lsp.DiagnosticCode.int, Lean.Lsp.DiagnosticCode.string, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Lsp.DiagnosticCode]]
[Lean.Meta.addCongrLemmaEntry.insert,[Unit.unit, List, Lean.Meta.CongrLemma, List.cons, List.nil, ite, GE.ge, Lean.Meta.CongrLemma.priority, PProd.fst],[List, Lean.Meta.CongrLemma]]
[Lean.IR.FnBody.uset.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.FnBody.uset, HAdd.hAdd, OfNat.ofNat]]
[IO.Error.resourceVanished.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.resourceVanished, HAdd.hAdd, OfNat.ofNat]]
[PUnit.ext,[rfl],[Eq]]
[Ring.add_left_neg,[],[Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat]]
[instOrdUInt64,[Ord.mk, compareOfLessAndEq],[Ord, UInt64]]
[Lean.Elab.Term.StructInst.DefaultFields.State.progress,[],[Bool]]
[List.length_add_eq_lengthTRAux,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Nat.zero_add, eq_self, Eq.mpr, congr, Nat.succ_add, List.length, Eq.symm, Nat.succ, rfl],[Eq, HAdd.hAdd, List.length, List.lengthTRAux]]
[Lean.Meta.Config.noConfusionType,[],[]]
[Lean.Name.isNum,[Lean.Name.anonymous, Lean.Name.str, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Elab.Term.Quotation.elabPrecheckedQuot,[Bind.bind, Lean.Elab.Term.Quotation.runPrecheck, Lean.Syntax.getQuotContent, Lean.Elab.Term.adaptExpander, Pure.pure],[Lean.Elab.Term.TermElab]]
[«term_!=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.JsonNumber.shiftr,[Lean.JsonNumber, Lean.JsonNumber.mk, HAdd.hAdd],[Lean.JsonNumber]]
[UInt16.val_eq_of_lt,[Fin.val_eq_of_lt],[Eq, Fin.val, UInt16.val, UInt16.ofNat]]
[Lean.Elab.Command.StructFieldView.ref,[],[Lean.Syntax]]
[Lean.Meta.mkAuxDefinitionFor,[Bind.bind, Lean.Meta.inferType, Lean.Meta.mkAuxDefinition, Bool.true],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.PrettyPrinter.Formatter.skip.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[Lean.Option.Decl.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Option.Decl.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Option.Decl.mk, And]]
[Lean.levelZero,[Lean.Level.zero, Lean.Level.mkData, OfNat.ofNat, Bool.false],[Lean.Level]]
[Lean.Elab.Term.withSynthesizeLight,[MonadFunctorT.monadMap, Bind.bind, MonadState.get, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, List.nil, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState, tryFinally, Lean.Elab.Term.synthesizeSyntheticMVars, Bool.false, ite, Eq, and, Bool.true, Pure.pure, PUnit.unit, HAppend.hAppend, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.TermElabM],[]]
[Lean.Elab.Deriving.Repr.mkBodyForInduct,[Bind.bind, Lean.Elab.Deriving.mkDiscrs, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.Elab.Deriving.Repr.mkBodyForInduct.mkAlts],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Lean.Parser.Command.optDeriving.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.notSymbol.parenthesizer, Lean.Parser.Command.derivingClasses.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Tactic.existsIntro,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.instToJsonInt,[Lean.ToJson.mk, Lean.Json.num, Lean.JsonNumber.fromInt],[Lean.ToJson, Int]]
[Lean.Lsp.instBEqDiagnosticTag,[BEq.mk, BEq.beq, Lean.Lsp.DiagnosticTag.toCtorIdx],[BEq, Lean.Lsp.DiagnosticTag]]
[ByteSlice.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, ByteSlice.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, ByteSlice.mk, And]]
[Lean.Server.FileWorker.compileHeader,[Bind.bind, Lean.Parser.parseHeader, IO, Prod, Lean.Server.Snapshots.Snapshot, Lean.SearchPath, liftM, IO.getEnv, Unit.unit, Pure.pure, System.FilePath.mk, System.FilePath.pathExists, Option.none, HDiv.hDiv, IO.appDir],[IO, Prod, Lean.Server.Snapshots.Snapshot, Lean.SearchPath]]
[WellFounded.fix',[WellFounded.fix],[]]
[Lean.IR.CtorLayout.scalarSize,[],[Nat]]
[List.append,[List, List.cons, PProd.fst],[List]]
[Lean.Server.RequestM.withWaitFindSnap,[Bind.bind, liftM, IO.AsyncList.waitFind?, Lean.Server.FileWorker.EditableDocument.cmdSnaps, Lean.Server.RequestM.mapTask, Unit.unit, Lean.Server.RequestM, throwThe, Lean.Server.RequestError, Lean.Server.RequestError.fileChanged, MonadExcept.throw, Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.internalError, ToString.toString],[Lean.Server.RequestM, Lean.Server.RequestTask]]
[Lean.Lsp.SymbolKind.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Widget.InfoWithCtx.info,[],[Lean.Elab.Info]]
[Lean.Meta.isUIntPatLit,[Option.isSome, Lean.Meta.isUIntPatLit?],[Bool]]
[Nat.dvd_sub,[Iff.mpr, Nat.dvd_add_iff_left, Eq.mpr, Eq.refl, Dvd.dvd, HAdd.hAdd, HSub.hSub, Nat.sub_add_cancel],[Dvd.dvd, HSub.hSub]]
[Lean.Parser.strLit.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.strLitKind, Bool.true, Lean.PrettyPrinter.Formatter.strLitNoAntiquot.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.instInhabitedConstantInfo,[Inhabited.mk, Lean.ConstantInfo.axiomInfo, arbitrary],[Inhabited, Lean.ConstantInfo]]
[Exists.elim,[],[]]
[Lean.Elab.Term.StructInst.Field.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.StructInst.Field.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.StructInst.Field.mk, And]]
[List.reduceOption,[List.filterMap, id],[List]]
[Std.PersistentArray.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.PersistentArray.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.CompletionList.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.CompletionList.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.instFromJsonWaitForDiagnostics,[Lean.FromJson.mk, Pure.pure, Lean.Lsp.WaitForDiagnostics.mk],[Lean.FromJson, Lean.Lsp.WaitForDiagnostics]]
[List.remove,[Unit.unit, List, List.nil, ite, Eq, PProd.fst, List.cons],[List]]
[Lean.Elab.Tactic.instMonadBacktrackSavedStateTacticM,[Lean.MonadBacktrack.mk, Lean.Elab.Tactic.saveState, Lean.Elab.Tactic.SavedState.restore],[Lean.MonadBacktrack, Lean.Elab.Tactic.SavedState, Lean.Elab.Tactic.TacticM]]
[Lean.Json.CompressWorkItem.arrayEnd.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Json.CompressWorkItem.arrayEnd, OfNat.ofNat]]
[Lean.LocalContext.getFVars,[Array.map, Lean.mkFVar, Lean.LocalContext.getFVarIds],[Array, Lean.Expr]]
[Lean.initializing,[orM, liftM, IO.initializing, ST.Ref.get],[IO, Bool]]
[DoResultSBC.noConfusionType,[],[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.provideds,[],[Array, Bool]]
[Lean.Server.FileWorker.WorkerContext.hOut,[],[IO.FS.Stream]]
[Lean.getPPFullNames,[Lean.KVMap.get, Lean.Option.name, Lean.pp.fullNames, Lean.getPPAll],[Bool]]
[Quot.recOnSubsingleton.proof_1,[Subsingleton.elim, Quot.sound],[Eq, Quot.sound]]
[Lean.Elab.CommandInfo.mk.inj,[],[Eq]]
[Lean.termThrowErrorAt___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.unary],[Lean.ParserDescr]]
[Lean.Expr.bindingBody!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[Lean.Expr.ReplaceImpl.initCache.proof_1,[lcProof],[Eq, Unit, Lean.Expr]]
[Lean.instEval_1,[Lean.Eval.mk, IO.println, repr, Unit.unit],[Lean.Eval]]
[Lean.Meta.collectPrivateIn,[Bind.bind, Lean.getConstInfo, Pure.pure, Lean.Expr.foldConsts, Lean.ConstantInfo.value!, ite, Eq, Lean.isPrivateName, Bool.true, Lean.NameSet.insert],[Lean.NameSet]]
[Lean.Name.beq,[Unit.unit, Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Bool, Bool.true, and, BEq.beq, PProd.fst, Bool.false],[Bool]]
[Lean.TraceState.noConfusionType,[],[]]
[Prod.swap_injective,[Function.left_inverse.injective, Prod.swap_left_inverse],[Function.injective, Prod.swap]]
[Prod.mk.eta,[Eq, Prod.mk, Prod.fst, Prod.snd, rfl],[Eq, Prod.mk, Prod.fst, Prod.snd]]
[ne_self_iff_false,[not_iff_false_intro, rfl],[Iff, Ne, False]]
[USize.zero_def,[rfl],[Eq, OfNat.ofNat, USize.mk]]
[Lean.Meta.SynthInstance.ConsumerNode.mvar,[],[Lean.Expr]]
[Int.subNatNat_elim,[],[Int.subNatNat]]
[Lean.instInhabitedRecursorRule,[Inhabited.mk, Lean.RecursorRule.mk, arbitrary],[Inhabited, Lean.RecursorRule]]
[Nat.decEq.proof_1,[Eq.refl, Nat.beq],[Eq, Nat.beq]]
[Lean.ConstantInfo.axiomInfo.inj,[],[Eq]]
[Lean.Parser.Term.show,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat, HOrElse.hOrElse, Lean.Parser.Term.fromTerm, Lean.Parser.Term.byTactic],[Lean.Parser.Parser]]
[Char.val_ne_of_ne,[absurd, Char.eq_of_val_eq],[Not, Eq, Char.val]]
[Lean.Parser.Syntax.sepBy.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.syntaxParser.parenthesizer, Lean.Parser.strLit.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Std.PersistentHashMap.Node.entries.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.trans, Eq.refl, SizeOf.sizeOf, List.nil, congr, Std.PersistentHashMap.Entry.entry, Std.PersistentHashMap.Entry.ref, Std.PersistentHashMap.Entry.null, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec],[Eq, SizeOf.sizeOf, Std.PersistentHashMap.Node.entries, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.WaitForDiagnostics.noConfusion,[noConfusionEnum, Lean.Lsp.WaitForDiagnostics.toCtorIdx],[Lean.Lsp.WaitForDiagnostics.noConfusionType]]
[Lean.Elab.Tactic.withMacroExpansion,[Lean.Elab.withMacroExpansionInfo, withTheReader, Lean.Elab.Term.Context, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.Context.declName?, List.cons, Lean.Elab.MacroStackElem.mk, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.currMacroScope, Lean.Elab.Term.Context.mayPostpone, Lean.Elab.Term.Context.errToSorry, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.Term.Context.autoBoundImplicits, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection],[Lean.Elab.Tactic.TacticM]]
[Functor.map,[],[]]
[UInt8.add,[UInt8.mk, HAdd.hAdd, UInt8.val],[UInt8]]
[StateT.run_monadLift,[rfl],[Eq, StateT.run, MonadLiftT.monadLift, Bind.bind, Pure.pure, Prod.mk]]
[MonoidWithZero.toMonoid,[],[Monoid]]
[Lean.Syntax.isQuot,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Syntax.atom, Lean.Syntax.ident, Bool, Bool.true, Bool.false],[Bool]]
[Lean.SMap.map₂,[],[Std.PHashMap]]
[Lean.Syntax.hasMissing,[Id.run, Bind.bind, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, Unit.unit, Id, Bool, MProd.fst, Pure.pure],[Bool]]
[Lean.Elab.Deriving.Ord.mkOrdInstanceHandler,[Bind.bind, Array.allM, Lean.isInductive, OfNat.ofNat, Array.size, ite, Eq, and, Decidable.decide, GT.gt, Bool.true, Lean.Elab.Command.liftTermElabM, Option.none, Lean.Elab.Deriving.mkContext, Array.getOp, Lean.Elab.Deriving.Ord.mkMutualBlock, Lean.Elab.Deriving.mkInstanceCmds, Lean.Name.mkStr, Lean.Name.anonymous, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Array.forM, Lean.Elab.Command.elabCommand, Bool.false],[Lean.Elab.Command.CommandElabM, Bool]]
[Lean.Xml.Parser.children,[SeqLeft.seqLeft, HOrElse.hOrElse, Lean.Xml.Parser.choice, Lean.Xml.Parser.seq, optional, Lean.Parsec.skipChar, Char.ofNat],[Lean.Parsec, Unit]]
[BaseIO.mapTasks.go,[BaseIO, Task, BaseIO.bindTask, PProd.fst, List.cons, BaseIO.asTask, List.reverse],[BaseIO, Task]]
[ToStream.toStream,[],[]]
[Lean.mkEmptyEnvironment,[Bind.bind, liftM, IO.initializing, ite, Eq, Bool.true, MonadExcept.throw, IO.userError, Pure.pure, PUnit.unit],[IO, Lean.Environment]]
[Repr.addAppParen,[ite, GE.ge, OfNat.ofNat, Std.Format.paren],[Std.Format]]
[Lean.Parser.Command.optDeriving.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.notSymbol.formatter, Lean.Parser.Command.derivingClasses.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Tactic.nlinarith,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy],[Lean.ParserDescr]]
[List.forM_cons,[rfl],[Eq, ForM.forM, List.cons, Bind.bind]]
[Lean.IR.UnreachableBranches.InterpContext.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.bracketedBinder.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.none, Bool.false, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.explicitBinder.formatter, Lean.Parser.Term.strictImplicitBinder.formatter, Lean.Parser.Term.implicitBinder.formatter, Lean.Parser.Term.instBinder.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.TextDocumentSyncKind.toCtorIdx,[OfNat.ofNat],[Nat]]
[UInt32.ofNatCore,[UInt32.mk, Fin.mk],[UInt32]]
[Lean.Elab.Term.StructInst.DefaultFields.getFieldName,[List.nil, List.cons, Lean.Elab.Term.StructInst.FieldLHS.fieldName, Lean.Elab.Term.StructInst.FieldLHS.fieldIndex, Lean.Elab.Term.StructInst.FieldLHS.modifyOp, Lean.Name, Lean.Elab.Term.StructInst.Field.lhs, panicWithPosWithDecl, OfNat.ofNat],[Lean.Name]]
[Lean.Lsp.WorkDoneProgressEnd.kind,[],[String]]
[Lean.Server.foldDocumentChanges,[Array.foldl, Lean.Server.applyDocumentChange, OfNat.ofNat, Array.size],[Lean.FileMap]]
[Lean.NamePart.lt,[Lean.NamePart.str, Lean.NamePart.num, Bool, Decidable.decide, LT.lt, Bool.true, Bool.false],[Bool]]
[Lean.Parser.getTokenTable,[Lean.Parser.ParserExtension.State.tokens, Lean.ScopedEnvExtension.getState, Lean.Parser.parserExtension],[Lean.Parser.TokenTable]]
[UInt64.shiftRight,[UInt64.mk, HShiftRight.hShiftRight, UInt64.val, UInt64.modn, OfNat.ofNat],[UInt64]]
[Lean.Lsp.WorkDoneProgressBegin.noConfusionType,[],[]]
[Lean.Meta.modifyTargetEqLHS,[Lean.Meta.modifyTarget, Bind.bind, Lean.Meta.matchEq?, Option.none, Lean.Meta.MetaM, Lean.Expr, Lean.Meta.mkEq, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Syntax.missing],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.Lsp.DidChangeTextDocumentParams.noConfusionType,[],[]]
[Lean.Elab.Command.StructFieldInfo.declName,[],[Lean.Name]]
[Lean.Export.State.levels,[],[Lean.Export.Alloc, Lean.Level]]
[Lean.Parser.Level.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.levelParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.InfoState.enabled,[],[Bool]]
[Lean.Elab.InfoTree.goalsAt?,[Id.run, Lean.Elab.InfoTree.deepestNodes, Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofTermInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.Info.ofCompletionInfo, Option, Lean.Elab.GoalsAtResult, OptionM.run, Prod.mk, Option.none, Option.some, OptionM, Lean.Elab.Info.pos?, Lean.Elab.Info.tailPos?, Bind.bind, guard, And, LE.le, Eq, or, Decidable.decide, LT.lt, HAdd.hAdd, Bool.true, Pure.pure, Lean.Elab.GoalsAtResult.mk, and, GT.gt, GE.ge, not, Std.PersistentArray.any, Alternative.failure, Lean.Elab.InfoTree.goalsAt?.hasNestedTactic],[List, Lean.Elab.GoalsAtResult]]
[Prod.exists',[Prod.exists],[Iff, Exists, Prod.fst, Prod.snd]]
[decidable_eq_of_bool_pred,[dite, Eq, Bool.true, Decidable.isTrue, Decidable.isFalse, decidable_eq_of_bool_pred.proof_1],[DecidableEq]]
[Std.Format.nest.inj,[And.intro],[And, Eq]]
[Lean.Xml.Parser.CharRef,[Bind.bind, Lean.Parsec.skipString, HOrElse.hOrElse, Functor.map, Lean.Xml.Parser.digitsToNat, OfNat.ofNat, Lean.Parsec.many1, Lean.Xml.Parser.hexDigitToNat, Lean.Parsec.digit, SeqRight.seqRight, Lean.Parsec.skipChar, Char.ofNat, Lean.Parsec.hexDigit, Pure.pure],[Lean.Parsec, Lean.Xml.Parser.LeanChar]]
[Lean.Unhygienic.run,[StateT.run', Lean.Unhygienic.Context.mk, Lean.Syntax.missing, Lean.firstFrontendMacroScope, HAdd.hAdd, OfNat.ofNat],[]]
[Lean.Meta.MatcherApp.motive,[],[Lean.Expr]]
[Lean.Elab.Command.elabCheckCore,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.withoutModifyingEnv, Lean.Elab.Command.runTermElabM, Option.some, Bind.bind, Lean.Elab.Term.elabTerm, Option.none, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, liftM, Lean.Meta.instantiateMVars, Lean.Elab.Term.levelMVarToParam, OfNat.ofNat, Lean.Elab.Term.TermElabM, Unit, Lean.Meta.inferType, Lean.Expr.isSyntheticSorry, Pure.pure, PUnit.unit, Lean.Elab.logInfoAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Lean.Lsp.instToJsonRpcRef,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.RpcRef.p, List.nil],[Lean.ToJson, Lean.Lsp.RpcRef]]
[Lean.Elab.Deriving.DecEq.mkEnumOfNat,[Bind.bind, Lean.getConstInfoInduct, Lean.Meta.withLocalDeclD, Lean.Name.mkStr, Lean.Name.anonymous, Lean.mkConst, List.nil, Lean.Meta.mkLambdaFVars, List.toArray, List.cons, OfNat.ofNat, Array.size, Bool.false, Bool.true, Lean.Meta.mkArrow, Lean.addAndCompile, Lean.Declaration.defnDecl, Lean.DefinitionVal.mk, Lean.ConstantVal.mk, Lean.ReducibilityHints.abbrev, Lean.DefinitionSafety.safe, Lean.Elab.Deriving.DecEq.mkEnumOfNat.mkDecTree],[Lean.Meta.MetaM, Unit]]
[Lean.Parser.Attr.intro,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Core.Context.ref,[],[Lean.Syntax]]
[ByteSliceT.getOp,[ByteArray.get!, ByteSliceT.arr, HAdd.hAdd, ByteSliceT.off],[UInt8]]
[List.rangeAux,[List, Nat, PProd.fst, List.cons],[List, Nat]]
[Lean.PrettyPrinter.Formatter.categoryParser.formatter,[Lean.PrettyPrinter.Formatter.group, Lean.PrettyPrinter.Formatter.indent, Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.ofFormat, Std.ToFormat.format, Pure.pure, PUnit.unit, Option.none],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.RewriteResult.noConfusionType,[],[]]
[Lean.Elab.Term.LVal.fieldName.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.LVal.fieldName, HAdd.hAdd, OfNat.ofNat]]
[Lean.NamePart.str.injEq,[Eq.propIntro, Eq.refl, Lean.NamePart.str, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.NamePart.str]]
[IO.FS.Stream.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Command.axiom.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.Command.declSig.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Info.toElabInfo?,[Option, Lean.Elab.ElabInfo, Option.some, Lean.Elab.TacticInfo.toElabInfo, Lean.Elab.TermInfo.toElabInfo, Lean.Elab.CommandInfo.toElabInfo, Option.none],[Option, Lean.Elab.ElabInfo]]
[Lean.Elab.Term.Do.getDoHaveVar,[ite, Eq, Lean.Syntax.isNone, Bool.true, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.getId, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Name]]
[Lean.Lsp.InitializationOptions.editDelay?,[],[Option, Nat]]
[UInt32.add,[UInt32.mk, HAdd.hAdd, UInt32.val],[UInt32]]
[Function.cantor_injective,[Function.cantor_surjective, Function.right_inverse.surjective, funext, propext, Iff.intro, rfl],[Not, Function.injective]]
[Std.HashMap,[Subtype, Std.HashMapImp.WellFormed],[]]
[Lean.Parser.isIdCont,[ite, Eq, BEq.beq, Char.ofNat, Bool.true, String.atEnd, Bool.false, or, Lean.isIdFirst, Lean.isIdBeginEscape],[Bool]]
[Lean.Parser.Tactic.linarith,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy],[Lean.ParserDescr]]
[Lean.Elab.Tactic.ElimApp.State.argPos,[],[Nat]]
[IO.FS.FileType.toCtorIdx,[OfNat.ofNat],[Nat]]
[List.mem_append,[of_eq_true, Eq.trans, congr, congrArg, Iff, Mem.mem, List.nil_append, congrFun, Or, propext, List.mem_nil_iff, false_or, iff_self, List.cons_append, List.mem_cons_iff, HAppend.hAppend, Eq, or_assoc],[Iff, Mem.mem, HAppend.hAppend, Or]]
[Lean.IR.ExpandResetReuse.ProjMap,[Std.HashMap, Lean.IR.VarId, Lean.IR.Expr],[]]
[Nat.not_succ_le_zero,[False, Eq.refl, OfNat.ofNat, HEq.refl],[False]]
[Lean.SyntaxNodeKind,[Lean.Name],[]]
[List.decidableBall.proof_2,[List.mem_cons_self],[False]]
[Lean.Meta.ByCasesSubgoal.mvarId,[],[Lean.MVarId]]
[CoeSort.coe,[],[]]
[Lean.Meta.Match.Alt.idx,[],[Nat]]
[Lean.Elab.Tactic.liftMetaTactic,[Lean.Elab.Tactic.liftMetaTacticAux, Bind.bind, Pure.pure, Prod.mk, Unit.unit],[Lean.Elab.Tactic.TacticM, Unit]]
[List.appendTR,[List.reverseAux, List.reverse],[List]]
[Lean.IR.LocalContext.addJP,[Std.RBMap.insert, Lean.IR.JoinPointId.idx, Lean.IR.LocalContextEntry.joinPoint],[Lean.IR.LocalContext]]
[Lean.IR.Sorry.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Sorry.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Sorry.State.mk, And]]
[Lean.ParserDescr.below,[PUnit, PProd],[]]
[Lean.Xml.Parser.PITarget,[SeqLeft.seqLeft, Lean.Xml.Parser.Name, HOrElse.hOrElse, Lean.Parsec.skipChar, Char.ofNat],[Lean.Parsec, String]]
[Lean.Meta.AbstractMVars.State.mctx,[],[Lean.MetavarContext]]
[Lean.Parser.nameLitFn,[ite, Eq, and, not, Lean.Parser.ParserState.hasError, Lean.Syntax.isOfKind, Array.back, Lean.Parser.ParserState.stxStack, Lean.nameLitKind, Bool.true, Lean.Parser.ParserState.mkErrorAt, Option.some],[Lean.Parser.ParserFn]]
[Std.PersistentHashMap.Node.below,[PProd, PUnit],[]]
[Lean.MessageSeverity.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.MetavarDecl.userName,[],[Lean.Name]]
[Lean.Elab.Term.ToParserDescrM,[ReaderT, Lean.Elab.Term.ToParserDescrContext, StateRefT', IO.RealWorld, Option, Nat, Lean.Elab.Term.TermElabM],[]]
[Lean.Name.updatePrefix,[Lean.Name, Lean.Name.anonymous, Lean.Name.mkStr, Lean.Name.mkNum],[Lean.Name]]
[Lean.Elab.Tactic.focus,[Bind.bind, Lean.Elab.Tactic.getUnsolvedGoals, List.nil, Lean.Elab.Tactic.TacticM, Lean.Elab.Tactic.setGoals, List.cons, HAppend.hAppend, Pure.pure, Lean.Elab.Tactic.throwNoGoalsToBeSolved],[Lean.Elab.Tactic.TacticM]]
[unsafeCast.proof_1,[lcProof],[Eq]]
[Lean.Meta.IndPredBelow.Context.numParams,[],[Nat]]
[Lean.IR.instReprCtorInfo,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.IR.CtorInfo.name, Std.Format.line, Lean.IR.CtorInfo.cidx, Lean.IR.CtorInfo.size, Lean.IR.CtorInfo.usize, Lean.IR.CtorInfo.ssize],[Repr, Lean.IR.CtorInfo]]
[Lean.Meta.mkCongrArg,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Meta.mkEqRefl, Lean.mkApp, Lean.Expr.appArg!, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Option.none, Option.some, Prod.mk, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.arrow?, Lean.Expr.eq?, Lean.Meta.getLevel, Pure.pure, Lean.mkApp6, Lean.mkConst, List.cons, List.nil, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr],[Lean.Meta.MetaM, Lean.Expr]]
[SubNegMonoid.gsmul_zero',[],[Eq, SubNegMonoid.gsmul, OfNat.ofNat]]
[Nat.coprime.eq_one_of_dvd,[Eq.mpr, Eq.refl, Eq, OfNat.ofNat, Eq.symm, Nat.coprime.gcd_eq_one, Nat.gcd, Nat.gcd_eq_left, rfl],[Eq, OfNat.ofNat]]
[Lean.Widget.Lean.Widget.InteractiveGoal.instFromJsonRpcEncodingPacket,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Array, Lean.Widget.TaggedText, Option, String, Pure.pure],[Lean.FromJson]]
[Lean.Compiler.SpecState.specInfo,[],[Lean.SMap, Lean.Name, Lean.Compiler.SpecInfo]]
[Lean.IR.LitVal.noConfusionType,[],[]]
[Lean.getInitFnNameForCore?,[Option.none, Unit.unit, Lean.Name.str, Lean.Name.num, Option, Lean.Name, Lean.ParametricAttribute.getParam, Option.some],[Option, Lean.Name]]
[UInt8.decEq.proof_1,[rfl],[Eq, UInt8.mk]]
[Lean.Declaration.thmDecl.inj,[],[Eq]]
[Mathlib.Tactic.Lint.Linter.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Mathlib.Tactic.Lint.Linter.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Mathlib.Tactic.Lint.Linter.mk, And]]
[Lean.Meta.findLocalDeclWithType?,[Bind.bind, Lean.MonadLCtx.getLCtx, Lean.LocalContext.findDeclRevM?, ite, Eq, Lean.LocalDecl.isAuxDecl, Bool.true, Pure.pure, Option.none, Lean.Meta.isDefEq, Lean.LocalDecl.type, Option.some, Lean.LocalDecl.fvarId],[Lean.Meta.MetaM, Option, Lean.FVarId]]
[Lean.Parser.Tactic.group,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.MetavarContext.assignLevel,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Lean.MetavarContext.decls, Lean.MetavarContext.userNames, Std.PersistentHashMap.insert, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment],[Lean.MetavarContext]]
[Lean.Elab.Term.Do.getDoIdDeclVar,[Lean.Syntax.getId, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Name]]
[ExceptCpsT.runCatch_bind_throw,[rfl],[Eq, ExceptCpsT.runCatch, Bind.bind, MonadExcept.throw, Pure.pure]]
[Lean.Meta.Cache.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Cache.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Deriving.mkInstImplicitBinders,[Lean.Meta.forallBoundedTelescope, Lean.ConstantVal.type, Lean.InductiveVal.toConstantVal, Option.some, Lean.InductiveVal.numParams, Bind.bind, ForIn.forIn, MonadExcept.tryCatch, liftM, Lean.Meta.mkAppM, List.toArray, List.cons, List.nil, Lean.Meta.isTypeCorrect, ite, Eq, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.atom, Lean.mkIdent, PUnit.unit, MProd.mk, Unit.unit, MProd.fst, ForInStep.yield],[Lean.Elab.Term.TermElabM, Array, Lean.Syntax]]
[Nat.Up.WF,[Subrelation.wf, WellFoundedRelation.rel, measure, HSub.hSub, Nat.sub_lt_sub_left, WellFoundedRelation.wf],[WellFounded, Nat.Up]]
[Nat.succ_ne_zero,[],[Ne, Nat.succ, OfNat.ofNat]]
[Lean.Lsp.SymbolKind.enum.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.enum, OfNat.ofNat]]
[ST.instInhabitedRef.proof_1,[Nonempty.intro, arbitrary],[Nonempty]]
[Lean.Elab.Tactic.AuxMatchTermState.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Syntax.sepBy,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.syntaxParser, Lean.Parser.strLit, Lean.Parser.optional, Lean.Parser.nonReservedSymbol, Bool.false],[Lean.Parser.Parser]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.hBinOpHeuristic,[Bind.bind, MonadReader.read, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, andM, Pure.pure, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isHBinOp, orM, liftM, Lean.Meta.instantiateMVars, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.hasMVarAtCurrDepth, Array.getOp, OfNat.ofNat, ite, Eq, Bool.true, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.tryUnify, PUnit.unit],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit]]
[instDecidableLe_2,[UInt16.decLe],[Decidable, LE.le]]
[panic,[panicCore],[]]
[typedExpr,[],[]]
[And.noConfusionType,[],[]]
[Function.is_partial_inv,[Iff, Eq, Option.some],[]]
[Mathlib.Tactic.Lint.getDeclsInCurrModule,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Array.map, Prod.fst, List.toArray, Std.PersistentHashMap.toList, Lean.SMap.map₂, Lean.Environment.constants],[Lean.Core.CoreM, Array, Lean.Name]]
[Std.HashMapImp.expand.proof_1,[Nat.mul_pos, Subtype.property, of_decide_eq_true, Eq.refl, Bool.true],[GT.gt, HMul.hMul, Array.size, Subtype.val, OfNat.ofNat]]
[Lean.Declaration.opaqueDecl.injEq,[Eq.propIntro, Eq.refl, Lean.Declaration.opaqueDecl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Declaration.opaqueDecl]]
[Function.injective,[Eq],[]]
[UInt64.one_def,[rfl],[Eq, OfNat.ofNat, UInt64.mk]]
[Lean.Meta.setInlineAttribute,[Bind.bind, Lean.MonadEnv.getEnv, Lean.Meta.MetaM, Unit, Lean.Compiler.setInlineAttribute, Lean.setEnv, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format],[Lean.Meta.MetaM, Unit]]
[instTransEq_1,[Trans.mk, instTransEq_1.proof_1],[Trans, Eq]]
[Std.HashMap.insert.proof_1,[Eq.refl, Std.HashMapImp.insert],[Eq, Std.HashMapImp.insert]]
[Lean.Parser.unicodeSymbol.formatter,[Lean.PrettyPrinter.Formatter.tokenWithAntiquot.formatter, Lean.PrettyPrinter.Formatter.unicodeSymbolNoAntiquot.formatter],[Lean.PrettyPrinter.Formatter]]
[Mem.noConfusionType,[],[]]
[Tactic.Ring.Cache.mk.inj,[And.intro],[And, Eq]]
[Decidable.noConfusionType,[],[]]
[recSubsingleton,[Subsingleton],[Subsingleton]]
[Lean.Meta.ElimEmptyInductive.M,[StateRefT', IO.RealWorld, Nat, Lean.Meta.MetaM],[]]
[Lean.Parser.Term.doAssert.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[not_and',[Iff.trans, not_and, imp_not_comm],[Iff, Not, And]]
[Lean.Widget.MsgEmbed.lazyTrace.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Widget.MsgEmbed.lazyTrace, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.AltCore.noConfusionType,[],[]]
[Lean.Meta.clear,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.MonadLCtx.getLCtx, ite, Eq, Lean.LocalContext.contains, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.throwTacticEx, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkFVar, Lean.Syntax.missing],[Lean.Meta.MetaM, Lean.MVarId]]
[IO.FS.SystemTime.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FS.SystemTime.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.FS.SystemTime.mk, And]]
[Lean.Meta.AbstractNestedProofs.isNonTrivialProof,[Bind.bind, Lean.Meta.isProof, ite, Eq, not, Bool.true, Pure.pure, Bool.false, Lean.Expr.withApp, or, Lean.Expr.isAtomic, Array.any, OfNat.ofNat, Array.size],[Lean.Meta.MetaM, Bool]]
[and_self_left,[Iff.intro, And.intro, And.left, And.right],[Iff, And]]
[Lean.Elab.Term.expandShow,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, cond, Option.getD, Lean.Syntax.getHeadInfo?, Lean.Macro.throwUnsupported],[Lean.Macro]]
[List.notElem,[not, List.elem],[Bool]]
[Lean.Parser.ParserState.mergeErrors,[Lean.Parser.ParserState.mk, Option.none, Lean.Parser.ParserState, ite, Eq, BEq.beq, Bool.true, Array.shrink, Option.some, Lean.Parser.Error.merge],[Lean.Parser.ParserState]]
[Nat.add_assoc,[Eq, HAdd.hAdd, rfl, congrArg, Nat.succ, PProd.fst],[Eq, HAdd.hAdd]]
[IO.Error.invalidArgument.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.invalidArgument, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.leftArrow,[Lean.Parser.unicodeSymbol],[Lean.Parser.Parser]]
[Lean.Parser.Tactic.rwSeq,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.KeyedDeclsAttribute.mkStateOfTable,[Lean.KeyedDeclsAttribute.ExtensionState.mk, Lean.SMap.fold, List.foldl, Std.PersistentHashSet.insert, Lean.KeyedDeclsAttribute.OLeanEntry.declName, Lean.KeyedDeclsAttribute.AttributeEntry.toOLeanEntry, EmptyCollection.emptyCollection],[Lean.KeyedDeclsAttribute.ExtensionState]]
[Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat.lt_of_le_of_lt],[LT.lt]]
[IO.FS.Handle.readBinToEnd,[ByteArray.empty, IO.FS.Handle.readBinToEnd.loop],[IO, ByteArray]]
[Lean.Lsp.SymbolKind.operator.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.operator, OfNat.ofNat]]
[Lean.Elab.Term.MutualClosure.pushLetRecs,[List.foldl, Array.push, Lean.Elab.PreDefinition.mk, Lean.Elab.Term.MutualClosure.LetRecClosure.ref, List.nil, Lean.Elab.Modifiers.mk, Lean.Elab.Modifiers.docString?, Lean.Elab.Modifiers.visibility, Lean.Elab.Modifiers.isNoncomputable, Lean.Elab.Modifiers.recKind, Lean.Elab.Modifiers.isUnsafe, Lean.Elab.Term.LetRecToLift.attrs, Lean.Elab.Term.MutualClosure.LetRecClosure.toLift, Lean.Elab.Term.LetRecToLift.declName],[Array, Lean.Elab.PreDefinition]]
[Quotient.sound,[Quotient.sound.proof_1],[Eq, Quotient.mk]]
[Nat.sub_add_eq_max,[le_total, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HSub.hSub, max, max_eq_right, Iff.mpr, Nat.sub_eq_zero_iff_le, OfNat.ofNat, Nat.zero_add, rfl, Eq.symm, max_eq_left, Nat.sub_add_cancel],[Eq, HAdd.hAdd, HSub.hSub, max]]
[Lean.Widget.TaggedText.tag.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Widget.TaggedText.tag, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Widget.TaggedText.tag, And]]
[Lean.Parser.Level.addLit,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.numLit],[Lean.Parser.TrailingParser]]
[Lean.Xml.Parser.Char,[HOrElse.hOrElse, Lean.Parsec.attempt, Bind.bind, Lean.Parsec.anyChar, Pure.pure, Char.toNat, ite, Or, And, LE.le, OfNat.ofNat, Lean.Parsec.fail, Lean.Parsec.pchar, Char.ofNat, Lean.Xml.Parser.endl],[Lean.Parsec, Lean.Xml.Parser.LeanChar]]
[Lean.Lsp.DiagnosticWith.message,[],[]]
[Lean.Parsec.instReprParseResult,[Repr.mk, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, HAppend.hAppend, Std.Format.text, Std.Format.line, reprArg, Std.Format.FlattenBehavior.allOrNone],[Repr, Lean.Parsec.ParseResult]]
[Lean.Option.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Option.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Command.mkSimpleDelab,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Bind.bind, liftM, Lean.Macro.resolveGlobalName, Lean.Syntax.getId, List.nil, List.cons, Prod.mk, OptionT, Lean.MacroM, Lean.Syntax, guard, Array.all, Function.comp, Lean.Syntax.isIdent, Lean.Syntax.getAntiquotTerm, OfNat.ofNat, Array.size, Array.allDiff, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.mkIdent, Array.append, Alternative.failure],[OptionT, Lean.MacroM, Lean.Syntax]]
[Lean.Server.FileWorker.handlePlainTermGoal,[Bind.bind, Lean.Server.FileWorker.getInteractiveTermGoal, Pure.pure, Task.map, Except.map, Option.map, Lean.Lsp.PlainTermGoal.mk, ToString.toString, Lean.Widget.InteractiveGoal.pretty, Lean.Widget.InteractiveTermGoal.toInteractiveGoal, Lean.Widget.InteractiveTermGoal.range, Task.Priority.default],[Lean.Server.RequestM, Lean.Server.RequestTask, Option, Lean.Lsp.PlainTermGoal]]
[Lean.Syntax.Traverser.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Syntax.Traverser.mk, HAdd.hAdd, OfNat.ofNat]]
[if_simp_congr_prop,[if_ctx_simp_congr_prop],[Iff, ite]]
[Lean.AttributeApplicationTime.beforeElaboration.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.AttributeApplicationTime.beforeElaboration, OfNat.ofNat]]
[Lean.Parser.Level.paren.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.levelParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Literal.type,[Lean.Expr, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.Expr]]
[Lean.Elab.Tactic.tryCatch,[Bind.bind, Lean.MonadBacktrack.saveState, MonadExcept.tryCatch, Lean.Elab.Tactic.SavedState.restore],[Lean.Elab.Tactic.TacticM]]
[Lean.IR.IRType.float.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.IR.IRType.float, OfNat.ofNat]]
[Lean.MonadNameGenerator.getNGen,[],[Lean.NameGenerator]]
[StateCpsT.runK_bind_get,[rfl],[Eq, StateCpsT.runK, Bind.bind, MonadState.get]]
[Lean.Expr.constName!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Name, panicWithPosWithDecl, OfNat.ofNat],[Lean.Name]]
[Lean.Compiler.SpecArgKind.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Widget.InfoPopup.noConfusionType,[],[]]
[Function.bijective,[And, Function.injective, Function.surjective],[]]
[Lean.Meta.SynthInstance.generate,[Bind.bind, Lean.Meta.SynthInstance.getTop, ite, Eq, BEq.beq, Lean.Meta.SynthInstance.GeneratorNode.currInstanceIdx, OfNat.ofNat, Bool.true, modify, Lean.Meta.SynthInstance.State.mk, Lean.Meta.SynthInstance.State.result?, Array.pop, Lean.Meta.SynthInstance.State.generatorStack, Lean.Meta.SynthInstance.State.resumeStack, Lean.Meta.SynthInstance.State.tableEntries, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Meta.SynthInstance.SynthM, Unit]]
[Lean.Elab.Level.State.noConfusionType,[],[]]
[List.mem_union_iff,[of_eq_true, Eq.trans, congr, congrArg, Iff, Mem.mem, List.nil_union, congrFun, Or, propext, List.mem_nil_iff, false_or, iff_self, List.cons_union, List.mem_insert_iff, Eq, List.mem_cons_iff, or_assoc],[Iff, Mem.mem, List.union, Or]]
[Lean.MetavarDecl.index,[],[Nat]]
[Quotient.lift,[Quot.lift],[]]
[Lean.KVMap.get?,[Option.bind, Lean.KVMap.find, Lean.KVMap.Value.ofDataValue?],[Option]]
[Array.foldr,[Id.run, Array.foldrM],[]]
[ByteArray.toUInt64LE!,[ite, Eq, BEq.beq, ByteArray.size, OfNat.ofNat, Bool.true, HOr.hOr, HShiftLeft.hShiftLeft, UInt8.toUInt64, ByteArray.get!, panicWithPosWithDecl, HAppend.hAppend],[UInt64]]
[Lean.Parser.Term.liftMethod.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.minPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.leftArrow.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[List.append_ne_nil_of_ne_nil_left,[of_eq_true, Eq.trans, implies_congr_ctx, ne_eq, List.nil, HAppend.hAppend, congrArg, Not, propext, List.append_eq_nil, congrFun, And, eq_false, Eq, false_and, eq_true_of_decide, Eq.refl, Bool.true, implies_true],[Ne, HAppend.hAppend, List.nil]]
[Lean.KernelException.appTypeMismatch.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.appTypeMismatch, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KernelException.appTypeMismatch, And]]
[Int.ofNat_zero,[rfl],[Eq, Int.ofNat, OfNat.ofNat]]
[instSubsingletonDecidable.proof_1,[Subsingleton.intro, Eq, Decidable.isTrue, rfl, absurd, Decidable.isFalse],[Subsingleton, Decidable]]
[Lean.mkLocalDeclEx,[Lean.LocalDecl.cdecl],[Lean.LocalDecl]]
[Nat.lcm_dvd,[Dvd.dvd, Nat.lcm, Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, Nat.dvd_zero, Nat.dvd_of_mul_dvd_mul_left, Nat.gcd_pos_of_pos_left, Nat.pos_of_dvd_of_pos, HMul.hMul, Nat.gcd, Nat.gcd_mul_lcm, Eq.symm, Nat.gcd_mul_right, Nat.mul_comm, Nat.dvd_gcd, Nat.mul_dvd_mul_left, Nat.mul_dvd_mul_right],[Dvd.dvd, Nat.lcm]]
[Lean.Elab.TacticInfo.mctxAfter,[],[Lean.MetavarContext]]
[Lean.Server.Watchdog.tryWriteMessage,[Bind.bind, Lean.Server.Watchdog.findFileWorker?, Option.none, Lean.Server.Watchdog.ServerM, Unit, ST.Ref.modifyGet, Lean.Server.Watchdog.FileWorker.groupedEditsRef, Unit.unit, Prod, Bool, Option, Lean.Server.Watchdog.GroupedEdits, Prod.mk, Bool.true, Option.some, Lean.Server.Watchdog.GroupedEdits.mk, Lean.Server.Watchdog.GroupedEdits.applyTime, Lean.Server.Watchdog.GroupedEdits.params, Lean.Server.Watchdog.GroupedEdits.signalTask, Array.push, Lean.Server.Watchdog.GroupedEdits.queuedMsgs, Bool.false, ite, Eq, Pure.pure, PUnit.unit, MonadReader.read, liftM, IO.FS.Stream.putStrLn, Lean.Server.Watchdog.ServerContext.hLog, HAppend.hAppend, ToString.toString, Lean.Json.compress, Lean.ToJson.toJson],[Lean.Server.Watchdog.ServerM, Unit]]
[IO.FS.Stream.Buffer.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.FS.Stream.Buffer.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.ParserModuleContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserModuleContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.ParserModuleContext.mk, And]]
[Lean.ImportM.Context.noConfusionType,[],[]]
[Nat.Up.next,[And.intro, Nat.lt_succ_self],[Nat.Up, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.ToDepElimPattern.State.found,[],[Lean.FVarIdSet]]
[instAddUSize,[Add.mk, USize.add],[Add, USize]]
[Lean.Parser.Command.syntaxCat.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.Command.catBehavior.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.CompletionList.items,[],[Array, Lean.Lsp.CompletionItem]]
[Lean.Elab.Tactic.forEachVar,[Bind.bind, ForIn.forIn, PUnit.unit, Lean.Elab.Tactic.withMainContext, Lean.Elab.Tactic.getFVarId, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.nil, Pure.pure, ForInStep.yield],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.Elab.Term.Quotation.stxQuot.expand,[Bind.bind, Lean.Syntax.getQuotContent, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Lean.Elab.Visibility.protected.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Visibility.protected, OfNat.ofNat]]
[Lean.Macro,[Lean.MacroM, Lean.Syntax],[]]
[Function.injective2,[And, Eq],[]]
[List.hasDecidableLt.proof_3,[Eq.symm, eq_of_heq, Eq.refl, List.cons, HEq.refl, False, absurd],[False]]
[Lean.Elab.Visibility.regular.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Visibility.regular, OfNat.ofNat]]
[Lean.FVarId.mk.injEq,[Eq.propIntro, Eq.refl, Lean.FVarId.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.FVarId.mk]]
[Lean.Meta.InstanceEntry.priority,[],[Nat]]
[Mathlib.Tactic.Lint.getLinter,[arbitrary],[Lean.Core.CoreM, Mathlib.Tactic.Lint.NamedLinter]]
[withPtrEqDecEq.proof_1,[toBoolUsing_eq_true, Unit.unit],[Eq, toBoolUsing, Unit.unit, Bool.true]]
[and_imp,[Iff.intro, And.intro],[Iff]]
[Lean.Parser.checkWsBefore,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.checkWsBeforeFn],[Lean.Parser.Parser]]
[Std.HashSetImp.fold,[Std.HashSetImp.foldBuckets, Std.HashSetImp.buckets],[]]
[Lean.Elab.resolveGlobalConstNoOverloadWithInfo,[Bind.bind, Lean.resolveGlobalConstNoOverload, Lean.Elab.MonadInfoTree.getInfoState, ite, Eq, Lean.Elab.InfoState.enabled, Bool.true, Lean.mkConstWithLevelParams, Lean.Elab.pushInfoLeaf, Lean.Elab.Info.ofTermInfo, Lean.Elab.TermInfo.mk, Lean.Elab.ElabInfo.mk, Lean.Name.anonymous, Lean.LocalContext.empty, Pure.pure, PUnit.unit],[Lean.Name]]
[Lean.IR.LiveVars.collectExpr,[Lean.IR.LiveVars.Collector, Array.foldl, OfNat.ofNat, Array.size, Lean.IR.Arg.irrelevant, Std.RBTree.insert, Function.comp],[Lean.IR.LiveVars.Collector]]
[Lean.IR.EmitC.emitCInitName,[Bind.bind, Lean.IR.EmitC.toCInitName, Lean.IR.EmitC.emit],[Lean.IR.EmitC.M, Unit]]
[Substring.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Substring.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.mkRecursorValEx,[Lean.RecursorVal.mk, Lean.ConstantVal.mk],[Lean.RecursorVal]]
[Lean.Parser.takeWhile1Fn,[Lean.Parser.andthenFn, Lean.Parser.satisfyFn, Lean.Parser.takeWhileFn],[Lean.Parser.ParserFn]]
[Lean.KernelException.alreadyDeclared.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.alreadyDeclared, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KernelException.alreadyDeclared, And]]
[Lean.Elab.addPreDefinitions,[Lean.Meta.withLCtx, Lean.LocalContext.mk, EmptyCollection.emptyCollection, Bind.bind, ForIn.forIn, PUnit.unit, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.type, Lean.Elab.PreDefinition.value, Pure.pure, ForInStep.yield, Array.mapM, liftM, StateRefT'.run, Lean.Meta.collectMVars, Lean.CollectMVars.State.mk, Lean.Meta.MetaM, Array, Lean.MVarId, Lean.CollectMVars.State.result, Lean.Elab.Term.logUnassignedUsingErrorInfos, Option.none, Lean.Meta.mkSorry, Array.isEmpty, Lean.Elab.throwAbortCommand, Array.map, List.toArray, Lean.Elab.liftMacroM, Lean.Elab.WF.expandTerminationHint, Lean.Elab.TerminationHints.terminationBy?, Lean.Elab.TerminationHints.decreasingBy?, MProd.mk, Lean.Elab.Term.TermElabM, Unit, Lean.Elab.WF.TerminationHint.ensureIsEmpty],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.AttributeImplCore.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Command.StructView.noConfusionType,[],[]]
[LE.noConfusionType,[],[]]
[Std.Rbcolor.noConfusion,[noConfusionEnum, Std.Rbcolor.toCtorIdx],[Std.Rbcolor.noConfusionType]]
[Lean.Elab.Term.Do.ToCodeBlock.tryCatchPred,[or, Lean.Elab.Term.Do.CodeBlock.code, Array.any, Lean.Elab.Term.Do.ToCodeBlock.Catch.codeBlock, OfNat.ofNat, Array.size, Unit.unit, Bool, Bool.false],[Bool]]
[Lean.PrettyPrinter.Formatter.unicodeSymbolNoAntiquot.formatter,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Lean.PrettyPrinter.FormatterM, Unit, ite, Eq, BEq.beq, String.trim, Bool.true, Lean.PrettyPrinter.Formatter.pushToken, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.PrettyPrinter.Formatter]]
[Lean.MetavarContext.MkBinding.Exception.revertFailure.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MetavarContext.MkBinding.Exception.revertFailure, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MetavarContext.MkBinding.Exception.revertFailure, And]]
[FloatSpec.mk.inj,[And.intro],[And, Eq, HEq]]
[instReprUInt64,[Repr.mk, repr, UInt64.toNat],[Repr, UInt64]]
[Lean.setOptionFromString,[Bind.bind, Pure.pure, List.nil, List.cons, IO, Lean.Options, Lean.getOptionDefaulValue, Lean.KVMap.setString, ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.KVMap.setBool, Bool.false, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Lean.KVMap.setName, String.toName, Unit.unit, String.toNat?, Lean.KVMap.setNat, String.toInt?, Lean.KVMap.setInt],[IO, Lean.Options]]
[Lean.MonadEnv.modifyEnv,[],[Unit]]
[FloatArray.mk.inj,[],[Eq]]
[LawfulApplicative.map_pure,[],[Eq, Functor.map, Pure.pure]]
[Lean.PrettyPrinter.Formatter.Context.noConfusionType,[],[]]
[Lean.Elab.Term.Do.ToCodeBlock.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.ToCodeBlock.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[«term∃!_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.ParserInfo.firstTokens,[],[Lean.Parser.FirstTokens]]
[instLawfulMonadStateRefT'.proof_1,[inferInstanceAs, LawfulMonad, ReaderT, ST.Ref],[LawfulMonad, ReaderT, ST.Ref]]
[Lean.IR.EmitC.toCType,[Unit.unit, String, panicWithPosWithDecl, OfNat.ofNat],[String]]
[Lean.MetavarContext.MkBinding.Exception.noConfusionType,[],[]]
[Lean.Meta.DefEqContext.rhs,[],[Lean.Expr]]
[instLEUInt32,[LE.mk, LE.le, UInt32.val],[LE, UInt32]]
[Lean.Lsp.PlainGoalParams.noConfusionType,[],[]]
[is_dec_eq,[Eq],[]]
[Lean.Elab.Deriving.BEq.mkMutualBlock,[Bind.bind, ForIn.forIn, Lean.Elab.Deriving.BEq.mkAuxFunction, Pure.pure, PUnit.unit, ForInStep.yield, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Array.append, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Lean.Elab.Term.elabHole,[Bind.bind, liftM, Lean.Meta.mkFreshExprMVar, Lean.MetavarKind.natural, Lean.Name.anonymous, Lean.Elab.Term.registerMVarErrorHoleInfo, Lean.Expr.mvarId!, Pure.pure],[Lean.Elab.Term.TermElab]]
[IO.Error.alreadyExists.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.alreadyExists, HAdd.hAdd, OfNat.ofNat]]
[Int.neg_neg,[Unit.unit, Eq, Neg.neg, rfl],[Eq, Neg.neg]]
[Substring.hasBeq,[BEq.mk, Substring.beq],[BEq, Substring]]
[Lean.Elab.admitGoal,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.inferType, Lean.mkMVar, Lean.Meta.mkSorry, Bool.true, Lean.Meta.assignExprMVar],[Lean.Meta.MetaM, Unit]]
[String.Range.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, String.Range.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, String.Range.mk, And]]
[Lean.Elab.Term.setLevelNames,[modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Lsp.DocumentSymbol.ibelow,[And, True],[]]
[Lean.Meta.Rewrite.Config.noConfusionType,[],[]]
[Lean.Meta.State.mctx,[],[Lean.MetavarContext]]
[Lean.Parser.Term.optExprPrecedence,[Lean.Parser.optional, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[Lean.Lsp.WorkDoneProgressEnd.noConfusionType,[],[]]
[Lean.CollectLevelParams.State.noConfusionType,[],[]]
[LinearOrder.decidable_eq,[],[DecidableEq]]
[Lean.Meta.instInhabitedSimpEntry,[Inhabited.mk, Lean.Meta.SimpEntry.lemma, arbitrary],[Inhabited, Lean.Meta.SimpEntry]]
[Lean.Parser.Command.check,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Zero.noConfusionType,[],[]]
[Lean.Parser.Command.openDecl,[HOrElse.hOrElse, Lean.Parser.Command.openHiding, Lean.Parser.Command.openRenaming, Lean.Parser.Command.openOnly, Lean.Parser.Command.openSimple, Lean.Parser.Command.openScoped],[Lean.Parser.Parser]]
[Lean.JsonNumber.ltProp,[LT.mk, Eq, Lean.JsonNumber.lt, Bool.true],[LT, Lean.JsonNumber]]
[Lean.IR.ExplicitBoxing.withParams,[MonadWithReader.withReader, Lean.IR.ExplicitBoxing.BoxingContext.mk, Lean.IR.ExplicitBoxing.BoxingContext.f, Lean.IR.LocalContext.addParams, Lean.IR.ExplicitBoxing.BoxingContext.localCtx, Lean.IR.ExplicitBoxing.BoxingContext.resultType, Lean.IR.ExplicitBoxing.BoxingContext.decls, Lean.IR.ExplicitBoxing.BoxingContext.env],[Lean.IR.ExplicitBoxing.M]]
[ExistsUnique,[Exists, And, Eq],[]]
[Lean.Elab.Info.ofTacticInfo.inj,[],[Eq]]
[Lean.KeyedDeclsAttribute.OLeanEntry.declName,[],[Lean.Name]]
[Tactic.Ring.HornerExpr.pp,[Lean.Meta.MetaM, Std.Format, Bind.bind, Lean.PrettyPrinter.ppExpr, Lean.Name.anonymous, List.nil, Pure.pure, HAppend.hAppend, Std.Format.text, ToString.toString, PProd.fst, PProd.snd, Prod.fst],[Lean.Meta.MetaM, Std.Format]]
[List.mem_join,[Unit.unit, Iff, Mem.mem, List.join, Exists, And, of_eq_true, Eq.trans, congr, congrArg, List.join_nil, propext, List.mem_nil_iff, funext, congrFun, false_and, eq_false, exists_false, eq_true_of_decide, Eq.refl, Bool.true, Eq.mpr, List.mem_append, Or, PProd.fst, List.cons, Iff.intro, Exists.intro, And.intro, Or.inl, rfl, Or.inr, Eq.symm, eq_of_heq, HEq.refl],[Iff, Mem.mem, List.join, Exists, And]]
[Std.Format.sbracket,[Std.Format.bracket],[Std.Format]]
[Tactic.TryThis.addSuggestion,[Lean.Elab.logInfoAt, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Unit]]
[UInt64.decLe,[Decidable, LE.le, inferInstanceAs],[Decidable, LE.le]]
[Lean.Parser.Attr.notationClass,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Std.ShareCommon.ObjectSet,[Std.HashSet, Std.ShareCommon.Object],[]]
[Lean.Elab.Term.LetIdDeclView.noConfusionType,[],[]]
[Lean.Meta.IndPredBelow.Variables.indVal,[],[Array, Lean.Expr]]
[Char.instDecidableLe,[UInt32.decLe, Char.val],[Decidable, LE.le]]
[Lean.Level.PP.Result.imax,[Lean.Level.PP.Result.leaf, Lean.Level.PP.Result.num, Lean.Level.PP.Result.offset, Lean.Level.PP.Result.maxNode, Lean.Level.PP.Result, Lean.Level.PP.Result.imaxNode, List.cons, List.nil],[Lean.Level.PP.Result]]
[Lean.Meta.Simp.synthesizeArgs,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, Unit.unit, Lean.Meta.Simp.SimpM, ForInStep, MProd, Option, Bool, Subarray, Lean.BinderInfo, Stream.next?, Pure.pure, ForInStep.done, liftM, Lean.Meta.inferType, ite, Eq, Lean.BinderInfo.isInstImplicit, Bool.true, PUnit.unit, ForInStep.yield, Option.some, Bool.false, Lean.Meta.instantiateMVars, Lean.Expr.isMVar, Lean.Meta.isProp, Lean.Meta.isDefEq, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Meta.isClass?, Option.isSome, MProd.fst, Lean.Meta.Simp.synthesizeArgs.synthesizeInstance],[Lean.Meta.Simp.SimpM, Bool]]
[Lean.Meta.Config.unificationHints,[],[Bool]]
[UInt32.noConfusionType,[],[]]
[Lean.IR.IsLive.visitArg,[Pure.pure, Lean.IR.HasIndex.visitArg],[Lean.IR.IsLive.M, Bool]]
[Lean.IR.NormalizeIds.withParams,[Bind.bind, Array.foldlM, getModify, HAdd.hAdd, OfNat.ofNat, Pure.pure, Std.RBMap.insert, Lean.IR.VarId.idx, Lean.IR.Param.x, Array.size],[Lean.IR.NormalizeIds.N]]
[Lean.LocalContext.firstDeclM,[Bind.bind, Lean.LocalContext.findDeclM?, Function.comp, optional, Unit.unit, Alternative.failure, Pure.pure],[]]
[Lean.Elab.Command.CtorView.binders,[],[Lean.Syntax]]
[Lean.PrettyPrinter.Parenthesizer.instMonadTraverserParenthesizerM,[Lean.Syntax.MonadTraverser.mk, MonadState.mk, Functor.map, Lean.PrettyPrinter.Parenthesizer.State.stxTrav, MonadState.get, modify, Lean.PrettyPrinter.Parenthesizer.State.mk, Lean.PrettyPrinter.Parenthesizer.State.contPrec, Lean.PrettyPrinter.Parenthesizer.State.contCat, Lean.PrettyPrinter.Parenthesizer.State.minPrec, Lean.PrettyPrinter.Parenthesizer.State.trailPrec, Lean.PrettyPrinter.Parenthesizer.State.trailCat, Lean.PrettyPrinter.Parenthesizer.State.visitedToken, MonadState.modifyGet, Prod, Lean.PrettyPrinter.Parenthesizer.State, Prod.mk],[Lean.Syntax.MonadTraverser, Lean.PrettyPrinter.ParenthesizerM]]
[Subtype.coe_injective,[Subtype.ext],[Function.injective, Subtype.val]]
[Set.instInterSet,[Inter.mk, Set.inter],[Inter, Set]]
[Lean.Elab.Term.LValResolution.projFn.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LValResolution.projFn, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.LValResolution.projFn, And]]
[Lean.Server.RequestContext.noConfusionType,[],[]]
[Lean.Syntax.getArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Array, Lean.Syntax, Array.empty],[Array, Lean.Syntax]]
[Lean.Elab.getDeclarationSelectionRef,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, not, Lean.Syntax.isNone, Lean.Syntax.getOp, OfNat.ofNat, Lean.Syntax.isIdent],[Lean.Syntax]]
[Lean.expandBrackedBinders,[Bind.bind, Lean.MonadRef.getRef, Lean.expandBrackedBindersAux, List.toArray, List.cons, List.nil],[Lean.MacroM, Lean.Syntax]]
[Classical.strongIndefiniteDescription,[dite, Exists, Subtype.mk, Classical.choice, Classical.strongIndefiniteDescription.proof_2],[Subtype]]
[Lean.Elab.Term.SavedState.mk.inj,[And.intro],[And, Eq]]
[Nat.ctor_eq_zero,[rfl],[Eq, Nat.zero, OfNat.ofNat]]
[Std.HashMap.insert,[Std.HashMap, Std.HashMapImp.insert, Std.HashMap.insert.proof_1, Subtype.mk, Std.HashMap.insert.proof_2],[Std.HashMap]]
[Lean.Meta.ByCasesSubgoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.ByCasesSubgoal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.ByCasesSubgoal.mk, And]]
[Lean.PrettyPrinter.Delaborator.delabNamedPattern,[Bind.bind, MonadReader.read, guard, Eq, Lean.PrettyPrinter.Delaborator.Context.inPattern, Bool.true, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, BEq.beq, Lean.Expr.getAppNumArgs, OfNat.ofNat, Lean.PrettyPrinter.Delaborator.SubExpr.withAppFn, Lean.PrettyPrinter.Delaborator.SubExpr.withAppArg, Lean.PrettyPrinter.Delaborator.delab, Lean.Syntax.isIdent, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.Meta.Instances.discrTree,[],[Lean.Meta.DiscrTree, Lean.Meta.InstanceEntry]]
[Lean.Elab.Level.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Level.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.MetavarContext.getDelayedAssignment?,[Std.PersistentHashMap.find?, Lean.MetavarContext.dAssignment],[Option, Lean.DelayedMetavarAssignment]]
[Std.RBTree.ofList,[Unit.unit, Std.RBTree, Std.mkRBTree, Std.RBTree.insert, PProd.fst],[Std.RBTree]]
[Lean.Elab.Command.StructFieldView.type?,[],[Option, Lean.Syntax]]
[Lean.Elab.Term.StructInst.markDefaultMissing,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Expr]]
[Lean.JsonRpc.ErrorCode.noConfusionType,[noConfusionTypeEnum, Lean.JsonRpc.ErrorCode.toCtorIdx],[]]
[Lean.Elab.Command.expandMixfix,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Lean.Syntax.isNone, Unit.unit, Option.none, Option.some, Lean.Macro.throwUnsupported, Lean.Elab.Command.expandMixfix.withAttrKindGlobal],[Lean.Macro]]
[Lean.IR.FnBody.flatten,[Lean.IR.flattenAux, List.toArray, List.nil],[Prod, Array, Lean.IR.FnBody]]
[Lean.Parser.Level.hole.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.EnumAttributes.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.Match.MatcherResult.matcher,[],[Lean.Expr]]
[MonadStateOf.set,[],[PUnit]]
[Lean.Parser.Command.infixr.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.TransformStep.visit.inj,[],[Eq]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.fType,[],[Lean.Expr]]
[Lean.Elab.Term.elabTypeOf,[Bind.bind, Lean.Elab.Term.elabTerm, Lean.Syntax.getOp, OfNat.ofNat, Option.none, Bool.true, liftM, Lean.Meta.inferType],[Lean.Elab.Term.TermElab]]
[Array.findM?,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, ite, Eq, Bool.true, Pure.pure, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, Option, MProd.fst],[Option]]
[Lean.LocalDecl.setValue,[Lean.LocalDecl.cdecl, Lean.LocalDecl, Lean.LocalDecl.ldecl],[Lean.LocalDecl]]
[Lean.PrettyPrinter.Delaborator.delabNameMkNum,[Lean.PrettyPrinter.Delaborator.delabNameMkStr],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.Meta.DiscrTree.mk.inj,[],[Eq]]
[Mathlib.ExtendedBinder.extBinderParenthesized,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Mathlib.ExtendedBinder.extBinder],[Lean.ParserDescr]]
[Lean.Compiler.SpecInfo.mutualDecls,[],[List, Lean.Name]]
[Lean.ConstantInfo.hints,[Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.ReducibilityHints, Lean.ReducibilityHints.opaque],[Lean.ReducibilityHints]]
[Lean.Parser.categoryParserOfStackFn,[ite, LT.lt, Array.size, HAdd.hAdd, OfNat.ofNat, Lean.Parser.ParserState.mkUnexpectedError, List.nil, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Parser.ParserState, Array.get!, HSub.hSub, Lean.Parser.categoryParserFn],[Lean.Parser.ParserFn]]
[Lean.CollectLevelParams.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.CollectLevelParams.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.instToExprBool,[Lean.ToExpr.mk, ite, Eq, Bool.true, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.ToExpr, Bool]]
[Lean.IR.UnreachableBranches.Value.top.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.IR.UnreachableBranches.Value.top, OfNat.ofNat]]
[Lean.Declaration.opaqueDecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Declaration.opaqueDecl, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.registerSimpAttr,[Bind.bind, Lean.Meta.mkSimpExt, Lean.Meta.mkSimpAttr, Pure.pure],[IO, Lean.Meta.SimpExtension]]
[Lean.Parser.Syntax.sepBy.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.syntaxParser.formatter, Lean.Parser.strLit.formatter, Lean.Parser.optional.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[instAddNat,[Add.mk, Nat.add],[Add, Nat]]
[instDecidableEqSum,[Decidable, Eq, dite, Decidable.isTrue, instDecidableEqSum.proof_1, Decidable.isFalse, instDecidableEqSum.proof_2, instDecidableEqSum.proof_3, instDecidableEqSum.proof_4, instDecidableEqSum.proof_5, instDecidableEqSum.proof_6],[DecidableEq, Sum]]
[Array.push,[Array.mk, List.concat, Array.data],[Array]]
[Std.Range.instForMRangeNat,[ForM.mk, Std.Range.forM],[ForM, Std.Range, Nat]]
[Function.injective2.left,[And.left],[Eq]]
[dif_ctx_simp_congr,[dif_ctx_congr],[Eq, dite]]
[Lean.Meta.reduce,[Lean.MonadCacheT.run, Lean.Meta.reduce.visit],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.ProjectionFunctionInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ProjectionFunctionInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ProjectionFunctionInfo.mk, And]]
[Function.has_left_inverse.injective,[Exists.elim, Function.left_inverse.injective],[Function.injective]]
[notM,[Functor.map, not],[Bool]]
[IO.Process.StdioConfig.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Process.StdioConfig.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.ParserState.cache,[],[Lean.Parser.ParserCache]]
[Lean.Elab.Term.elabLevel,[Lean.Elab.Term.liftLevelM, Lean.Elab.Level.elabLevel],[Lean.Elab.Term.TermElabM, Lean.Level]]
[Lean.MonadResolveName.getCurrNamespace,[],[Lean.Name]]
[Lean.Lsp.DidOpenTextDocumentParams.noConfusionType,[],[]]
[Std.HashSet.instEmptyCollectionHashSet,[EmptyCollection.mk, Std.mkHashSet, OfNat.ofNat],[EmptyCollection, Std.HashSet]]
[true_implies,[propext, Iff.intro, trivial],[Eq]]
[Lean.Meta.intro1,[Lean.Meta.intro1Core, Bool.false],[Lean.Meta.MetaM, Prod, Lean.FVarId, Lean.MVarId]]
[LinearOrder.decidable_lt,[],[DecidableRel, LT.lt]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.discrs,[],[Array, Lean.Syntax]]
[Lean.Parser.Tactic.lift,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.binderIdent],[Lean.ParserDescr]]
[Lean.Lsp.instToJsonInitializeResult,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.InitializeResult.capabilities, List.nil, Lean.Json.opt, Lean.Lsp.InitializeResult.serverInfo?],[Lean.ToJson, Lean.Lsp.InitializeResult]]
[Eq.trans,[],[Eq]]
[Nat.gcd_one_right,[Eq.trans, Nat.gcd_comm, OfNat.ofNat, Nat.gcd_one_left],[Eq, Nat.gcd, OfNat.ofNat]]
[Std.PersistentHashMap.mkEmptyEntries,[Std.PersistentHashMap.Node.entries, Std.PersistentHashMap.mkEmptyEntriesArray],[Std.PersistentHashMap.Node]]
[Lean.Parser.longestMatchStep,[Unit.unit, Prod, Lean.Parser.ParserState, Nat, Lean.Parser.ParserState.errorMsg, ite, Eq, or, Decidable.decide, GT.gt, Lean.Parser.ParserState.pos, and, BEq.beq, Bool.true, Prod.mk, Lean.Parser.ParserState.replaceLongest, LT.lt, Lean.Parser.ParserState.mk, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.cache, Nat.min, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.keepNewError, Lean.Parser.ParserState.keepPrevError, Lean.Parser.ParserState.mergeErrors, Lean.Parser.ParserState.pushSyntax],[Prod, Lean.Parser.ParserState, Nat]]
[Lean.PrettyPrinter.Delaborator.SubExpr.mkRoot,[Lean.PrettyPrinter.Delaborator.SubExpr.mk, OfNat.ofNat],[Lean.PrettyPrinter.Delaborator.SubExpr]]
[instHModUInt64NatUInt64,[HMod.mk, UInt64.modn],[HMod, UInt64, Nat]]
[Lean.MetavarContext.LevelMVarToParam.Context.noConfusionType,[],[]]
[HOrElse.noConfusionType,[],[]]
[UInt32.ofNat',[UInt32.mk, Fin.mk],[UInt32]]
[Lean.SimplePersistentEnvExtension.setState,[Lean.PersistentEnvExtension.modifyState, Prod, List, Prod.mk],[Lean.Environment]]
[Lean.Parser.PrattParsingTables.trailingParsers,[],[List, Prod, Lean.Parser.Parser, Nat]]
[Lean.Meta.CaseValuesSubgoal.noConfusionType,[],[]]
[Lean.Lsp.TextDocumentChangeRegistrationOptions.documentSelector?,[],[Option, Lean.Lsp.DocumentSelector]]
[Lean.SCC.State.noConfusionType,[],[]]
[Lean.Syntax.getRange?,[Option.none, Option.some, Option, String.Range, Lean.Syntax.getPos?, Lean.Syntax.getTailPos?, String.Range.mk],[Option, String.Range]]
[Nat.pos_of_ne_zero,[Or.resolve_left, Nat.eq_zero_or_pos],[LT.lt, OfNat.ofNat]]
[Function.comp.right_id,[rfl],[Eq, Function.comp, id]]
[Lean.IR.EmitC.emitCtorSetArgs,[Nat.forM, Array.size, Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitArg, Array.getOp, Lean.IR.EmitC.emitLn],[Lean.IR.EmitC.M, Unit]]
[instSemiringFin.proof_13,[],[]]
[Lean.Meta.IndPredBelow.mkCtorType.mkBelowBinder,[Lean.Meta.forallTelescopeReducing, Lean.Expr.withApp, Option.none, Lean.Meta.MetaM, Lean.Expr.constName?, Array.findIdx?, Lean.Meta.IndPredBelow.Context.typeInfos, BEq.beq, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Bind.bind, Lean.Meta.mkForallFVars, Bool.false, Bool.true, Lean.Meta.IndPredBelow.mkCtorType.copyVarName, Lean.Expr.fvarId!, Lean.Meta.withLocalDecl, Lean.Expr.binderInfo, Unit.unit],[Lean.Meta.MetaM]]
[IO.AccessRight.execution,[],[Bool]]
[Lean.Elab.Command.getTerminationHints,[ite, Eq, or, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.TerminationHints.mk, Lean.Syntax.getOptional?, Array.getOp, HSub.hSub, Array.size, OfNat.ofNat],[Lean.Elab.TerminationHints]]
[instMonadFinallyStateRefT',[inferInstanceAs, MonadFinally, ReaderT, ST.Ref],[MonadFinally, StateRefT']]
[Lean.Elab.addNonRec,[Lean.withRef, Lean.Elab.PreDefinition.ref, Bind.bind, liftM, Lean.Elab.abstractNestedProofs, Lean.MonadEnv.getEnv, Lean.addDecl, Lean.Elab.withSaveInfoContext, Lean.mkConstWithLevelParams, Lean.Elab.PreDefinition.declName, Lean.Elab.Term.addTermInfo, Option.none, Lean.Name.anonymous, Bool.true, Lean.Elab.applyAttributesOf, List.toArray, List.cons, List.nil, Lean.AttributeApplicationTime.afterTypeChecking, ite, Eq, and, not, Lean.Elab.DefKind.isTheorem, Lean.Elab.PreDefinition.kind, Lean.Elab.Modifiers.isNoncomputable, Lean.Elab.PreDefinition.modifiers, MonadExcept.tryCatch, Lean.compileDecl, Pure.pure, DoResultPR.pure, PUnit.unit, MonadReader.read, Lean.Elab.Term.Context.isNoncomputableSection, DoResultPR.return, Bool.false, MonadExcept.throw, Lean.Elab.Term.TermElabM, Bool, Unit.unit],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Meta.introN,[Lean.Meta.introNCore, Bool.false],[Lean.Meta.MetaM, Prod, Array, Lean.FVarId, Lean.MVarId]]
[Lean.Server.Watchdog.FileWorker.runEditsSignalTask,[Bind.bind, liftM, IO.asTask, Task.Priority.default, Pure.pure, Task.map, Lean.Server.Watchdog.WorkerEvent, Lean.Server.Watchdog.WorkerEvent.ioError, Lean.Server.Watchdog.FileWorker.runEditsSignalTask.loopAction],[IO, Task, Lean.Server.Watchdog.WorkerEvent]]
[String.contains,[String.any, BEq.beq],[Bool]]
[Lean.Core.instMonadRecDepthCoreM,[Lean.MonadRecDepth.mk, MonadWithReader.withReader, Lean.Core.Context.mk, Lean.Core.Context.options, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats, Bind.bind, MonadReader.read, Pure.pure, Lean.Core.Context.currRecDepth],[Lean.MonadRecDepth, Lean.Core.CoreM]]
[proofIrrel,[rfl],[Eq]]
[Lean.Server.FileWorker.ElabTaskError.ioError.inj,[],[Eq]]
[Nat.find_x.proof_1,[And.intro],[And, Not]]
[instShiftRightUSize,[ShiftRight.mk, USize.shiftRight],[ShiftRight, USize]]
[Lean.Parser.Term.byTactic,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Tactic.tacticSeq],[Lean.Parser.Parser]]
[Lean.Parser.Command.optNamedName.formatter,[Lean.Parser.optional.formatter, Lean.Parser.Command.namedName.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.KVMap.instBEqKVMap,[BEq.mk, Lean.KVMap.eqv],[BEq, Lean.KVMap]]
[Lean.Elab.FieldInfo.noConfusionType,[],[]]
[Lean.Parser.Term.pipeProj.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.minPrec, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.fieldIdx.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.many.formatter, Lean.Parser.Term.argument.formatter],[Lean.PrettyPrinter.Formatter]]
[Equiv.trans.proof_1,[Function.left_inverse.comp, Equiv.leftInv],[Function.left_inverse, Function.comp, Equiv.invFun, Equiv.toFun]]
[Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.instToJsonRpcKeepAliveParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.RpcKeepAliveParams.uri, List.nil, Lean.Lsp.RpcKeepAliveParams.sessionId],[Lean.ToJson, Lean.Lsp.RpcKeepAliveParams]]
[Lean.Elab.Term.toParserDescr.isValidAtom,[and, not, String.isEmpty, bne, String.getOp, OfNat.ofNat, Char.ofNat, BEq.beq, or, String.bsize, Lean.isIdFirst, Lean.isIdBeginEscape, Char.isDigit],[Bool]]
[Lean.Parser.identFn,[ite, Eq, and, not, Lean.Parser.ParserState.hasError, Lean.Syntax.isIdent, Array.back, Lean.Parser.ParserState.stxStack, Bool.true, Lean.Parser.ParserState.mkErrorAt, Option.some],[Lean.Parser.ParserFn]]
[Lean.Level.PP.Result.leaf.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Level.PP.Result.leaf, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.InjectionResultCore.noConfusionType,[],[]]
[Lean.IR.ExpandResetReuse.isSelfSSet,[Option.none, Option.some, Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.fap, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Bool, Std.HashMap.find?, Lean.IR.ExpandResetReuse.Context.projMap, and, BEq.beq, Bool.false],[Bool]]
[Equiv.noConfusionType,[],[]]
[decidable_of_bool.proof_2,[mt, Iff.mpr, Bool.ff_ne_tt],[Not]]
[Std.HashSetImp.mk.inj,[And.intro],[And, Eq]]
[instHModUInt32NatUInt32,[HMod.mk, UInt32.modn],[HMod, UInt32, Nat]]
[Lean.MessageDataContext.lctx,[],[Lean.LocalContext]]
[Lean.Expr.app4?,[ite, Eq, Lean.Expr.isAppOfArity, OfNat.ofNat, Bool.true, Option.some, Prod.mk, Lean.Expr.appArg!, Lean.Expr.appFn!, Option.none],[Option, Prod, Lean.Expr]]
[Lean.Expr.getOptParamDefault?,[ite, Eq, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Bool.true, Option.some, Lean.Expr.appArg!, Option.none],[Option, Lean.Expr]]
[Lean.PrettyPrinter.FormatterM,[ReaderT, Lean.PrettyPrinter.Formatter.Context, StateRefT', IO.RealWorld, Lean.PrettyPrinter.Formatter.State, Lean.Core.CoreM],[]]
[Lean.Meta.Match.getMkMatcherInputInContext,[Bind.bind, Lean.Meta.getMatcherInfo?, Option.none, Lean.Meta.MetaM, Lean.Meta.Match.MkMatcherInput, Lean.getConstInfo, Lean.Meta.instantiateForall, Lean.ConstantInfo.type, HAppend.hAppend, Lean.Meta.MatcherApp.params, List.toArray, List.cons, Lean.Meta.MatcherApp.motive, List.nil, Lean.Meta.forallBoundedTelescope, Option.some, Lean.Meta.Match.MatcherInfo.numDiscrs, Lean.Meta.mkForallFVars, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM, Lean.Meta.Match.MkMatcherInput]]
[Lean.Elab.InfoTree.ofJson.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.InfoTree.ofJson, HAdd.hAdd, OfNat.ofNat]]
[Std.PersistentHashMap.Node.entries.injEq,[Eq.propIntro, Eq.refl, Std.PersistentHashMap.Node.entries, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.PersistentHashMap.Node.entries]]
[Lean.Meta.RecursorInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.RecursorInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.RecursorInfo.mk, And]]
[Lean.Elab.Command.State.nextInstIdx,[],[Nat]]
[Std.PersistentHashMap.maxCollisions,[OfNat.ofNat],[Nat]]
[Lean.Compiler.mkUIntLit,[Lean.mkApp, Lean.mkConst, Lean.Compiler.NumScalarTypeInfo.ofNatFn, List.nil, Lean.mkRawNatLit, HMod.hMod, Lean.Compiler.NumScalarTypeInfo.size],[Lean.Expr]]
[«term_^_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instToStringFin,[ToString.mk, ToString.toString, Fin.val],[ToString, Fin]]
[Lean.Meta.Match.State.noConfusionType,[],[]]
[Std.Format.append.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.Format.append, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.Format.append, And]]
[Nat.le_of_eq,[Nat.le_refl],[LE.le]]
[Int.negSucc_ofNat_ofNat,[rfl],[Eq, HMul.hMul, Int.negSucc, Int.ofNat, Int.negOfNat, Nat.succ]]
[Lean.Parser.Command.catBehaviorBoth,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.nonReservedSymbol, Bool.false],[Lean.Parser.Parser]]
[«term-[1+_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.PrettyPrinter.Formatter.getStack,[Bind.bind, MonadState.get, Pure.pure, Lean.PrettyPrinter.Formatter.State.stack],[Lean.PrettyPrinter.FormatterM, Array, Std.Format]]
[Lean.Widget.TaggedText.append.inj,[],[Eq]]
[Function.Equiv.isEquivalence,[Equivalence.mk, Function.Equiv.refl, Function.Equiv.symm, Function.Equiv.trans],[Equivalence, Function.Equiv]]
[Lean.Compiler.atMostOnce.visit,[Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lit, Lean.Compiler.atMostOnce.Visitor, Lean.Compiler.atMostOnce.visitFVar, HAndThen.hAndThen, PProd.fst, PProd.snd, Lean.Compiler.atMostOnce.skip],[Lean.Compiler.atMostOnce.Visitor]]
[List.forall_mem_map_iff,[Iff.intro, List.mem_map_of_mem, Iff.mp, List.mem_map, Eq.mpr, Eq.refl],[Iff]]
[Lean.Lsp.HoverParams.noConfusionType,[],[]]
[Lean.Widget.InfoWithCtx.noConfusionType,[],[]]
[Nat.sub_mul_div,[Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HSub.hSub, HMul.hMul, OfNat.ofNat, Nat.div_zero, Nat.zero_sub, rfl, Eq.symm, Nat.zero, Nat.mul_zero, Nat.sub_zero],[Eq, HDiv.hDiv, HSub.hSub, HMul.hMul]]
[Int.instMulInt,[Mul.mk, Int.mul],[Mul, Int]]
[USize.instSemiringUSize.proof_1,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, USize.zero_def, USize.add_def, USize.mk, OfNat.ofNat, add_zero, USize.val, USize.mk_val_eq, eq_self, propext, forall_const, USize],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.normalizeLevel,[Bind.bind, Lean.Meta.instantiateLevelMVars, Pure.pure, Lean.Level.normalize],[Lean.Meta.MetaM, Lean.Level]]
[Lean.getOptionDecls,[ST.Ref.get],[IO, Lean.OptionDecls]]
[instHashableUInt8,[Hashable.mk, UInt8.toUInt64],[Hashable, UInt8]]
[Lean.Meta.fullApproxDefEq,[Lean.Meta.mapMetaM, Lean.Meta.withConfig, Lean.Meta.Config.mk, Bool.true, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct],[]]
[Lean.Elab.Command.mkDefViewOfExample,[Lean.Elab.DefView, Lean.Elab.DefView.mk, Lean.Elab.DefKind.example, Option.some, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Elab.DefView]]
[Lean.Syntax.isNone,[Unit.unit, Lean.Syntax.atom, Lean.Syntax.ident, Bool, and, BEq.beq, Lean.nullKind, Array.size, OfNat.ofNat, Bool.true, Bool.false],[Bool]]
[Lean.Syntax.isAntiquotSuffixSplice,[Option.isSome, Lean.Syntax.antiquotSuffixSplice?],[Bool]]
[or_false,[propext, Iff.intro, False.elim, Or.inl],[Eq, Or, False]]
[Lean.Lsp.Position.noConfusionType,[],[]]
[DecidableEq,[Decidable, Eq],[]]
[instOrdUInt32,[Ord.mk, compareOfLessAndEq],[Ord, UInt32]]
[String.Iterator.toString,[String],[String]]
[List.instLEList,[LE.mk, List.le],[LE, List]]
[String.Iterator.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, String.Iterator.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, String.Iterator.mk, And]]
[emptyRelation,[False],[]]
[Nat.succ_add_eq_succ_add,[of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.succ_add, Nat.add_succ, eq_self, Nat.succ, HAdd.hAdd],[Eq, HAdd.hAdd, Nat.succ]]
[Lean.Meta.SplitIf.splitIfAt?,[Option.none, Lean.Meta.MetaM, Option, Prod, Lean.Meta.ByCasesSubgoal, Lean.Meta.SplitIf.findIfToSplit?, Unit.unit, Bind.bind, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure],[Lean.Meta.MetaM, Option, Prod, Lean.Meta.ByCasesSubgoal]]
[Lean.Elab.DefView.ref,[],[Lean.Syntax]]
[Function.Equiv.trans,[Eq.trans],[Function.Equiv]]
[Array.foldlMUnsafe,[ite, LT.lt, LE.le, Array.size, USize.ofNat, Pure.pure, Array.foldlMUnsafe.fold],[]]
[Pure.noConfusionType,[],[]]
[Nonempty.elim.proof_1,[],[]]
[Lean.Elab.Command.elabOpenPrivate,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Lean.AttributeImpl.toAttributeImplCore,[],[Lean.AttributeImplCore]]
[Lean.Elab.OpenDecl.State.noConfusionType,[],[]]
[Lean.KernelException.exprTypeMismatch.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.exprTypeMismatch, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KernelException.exprTypeMismatch, And]]
[Lean.Parser.Command.extends.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.termParser.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Std.HashMap.insert'.proof_1,[Eq.refl, Std.HashMapImp.insert],[Eq, Std.HashMapImp.insert]]
[Lean.Elab.Term.ElabAppArgs.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.ElabAppArgs.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Std.PersistentHashMap.mul2Shift,[USize.shiftLeft],[USize]]
[Lean.Elab.PreDefinition.modifiers,[],[Lean.Elab.Modifiers]]
[Lean.Elab.Command.StructView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Command.StructView.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.simpArg,[Lean.ParserDescr.binary, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.Tactic.simpStar, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma],[Lean.ParserDescr]]
[Lean.Elab.printImports,[Bind.bind, Lean.Elab.parseImports, IO, Unit, ForIn.forIn, PUnit.unit, Lean.findOLean, Lean.Import.module, IO.println, Pure.pure, ForInStep.yield],[IO, Unit]]
[Lean.instEmptyCollectionPrefixTree,[EmptyCollection.mk, Lean.PrefixTree.empty],[EmptyCollection, Lean.PrefixTree]]
[IO.Error.unsatisfiedConstraints.inj,[And.intro],[And, Eq]]
[Nat.le.brecOn,[Nat.le.below.refl, Nat.le.below.step],[]]
[Lean.PrettyPrinter.Parenthesizer.charLit.parenthesizer,[Lean.Parser.Term.char.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.Match.Unify.State.fvarSubst,[],[Lean.Meta.FVarSubst]]
[Lean.Parser.mkParserContext,[Lean.Parser.ParserContext.mk, OfNat.ofNat, Lean.Parser.getTokenTable, Lean.Parser.ParserModuleContext.env],[Lean.Parser.ParserContext]]
[Lean.Elab.Command.elabEvalUnsafe,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, MonadReader.read, Lean.MonadEnv.getEnv, Lean.Environment.contains, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Lean.Parser.Tactic.rcasesPat.one,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Server.Watchdog.ServerEvent.clientError.injEq,[Eq.propIntro, Eq.refl, Lean.Server.Watchdog.ServerEvent.clientError, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.Watchdog.ServerEvent.clientError]]
[Lean.IR.Borrow.ParamMap.Key.jp.inj,[And.intro],[And, Eq]]
[Lean.Meta.splitLocalDecl?,[Lean.commitWhenSome?, Lean.Meta.withMVarContext, Bind.bind, Lean.MonadEnv.getEnv, Lean.Meta.inferType, Lean.mkFVar, Lean.Meta.instantiateMVars, Option.none, Lean.Meta.MetaM, Option, List, Lean.MVarId, Lean.Meta.Split.findSplit?, ite, Eq, or, Lean.Expr.isIte, Lean.Expr.isDIte, Bool.true, Lean.Meta.splitIfLocalDecl?, Pure.pure, Option.map, List.cons, List.nil, Lean.Meta.revert, List.toArray, Bool.false, Lean.Meta.Split.splitMatch, List.mapM, Lean.Meta.introNP, Prod.snd, Option.some],[Lean.Meta.MetaM, Option, List, Lean.MVarId]]
[Lean.Parser.Term.sort,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.checkWsBefore, Lean.Parser.checkPrec, Lean.Parser.leadPrec, Lean.Parser.checkColGt, Lean.Parser.levelParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[Nat.lt_trichotomy,[Nat.lt_by_cases, Or.inl, Function.comp, Or.inr],[Or, LT.lt, Eq]]
[Lean.MonadRef.getRef,[],[Lean.Syntax]]
[Lean.Elab.DefView.type?,[],[Option, Lean.Syntax]]
[Lean.findDeclarationRangesCore?,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.MapDeclarationExtension.find?, Lean.declRangeExt],[Option, Lean.DeclarationRanges]]
[UInt16.one_def,[rfl],[Eq, OfNat.ofNat, UInt16.mk]]
[Lean.Parser.Attr.normCast,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[CoeTail.coe,[],[]]
[Lean.IR.Param.x,[],[Lean.IR.VarId]]
[Lean.SMap.insert',[Lean.SMap, Lean.SMap.mk, Bool.true, Std.HashMap.insert, Bool.false, Std.PersistentHashMap.insert],[Lean.SMap]]
[if_ctx_congr,[Eq, ite, absurd, Iff.mp, not_iff_not_of_iff, Iff.mpr],[Eq, ite]]
[Lean.Parser.epsilonInfo,[Lean.Parser.ParserInfo.mk, Lean.Parser.FirstTokens.epsilon],[Lean.Parser.ParserInfo]]
[ne_false_of_self,[],[Ne, False]]
[Std.PersistentArray.tail,[],[Array]]
[Lean.NameSanitizerState.nameStem2Idx,[],[Lean.NameMap, Nat]]
[Lean.Meta.Match.Unify.M,[ReaderT, Lean.Meta.Match.Unify.Context, StateRefT', IO.RealWorld, Lean.Meta.Match.Unify.State, Lean.Meta.MetaM],[]]
[Lean.Parser.Command.structFields,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.manyIndent, HAndThen.hAndThen, Lean.Parser.ppLine, Lean.Parser.checkColGe, HOrElse.hOrElse, Lean.Parser.Command.structExplicitBinder, Lean.Parser.Command.structImplicitBinder, Lean.Parser.Command.structInstBinder, Lean.Parser.Command.structSimpleBinder],[Lean.Parser.Parser]]
[Lean.Parser.Term.haveEqnsDecl.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.haveIdLhs.formatter, Lean.Parser.Term.matchAlts.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.instToJsonTextDocumentIdentifier,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentIdentifier.uri, List.nil],[Lean.ToJson, Lean.Lsp.TextDocumentIdentifier]]
[Lean.Meta.Closure.MkValueTypeClosureResult.value,[],[Lean.Expr]]
[Lean.Expr.Data.hasLevelMVar,[BEq.beq, UInt64.land, UInt64.shiftRight, OfNat.ofNat],[Bool]]
[Lean.Elab.Term.Quotation.precheckIdent,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Elab.Term.Quotation.PrecheckM, Unit, ite, Eq, not, List.isEmpty, Bool.true, Pure.pure, PUnit.unit, Bind.bind, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.Quotation.Precheck]]
[Lean.Parser.Syntax.subPrec,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Meta.Match.addMatcherInfo,[Lean.MonadEnv.modifyEnv, Lean.Meta.Match.Extension.addMatcherInfo],[Lean.Meta.MetaM, Unit]]
[Nat.one_add,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Nat.add_comm, OfNat.ofNat, Nat.succ, eq_self, HAdd.hAdd],[Eq, HAdd.hAdd, OfNat.ofNat, Nat.succ]]
[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer,[Bind.bind, MonadState.get, HOrElse.hOrElse],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.UnreachableBranches.findVarValue,[Bind.bind, MonadReader.read, MonadState.get, Pure.pure, Std.HashMap.findD, Lean.IR.UnreachableBranches.Value.bot],[Lean.IR.UnreachableBranches.M, Lean.IR.UnreachableBranches.Value]]
[Iff.elim,[Iff.elim.proof_1],[]]
[Quotient.inductionOn,[Quot.inductionOn],[]]
[Lean.InductiveType.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.InductiveType.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.Param.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Param.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Param.mk, And]]
[Lean.Syntax.getId,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Name, Lean.Name.anonymous],[Lean.Name]]
[Lean.Elab.Term.CollectPatternVars.State.noConfusionType,[],[]]
[Float.ofNat,[OfScientific.ofScientific, Bool.false, OfNat.ofNat],[Float]]
[fix3,[fixCore3, arbitrary],[]]
[Lean.Parser.Term.matchDiscr.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.PrettyPrinter.Parenthesizer.evalInsideQuot.parenthesizer, Lean.Parser.Term.matchDiscr.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.sub_add_comm,[Iff.mpr, Nat.sub_eq_iff_eq_add, Nat.le_trans, Nat.le_add_right, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HSub.hSub, Nat.add_right_comm, Nat.sub_add_cancel, rfl],[Eq, HSub.hSub, HAdd.hAdd]]
[Lean.Lsp.instToJsonLeanFileProgressParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.LeanFileProgressParams.textDocument, List.nil, Lean.Lsp.LeanFileProgressParams.processing],[Lean.ToJson, Lean.Lsp.LeanFileProgressParams]]
[Lean.Elab.Term.MutualClosure.LetRecClosure.ref,[],[Lean.Syntax]]
[String.isEmpty,[BEq.beq, String.bsize, OfNat.ofNat],[Bool]]
[Lean.Meta.DiscrTree.Key.arity,[Lean.Meta.DiscrTree.Key.lit, Lean.Meta.DiscrTree.Key.star, Lean.Meta.DiscrTree.Key.other, Unit.unit, Nat, OfNat.ofNat],[Nat]]
[Lean.Export.Entry.expr.injEq,[Eq.propIntro, Eq.refl, Lean.Export.Entry.expr, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Export.Entry.expr]]
[Lean.Lsp.RpcKeepAliveParams.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.Borrow.OwnedSet.getHash,[UInt64, mixHash, Hashable.hash],[UInt64]]
[Lean.PersistentEnvExtensionDescr.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PersistentEnvExtensionDescr.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Closure.preprocess,[Bind.bind, liftM, Lean.Meta.instantiateMVars, MonadReader.read, ite, Eq, not, Lean.Meta.Closure.Context.zeta, Bool.true, Lean.Meta.check, Pure.pure, PUnit.unit],[Lean.Meta.Closure.ClosureM, Lean.Expr]]
[fix4,[fixCore4, arbitrary],[]]
[Lean.mkLHSGoal,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Expr]]
[Lean.IR.Alt.ctor,[Lean.IR.AltCore.ctor],[Lean.IR.AltCore, Lean.IR.FnBody]]
[Lean.Lsp.InitializeParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.InitializeParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Set.instSdiffSet,[Sdiff.mk, Set.diff],[Sdiff, Set]]
[instOrdString,[Ord.mk, compareOfLessAndEq],[Ord, String]]
[Lean.Parser.Term.tupleTail.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.termParser.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Server.Completion.HoverInfo.inside.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.Completion.HoverInfo.inside, HAdd.hAdd, OfNat.ofNat]]
[Set.instSubsetSet,[Subset.mk, Set.subset],[Subset, Set]]
[Lean.MetavarContext.UnivMVarParamResult.expr,[],[Lean.Expr]]
[Lean.getBuiltinAttributeNames,[Bind.bind, ST.Ref.get, Lean.attributeMapRef, Pure.pure, Std.PersistentHashMap.foldl, List.cons, List.nil],[IO, List, Lean.Name]]
[Lean.Meta.Match.Problem.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.Problem.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.Problem.mk, And]]
[Lean.Parser.Term.typeOf,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[StateCpsT.runK,[],[]]
[Lean.Elab.Term.MkInstResult.instVal,[],[Lean.Expr]]
[Lean.IR.HasIndex.visitArg,[Lean.IR.Arg.irrelevant, Bool, Lean.IR.HasIndex.visitVar, Bool.false],[Bool]]
[Lean.AttributeImplCore.name,[],[Lean.Name]]
[UInt16.instRingUInt16.proof_1,[congrArg, UInt16.mk, Ring.sub_eq_add_neg, UInt16.val],[Eq, UInt16.mk]]
[Lean.Parser.Term.doBreak,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Parser.Term.depArrow,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.bracketedBinder, Lean.Parser.unicodeSymbol, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.IR.collectUsedDecls,[StateT.run', Lean.IR.CollectUsedDecls.collectDecl],[Lean.NameSet]]
[Lean.Elab.Tactic.evalRevert,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Tactic.getMainGoal, Lean.Elab.Tactic.getFVarIds, liftM, Lean.Meta.revert, Bool.false, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.nil, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[Array.mk.inj,[],[Eq]]
[Fin.val_ne_of_ne,[absurd, Fin.eq_of_val_eq],[Ne, Fin.val]]
[Lean.Elab.Term.MutualClosure.FixPoint.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.MutualClosure.FixPoint.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.MutualClosure.FixPoint.State.mk, And]]
[Lean.Parser.Command.elabTail,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.darrow, Lean.Parser.withPosition, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.Parser.Command.initialize.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.visibility.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.Term.typeSpec.parenthesizer, Lean.Parser.Term.leftArrow.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.Do.Code.reassign.inj,[And.intro],[And, Eq]]
[Std.HashMap.instEmptyCollectionHashMap,[EmptyCollection.mk, Std.mkHashMap, OfNat.ofNat],[EmptyCollection, Std.HashMap]]
[Lean.Elab.Command.mkResultUniverse,[ite, Eq, and, Array.isEmpty, BEq.beq, OfNat.ofNat, Bool.true, Lean.levelOne, not, Lean.Level.isZero, Lean.Level.isNeverZero, Lean.Level.normalize, Lean.mkLevelMax],[Lean.Level]]
[Lean.PrefixTreeNode.noConfusionType,[],[]]
[instHOrElse,[HOrElse.mk, OrElse.orElse],[HOrElse]]
[Mathlib.Tactic.Lint.isConditionalHyps,[Unit.unit, Lean.Meta.MetaM, Bool, Pure.pure, Bool.false, Bind.bind, Lean.Meta.getFVarLocalDecl, List.anyM, Lean.Meta.inferType, Lean.Expr.containsFVar, Lean.Expr.fvarId!, ite, Eq, and, not, Lean.BinderInfo.isInstImplicit, Lean.LocalDecl.binderInfo, Bool.true, PUnit.unit],[Lean.Meta.MetaM, Bool]]
[ExceptT.run_map,[Eq.mpr, congrArg, Eq, ExceptT.run, ExceptT.mk, Bind.bind, Except, Pure.pure, Except.ok, Except.error, map_eq_pure_bind, Except.map, bind_congr, of_eq_true, eq_self, Eq.symm, Eq.refl],[Eq, ExceptT.run, Functor.map, Except.map]]
[add_right_cancel,[IsAddRightCancel.add_right_cancel],[Eq]]
[Lean.CollectFVars.State.mk.inj,[And.intro],[And, Eq]]
[Lean.MetavarContext.LevelMVarToParam.State.mk.inj,[And.intro],[And, Eq]]
[Lean.getBuildDir,[Bind.bind, IO.appDir, Pure.pure, Option.get!, System.FilePath.parent],[IO, System.FilePath]]
[Lean.Elab.Term.toParserDescr.ensureNoPrec,[ite, Eq, Lean.Syntax.isNone, Lean.Syntax.getOp, OfNat.ofNat, Bool.true, Pure.pure, PUnit.unit, Lean.throwErrorAt, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.ToParserDescrM, PUnit]]
[Lean.Parser.Syntax.nonReserved.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.strLit.formatter],[Lean.PrettyPrinter.Formatter]]
[List.subset_append_right,[List.mem_append_right],[Subset.subset, HAppend.hAppend]]
[IO.FS.Stream.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.Stream.mk, OfNat.ofNat]]
[Lean.instBEqMVarId,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.MVarId]]
[Lean.ParametricAttribute.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ParametricAttribute.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ParametricAttribute.mk, And]]
[StateCpsT.runK_modify,[rfl],[Eq, StateCpsT.runK, modify, PUnit.unit]]
[Lean.IR.Expr.ap.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Expr.ap, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Structural.EqnInfo.value,[],[Lean.Expr]]
[Lean.Widget.TaggedText.ibelow,[True, And],[]]
[Lean.Parser.ParserExtension.OLeanEntry.parser.inj,[And.intro],[And, Eq]]
[Lean.Expr.isProp,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Lsp.CompletionOptions.allCommitCharacters?,[],[Option, Array, String]]
[Lean.SyntaxNode.getKind,[Lean.SyntaxNodeKind, Lean.unreachIsNodeMissing, Lean.unreachIsNodeAtom, Lean.unreachIsNodeIdent],[Lean.SyntaxNodeKind]]
[Lean.Lsp.ReferenceContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.ReferenceContext.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.toSuperDigits,[Nat.toSuperDigitsAux, List.nil],[List, Char]]
[Lean.Parser.Command.identPrec.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optPrecedence.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Int.instLTInt,[LT.mk, Int.lt],[LT, Int]]
[Lean.mkModuleData,[Bind.bind, ST.Ref.get, Lean.persistentEnvExtensionsRef, Pure.pure, Lean.ModuleData.mk, Lean.EnvironmentHeader.imports, Lean.Environment.header, Lean.SMap.foldStage2, Array.push, List.toArray, List.nil, Lean.Environment.constants],[IO, Lean.ModuleData]]
[Lean.LocalContext.anyM,[Std.PersistentArray.anyM, Lean.LocalContext.decls, Unit.unit, Bool, Pure.pure, Bool.false],[Bool]]
[List.lengthTRAux,[Nat, PProd.fst, Nat.succ],[Nat]]
[USize.val_eq_of_eq,[Eq, USize.val, congrArg],[Eq, USize.val]]
[Lean.Server.RequestContext.doc,[],[Lean.Server.FileWorker.EditableDocument]]
[Nat.ble_eq_true_of_le,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Eq, Nat.ble, Bool.true, Nat.ble_self_eq_true, Nat.ble_succ_eq_true, PProd.fst],[Eq, Nat.ble, Bool.true]]
[Lean.JsonRpc.Response.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonRpc.Response.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.JsonRpc.Response.mk, And]]
[FloatArray.set!,[FloatArray, FloatArray.mk, Array.set!],[FloatArray]]
[Lean.Parser.evalParserConstUnsafe,[Lean.Parser.ParserState, HOrElse.hOrElse, Lean.Environment.evalConstCheck, Lean.Parser.Parser, Lean.Parser.ParserModuleContext.env, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserModuleContext.options, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.Parser.fn, Lean.Parser.ParserState.mkUnexpectedError, HAppend.hAppend, ToString.toString, List.nil],[Lean.Parser.ParserFn]]
[Lean.Lsp.SymbolKind.struct.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.struct, OfNat.ofNat]]
[Lean.PrettyPrinter.Formatter.checkLineEq.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.mkEqTrans,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Option.none, Option.some, Prod.mk, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.eq?, Lean.Meta.getLevel, Lean.mkApp6, Lean.mkConst, List.cons, List.nil, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Parser.sepBy,[Lean.Parser.sepByNoAntiquot, Lean.Parser.sepByElemParser],[Lean.Parser.Parser]]
[instReprAtomUInt32,[ReprAtom.mk],[ReprAtom, UInt32]]
[Mathlib.ExtendedBinder.«binderTerm>_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Term.structInstArrayRef.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[List.Perm.symm,[List.Perm.nil, List.Perm.cons, List.Perm.swap, List.Perm.trans],[List.Perm]]
[Nat.lt_of_succ_lt,[Nat.le_of_succ_le],[LT.lt]]
[Lean.MessageData.ofLevel.inj,[],[Eq]]
[Lean.Json.instBEqJson,[BEq.mk],[BEq, Lean.Json]]
[Lean.Elab.Command.State.scopes,[],[List, Lean.Elab.Command.Scope]]
[Lean.IR.IRType.isStruct,[Lean.IR.IRType.float, Lean.IR.IRType.uint8, Lean.IR.IRType.uint16, Lean.IR.IRType.uint32, Lean.IR.IRType.uint64, Lean.IR.IRType.usize, Lean.IR.IRType.irrelevant, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.union, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Meta.whnfUntil,[Bind.bind, Lean.Meta.whnfHeadPred, Pure.pure, not, Lean.Expr.isAppOf, ite, Eq, Bool.true, Option.some, Option.none],[Lean.Meta.MetaM, Option, Lean.Expr]]
[Except.tryCatch,[Except, Except.ok],[Except]]
[Lean.IR.Checker.CheckerState.mk.injEq,[Eq.propIntro, Eq.refl, Lean.IR.Checker.CheckerState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Checker.CheckerState.mk]]
[Lean.Parser.Term.ensureExpectedType.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.strLit.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Syntax.copyHeadTailInfoFrom,[Lean.Syntax.setTailInfo, Lean.Syntax.setHeadInfo, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo],[Lean.Syntax]]
[Lean.PrettyPrinter.FormatterM.orElse,[Bind.bind, MonadState.get, Lean.catchInternalId, Lean.PrettyPrinter.backtrackExceptionId, MonadStateOf.set, Unit.unit],[Lean.PrettyPrinter.FormatterM]]
[Lean.Meta.DiscrTree.instToFormatTrie,[Std.ToFormat.mk, Lean.Meta.DiscrTree.Trie.format],[Std.ToFormat, Lean.Meta.DiscrTree.Trie]]
[Task.Priority,[Nat],[]]
[Lean.Lsp.instInhabitedLocation,[Inhabited.mk, Lean.Lsp.Location.mk, arbitrary],[Inhabited, Lean.Lsp.Location]]
[Lean.Expr.constName,[Option.getD, Lean.Expr.constName?, Lean.Name.anonymous],[Lean.Name]]
[HAppend.hAppend,[],[]]
[USize.instCommRingUSize,[CommRing.mk, USize.instCommRingUSize.proof_1],[CommRing, USize]]
[Lean.Expr.ReplaceImpl.cache,[Bind.bind, modify, Lean.Expr.ReplaceImpl.State, Lean.Expr.ReplaceImpl.State.mk, Array.uset, Lean.Expr.ReplaceImpl.cache.proof_1, Lean.Expr.ReplaceImpl.cache.proof_2, Pure.pure],[Lean.Expr.ReplaceImpl.ReplaceM, Lean.Expr]]
[instComplementUInt64,[Complement.mk, UInt64.complement],[Complement, UInt64]]
[Lean.Parser.Term.instBinder.formatter,[Lean.ppGroup.formatter, Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.optIdent.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Attr.extern.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.optional.parenthesizer, Lean.Parser.numLit.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.Attr.externEntry.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.OpenDecl.instToStringOpenDecl,[ToString.mk, String, HAppend.hAppend, ToString.toString, ite, Eq, BEq.beq, List.nil, Bool.true],[ToString, Lean.OpenDecl]]
[Lean.Parser.ParserState.keepNewError,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Lean.Parser.ParserState.keepTop],[Lean.Parser.ParserState]]
[Lean.ClosedTermCache.map,[],[Std.PHashMap, Lean.Expr, Lean.Name]]
[Lean.IR.FnBody.hasLiveVar,[StateT.run', Lean.IR.IsLive.visitFnBody, Lean.IR.VarId.idx],[Bool]]
[Mathlib.Tactic.Ext.tacticExt__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.ParametricAttributeImpl.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ParametricAttributeImpl.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.StructInst.Source.isNone,[Unit.unit, Lean.Elab.Term.StructInst.Source.implicit, Lean.Elab.Term.StructInst.Source.explicit, Bool, Bool.true, Bool.false],[Bool]]
[List.mapM,[Unit.unit, List, Pure.pure, List.nil, Bind.bind, PProd.fst, List.cons],[List]]
[Lean.Elab.Tactic.focusAndDone,[Lean.Elab.Tactic.focus, Bind.bind, Lean.Elab.Tactic.done, Pure.pure],[Lean.Elab.Tactic.TacticM]]
[Lean.Server.FileWorker.handleDocumentHighlight,[Bind.bind, Lean.Server.RequestM.readDoc, Lean.Server.RequestM.withWaitFindSnap, Decidable.decide, GT.gt, Lean.Server.Snapshots.Snapshot.endPos, Pure.pure, List.toArray, List.nil, Option.none, Lean.Server.RequestM, Array, Lean.Lsp.DocumentHighlight, Lean.Server.Snapshots.Snapshot.stx, List.cons, PUnit.unit, Lean.Server.FileWorker.handleDocumentHighlight.highlightReturn?],[Lean.Server.RequestM, Lean.Server.RequestTask, Array, Lean.Lsp.DocumentHighlight]]
[Lean.Elab.WF.TerminationStrategy.decreasingTactic,[],[Lean.Elab.WF.TerminationHint]]
[Lean.Meta.Contradiction.Config.useDecide,[],[Bool]]
[Lean.PersistentEnvExtension.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PersistentEnvExtension.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.mkDeclName,[ite, Eq, or, Lean.Name.isAtomic, Lean.Elab.isFreshInstanceName, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Prod, Lean.Name]]
[ExceptT.instLawfulMonadExceptT,[ExceptT.instLawfulMonadExceptT.proof_1],[LawfulMonad, ExceptT]]
[Lean.Elab.MonadLog.getFileName,[],[String]]
[Lean.Json.getStr?,[Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.arr, Lean.Json.obj, Except, String, Pure.pure, MonadExcept.throw],[Except, String]]
[Nat.toLevel,[Lean.Level.ofNat],[Lean.Level]]
[Lean.Elab.CompletionInfo.id.inj,[And.intro],[And, Eq]]
[EIO.toBaseIO,[EStateM.Result, Empty, IO.RealWorld, Except, EStateM.Result.ok, Except.ok, Except.error],[BaseIO, Except]]
[Lean.Parser.Command.declValSimple.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.whereDecls.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Term.matchAltExpr,[Lean.Parser.Term.matchAlt, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.ExternAttrData.mk.inj,[And.intro],[And, Eq]]
[Iff.rfl,[Iff.refl],[Iff]]
[Function.has_uncurry_induction,[Function.has_uncurry.mk, Function.has_uncurry.uncurry, Prod.fst, Prod.snd],[Function.has_uncurry, Prod]]
[Lean.PersistentEnvExtensionState.noConfusionType,[],[]]
[Lean.Server.FileWorker.WorkerContext.noConfusionType,[],[]]
[Lean.Meta.AbstractMVarsResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.AbstractMVarsResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.AbstractMVarsResult.mk, And]]
[BaseIO.toIO,[liftM],[IO]]
[Lean.mkAppN,[Array.foldl, Lean.mkApp, OfNat.ofNat, Array.size],[Lean.Expr]]
[Lean.Elab.Term.Do.DoIfView.thenBranch,[],[Lean.Syntax]]
[Lean.mkNoConfusionCore,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.MonadEnv.modifyEnv, Lean.throwKernelException, Lean.mkNoConfusionCoreImp],[Unit]]
[precMin,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[instOrdUSize,[Ord.mk, compareOfLessAndEq],[Ord, USize]]
[Lean.getStructureFields,[Option.none, Array, Lean.Name, Lean.getStructureInfo?, Lean.StructureInfo.fieldNames, panicWithPosWithDecl, OfNat.ofNat],[Array, Lean.Name]]
[Nat.superDigitChar,[ite, Eq, OfNat.ofNat, Char.ofNat],[Char]]
[inv_inv,[inv_eq_of_mul_eq_one, mul_left_inv],[Eq, Inv.inv]]
[List.lt.brecOn,[List.lt.below.nil, List.lt.below.head, List.lt.below.tail],[]]
[Lean.Expr.mdata.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Expr.mdata, HAdd.hAdd, OfNat.ofNat]]
[Lean.MessageData.withContext.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MessageData.withContext, HAdd.hAdd, OfNat.ofNat]]
[instSemiringFin.proof_4,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.mul_def, congrFun, HMod.hMod, Nat.mul_comm, eq_self, HMul.hMul],[Eq, HMul.hMul]]
[Nat.gcd_mul_right_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.gcd_comm, Nat.gcd_mul_right_left, rfl],[Eq, Nat.gcd, HMul.hMul]]
[Mathlib.Tactic.Ext.«termExtType%__»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.PrettyPrinter.Formatter.atomic.formatter,[],[Lean.PrettyPrinter.Formatter]]
[Option.toBool,[Unit.unit, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Meta.getMatcherInfo?,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Meta.getMatcherInfoCore?],[Option, Lean.Meta.Match.MatcherInfo]]
[Array.foldlM.loop,[dite, LT.lt, Unit.unit, Pure.pure, Bind.bind, Array.get, Fin.mk, Array.foldlM.loop.proof_1, PProd.fst, HAdd.hAdd, OfNat.ofNat],[]]
[Std.PersistentArrayNode.leaf.injEq,[Eq.propIntro, Eq.refl, Std.PersistentArrayNode.leaf, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.PersistentArrayNode.leaf]]
[Lean.getPPAnalysisBlockImplicit,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false],[Bool]]
[Lean.SimplePersistentEnvExtension,[Lean.PersistentEnvExtension, Prod, List],[]]
[Lean.Elab.Term.Quotation.ArrayStxBuilder.empty,[Sum.inl, List.toArray, List.nil],[Lean.Elab.Term.Quotation.ArrayStxBuilder]]
[Preorder.noConfusionType,[],[]]
[Lean.Elab.Term.Do.ToCodeBlock.Catch.optType,[],[Lean.Syntax]]
[Std.RBNode.depth,[Unit.unit, Nat, OfNat.ofNat, Nat.succ, PProd.fst, PProd.snd],[Nat]]
[Lean.Level.PP.Result.leaf.injEq,[Eq.propIntro, Eq.refl, Lean.Level.PP.Result.leaf, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Level.PP.Result.leaf]]
[Lean.Elab.Command.InductiveView.binders,[],[Lean.Syntax]]
[Lean.IR.EmitC.main,[Bind.bind, Lean.IR.EmitC.emitFileHeader, Lean.IR.EmitC.emitFnDecls, Lean.IR.EmitC.emitFns, Lean.IR.EmitC.emitInitFn, Lean.IR.EmitC.emitMainFnIfNeeded, Lean.IR.EmitC.emitFileFooter],[Lean.IR.EmitC.M, Unit]]
[IO.Error.illegalOperation.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.illegalOperation, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.illegalOperation, And]]
[Lean.Meta.DefEqContext.lhs,[],[Lean.Expr]]
[Lean.Lsp.instToJsonTextDocumentItem,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentItem.uri, List.nil, Lean.Lsp.TextDocumentItem.languageId, Lean.Lsp.TextDocumentItem.version, Lean.Lsp.TextDocumentItem.text],[Lean.ToJson, Lean.Lsp.TextDocumentItem]]
[Lean.Expr.updateForallE!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateForall, Lean.Expr.forallE, Lean.Expr.Data.binderInfo, Lean.Expr.updateForallE!.proof_1, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[Lean.IR.MaxIndex.instAndThenCollector,[AndThen.mk, Function.comp, Unit.unit],[AndThen, Lean.IR.MaxIndex.Collector]]
[Lean.Level.isMVar,[Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Bool, Bool.true, Bool.false],[Bool]]
[Nat.sub_le_sub_left,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, LE.le, HSub.hSub, Nat.le.dest, Eq.mpr, Nat.sub_sub, Nat.sub_le],[LE.le, HSub.hSub]]
[Lean.Parser.Command.initialize.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.visibility.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.ident.formatter, Lean.Parser.Term.typeSpec.formatter, Lean.Parser.Term.leftArrow.formatter, Lean.Parser.Term.doSeq.formatter],[Lean.PrettyPrinter.Formatter]]
[Substring.takeRight,[Substring.mk, Substring, HAdd.hAdd, Substring.prevn, Substring.bsize],[Substring]]
[Lean.ScopedEnvExtension.StateStack.stateStack,[],[List, Lean.ScopedEnvExtension.State]]
[Lean.Widget.instBEqTaggedText,[BEq.mk],[BEq, Lean.Widget.TaggedText]]
[Lean.Elab.Term.LVal.fieldIdx.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.LVal.fieldIdx, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.builtin_initialize.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.visibility.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.ident.formatter, Lean.Parser.Term.typeSpec.formatter, Lean.Parser.Term.leftArrow.formatter, Lean.Parser.Term.doSeq.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.SyntheticMVarDecl.mk.inj,[And.intro],[And, Eq]]
[UInt64.toUInt16,[Nat.toUInt16, UInt64.toNat],[UInt16]]
[instDecidableEq_1,[LinearOrder.decidable_eq],[Decidable, Eq]]
[Lean.Lsp.instFromJsonRange,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.Position, Pure.pure, Lean.Lsp.Range.mk],[Lean.FromJson, Lean.Lsp.Range]]
[Lean.Elab.Term.elabExplicit,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Bind.bind, List.nil, Bool.false, List.toArray, BEq.beq, Array.size, OfNat.ofNat, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.Elab.Term.TermElabM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Pure.pure, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError, Lean.Elab.Term.elabTerm, Lean.Syntax.matchesNull, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElab]]
[Int.subNatNat_add_negSucc_ofNat,[],[Eq, HAdd.hAdd, Int.subNatNat, Int.negSucc, Nat.succ]]
[Classical.strongIndefiniteDescription.proof_1,[Subtype.property, Classical.indefiniteDescription],[Subtype.val, Classical.indefiniteDescription]]
[Lean.Meta.DiscrTree.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.DiscrTree.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Compiler.instBEqSpecializeAttributeKind,[BEq.mk, BEq.beq, Lean.Compiler.SpecializeAttributeKind.toCtorIdx],[BEq, Lean.Compiler.SpecializeAttributeKind]]
[Lean.Server.Completion.HoverInfo.inside.injEq,[Eq.propIntro, Eq.refl, Lean.Server.Completion.HoverInfo.inside, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.Completion.HoverInfo.inside]]
[IO.Error.timeExpired.inj,[And.intro],[And, Eq]]
[tactic_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Meta.Hypothesis.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Hypothesis.mk, HAdd.hAdd, OfNat.ofNat]]
[List.decidableBall.proof_3,[List.mem_cons_of_mem],[False]]
[Lean.Meta.DiscrTree.Key.proj.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.DiscrTree.Key.proj, HAdd.hAdd, OfNat.ofNat]]
[instDecidableNot,[Decidable, Not, Decidable.isFalse, absurd, Decidable.isTrue],[Decidable, Not]]
[Lean.Parser.Term.unreachable.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Syntax.node.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Syntax.node, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Syntax.node, And]]
[Lean.instFVarIdSetInhabited,[Std.instInhabitedRBTree],[Inhabited, Lean.FVarIdSet]]
[Lean.Elab.Term.mkLetIdDeclView,[Lean.Elab.Term.LetIdDeclView.mk],[Lean.Elab.Term.LetIdDeclView]]
[Lean.Parser.unicodeSymbol.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.tokenWithAntiquot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.unicodeSymbolNoAntiquot.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[UInt64.instCommRingUInt64,[CommRing.mk, UInt64.instCommRingUInt64.proof_1],[CommRing, UInt64]]
[Lean.PrettyPrinter.Formatter.checkLhsPrec.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.Match.Alt.applyFVarSubst,[Lean.Meta.Match.Alt.mk, Lean.Meta.Match.Alt.ref, Lean.Meta.Match.Alt.idx, Lean.Expr.applyFVarSubst, Lean.Meta.Match.Alt.rhs, List.map, Lean.LocalDecl.applyFVarSubst, Lean.Meta.Match.Alt.fvarDecls, Lean.Meta.Match.Pattern.applyFVarSubst, Lean.Meta.Match.Alt.patterns],[Lean.Meta.Match.Alt]]
[Lean.Json.CompressWorkItem.json.injEq,[Eq.propIntro, Eq.refl, Lean.Json.CompressWorkItem.json, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Json.CompressWorkItem.json]]
[Lean.Elab.Command.elabPrintPrefix,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Lean.Elab.Command.liftTermElabM, Option.none, Bind.bind, Lean.Meta.find, Pure.pure, Lean.Name.isPrefixOf, Lean.ConstantInfo.name, Lean.Meta.FindOptions.mk, String.isEmpty, Lean.resolveGlobalConst, List.nil, List.cons, Lean.Elab.Term.TermElabM, Unit, PUnit.unit, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Nat.eq_of_mul_eq_mul_left,[Nat.le_antisymm, Nat.le_of_mul_le_mul_left, Nat.le_of_eq, Eq.symm],[Eq]]
[UInt64.instRingUInt64,[Ring.mk, UInt64.instRingUInt64.proof_1, UInt64.mk, Ring.gsmul, UInt64.val, UInt64.instRingUInt64.proof_2, UInt64.instRingUInt64.proof_3, UInt64.instRingUInt64.proof_4, UInt64.instRingUInt64.proof_5],[Ring, UInt64]]
[Lean.Widget.Lean.Widget.MsgToInteractive.instRpcEncodingMsgToInteractiveRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Lean.Widget.MsgToInteractive.msg, Lean.Widget.MsgToInteractive.indent, Pure.pure, Lean.Server.RpcEncoding.rpcDecode, Lean.Widget.MsgToInteractive.mk],[Lean.Server.RpcEncoding, Lean.Widget.MsgToInteractive]]
[Lean.Meta.Match.MkMatcherInput.matcherName,[],[Lean.Name]]
[Lean.Elab.Tactic.SavedState.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.MaxIndex.Collector,[Lean.IR.Index],[]]
[Lean.Name.getNumParts,[Unit.unit, Nat, OfNat.ofNat, HAdd.hAdd, PProd.fst],[Nat]]
[Lean.Meta.Simp.rewriteUsingDecide?,[Lean.Meta.withReducibleAndInstances, ite, Eq, or, Lean.Expr.hasFVar, Lean.Expr.hasMVar, Lean.Expr.isConstOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Option.none, Bind.bind, MonadExcept.tryCatch, Lean.Meta.mkDecide, Lean.Meta.withDefault, Lean.Meta.whnf, Lean.Meta.mkEqRefl, Lean.mkConst, List.nil, Option.some, Lean.Meta.Simp.Result.mk, Lean.mkAppN, List.toArray, List.cons, Lean.Expr.appArg!],[Lean.Meta.MetaM, Option, Lean.Meta.Simp.Result]]
[Lean.MetavarContext.MkBinding.revert,[Bind.bind, MonadState.modifyGet, Prod.mk, Lean.MetavarContext.MkBinding.State.cache, Lean.MetavarContext.MkBinding.State.mk, Lean.MetavarContext.MkBinding.State.mctx, Lean.MetavarContext.MkBinding.State.ngen, EmptyCollection.emptyCollection, modify, Pure.pure, List.toArray, List.nil],[Lean.MetavarContext.MkBinding.M, Prod, Lean.Expr, Array]]
[Lean.Parser.Command.deriving.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.derivingClasses.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.ident.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Structural.instInhabitedEqnsExtState,[Inhabited.mk, Lean.Elab.Structural.EqnsExtState.mk, arbitrary],[Inhabited, Lean.Elab.Structural.EqnsExtState]]
[Lean.Parser.checkColGe,[Lean.Parser.Parser.mk, Lean.Parser.checkColGeFn],[Lean.Parser.Parser]]
[Lean.Parser.Term.dynamicQuot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.incQuotDepth, Lean.Parser.parserOfStack],[Lean.Parser.Parser]]
[Lean.Elab.Term.ToParserDescrContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.ToParserDescrContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.ToParserDescrContext.mk, And]]
[List.length_singleton,[rfl],[Eq, List.length, List.cons, List.nil, OfNat.ofNat]]
[Lean.Server.FileWorker.handleSemanticTokens.addToken,[Bind.bind, MonadReader.read, ReaderT, Lean.Server.FileWorker.SemanticTokensContext, StateT, Lean.Server.FileWorker.SemanticTokensState, Lean.Server.RequestM, PUnit, Prod.mk, Option.none, Option.some, Lean.Syntax.getPos?, Bool.false, Lean.Syntax.getTailPos?, ite, Eq, and, Decidable.decide, LE.le, LT.lt, Bool.true, MonadState.get, modify, Lean.Server.FileWorker.SemanticTokensState.mk, HAppend.hAppend, Lean.Server.FileWorker.SemanticTokensState.data, List.toArray, List.cons, List.nil, Pure.pure, PUnit.unit],[ReaderT, Lean.Server.FileWorker.SemanticTokensContext, StateT, Lean.Server.FileWorker.SemanticTokensState, Lean.Server.RequestM, PUnit]]
[List.length_reverse,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, List.length, List.reverse_cons, List.length_append, List.reverse, List.cons, List.nil, HAdd.hAdd, List.length_cons, Nat.succ, List.length_nil, eq_self, OfNat.ofNat],[Eq, List.length, List.reverse]]
[Lean.Parser.Attr.toAdditiveReorder,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[instNegFin,[Neg.mk, Fin.mk, HMod.hMod, HSub.hSub, Fin.val, instNegFin.proof_1],[Neg, Fin]]
[String.trim,[Substring.toString, Substring.trim, String.toSubstring],[String]]
[instOfNatUInt16,[OfNat.mk, UInt16.ofNat],[OfNat, UInt16]]
[Lean.Elab.Term.ToDepElimPattern.State.localDecls,[],[Array, Lean.LocalDecl]]
[Lean.Meta.Closure.ClosureM,[ReaderT, Lean.Meta.Closure.Context, StateRefT', IO.RealWorld, Lean.Meta.Closure.State, Lean.Meta.MetaM],[]]
[Lean.Meta.isCoeDecl,[or, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous],[Bool]]
[Lean.IR.MData,[Lean.KVMap],[]]
[Lean.Parser.Command.end.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.mod_eq_sub_mod,[Eq, HMod.hMod, HSub.hSub, Nat.eq_zero_or_pos, rfl, Eq.symm, Nat.sub_zero, if_pos, And.intro, Nat.mod_eq],[Eq, HMod.hMod, HSub.hSub]]
[Lean.Elab.MacroStack,[List, Lean.Elab.MacroStackElem],[]]
[Lean.Meta.liftMetaM,[liftM],[]]
[Lean.Meta.mkFunUnit,[Bind.bind, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Lean.mkLambda, Lean.BinderInfo.default, Lean.mkConst, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.RecursorVal.rules,[],[List, Lean.RecursorRule]]
[Lean.CollectLevelParams.State.params,[],[Array, Lean.Name]]
[Lean.Parser.withAntiquotSpliceAndSuffix,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquotSplice, Lean.Parser.withoutInfo, Lean.Parser.withAntiquotSuffixSplice],[Lean.Parser.Parser]]
[Lean.Meta.SynthInstance.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SynthInstance.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Simp.rewritePre,[Bind.bind, MonadReader.read, Pure.pure, Lean.Meta.Simp.Context.simpLemmas, Lean.Meta.Simp.rewrite, Lean.Meta.SimpLemmas.pre, Lean.Meta.SimpLemmas.erased, Lean.Meta.Simp.Step.visit],[Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step]]
[Lean.Parser.leadingParserAux,[Id.run, Id, Lean.Parser.ParserState, ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Pure.pure, Bind.bind, PUnit.unit],[Lean.Parser.ParserFn]]
[Lean.Elab.expandDeclIdCore,[ite, Eq, Lean.Syntax.isIdent, Bool.true, Prod.mk, Lean.Syntax.getId, Lean.mkNullNode, List.toArray, List.nil],[Prod, Lean.Name, Lean.Syntax]]
[Lean.Meta.Config.quasiPatternApprox,[],[Bool]]
[Lean.IR.Borrow.M,[ReaderT, Lean.IR.Borrow.BorrowInfCtx, StateM, Lean.IR.Borrow.BorrowInfState],[]]
[Lean.MessageData.ofList,[Unit.unit, List.cons, Lean.MessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.MessageData.sbracket, Lean.MessageData.joinSep, HAppend.hAppend, Std.Format.text, Std.Format.line],[Lean.MessageData]]
[Lean.Expr.proj.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.proj, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Expr.proj, And]]
[Lean.MetavarContext.findExprDependsOn,[StateT.run', Lean.MetavarContext.DependsOn.main, EmptyCollection.emptyCollection],[Bool]]
[Lean.PrettyPrinter.Delaborator.failure,[MonadExcept.throw, Lean.Exception.internal, Lean.PrettyPrinter.Delaborator.delabFailureId, Lean.KVMap.mk],[Lean.PrettyPrinter.Delaborator.DelabM]]
[Lean.IR.EmitC.emitDec,[Bind.bind, Lean.IR.EmitC.emit, ite, Eq, Bool.true, bne, OfNat.ofNat, Pure.pure, PUnit.unit],[Lean.IR.EmitC.M, Unit]]
[Lean.Syntax.matchesNull,[Lean.Syntax.isNodeOf, Lean.nullKind],[Bool]]
[Lean.Elab.Command.InductiveView.ref,[],[Lean.Syntax]]
[Except.map,[Except, Except.error, Except.ok],[Except]]
[Nat.gcd_gcd_self_left_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, Nat.gcd_comm, Nat.gcd_gcd_self_right_right, rfl],[Eq, Nat.gcd]]
[Lean.Compiler.InlineAttributeKind.noConfusion,[noConfusionEnum, Lean.Compiler.InlineAttributeKind.toCtorIdx],[Lean.Compiler.InlineAttributeKind.noConfusionType]]
[Char.isValidUInt32,[LT.lt, UInt32.size, Nat.lt_trans, of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, UInt32.size]]
[Lean.Parser.Command.mkSimpAttribute,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.TagAttribute.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.TagAttribute.mk, HAdd.hAdd, OfNat.ofNat]]
[instRingFin.proof_5,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat, add_comm, Eq.symm, instRingFin.proof_1, Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Fin.val, Fin.sub_def, congrFun, HMod.hMod, Nat.add_sub_cancel', Nat.le_of_lt, Fin.isLt, Nat.mod_self, Fin.zero_def, eq_true_of_decide, Bool.true],[Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat]]
[Lean.Elab.Tactic.Context.mk.inj,[And.intro],[And, Eq]]
[List.cons_union,[of_eq_true, eq_self, List.insert, List.foldr],[Eq, List.union, List.cons, List.insert]]
[Lean.DefinitionVal.safety,[],[Lean.DefinitionSafety]]
[Nat.not_coprime_of_dvd_of_dvd,[],[Not, Nat.coprime]]
[Lean.ExternEntry.foreign.inj,[And.intro],[And, Eq]]
[Lean.Parser.ParserAttributeHook.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Parser.ParserAttributeHook.mk, OfNat.ofNat]]
[Lean.Parser.precedenceParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Parenthesizer]]
[PSum.inl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, PSum.inl, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.structInstLVal,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, HOrElse.hOrElse, Lean.Parser.Term.ident, Lean.Parser.fieldIdx, Lean.Parser.Term.structInstArrayRef, Lean.Parser.many, Lean.Parser.group, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Exists.imp,[exists_imp_exists],[Exists]]
[Lean.Elab.Command.Context.ref,[],[Lean.Syntax]]
[Lean.DefinitionVal.hints,[],[Lean.ReducibilityHints]]
[Lean.Elab.Command.CtorView.type?,[],[Option, Lean.Syntax]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.mvarName,[Bind.bind, Lean.Meta.getMVarDecl, Lean.Expr.mvarId!, Pure.pure, Lean.MetavarDecl.userName],[Lean.Meta.MetaM, Lean.Name]]
[Lean.ParserCompiler.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ParserCompiler.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.instToJsonLeanFileProgressProcessingInfo,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.LeanFileProgressProcessingInfo.range, List.nil],[Lean.ToJson, Lean.Lsp.LeanFileProgressProcessingInfo]]
[prioMid,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Iff.elim_left.proof_1,[Iff.mp],[]]
[Lean.Export.Alloc.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Export.Alloc.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Export.Alloc.mk, And]]
[Lean.Server.FileWorker.SemanticTokensState.lastLspPos,[],[Lean.Lsp.Position]]
[ExceptCpsT.lift,[Bind.bind],[ExceptCpsT]]
[Lean.Server.RequestError.noConfusionType,[],[]]
[Lean.Parser.Term.matchAlt,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ppIndent, Lean.Parser.sepBy1, Lean.Parser.termParser, OfNat.ofNat, Bool.false, Lean.Parser.darrow, Lean.Parser.checkColGe],[Lean.Parser.Parser]]
[not_le_of_gt,[And.right, le_not_le_of_lt],[Not, LE.le]]
[Function.involutive.left_inverse,[],[Function.left_inverse]]
[Lean.IR.VarId.noConfusionType,[],[]]
[LE.le,[],[]]
[Lean.Parser.ModuleParserState.pos,[],[String.Pos]]
[Lean.Elab.MonadInfoTree.noConfusionType,[],[]]
[WellFounded.noConfusionType,[],[]]
[Lean.Meta.ElimInfo.altsInfo,[],[Array, Lean.Meta.ElimAltInfo]]
[Lean.Json.str.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Json.str, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.charLit,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.charLitKind, Bool.true, Lean.Parser.charLitNoAntiquot],[Lean.Parser.Parser]]
[IO.FS.DirEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FS.DirEntry.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.FS.DirEntry.mk, And]]
[Lean.Parser.Command.namedPrio,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.priorityParser],[Lean.Parser.Parser]]
[Lean.Elab.Term.StructInst.instInhabitedExplicitSourceInfo,[Inhabited.mk, Lean.Elab.Term.StructInst.ExplicitSourceInfo.mk, arbitrary],[Inhabited, Lean.Elab.Term.StructInst.ExplicitSourceInfo]]
[not_iff,[Decidable.not_iff],[Iff, Not]]
[List.mem_of_mem_erase,[List.erase_subset],[Mem.mem]]
[Lean.Parser.Term.letDecl,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.notFollowedBy, Lean.Parser.nonReservedSymbol, Bool.false, HOrElse.hOrElse, Lean.Parser.Term.letIdDecl, Lean.Parser.Term.letPatDecl, Lean.Parser.Term.letEqnsDecl],[Lean.Parser.Parser]]
[Nat.dvd_add_iff_right,[Iff.intro, Nat.dvd_add, Exists.elim, Eq.symm, eq_of_heq, Eq.refl, HMul.hMul, HEq.refl, Dvd.dvd, Exists.intro, HSub.hSub, Eq.mpr, Eq, Nat.mul_sub_left_distrib, HAdd.hAdd, Nat.add_sub_cancel_left, rfl],[Iff, Dvd.dvd, HAdd.hAdd]]
[Lean.Expr.setAppPPExplicit,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.setPPExplicit, Lean.mkAppN, Bool.true],[Lean.Expr]]
[Lean.Lsp.instToJsonWorkDoneProgressBegin,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.WorkDoneProgressReport.kind, Lean.Lsp.WorkDoneProgressBegin.toWorkDoneProgressReport, List.nil, Lean.Json.opt, Lean.Lsp.WorkDoneProgressReport.message?, Lean.Lsp.WorkDoneProgressReport.cancellable, Lean.Lsp.WorkDoneProgressReport.percentage?, Lean.Lsp.WorkDoneProgressBegin.title],[Lean.ToJson, Lean.Lsp.WorkDoneProgressBegin]]
[Lean.Parser.Tactic.failIfSuccess?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Elab.MacroExpansionInfo.noConfusionType,[],[]]
[Nat.strong_rec_on,[WellFounded.fix', WellFoundedRelation.wf, Nat.lt_wfRel],[]]
[Std.Range.forM.loop,[ite, GE.ge, Std.Range.stop, Pure.pure, PUnit.unit, Unit.unit, PUnit, Bind.bind, PProd.fst, HAdd.hAdd, Std.Range.step],[PUnit]]
[Lean.IR.ExplicitBoxing.run,[Lean.IR.ExplicitBoxing.addBoxedVersions],[Array, Lean.IR.Decl]]
[Lean.Elab.InfoTree.noConfusionType,[],[]]
[Lean.Level.imax.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Level.imax, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Command.expandElab,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Option.some, Lean.Macro.throwUnsupported],[Lean.Macro]]
[instReprAtomChar,[ReprAtom.mk],[ReprAtom, Char]]
[Lean.Server.FileWorker.handleReferences,[Bind.bind, Lean.Server.RequestM.readDoc, liftM, IO.AsyncList.waitAll, Bool.true, Lean.Server.FileWorker.EditableDocument.cmdSnaps, Lean.Server.RequestM.mapTask, Lean.Server.RequestM, Array, Lean.Lsp.Location, Option.none, List.find?, Decidable.decide, GT.gt, Lean.Server.Snapshots.Snapshot.endPos, Lean.Elab.InfoTree.hoverableInfoAt?, Lean.Server.Snapshots.Snapshot.infoTree, Pure.pure, Lean.Lsp.ReferenceContext.includeDeclaration, Lean.Lsp.ReferenceParams.context, PUnit.unit, Lean.Server.FileWorker.handleReferences.identOf, Lean.Server.FileWorker.handleReferences.findReferences, Lean.Server.FileWorker.handleReferences.applyIdMap, Lean.Server.FileWorker.handleReferences.combineFvars, Lean.Server.FileWorker.handleReferences.referencesTo],[Lean.Server.RequestM, Lean.Server.RequestTask, Array, Lean.Lsp.Location]]
[Int.subNatNat_of_sub_eq_succ,[],[Eq, Int.subNatNat, Int.negSucc]]
[Lean.instInhabitedDataValue,[Inhabited.mk, Lean.DataValue.ofString, arbitrary],[Inhabited, Lean.DataValue]]
[Nat.to_digits_core_lens_eq,[of_eq_true, eq_self, HAdd.hAdd, List.length, OfNat.ofNat, Classical.em, Eq, HDiv.hDiv, Eq.trans, congr, congrArg, ite_congr, congrFun, eq_true_of_decide, Eq.refl, Bool.true, List.cons, Nat.digitChar, HMod.hMod, Nat.toDigitsCore, if_true, Eq.symm, Eq.mpr, eq_false, if_false],[Eq, List.length, Nat.toDigitsCore, List.cons, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.registerAlias,[Lean.Parser.registerAliasCore, Lean.Parser.parserAliasesRef],[IO, Unit]]
[Lean.Elab.Term.MVarErrorKind.implicitArg.inj,[],[Eq]]
[Lean.Meta.ElimInfo.targetsPos,[],[Array, Nat]]
[Lean.Elab.Modifiers.isNoncomputable,[],[Bool]]
[Lean.Elab.Tactic.MkSimpContextResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.MkSimpContextResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Tactic.MkSimpContextResult.mk, And]]
[IO.FS.Stream.withPrefix,[IO.FS.Stream.mk, IO.FS.Stream.isEof, IO.FS.Stream.flush, IO.FS.Stream.read, Bind.bind, IO.FS.Stream.putStr, IO.FS.Stream.write, IO.FS.Stream.getLine, HAppend.hAppend],[IO.FS.Stream]]
[IO.FS.Mode.noConfusionType,[noConfusionTypeEnum, IO.FS.Mode.toCtorIdx],[]]
[Lean.Meta.headBetaMVarType,[Bind.bind, Lean.Meta.getMVarType, Lean.Meta.setMVarType, Lean.Expr.headBeta],[Lean.Meta.MetaM, Unit]]
[Lean.JsonRpc.RequestID.str.injEq,[Eq.propIntro, Eq.refl, Lean.JsonRpc.RequestID.str, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.JsonRpc.RequestID.str]]
[List.instListDecidableLe,[inferInstanceAs, Decidable, Not, LT.lt],[Decidable, LE.le]]
[Lean.Name.toStringWithSep.maybeEscape,[ite, Eq, Bool.true, Option.getD, Lean.Name.escapePart],[String]]
[Lean.Meta.Closure.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Closure.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Closure.State.mk, And]]
[Lean.Elab.Deriving.Header.targetNames,[],[Array, Lean.Name]]
[Nat.mul_div_cancel_left,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, Nat.mul_comm, Nat.mul_div_cancel, rfl],[Eq, HDiv.hDiv, HMul.hMul]]
[Lean.Meta.DiscrTree.Key.format,[Unit.unit, Std.Format, Std.Format.text, Std.ToFormat.format, repr, HAppend.hAppend, Lean.FVarId.name],[Std.Format]]
[Lean.Parser.ModuleParserState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ModuleParserState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.ModuleParserState.mk, And]]
[Lean.Level.find?.visit,[ite, Eq, Bool.true, Pure.pure, Lean.Level.zero, Lean.Level.param, Lean.Level.mvar, OptionM, Lean.Level, PProd.fst, HOrElse.hOrElse, PProd.snd, Alternative.failure],[OptionM, Lean.Level]]
[Lean.Elab.Term.MkInstResult.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.withLevelNames,[Bind.bind, Lean.Elab.Term.getLevelNames, Lean.Elab.Term.setLevelNames, tryFinally],[Lean.Elab.Term.TermElabM]]
[UInt64.instSemiringUInt64.proof_3,[congrArg, UInt64.mk, Semiring.nsmul_zero', UInt64.val],[Eq, UInt64.mk, Semiring.nsmul, OfNat.ofNat, UInt64.val]]
[Lean.Parser.Tactic.normCast,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Elab.InfoTree.hole.inj,[],[Eq]]
[Lean.AttributeExtensionOLeanEntry.builder.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.AttributeExtensionOLeanEntry.builder, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.AttributeExtensionOLeanEntry.builder, And]]
[Lean.Parser.Term.quotedName,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.nameLit],[Lean.Parser.Parser]]
[Lean.EnvExtensionInterfaceUnsafe.ensureExtensionsArraySize,[Array.size, Lean.Environment.extensions, Lean.EnvExtensionInterfaceUnsafe.ensureExtensionsArraySize.loop],[IO, Lean.Environment]]
[Lean.Parser.Tactic.nativeDecide.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Syntax.rewriteBottomUp,[Id.run, Lean.Syntax.rewriteBottomUpM],[Lean.Syntax]]
[Lean.Widget.InteractiveHypothesis.names,[],[Array, String]]
[instDecidableLt,[UInt32.decLt],[Decidable, LT.lt]]
[Lean.ConstructorVal.numParams,[],[Nat]]
[Lean.ExternEntry.standard.inj,[And.intro],[And, Eq]]
[Std.RBTree.toList,[Std.RBTree.revFold, List.cons, List.nil],[List]]
[Lean.instInhabitedModuleData,[Inhabited.mk, Lean.ModuleData.mk, arbitrary],[Inhabited, Lean.ModuleData]]
[Lean.Parser.antiquotExpr.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.identNoAntiquot.parenthesizer, Lean.Parser.antiquotNestedExpr.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Core.Context.currNamespace,[],[Lean.Name]]
[StateT.run_seqLeft,[],[Eq, StateT.run, SeqLeft.seqLeft, Bind.bind, Prod.snd, Pure.pure, Prod.mk, Prod.fst]]
[Lean.Elab.Deriving.DecEq.mkMatch.mkSameCtorRhs,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Syntax, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.MonadQuotation.withFreshMacroScope, PProd.fst, Lean.Syntax.atom, ite, Eq, Bool.true, Lean.mkIdent],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Lean.Elab.TerminationHints.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.TerminationHints.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.TerminationHints.mk, And]]
[IO.FS.Stream.chainRight,[IO.FS.Stream.mk, IO.FS.Stream.isEof, SeqRight.seqRight, IO.FS.Stream.flush, Bind.bind, IO.FS.Stream.read, IO.FS.Stream.write, ite, Eq, Bool.true, Pure.pure, PUnit.unit, IO.FS.Stream.getLine, IO.FS.Stream.putStr],[IO.FS.Stream]]
[Lean.PrettyPrinter.Delaborator.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.NormNum.LawfulOne.noConfusionType,[],[]]
[Lean.KeyedDeclsAttribute.Table,[Lean.SMap, Lean.KeyedDeclsAttribute.Key, List, Lean.KeyedDeclsAttribute.AttributeEntry],[]]
[List.decidablePairwise,[Decidable, List.pairwise, List.decidablePairwise.proof_1, Decidable.isTrue, List.pairwise.nil, List.cons, PProd.fst, List.decidableBall, Decidable.isFalse, List.decidablePairwise.proof_2, List.decidablePairwise.proof_3, List.decidablePairwise.proof_4],[Decidable, List.pairwise]]
[StateT.set,[Pure.pure, Prod.mk, PUnit.unit],[StateT, PUnit]]
[Lean.Xml.Parser.doctypedecl,[Bind.bind, Lean.Parsec.skipString, SeqLeft.seqLeft, SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Xml.Parser.Name, optional, Lean.Xml.Parser.ExternalID, Pure.pure, Unit.unit, Lean.Parsec.skipChar, Char.ofNat, Lean.Xml.Parser.intSubset],[Lean.Parsec, Unit]]
[Lean.Compiler.instInhabitedSpecArgKind,[Inhabited.mk, Lean.Compiler.SpecArgKind.fixed],[Inhabited, Lean.Compiler.SpecArgKind]]
[DivInvMonoid.toInv,[],[Inv]]
[liftCoeM,[Bind.bind, liftM, Pure.pure, coe],[]]
[Lean.getExternConstArity,[Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.Core.CoreM, Option, Nat, Lean.getExternAttrData, Pure.pure, Option.none, Lean.ExternAttrData.arity?, Option.some, Lean.getConstInfo, Lean.Meta.MetaM.run, Lean.Meta.forallTelescopeReducing, Lean.ConstantInfo.type, Array.size, Lean.Meta.Context.mk, Lean.Meta.State.mk],[Lean.Core.CoreM, Option, Nat]]
[Lean.Lsp.Trace.noConfusion,[noConfusionEnum, Lean.Lsp.Trace.toCtorIdx],[Lean.Lsp.Trace.noConfusionType]]
[instInhabitedEIO,[inferInstanceAs, Inhabited, EStateM, IO.RealWorld],[Inhabited, EIO]]
[Lean.InductiveVal.ctors,[],[List, Lean.Name]]
[Lean.Elab.Term.Do.extendUpdatedVars,[ite, Eq, Std.RBTree.any, not, Lean.NameSet.contains, Lean.Elab.Term.Do.CodeBlock.uvars, Bool.true, Bind.bind, Lean.Elab.Term.Do.extendUpdatedVarsAux, Lean.Elab.Term.Do.CodeBlock.code, Pure.pure, Lean.Elab.Term.Do.CodeBlock.mk],[Lean.Elab.Term.TermElabM, Lean.Elab.Term.Do.CodeBlock]]
[coeHead,[CoeHead.coe],[]]
[Lean.IR.Expr.pap.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.pap, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Expr.pap, And]]
[Lean.Level.PP.Result.num.injEq,[Eq.propIntro, Eq.refl, Lean.Level.PP.Result.num, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Level.PP.Result.num]]
[Lean.Json.CompressWorkItem.comma.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Json.CompressWorkItem.comma, OfNat.ofNat]]
[Lean.MonadCacheT.run,[StateRefT'.run', Std.mkHashMap, OfNat.ofNat],[]]
[Lean.Parser.Term.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, HOrElse.hOrElse, Lean.Parser.termParser, Lean.Parser.many1Unbox, Lean.Parser.commandParser],[Lean.Parser.Parser]]
[Std.PersistentArrayNode.node.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.trans, Eq.refl, SizeOf.sizeOf, List.nil, HAdd.hAdd, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec],[Eq, SizeOf.sizeOf, Std.PersistentArrayNode.node, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.hole.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.LeanFileProgressParams.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Command.StructCtorView.mk.inj,[And.intro],[And, Eq]]
[Lean.Server.Snapshots.Snapshot.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.Snapshots.Snapshot.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.Snapshots.Snapshot.mk, And]]
[Lean.Lsp.Hover.range?,[],[Option, Lean.Lsp.Range]]
[Std.RBMap.instReprRBMap,[Repr.mk, Repr.addAppParen, HAppend.hAppend, Std.Format.text, repr, Std.RBMap.toList],[Repr, Std.RBMap]]
[CoeHead.noConfusionType,[],[]]
[Lean.Parsec.instAlternativeParsec,[Alternative.mk, Lean.Parsec.fail, Lean.Parsec.orElse],[Alternative, Lean.Parsec]]
[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.mk, And]]
[UInt32.instSemiringUInt32.proof_2,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt32.zero_def, UInt32.add_def, UInt32.mk, OfNat.ofNat, zero_add, UInt32.val, UInt32.mk_val_eq, eq_self, propext, forall_const, UInt32],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.Quotation.HeadInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Quotation.HeadInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Quotation.HeadInfo.mk, And]]
[Lean.Lsp.ClientCapabilities.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Lsp.ServerInfo.version?,[],[Option, String]]
[Lean.Parser.Tactic.field,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.RecursorVal.noConfusionType,[],[]]
[Lean.Elab.Tactic.ElimApp.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.ElimApp.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Tactic.ElimApp.State.mk, And]]
[Lean.PrettyPrinter.Formatter.tokenWithAntiquot.formatter,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, Lean.Syntax.isTokenAntiquot, Bool.true, Lean.PrettyPrinter.Formatter.visitArgs],[Lean.PrettyPrinter.Formatter]]
[Lean.AttributeImplCore.descr,[],[String]]
[Lean.Lsp.FileSource.noConfusionType,[],[]]
[Lean.Parser.Term.char,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.charLit],[Lean.Parser.Parser]]
[Lean.Meta.SimpExtension,[Lean.SimpleScopedEnvExtension, Lean.Meta.SimpEntry, Lean.Meta.SimpLemmas],[]]
[Lean.instFromJsonLeanPaths,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.SearchPath, Pure.pure, Lean.LeanPaths.mk],[Lean.FromJson, Lean.LeanPaths]]
[StateCpsT.runK_bind_pure,[rfl],[Eq, StateCpsT.runK, Bind.bind, Pure.pure]]
[Lean.Parser.InputContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.InputContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.InputContext.mk, And]]
[Lean.Parser.numLitFn,[ite, Eq, and, not, Lean.Parser.ParserState.hasError, Lean.Syntax.isOfKind, Array.back, Lean.Parser.ParserState.stxStack, Lean.numLitKind, Bool.true, Lean.Parser.ParserState.mkErrorAt, Option.some],[Lean.Parser.ParserFn]]
[Lean.Lsp.TextDocumentSyncOptions.openClose,[],[Bool]]
[EStateM.throw,[EStateM.Result.error],[EStateM]]
[Lean.Meta.DiscrTree.instToFormatKey,[Std.ToFormat.mk, Lean.Meta.DiscrTree.Key.format],[Std.ToFormat, Lean.Meta.DiscrTree.Key]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.lhs,[],[Lean.Expr]]
[Lean.Meta.exactlyOne,[List.nil, List.cons, Lean.Meta.MetaM, Lean.MVarId, Pure.pure, Lean.throwError],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.Export.Entry.defn.inj,[],[Eq]]
[Lean.Meta.AuxLemmas.lemmas,[],[Std.PHashMap, Lean.Expr, Prod, Lean.Name, List]]
[Lean.Parser.testParseModuleAux,[Lean.Parser.testParseModuleAux.parse],[IO, Array, Lean.Syntax]]
[Lean.Meta.removeUnused,[Bind.bind, Lean.Meta.getLocalInstances, Lean.MonadLCtx.getLCtx, Array.foldrM, Lean.Meta.MetaM, Prod, Lean.LocalContext, Lean.LocalInstances, Array, Lean.Expr, Lean.CollectFVars.State, ite, Eq, Std.RBTree.contains, Lean.CollectFVars.State.fvarSet, Lean.Expr.fvarId!, Bool.true, Lean.Meta.inferType, StateRefT'.run, Lean.Meta.collectUsedFVars, Pure.pure, Prod.mk, Array.push, Lean.LocalContext.erase, Lean.LocalInstances.erase, List.toArray, List.nil, Array.size, OfNat.ofNat, Array.reverse],[Lean.Meta.MetaM, Prod, Lean.LocalContext, Lean.LocalInstances, Array, Lean.Expr]]
[Lean.Core.checkMaxHeartbeats,[Bind.bind, MonadReader.read, Lean.Core.checkMaxHeartbeatsCore, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Core.Context.maxHeartbeats],[Lean.Core.CoreM, Unit]]
[Lean.Lsp.TextDocumentRegistrationOptions.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.TextDocumentRegistrationOptions.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.TextDocumentRegistrationOptions.mk]]
[Int.negSucc_ofNat_eq,[rfl],[Eq, Int.negSucc, Neg.neg, HAdd.hAdd, Int.ofNat, OfNat.ofNat]]
[Lean.Level.data,[Lean.Level.Data],[Lean.Level.Data]]
[Lean.Elab.OpenDecl.instMonadResolveNameM,[Lean.MonadResolveName.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Elab.OpenDecl.State.currNamespace, Lean.Elab.OpenDecl.State.openDecls],[Lean.MonadResolveName, Lean.Elab.OpenDecl.M]]
[Lean.Elab.Frontend.State.commandState,[],[Lean.Elab.Command.State]]
[Lean.IR.formatDecl,[Std.Format, HAppend.hAppend, Std.Format.text, Std.ToFormat.format, Lean.IR.formatParams, Std.Format.nest, Int.ofNat, Std.Format.line, Lean.IR.formatFnBody],[Std.Format]]
[Lean.IR.EmitC.emitUSet,[Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn],[Lean.IR.EmitC.M, Unit]]
[Lean.Parser.Command.set_option.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter, Lean.ppSpace.formatter, Lean.Parser.Command.optionValue.formatter],[Lean.PrettyPrinter.Formatter]]
[PSigma.revLex.proof_1,[WellFounded.intro, Acc, PSigma.RevLex, PSigma.revLexAccessible, WellFounded.apply],[WellFounded, PSigma.RevLex]]
[Subtype.coind_injective,[congrArg, Subtype.val],[Function.injective, Subtype.coind]]
[iff_self,[propext, Iff.intro, trivial, id],[Eq, Iff, True]]
[Std.Format.noConfusionType,[],[]]
[Lean.Export.Alloc.map,[],[Std.HashMap, Nat]]
[Lean.Lsp.WaitForDiagnostics.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.WaitForDiagnostics.toCtorIdx],[]]
[Lean.Meta.replaceTargetDefEq,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType, ite, Eq, BEq.beq, Bool.true, Pure.pure, Lean.Meta.getMVarTag, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.mkExpectedTypeHint, Lean.Meta.assignExprMVar, Lean.Expr.mvarId!],[Lean.Meta.MetaM, Lean.MVarId]]
[LawfulApplicative.noConfusionType,[],[]]
[Lean.Syntax.atom.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Syntax.atom, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Syntax.atom, And]]
[Lean.Meta.mkFreshLevelMVarsFor,[Lean.Meta.mkFreshLevelMVars, Lean.ConstantInfo.numLevelParams],[Lean.Meta.MetaM, List, Lean.Level]]
[Lean.MonadFileMap.noConfusionType,[],[]]
[Lean.Elab.Info.fmtHover?.fmtTerm?,[Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofCompletionInfo, Lean.Meta.MetaM, Option, Std.Format, Bind.bind, Lean.Meta.inferType, Lean.Elab.TermInfo.expr, Lean.MonadWithOptions.withOptions, Lean.Option.set, Lean.pp.fullNames, Bool.true, Lean.Meta.ppExpr, Pure.pure, Option.some, HAppend.hAppend, Std.ToFormat.format, Lean.Elab.FieldInfo.val, Lean.Elab.FieldInfo.fieldName, Option.none],[Lean.Meta.MetaM, Option, Std.Format]]
[ByteArray.getOp,[ByteArray.get!],[UInt8]]
[Subtype.val_prop,[Subtype.property],[Mem.mem, Subtype.val]]
[Char.val_eq_of_eq,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Eq, Char.val, rfl],[Eq, Char.val]]
[Lean.ExprStructEq.hash,[UInt64, Lean.Expr.hash],[UInt64]]
[Lean.Elab.Term.instInhabitedNamedArg,[Inhabited.mk, Lean.Elab.Term.NamedArg.mk, arbitrary],[Inhabited, Lean.Elab.Term.NamedArg]]
[Lean.Meta.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.State.mk, And]]
[Lean.instInhabitedAxiomVal,[Inhabited.mk, Lean.AxiomVal.mk, arbitrary],[Inhabited, Lean.AxiomVal]]
[Lean.MetavarContext.LevelMVarToParam.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MetavarContext.LevelMVarToParam.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MetavarContext.LevelMVarToParam.Context.mk, And]]
[Lean.Parser.symbolFn,[Lean.Parser.symbolFnAux, HAppend.hAppend],[Lean.Parser.ParserFn]]
[Lean.Parser.precedence.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.precedenceParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Command.declModifiersF.formatter,[Lean.Parser.Command.declModifiers.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.CongrTheorem.argKinds,[],[Array, Lean.Meta.CongrArgKind]]
[Lean.Core.State.mk.inj,[And.intro],[And, Eq]]
[Std.PersistentHashMap.Node.noConfusionType,[],[]]
[Std.PersistentHashSet.instInhabitedPersistentHashSet,[Inhabited.mk, Std.PersistentHashSet.empty],[Inhabited, Std.PersistentHashSet]]
[Lean.Widget.addInteractiveHypothesis,[Bind.bind, Lean.Widget.exprToInteractive, Option.mapM, Lean.Meta.isClass?, Lean.Meta.instantiateMVars, Pure.pure, Array.push, Lean.Widget.InteractiveHypothesis.mk, Array.map, ToString.toString, Option.isSome, Lean.Expr.isSort],[Lean.Meta.MetaM, Array, Lean.Widget.InteractiveHypothesis]]
[Equivalence.refl,[],[]]
[instDivUInt16,[Div.mk, UInt16.div],[Div, UInt16]]
[Lean.InductiveVal.isReflexive,[],[Bool]]
[max_lt,[Or.elim, le_or_gt, Eq.mpr, Eq.refl, LT.lt, max, max_eq_right, max_eq_left_of_lt],[LT.lt, max]]
[UInt64.land,[UInt64.mk, Fin.land, UInt64.val],[UInt64]]
[Lean.Parser.Attr.externEntry.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.ident.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.strLit.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Server.Snapshots.Snapshot.cmdState,[],[Lean.Elab.Command.State]]
[Lean.Elab.Command.ElabStructResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Command.ElabStructResult.mk, HAdd.hAdd, OfNat.ofNat]]
[«term_\_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Meta.change,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getMVarType, ite, Eq, Bool.true, Lean.Meta.isDefEq, Pure.pure, PUnit.unit, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Syntax.missing],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.Server.Watchdog.FileWorkerMap,[Std.RBMap, Lean.Lsp.DocumentUri, Lean.Server.Watchdog.FileWorker, Ord.compare],[]]
[Mathlib.Prelude.Rename.getRenameMap,[Lean.SimplePersistentEnvExtension.getState, Mathlib.Prelude.Rename.renameExtension],[Mathlib.Prelude.Rename.RenameMap]]
[Lean.Level.PP.Result.maxNode.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.refl, SizeOf.sizeOf, List.nil, Eq.trans, HAdd.hAdd, Eq.symm, List.cons.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Level.PP.Result.maxNode, HAdd.hAdd, OfNat.ofNat]]
[List.length_map,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.length, List.map_nil, List.length_nil, eq_true_of_decide, Eq.refl, Bool.true, List.map_cons, List.length_cons, List.map, Nat.succ, eq_self],[Eq, List.length, List.map]]
[Lean.Parser.ident.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.identKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.identNoAntiquot.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.hasAssignableMVar,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.hasAssignableMVar],[Lean.Meta.MetaM, Bool]]
[Lean.Widget.InteractiveTermGoal.hyps,[],[Array, Lean.Widget.InteractiveHypothesis]]
[Lean.Parser.Term.doIdDecl,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.Term.ident, Lean.Parser.Term.optType, Lean.Parser.Term.leftArrow, Lean.Parser.doElemParser],[Lean.Parser.Parser]]
[Lean.Elab.DefKind.isTheorem,[Lean.Elab.DefKind.def, Unit.unit, Lean.Elab.DefKind.example, Lean.Elab.DefKind.opaque, Lean.Elab.DefKind.abbrev, Bool, Bool.true, Bool.false],[Bool]]
[Lean.IR.IRType.tobject.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.IR.IRType.tobject, OfNat.ofNat]]
[Lean.Parser.Tactic.trans,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[eq_true_of_decide,[propext, Iff.intro, trivial, of_decide_eq_true],[Eq, True]]
[Lean.Elab.Tactic.getInductiveValFromMajor,[Lean.Elab.Tactic.liftMetaMAtMain, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnf, Lean.matchConstInduct, Lean.Expr.getAppFn, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Syntax.missing, Pure.pure],[Lean.Elab.Tactic.TacticM, Lean.InductiveVal]]
[Lean.Lsp.DocumentHighlightKind.noConfusion,[noConfusionEnum, Lean.Lsp.DocumentHighlightKind.toCtorIdx],[Lean.Lsp.DocumentHighlightKind.noConfusionType]]
[Lean.instHashableLiteral,[Hashable.mk, Lean.Literal.hash],[Hashable, Lean.Literal]]
[Lean.observing?,[Bind.bind, Lean.MonadBacktrack.saveState, MonadExcept.tryCatch, Pure.pure, DoResultPR.pure, PUnit.unit, Lean.MonadBacktrack.restoreState, DoResultPR.return, Option.none, Option, Option.some],[Option]]
[Lean.KeyedDeclsAttribute.Def.evalKey,[],[Lean.AttrM, Lean.KeyedDeclsAttribute.Key]]
[instLTUInt64,[LT.mk, UInt64.lt],[LT, UInt64]]
[Lean.Elab.instInhabitedMacroExpansionInfo,[Inhabited.mk, Lean.Elab.MacroExpansionInfo.mk, arbitrary],[Inhabited, Lean.Elab.MacroExpansionInfo]]
[Lean.Meta.mkGeneralizationForbiddenSet.visit,[Bind.bind, Lean.Meta.getLocalDecl, Lean.Meta.instantiateMVars, Lean.LocalDecl.type, Option.none, Lean.Meta.MetaM, Prod, List, Lean.FVarId, Lean.FVarIdSet, Lean.LocalDecl.value?, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Prod, List, Lean.FVarId, Lean.FVarIdSet]]
[Lean.Lsp.CompletionList.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.CompletionList.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.CompletionList.mk, And]]
[Lean.instInhabitedData_1,[inferInstanceAs, Inhabited, UInt64],[Inhabited, Lean.Expr.Data]]
[Lean.NamingContext.noConfusionType,[],[]]
[Lean.PrettyPrinter.Formatter.node.formatter,[Bind.bind, Lean.PrettyPrinter.Formatter.checkKind, Lean.PrettyPrinter.Formatter.visitArgs],[Lean.PrettyPrinter.Formatter]]
[xor_false,[funext, of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, Or, false_and, Not, And, eq_true_of_decide, Eq.refl, Bool.true, and_true, false_or, id_eq, eq_self, propext, implies_true_iff],[Eq, xor, False, id]]
[Lean.Parser.Tactic.clarify,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.sepBy1],[Lean.ParserDescr]]
[List.inj_on,[Eq],[]]
[List.decidablePairwise.proof_4,[Eq.symm, eq_of_heq, Eq.refl, List.cons, HEq.refl, False],[False]]
[Mathlib.Tactic.Lint.nolint,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.getPPAnalyzeTypeAscriptions,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.typeAscriptions, Lean.Option.defValue],[Bool]]
[Lean.Environment.noConfusionType,[],[]]
[Lean.Declaration.thmDecl.injEq,[Eq.propIntro, Eq.refl, Lean.Declaration.thmDecl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Declaration.thmDecl]]
[Lean.withNestedTraces,[Bind.bind, Lean.getTraces, Lean.modifyTraces, Std.PersistentArray.mk, Lean.MonadRef.getRef, tryFinally, ite, Eq, BEq.beq, Std.PersistentArray.size, OfNat.ofNat, Bool.true, and, Lean.MessageData.isNest, Lean.TraceElem.msg, Std.PersistentArray.getOp, HAppend.hAppend, Std.PersistentArray.push, Lean.TraceElem.mk, Lean.MessageData.nestD],[]]
[UInt16.eq_of_val_eq,[Eq, congrArg, UInt16.mk],[Eq]]
[ExceptT.bind_pure_comp,[rfl],[Eq, Bind.bind, Function.comp, Pure.pure, Functor.map]]
[instToFormat,[Std.ToFormat.mk, Function.comp, Std.Format.text, ToString.toString],[Std.ToFormat]]
[SeqLeft.noConfusionType,[],[]]
[Lean.Elab.Term.Do.ToCodeBlock.Catch.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.ToCodeBlock.Catch.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.injections,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Meta.markSmartUnfoldigMatchAlt,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Expr]]
[Lean.Parser.ParserState.errorMsg,[],[Option, Lean.Parser.Error]]
[Lean.StructureDescr.fields,[],[Array, Lean.StructureFieldInfo]]
[OptionT,[Option],[]]
[Fin.overflowingAdd,[Prod.mk, Decidable.decide, LE.le, HAdd.hAdd, Fin.val],[Prod, Bool, Fin]]
[Lean.Meta.AssertAfterResult.mvarId,[],[Lean.MVarId]]
[Lean.Parser.Attr.elementwise,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[decidable_of_decidable_of_iff,[dite, Decidable.isTrue, Iff.mp, Decidable.isFalse, decidable_of_decidable_of_iff.proof_1],[Decidable]]
[Lean.IR.mkFAppExpr,[Lean.IR.Expr.fap],[Lean.IR.Expr]]
[Lean.Parser.Term.binderTactic.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Tactic.tacticSeq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.instBEqAttributeKind,[BEq.mk, BEq.beq, Lean.AttributeKind.toCtorIdx],[BEq, Lean.AttributeKind]]
[Mathlib.Tactic.Ext.mkAndN,[Unit.unit, List.cons, Lean.Expr, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.mkAnd, PProd.fst],[Lean.Expr]]
[Lean.Parser.Command.«command_Notation3_____=>_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.Parser.Command.notation3Item, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.mkApp10,[Lean.mkApp6, Lean.mkApp4],[Lean.Expr]]
[UInt8.size,[OfNat.ofNat],[Nat]]
[Lean.Level.isParam,[Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.mvar, Bool, Bool.true, Bool.false],[Bool]]
[Lean.PrettyPrinter.Delaborator.SubExpr.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.AbstractMVars.State.fvars,[],[Array, Lean.Expr]]
[Lean.Server.Watchdog.WorkerState.running.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Server.Watchdog.WorkerState.running, OfNat.ofNat]]
[Lean.Meta.FVarSubst.erase,[Lean.Meta.FVarSubst.mk, Std.AssocList.erase, Lean.Meta.FVarSubst.map],[Lean.Meta.FVarSubst]]
[Lean.Lsp.instToJsonTextDocumentPositionParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, List.nil, Lean.Lsp.TextDocumentPositionParams.position],[Lean.ToJson, Lean.Lsp.TextDocumentPositionParams]]
[Lean.Xml.Parser.Enumeration,[Bind.bind, Lean.Parsec.skipChar, Char.ofNat, SeqRight.seqRight, optional, Lean.Xml.Parser.S, Lean.Xml.Parser.Nmtoken, Lean.Parsec.many],[Lean.Parsec, Unit]]
[Lean.Elab.TermInfo.noConfusionType,[],[]]
[Std.RBMap.size,[Std.RBMap.fold, HAdd.hAdd, OfNat.ofNat],[Nat]]
[Lean.Level.hash,[Lean.Level.Data.hash, Lean.Level.data],[UInt64]]
[Lean.Meta.SimpExtension.getLemmas,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.ScopedEnvExtension.getState],[Lean.Core.CoreM, Lean.Meta.SimpLemmas]]
[Prod.swap_bijective,[And.intro, Prod.swap_injective, Prod.swap_surjective],[Function.bijective, Prod.swap]]
[Lean.PrettyPrinter.Delaborator.SubExpr.descend,[withTheReader, Lean.PrettyPrinter.Delaborator.SubExpr, Lean.PrettyPrinter.Delaborator.SubExpr.mk, HAdd.hAdd, HMul.hMul, Lean.PrettyPrinter.Delaborator.SubExpr.pos, Lean.PrettyPrinter.Delaborator.SubExpr.maxChildren],[]]
[Lean.Elab.Tactic.evalExistsIntro,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Tactic.evalApplyLikeTactic, Bind.bind, Lean.Meta.existsIntro, Pure.pure, List.cons, List.nil, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[Lean.Elab.Term.ElabAppArgs.State.toSetErrorCtx,[],[Array, Lean.MVarId]]
[not_exists,[exists_imp_distrib],[Iff, Not, Exists]]
[Lean.Expr.hasExprMVarEx,[Lean.Expr.hasExprMVar],[Bool]]
[Lean.PrettyPrinter.Delaborator.State.infos,[],[Std.RBMap, Lean.PrettyPrinter.Delaborator.Pos, Lean.Elab.Info, Ord.compare]]
[Lean.BinderInfo.isImplicit,[Lean.BinderInfo.default, Unit.unit, Lean.BinderInfo.strictImplicit, Lean.BinderInfo.instImplicit, Lean.BinderInfo.auxDecl, Bool, Bool.true, Bool.false],[Bool]]
[Lean.getPPAnalyzeTrustKnownFOType2TypeHOFuns,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.trustKnownFOType2TypeHOFuns, Lean.Option.defValue],[Bool]]
[Lean.Server.FileWorker.WorkerContext.srcSearchPath,[],[Lean.SearchPath]]
[Lean.Expr.getUsedConstants,[Lean.Expr.foldConsts, List.toArray, List.nil, Array.push],[Array, Lean.Name]]
[imp_congr_ctx,[Iff.trans, imp_congr_left, imp_congr_right],[Iff]]
[Lean.DefinitionSafety.partial.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.DefinitionSafety.partial, OfNat.ofNat]]
[Lean.Expr.withApp,[Lean.Expr.withAppAux, Array.mkArray, HSub.hSub, OfNat.ofNat],[]]
[Lean.Elab.Term.Do.mkFreshJP,[ite, Eq, Array.isEmpty, Bool.true, Bind.bind, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, List.toArray, List.cons, Prod.mk, Bool.false, List.nil],[Lean.Elab.Term.TermElabM, Lean.Elab.Term.Do.JPDecl]]
[Lean.Elab.Command.StructView.type,[],[Lean.Syntax]]
[IsMulLeftCancel.noConfusionType,[],[]]
[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer,[SeqRight.seqRight],[Lean.PrettyPrinter.Parenthesizer]]
[«term_>>>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Syntax.getSepArgs,[Array.getSepElems, Lean.Syntax.getArgs],[Array, Lean.Syntax]]
[Lean.StructureInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.StructureInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Function.«term_∘₂_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[List.toFloatArray.loop,[FloatArray, PProd.fst, FloatArray.push],[FloatArray]]
[bind_congr,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Bind.bind, funext, eq_self],[Eq, Bind.bind]]
[Equiv.invFun,[],[]]
[Lean.KeyedDeclsAttribute.ExtensionState.insert,[Lean.KeyedDeclsAttribute.ExtensionState.mk, List.cons, Lean.KeyedDeclsAttribute.AttributeEntry.toOLeanEntry, Lean.KeyedDeclsAttribute.ExtensionState.newEntries, Unit.unit, Lean.KeyedDeclsAttribute.Table, Lean.SMap.find?, Lean.KeyedDeclsAttribute.OLeanEntry.key, Lean.SMap.insert, List.nil, Lean.KeyedDeclsAttribute.ExtensionState.table, Std.PersistentHashSet.insert, Lean.KeyedDeclsAttribute.ExtensionState.declNames, Lean.KeyedDeclsAttribute.OLeanEntry.declName, Std.PersistentHashSet.erase, Lean.KeyedDeclsAttribute.ExtensionState.erased],[Lean.KeyedDeclsAttribute.ExtensionState]]
[Lean.Meta.Match.Extension.Entry.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Command.StructCtorView.noConfusionType,[],[]]
[Lean.MessageData.withNamingContext.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MessageData.withNamingContext, HAdd.hAdd, OfNat.ofNat]]
[Lean.Export.biStr,[Unit.unit, String, panicWithPosWithDecl, OfNat.ofNat],[String]]
[Lean.PrettyPrinter.mkFormatterAttribute,[Lean.KeyedDeclsAttribute.init, Lean.KeyedDeclsAttribute.Def.mk, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.MonadEnv.getEnv, Lean.Attribute.Builtin.getId, ite, Eq, or, and, Option.isSome, Lean.Environment.find?, Lean.Parser.isValidSyntaxNodeKind, Bool.true, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[IO, Lean.KeyedDeclsAttribute, Lean.PrettyPrinter.Formatter]]
[Lean.PrettyPrinter.Parenthesizer.State.contCat,[],[Lean.Name]]
[Lean.Rat.instDivRat,[Div.mk, HMul.hMul, Lean.Rat.inv],[Div, Lean.Rat]]
[runST,[Unit, Unit.unit],[]]
[Lean.MessageData.node.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.trans, Eq.refl, SizeOf.sizeOf, List.nil, HAdd.hAdd, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.MessageData.node, HAdd.hAdd, OfNat.ofNat]]
[Lean.instInhabitedMetavarKind,[Inhabited.mk, Lean.MetavarKind.natural],[Inhabited, Lean.MetavarKind]]
[Lean.Elab.Term.Do.hasExitPointPred,[Lean.Elab.Term.Do.hasExitPointPred.loop],[Bool]]
[Lean.ToJson.toJson,[],[Lean.Json]]
[Lean.Parser.ParserExtension.Entry.kind.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.ParserExtension.Entry.kind, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.ParserExtension.Entry.kind]]
[Lean.mkApp,[Lean.Expr.app, Lean.Expr.mkData, mixHash, UInt8.toUInt64, Hashable.hash, max, Lean.Expr.looseBVarRange, or, Lean.Expr.hasFVar, Lean.Expr.hasExprMVar, Lean.Expr.hasLevelMVar, Lean.Expr.hasLevelParam],[Lean.Expr]]
[Lean.IR.FnBody.ret.injEq,[Eq.propIntro, Eq.refl, Lean.IR.FnBody.ret, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.FnBody.ret]]
[Lean.Meta.instantiateForall,[OfNat.ofNat],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Expr.binderInfo,[Lean.Expr.Data.binderInfo, Lean.Expr.data],[Lean.BinderInfo]]
[Lean.Elab.log,[Bind.bind, Lean.Elab.MonadLog.getRef, Lean.Elab.logAt],[Unit]]
[Function.sometimes_spec,[Eq.mpr, Eq.refl, Function.sometimes, Function.sometimes_eq],[Function.sometimes]]
[Lean.Meta.GeneralizeIndicesSubgoal.fvarId,[],[Lean.FVarId]]
[Lean.Lsp.WorkDoneProgressReport.message?,[],[Option, String]]
[Array.forInUnsafe,[OfNat.ofNat, Array.forInUnsafe.loop],[]]
[Lean.Macro.instInhabitedMethods,[Inhabited.mk, Lean.Macro.Methods.mk, arbitrary],[Inhabited, Lean.Macro.Methods]]
[Lean.Parser.PrattParsingTables.leadingParsers,[],[List, Prod, Lean.Parser.Parser, Nat]]
[Mathlib.Tactic.Ext.tacticApplyExtLemma,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Core.betaReduce,[Lean.Core.transform, Pure.pure, Lean.TransformStep.visit, Lean.Expr.headBeta, Lean.TransformStep.done],[Lean.Core.CoreM, Lean.Expr]]
[Lean.getDefaultFnForField?,[Option.none, Option, Lean.Name, Lean.getProjFnForField?, ite, Eq, Lean.Environment.contains, Bool.true, Option.some],[Option, Lean.Name]]
[Nat.pred_inj,[Eq, Eq.mpr, Eq.refl, HAdd.hAdd, OfNat.ofNat, rfl, absurd, Nat.lt_irrefl],[Eq]]
[Lean.Syntax.antiquotKind?,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Syntax.atom, Lean.Syntax.ident, Option, Lean.SyntaxNodeKind, ite, Lean.Syntax.isOfKind, Array.getOp, OfNat.ofNat, Lean.Name.mkStr, Bool.true, Option.some, Option.none],[Option, Lean.SyntaxNodeKind]]
[Lean.Parser.Tactic.mkDecorations,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[noConfusionEnum,[dite, Eq, cast, noConfusionEnum.proof_1, False.elim, noConfusionEnum.proof_2],[noConfusionTypeEnum]]
[Lean.Meta.SizeOfSpecNested.Context.indInfo,[],[Lean.InductiveVal]]
[Lean.Meta.revert,[ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Prod.mk, List.toArray, List.nil, Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, ForIn.forIn, PUnit.unit, Lean.Meta.getLocalDecl, Lean.LocalDecl.isAuxDecl, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkFVar, ForInStep.yield, Lean.MonadMCtx.getMCtx, Lean.MonadLCtx.getLCtx, Lean.Meta.MetaM, Prod, Array, Lean.FVarId, Lean.MVarId, Lean.MetavarContext.MkBinding.collectDeps, MProd.mk, Lean.Expr.fvarId!, Lean.Meta.clear, Lean.Meta.getMVarTag, Lean.Meta.setMVarKind, Lean.MetavarKind.natural, tryFinally, Lean.Meta.liftMkBindingM, Lean.MetavarContext.revert, Lean.MetavarKind.syntheticOpaque],[Lean.Meta.MetaM, Prod, Array, Lean.FVarId, Lean.MVarId]]
[Lean.Elab.Command.expandBuiltinInitialize,[Lean.Elab.Command.expandInitCmd, Bool.true],[Lean.Macro]]
[monadLift_self,[rfl],[Eq, MonadLiftT.monadLift]]
[Lean.Elab.Deriving.Context.typeInfos,[],[Array, Lean.InductiveVal]]
[Lean.IR.LocalContextEntry.noConfusionType,[],[]]
[StateT.seqLeft_eq,[StateT.ext, of_eq_true, Eq.trans, congr, congrArg, Eq, StateT.run_seqLeft, StateT.run_seq, Functor.map, Function.const, Bind.bind, StateT.run_map, map_eq_pure_bind, Prod.mk, Prod.fst, Prod.snd, StateT.run, funext, LawfulMonad.bind_assoc, Pure.pure, LawfulMonad.pure_bind, congrFun, Function.const_apply, eq_self],[Eq, SeqLeft.seqLeft, Seq.seq, Functor.map, Function.const]]
[Lean.Meta.Match.instInhabitedPattern,[Inhabited.mk, Lean.Meta.Match.Pattern.inaccessible, arbitrary],[Inhabited, Lean.Meta.Match.Pattern]]
[Nat.add_le_add,[Nat.le_trans, Nat.add_le_add_right, Nat.add_le_add_left],[LE.le, HAdd.hAdd]]
[Lean.Meta.Instances.eraseCore,[Lean.Meta.Instances.mk, Lean.Meta.Instances.discrTree, Std.PersistentHashSet.erase, Lean.Meta.Instances.instanceNames, Std.PersistentHashSet.insert, Lean.Meta.Instances.erased],[Lean.Meta.Instances]]
[Lean.Meta.Cases.cases,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.MonadEnv.getEnv, ite, Eq, or, not, Lean.Environment.contains, Bool.true, Pure.pure, Option.none, Lean.Meta.getLocalDecl, Lean.Meta.whnf, Lean.LocalDecl.type, Lean.Expr.withApp, Lean.matchConstInduct, bne, Array.size, HAdd.hAdd, Lean.InductiveVal.numIndices, Lean.InductiveVal.numParams, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.Meta.MetaM, Option, Lean.Meta.Cases.Context, Lean.Environment.find?, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Lean.Meta.Cases.Context.mk, Unit.unit, Array, Lean.Meta.CasesSubgoal, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing, BEq.beq, Lean.Meta.Cases.Context.inductiveVal, OfNat.ofNat, Lean.Meta.inferType, Lean.mkFVar, Lean.Meta.getInductiveUniverseAndParams, Lean.Meta.induction, Array.mapIdx, Lean.Meta.CasesSubgoal.mk, Lean.Meta.generalizeIndices, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MessageData.ofGoal, Lean.Meta.GeneralizeIndicesSubgoal.mvarId, PUnit.unit],[Lean.Meta.MetaM, Array, Lean.Meta.CasesSubgoal]]
[Lean.Parser.Command.commentBody.formatter,[Lean.PrettyPrinter.Formatter.visitAtom, Lean.Name.anonymous],[Lean.PrettyPrinter.Formatter]]
[Lean.PrettyPrinter.Parenthesizer.decQuotDepth.parenthesizer,[],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.StructureInfo.mk.inj,[And.intro],[And, Eq]]
[ulift.noConfusionType,[],[]]
[Lean.Parser.Command.declValEqns.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.Term.matchAltsWhereDecls.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Export.Entry.name.inj,[],[Eq]]
[Lean.Meta.mkFreshExprMVarWithId,[Unit.unit, Lean.Meta.MetaM, Lean.Expr, Bind.bind, Lean.MonadLCtx.getLCtx, Lean.Meta.getLocalInstances, Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.addExprMVarDecl, Pure.pure, Lean.mkMVar, OfNat.ofNat, Lean.Meta.mkFreshLevelMVar, Lean.Meta.mkFreshExprMVar, Option.some, Lean.mkSort, Lean.MetavarKind.natural, Lean.Name.anonymous],[Lean.Meta.MetaM, Lean.Expr]]
[IO.Error.inappropriateType.inj,[And.intro],[And, Eq]]
[Lean.mkNatLit,[Lean.mkApp3, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.levelZero, List.nil, Lean.mkApp],[Lean.Expr]]
[Lean.Meta.IndPredBelow.Context.noConfusionType,[],[]]
[MonadWithReader.noConfusionType,[],[]]
[Lean.ConstantInfo.opaqueInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ConstantInfo.opaqueInfo, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.charLit.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.charLitKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.charLitNoAntiquot.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.InstanceEntry.val,[],[Lean.Expr]]
[Lean.Lsp.instInhabitedPublishDiagnosticsParams,[Inhabited.mk, Lean.Lsp.PublishDiagnosticsParams.mk, arbitrary],[Inhabited, Lean.Lsp.PublishDiagnosticsParams]]
[BEq.noConfusionType,[],[]]
[Lean.Expr.FindImpl.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Expr.FindImpl.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.introMatch,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.matchAlts],[Lean.Parser.Parser]]
[Array.back,[Array.get!, HSub.hSub, Array.size, OfNat.ofNat],[]]
[Nat.two_step_induction,[Unit.unit, PProd.fst, PProd.snd],[]]
[Classical.skolem,[Iff.intro, Classical.axiomOfChoice, Exists, Exists.intro],[Iff, Exists]]
[Lean.Meta.DiscrTree.Trie.node.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, Eq.refl, List.nil, congr, Prod.mk, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Meta.DiscrTree.Trie.node, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.getExpectedNumArgs,[Bind.bind, Lean.Meta.getExpectedNumArgsAux, Lean.Meta.MetaM, Nat, Pure.pure],[Lean.Meta.MetaM, Nat]]
[instComplementUSize,[Complement.mk, USize.complement],[Complement, USize]]
[Lean.Parser.sepByElemParser.parenthesizer,[Lean.Parser.withAntiquotSpliceAndSuffix.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol.parenthesizer, HAppend.hAppend, String.trim],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.SimplePersistentEnvExtensionDescr.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.SimplePersistentEnvExtensionDescr.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.SimplePersistentEnvExtensionDescr.mk, And]]
[Lean.Elab.Term.registerSyntheticMVarWithCurrRef,[Bind.bind, Lean.MonadRef.getRef, Lean.Elab.Term.registerSyntheticMVar],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Parser.Term.doUnless.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withForbidden.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.MonadRecDepth.getMaxRecDepth,[],[Nat]]
[Lean.IR.containsDecl,[Bind.bind, MonadState.get, Pure.pure, Lean.SMap.contains, Lean.SimplePersistentEnvExtension.getState, Lean.IR.declMapExt, Lean.IR.CompilerState.env],[Lean.IR.CompilerM, Bool]]
[ExceptCpsT.run_bind_lift,[rfl],[Eq, ExceptCpsT.run, Bind.bind, ExceptCpsT.lift]]
[Int.subNatNat_add,[],[Eq, Int.subNatNat, HAdd.hAdd, Int.ofNat]]
[Lean.Parser.Tactic.omega,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary],[Lean.ParserDescr]]
[instMonadFinallyBaseIO,[inferInstanceAs, MonadFinally, EIO, Empty],[MonadFinally, BaseIO]]
[Lean.Meta.ToHide.Context.mk.inj,[],[Eq]]
[Lean.getBuiltinAttributeImpl,[Bind.bind, ST.Ref.get, Lean.attributeMapRef, Unit.unit, IO, Lean.AttributeImpl, Std.PersistentHashMap.find?, Pure.pure, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString],[IO, Lean.AttributeImpl]]
[Lean.Compiler.SpecArgKind.fixed.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Compiler.SpecArgKind.fixed, OfNat.ofNat]]
[Lean.Attribute.Builtin.getPrio,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.getAttrParamOptPrio, Lean.Syntax.getOp, OfNat.ofNat, Lean.throwErrorAt, Lean.ToMessageData.toMessageData],[Lean.AttrM, Nat]]
[sorry,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[instDecidableEqUInt64,[UInt64.decEq],[DecidableEq, UInt64]]
[IO.FS.Stream.Buffer.noConfusionType,[],[]]
[Lean.Compiler.FFI.getLinkerFlags,[HAppend.hAppend, List.toArray, List.cons, System.FilePath.toString, HDiv.hDiv, System.FilePath.mk, List.nil, String.splitOn, String.trim],[Array, String]]
[Lean.Parser.Command.structFields.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.manyIndent.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.ppLine.formatter, Lean.PrettyPrinter.Formatter.checkColGe.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.structExplicitBinder.formatter, Lean.Parser.Command.structImplicitBinder.formatter, Lean.Parser.Command.structInstBinder.formatter, Lean.Parser.Command.structSimpleBinder.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.motiveNamed,[],[Bool]]
[String.nextWhile,[String.bsize],[String.Pos]]
[Lean.Lsp.MarkupKind.plaintext.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.MarkupKind.plaintext, OfNat.ofNat]]
[List.or_exists_of_exists_mem_cons,[Or, Exists, And, Mem.mem, Eq.mpr, Eq.refl, Eq.symm, Or.inl, Or.inr, Exists.intro, And.intro],[Or, Exists, And, Mem.mem]]
[modify,[MonadState.modifyGet, Prod.mk, PUnit.unit],[PUnit]]
[Function.surjective.of_comp,[Exists, Eq, Exists.intro],[Function.surjective]]
[Lean.Elab.Term.MutualClosure.Replacement.apply,[Lean.Expr.replace, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Expr, Option.none, Std.RBMap.find?, Option.some],[Lean.Expr]]
[Lean.Expr.isSyntheticSorry,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Name.anonymous, dite, Eq, Lean.Name.str, Eq.symm, Lean.Name.num, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Parser.noFirstTokenInfo,[Lean.Parser.ParserInfo.mk, Lean.Parser.ParserInfo.collectTokens, Lean.Parser.ParserInfo.collectKinds],[Lean.Parser.ParserInfo]]
[Lean.Parser.AliasValue.unary.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Parser.AliasValue.unary, OfNat.ofNat]]
[Nat.forRevM,[Nat.forRevM.loop],[Unit]]
[Lean.IR.Borrow.BorrowInfCtx.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Borrow.BorrowInfCtx.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.elabArg.parenthesizer,[Lean.Parser.Command.macroArg.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Tactic.triv,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Parser.Level.ident.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[instReprAtomBool,[ReprAtom.mk],[ReprAtom, Bool]]
[Lean.Server.RequestError.message,[],[String]]
[Lean.Meta.Simp.Step.visit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Simp.Step.visit, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.CompletionInfo.endSection.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.CompletionInfo.endSection, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.MaxIndex.collectDecl,[Lean.IR.MaxIndex.Collector, HAndThen.hAndThen, Array.foldl, OfNat.ofNat, Array.size, ite, GT.gt, Lean.IR.VarId.idx, Lean.IR.Param.x, Lean.IR.MaxIndex.collectFnBody],[Lean.IR.MaxIndex.Collector]]
[List.get.proof_1,[Nat.le_of_succ_le_succ, List.length_cons],[LE.le, Nat.succ, List.length]]
[List.card_insert_of_not_mem,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.card, List.insert_of_not_mem, Not, eq_false, eq_true_of_decide, Eq.refl, Bool.true, List.card_cons_of_not_mem, HAdd.hAdd, OfNat.ofNat, eq_self],[Eq, List.card, List.insert, HAdd.hAdd, OfNat.ofNat]]
[Lean.Xml.Parser.endl,[SeqRight.seqRight, HOrElse.hOrElse, Lean.Parsec.skipString, Lean.Parsec.skipChar, Char.ofNat, Pure.pure],[Lean.Parsec, Lean.Xml.Parser.LeanChar]]
[Lean.Meta.Simp.Config.iota,[],[Bool]]
[ite_not,[dite_not],[Eq, ite, Not]]
[Lean.Meta.processPostponed,[Bind.bind, Lean.Meta.getPostponed, Pure.pure, Std.PersistentArray.size, ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.processPostponed.loop],[Lean.Meta.MetaM, Bool]]
[exists_unique_congr,[exists_congr, and_congr, forall_congr', imp_congr_left],[Iff, ExistsUnique]]
[USize.modn,[USize.mk, HMod.hMod, USize.val],[USize]]
[Lean.Lsp.instFromJsonDiagnosticSeverity,[Lean.FromJson.mk, Except.error, dite, Eq, Unit.unit, Eq.symm, Except.ok, Except, String, Lean.Lsp.DiagnosticSeverity, Lean.Json.getNat?, Pure.pure, Lean.Lsp.DiagnosticSeverity.error, Lean.Lsp.DiagnosticSeverity.warning, Lean.Lsp.DiagnosticSeverity.information, Lean.Lsp.DiagnosticSeverity.hint, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.FromJson, Lean.Lsp.DiagnosticSeverity]]
[Lean.instReprPosition,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.Position.line, Std.Format.line, Lean.Position.column],[Repr, Lean.Position]]
[Function.involutive.bijective,[And.intro, Function.involutive.injective, Function.involutive.surjective],[Function.bijective]]
[IO.FileRight.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.FileRight.mk, HAdd.hAdd, OfNat.ofNat]]
[String.pushn,[Nat.repeat, String.push],[String]]
[trans_rel_right,[Eq.symm],[]]
[Lean.MessageLog.getInfoMessages,[Lean.MessageLog.mk, Std.PersistentArray.filter, Lean.MessageLog.msgs, Unit.unit, Lean.MessageSeverity.warning, Lean.MessageSeverity.error, Bool, Lean.Message.severity, Bool.true, Bool.false],[Lean.MessageLog]]
[Lean.Elab.Term.StructInst.CtorHeaderResult.ctorFn,[],[Lean.Expr]]
[Lean.mkRecName,[Lean.Name.mkStr],[Lean.Name]]
[Lean.Lsp.DocumentSymbolResult.noConfusionType,[],[]]
[StateT.monadControl,[MonadControl.mk, Prod, Bind.bind, MonadState.get, liftM, StateT.run, StateT, MonadStateOf.set, Pure.pure],[MonadControl, StateT]]
[instInhabitedUInt64,[Inhabited.mk, UInt64.ofNatCore, OfNat.ofNat, instInhabitedUInt64.proof_1],[Inhabited, UInt64]]
[Lean.Lsp.instToJsonPosition,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.Position.line, List.nil, Lean.Lsp.Position.character],[Lean.ToJson, Lean.Lsp.Position]]
[List.filterMap,[Unit.unit, List, List.nil, PProd.fst, List.cons],[List]]
[Lean.Elab.Command.mkNameFromParserSyntax,[Lean.Elab.mkUnusedBaseName, Lean.Name.mkSimple, Lean.Elab.Command.mkNameFromParserSyntax.visit, Lean.Elab.Command.mkNameFromParserSyntax.appendCatName],[Lean.MacroM, Lean.Name]]
[Lean.Parser.convParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Parser.Parser]]
[Lean.IR.Checker.checkDecl,[Lean.IR.Checker.M, Unit, Lean.IR.Checker.withParams, Lean.IR.Checker.checkFnBody, Pure.pure, Unit.unit],[Lean.IR.Checker.M, Unit]]
[Lean.Elab.DefViewElabHeader.mk.inj,[And.intro],[And, Eq]]
[Std.PersistentArray.branching,[USize.ofNat, HPow.hPow, OfNat.ofNat, USize.toNat, Std.PersistentArray.initShift],[USize]]
[Lean.Parser.Command.synth,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Acc.ndrecOn,[],[]]
[Lean.Widget.MsgToInteractive.msg,[],[Lean.Server.WithRpcRef, Lean.MessageData]]
[Lean.IR.HasIndex.visitJP,[BEq.beq, Lean.IR.JoinPointId.idx],[Bool]]
[Lean.Meta.NormNum.LawfulZero.isNat_zero,[],[Lean.Meta.NormNum.isNat, Zero.zero]]
[UInt8.instSemiringUInt8.proof_1,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt8.zero_def, UInt8.add_def, UInt8.mk, OfNat.ofNat, add_zero, UInt8.val, UInt8.mk_val_eq, eq_self, propext, forall_const, UInt8],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Array.toSubarray.proof_1,[Nat.le_refl, Array.size],[LE.le, Array.size]]
[Lean.Parser.symbol.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.tokenWithAntiquot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.symbolNoAntiquot.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Structural.mkIndPredBRecOn,[Bind.bind, liftM, Lean.Meta.inferType, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.Structural.RecArgInfo.fixedParams, Pure.pure, PUnit.unit],[Lean.Elab.Structural.M, Lean.Expr]]
[Lean.Meta.PostponedEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.PostponedEntry.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.PostponedEntry.mk, And]]
[Lean.Lsp.SymbolKind.field.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.field, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.PlainTermGoalParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.PlainTermGoalParams.mk, HAdd.hAdd, OfNat.ofNat]]
[UInt32.instRingUInt32.proof_4,[congrArg, UInt32.mk, SubNegMonoid.gsmul_neg', UInt32.val],[Eq, UInt32.mk, Ring.gsmul, Int.negSucc, UInt32.val]]
[Lean.Expr.instToStringExpr,[ToString.mk, Lean.Expr.dbgToString],[ToString, Lean.Expr]]
[Lean.Elab.Term.StructInst.trySynthStructInstance?,[ite, Eq, not, Lean.Elab.Term.StructInst.Struct.allDefault, Bool.true, Pure.pure, Option.none, MonadExcept.tryCatch, liftM, Lean.Meta.synthInstance?],[Lean.Elab.Term.TermElabM, Option, Lean.Expr]]
[Prod.id_prod,[funext, Eq, Prod.mk, Prod.fst, Prod.snd, id, rfl],[Eq, Prod.mk, Prod.fst, Prod.snd, id]]
[EStateM.instReprResult,[Repr.mk, Std.Format, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg],[Repr, EStateM.Result]]
[Lean.Parser.ppDedent,[id],[Lean.Parser.Parser]]
[Lean.Module.noConfusionType,[],[]]
[Nat.right_distrib,[],[Eq, HMul.hMul, HAdd.hAdd]]
[Lean.Lsp.instFromJsonCompletionItem,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, String, Option, Lean.Lsp.MarkupContent, Pure.pure, Lean.Lsp.CompletionItem.mk],[Lean.FromJson, Lean.Lsp.CompletionItem]]
[Lean.Syntax.expandInterpolatedStr,[Bind.bind, Lean.Syntax.expandInterpolatedStrChunks, Lean.Syntax.getArgs, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.MacroM, Lean.Syntax]]
[Lean.Meta.getArrayArgType,[Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, ite, Eq, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Elab.PreDefinition.kind,[],[Lean.Elab.DefKind]]
[Lean.Elab.Term.elabLiftMethod,[Lean.throwErrorAt, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.TermElab]]
[Lean.Meta.Cases.Context.majorTypeArgs,[],[Array, Lean.Expr]]
[Lean.PrettyPrinter.Parenthesizer.maybeParenthesize,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.Syntax.MonadTraverser.getIdx, MonadState.get, MonadStateOf.set, Lean.PrettyPrinter.Parenthesizer.State.mk, Lean.PrettyPrinter.Parenthesizer.State.stxTrav, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Prod.mk, Lean.PrettyPrinter.Parenthesizer.State.contPrec, Lean.PrettyPrinter.Parenthesizer.State.contCat, Lean.indentD, Lean.MessageData.ofFormat, Std.ToFormat.format, Pure.pure, PUnit.unit],[Lean.PrettyPrinter.ParenthesizerM, Unit]]
[Lean.Meta.mkEqNDRec,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.eq?, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr, Lean.Meta.getLevel, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.mkAppN, Lean.mkConst, List.cons, List.nil, List.toArray],[Lean.Meta.MetaM, Lean.Expr]]
[forall_imp,[],[]]
[Lean.Lsp.RpcKeepAliveParams.sessionId,[],[UInt64]]
[Lean.ConstructorVal.numFields,[],[Nat]]
[Lean.Meta.SimpLemmas.lemmaNames,[],[Std.PHashSet, Lean.Name]]
[Lean.Elab.Term.resolveName,[Bind.bind, MonadExcept.tryCatch, Lean.Elab.Term.resolveLocalName, Option.none, Lean.Elab.Term.TermElabM, DoResultPR, List, Prod, Lean.Expr, String, PUnit, ite, Eq, List.isEmpty, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, and, Lean.MonadLCtx.getLCtx, Lean.Elab.addCompletionInfo, Lean.Elab.CompletionInfo.id, Lean.Syntax.getId, Bool.false, Lean.Elab.Term.resolveName.process],[Lean.Elab.Term.TermElabM, List, Prod, Lean.Expr, String]]
[Lean.Elab.Tactic.instAlternativeTacticM,[Alternative.mk, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Elab.Tactic.orElse],[Alternative, Lean.Elab.Tactic.TacticM]]
[Std.ShareCommon.PersistentState.empty,[Std.ShareCommon.mkPersistentState, Unit.unit],[Std.ShareCommon.PersistentState]]
[Lean.Elab.Term.LetIdDeclView.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.substVars,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Classical.propDecidable,[Classical.choice, Classical.propDecidable.proof_1],[Decidable]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.knowsLevel,[],[Bool]]
[Lean.privateHeader,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Name]]
[eq_max,[le_antisymm, max, le_max_left, le_max_right, max_le],[Eq, max]]
[Nat.instAndOpNat,[AndOp.mk, Nat.land],[AndOp, Nat]]
[Lean.StructureDescr.mk.inj,[And.intro],[And, Eq]]
[IO.Process.Stdio.null.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.Process.Stdio.null, OfNat.ofNat]]
[Lean.Expr.sort.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Expr.sort, HAdd.hAdd, OfNat.ofNat]]
[Lean.MetavarContext.DependsOn.main,[ite, Eq, and, not, Lean.Expr.hasFVar, Lean.Expr.hasMVar, Bool.true, Pure.pure, Bool.false],[StateM, Lean.ExprSet, Bool]]
[Lean.Widget.InteractiveHypothesis.noConfusionType,[],[]]
[Lean.PersistentEnvExtension.getModuleEntries,[Array.get!, Lean.PersistentEnvExtensionState.importedEntries, Lean.EnvExtension.getState, Lean.PersistentEnvExtension.toEnvExtension],[Array]]
[Lean.Meta.mkLetCongr,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Int.mul_negSucc_ofNat_negSucc_ofNat,[rfl],[Eq, HMul.hMul, Int.negSucc, Int.ofNat, Nat.succ]]
[Lean.Parser.AliasTable,[Lean.NameMap, Lean.Parser.AliasValue],[]]
[Std.PersistentHashMap.isEmpty,[BEq.beq, Std.PersistentHashMap.size, OfNat.ofNat],[Bool]]
[StateT.run',[Functor.map, Prod.fst],[]]
[Mathlib.Tactic.Lint.NamedLinter.mk.inj,[And.intro],[And, Eq]]
[ToStream.noConfusionType,[],[]]
[Std.PersistentHashMap.Entry.entry.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.PersistentHashMap.Entry.entry, HAdd.hAdd, OfNat.ofNat]]
[Lean.Level.hashEx,[UInt64.toUInt32, Hashable.hash],[UInt32]]
[Lean.Parser.ParserInfo.noConfusionType,[],[]]
[instSTWorld,[STWorld.mk],[STWorld]]
[Lean.Expr.hasFVar,[Lean.Expr.Data.hasFVar, Lean.Expr.data],[Bool]]
[Lean.Parser.getBinaryAlias,[Bind.bind, Lean.Parser.getAlias, Unit.unit, Lean.Parser.AliasValue.const, Lean.Parser.AliasValue.unary, IO, Pure.pure, MonadExcept.throw, coe, HAppend.hAppend, ToString.toString],[IO]]
[WellFounded.induction,[WellFounded.recursion],[]]
[Lean.Parser.Command.in.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.withOpen.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.commandParser.formatter],[Lean.PrettyPrinter.Formatter]]
[String.foldrAux,[String.foldrAux.loop],[]]
[Lean.IR.ExpandResetReuse.mkFresh,[MonadState.modifyGet, Prod.mk, Lean.IR.VarId.mk, HAdd.hAdd, OfNat.ofNat],[Lean.IR.ExpandResetReuse.M, Lean.IR.VarId]]
[Lean.Elab.Tactic.evalManyTacticOptSemi,[Lean.Syntax.forArgsM, Bind.bind, Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.saveTacticInfoForToken],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.IR.mkIndexSet,[Std.RBTree.insert, Std.RBTree.empty],[Lean.IR.IndexSet]]
[guardHyp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Meta.InfoCacheKey.nargs?,[],[Option, Nat]]
[Lean.Expr.ReplaceLevelImpl.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.ReplaceLevelImpl.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Expr.ReplaceLevelImpl.State.mk, And]]
[Lean.Lsp.CompletionItem.label,[],[String]]
[instDecidableXor,[dite, Decidable.isFalse, instDecidableXor.proof_1, Decidable.isTrue, instDecidableXor.proof_2, instDecidableXor.proof_3, instDecidableXor.proof_4],[Decidable, xor]]
[Lean.Elab.Deriving.mkInductArgNames,[Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.InductiveVal.toConstantVal, Bind.bind, ForIn.forIn, liftM, Lean.Meta.getLocalDecl, Lean.Expr.fvarId!, Lean.Core.mkFreshUserName, Lean.Name.eraseMacroScopes, Lean.LocalDecl.userName, Pure.pure, PUnit.unit, ForInStep.yield],[Lean.Elab.Term.TermElabM, Array, Lean.Name]]
[PSigma.lex,[PSigma.lex.proof_1],[WellFounded, PSigma.Lex]]
[Lean.Elab.Term.elabNumLit,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Syntax.isNatLit?, Bind.bind, Pure.pure, Lean.Elab.throwIllFormedSyntax],[Lean.Elab.Term.TermElab]]
[Lean.Parser.Command.elab,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.suppressInsideQuot, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.docComment, Lean.Parser.Term.attrKind, Lean.Parser.symbol, Lean.Parser.optPrecedence, Lean.Parser.Command.optNamedName, Lean.Parser.Command.optNamedPrio, Lean.Parser.many1, Lean.Parser.Command.elabArg, Lean.Parser.Command.elabTail],[Lean.Parser.Parser]]
[Lean.Elab.Term.NamedArg.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.NamedArg.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.NamedArg.mk, And]]
[List.decidablePairwise.proof_3,[Iff.mpr, List.pairwise_cons, And.intro],[List.pairwise, List.cons]]
[Lean.Elab.Term.getCurrMacroScope,[Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Term.Context.currMacroScope],[Lean.Elab.Term.TermElabM, Lean.MacroScope]]
[ReaderT.read,[Pure.pure],[ReaderT]]
[Lean.Meta.CaseArraySizesSubgoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.CaseArraySizesSubgoal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.CaseArraySizesSubgoal.mk, And]]
[Lean.Meta.Closure.mkNextUserName,[Bind.bind, MonadState.get, modify, Lean.Meta.Closure.State.mk, Lean.Meta.Closure.State.visitedLevel, Lean.Meta.Closure.State.visitedExpr, Lean.Meta.Closure.State.levelParams, Lean.Meta.Closure.State.nextLevelIdx, Lean.Meta.Closure.State.levelArgs, Lean.Meta.Closure.State.newLocalDecls, Lean.Meta.Closure.State.newLocalDeclsForMVars, Lean.Meta.Closure.State.newLetDecls, HAdd.hAdd, Lean.Meta.Closure.State.nextExprIdx, OfNat.ofNat, Lean.Meta.Closure.State.exprMVarArgs, Lean.Meta.Closure.State.exprFVarArgs, Lean.Meta.Closure.State.toProcess, Pure.pure],[Lean.Meta.Closure.ClosureM, Lean.Name]]
[Lean.Widget.Lean.Widget.InteractiveGoals.instFromJsonRpcEncodingPacket,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Array, Pure.pure],[Lean.FromJson]]
[Lean.Meta.withDefault,[Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.default],[]]
[Lean.Server.FileWorker.RpcSession.store,[Prod.mk],[Prod, Lean.Lsp.RpcRef, Lean.Server.FileWorker.RpcSession]]
[Equiv.refl.proof_2,[rfl],[Eq, id]]
[Std.PersistentHashMap.EntriesNode,[Subtype, Std.PersistentHashMap.IsEntriesNode],[]]
[Lean.Elab.Term.MatchAltView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.MatchAltView.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.MatchAltView.mk, And]]
[Lean.getPPAnalysisLetVarType,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false],[Bool]]
[ByteSliceT.size,[HSub.hSub, ByteArray.size, ByteSliceT.arr, ByteSliceT.off],[Nat]]
[iff_of_true,[Iff.intro],[Iff]]
[Lean.Lsp.SymbolKind.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.SymbolKind.toCtorIdx],[]]
[EStateM.instMonadStateOfEStateM,[MonadStateOf.mk, EStateM.get, EStateM.set, EStateM.modifyGet],[MonadStateOf, EStateM]]
[Lean.Parser.Tactic.location,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.Parser.Tactic.locationWildcard, Lean.Parser.Tactic.locationHyp],[Lean.ParserDescr]]
[Option.some.injEq,[Eq.propIntro, Eq.refl, Option.some, Eq.symm, eq_of_heq, HEq.refl],[Eq, Option.some]]
[Lean.Elab.MonadInfoTree.modifyInfoState,[],[Unit]]
[MonadReaderOf.noConfusionType,[],[]]
[ExceptT.lift_pure,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, ExceptT.mk, LawfulApplicative.map_pure, Except.ok, Pure.pure, eq_self],[Eq, ExceptT.lift, Pure.pure]]
[Lean.Meta.SynthInstance.ConsumerNode.size,[],[Nat]]
[Eq.propIntro,[propext, Iff.intro],[Eq]]
[Lean.Lsp.WorkDoneProgressReport.mk.inj,[And.intro],[And, Eq]]
[Lean.addAlias,[Lean.PersistentEnvExtension.addEntry, Lean.aliasExtension, Prod.mk],[Lean.Environment]]
[Lean.Meta.SynthInstance.resume,[Bind.bind, Lean.Meta.SynthInstance.getNextToResume, Lean.Meta.SynthInstance.SynthM, Unit, Unit.unit, Lean.Meta.SynthInstance.ConsumerNode.subgoals, panicWithPosWithDecl, OfNat.ofNat, Lean.Meta.SynthInstance.tryAnswer, Lean.Meta.SynthInstance.ConsumerNode.mctx, Pure.pure, Lean.Meta.withMCtx, Lean.traceM, Lean.Name.mkStr, Lean.Name.anonymous, liftM, Lean.Meta.inferType, Lean.Meta.SynthInstance.ConsumerNode.mvar, HAppend.hAppend, Lean.ToMessageData.toMessageData, HAdd.hAdd, Lean.Meta.SynthInstance.ConsumerNode.size, Lean.Meta.SynthInstance.Answer.size, Lean.Meta.SynthInstance.consume, Lean.Meta.SynthInstance.ConsumerNode.mk, Lean.Meta.SynthInstance.ConsumerNode.key],[Lean.Meta.SynthInstance.SynthM, Unit]]
[Lean.Elab.isAbortTacticException,[Lean.Exception.error, Bool, BEq.beq, Lean.Elab.abortTacticExceptionId, Bool.false],[Bool]]
[true_eq_false_of_false,[False.elim],[Eq, True, False]]
[Char.toNat,[UInt32.toNat, Char.val],[Nat]]
[Lean.Parser.optPrecedence.formatter,[Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.precedence.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.IndPredBelow.BrecOnVariables.motives,[],[Array, Lean.FVarId]]
[or_iff_right_of_imp,[Iff.intro, id, Or.inr],[Iff, Or]]
[Std.HashMap.insert'.proof_2,[],[Std.HashMapImp.WellFormed, Prod.fst, Prod.mk]]
[Lean.ReducibilityStatus.reducible.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.ReducibilityStatus.reducible, OfNat.ofNat]]
[Nat.min,[ite, LE.le],[Nat]]
[Lean.Parser.Tactic.Conv.convTrace_state,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.JsonRpc.Message.response.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.JsonRpc.Message.response, HAdd.hAdd, OfNat.ofNat]]
[Prod.snd,[],[]]
[Lean.Constructor.name,[],[Lean.Name]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withNaryFn,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.PrettyPrinter.Delaborator.SubExpr.getPos, withTheReader, Lean.PrettyPrinter.Delaborator.SubExpr, Lean.PrettyPrinter.Delaborator.SubExpr.mk, Lean.Expr.getAppFn],[]]
[Lean.Elab.Command.isDefLike,[or, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous],[Bool]]
[lt_irrefl,[False, le_not_le_of_lt],[Not, LT.lt]]
[Lean.TransformStep.done.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.TransformStep.done, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.analyzeSort,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM, Unit]]
[Lean.Lsp.DocumentSymbol.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DocumentSymbol.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.DocumentSymbol.mk]]
[Lean.Meta.Simp.State.noConfusionType,[],[]]
[List.eraseReps,[Unit.unit, List, List.nil, List.eraseRepsAux],[List]]
[NonScalar.noConfusionType,[],[]]
[Lean.Elab.WF.TerminationHint.none.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.WF.TerminationHint.none, OfNat.ofNat]]
[List.map_subset,[Eq.mpr, Eq.trans, implies_congr, propext, List.mem_map, exists_imp_distrib, forall_congr, and_imp, Exists.intro, And.intro],[Subset.subset, List.map]]
[Lean.Parser.mkInputContext,[Lean.Parser.InputContext.mk, String.toFileMap],[Lean.Parser.InputContext]]
[Lean.Elab.MacroExpansionInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.MacroExpansionInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.MacroExpansionInfo.mk, And]]
[Lean.Json.parse,[Except, String, Lean.Json, Lean.Json.Parser.any, String.mkIterator, Except.ok, Except.error, HAppend.hAppend, ToString.toString, Nat.repr, String.Iterator.i],[Except, String, Lean.Json]]
[Nat.coprime_one_right,[Nat.gcd_one_right],[Nat.coprime, OfNat.ofNat]]
[Lean.getPPAnalyzeTrustSubtypeMk,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.trustSubtypeMk, Lean.Option.defValue],[Bool]]
[Lean.Expr.hasMVarEx,[Lean.Expr.hasMVar],[Bool]]
[Lean.Meta.mkArrow,[Bind.bind, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Lean.mkForall, Lean.BinderInfo.default],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.LocalContext.isEmpty,[Std.PersistentHashMap.isEmpty, Lean.LocalContext.fvarIdToDecl],[Bool]]
[Lean.Elab.DefKind.noConfusionType,[noConfusionTypeEnum, Lean.Elab.DefKind.toCtorIdx],[]]
[Array.swap,[Array.set, Array.swap.proof_1],[Array]]
[Lean.Meta.FunInfo.resultDeps,[],[Array, Nat]]
[Lean.Parser.withAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.orelseInfo, Lean.Parser.Parser.info, Lean.Parser.withAntiquotFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.MessageLog.errorsToWarnings,[Lean.MessageLog.mk, Std.PersistentArray.map, Lean.MessageSeverity.information, Lean.MessageSeverity.warning, Unit.unit, Lean.Message, Lean.Message.severity, Lean.Message.mk, Lean.Message.fileName, Lean.Message.pos, Lean.Message.endPos, Lean.Message.caption, Lean.Message.data, Lean.MessageLog.msgs],[Lean.MessageLog]]
[Lean.setBuiltinInitAttr,[Lean.ParametricAttribute.setParam, Lean.builtinInitAttr],[Except, String, Lean.Environment]]
[SubNegMonoid.toAddMonoid,[],[AddMonoid]]
[Lean.Lsp.ClientInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.ClientInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.coprime.gcd_both,[Nat.coprime.gcd_right, Nat.coprime.gcd_left],[Nat.coprime, Nat.gcd]]
[Lean.Widget.InteractiveGoals.noConfusionType,[],[]]
[Lean.mkQuotValEx,[Lean.QuotVal.mk, Lean.ConstantVal.mk],[Lean.QuotVal]]
[Lean.Environment.freeRegions,[Array.forM, Lean.CompactedRegion.free, Lean.EnvironmentHeader.regions, Lean.Environment.header, OfNat.ofNat, Array.size],[IO, Unit]]
[Subtype.restrict,[Subtype.val],[Subtype.val]]
[Lean.Parser.Trie.instToStringTrie,[ToString.mk, Std.Format.pretty, flip, Std.Format.joinSep, Std.Format.line, Std.Format.defWidth],[ToString, Lean.Parser.Trie]]
[List.eraseDupsAux,[List, List.reverse, Unit.unit, List.elem, PProd.fst, List.cons],[List]]
[Lean.IR.UnreachableBranches.InterpState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.UnreachableBranches.InterpState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.UnreachableBranches.InterpState.mk, And]]
[Lean.IR.FnBody.dec.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.FnBody.dec, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.elab.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.suppressInsideQuot.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.docComment.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optPrecedence.formatter, Lean.Parser.Command.optNamedName.formatter, Lean.Parser.Command.optNamedPrio.formatter, Lean.Parser.many1.formatter, Lean.Parser.Command.elabArg.formatter, Lean.Parser.Command.elabTail.formatter],[Lean.PrettyPrinter.Formatter]]
[UInt8.isUpper,[and, Decidable.decide, GE.ge, OfNat.ofNat, LE.le],[Bool]]
[Lean.KernelException.letTypeMismatch.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KernelException.letTypeMismatch, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.MarkupContent.value,[],[String]]
[or_self_right,[Iff.intro, Or.elim, id, Or.inr, Function.comp, Or.inl],[Iff, Or]]
[Lean.Lsp.instFromJsonHoverParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.HoverParams.mk, Lean.Lsp.TextDocumentPositionParams.mk],[Lean.FromJson, Lean.Lsp.HoverParams]]
[Lean.Parsec.skip,[Lean.Parsec.ParseResult.success, String.Iterator.next, Unit.unit],[Lean.Parsec, Unit]]
[Sum.inhabitedRight,[Inhabited.mk, Sum.inr, arbitrary],[Inhabited, Sum]]
[Lean.Elab.Term.registerMVarErrorInfo,[modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Std.RBMap.insert, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.MVarErrorInfo.mvarId, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.IR.ExpandResetReuse.releaseUnreadFields,[Nat.foldM, Unit.unit, Lean.IR.ExpandResetReuse.M, Lean.IR.FnBody, Array.get!, Pure.pure, Bind.bind, Lean.IR.ExpandResetReuse.mkFresh, Lean.IR.FnBody.vdecl, Lean.IR.IRType.object, Lean.IR.Expr.proj, Lean.IR.FnBody.dec, OfNat.ofNat, Bool.true, Bool.false, Array.size],[Lean.IR.ExpandResetReuse.M, Lean.IR.FnBody]]
[IO.FileRight.other,[],[IO.AccessRight]]
[Lean.Expr.headNumArgs,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.proj, Nat, PProd.fst, HAdd.hAdd, OfNat.ofNat, PProd.snd],[Nat]]
[Lean.Elab.Term.elabLetDelayedDecl,[Lean.Elab.Term.elabLetDeclCore, Bool.true, Bool.false],[Lean.Elab.Term.TermElab]]
[IO.Error.mkResourceExhaustedFile,[Function.comp, IO.Error.resourceExhausted, Option.some],[IO.Error]]
[ulift.down,[],[]]
[Lean.Parser.Command.open.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.openDecl.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[IO.Error.protocolError.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.protocolError, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.protocolError, And]]
[Lean.Syntax.SepArray.instCoeTailSepArrayArraySyntax,[CoeTail.mk, Lean.Syntax.SepArray.getElems],[CoeTail, Lean.Syntax.SepArray, Array, Lean.Syntax]]
[Lean.Lsp.instToJsonSemanticTokensParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.SemanticTokensParams.textDocument, List.nil],[Lean.ToJson, Lean.Lsp.SemanticTokensParams]]
[Lean.Parser.ParserState.lhsPrec,[],[Nat]]
[Std.AssocList.instForInAssocListProd,[ForIn.mk, Std.AssocList.forIn],[ForIn, Std.AssocList, Prod]]
[Lean.Unhygienic.Context.noConfusionType,[],[]]
[Lean.Parser.Tactic.generalizeArg,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[Lean.Parser.Command.structExplicitBinder.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Command.declModifiers.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.inferMod.formatter, Lean.Parser.Command.optDeclSig.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.binderTactic.formatter, Lean.Parser.Term.binderDefault.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Command.checkRuleKind,[or, BEq.beq, HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous],[Bool]]
[Std.PersistentHashMap.foldl,[Id.run, Std.PersistentHashMap.foldlM],[]]
[Lean.instToJsonLeanPaths,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.LeanPaths.oleanPath, List.nil, Lean.LeanPaths.srcPath],[Lean.ToJson, Lean.LeanPaths]]
[instInhabitedForInStep,[Inhabited.mk, ForInStep.done, arbitrary],[Inhabited, ForInStep]]
[Lean.Meta.AssertAfterResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.AssertAfterResult.mk, HAdd.hAdd, OfNat.ofNat]]
[Array.instBEqArray,[BEq.mk, Array.isEqv, BEq.beq],[BEq, Array]]
[Nat.lt_succ_of_lt,[Nat.le_succ_of_le],[LT.lt, Nat.succ]]
[Lean.Parser.Term.haveDecl,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HOrElse.hOrElse, Lean.Parser.Term.haveIdDecl, Lean.Parser.Term.letPatDecl, Lean.Parser.Term.haveEqnsDecl, Bool.false],[Lean.Parser.Parser]]
[Lean.IR.Borrow.OwnedSet.instHashableKey,[Hashable.mk, Lean.IR.Borrow.OwnedSet.getHash],[Hashable, Lean.IR.Borrow.OwnedSet.Key]]
[UInt16.instCommRingUInt16,[CommRing.mk, UInt16.instCommRingUInt16.proof_1],[CommRing, UInt16]]
[Lean.Meta.Match.instInhabitedAlt,[Inhabited.mk, Lean.Meta.Match.Alt.mk, arbitrary],[Inhabited, Lean.Meta.Match.Alt]]
[Lean.Meta.GeneralizeArg.expr,[],[Lean.Expr]]
[List.nodupDecidable,[List.decidablePairwise],[Decidable, List.nodup]]
[Lean.instForInMVarIdMapProdMVarId,[inferInstanceAs, ForIn, Std.RBMap, Lean.MVarId, Lean.Name.quickCmp, Lean.MVarId.name, Prod],[ForIn, Lean.MVarIdMap, Prod, Lean.MVarId]]
[Lean.Elab.Tactic.Simp.DischargeWrapper.custom.inj,[And.intro],[And, Eq]]
[Lean.Server.FileWorker.updatePendingRequests,[modify, Lean.Server.FileWorker.WorkerState.mk, Lean.Server.FileWorker.WorkerState.doc, Lean.Server.FileWorker.WorkerState.pendingRequests, Lean.Server.FileWorker.WorkerState.rpcSessions],[Lean.Server.FileWorker.WorkerM, Unit]]
[Lean.Elab.Term.PatternVar.anonymousVar.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.PatternVar.anonymousVar, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.PatternVar.anonymousVar]]
[Lean.Parser.Term.attr.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.attrParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.instReprLineRange,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.Lsp.LineRange.start, Std.Format.line, Lean.Lsp.LineRange.end],[Repr, Lean.Lsp.LineRange]]
[Prod.ext_iff,[Eq.mpr, Eq.refl, Iff, Eq, And, Prod.fst, Prod.snd, Eq.symm, Prod.mk.eta, Prod.mk, propext, Prod.mk.inj_iff, Iff.rfl],[Iff, Eq, And, Prod.fst, Prod.snd]]
[Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.addPrecCheck],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.shiftLeft,[Nat, PProd.fst, HMul.hMul, OfNat.ofNat],[Nat]]
[Lean.Parser.Command.declVal,[HOrElse.hOrElse, Lean.Parser.Command.declValSimple, Lean.Parser.Command.declValEqns, Lean.Parser.Command.whereStructInst],[Lean.Parser.Parser]]
[Lean.Meta.Match.MatchEqns.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.MatchEqns.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.MatchEqns.mk, And]]
[Lean.PrettyPrinter.Delaborator.DelabM,[ReaderT, Lean.PrettyPrinter.Delaborator.Context, StateRefT', IO.RealWorld, Lean.PrettyPrinter.Delaborator.State, Lean.Meta.MetaM],[]]
[Lean.Parser.Term.dynamicQuot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.PrettyPrinter.Formatter.parserOfStack.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.instInhabitedStructureFieldInfo,[Inhabited.mk, Lean.StructureFieldInfo.mk, arbitrary],[Inhabited, Lean.StructureFieldInfo]]
[Lean.Parser.Term.doTry.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer, Lean.Parser.many.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.doCatch.parenthesizer, Lean.Parser.Term.doCatchMatch.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.doFinally.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[StateCpsT.instMonadLiftStateCpsT,[MonadLift.mk, StateCpsT.lift],[MonadLift, StateCpsT]]
[Lean.Parser.Term.«term%%ₓ_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Term.expandOptType,[ite, Eq, Lean.Syntax.isNone, Bool.true, Lean.mkHole, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Syntax]]
[coe,[CoeT.coe],[]]
[Lean.Meta.getEqnsFor?,[Bind.bind, ST.Ref.get, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, Lean.Meta.MetaM, ForInStep, MProd, Option, Array, Lean.Name, PUnit, Pure.pure, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, MProd.fst],[Lean.Meta.MetaM, Option, Array, Lean.Name]]
[Lean.instHashableMVarId,[Hashable.mk, UInt64, mixHash, OfNat.ofNat, Hashable.hash],[Hashable, Lean.MVarId]]
[Lean.Compiler.foldNatMod,[Lean.Compiler.foldNatBinOp, Mod.mod],[Option, Lean.Expr]]
[Option.noConfusionType,[],[]]
[Lean.Parser.addBuiltinTrailingParser,[Lean.Parser.addBuiltinParser, Bool.false],[IO, Unit]]
[UInt16.instCommRingUInt16.proof_1,[UInt16.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, UInt16.val, UInt16.mul_def, CommSemiring.mul_comm],[Eq, HMul.hMul]]
[List.nil_eq_append_iff,[Eq.mpr, Eq.refl, Iff, Eq, List.nil, HAppend.hAppend, And, propext, eq_comm, List.append_eq_nil, Iff.rfl],[Iff, Eq, List.nil, HAppend.hAppend, And]]
[Char.isValidChar_of_isValidChar_Nat,[isValidChar, UInt32.ofNat', Char.isValidUInt32, Or.inl, Or.inr, And.intro],[isValidChar, UInt32.ofNat', Char.isValidUInt32]]
[Lean.Meta.Match.Example.ctor.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.refl, List.nil, Eq.trans, Eq.symm, List.cons.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Meta.Match.Example.ctor, HAdd.hAdd, OfNat.ofNat]]
[IO.Error.illegalOperation.inj,[And.intro],[And, Eq]]
[Id,[],[]]
[Lean.IR.ExplicitBoxing.BoxingContext.f,[],[Lean.IR.FunId]]
[Lean.Meta.getNondepPropHyps,[Lean.Meta.withMVarContext, Bind.bind, Lean.MonadLCtx.getLCtx, ForIn.forIn, Lean.Meta.getMVarType, ite, Eq, Std.HashSet.isEmpty, Bool.true, Pure.pure, List.toArray, List.nil, Std.HashSet.contains, Lean.LocalDecl.fvarId, PUnit.unit, ForInStep.yield, Lean.Meta.getNondepPropHyps.removeDeps],[Lean.Meta.MetaM, Array, Lean.FVarId]]
[Std.PHashSet,[Std.PersistentHashSet],[]]
[Lean.Elab.Command.ElabStructResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.ElabStructResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Command.ElabStructResult.mk, And]]
[Lean.Elab.mkInhabitantFor,[Bind.bind, MonadExcept.tryCatch, Lean.Meta.mkArbitrary, Pure.pure, Option.some, Option.none, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.Meta.mkLambdaFVars, Bool.false, Bool.true, Array.findM?, Lean.Meta.inferType, Lean.Meta.isDefEq, Array.size, Option, Lean.Meta.mkForallFVars, List.toArray, List.cons, List.nil, PProd.fst, Array.ofSubarray, Array.toSubarray, OfNat.ofNat, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM, Lean.Expr]]
[instToStreamRangeRange,[ToStream.mk],[ToStream, Std.Range]]
[List.forall_mem_singleton,[Eq.mpr, congrFun, congrArg, Iff, Eq.trans, forall_congr, implies_congr, propext, List.mem_singleton, Eq.refl, forall_eq, Iff.rfl],[Iff]]
[Lean.Parser.evalInsideQuot,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, ite, Eq, and, Decidable.decide, GT.gt, Lean.Parser.ParserContext.quotDepth, OfNat.ofNat, not, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Option.get, Lean.Parser.ParserModuleContext.options, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.internal.parseQuotWithCurrentStage, Lean.Environment.contains, Lean.Parser.ParserModuleContext.env, Bool.true, Lean.Parser.evalParserConst, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.Elab.Structural.RecArgInfo.recArgPos,[HAdd.hAdd, Array.size, Lean.Elab.Structural.RecArgInfo.fixedParams, Lean.Elab.Structural.RecArgInfo.pos],[Nat]]
[Lean.Server.instInhabitedRequestM,[Inhabited.mk, MonadExcept.throw, Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.internalError, ToString.toString, IO.userError],[Inhabited, Lean.Server.RequestM]]
[Lean.HeadIndex.forallE.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.HeadIndex.forallE, OfNat.ofNat]]
[Lean.Lsp.LocationLink.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.LocationLink.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.LocationLink.mk, And]]
[Lean.Compiler.CSimp.Entry.fromDeclName,[],[Lean.Name]]
[Nat.eq_zero_or_eq_succ_pred,[of_eq_true, Eq.trans, congr, congrArg, Or, congrFun, Eq, Nat.zero_eq, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true, eq_false', Eq.symm, Nat.succ, Nat.pred_succ, eq_self],[Or, Eq, OfNat.ofNat, Nat.succ, Nat.pred]]
[ExceptCpsT.run_pure,[rfl],[Eq, ExceptCpsT.run, Pure.pure, Except.ok]]
[Lean.Xml.Parser.NameStartChar,[Lean.Parsec.attempt, Bind.bind, Lean.Parsec.anyChar, ite, Or, And, LE.le, Char.ofNat, Pure.pure, Eq, Array.any, List.toArray, List.cons, Prod.mk, OfNat.ofNat, List.nil, Bool, Decidable.decide, Array.size, Bool.true, Lean.Parsec.fail],[Lean.Parsec, Lean.Xml.Parser.LeanChar]]
[Lean.Json.instToStringJson,[ToString.mk, Lean.Json.pretty, OfNat.ofNat],[ToString, Lean.Json]]
[Lean.isAttribute,[Std.PersistentHashMap.contains, Lean.AttributeExtensionState.map, Lean.PersistentEnvExtension.getState, Lean.attributeExtension],[Bool]]
[Lean.Elab.Term.CoeImpl.«termCoe%_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Set.image,[setOf, Exists, And, Mem.mem, Eq],[Set]]
[Lean.Parser.Term.assert,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat, Lean.Parser.Term.optSemicolon],[Lean.Parser.Parser]]
[Lean.Parser.Tactic.Conv.congr,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.IR.Arg.var.inj,[],[Eq]]
[Tactic.TryThis.delabToRefinableSyntax,[Bind.bind, readThe, Lean.Core.Context, liftM, Lean.PrettyPrinter.delab, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, EmptyCollection.emptyCollection, Tactic.TryThis.replaceMVarsByUnderscores],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Nat.mul_zero,[rfl],[Eq, HMul.hMul, OfNat.ofNat]]
[instStreamRangeNat,[Stream.mk, ite, LT.lt, Std.Range.start, Std.Range.stop, Option.some, Prod.mk, Std.Range.mk, HAdd.hAdd, Std.Range.step, Option.none],[Stream, Std.Range, Nat]]
[Lean.Elab.Tactic.AuxMatchTermState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.AuxMatchTermState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Tactic.AuxMatchTermState.mk, And]]
[Lean.Elab.Term.Do.concat,[ite, Eq, Lean.Elab.Term.Do.hasTerminalAction, Lean.Elab.Term.Do.CodeBlock.code, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.throwErrorAt, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.TermElabM, Lean.Elab.Term.Do.CodeBlock]]
[Lean.Elab.Tactic.Location.targets.inj,[And.intro],[And, Eq]]
[Lean.LocalContext.mkLocalDecl,[Lean.LocalContext, Lean.LocalContext.mk, Std.PersistentHashMap.insert, Std.PersistentArray.push, Option.some],[Lean.LocalContext]]
[Lean.LazyInitExtension.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.LazyInitExtension.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.UnreachableBranches.interpExpr,[Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Lean.IR.UnreachableBranches.M, Lean.IR.UnreachableBranches.Value, Bind.bind, Array.mapM, Lean.IR.UnreachableBranches.findArgValue, Pure.pure, Lean.IR.UnreachableBranches.Value.ctor, Lean.IR.UnreachableBranches.findVarValue, Lean.IR.UnreachableBranches.projValue, MonadReader.read, Unit.unit, Lean.IR.UnreachableBranches.getFunctionSummary?, Lean.IR.UnreachableBranches.InterpContext.env, MonadState.get, Array.findIdx?, Lean.IR.UnreachableBranches.InterpContext.decls, BEq.beq, Lean.IR.Decl.name, Std.PersistentArray.getOp, Lean.IR.UnreachableBranches.InterpState.funVals, Lean.IR.UnreachableBranches.Value.top],[Lean.IR.UnreachableBranches.M, Lean.IR.UnreachableBranches.Value]]
[noConfusionEnum.proof_2,[congrArg],[False]]
[Lean.Server.Snapshots.Snapshot.beginPos,[],[String.Pos]]
[Lean.«command_Unif_hint___Where_|-⊢_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.unifConstraintElem, Lean.unifConstraint],[Lean.ParserDescr]]
[Lean.SMap.switch,[ite, Eq, Lean.SMap.stage₁, Bool.true, Lean.SMap.mk, Bool.false, Lean.SMap.map₁, Lean.SMap.map₂],[Lean.SMap]]
[Lean.registerTraceClass,[Lean.registerOption, HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous, Lean.OptionDecl.mk, Lean.DataValue.ofBool, Bool.false],[IO, Unit]]
[ByteArray.forIn.loop.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self],[LE.le, ByteArray.size]]
[Function.bijective.exists_unique,[Iff.mp, Function.bijective_iff_exists_unique],[ExistsUnique, Eq]]
[Lean.IR.FnBody.split,[Prod.mk],[Prod, Lean.IR.FnBody]]
[Std.RBNode.ibelow,[True, And],[]]
[Lean.Elab.Term.Quotation.elabMatchSyntax,[Lean.Elab.Term.adaptExpander, Lean.Elab.Term.Quotation.match_syntax.expand],[Lean.Elab.Term.TermElab]]
[Std.PersistentHashMap.Node.collision.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.PersistentHashMap.Node.collision, HAdd.hAdd, OfNat.ofNat]]
[Lean.JsonRpc.RequestID.num.inj,[],[Eq]]
[min,[ite, LE.le],[]]
[Lean.ExprSet,[Std.HashSet, Lean.Expr],[]]
[Lean.IR.FnBody.freeIndices,[Lean.IR.FnBody.collectFreeIndices, EmptyCollection.emptyCollection],[Lean.IR.IndexSet]]
[Lean.Parser.Term.parenSpecial.formatter,[Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.tupleTail.formatter, Lean.Parser.Term.typeAscription.formatter],[Lean.PrettyPrinter.Formatter]]
[Array.reverse,[OfNat.ofNat, Array.reverse.rev],[Array]]
[Lean.Elab.Term.instInhabitedTermElabM,[Inhabited.mk, MonadExcept.throw, arbitrary],[Inhabited, Lean.Elab.Term.TermElabM]]
[Lean.popScope,[Bind.bind, ST.Ref.get, Lean.scopedEnvExtensionsRef, ForIn.forIn, PUnit.unit, Lean.MonadEnv.modifyEnv, Lean.ScopedEnvExtension.popScope, Pure.pure, ForInStep.yield],[Unit]]
[Fin.ofNat,[Fin.mk, HMod.hMod, Nat.succ, Fin.ofNat.proof_1],[Fin, Nat.succ]]
[Lean.Meta.getDefaultInstancesPriorities,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Meta.DefaultInstances.priorities, Lean.SimplePersistentEnvExtension.getState, Lean.Meta.defaultInstanceExtension],[Lean.Meta.PrioritySet]]
[Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing,[Lean.Elab.Term.synthesizeSyntheticMVars, Bool.false],[Lean.Elab.Term.TermElabM, Unit]]
[ULift.down_up,[rfl],[Eq, ULift.down, ULift.up]]
[List.append_ne_nil_of_ne_nil_right,[of_eq_true, Eq.trans, implies_congr_ctx, ne_eq, List.nil, HAppend.hAppend, congrArg, Not, propext, List.append_eq_nil, And, Eq, eq_false, and_false, eq_true_of_decide, Eq.refl, Bool.true, implies_true],[Ne, HAppend.hAppend, List.nil]]
[List.and,[List.all, id],[Bool]]
[Lean.Parser.Trie.insert,[OfNat.ofNat, Lean.Parser.Trie.insert.loop, Lean.Parser.Trie.insert.insertEmpty],[Lean.Parser.Trie]]
[Lean.Meta.dependsOn,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.exprDependsOn],[Lean.Meta.MetaM, Bool]]
[Lean.Elab.Term.Do.Alt.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Alt.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.Alt.mk, And]]
[Lean.JsonNumber.normalize,[Prod, Int, Nat, Id.run, ite, Eq, OfNat.ofNat, Prod.mk, Bind.bind, ForIn.forIn, HMod.hMod, Pure.pure, PUnit.unit, ForInStep.yield, ForInStep.done, HAdd.hAdd, Neg.neg, Int.ofNat],[Prod, Int, Nat]]
[InvImage.accessible,[InvImage.accessible.proof_1],[Acc, InvImage]]
[Nat.div_zero,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, OfNat.ofNat, Nat.div_eq, of_eq_true, Eq.trans, congrFun, congrArg, ite_congr, And, eq_false_of_decide, Bool.false, LE.le, false_and, HAdd.hAdd, Nat.sub_zero, ite_false, eq_true_of_decide, Bool.true],[Eq, HDiv.hDiv, OfNat.ofNat]]
[Lean.Meta.getFVarsToGeneralize,[Bind.bind, Lean.Meta.mkGeneralizationForbiddenSet, Lean.Meta.getFVarSetToGeneralize, Lean.Meta.sortFVarIds, Std.RBTree.toArray],[Lean.Meta.MetaM, Array, Lean.FVarId]]
[Lean.Meta.Match.MatchEqns.mk.inj,[And.intro],[And, Eq]]
[Lean.Expr.isArrow,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, not, Lean.Expr.hasLooseBVars, Bool.false],[Bool]]
[IO.Error.mkInterrupted,[IO.Error.interrupted],[IO.Error]]
[Lean.MapDeclarationExtension,[Lean.SimplePersistentEnvExtension, Prod, Lean.Name, Lean.NameMap],[]]
[Lean.Parser.ParserExtension.OLeanEntry.token.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.ParserExtension.OLeanEntry.token, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.namedPattern.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkStackTop.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Server.FileWorker.RpcSession.expireTime,[],[Nat]]
[List.foldrM,[Pure.pure, Bind.bind, PProd.fst],[]]
[Function.inv_fun_eq_of_injective_of_right_inverse,[funext, Function.inv_fun, Eq.mpr, Eq.refl, Eq, Function.inv_fun_eq, Exists.intro],[Eq, Function.inv_fun]]
[Seq.seq,[],[]]
[Lean.Syntax.mkAntiquotSuffixSpliceNode,[Lean.mkNode, HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkAtom, List.nil],[Lean.Syntax]]
[UInt32.neg_def,[rfl],[Eq, Neg.neg, UInt32.mk, UInt32.val]]
[Lean.Parser.Tactic.tacticSeqBracketed.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many.formatter, Lean.Parser.group.formatter, Lean.ppLine.formatter, Lean.Parser.tacticParser.formatter, Lean.Parser.optional.formatter, Lean.ppDedent.formatter],[Lean.PrettyPrinter.Formatter]]
[decide_eq_false,[Eq, Decidable.decide, Bool.false, absurd, rfl],[Eq, Decidable.decide, Bool.false]]
[Lean.IR.FnBody.case.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.case, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.FnBody.case, And]]
[Lean.Lsp.DidChangeTextDocumentParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.DidChangeTextDocumentParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.DidChangeTextDocumentParams.mk, And]]
[Lean.MessageData.tagged.inj,[And.intro],[And, Eq]]
[Lean.Meta.AssertAfterResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.AssertAfterResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.AssertAfterResult.mk, And]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isSubstLike,[or, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat],[Bool]]
[Lean.IR.addDecls,[Array.forM, Lean.IR.addDecl, OfNat.ofNat, Array.size],[Lean.IR.CompilerM, Unit]]
[Lean.Constructor.type,[],[Lean.Expr]]
[Lean.Parser.instInhabitedModuleParserState,[Inhabited.mk, Lean.Parser.ModuleParserState.mk, arbitrary],[Inhabited, Lean.Parser.ModuleParserState]]
[Lean.Elab.Term.PatternVarDecl.anonymousVar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.PatternVarDecl.anonymousVar, HAdd.hAdd, OfNat.ofNat]]
[SizeOf.sizeOf,[],[Nat]]
[Lean.Elab.TermInfo.expr,[],[Lean.Expr]]
[Lean.Lsp.RpcReleaseParams.sessionId,[],[UInt64]]
[Lean.PersistentExprStructMap,[Std.PHashMap, Lean.ExprStructEq],[]]
[Lean.Elab.Term.mkPairs,[HSub.hSub, Array.size, OfNat.ofNat, Array.back, Lean.Elab.Term.mkPairs.loop],[Lean.MacroM, Lean.Syntax]]
[Lean.Expr.ibelow,[True, And],[]]
[Lean.Elab.Info.occursBefore?,[OptionM.run, Bind.bind, Lean.Elab.Info.tailPos?, guard, LE.le, Pure.pure, HSub.hSub],[Option, Nat]]
[Lean.Meta.CongrTheorem.noConfusionType,[],[]]
[Lean.Expr.looseBVarRangeEx,[Lean.Expr.Data.looseBVarRange, Lean.Expr.data],[UInt32]]
[Lean.MetaEval.noConfusionType,[],[]]
[Lean.Elab.Structural.RecArgInfo.indParams,[],[Array, Lean.Expr]]
[Lean.Meta.ToHide.Context.goalTarget,[],[Lean.Expr]]
[List.toString,[Unit.unit, String, HAppend.hAppend, List.toStringAux, Bool.true, List.cons],[String]]
[UInt16.sub,[UInt16.mk, HSub.hSub, UInt16.val],[UInt16]]
[Lean.Meta.getLevel,[Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Lean.Level, Pure.pure, Lean.Meta.isReadOnlyOrSyntheticOpaqueExprMVar, ite, Eq, Bool.true, Lean.Meta.throwTypeExcepted, Lean.Meta.mkFreshLevelMVar, Lean.Meta.assignExprMVar, Lean.mkSort],[Lean.Meta.MetaM, Lean.Level]]
[Lean.Lsp.TextDocumentSyncKind.none.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.TextDocumentSyncKind.none, OfNat.ofNat]]
[Lean.QuotVal.noConfusionType,[],[]]
[Std.Format.FlattenBehavior.noConfusion,[noConfusionEnum, Std.Format.FlattenBehavior.toCtorIdx],[Std.Format.FlattenBehavior.noConfusionType]]
[String.csize,[UInt32.toNat, Char.utf8Size],[Nat]]
[Lean.Lsp.LineRange.mk.inj,[And.intro],[And, Eq]]
[lt_min,[Or.elim, le_or_gt, Eq.mpr, Eq.refl, LT.lt, min, min_eq_left, min_eq_right_of_lt],[LT.lt, min]]
[Lean.Elab.instInhabitedInfoTree,[Inhabited.mk, Lean.Elab.InfoTree.node, arbitrary],[Inhabited, Lean.Elab.InfoTree]]
[Lean.Parser.Tactic.cases',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.casesTarget, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.binderIdent],[Lean.ParserDescr]]
[Std.PersistentArray.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.PersistentArray.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.PersistentArray.mk, And]]
[Lean.Lsp.instFromJsonSemanticTokens,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Array, Nat, Pure.pure, Lean.Lsp.SemanticTokens.mk],[Lean.FromJson, Lean.Lsp.SemanticTokens]]
[Lean.Parser.Term.doFor,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.sepBy1, Lean.Parser.Term.doForDecl, Bool.false, Lean.Parser.Term.doSeq],[Lean.Parser.Parser]]
[Lean.ImportM.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.ext1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Nat.prod_dvd_and_dvd_of_dvd_prod.proof_1,[Eq.symm],[Eq, Nat.zero, Nat.gcd]]
[EStateM.Result.error.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, EStateM.Result.error, HAdd.hAdd, OfNat.ofNat]]
[IO.FS.Stream.flush,[],[IO, Unit]]
[Lean.Meta.Match.InjectionAnyResult.noConfusionType,[],[]]
[Ring.gsmul_zero',[],[Eq, Ring.gsmul, OfNat.ofNat]]
[Lean.IR.EmitC.toHexDigit,[String.singleton, Nat.digitChar],[String]]
[Lean.PrettyPrinter.Formatter,[Lean.PrettyPrinter.FormatterM, Unit],[]]
[Lean.Parser.Tactic.rcasesPat.quot,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Command.Context.noConfusionType,[],[]]
[IO.FS.Stream.readMessage,[Bind.bind, IO.FS.Stream.readJson, IO, Lean.JsonRpc.Message, Lean.FromJson.fromJson?, Pure.pure, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Lean.Json.compress],[IO, Lean.JsonRpc.Message]]
[Lean.Lsp.ReferenceContext.includeDeclaration,[],[Bool]]
[UInt32.shiftLeft,[UInt32.mk, HShiftLeft.hShiftLeft, UInt32.val, UInt32.modn, OfNat.ofNat],[UInt32]]
[MonadReader.noConfusionType,[],[]]
[Lean.PrettyPrinter.instOrElseFormatterM,[OrElse.mk, Lean.PrettyPrinter.FormatterM.orElse],[OrElse, Lean.PrettyPrinter.FormatterM]]
[let_body_congr,[],[Eq]]
[List.reverse_reverse,[Eq.mpr, Eq.refl, Eq, List.reverseAux, List.nil, List.reverseAux_reverseAux_nil, rfl],[Eq, List.reverse]]
[FloatArray.getOp,[FloatArray.get!],[Float]]
[Function.surjective.exists,[Iff.intro, Exists, Exists.intro, Eq.symm],[Iff, Exists]]
[Lean.MetavarContext.UnivMVarParamResult.mk.inj,[And.intro],[And, Eq]]
[Int.natAbs_mul_self,[Eq, Int.ofNat, HMul.hMul, Int.natAbs, rfl],[Eq, Int.ofNat, HMul.hMul, Int.natAbs]]
[Preorder.toLE,[],[LE]]
[Lean.Parser.Attr.instance.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.priorityParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.SyntheticMVarKind.postponed.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.SyntheticMVarKind.postponed, HAdd.hAdd, OfNat.ofNat]]
[Lean.Syntax.antiquotSpliceKind?,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Syntax.atom, Lean.Syntax.ident, Option, Lean.SyntaxNodeKind, Option.some, Option.none],[Option, Lean.SyntaxNodeKind]]
[Lean.IR.addBoxedVersionAux,[Bind.bind, Lean.IR.getEnv, ite, Eq, not, Lean.IR.ExplicitBoxing.requiresBoxedVersion, Bool.true, Pure.pure, Unit.unit, Lean.IR.explicitRC, Array.forM, Lean.IR.modifyEnv, Lean.IR.addDeclAux, OfNat.ofNat, Array.size],[Lean.IR.CompilerM, Unit]]
[Lean.Lsp.instFromJsonLineRange,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Nat, Pure.pure, Lean.Lsp.LineRange.mk],[Lean.FromJson, Lean.Lsp.LineRange]]
[MonadWithReader.withReader,[],[]]
[Lean.rootNamespace,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Name]]
[Lean.Xml.Parser.LeanChar,[Char],[]]
[Lean.NameSanitizerState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.NameSanitizerState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.NameSanitizerState.mk, And]]
[CoeT.noConfusionType,[],[]]
[UInt64.le,[LE.le, UInt64.val],[]]
[Lean.«termMacro.trace[__]_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Command.CollectAxioms.State.noConfusionType,[],[]]
[Std.PersistentArray.Stats.numNodes,[],[Nat]]
[Lean.getPPAnalyzeKnowsType,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.knowsType, Lean.Option.defValue],[Bool]]
[Lean.firstFrontendMacroScope,[HAdd.hAdd, Lean.reservedMacroScope, OfNat.ofNat],[Nat]]
[min_eq_left,[Eq.symm, eq_min, le_refl],[Eq, min]]
[Lean.Parser.Tactic.constructorM,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.IR.Checker.checkType,[ite, Eq, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.IR.Checker.M, Unit]]
[Lean.Meta.SynthInstance.getSubgoals,[Bind.bind, Lean.Meta.inferType, List.toArray, List.nil, OfNat.ofNat, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Lean.Meta.SynthInstance.SubgoalsResult, Lean.Expr.getAppFn, Lean.MonadEnv.getEnv, ite, Eq, Lean.Meta.SynthInstance.hasInferTCGoalsRLAttribute, Bool.true, Pure.pure, Lean.Meta.SynthInstance.SubgoalsResult.mk, List.reverse, Lean.Meta.SynthInstance.SubgoalsResult.subgoals, Lean.Meta.SynthInstance.SubgoalsResult.instVal, Lean.Meta.SynthInstance.SubgoalsResult.instTypeBody],[Lean.Meta.MetaM, Lean.Meta.SynthInstance.SubgoalsResult]]
[Lean.Parser.scientificLitNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.scientificLitFn],[Lean.Parser.Parser]]
[imp_false,[Iff.rfl],[Iff, False, Not]]
[Lean.SourceInfo.updateTrailing,[Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Lean.SourceInfo, Lean.SourceInfo.original],[Lean.SourceInfo]]
[List.findM?,[Unit.unit, Option, Pure.pure, Option.none, Bind.bind, Option.some, PProd.fst],[Option]]
[Quot.indBeta,[rfl],[Eq, Quot.ind, Quot.mk]]
[Lean.Parser.withResultOfFn,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Parser.ParserState.pushSyntax, Lean.Parser.ParserState.popSyntax],[Lean.Parser.ParserFn]]
[Tactic.Ring.horner_add_horner_gt,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Tactic.Ring.horner, Eq.symm, OfNat.ofNat, of_eq_true, Eq.trans, congr, congrArg, add_comm, HMul.hMul, HPow.hPow, add_assoc, congrFun, add_zero, add_mul, mul_assoc, pow_add, eq_self],[Eq, HAdd.hAdd, Tactic.Ring.horner]]
[Nat.coprime.gcd_mul_left_cancel_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.gcd_comm, Nat.coprime.gcd_mul_left_cancel, rfl],[Eq, Nat.gcd, HMul.hMul]]
[Lean.Parser.Tactic.tacticRfl,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.NamingContext.currNamespace,[],[Lean.Name]]
[UInt8.val_eq_of_eq,[Eq, UInt8.val, congrArg],[Eq, UInt8.val]]
[Lean.Meta.mkArbitrary,[Lean.Meta.mkAppOptM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Option.some, Option.none, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Meta.Match.MatcherResult.counterExamples,[],[List, Lean.Meta.Match.CounterExample]]
[Lean.PrettyPrinter.Formatter.Context.table,[],[Lean.Parser.TokenTable]]
[Lean.Meta.SimpLemma.keys,[],[Array, Lean.Meta.DiscrTree.Key]]
[Lean.Elab.Term.StructInst.Source.explicit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.StructInst.Source.explicit, HAdd.hAdd, OfNat.ofNat]]
[Nat.le_refl,[Nat.le.refl],[LE.le]]
[Lean.OpenDecl.explicit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.OpenDecl.explicit, HAdd.hAdd, OfNat.ofNat]]
[UInt32.toUInt8,[Nat.toUInt8, UInt32.toNat],[UInt8]]
[andM,[Bind.bind, Unit.unit, ToBool.toBool, Pure.pure],[]]
[Lean.Elab.Term.Do.ToCodeBlock.ensureEOS,[ite, Eq, List.isEmpty, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.Do.ToCodeBlock.M, Unit]]
[Std.RBNode.isBlack,[Std.RBNode.leaf, Std.RBNode.node, Std.Rbcolor.red, Bool, Bool.true, Bool.false],[Bool]]
[List.rotateRight,[ite, LE.le, OfNat.ofNat, HAppend.hAppend],[List]]
[IO.FS.Stream.Buffer.data,[],[ByteArray]]
[Lean.PrettyPrinter.ppModule,[Bind.bind, Lean.PrettyPrinter.parenthesize, Lean.Parser.Module.module.parenthesizer, Lean.PrettyPrinter.format, Lean.Parser.Module.module.formatter],[Lean.Core.CoreM, Std.Format]]
[Lean.Xml.Content.Element.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Xml.Content.Element, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.tupleTail,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.sepBy1, Lean.Parser.termParser, Bool.false],[Lean.Parser.Parser]]
[«term_::_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.mkOptionalNode,[Unit.unit, Lean.Syntax, Lean.mkNullNode, List.toArray, List.cons, List.nil],[Lean.Syntax]]
[Lean.KeyedDeclsAttribute.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KeyedDeclsAttribute.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.instToMessageDataExpr,[Lean.ToMessageData.mk, Lean.MessageData.ofExpr],[Lean.ToMessageData, Lean.Expr]]
[Lean.Meta.State.zetaFVarIds,[],[Lean.FVarIdSet]]
[Lean.Compiler.natPowThreshold,[OfNat.ofNat],[Nat]]
[Function.surj_inv,[Classical.choose],[]]
[Lean.Meta.IndPredBelow.BrecOnVariables.mk.inj,[And.intro],[And, Eq]]
[Lean.InternalExceptionId.toString,[HAppend.hAppend, ToString.toString, Lean.InternalExceptionId.idx],[String]]
[List.map_nil,[rfl],[Eq, List.map, List.nil]]
[String.instLTString,[LT.mk, LT.lt, String.data],[LT, String]]
[List.mem_inter_iff,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, List.mem_filter, List.nil, Decidable.decide, Mem.mem, congrFun, And, List.mem_nil_iff, Eq, Bool.true, false_and, eq_true_of_decide, Eq.refl, List.cons, List.mem_cons_iff, decide_eq_true_iff, iff_self, Or],[Iff, Mem.mem, List.inter, And]]
[Lean.ConstantInfo.inductInfo.inj,[],[Eq]]
[IO.AsyncList.instAppendAsyncList,[Append.mk, IO.AsyncList.append],[Append, IO.AsyncList]]
[Lean.Lsp.Command.title,[],[String]]
[Lean.Level.PP.Result.imaxNode.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.refl, SizeOf.sizeOf, List.nil, Eq.trans, HAdd.hAdd, Eq.symm, List.cons.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Level.PP.Result.imaxNode, HAdd.hAdd, OfNat.ofNat]]
[SizeOf.noConfusionType,[],[]]
[Lean.instToExprUnit,[Lean.ToExpr.mk, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.ToExpr, Unit]]
[Lean.MonadHashMapCacheAdapter.noConfusionType,[],[]]
[Lean.Parser.Term.str.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.strLit.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Level.hasMVar,[Lean.Level.Data.hasMVar, Lean.Level.data],[Bool]]
[Lean.ppDedent.formatter,[Bind.bind, Lean.MonadOptions.getOptions, Lean.PrettyPrinter.Formatter.indent, Option.some, HSub.hSub, OfNat.ofNat, Int.ofNat, Std.Format.getIndent],[Lean.PrettyPrinter.Formatter]]
[LawfulFunctor.id_map,[],[Eq, Functor.map, id]]
[Lean.Elab.Command.elabCheckFailure,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Elab.Command.failIfSucceeds, Lean.Elab.Command.elabCheckCore, Bool.false, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Lean.Elab.registerBuiltinDerivingHandlerWithArgs,[Bind.bind, liftM, IO.initializing, ite, Eq, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, IO.userError],[IO, Unit]]
[Nat.add_left_cancel,[Eq.mpr, implies_congr, congr, congrArg, Eq, Eq.trans, congrFun, HAdd.hAdd, Nat.zero_eq, Nat.zero_add, Eq.refl, Nat.succ_add, Nat.succ.injEq],[Eq]]
[Lean.MetavarContext.instantiateMVars,[ite, Eq, not, Lean.Expr.hasMVar, Bool.true, Prod.mk, runST, StateRefT'.run, Lean.MonadCacheT.run],[Prod, Lean.Expr, Lean.MetavarContext]]
[Function.right_inverse_inv_fun,[Function.inv_fun_eq],[Function.right_inverse, Function.inv_fun]]
[Lean.Parser.TokenCacheEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.TokenCacheEntry.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.TokenCacheEntry.mk, And]]
[Lean.Elab.Term.StructInst.DefaultFields.State.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.StructInst.DefaultFields.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.StructInst.DefaultFields.State.mk]]
[Lean.Parser.Tactic.nativeDecide.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.nonReservedSymbol.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[List.disjoint_append_left,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, forall_congr, implies_congr, propext, List.mem_append, Eq.refl, False, or_imp_distrib, forall_and_distrib, And, iff_self],[Iff, List.disjoint, HAppend.hAppend, And]]
[Lean.Level.any,[Option.isSome, Lean.Level.find?],[Bool]]
[Lean.Widget.Lean.MessageData.instRpcEncodingWithRpcRefMessageDataRpcRef,[Lean.Server.RpcEncoding.mk],[Lean.Server.RpcEncoding, Lean.Server.WithRpcRef, Lean.MessageData, Lean.Lsp.RpcRef]]
[Lean.Lsp.TextDocumentItem.uri,[],[Lean.Lsp.DocumentUri]]
[Lean.instToFormatKVMap,[Std.ToFormat.mk, Lean.formatKVMap],[Std.ToFormat, Lean.KVMap]]
[Lean.Parser.ParserExtension.OLeanEntry.parser.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.ParserExtension.OLeanEntry.parser, HAdd.hAdd, OfNat.ofNat]]
[Lean.Json.instCoeRBNodeStringJsonStructured,[Coe.mk, Lean.Json.Structured.obj],[Coe, Std.RBNode, String, Lean.Json, Lean.Json.Structured]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withLetVarType,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.SubExpr.descend, OfNat.ofNat, panicWithPosWithDecl],[]]
[Lean.Meta.IndPredBelow.Variables.mk.inj,[And.intro],[And, Eq]]
[Lean.Xml.Parser.NameChar,[HOrElse.hOrElse, Lean.Xml.Parser.NameStartChar, Lean.Parsec.digit, Lean.Parsec.pchar, Char.ofNat, Lean.Parsec.satisfy, Decidable.decide, Or, And, LE.le],[Lean.Parsec, Lean.Xml.Parser.LeanChar]]
[Lean.Elab.Term.Do.DoIfView.noConfusionType,[],[]]
[instToStringUInt64,[ToString.mk, ToString.toString, UInt64.toNat],[ToString, UInt64]]
[Lean.Compiler.unFoldFns,[HAppend.hAppend, List.cons, Prod.mk, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Compiler.foldNatSucc, Lean.Compiler.foldCharOfNat, List.nil, Lean.Compiler.uintFoldToNatFns],[List, Prod, Lean.Name, Lean.Compiler.UnFoldFn]]
[Lean.ConstantInfo.recInfo.injEq,[Eq.propIntro, Eq.refl, Lean.ConstantInfo.recInfo, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ConstantInfo.recInfo]]
[Lean.Elab.Structural.RecArgInfo.pos,[],[Nat]]
[UInt16.sub_def,[rfl],[Eq, HSub.hSub, UInt16.mk, UInt16.val]]
[Lean.ParametricAttributeImpl.afterSet,[],[Lean.AttrM, Unit]]
[Std.AssocList.cons.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.AssocList.cons, HAdd.hAdd, OfNat.ofNat]]
[Lean.instInhabitedPPFns,[Inhabited.mk, Lean.PPFns.mk, arbitrary],[Inhabited, Lean.PPFns]]
[Lean.Lsp.instFromJsonLeanFileProgressParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.VersionedTextDocumentIdentifier, Array, Lean.Lsp.LeanFileProgressProcessingInfo, Pure.pure, Lean.Lsp.LeanFileProgressParams.mk],[Lean.FromJson, Lean.Lsp.LeanFileProgressParams]]
[Nat.div.proof_1,[WellFoundedRelation.wf, measure, id],[WellFounded, WellFoundedRelation.rel, measure, id]]
[Int.neg_ofNat_zero,[rfl],[Eq, Neg.neg, Int.ofNat, OfNat.ofNat]]
[Lean.Export.instOfStateName,[Lean.Export.OfState.mk, Lean.Export.State.names, Lean.Export.State.mk, Lean.Export.State.levels, Lean.Export.State.exprs, Lean.Export.State.defs, Lean.Export.State.stk],[Lean.Export.OfState, Lean.Name]]
[Lean.Json.Parser.lookahead,[Bind.bind, Lean.Parsec.peek!, ite, Pure.pure, Unit.unit, Lean.Parsec.fail, HAppend.hAppend],[Lean.Parsec, Unit]]
[Lean.expandBrackedBindersAux.loop,[Unit.unit, Lean.MacroM, Lean.Syntax, Pure.pure, Bind.bind, Lean.expandExplicitBindersAux, Option.some, PProd.fst],[Lean.MacroM, Lean.Syntax]]
[Lean.Environment.isConstructor,[Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo, Bool, Lean.Environment.find?, Bool.true, Bool.false],[Bool]]
[Lean.KernelException.alreadyDeclared.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KernelException.alreadyDeclared, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.DiagnosticSeverity.error.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.DiagnosticSeverity.error, OfNat.ofNat]]
[Lean.Server.Completion.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.Completion.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Expr.FoldConstsImpl.State.visitedTerms,[],[Array, Lean.Expr]]
[List.not_mem_of_not_mem_cons,[absurd, Or.inr],[Not, Mem.mem]]
[Function.decidable_eq_pfun.proof_1,[Iff.symm, Function.funext_iff],[Iff, Eq]]
[Lean.IR.Borrow.ParamMap.getHash,[UInt64, Hashable.hash, mixHash],[UInt64]]
[Functor.map_equiv.proof_1,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Functor.map_map, Equiv.toFun, Equiv.symm, Functor.map, Equiv.symm_comp_self, LawfulFunctor.id_map, eq_self],[Eq, Functor.map, Equiv.toFun, Equiv.symm]]
[Lean.Meta.CaseValuesSubgoal.mk.inj,[And.intro],[And, Eq]]
[Lean.PrettyPrinter.Delaborator.delabAppMatch,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPNotation, Lean.getPPMatch, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.withAppFnArgs, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.PrettyPrinter.Delaborator.AppMatchState, Lean.Meta.getMatcherInfo?, Option.none, Lean.getConstInfo, Pure.pure, Lean.PrettyPrinter.Delaborator.AppMatchState.mk, Lean.ConstantInfo.instantiateTypeLevelParams, Alternative.failure, ite, LT.lt, Array.size, Lean.PrettyPrinter.Delaborator.AppMatchState.params, Lean.Meta.Match.MatcherInfo.numParams, Lean.PrettyPrinter.Delaborator.AppMatchState.info, Lean.PrettyPrinter.Delaborator.AppMatchState.matcherTy, Array.push, Lean.PrettyPrinter.Delaborator.AppMatchState.motive, Lean.PrettyPrinter.Delaborator.AppMatchState.motiveNamed, Lean.PrettyPrinter.Delaborator.AppMatchState.discrs, Lean.PrettyPrinter.Delaborator.AppMatchState.varNames, Lean.PrettyPrinter.Delaborator.AppMatchState.rhss, Lean.PrettyPrinter.Delaborator.AppMatchState.moreArgs, Eq, Option.isNone, Bool.true, Lean.Meta.lambdaTelescope, liftM, Lean.Meta.mkForallFVars, Bool.false, withTheReader, Lean.PrettyPrinter.Delaborator.SubExpr, Lean.PrettyPrinter.Delaborator.SubExpr.mk, Lean.PrettyPrinter.Delaborator.SubExpr.pos, Lean.PrettyPrinter.Delaborator.delab, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPAnalysisNamedArg, Option.some, Prod.mk, Lean.Meta.Match.MatcherInfo.numDiscrs, Lean.Meta.Match.MatcherInfo.altNumParams, List.toArray, List.nil, Array.getOp, or, Decidable.decide, PUnit.unit],[Lean.PrettyPrinter.Delaborator.Delab]]
[Nat.to_digits_core_lens_eq_aux,[Classical.em, Eq, HDiv.hDiv, OfNat.ofNat, of_eq_true, Eq.trans, congr, congrArg, List.length, ite_congr, congrFun, eq_true_of_decide, Eq.refl, Bool.true, List.cons, Nat.digitChar, HMod.hMod, Nat.toDigitsCore, if_true, HAdd.hAdd, eq_self, Eq.symm, Eq.mpr, eq_false, if_false, Eq.mp, implies_congr, trivial],[Eq, List.length, Nat.toDigitsCore]]
[Lean.Unhygienic.Context.ref,[],[Lean.Syntax]]
[Lean.Widget.goalToInteractive.pushPending,[ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Lean.Meta.MetaM, Array, Lean.Widget.InteractiveHypothesis, Lean.Widget.addInteractiveHypothesis, Option.none],[Lean.Meta.MetaM, Array, Lean.Widget.InteractiveHypothesis]]
[System.FilePath.extension,[Option.bind, System.FilePath.fileName, Unit.unit, dite, Eq, Eq.symm, Option, String, String.revPosOf, Char.ofNat, Option.none, Option.some, String.extract, HAdd.hAdd, OfNat.ofNat, String.bsize],[Option, String]]
[Lean.Meta.withoutProofIrrelevance,[Lean.Meta.withConfig, Lean.Meta.Config.mk, Lean.Meta.Config.foApprox, Lean.Meta.Config.ctxApprox, Lean.Meta.Config.quasiPatternApprox, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Bool.false, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct],[]]
[Lean.PPFns.ppGoal,[],[IO, Std.Format]]
[instToStringBool,[ToString.mk, cond],[ToString, Bool]]
[Lean.PrettyPrinter.Parenthesizer.Context.mk.inj,[],[Eq]]
[Lean.Elab.Term.MVarErrorInfo.argName?,[],[Option, Lean.Name]]
[Lean.Meta.GeneralizeTelescope.Entry.expr,[],[Lean.Expr]]
[Lean.IR.CtorInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.CtorInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.CtorInfo.mk, And]]
[Lean.Parser.Term.termReturn.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.checkLineEq.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Nat.gcd_rec,[Unit.unit, Eq, Nat.gcd, HMod.hMod, of_eq_true, Eq.trans, congrFun, congrArg, Nat.gcd_succ, HAdd.hAdd, OfNat.ofNat, eq_self, Nat.succ],[Eq, Nat.gcd, HMod.hMod]]
[Lean.mkModuleInitializationFunctionName,[HAppend.hAppend, Lean.Name.mangle],[String]]
[Lean.IR.instInhabitedDecl,[Inhabited.mk, Lean.IR.Decl.extern, arbitrary],[Inhabited, Lean.IR.Decl]]
[Lean.Elab.Structural.EqnsExtState.noConfusionType,[],[]]
[Lean.MonadCacheT.instMonadExceptOfMonadCacheT,[inferInstanceAs, MonadExceptOf, StateRefT', Std.HashMap],[MonadExceptOf, Lean.MonadCacheT]]
[Ordering.isLE,[Unit.unit, Bool, Bool.true, Bool.false],[Bool]]
[Lean.IR.Borrow.ParamMap.Key.decl.injEq,[Eq.propIntro, Eq.refl, Lean.IR.Borrow.ParamMap.Key.decl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Borrow.ParamMap.Key.decl]]
[Lean.Server.Completion.HoverInfo.inside.inj,[],[Eq]]
[Lean.ConstantVal.noConfusionType,[],[]]
[MonoidWithZero.toZero,[],[Zero]]
[Lean.Elab.Command.elabOpenPrivateLike,[Bind.bind, ForIn.forIn, Lean.resolveGlobalConstNoOverload, Lean.Meta.collectPrivateIn, Pure.pure, PUnit.unit, ForInStep.yield, Lean.MonadEnv.getEnv, Lean.Environment.moduleIdxForModule?, Lean.Syntax.getId, Option.none, Lean.Elab.Command.CommandElabM, ForInStep, Lean.NameSet, ite, Eq, Lean.isPrivateName, Bool.true, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, and, Array.isEmpty, not, Std.RBTree.isEmpty, Lean.Elab.logInfo, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format],[Lean.Elab.Command.CommandElabM, Unit]]
[add_comm,[AddCommSemigroup.add_comm],[Eq, HAdd.hAdd]]
[Lean.ppIndent.formatter,[Lean.PrettyPrinter.Formatter.indent, Option.none],[Lean.PrettyPrinter.Formatter]]
[Array.empty,[Array.mkEmpty, OfNat.ofNat],[Array]]
[Lean.Parser.Command.explode,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Parser.Term.match.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.generalizingParam.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.Term.matchDiscr.formatter, Bool.false, Lean.Parser.Term.optType.formatter, Lean.Parser.Term.matchAlts.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Lean.«tacticMatch_,,With.»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.PrettyPrinter.Parenthesizer.setExpected.parenthesizer,[],[Lean.PrettyPrinter.Parenthesizer]]
[HEq.ndrecOn,[],[]]
[Lean.NameSanitizerState.options,[],[Lean.Options]]
[Lean.SSet.fold,[Lean.SMap.fold],[]]
[Lean.throwKernelException,[Bind.bind, Lean.MonadOptions.getOptions, Lean.throwError, Lean.KernelException.toMessageData],[]]
[Lean.Parser.Term.doSeqItem.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.Parser.doElemParser.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Array.forInUnsafe.loop,[ite, LT.lt, Bind.bind, Pure.pure, Array.forInUnsafe.loop, HAdd.hAdd, OfNat.ofNat],[]]
[Lean.Compiler.CSimp.add,[Bind.bind, Lean.getConstInfo, Option.none, Option.some, Prod.mk, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Core.CoreM, Option, Lean.Compiler.CSimp.Entry, Lean.Expr.eq?, Lean.ConstantInfo.type, ite, Eq, BEq.beq, Bool.true, Pure.pure, Lean.Compiler.CSimp.Entry.mk, Unit, Lean.ScopedEnvExtension.add, Lean.Compiler.CSimp.ext, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Core.CoreM, Unit]]
[Lean.ParserCompiler.CombinatorAttribute.impl,[],[Lean.AttributeImpl]]
[Lean.Compiler.InlineAttributeKind.inline.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Compiler.InlineAttributeKind.inline, OfNat.ofNat]]
[Lean.Elab.Term.elabRawNatLit,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Syntax.isNatLit?, Lean.Syntax.getOp, OfNat.ofNat, Pure.pure, Lean.mkRawNatLit, Lean.Elab.throwIllFormedSyntax],[Lean.Elab.Term.TermElab]]
[Lean.Parser.Term.sufficesDecl.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.optIdent.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.fromTerm.parenthesizer, Lean.Parser.Term.byTactic.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.JsonRpc.Request.noConfusionType,[],[]]
[Lean.Parser.Tactic.simpPre,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Quotient.exists_rep,[Quot.exists_rep],[Exists, Eq, Quotient.mk]]
[Lean.Parser.Command.inductive.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.Command.optDeclSig.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.Command.ctor.parenthesizer, Lean.Parser.Command.optDeriving.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Structural.RecArgInfo.indName,[],[Lean.Name]]
[Lean.Parser.InputContext.input,[],[String]]
[Nat.forM,[Nat.forM.loop],[Unit]]
[Lean.Elab.Command.checkResultingUniverse,[Bind.bind, Lean.MonadOptions.getOptions, ite, Eq, Lean.Option.get, Lean.Elab.Command.bootstrap.inductiveCheckResultingUniverse, Bool.true, liftM, Lean.Meta.instantiateLevelMVars, and, not, Lean.Level.isZero, Lean.Level.isNeverZero, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.ofLevel, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElabM, Unit]]
[IO.AsyncList.cons.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.AsyncList.cons, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.AsyncList.cons, And]]
[Lean.IR.instHashableVarId,[Hashable.mk, Hashable.hash, Lean.IR.VarId.idx],[Hashable, Lean.IR.VarId]]
[ByteSlice.noConfusionType,[],[]]
[Append.append,[],[]]
[PSigma.lexAccessible,[PSigma.lexAccessible.proof_1],[Acc, PSigma.Lex, PSigma.mk]]
[Lean.Expr.ReplaceLevelImpl.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Expr.ReplaceLevelImpl.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.ScopedEnvExtension.StateStack.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ScopedEnvExtension.StateStack.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.ElimAltInfo.noConfusionType,[],[]]
[Lean.Parser.Tactic.Conv.convDone,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Meta.Rewrite.Config.transparency,[],[Lean.Meta.TransparencyMode]]
[FloatSpec.decLt,[],[DecidableRel, FloatSpec.lt]]
[Lean.Elab.instInhabitedInfoState,[Inhabited.mk, Lean.Elab.InfoState.mk, arbitrary],[Inhabited, Lean.Elab.InfoState]]
[Lean.IR.ExplicitBoxing.isBoxedName,[Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Syntax.antiquotSuffixSplice?,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Syntax.atom, Lean.Syntax.ident, Option, Lean.SyntaxNodeKind, Option.some, Option.none],[Option, Lean.SyntaxNodeKind]]
[Lean.Option.setIfNotSet,[ite, Eq, Lean.KVMap.contains, Lean.Option.name, Bool.true, Lean.Option.set],[Lean.Options]]
[List.tail_eq_of_cons_eq,[],[Eq]]
[Lean.Meta.MVarRenaming.noConfusionType,[],[]]
[Nat.le_add_left,[Nat.le_add_right, Nat.add_comm],[LE.le, HAdd.hAdd]]
[Lean.Xml.Parser.VersionInfo,[Bind.bind, SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Parsec.skipString, Lean.Xml.Parser.Eq, Lean.Xml.Parser.quote, Lean.Xml.Parser.VersionNum],[Lean.Parsec, Unit]]
[Lean.JsonRpc.ErrorCode.invalidParams.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.JsonRpc.ErrorCode.invalidParams, OfNat.ofNat]]
[Lean.Parser.Tactic.nestedTactic,[Lean.Parser.Tactic.tacticSeqBracketed],[Lean.Parser.Parser]]
[Nat.sub_sub_self,[Iff.mpr, Nat.sub_eq_iff_eq_add, Nat.sub_le, Eq.symm, Nat.add_sub_of_le],[Eq, HSub.hSub]]
[Lean.Parser.Tactic.piInstanceDeriveField,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Nat.dvd_zero,[Exists.intro, OfNat.ofNat, of_eq_true, Eq.trans, congrArg, Eq, Nat.mul_zero, eq_true_of_decide, Eq.refl, Bool.true],[Dvd.dvd, OfNat.ofNat]]
[Lean.Json.CompressWorkItem.noConfusionType,[],[]]
[Lean.Parser.Tactic.delta,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Json.isNull,[Unit.unit, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Parser.Term.letRecDecl.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.docComment.formatter, Lean.Parser.Term.attributes.formatter, Lean.Parser.Term.letDecl.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.Simp.SimpLetCase.noConfusionType,[noConfusionTypeEnum, Lean.Meta.Simp.SimpLetCase.toCtorIdx],[]]
[Lean.Expr.constLevels!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, List, Lean.Level, panicWithPosWithDecl, OfNat.ofNat],[List, Lean.Level]]
[Subarray.forInUnsafe,[USize.ofNat, Subarray.start, Subarray.forInUnsafe.loop],[]]
[Lean.Meta.mkLambdaFVars,[ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Lean.Meta.liftMkBindingM, Lean.MetavarContext.mkLambda],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Widget.InteractiveDiagnostic,[Lean.Lsp.DiagnosticWith, Lean.Widget.TaggedText, Lean.Widget.MsgEmbed],[]]
[Lean.Elab.Command.elabOpen,[Bind.bind, Lean.Elab.OpenDecl.elabOpenDecl, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Command.modifyScope, Lean.Elab.Command.Scope.mk, Lean.Elab.Command.Scope.header, Lean.Elab.Command.Scope.opts, Lean.Elab.Command.Scope.currNamespace, Lean.Elab.Command.Scope.levelNames, Lean.Elab.Command.Scope.varDecls, Lean.Elab.Command.Scope.varUIds, Lean.Elab.Command.Scope.isNoncomputable],[Lean.Elab.Command.CommandElab]]
[OfNat.noConfusionType,[],[]]
[Lean.IR.Checker.maxCtorFields,[Lean.IR.Checker.getMaxCtorFields, Unit.unit],[Nat]]
[Lean.Meta.CheckAssignment.CheckAssignmentM,[ReaderT, Lean.Meta.CheckAssignment.Context, StateRefT', IO.RealWorld, Lean.Meta.CheckAssignment.State, Lean.Meta.MetaM],[]]
[Lean.Server.FileWorker.WorkerState.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.structInstArrayRef,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.addDocString',[Unit.unit, Unit, Lean.addDocString, Pure.pure],[Unit]]
[Lean.TagDeclarationExtension,[Lean.SimplePersistentEnvExtension, Lean.Name, Lean.NameSet],[]]
[Lean.LeanPaths.oleanPath,[],[Lean.SearchPath]]
[Lean.IR.Checker.CheckerState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Checker.CheckerState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Name.isPrefixOf,[Lean.Name.str, Lean.Name.num, Bool, BEq.beq, Lean.Name.anonymous, or, PProd.fst],[Bool]]
[Lean.Parser.Term.typeOf.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.getPPAnalysisHole,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false],[Bool]]
[Lean.ClosedTermCache.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ClosedTermCache.mk, HAdd.hAdd, OfNat.ofNat]]
[IO.FS.Stream.write,[],[IO, Unit]]
[Lean.ConstantInfo.noConfusionType,[],[]]
[Lean.ScopedEnvExtension.State.state,[],[]]
[Lean.Elab.Structural.instInhabitedEqnInfo,[Inhabited.mk, Lean.Elab.Structural.EqnInfo.mk, arbitrary],[Inhabited, Lean.Elab.Structural.EqnInfo]]
[Lean.Parser.Attr.toAdditive!?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Meta.SynthInstance.Answer.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SynthInstance.Answer.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.DocumentSymbolAux.kind,[],[Lean.Lsp.SymbolKind]]
[Std.PersistentHashMap.contains,[Bool, Std.PersistentHashMap.containsAux, UInt64.toUSize, Hashable.hash],[Bool]]
[Lean.Lsp.LineRange.start,[],[Nat]]
[UInt8.eq_of_val_eq,[Eq, congrArg, UInt8.mk],[Eq]]
[UInt64.mul_def,[rfl],[Eq, HMul.hMul, UInt64.mk, UInt64.val]]
[Lean.Expr.prod?,[Lean.Expr.app2?, Lean.Name.mkStr, Lean.Name.anonymous],[Option, Prod, Lean.Expr]]
[Lean.Parser.Tactic.focus,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.params,[],[Array, Lean.Expr]]
[Lean.Elab.Term.LVal.fieldIdx.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LVal.fieldIdx, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.LVal.fieldIdx, And]]
[Lean.Lsp.DiagnosticTag.unnecessary.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.DiagnosticTag.unnecessary, OfNat.ofNat]]
[Lean.Elab.Structural.State.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Structural.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Structural.State.mk]]
[Unit.ext,[rfl],[Eq]]
[Lean.Elab.DefViewElabHeader.kind,[],[Lean.Elab.DefKind]]
[Lean.ReducibilityStatus.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Elab.Term.mkFreshBinderName,[Lean.MonadQuotation.withFreshMacroScope, Lean.MonadQuotation.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Name]]
[ExceptCpsT,[],[]]
[UInt64.instCommRingUInt64.proof_1,[UInt64.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, UInt64.val, UInt64.mul_def, CommSemiring.mul_comm],[Eq, HMul.hMul]]
[List.redLength,[Unit.unit, Nat, OfNat.ofNat, Nat.succ, PProd.fst],[Nat]]
[Lean.Parser.Attr.simp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.simpPre, Lean.Parser.Tactic.simpPost, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.decQuotDepth,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.addQuotDepthFn, Neg.neg, OfNat.ofNat, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[OfNat.ofNat,[],[]]
[Lean.activateScoped,[Bind.bind, ST.Ref.get, Lean.scopedEnvExtensionsRef, ForIn.forIn, PUnit.unit, Lean.MonadEnv.modifyEnv, Lean.ScopedEnvExtension.activateScoped, Pure.pure, ForInStep.yield],[Unit]]
[Nat.coprime_iff_gcd_eq_one,[Iff.rfl],[Iff, Nat.coprime, Eq, Nat.gcd, OfNat.ofNat]]
[Lean.Environment.setMainModule,[Lean.Environment.mk, Lean.Environment.const2ModIdx, Lean.Environment.constants, Lean.Environment.extensions, Lean.EnvironmentHeader.mk, Lean.EnvironmentHeader.trustLevel, Lean.EnvironmentHeader.quotInit, Lean.EnvironmentHeader.imports, Lean.EnvironmentHeader.regions, Lean.EnvironmentHeader.moduleNames],[Lean.Environment]]
[ReaderT.run_monadLift,[rfl],[Eq, ReaderT.run, MonadLiftT.monadLift]]
[Lean.Parser.ParserCache.mk.inj,[],[Eq]]
[Lean.Parser.Term.binrel.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.ppSpace.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Tactic.ext1?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.LBool.false.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.LBool.false, OfNat.ofNat]]
[Lean.Parser.Command.optionValue.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.strLit.formatter, Lean.Parser.numLit.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.instInhabitedScopedEnvExtension,[Inhabited.mk, Lean.ScopedEnvExtension.mk, arbitrary],[Inhabited, Lean.ScopedEnvExtension]]
[Lean.Meta.Match.Unify.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.Unify.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Sdiff.sdiff,[],[]]
[Lean.RecursorRule.rhs,[],[Lean.Expr]]
[Std.HashSetImp.noConfusionType,[],[]]
[Lean.Parser.Tactic.deriveElementwiseProof,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Elab.logException,[Unit, Lean.Elab.logErrorAt, ite, Eq, Lean.Elab.isAbortExceptionId, Bool.true, Pure.pure, PUnit.unit, Bind.bind, liftM, Lean.InternalExceptionId.getName, Lean.Elab.logError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Unit]]
[List.tail!,[Unit.unit, List, panicWithPosWithDecl, OfNat.ofNat],[List]]
[Lean.Elab.Structural.State.noConfusionType,[],[]]
[Lean.instMVarIdSetEmptyCollection,[Std.instEmptyCollectionRBTree, Lean.MVarId, Lean.Name.quickCmp, Lean.MVarId.name],[EmptyCollection, Lean.MVarIdSet]]
[exists_eq',[Exists.intro, rfl],[Exists, Eq]]
[Lean.mkLet,[Lean.Expr.letE, Lean.Expr.mkDataForLet, mixHash, UInt8.toUInt64, Hashable.hash, max, Lean.Expr.looseBVarRange, HSub.hSub, OfNat.ofNat, or, Lean.Expr.hasFVar, Lean.Expr.hasExprMVar, Lean.Expr.hasLevelMVar, Lean.Expr.hasLevelParam],[Lean.Expr]]
[Lean.Parser.Tactic.Conv.conv,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[Lean.Export.Alloc.noConfusionType,[],[]]
[List.join,[Unit.unit, List, List.nil, HAppend.hAppend, PProd.fst],[List]]
[Lean.Elab.Tactic.throwNoGoalsToBeSolved,[Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Elab.Tactic.TacticM]]
[Lean.IR.Borrow.infer,[StateT.run', Lean.IR.Borrow.collectDecls, Lean.IR.Borrow.BorrowInfCtx.mk, Lean.IR.Borrow.BorrowInfState.mk, Lean.IR.Borrow.mkInitParamMap],[Lean.IR.Borrow.ParamMap]]
[Lean.ExternEntry.standard.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ExternEntry.standard, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ExternEntry.standard, And]]
[OrOp.or,[],[]]
[Lean.LocalContext.noConfusionType,[],[]]
[Lean.MetavarContext.MkBinding.M,[ReaderT, Bool, Lean.MetavarContext.MkBinding.MCore],[]]
[Lean.KVMap.eqv,[and, Lean.KVMap.subset],[Bool]]
[Std.HashMapImp.insert,[Prod, Std.HashMapImp, Bool, ite, Eq, Std.AssocList.contains, Bool.true, Prod.mk, Std.HashMapImp.mk, Std.HashMapBucket.update, Std.AssocList.replace, LE.le, HDiv.hDiv, HMul.hMul, OfNat.ofNat, Array.size, Subtype.val, Bool.false, Std.HashMapImp.expand],[Prod, Std.HashMapImp, Bool]]
[Lean.Elab.Frontend.processCommand,[Bind.bind, Lean.Elab.Frontend.updateCmdPos, Lean.Elab.Frontend.getCommandState, Lean.Elab.Frontend.getInputContext, Lean.Elab.Frontend.getParserState, Lean.Elab.Frontend.FrontendM, Bool, Lean.profileit, Lean.Elab.Command.Scope.opts, Lean.Parser.parseCommand, Lean.Elab.Command.State.messages, modify, Lean.Elab.Frontend.State.mk, Lean.Elab.Frontend.State.commandState, Lean.Elab.Frontend.State.parserState, Lean.Elab.Frontend.State.cmdPos, Array.push, Lean.Elab.Frontend.State.commands, Lean.Elab.Frontend.setParserState, Lean.Elab.Frontend.setMessages, ite, Eq, or, Lean.Parser.isEOI, Lean.Parser.isExitCommand, Bool.true, Pure.pure, Lean.profileitM, IO.Error, Lean.Elab.Frontend.elabCommandAtFrontend, Bool.false],[Lean.Elab.Frontend.FrontendM, Bool]]
[Lean.Lsp.WorkDoneProgressReport.kind,[],[String]]
[Lean.IR.VarId.mk.inj,[],[Eq]]
[WellFounded.fixF,[],[]]
[Lean.Lsp.TextDocumentItem.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.TextDocumentItem.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.TextDocumentItem.mk, And]]
[Lean.Parser.runLongestMatchParser,[Id.run, Option.none, Id, Lean.Parser.ParserState, Bind.bind, Pure.pure, PUnit.unit],[Lean.Parser.ParserFn]]
[Lean.Elab.Tactic.Context.main,[],[Lean.MVarId]]
[Lean.SMap.instInhabitedSMap,[Inhabited.mk, Lean.SMap.mk],[Inhabited, Lean.SMap]]
[Lean.mkAppEx,[Lean.mkApp],[Lean.Expr]]
[Lean.mkDefinitionValEx,[Lean.DefinitionVal.mk, Lean.ConstantVal.mk],[Lean.DefinitionVal]]
[Lean.ParametricAttribute.getParam,[Unit.unit, Option, Lean.Environment.getModuleIdxFor?, Array.binSearch, Lean.PersistentEnvExtension.getModuleEntries, Lean.ParametricAttribute.ext, Prod.mk, arbitrary, Lean.Name.quickLt, Prod.fst, OfNat.ofNat, HSub.hSub, Array.size, Option.some, Option.none, Lean.NameMap.find?, Lean.PersistentEnvExtension.getState],[Option]]
[Lean.Expr.ReplaceImpl.cache.proof_2,[lcProof],[LT.lt, USize.toNat, Array.size]]
[Lean.DelayedMetavarAssignment.lctx,[],[Lean.LocalContext]]
[Lean.Meta.Simp.Discharge,[Lean.Meta.Simp.SimpM, Option, Lean.Expr],[]]
[Substring.front,[Substring.get, OfNat.ofNat],[Char]]
[Lean.Parser.declareLeadingBuiltinParser,[Lean.Parser.declareBuiltinParser, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Core.CoreM, Unit]]
[Lean.JsonNumber.noConfusionType,[],[]]
[Lean.StructureFieldInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.brecOnSuffix,[],[String]]
[Lean.IR.EmitC.emitDeclAux,[Bind.bind, Lean.IR.EmitC.getEnv, Lean.IR.EmitC.M, Unit, MonadWithReader.withReader, Lean.IR.EmitC.Context.mk, Lean.IR.EmitC.Context.env, Lean.IR.EmitC.Context.modName, Lean.IR.EmitC.Context.mainFn, Lean.IR.EmitC.Context.mainParams, ite, Eq, Lean.hasInitAttr, Lean.IR.Decl.name, Bool.true, Pure.pure, PUnit.unit, Lean.IR.Decl.extern, Lean.IR.EmitC.toCName, BEq.beq, Array.size, OfNat.ofNat, Lean.IR.EmitC.emit, Unit.unit],[Lean.IR.EmitC.M, Unit]]
[Std.ShareCommon.ObjectPersistentSet.find?,[Std.PersistentHashSet.find?],[Option, Std.ShareCommon.Object]]
[Lean.PrettyPrinter.Delaborator.isRegularApp,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, ite, Eq, not, Lean.Expr.isConst, Lean.PrettyPrinter.Delaborator.unfoldMDatas, Lean.Expr.getAppFn, Bool.true, Pure.pure, Bool.false, PUnit.unit],[Lean.PrettyPrinter.Delaborator.DelabM, Bool]]
[Lean.Meta.SynthInstance.Answer.noConfusionType,[],[]]
[Lean.IR.FnBody.ret.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.FnBody.ret, HAdd.hAdd, OfNat.ofNat]]
[Lean.isTracingEnabledFor,[Bind.bind, Lean.MonadTrace.getTraceState, ite, Eq, not, Lean.TraceState.enabled, Bool.true, Pure.pure, Bool.false, Lean.MonadOptions.getOptions, Lean.checkTraceOption],[Bool]]
[Lean.Elab.Command.instInhabitedState,[Inhabited.mk, Lean.Elab.Command.State.mk, arbitrary],[Inhabited, Lean.Elab.Command.State]]
[Lean.IR.LocalContext.addParams,[Array.foldl, Lean.IR.LocalContext.addParam, OfNat.ofNat, Array.size],[Lean.IR.LocalContext]]
[Lean.Meta.mapError,[controlAt, Lean.Meta.MetaM, Lean.Meta.mapErrorImp],[]]
[Lean.Expr.ReplaceLevelImpl.initCache,[Lean.Expr.ReplaceLevelImpl.State.mk, Array.mkArray, USize.toNat, Lean.Expr.ReplaceLevelImpl.cacheSize, cast, Lean.Expr.ReplaceLevelImpl.initCache.proof_1, Unit.unit, arbitrary],[Lean.Expr.ReplaceLevelImpl.State]]
[ST.Ref.mk.inj,[],[Eq]]
[Lean.Elab.Term.Do.ToTerm.mkNestedKind,[Unit.unit, Lean.Elab.Term.Do.ToTerm.Kind, Lean.Elab.Term.Do.ToTerm.Kind.regular, Lean.Elab.Term.Do.ToTerm.Kind.nestedBC, Lean.Elab.Term.Do.ToTerm.Kind.nestedPR, Lean.Elab.Term.Do.ToTerm.Kind.nestedSBC, Lean.Elab.Term.Do.ToTerm.Kind.nestedPRBC, panicWithPosWithDecl, OfNat.ofNat],[Lean.Elab.Term.Do.ToTerm.Kind]]
[Lean.Lsp.DiagnosticSeverity.information.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.DiagnosticSeverity.information, OfNat.ofNat]]
[Lean.Server.FileWorker.lakeSetupSearchPath,[Bind.bind, IO.Process.spawn, IO.Process.SpawnArgs.mk, IO.Process.StdioConfig.mk, IO.Process.Stdio.null, IO.Process.Stdio.piped, System.FilePath.toString, liftM, IO.asTask, Task.Priority.dedicated, IO.FS.Handle.readToEnd, IO.Process.Child.stdout, IO.ofExcept, Task.get, IO.Process.Child.wait, dite, Eq, UInt32.ofNat, Unit.unit, Eq.symm, IO, Lean.SearchPath, Pure.pure, Lean.Json.parse, Lean.FromJson.fromJson?, Except.error, Lean.getBuildDir, Lean.initSearchPath, Lean.LeanPaths.oleanPath, List.mapM, Lean.realPathNormalized, Lean.LeanPaths.srcPath, IO.throwServerError, HAppend.hAppend, ToString.toString, List.nil, Lean.Server.FileWorker.lakeSetupSearchPath.processStderr],[IO, Lean.SearchPath]]
[Array.allM,[Bind.bind, Array.anyM, Pure.pure, not, OfNat.ofNat, Array.size],[Bool]]
[USize.instSemiringUSize.proof_5,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, congrFun, HMul.hMul, USize.zero_def, USize.mul_def, USize.mk, OfNat.ofNat, MonoidWithZero.zero_mul, USize.val, eq_self, propext, forall_const, USize],[Eq, HMul.hMul, OfNat.ofNat]]
[panicWithPosWithDecl,[panic, HAppend.hAppend, ToString.toString],[]]
[Lean.Meta.matchHelper?,[Bind.bind, Unit.unit, Option.some, Lean.Meta.MetaM, Option, Lean.Meta.whnf, Pure.pure],[Lean.Meta.MetaM, Option]]
[PUnit.eq_punit,[PUnit.subsingleton, PUnit.unit],[Eq, PUnit.unit]]
[Lean.Meta.getHygienicIntro,[Bind.bind, Lean.MonadOptions.getOptions, Pure.pure, Lean.Option.get, Lean.Meta.tactic.hygienic],[Lean.Meta.MetaM, Bool]]
[Lean.Server.Snapshots.parseNextCmd,[IO, Lean.Syntax, Pure.pure],[IO, Lean.Syntax]]
[Bool.noConfusionType,[],[]]
[Lean.ScopedEnvExtension.pushScope,[Unit.unit, Lean.Environment, Lean.ScopedEnvExtension.StateStack.stateStack, Lean.PersistentEnvExtension.setState, Lean.ScopedEnvExtension.ext, Lean.ScopedEnvExtension.StateStack.mk, List.cons, Lean.ScopedEnvExtension.StateStack.scopedEntries, Lean.ScopedEnvExtension.StateStack.newEntries],[Lean.Environment]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.NormNum.evalEq,[Bind.bind, Lean.Meta.getLevel, Lean.Level.zero, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Meta.MetaM, Lean.Expr, Lean.Meta.synthInstance, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil, Option.none, Lean.Meta.NormNum.evalIsNat, guard, Eq, BEq.beq, Lean.Expr.natLit!, Bool.true, Pure.pure, Lean.mkApp7, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM, Lean.Expr]]
[dite_not,[Decidable.em, of_eq_true, Eq.trans, congr, congrArg, Eq, dite_congr, Not, eq_true, eq_false_of_decide, Eq.refl, Bool.false, Eq.mpr_prop, Eq.mpr_not, dite_false, not_not_intro, dite_true, eq_self, not_false, Eq.symm, eq_false, eq_true_of_decide, Bool.true, True.intro],[Eq, dite, Not, not_not_intro]]
[instAddCommMonoid_1.proof_1,[AddCommSemigroup.add_comm],[Eq, HAdd.hAdd]]
[Nat.add_mod,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, Nat.add_mod_mod, Nat.mod_add_mod, rfl],[Eq, HMod.hMod, HAdd.hAdd]]
[List.hasDecEq.proof_5,[absurd],[False]]
[Lean.Lsp.SemanticTokensParams.noConfusionType,[],[]]
[Lean.IR.mkAppExpr,[Lean.IR.Expr.ap],[Lean.IR.Expr]]
[UInt32.val,[],[Fin, UInt32.size]]
[Fin.instShiftRightFin,[ShiftRight.mk, Fin.shiftRight],[ShiftRight, Fin]]
[Lean.Environment.header,[],[Lean.EnvironmentHeader]]
[Lean.Meta.NormNum.instLawfulZero,[Lean.Meta.NormNum.instLawfulZero.proof_1],[Lean.Meta.NormNum.LawfulZero]]
[Lean.instCoeBoolDataValue,[Coe.mk, Lean.DataValue.ofBool],[Coe, Bool, Lean.DataValue]]
[Lean.Meta.mkFreshLevelMVars,[Nat.foldM, Bind.bind, Lean.Meta.mkFreshLevelMVar, Pure.pure, List.cons, List.nil],[Lean.Meta.MetaM, List, Lean.Level]]
[Lean.JsonNumber.instReprJsonNumber,[Repr.mk, Std.Format, Std.Format.bracket, HAppend.hAppend, repr, Std.Format.text],[Repr, Lean.JsonNumber]]
[Lean.IR.Expr.box.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Expr.box, HAdd.hAdd, OfNat.ofNat]]
[Lean.Option.get,[Lean.KVMap.get, Lean.Option.name, Lean.Option.defValue],[]]
[Lean.StructureFieldInfo.projFn,[],[Lean.Name]]
[Lean.Elab.Structural.findRecArg,[Bind.bind, liftM, IO.mkRef, EmptyCollection.emptyCollection, ForIn.forIn, PUnit.unit, Lean.Meta.inferType, Lean.Meta.forEachExpr, Lean.matchConstInduct, Lean.Expr.getAppFn, Pure.pure, Unit.unit, ite, Eq, and, Decidable.decide, GT.gt, Lean.InductiveVal.numIndices, OfNat.ofNat, BEq.beq, HAdd.hAdd, Lean.InductiveVal.numParams, Lean.Expr.getAppNumArgs, Bool.true, Lean.Expr.isFVar, Array.any, Array.size, ST.Ref.modify, Std.RBTree.insert, Lean.Expr.fvarId!, ForInStep.yield, ST.Ref.get, Lean.Elab.Structural.findRecArg.go],[Lean.Elab.Structural.M]]
[instToStringByteSlice,[ToString.mk, Id.run, Bind.bind, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield],[ToString, ByteSlice]]
[Lean.BinderInfo.noConfusion,[noConfusionEnum, Lean.BinderInfo.toCtorIdx],[Lean.BinderInfo.noConfusionType]]
[Lean.Lsp.instFromJsonPlainGoalParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.PlainGoalParams.mk, Lean.Lsp.TextDocumentPositionParams.mk],[Lean.FromJson, Lean.Lsp.PlainGoalParams]]
[Nat.gcd_dvd_gcd_mul_left_right,[Nat.gcd_dvd_gcd_of_dvd_right, Nat.dvd_mul_left],[Dvd.dvd, Nat.gcd, HMul.hMul]]
[Lean.Lsp.RpcConnectParams.mk.inj,[],[Eq]]
[Lean.LocalDecl.index,[Nat],[Nat]]
[Lean.AttributeImpl.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.AttributeImpl.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.AttributeImpl.mk, And]]
[Lean.PrettyPrinter.ppCommand,[Bind.bind, Lean.PrettyPrinter.parenthesizeCommand, Lean.PrettyPrinter.formatCommand],[Lean.Core.CoreM, Std.Format]]
[Nat.add_sub_add_right,[Eq, HSub.hSub, HAdd.hAdd, Eq.mpr, Eq.refl, OfNat.ofNat, Nat.add_zero, rfl, Nat.add_succ, Nat.succ, Nat.succ_sub_succ, PProd.fst],[Eq, HSub.hSub, HAdd.hAdd]]
[instToStringProd,[ToString.mk, String, HAppend.hAppend, ToString.toString],[ToString, Prod]]
[Lean.Parser.Tactic.rintroPat.one,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Mathlib.Tactic.Lint.Linter.errorsFound,[],[Lean.MessageData]]
[Lean.Meta.apply,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType, Lean.Meta.inferType, Lean.Meta.getExpectedNumArgsAux, Lean.Meta.MetaM, List, Lean.MVarId, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.getExpectedNumArgs],[Lean.Meta.MetaM, List, Lean.MVarId]]
[instOrdUInt8,[Ord.mk, compareOfLessAndEq],[Ord, UInt8]]
[Lean.Parser.declareBuiltinParser,[Lean.declareBuiltin],[Lean.Core.CoreM, Unit]]
[Lean.ImportState.moduleNameSet,[],[Lean.NameSet]]
[Lean.Parser.strAux,[Lean.Parser.strAux.parse],[Lean.Parser.ParserFn]]
[Lean.MessageData.instAppendMessageData,[Append.mk, Lean.MessageData.compose],[Append, Lean.MessageData]]
[Lean.Parser.fieldIdxFn,[ite, Eq, and, Char.isDigit, bne, Char.ofNat, Bool.true, Lean.Parser.mkNodeToken, Lean.fieldIdxKind, Lean.Parser.ParserState.mkErrorAt, Option.some],[Lean.Parser.ParserFn]]
[Lean.Elab.Tactic.closeMainGoal,[ite, Eq, Bool.true, Bind.bind, Lean.Elab.Tactic.ensureHasNoMVars, Pure.pure, PUnit.unit],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.Lsp.ServerCapabilities.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.ServerCapabilities.mk, HAdd.hAdd, OfNat.ofNat]]
[List.mem_nil,[Iff.rfl],[Iff, Mem.mem, List.nil, False]]
[«term_^^^_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Import.module,[],[Lean.Name]]
[Lean.Parser.Term.attrKind,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.optional, HOrElse.hOrElse, Lean.Parser.Term.scoped, Lean.Parser.Term.local],[Lean.Parser.Parser]]
[Float.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Float.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.find_min,[And.right, Subtype.property, Nat.find_x],[Not]]
[Lean.Parser.Term.attributes.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.Term.attrInstance.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[or,[Unit.unit, Bool, Bool.true],[Bool]]
[Lean.Lsp.instFileSourceDidOpenTextDocumentParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.DidOpenTextDocumentParams.textDocument],[Lean.Lsp.FileSource, Lean.Lsp.DidOpenTextDocumentParams]]
[Lean.instBEqLBool,[BEq.mk, BEq.beq, Lean.LBool.toCtorIdx],[BEq, Lean.LBool]]
[Lean.Lsp.WaitForDiagnosticsParams.version,[],[Nat]]
[Lean.Lsp.SaveOptions.noConfusionType,[],[]]
[Lean.ReducibilityHints.isAbbrev,[Lean.ReducibilityHints.opaque, Unit.unit, Lean.ReducibilityHints.regular, Bool, Bool.true, Bool.false],[Bool]]
[Id.map_eq,[rfl],[Eq, Functor.map]]
[Lean.Elab.Term.getPatternsVars,[Bind.bind, StateRefT'.run, Lean.Elab.Term.CollectPatternVars.State.mk, Lean.Elab.Term.TermElabM, Array, Lean.Elab.Term.PatternVar, Pure.pure, Lean.Elab.Term.CollectPatternVars.State.vars],[Lean.Elab.Term.TermElabM, Array, Lean.Elab.Term.PatternVar]]
[Array.uget,[Array.get, Fin.mk, USize.toNat],[]]
[Lean.Xml.Parser.XMLdecl,[Bind.bind, Lean.Parsec.skipString, Lean.Xml.Parser.VersionInfo, SeqRight.seqRight, optional, Lean.Xml.Parser.EncodingDecl, Lean.Xml.Parser.SDDecl, Lean.Xml.Parser.S],[Lean.Parsec, Unit]]
[Nat.sub_one,[rfl],[Eq, HSub.hSub, OfNat.ofNat, Nat.pred]]
[Lean.Expr.ReplaceImpl.replaceUnsafeM,[Lean.Expr.ReplaceImpl.replaceUnsafeM.visit],[Lean.Expr.ReplaceImpl.ReplaceM, Lean.Expr]]
[Lean.Meta.Match.Unify.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Unify.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.Unify.Context.mk]]
[Mathlib.Tactic.Lint.withSimpLemmaInfos,[Lean.Meta.withReducible, Bind.bind, Lean.Meta.mkSorry, Bool.true, Bool.false, Array.mapM, Lean.Meta.MetaM, Lean.Meta.forallTelescopeReducing, Pure.pure, Lean.Expr.eq?, Option.none, Mathlib.Tactic.Lint.isConditionalHyps, Array.toList, Mathlib.Tactic.Lint.SimpLemmaInfo.mk, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, List.toArray],[Lean.Meta.MetaM, Array]]
[Fin.mod_eq_val,[Nat.mod_eq_of_lt, Fin.isLt],[Eq, HMod.hMod, Fin.val]]
[Lean.instToMessageDataOptionExpr,[Lean.ToMessageData.mk, Unit.unit, Lean.MessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.ToMessageData.toMessageData],[Lean.ToMessageData, Option, Lean.Expr]]
[Lean.PrettyPrinter.Formatter.error.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[OptionM,[OptionT, Id],[]]
[Lean.Elab.PreDefinition.levelParams,[],[List, Lean.Name]]
[UInt8.instSemiringUInt8.proof_3,[congrArg, UInt8.mk, Semiring.nsmul_zero', UInt8.val],[Eq, UInt8.mk, Semiring.nsmul, OfNat.ofNat, UInt8.val]]
[Lean.Elab.Term.instMetaEvalTermElabM,[Lean.MetaEval.mk, Lean.MetaEval.eval, Lean.Elab.Term.TermElabM.run', Lean.Elab.Term.Context.mk, arbitrary, Lean.Elab.Term.State.mk, Bool.true],[Lean.MetaEval, Lean.Elab.Term.TermElabM]]
[Lean.getProjectionFnInfo?,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Environment.getProjectionFnInfo?],[Option, Lean.ProjectionFunctionInfo]]
[Lean.Meta.mkSizeOfInstances,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, Lean.Meta.isInductivePredicate, ite, Eq, and, Lean.Environment.contains, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Option.get, Lean.Meta.genSizeOf, not, Bool.true, Lean.getConstInfoInduct, Lean.InductiveVal.isUnsafe, Pure.pure, PUnit.unit, Lean.Meta.mkSizeOfFns, Lean.Meta.MetaM, Unit, ForIn.forIn, Unit.unit, ForInStep, Subarray, Lean.Name, Stream.next?, ForInStep.done, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.InductiveVal.toConstantVal, OfNat.ofNat, List.toArray, List.nil, Array.ofSubarray, Lean.Meta.mkAppM, List.cons, Lean.Meta.withLocalDeclD, Lean.Meta.mkLambdaFVars, Lean.mkAppN, Lean.mkConst, HAppend.hAppend, Bool.false, Lean.Meta.mkForallFVars, Lean.addDecl, Lean.Declaration.defnDecl, Lean.DefinitionVal.mk, Lean.ConstantVal.mk, Lean.ConstantVal.levelParams, Lean.ReducibilityHints.abbrev, Lean.DefinitionSafety.safe, Lean.Meta.addInstance, Lean.AttributeKind.global, ForInStep.yield, Lean.Meta.genSizeOfSpec, Lean.getConstInfoCtor, Lean.ConstructorVal.toConstantVal, Lean.Meta.mkNumeral, Lean.Meta.inferType, Lean.Meta.whnf, Lean.Expr.isForall, Lean.Meta.mkAdd, Lean.Meta.mkEq, Lean.InductiveVal.isNested, ReaderT.run, Lean.Meta.SizeOfSpecNested.main, Lean.Meta.SizeOfSpecNested.Context.mk, Lean.Meta.mkEqRefl, Lean.InductiveVal.all],[Lean.Meta.MetaM, Unit]]
[Lean.Parser.Command.postfix.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Std.RBMap.isEmpty,[Subtype.mk, Std.RBNode.node, Bool, Bool.true, Bool.false],[Bool]]
[List.getLast!.proof_1,[],[List.noConfusionType, False, List.cons, List.nil]]
[Lean.Lsp.LocationLink.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.LocationLink.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.FnBody.case.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, Eq.refl, List.nil, congr, Lean.IR.AltCore.ctor, Lean.IR.AltCore.default, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.IR.FnBody.case, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.getLocalInstances,[Bind.bind, MonadReader.read, Pure.pure, Lean.Meta.Context.localInstances],[Lean.Meta.MetaM, Lean.LocalInstances]]
[Lean.Meta.IndPredBelow.Context.typeInfos,[],[Array, Lean.InductiveVal]]
[Lean.Lsp.Trace.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.Trace.toCtorIdx],[]]
[Lean.Parser.Tactic.measurability,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Function.bijective.of_comp_iff,[and_congr, Function.injective.of_comp_iff', Function.surjective.of_comp_iff, Function.bijective.surjective],[Iff, Function.bijective, Function.comp]]
[Lean.PrettyPrinter.Delaborator.mkAppUnexpanderAttribute,[Lean.KeyedDeclsAttribute.init, Lean.KeyedDeclsAttribute.Def.mk, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.Attribute.Builtin.getId, Lean.resolveGlobalConstNoOverloadCore],[IO, Lean.KeyedDeclsAttribute, Lean.PrettyPrinter.Unexpander]]
[List.disjoint_of_disjoint_append_left_left,[And.left, Iff.mp, List.disjoint_append_left],[List.disjoint]]
[Lean.Elab.Deriving.Repr.mkBodyForInduct.mkAlts,[Bind.bind, ForIn.forIn, Lean.getConstInfoCtor, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, PUnit.unit, ForInStep.yield, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, MProd.mk, liftM, Lean.Core.mkFreshUserName, Lean.Meta.inferType, ite, Eq, Lean.Expr.isAppOf, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Bool.true, Lean.mkIdent, Lean.Elab.Term.TermElabM, Lean.Syntax, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom],[Lean.Elab.Term.TermElabM, Array, Lean.Syntax]]
[Lean.JsonRpc.ResponseError.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.JsonRpc.ResponseError.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.IsLive.visitExpr,[Pure.pure, Lean.IR.HasIndex.visitExpr],[Lean.IR.IsLive.M, Bool]]
[Char.le,[LE.le, Char.val],[]]
[Lean.SCC.State.mk.inj,[And.intro],[And, Eq]]
[Lean.TraceState.enabled,[],[Bool]]
[Lean.Server.FileWorker.WorkerState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.FileWorker.WorkerState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.getPPStructureInstanceType,[Lean.KVMap.get, Lean.Option.name, Lean.pp.structureInstanceTypes, Lean.getPPAll],[Bool]]
[StateCpsT.lift,[Bind.bind],[StateCpsT]]
[Lean.Meta.addUnificationHint,[Lean.Meta.withNewMCtxDepth, Bind.bind, Lean.getConstInfo, Unit.unit, Lean.Meta.MetaM, Unit, Lean.ConstantInfo.value?, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Meta.lambdaMetaTelescope, Option.none, List.toArray, List.nil, ExceptT, Lean.MessageData, Id, Lean.Meta.UnificationConstraint, Lean.Expr.eq?, Pure.pure, Lean.Meta.UnificationConstraint.mk, MonadExcept.throw, HAppend.hAppend, Lean.indentExpr, Lean.Meta.DiscrTree.mkPath, Lean.Meta.UnificationConstraint.lhs, Lean.Meta.UnificationHint.pattern, List.forM, Lean.Meta.UnificationHint.constraints, Lean.Meta.isDefEq, Lean.Meta.UnificationConstraint.rhs, ite, Eq, Bool.true, PUnit.unit, Lean.ScopedEnvExtension.add, Lean.Meta.unificationHintExtension, Lean.Meta.UnificationHintEntry.mk, Lean.isTracingEnabledFor, Lean.MonadEnv.getEnv, Lean.addTrace, Lean.ScopedEnvExtension.getState],[Lean.Meta.MetaM, Unit]]
[Lean.IR.CtorInfo.mk.inj,[And.intro],[And, Eq]]
[Int.rem,[Int, Int.ofNat, HMod.hMod, Nat.succ, Neg.neg],[Int]]
[Lean.Meta.simpTargetCore,[Bind.bind, Lean.Meta.getMVarType, Lean.Meta.instantiateMVars, Lean.Meta.simp, ite, Eq, Lean.Expr.isConstOf, Lean.Meta.Simp.Result.expr, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Unit.unit, Lean.Meta.MetaM, Option, Lean.MVarId, Lean.Meta.Simp.Result.proof?, Lean.Meta.mkOfEqTrue, Lean.Meta.assignExprMVar, Lean.mkConst, List.nil, coeM, Lean.Meta.applySimpResultToTarget],[Lean.Meta.MetaM, Option, Lean.MVarId]]
[Lean.Server.Completion.addToBlackList,[Lean.TagDeclarationExtension.tag, Lean.Server.Completion.completionBlackListExt],[Lean.Environment]]
[Nat.gcd_mul_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.mul_comm, Nat.gcd_mul_left, rfl],[Eq, Nat.gcd, HMul.hMul]]
[Array.findSomeM?,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, ForInStep, MProd, Option, PUnit, Pure.pure, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, MProd.fst],[Option]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM,[ReaderT, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context, StateRefT', IO.RealWorld, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State, Lean.Meta.MetaM],[]]
[Lean.Elab.Term.SyntheticMVarKind.tactic.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.SyntheticMVarKind.tactic, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.SyntheticMVarKind.tactic, And]]
[Lean.Lsp.DocumentHighlightParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DocumentHighlightParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.DocumentHighlightParams.mk]]
[Lean.Elab.Term.StructInst.FieldVal.default.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Term.StructInst.FieldVal.default, OfNat.ofNat]]
[Nat.toDigitsCore,[List, Char, ite, Eq, OfNat.ofNat, List.cons, PProd.fst],[List, Char]]
[Semiring.nsmul_succ',[],[Eq, Semiring.nsmul, Nat.succ, HAdd.hAdd]]
[Lean.sanitizeName,[Bind.bind, MonadState.get, modify, Lean.NameSanitizerState.mk, Lean.NameSanitizerState.options, Lean.NameSanitizerState.nameStem2Idx, Lean.NameMap.insert, Lean.NameSanitizerState.userName2Sanitized, Pure.pure],[StateM, Lean.NameSanitizerState, Lean.Name]]
[IO.FS.Handle.readToEnd,[IO.FS.Handle.readToEnd.loop],[IO, String]]
[Lean.Elab.Term.SavedContext.declName?,[],[Option, Lean.Name]]
[Std.PShareCommonT,[StateT, Std.ShareCommon.PState],[]]
[Lean.EnvironmentHeader.moduleNames,[],[Array, Lean.Name]]
[And.imp,[And.intro, And.left, And.right],[And]]
[Lean.Level.isZero,[Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Elab.Term.Arg.expr.inj,[],[Eq]]
[Lean.Level.updateIMax!.proof_1,[rfl],[Eq, Lean.Level.isIMax, Lean.Level.imax]]
[Lean.Expr.isEq,[Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat],[Bool]]
[Lean.IR.FnBody.maxIndex,[Lean.IR.MaxIndex.collectFnBody, OfNat.ofNat],[Lean.IR.Index]]
[Int.ofNat_mul_negOfNat,[Unit.unit, Eq, HMul.hMul, Int.ofNat, Int.negOfNat, rfl],[Eq, HMul.hMul, Int.ofNat, Int.negOfNat]]
[Lean.Elab.Term.Quotation.ArrayStxBuilder.build,[Lean.Syntax, Lean.Quote.quote],[Lean.Syntax]]
[Lean.PrettyPrinter.Parenthesizer.instMonadQuotationParenthesizerM,[Lean.MonadQuotation.mk, Pure.pure, arbitrary],[Lean.MonadQuotation, Lean.PrettyPrinter.ParenthesizerM]]
[boolToProp,[Coe.mk, Eq, Bool.true],[Coe, Bool]]
[Lean.MonadQuotation.getCurrMacroScope,[],[Lean.MacroScope]]
[Lean.Parser.Tactic.Conv.pattern,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Server.FileWorker.Reference.ident,[],[Lean.Server.FileWorker.RefIdent]]
[Int.add_zero,[Eq, HAdd.hAdd, OfNat.ofNat, rfl],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.generalizeTelescope,[Bind.bind, Array.mapM, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Pure.pure, Lean.Meta.GeneralizeTelescope.Entry.mk, Bool.false, Lean.Meta.GeneralizeTelescope.generalizeTelescopeAux, OfNat.ofNat, List.toArray, List.nil],[Lean.Meta.MetaM]]
[Lean.Meta.instInhabitedState,[Inhabited.mk, Lean.Meta.State.mk, arbitrary],[Inhabited, Lean.Meta.State]]
[Lean.Elab.Term.Quotation.ArrayStxBuilder.push,[Lean.Elab.Term.Quotation.ArrayStxBuilder, Sum.inl, Array.push, Sum.inr, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil],[Lean.Elab.Term.Quotation.ArrayStxBuilder]]
[or_iff_left_of_imp,[Iff.intro, id, Or.inl],[Iff, Or]]
[UInt64.instRingUInt64.proof_2,[congrArg, UInt64.mk, Ring.gsmul_zero', UInt64.val],[Eq, UInt64.mk, Ring.gsmul, OfNat.ofNat, UInt64.val]]
[Lean.PrettyPrinter.Delaborator.ParamKind.name,[],[Lean.Name]]
[DivInvMonoid.gpow_succ',[],[Eq, DivInvMonoid.gpow, Int.ofNat, Nat.succ, HMul.hMul]]
[Lean.ScopedEnvExtension.ScopedEntries.mk.inj,[],[Eq]]
[USize.ofNat32.proof_1,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, OfNat.ofNat, HEq.refl, LT.lt, USize.size, usize_size_eq, Nat.lt_trans, of_decide_eq_true, Bool.true],[LT.lt, USize.size]]
[Lean.Parser.tokenWithAntiquotFn,[Id.run, ite, Eq, or, Lean.Parser.ParserState.hasError, BEq.beq, Lean.Parser.ParserContext.quotDepth, OfNat.ofNat, Bool.true, Pure.pure, Bind.bind, PUnit.unit],[Lean.Parser.ParserFn]]
[Lean.Meta.FindOptions.stage1,[],[Bool]]
[Lean.instInhabitedLevel,[Inhabited.mk, Lean.Level.zero, arbitrary],[Inhabited, Lean.Level]]
[Lean.Meta.TransparencyMode.lt,[Lean.Meta.TransparencyMode.all, Unit.unit, Lean.Meta.TransparencyMode.default, Lean.Meta.TransparencyMode.reducible, Lean.Meta.TransparencyMode.instances, Bool, Bool.true, Bool.false],[Bool]]
[instDecidableEqBool,[Unit.unit, Decidable, Eq, Decidable.isTrue, rfl, Decidable.isFalse, instDecidableEqBool.proof_1, instDecidableEqBool.proof_2],[DecidableEq, Bool]]
[Lean.Meta.DefaultInstances.mk.inj,[And.intro],[And, Eq]]
[Function.surjective_id,[Exists.intro, rfl],[Function.surjective, id]]
[Lean.Meta.UnificationConstraint.lhs,[],[Lean.Expr]]
[unexpandUnit,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.PrettyPrinter.Unexpander]]
[Lean.Lsp.PlainTermGoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.PlainTermGoal.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.lt_ge_by_cases.proof_1,[Iff.mp, not_lt],[LE.le]]
[Quot.recOn,[Quot.rec],[]]
[Lean.Parser.Tactic.matchHyp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Nat.mul_div_le,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, OfNat.ofNat, HEq.refl, LE.le, HMul.hMul, HDiv.hDiv, Nat.eq_zero_or_pos, Eq.mpr, Nat.zero_mul, Nat.zero_le, Nat.mul_comm, propext, Nat.le_div_iff_mul_le, Nat.le_refl],[LE.le, HMul.hMul, HDiv.hDiv]]
[Lean.Parser.Term.parenSpecial.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.tupleTail.parenthesizer, Lean.Parser.Term.typeAscription.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Server.FileWorker.SemanticTokensState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.FileWorker.SemanticTokensState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.FileWorker.SemanticTokensState.mk, And]]
[Tactic.Ring.horner_mul_horner,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Tactic.Ring.horner, Eq.symm, HAdd.hAdd, OfNat.ofNat, of_eq_true, Eq.trans, congr, congrArg, congrFun, mul_comm, HPow.hPow, mul_add, mul_left_comm, add_mul, mul_assoc, add_zero, eq_self],[Eq, HMul.hMul, Tactic.Ring.horner]]
[Lean.Meta.UnificationHint.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.UnificationHint.mk, HAdd.hAdd, OfNat.ofNat]]
[Sigma.fst,[],[]]
[«term¬_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Command.State.env,[],[Lean.Environment]]
[String.Iterator.noConfusionType,[],[]]
[Lean.IR.EmitC.Context.modName,[],[Lean.Name]]
[Lean.instToStringOptions,[inferInstanceAs, ToString, Lean.KVMap],[ToString, Lean.Options]]
[instOfNat,[OfNat.mk, Zero.zero],[OfNat]]
[Lean.IR.Borrow.BorrowInfCtx.decls,[],[Array, Lean.IR.Decl]]
[Lean.Parser.Tactic.guardTags,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.nameLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Lean.ScopedEnvExtension.Descr.toOLeanEntry,[],[]]
[Lean.JsonRpc.Batch,[Array, Lean.JsonRpc.Message],[]]
[Lean.Meta.mkHasTypeButIsExpectedMsg,[MonadExcept.tryCatch, Bind.bind, Lean.Meta.inferType, Lean.Meta.addPPExplicitToExposeDiff, Lean.Meta.MetaM, Lean.MessageData, Pure.pure, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.indentExpr],[Lean.Meta.MetaM, Lean.MessageData]]
[Lean.Elab.Command.instInhabitedCtorView,[Inhabited.mk, Lean.Elab.Command.CtorView.mk, arbitrary],[Inhabited, Lean.Elab.Command.CtorView]]
[isValidChar,[Or, LT.lt, OfNat.ofNat, And],[]]
[Lean.Elab.Term.SyntheticMVarDecl.mvarId,[],[Lean.MVarId]]
[Lean.Elab.Term.Do.ToTerm.Context.m,[],[Lean.Syntax]]
[Lean.registerEnvExtension,[Lean.EnvExtensionInterface.registerExt, Lean.EnvExtensionInterfaceImp],[IO, Lean.EnvExtension]]
[Lean.Expr.proj.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Expr.proj, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.terminationBy.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.terminationHint.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[String.getOp,[String.get],[Char]]
[Lean.IR.ExplicitRC.mustConsume,[and, Lean.IR.ExplicitRC.VarInfo.ref, Lean.IR.ExplicitRC.VarInfo.consume],[Bool]]
[Lean.Meta.mkImpCongrCtx,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[coeTC,[CoeTC.coe],[]]
[Function.curry_uncurry,[rfl],[Eq, Function.curry, Function.uncurry]]
[StateRefT'.instMonadFunctorStateRefT',[inferInstanceAs, MonadFunctor, ReaderT, ST.Ref],[MonadFunctor, StateRefT']]
[Lean.IR.CtorInfo.noConfusionType,[],[]]
[Lean.Server.Watchdog.WorkerState.crashed.inj,[],[Eq]]
[Lean.Macro.throwErrorAt,[Lean.withRef, Lean.Macro.throwError],[Lean.MacroM]]
[Lean.Environment.addAux,[Lean.Environment.mk, Lean.Environment.const2ModIdx, Lean.SMap.insert, Lean.Environment.constants, Lean.ConstantInfo.name, Lean.Environment.extensions, Lean.Environment.header],[Lean.Environment]]
[Lean.Meta.instInhabitedTransparencyMode,[Inhabited.mk, Lean.Meta.TransparencyMode.all],[Inhabited, Lean.Meta.TransparencyMode]]
[System.FilePath.isAbsolute,[or, List.contains, System.FilePath.pathSeparators, String.front, System.FilePath.toString, and, System.Platform.isWindows, Decidable.decide, GE.ge, String.bsize, OfNat.ofNat, BEq.beq, String.getOp, Char.ofNat],[Bool]]
[Lean.Lsp.SemanticTokensOptions.full,[],[Bool]]
[Lean.Elab.Term.CollectPatternVars.Context.args,[],[List, Lean.Elab.Term.Arg]]
[Lean.PrettyPrinter.Delaborator.maybeAddBlockImplicit,[Bind.bind, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPAnalysisBlockImplicit, ite, Eq, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax]]
[Function.comp.left_id,[rfl],[Eq, Function.comp, id]]
[and_or_distrib_right,[Iff.trans, Or.comm, or_and_distrib_left, and_congr],[Iff, Or, And]]
[List.eq_or_ne_mem_of_mem,[Classical.em, Eq, Or.inl, Eq.symm, Or.inr, And.intro, Or.resolve_left, Eq.refl],[Or, Eq, And, Ne, Mem.mem]]
[Lean.ResolveName.resolveNamespaceUsingOpenDecls,[Unit.unit, Lean.OpenDecl.simple, List.cons, Lean.OpenDecl.explicit, Option, Lean.Name, Option.none, ite, Eq, Lean.Environment.isNamespace, HAppend.hAppend, Bool.true, Option.some, PProd.fst],[Option, Lean.Name]]
[Lean.MessageDataContext.mk.inj,[And.intro],[And, Eq]]
[Nat.prod_dvd_and_dvd_of_dvd_prod.proof_2,[Eq.refl, Nat.gcd],[Eq, Nat.gcd]]
[Lean.Compiler.getCachedSpecialization,[Lean.SMap.find?, Lean.Compiler.SpecState.cache, Lean.SimplePersistentEnvExtension.getState, Lean.Compiler.specExtension],[Option, Lean.Name]]
[Lean.IR.instToFormatCtorInfo,[Std.ToFormat.mk, Std.Format, Id.run, ite, Eq, or, Decidable.decide, GT.gt, OfNat.ofNat, Bool.true, Bind.bind, Pure.pure, PUnit.unit],[Std.ToFormat, Lean.IR.CtorInfo]]
[Lean.Lsp.ServerCapabilities.textDocumentSync?,[],[Option, Lean.Lsp.TextDocumentSyncOptions]]
[Lean.MessageData.toString,[Bind.bind, Lean.MessageData.format, Pure.pure, ToString.toString],[IO, String]]
[Lean.Meta.DefEqContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.DefEqContext.mk, HAdd.hAdd, OfNat.ofNat]]
[xor_comm,[of_eq_true, Eq.trans, congrArg, Eq, Or, And, Not, propext, or_comm, eq_self],[Eq, xor]]
[List.erasep_cons,[rfl],[Eq, List.erasep, List.cons, ite]]
[ite_true,[rfl],[Eq, ite, True]]
[Lean.Export.State.exprs,[],[Lean.Export.Alloc, Lean.Expr]]
[Lean.Meta.withExistingLocalDecls,[Lean.Meta.mapMetaM, Bind.bind, MonadReader.read, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.localInstances, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth, List.foldlM, Lean.Meta.isClass?, Lean.LocalDecl.type, Unit.unit, Lean.Meta.MetaM, Array, Lean.LocalInstance, Pure.pure, Array.push, Lean.LocalInstance.mk, Lean.LocalDecl.toExpr, ite, Eq, BEq.beq, Array.size, Bool.true, Lean.Meta.resettingSynthInstanceCache, Lean.Meta.Context.lctx],[]]
[Lean.PrettyPrinter.Formatter.numLitNoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.visitAtom, Lean.numLitKind],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.resolveId?,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Elab.Term.TermElabM, Option, Lean.Expr, Bind.bind, MonadExcept.tryCatch, Lean.Elab.Term.resolveName, List.nil, Option.none, Pure.pure, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.TermElabM, Option, Lean.Expr]]
[IO.Error.userError.inj,[],[Eq]]
[Std.ShareCommon.mkObjectSet,[Std.mkHashSet, OfNat.ofNat],[Std.ShareCommon.ObjectSet]]
[Fin.checked_mul_spec,[Iff.intro, Decidable.em, LE.le, HMul.hMul, Fin.val, False.elim, Eq.mp, Eq.trans, congrFun, congrArg, Eq, Unit.unit, Bool, Option, Fin, Prod.mk, Iff.mpr, decide_eq_true_iff, Option.none, Option.some, Bool.true, Bool.false, eq_false', Eq.symm, Nat.lt_of_not_le, Eq.refl, of_eq_true, decide_eq_false, Nat.not_le_of_lt, eq_true_of_decide],[Iff, Eq, Option.isSome, Fin.checkedMul, Bool.true, LT.lt, HMul.hMul, Fin.val]]
[Lean.Meta.instReduceEvalName,[Lean.Meta.ReduceEval.mk],[Lean.Meta.ReduceEval, Lean.Name]]
[Lean.Lsp.SemanticTokensRangeParams.noConfusionType,[],[]]
[Lean.Level.PP.Result.maxNode.inj,[],[Eq]]
[Lean.IR.IRType.union.inj,[And.intro],[And, Eq]]
[ST.Prim.Ref.modifyUnsafe,[Bind.bind, ST.Prim.Ref.take, ST.Prim.Ref.set],[ST, Unit]]
[instMulNat,[Mul.mk, Nat.mul],[Mul, Nat]]
[Subarray.popFront.proof_1,[Nat.le_of_lt_succ, Nat.add_lt_add_right, OfNat.ofNat],[LE.le, HAdd.hAdd, Subarray.start, OfNat.ofNat, Subarray.stop]]
[Lean.evalOptPrio,[Unit.unit, Lean.MacroM, Nat, Lean.evalPrio, Pure.pure, OfNat.ofNat],[Lean.MacroM, Nat]]
[PProd.noConfusionType,[],[]]
[Std.PersistentHashSet.contains,[Std.PersistentHashMap.contains, Std.PersistentHashSet.set],[Bool]]
[Lean.instFVarIdSetEmptyCollection,[Std.instEmptyCollectionRBTree, Lean.FVarId, Lean.Name.quickCmp, Lean.FVarId.name],[EmptyCollection, Lean.FVarIdSet]]
[Lean.instInhabitedHeadIndex,[Inhabited.mk, Lean.HeadIndex.fvar, arbitrary],[Inhabited, Lean.HeadIndex]]
[Lean.Lsp.PlainGoalParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.PlainGoalParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.PlainGoalParams.mk]]
[add_left_cancel,[IsAddLeftCancel.add_left_cancel],[Eq]]
[Std.AssocList.foldlM,[Pure.pure, Bind.bind, PProd.fst],[]]
[Lean.Elab.Command.CollectAxioms.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Command.CollectAxioms.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.StructInst.Struct.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.StructInst.Struct.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.StructInst.Struct.mk, And]]
[Lean.Widget.InteractiveGoals.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Widget.InteractiveGoals.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.GeneralizeIndicesSubgoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.GeneralizeIndicesSubgoal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.GeneralizeIndicesSubgoal.mk, And]]
[Lean.Lsp.DocumentFilter.pattern?,[],[Option, String]]
[Lean.Parser.Tactic.wlog,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.sepBy1],[Lean.ParserDescr]]
[String.quote,[ite, Eq, String.isEmpty, Bool.true, HAppend.hAppend, String.foldl, Char.quoteCore],[String]]
[Lean.ScopedEnvExtension.StateStack.mk.inj,[And.intro],[And, Eq]]
[OptionM.run,[],[Option]]
[Lean.Parsec.orElse,[Lean.Parsec.ParseResult, Lean.Parsec.ParseResult.success, ite, Eq, Unit.unit, Lean.Parsec.ParseResult.error],[Lean.Parsec]]
[MonadFunctorT.noConfusionType,[],[]]
[Lean.PrefixTreeNode.insert,[Lean.PrefixTreeNode.insert.loop, Lean.PrefixTreeNode.insert.insertEmpty],[Lean.PrefixTreeNode]]
[Lean.Meta.SynthInstance.Answer.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SynthInstance.Answer.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SynthInstance.Answer.mk, And]]
[Lean.Parser.Tactic.fieldSimp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.instFromJsonBool,[Lean.FromJson.mk, Lean.Json.getBool?],[Lean.FromJson, Bool]]
[Lean.Parser.Term.binderDefault,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Substring.posOf,[String.Pos, HSub.hSub, String.posOfAux],[String.Pos]]
[Lean.Parser.Term.funBinder.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.PrettyPrinter.Formatter.evalInsideQuot.formatter, Lean.Parser.Term.funBinder.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.RecursorInfo.majorPos,[],[Nat]]
[Lean.Parser.Command.macroTailTactic,[HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.identEq, Lean.Name.mkSimple, Lean.Parser.darrow, Lean.Parser.Command.macroRhs, Lean.Parser.Tactic.seq1],[Lean.Parser.Parser]]
[stdRange,[Prod.mk, OfNat.ofNat],[Prod, Nat]]
[Lean.Json.instCoeNatJson,[Coe.mk, Lean.Json.num, Lean.JsonNumber.fromNat],[Coe, Nat, Lean.Json]]
[Array.forIn.loop.proof_1,[Nat.lt_of_le_of_lt, Nat.sub_le, HSub.hSub, Array.size, OfNat.ofNat, Nat.sub_lt, Nat.zero_lt_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self, of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, HSub.hSub, Array.size, OfNat.ofNat]]
[Std.ShareCommon.ObjectPersistentSet,[Std.PersistentHashSet, Std.ShareCommon.Object],[]]
[Array.size_pop,[List.length_dropLast, Array.data],[Eq, Array.size, Array.pop, HSub.hSub, OfNat.ofNat]]
[Lean.Parser.Term.strictImplicitLeftBracket.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.group.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.FnBody.sset.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.sset, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.FnBody.sset, And]]
[Lean.Meta.Match.MatchEqnsExtState.noConfusionType,[],[]]
[Lean.Parser.many1.formatter,[Lean.PrettyPrinter.Formatter.many1NoAntiquot.formatter, Lean.Parser.withAntiquotSpliceAndSuffix.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Json.instCoeIntJson,[Coe.mk, Lean.Json.num, Lean.JsonNumber.fromInt],[Coe, Int, Lean.Json]]
[Prod.lex_def,[Iff.intro, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Or, Prod.fst, And, Eq, Prod.snd, of_eq_true, Eq.trans, congrFun, congrArg, eq_true, true_or, congr, eq_self, eq_true_of_decide, Bool.true, or_true, Prod.Lex, Prod.Lex.left, Prod.Lex.right],[Iff, Prod.Lex, Or, Prod.fst, And, Eq, Prod.snd]]
[Lean.Server.RequestTask,[Task, Except, Lean.Server.RequestError],[]]
[Lean.findSysroot?,[Bind.bind, liftM, IO.getEnv, Option.none, IO, System.FilePath, Pure.pure, System.FilePath.mk, PUnit.unit],[IO, System.FilePath]]
[Lean.Elab.Deriving.Header.argNames,[],[Array, Lean.Name]]
[Lean.Macro.withFreshMacroScope,[Bind.bind, MonadState.modifyGet, Prod.mk, Lean.Macro.State.macroScope, Lean.Macro.State.mk, HAdd.hAdd, OfNat.ofNat, Lean.Macro.State.traceMsgs, MonadWithReader.withReader, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth, Lean.Macro.Context.ref],[Lean.MacroM]]
[Lean.PrettyPrinter.Formatter.setLhsPrec.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.logErrorAt,[Lean.Elab.logAt, Lean.MessageSeverity.error],[Unit]]
[Lean.Parser.Tactic.ghostCalc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.binderIdent],[Lean.ParserDescr]]
[Lean.Lsp.instFromJsonInitializedParams,[Lean.FromJson.mk, Pure.pure, Lean.Lsp.InitializedParams.mk],[Lean.FromJson, Lean.Lsp.InitializedParams]]
[not_exists_of_forall_not,[Iff.mpr, exists_imp_distrib],[Not, Exists]]
[Lean.Name.isSuffixOf,[Lean.Name.str, Lean.Name.anonymous, Lean.Name.num, Bool, Bool.true, and, BEq.beq, PProd.fst, Bool.false],[Bool]]
[Lean.Meta.UnificationHintEntry.keys,[],[Array, Lean.Meta.DiscrTree.Key]]
[Lean.NamePart.num.injEq,[Eq.propIntro, Eq.refl, Lean.NamePart.num, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.NamePart.num]]
[Lean.Elab.WF.TerminationHintValue.value,[],[Lean.Syntax]]
[Lean.Core.Context.maxHeartbeats,[],[Nat]]
[USize.noConfusionType,[],[]]
[Lean.TagDeclarationExtension.isTagged,[Unit.unit, Bool, Lean.Environment.getModuleIdxFor?, Array.binSearchContains, Lean.PersistentEnvExtension.getModuleEntries, Lean.Name.quickLt, OfNat.ofNat, HSub.hSub, Array.size, Lean.NameSet.contains, Lean.SimplePersistentEnvExtension.getState],[Bool]]
[Tactic.Ring.horner_mul_const,[of_eq_true, Eq.trans, congr, congrArg, Eq, add_mul, HMul.hMul, HPow.hPow, congrFun, HAdd.hAdd, mul_right_comm, Eq.symm, eq_self],[Eq, HMul.hMul, Tactic.Ring.horner]]
[Lean.Parser.rawIdent,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.identKind, Bool.true, Lean.Parser.rawIdentNoAntiquot],[Lean.Parser.Parser]]
[Lean.Elab.addAndCompileNonRec,[Lean.withRef, Lean.Elab.PreDefinition.ref, Bind.bind, liftM, Lean.Elab.abstractNestedProofs, Lean.MonadEnv.getEnv, Lean.addDecl, Lean.Elab.withSaveInfoContext, Lean.mkConstWithLevelParams, Lean.Elab.PreDefinition.declName, Lean.Elab.Term.addTermInfo, Option.none, Lean.Name.anonymous, Bool.true, Lean.Elab.applyAttributesOf, List.toArray, List.cons, List.nil, Lean.AttributeApplicationTime.afterTypeChecking, ite, Eq, and, not, Lean.Elab.DefKind.isTheorem, Lean.Elab.PreDefinition.kind, Lean.Elab.Modifiers.isNoncomputable, Lean.Elab.PreDefinition.modifiers, MonadExcept.tryCatch, Lean.compileDecl, Pure.pure, DoResultPR.pure, PUnit.unit, MonadReader.read, Lean.Elab.Term.Context.isNoncomputableSection, DoResultPR.return, Bool.false, MonadExcept.throw, Lean.Elab.Term.TermElabM, Bool, Unit.unit],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Parser.Term.typeOf.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[StateCpsT.runK_get,[rfl],[Eq, StateCpsT.runK, MonadState.get]]
[Lean.Level.PP.Result.leaf.inj,[],[Eq]]
[Lean.IR.IsLive.visitVar,[Pure.pure, Lean.IR.HasIndex.visitVar],[Lean.IR.IsLive.M, Bool]]
[Lean.Parser.Attr.interactive,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.IR.ExpandResetReuse.mkFastPath,[Bind.bind, MonadReader.read, Lean.IR.ExpandResetReuse.releaseUnreadFields],[Lean.IR.ExpandResetReuse.M, Lean.IR.FnBody]]
[Lean.Elab.instInhabitedCommandInfo,[Inhabited.mk, Lean.Elab.CommandInfo.mk, arbitrary],[Inhabited, Lean.Elab.CommandInfo]]
[Lean.Json.Parser.str,[Lean.Json.Parser.strCore],[Lean.Parsec, String]]
[Setoid.iseqv,[],[Equivalence, Setoid.r]]
[Lean.Elab.Term.BinderView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.BinderView.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.BinderView.mk, And]]
[Lean.StructureInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.StructureInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.StructureInfo.mk, And]]
[Int.natAbs,[Nat, Nat.succ],[Nat]]
[Lean.Parser.Term.byTactic.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Tactic.tacticSeq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[List.eraseDups,[List.eraseDupsAux, List.nil],[List]]
[«term#[_,]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false],[Lean.ParserDescr]]
[Classical.strongIndefiniteDescription.proof_2,[absurd],[Classical.choice]]
[Nat.instShiftRightNat,[ShiftRight.mk, Nat.shiftRight],[ShiftRight, Nat]]
[Lean.ExternAttrData.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ExternAttrData.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ExternAttrData.mk, And]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.mk.inj,[And.intro],[And, Eq]]
[Lean.Expr.updateForall!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateForall, Lean.Expr.forallE, Lean.Expr.updateForall!.proof_1, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[Lean.Parser.Command.declModifiersT.formatter,[Lean.Parser.Command.declModifiers.formatter, Bool.true],[Lean.PrettyPrinter.Formatter]]
[Unit.unit,[PUnit.unit],[Unit]]
[Lean.Elab.Command.ProjectionInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Command.ProjectionInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Std.RBTree.instReprRBTree,[Repr.mk, Repr.addAppParen, HAppend.hAppend, Std.Format.text, repr, Std.RBTree.toList],[Repr, Std.RBTree]]
[instInhabitedTrue,[Inhabited.mk, True.intro],[Inhabited, True]]
[Lean.Expr.updateApp!.proof_1,[rfl],[Eq, Lean.Expr.isApp, Lean.Expr.app]]
[Lean.Elab.Deriving.BEq.mkBEqInstanceHandler,[Bind.bind, Lean.isEnumType, Array.getOp, OfNat.ofNat, ite, Eq, and, BEq.beq, Array.size, Bool.true, Lean.Elab.Command.liftTermElabM, Option.none, Lean.Elab.Deriving.mkContext, Pure.pure, Lean.Elab.Deriving.Context.auxFunNames, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Lean.Syntax.atom, Lean.mkIdent, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Lean.Elab.Deriving.mkInstanceCmds, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, PUnit.unit, Array.forM, Lean.Elab.Command.elabCommand, Array.allM, Lean.isInductive, Decidable.decide, GT.gt, Lean.Elab.Deriving.BEq.mkMutualBlock, Bool.false],[Lean.Elab.Command.CommandElabM, Bool]]
[Lean.Parser.Term.inaccessible.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.MessageData.tagged.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MessageData.tagged, HAdd.hAdd, OfNat.ofNat]]
[Lean.SSet.insert,[Lean.SMap.insert, Unit.unit],[Lean.SSet]]
[Lean.getConstInfoCtor,[Bind.bind, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo, Lean.ConstructorVal, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkConst, List.nil],[Lean.ConstructorVal]]
[Nat.gcd_assoc,[Nat.dvd_antisymm, Nat.dvd_gcd, Nat.dvd_trans, Nat.gcd_dvd_left, Nat.gcd, Nat.gcd_dvd_right],[Eq, Nat.gcd]]
[List.getD,[Option.getD, List.get?],[]]
[Lean.IR.JoinPointId.idx,[],[Lean.IR.Index]]
[Lean.KeyedDeclsAttribute.ExtensionState.table,[],[Lean.KeyedDeclsAttribute.Table]]
[Lean.Elab.Term.registerCustomErrorIfMVar,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Elab.Term.TermElabM, Unit, Lean.Expr.getAppFn, Lean.Elab.Term.registerMVarErrorCustomInfo, Pure.pure, Unit.unit],[Lean.Elab.Term.TermElabM, Unit]]
[Sum.noConfusionType,[],[]]
[Lean.JsonRpc.ErrorCode.serverNotInitialized.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.JsonRpc.ErrorCode.serverNotInitialized, OfNat.ofNat]]
[Lean.Elab.InfoState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.InfoState.mk, HAdd.hAdd, OfNat.ofNat]]
[Function.update_comp_eq_of_injective',[Iff.mpr, Function.eq_update_iff, And.intro, Function.update_same, Function.update_noteq, Function.injective.ne],[Eq, Function.update]]
[Lean.Elab.DerivingClassView.ref,[],[Lean.Syntax]]
[Lean.IR.Alt,[Lean.IR.AltCore, Lean.IR.FnBody],[]]
[FloatArray.isEmpty,[BEq.beq, FloatArray.size, OfNat.ofNat],[Bool]]
[Lean.Parser.Tactic.Conv.normNum1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Elab.Term.Do.getDoLetRecVars,[Bind.bind, ForIn.forIn, Lean.Elab.Term.Do.getLetDeclVars, Pure.pure, PUnit.unit, ForInStep.yield],[Lean.Elab.Term.TermElabM, Array, Lean.Name]]
[Lean.instToMessageDataLevel,[Lean.ToMessageData.mk, Lean.MessageData.ofLevel],[Lean.ToMessageData, Lean.Level]]
[Lean.KVMap.insert,[Lean.KVMap, Lean.KVMap.mk, Lean.KVMap.insertCore],[Lean.KVMap]]
[Lean.Compiler.atMostOnce.visitFVar,[Lean.Compiler.atMostOnce.AtMostOnceData.mk, Bool.false, Unit.unit, Bool.true, Lean.Compiler.atMostOnce.AtMostOnceData, BEq.beq, bne],[Lean.Compiler.atMostOnce.Visitor]]
[Lean.Elab.Structural.addSmartUnfoldingDef,[Bind.bind, liftM, Lean.Meta.isProp, Lean.Elab.PreDefinition.type, ite, Eq, Bool.true, Pure.pure, Unit.unit, Lean.Elab.Structural.addSmartUnfoldingDefAux, Lean.Elab.addNonRec],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Elab.WF.TerminationHintValue.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.WF.TerminationHintValue.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.DiscrTree.instBEqKey,[BEq.mk, Lean.Meta.DiscrTree.Key.const, Lean.Meta.DiscrTree.Key.fvar, Lean.Meta.DiscrTree.Key.lit, Lean.Meta.DiscrTree.Key.star, Lean.Meta.DiscrTree.Key.other, Lean.Meta.DiscrTree.Key.arrow, Lean.Meta.DiscrTree.Key.proj, Unit.unit, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Meta.DiscrTree.Key]]
[Mathlib.ExtendedBinder.«command__Binder_predicate_____=>_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Tactic.assumptionModCast,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Elab.Term.MutualClosure.UsedFVarsMap,[Lean.FVarIdMap, Lean.FVarIdSet],[]]
[Lean.mkIdentFromRef,[Bind.bind, Lean.MonadRef.getRef, Pure.pure, Lean.mkIdentFrom],[Lean.Syntax]]
[Lean.IR.LocalContext.getJPParams,[Option.none, Option.some, Lean.IR.LocalContextEntry.param, Lean.IR.LocalContextEntry.localVar, Option, Array, Lean.IR.Param, Std.RBMap.find?, Lean.IR.JoinPointId.idx],[Option, Array, Lean.IR.Param]]
[Lean.mkMData,[Lean.Expr.mdata, Lean.Expr.mkData, mixHash, UInt8.toUInt64, Hashable.hash, Lean.Expr.looseBVarRange, Lean.Expr.hasFVar, Lean.Expr.hasExprMVar, Lean.Expr.hasLevelMVar, Lean.Expr.hasLevelParam],[Lean.Expr]]
[Lean.Elab.Term.MVarErrorInfo.kind,[],[Lean.Elab.Term.MVarErrorKind]]
[Lean.Elab.TermInfo.expectedType?,[],[Option, Lean.Expr]]
[Lean.IR.UnreachableBranches.FunctionSummaries,[Lean.SMap, Lean.IR.FunId, Lean.IR.UnreachableBranches.Value],[]]
[Std.AssocList.findEntry?,[Unit.unit, Option, Prod, Option.none, BEq.beq, Option.some, Prod.mk, PProd.fst],[Option, Prod]]
[Lean.Meta.forallMetaTelescopeReducing,[List.toArray, List.nil, OfNat.ofNat, Bool.true],[Lean.Meta.MetaM, Prod, Array, Lean.Expr, Lean.BinderInfo]]
[Lean.Lsp.RpcConnected.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.RpcConnected.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.isRec,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.isRecCore],[Bool]]
[Lean.Elab.Command.StructFieldKind.fromParent.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Command.StructFieldKind.fromParent, OfNat.ofNat]]
[Std.RBMap.findD,[Option.getD, Std.RBMap.find?],[]]
[Lean.Meta.isTypeCorrect,[MonadExcept.tryCatch, Bind.bind, Lean.Meta.check, Pure.pure, Bool.true, Lean.isTracingEnabledFor, ite, Eq, Lean.addTrace, Lean.Exception.toMessageData, PUnit.unit],[Lean.Meta.MetaM, Bool]]
[Lean.Attribute.erase,[Bind.bind, Lean.MonadEnv.getEnv, Lean.ofExcept, Lean.getAttributeImpl, Lean.AttributeImpl.erase],[Lean.AttrM, Unit]]
[Lean.KeyedDeclsAttribute.instInhabitedDef,[Inhabited.mk, Lean.KeyedDeclsAttribute.Def.mk, arbitrary],[Inhabited, Lean.KeyedDeclsAttribute.Def]]
[Lean.addMacroScope,[Unit.unit, Lean.Name, Lean.Name.hasMacroScopes, BEq.beq, Lean.MacroScopesView.mainModule, Lean.Name.mkNum, Lean.MacroScopesView.review, Lean.MacroScopesView.mk, Lean.MacroScopesView.name, List.foldl, HAppend.hAppend, Lean.MacroScopesView.imported, Lean.MacroScopesView.scopes, List.cons, List.nil, Lean.Name.mkStr],[Lean.Name]]
[StateCpsT.runK_bind_set,[rfl],[Eq, StateCpsT.runK, Bind.bind, MonadStateOf.set, PUnit.unit]]
[Nat.instNumericNat,[Numeric.mk, id],[Numeric, Nat]]
[Lean.Server.instMonadLiftIORequestM,[MonadLift.mk, liftM, IO.toEIO, Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.internalError, ToString.toString],[MonadLift, IO, Lean.Server.RequestM]]
[Lean.QuotVal.toConstantVal,[],[Lean.ConstantVal]]
[Lean.Elab.Term.Do.addFreshJP,[Bind.bind, liftM, Lean.Elab.Term.Do.mkFreshJP, modify, Array.push, Pure.pure, Lean.Elab.Term.Do.JPDecl.name],[StateRefT', IO.RealWorld, Array, Lean.Elab.Term.Do.JPDecl, Lean.Elab.Term.TermElabM, Lean.Name]]
[List.append_bind,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, List.bind, List.cons_append, List.cons_bind, HAppend.hAppend, List.append_assoc, eq_self],[Eq, List.bind, HAppend.hAppend]]
[Std.PersistentHashMap.insertAtCollisionNode,[Std.PersistentHashMap.insertAtCollisionNodeAux, OfNat.ofNat],[Std.PersistentHashMap.CollisionNode]]
[Lean.Meta.NormNum.instLawfulOfNat_1,[Lean.Meta.NormNum.instLawfulOfNat_1.proof_1],[Lean.Meta.NormNum.LawfulOfNat]]
[List.length_pos_iff_ne_nil,[Iff.intro, List.ne_nil_of_length_pos, List.length_pos_of_ne_nil],[Iff, LT.lt, OfNat.ofNat, List.length, Ne, List.nil]]
[IsMulRightCancel.noConfusionType,[],[]]
[Lean.MetavarContext.UnivMVarParamResult.mctx,[],[Lean.MetavarContext]]
[Lean.Lsp.instToJsonWaitForDiagnostics,[Lean.ToJson.mk, Lean.Json.mkObj, List.nil],[Lean.ToJson, Lean.Lsp.WaitForDiagnostics]]
[Lean.Elab.ElabInfo.stx,[],[Lean.Syntax]]
[Nat.lcm_zero_right,[Nat.lcm_zero_left, Nat.lcm_comm, OfNat.ofNat],[Eq, Nat.lcm, OfNat.ofNat]]
[Lean.Elab.Structural.RecArgInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Structural.RecArgInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Widget.instInhabitedTaggedText,[Inhabited.mk, Lean.Widget.TaggedText.text, arbitrary],[Inhabited, Lean.Widget.TaggedText]]
[Lean.Parser.unicodeSymbolFn,[Lean.Parser.unicodeSymbolFnAux, List.cons, HAppend.hAppend, List.nil],[Lean.Parser.ParserFn]]
[Lean.Parser.ParserState.mkTrailingNode,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk],[Lean.Parser.ParserState]]
[Lean.PrettyPrinter.Delaborator.SubExpr.expr,[],[Lean.Expr]]
[List.card_union_disjoint,[Eq.mpr, Eq.refl, Eq, List.card, List.union, HAdd.hAdd, List.card_eq_of_equiv, List.union_equiv_append, HAppend.hAppend, List.card_append_disjoint, rfl],[Eq, List.card, List.union, HAdd.hAdd]]
[Lean.Elab.Term.Quotation.HeadCheck.slice.inj,[And.intro],[And, Eq]]
[Lean.Elab.Command.InductiveView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Command.InductiveView.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.CtorFieldInfo.scalar.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.CtorFieldInfo.scalar, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.CtorFieldInfo.scalar, And]]
[Lean.Elab.Term.ExtractMonadResult.α,[],[Lean.Expr]]
[Lean.Elab.Term.StructInst.DefaultFields.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.StructInst.DefaultFields.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.Do.Code.break.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.Do.Code.break, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.Code.break]]
[Lean.Syntax.isMissing,[Unit.unit, Lean.Syntax.node, Lean.Syntax.atom, Lean.Syntax.ident, Bool, Bool.true, Bool.false],[Bool]]
[Lean.instInhabitedEnvironmentHeader,[Inhabited.mk, Lean.EnvironmentHeader.mk, arbitrary],[Inhabited, Lean.EnvironmentHeader]]
[Lean.IR.IRType.struct.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.IRType.struct, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.IRType.struct, And]]
[String.Iterator.toEnd,[String.Iterator, String.Iterator.mk, String.bsize],[String.Iterator]]
[Lean.Server.Watchdog.OpenDocument.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Command.terminationHintMany.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.lookahead.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1Indent.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.Parser.optional.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[List.decidableMem.proof_3,[not_or_intro],[Not, Or, Eq, List.mem]]
[Lean.Parser.notFollowedByCategoryToken,[Lean.Parser.Parser.mk, Lean.Parser.notFollowedByCategoryTokenFn],[Lean.Parser.Parser]]
[Lean.Elab.Term.Quotation.MatchResult.uncovered.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Quotation.MatchResult.uncovered, OfNat.ofNat]]
[Lean.PersistentEnvExtension.exportEntriesFn,[],[Array]]
[MProd.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, MProd.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, MProd.mk, And]]
[ExceptCpsT.runCatch_pure,[rfl],[Eq, ExceptCpsT.runCatch, Pure.pure]]
[Lean.Position.line,[],[Nat]]
[Lean.Parser.minPrec,[OfNat.ofNat],[Nat]]
[Lean.Parser.group.formatter,[Lean.PrettyPrinter.Formatter.node.formatter, Lean.groupKind],[Lean.PrettyPrinter.Formatter]]
[Or.assoc,[Iff.intro, Or.imp_right, Or.inl, Or.inr, Or.imp_left],[Iff, Or]]
[Std.Format.prettyM,[List.cons, Bool.false, Std.Format.FlattenBehavior.allOrNone, Int.ofNat, OfNat.ofNat, List.nil],[Unit]]
[Lean.Elab.getInfoTrees,[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, Pure.pure, Lean.Elab.InfoState.trees],[Std.PersistentArray, Lean.Elab.InfoTree]]
[Lean.Elab.Command.ElabStructResult.projInstances,[],[List, Lean.Name]]
[Fin.elim0,[absurd, Nat.not_lt_zero],[]]
[Lean.Compiler.setImplementedBy,[Lean.ParametricAttribute.setParam, Lean.Compiler.implementedByAttr],[Except, String, Lean.Environment]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.PostponedEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.PostponedEntry.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.PostponedEntry.rhs,[],[Lean.Level]]
[coeOfDep,[CoeT.mk, coeD],[CoeT]]
[Lean.Elab.Term.CollectPatternVars.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.CollectPatternVars.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.CollectPatternVars.Context.mk, And]]
[Lean.Meta.Match.Problem.alts,[],[List, Lean.Meta.Match.Alt]]
[Lean.Elab.Term.StructInst.instToStringStruct,[ToString.mk, Function.comp, ToString.toString, Std.ToFormat.format],[ToString, Lean.Elab.Term.StructInst.Struct]]
[and_iff_right,[Iff.intro, And.right, And.intro],[Iff, And]]
[Lean.DeclarationRanges.noConfusionType,[],[]]
[Lean.NameGenerator.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.NameGenerator.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.FromJson.noConfusionType,[],[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.hasLevelMVarAtCurrDepth,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Option.isSome, Lean.Expr.findLevelMVar?, BEq.beq, Lean.MetavarContext.findLevelDepth?, Option.some, Lean.MetavarContext.depth],[Lean.Meta.MetaM, Bool]]
[PSigma.mkSkipLeft.proof_1,[PSigma.RevLex.right],[PSigma.RevLex, emptyRelation, PSigma.mk]]
[Int.decEq.proof_6,[],[Int.noConfusionType, False, Int.negSucc, Int.ofNat]]
[Lean.Meta.Closure.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Closure.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.FileWorker.instMonadRpcSession,[Lean.Server.MonadRpcSession.mk, MonadState.modifyGet, Lean.Server.FileWorker.RpcSession.store, Bind.bind, MonadState.get, Pure.pure, Std.PersistentHashMap.find?, Lean.Server.FileWorker.RpcSession.aliveRefs, Lean.Server.FileWorker.RpcSession.release],[Lean.Server.MonadRpcSession]]
[Lean.Compiler.addSpecializationInfo,[Lean.PersistentEnvExtension.addEntry, Lean.Compiler.specExtension, Lean.Compiler.SpecEntry.info],[Lean.Environment]]
[Array.binSearch,[ite, LT.lt, Array.size, Array.binSearchAux, id, Option.none],[Option]]
[Lean.Elab.Tactic.evalWithReducible,[Lean.Meta.withReducible, Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Elab.Tactic.Tactic]]
[USize.instAddSemigroupUSize,[AddSemigroup.mk, USize.instAddSemigroupUSize.proof_1],[AddSemigroup, USize]]
[Lean.PrettyPrinter.CategoryParenthesizer,[Lean.PrettyPrinter.Parenthesizer],[]]
[Std.PersistentHashSet.isEmpty,[Std.PersistentHashMap.isEmpty, Std.PersistentHashSet.set],[Bool]]
[Lean.Rat.instCoeIntRat,[Coe.mk],[Coe, Int, Lean.Rat]]
[Substring.prevn,[String.Pos, PProd.fst, Substring.prev],[String.Pos]]
[Lean.Server.Watchdog.ServerContext.hLog,[],[IO.FS.Stream]]
[PartialOrder.noConfusionType,[],[]]
[HOr.hOr,[],[]]
[Lean.IR.UnreachableBranches.Value.instBEqValue,[BEq.mk, Lean.IR.UnreachableBranches.Value.beq],[BEq, Lean.IR.UnreachableBranches.Value]]
[List.drop_eq_nil_of_le',[Eq, List.drop, List.nil, rfl, Eq.symm, Eq.refl, OfNat.ofNat, HEq.refl],[Eq, List.drop, List.nil]]
[Lean.StructureFieldInfo.binderInfo,[],[Lean.BinderInfo]]
[precArg,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Bool.ff_ne_tt,[],[False]]
[Lean.Parser.Term.let_delayed.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.letDecl.formatter, Lean.Parser.Term.optSemicolon.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Lean.PrettyPrinter.Parenthesizer.identNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken],[Lean.PrettyPrinter.Parenthesizer]]
[USize.eq_of_val_eq,[Eq, congrArg, USize.mk],[Eq]]
[Lean.Meta.NormNum.instLawfulOfNatInt,[Lean.Meta.NormNum.instLawfulOfNatInt.proof_1],[Lean.Meta.NormNum.LawfulOfNat, Int]]
[Lean.IR.Borrow.ParamMap.Key.decl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Borrow.ParamMap.Key.decl, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.elabPipeCompletion,[Bind.bind, Lean.Elab.Term.elabTerm, Lean.Syntax.getOp, OfNat.ofNat, Option.none, Bool.true, ite, Eq, Lean.Expr.isSorry, Pure.pure, PUnit.unit, Lean.Elab.Term.addDotCompletionInfo],[Lean.Elab.Term.TermElab]]
[non_contradictory,[Not],[]]
[Lean.Server.registerLspRequestHandler,[Bind.bind, liftM, IO.initializing, ite, Eq, not, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Pure.pure, PUnit.unit],[IO, Unit]]
[instAddCommMonoid_1,[AddCommMonoid.mk, instAddCommMonoid_1.proof_1],[AddCommMonoid]]
[Lean.Parser.Command.addDeclDoc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.IR.Expr.lit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Expr.lit, HAdd.hAdd, OfNat.ofNat]]
[Lean.MetavarContext.LevelMVarToParam.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MetavarContext.LevelMVarToParam.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.CongrArgKind.eq.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.CongrArgKind.eq, OfNat.ofNat]]
[Lean.Meta.SavedState.restore,[Bind.bind, liftM, Lean.Core.restore, Lean.Meta.SavedState.core, modify, Lean.Meta.State.mk, Lean.Meta.State.mctx, Lean.Meta.SavedState.meta, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed],[Lean.Meta.MetaM, Unit]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Modifiers.addAttribute,[Lean.Elab.Modifiers.mk, Lean.Elab.Modifiers.docString?, Lean.Elab.Modifiers.visibility, Lean.Elab.Modifiers.isNoncomputable, Lean.Elab.Modifiers.recKind, Lean.Elab.Modifiers.isUnsafe, Array.push, Lean.Elab.Modifiers.attrs],[Lean.Elab.Modifiers]]
[String.trimRight,[Substring.toString, Substring.trimRight, String.toSubstring],[String]]
[Lean.Meta.AbstractMVars.State.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.noindex.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[instMonadControlT,[MonadControlT.mk, MonadControlT.stM, MonadControl.stM, MonadControl.liftWith, MonadControlT.liftWith, Function.comp, MonadControl.restoreM, MonadControlT.restoreM],[MonadControlT]]
[USize.mul,[USize.mk, HMul.hMul, USize.val],[USize]]
[Lean.LocalContext.lastDeclM,[Bind.bind, Lean.LocalContext.findDeclRevM?, Function.comp, optional, Unit.unit, Alternative.failure, Pure.pure],[]]
[Std.Format.joinSep,[List.cons, Std.Format, Std.Format.nil, Std.ToFormat.format, HAppend.hAppend, PProd.fst],[Std.Format]]
[Lean.Elab.Level.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Level.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.FileWorker.getInteractiveGoals,[Bind.bind, Lean.Server.RequestM.readDoc, Lean.Server.RequestM.withWaitFindSnap, Decidable.decide, GE.ge, Lean.Server.Snapshots.Snapshot.endPos, Pure.pure, Option.none, List.nil, List.cons, Lean.Server.RequestM, Option, Lean.Widget.InteractiveGoals, Lean.Elab.InfoTree.goalsAt?, Lean.Server.DocumentMeta.text, Lean.Server.FileWorker.EditableDocument.meta, Lean.Server.Snapshots.Snapshot.infoTree, Functor.map, List.join, List.mapM, List, Lean.Widget.InteractiveGoal, liftM, Lean.Elab.ContextInfo.runMetaM, Lean.LocalContext.mk, Lean.Meta.withPPInaccessibleNames, Lean.Widget.goalToInteractive, Bool.true, Option.some, Lean.Widget.InteractiveGoals.mk, List.toArray],[Lean.Server.RequestM, Lean.Server.RequestTask, Option, Lean.Widget.InteractiveGoals]]
[Decidable.of_not_not,[Decidable.byContradiction, absurd],[]]
[Lean.Compiler.CSimp.instInhabitedEntry,[Inhabited.mk, Lean.Compiler.CSimp.Entry.mk, arbitrary],[Inhabited, Lean.Compiler.CSimp.Entry]]
[List.takeWhile,[Unit.unit, List, List.nil, List.cons, PProd.fst],[List]]
[SubNegMonoid.gsmul_succ',[],[Eq, SubNegMonoid.gsmul, Int.ofNat, Nat.succ, HAdd.hAdd]]
[ReaderT.instLawfulMonadReaderT.proof_1,[LawfulMonad.mk, ReaderT.ext, Eq.mpr, congr, congrArg, Eq, Eq.trans, ReaderT.run_bind, Pure.pure, Bind.bind, ReaderT.run, funext, ReaderT.run_pure, ReaderT.run_map, LawfulMonad.bind_pure_comp, rfl, of_eq_true, congrFun, LawfulMonad.pure_bind, eq_self, LawfulMonad.bind_assoc],[LawfulMonad, ReaderT]]
[Lean.Parser.optional.formatter,[Lean.PrettyPrinter.Formatter.optionalNoAntiquot.formatter, Lean.Parser.withAntiquotSpliceAndSuffix.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.Match.Example.val.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Example.val, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.Example.val]]
[Lean.Parser.dbgTraceStateFn,[dbgTrace, HAppend.hAppend, ToString.toString, Lean.Parser.ParserState.pos, Lean.Parser.ParserState.errorMsg, Array.extract, Lean.Parser.ParserState.stxStack, Array.size],[Lean.Parser.ParserFn]]
[List.toFloatArray,[FloatArray.empty, List.toFloatArray.loop],[FloatArray]]
[Lean.Expr.bindingDomain!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[Lean.Json.Structured.arr.inj,[],[Eq]]
[List.map,[Unit.unit, List, List.nil, List.cons, PProd.fst],[List]]
[instToStreamListList,[ToStream.mk],[ToStream, List]]
[USize.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, USize.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.version.isRelease,[Lean.version.getIsRelease, Unit.unit],[Bool]]
[Lean.Syntax.getIdAt,[Lean.Syntax.getId, Lean.Syntax.getArg],[Lean.Name]]
[Std.PersistentHashMap.Node.ibelow,[And, True],[]]
[Lean.Meta.DefEqContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.DefEqContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.DefEqContext.mk, And]]
[Lean.Elab.MonadLog.getRef,[],[Lean.Syntax]]
[Nat.succ_pred_eq_of_pos,[Eq.refl, Nat.zero, HEq.refl, Eq, Nat.succ, Nat.pred, rfl],[Eq, Nat.succ, Nat.pred]]
[Lean.Elab.Term.LVal.isFieldName,[Lean.Elab.Term.LVal.fieldIdx, Lean.Elab.Term.LVal.getOp, Bool, Bool.true, Bool.false],[Bool]]
[Lean.IR.UnreachableBranches.Value.bot.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.IR.UnreachableBranches.Value.bot, OfNat.ofNat]]
[Array.toPersistentArray,[Array.foldl, Std.PersistentArray.push, Std.PersistentArray.empty, OfNat.ofNat, Array.size],[Std.PersistentArray]]
[Lean.PrefixTreeNode.Node.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrefixTreeNode.Node, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PrefixTreeNode.Node, And]]
[Lean.LocalDecl.applyFVarSubst,[Lean.LocalDecl, Lean.LocalDecl.cdecl, Lean.Meta.FVarSubst.apply, Lean.LocalDecl.ldecl],[Lean.LocalDecl]]
[Lean.MessageData.instCoeSyntaxMessageData,[Coe.mk, Lean.MessageData.ofSyntax],[Coe, Lean.Syntax, Lean.MessageData]]
[Lean.Parser.FirstTokens.toStr,[Unit.unit, String, ToString.toString, HAppend.hAppend],[String]]
[Lean.Lsp.InitializeResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.InitializeResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.InitializeResult.mk, And]]
[List.eq_or_mem_of_mem_insert,[Iff.mp, List.mem_insert_iff],[Or, Eq, Mem.mem]]
[Lean.MonadMCtx.getMCtx,[],[Lean.MetavarContext]]
[Fin.instInhabitedFinHAdd,[Inhabited.mk, OfNat.ofNat],[Inhabited, Fin]]
[Lean.Meta.reduceMatcher?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Lean.Meta.ReduceMatcherResult, Lean.Expr.getAppFn, Bind.bind, Lean.Meta.getMatcherInfo?, Option.none, ite, LT.lt, Array.size, HAdd.hAdd, Lean.Meta.Match.MatcherInfo.numAlts, Pure.pure, Lean.Meta.ReduceMatcherResult.partialApp, Lean.getConstInfo, Lean.Meta.inferType, Lean.Meta.forallBoundedTelescope, Option.some, Lean.Meta.getTransparency, Eq, BEq.beq, Lean.Meta.TransparencyMode.reducible, Bool.true, PUnit.unit, Lean.Meta.ReduceMatcherResult.notMatcher],[Lean.Meta.MetaM, Lean.Meta.ReduceMatcherResult]]
[instSubUInt16,[Sub.mk, UInt16.sub],[Sub, UInt16]]
[Lean.PersistentEnvExtension.addEntryFn,[],[]]
[Lean.Expr.FoldConstsImpl.fold.visit,[Bind.bind, Lean.Expr.FoldConstsImpl.visited, ite, Eq, Bool.true, Pure.pure, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.lit, Lean.Expr.FoldConstsImpl.FoldM, Lean.Expr.FoldConstsImpl.fold.visit, MonadState.get, Lean.NameHashSet.contains, Lean.Expr.FoldConstsImpl.State.visitedConsts, modify, Lean.Expr.FoldConstsImpl.State.mk, Lean.Expr.FoldConstsImpl.State.visitedTerms, Lean.NameHashSet.insert],[Lean.Expr.FoldConstsImpl.FoldM]]
[Lean.idBeginEscape,[Char.ofNat],[Char]]
[List.reverseAux_eq_append,[of_eq_true, Eq.trans, congrArg, Eq, List.nil_append, eq_self, Eq.mpr, Eq.refl, List.reverseAux, List.cons, HAppend.hAppend, List.nil, List.append_assoc, rfl],[Eq, List.reverseAux, HAppend.hAppend, List.nil]]
[Lean.getPPAnalyzeTrustCoe,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.trustCoe, Lean.Option.defValue],[Bool]]
[Subtype.coe_eta,[Subtype.ext, rfl],[Eq, Subtype.mk, Subtype.val]]
[Lean.Parser.Term.noindex,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[Lean.Parser.Term.doContinue.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Attr.export.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Tactic.Ring.horner_add_horner_eq,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Tactic.Ring.horner, Eq.symm, of_eq_true, Eq.trans, congr, congrArg, add_comm, HMul.hMul, HPow.hPow, add_assoc, congrFun, add_mul, eq_self],[Eq, HAdd.hAdd, Tactic.Ring.horner]]
[Mathlib.Tactic.Lint.LintVerbosity.high.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Mathlib.Tactic.Lint.LintVerbosity.high, OfNat.ofNat]]
[Array.back?,[Array.get?, HSub.hSub, Array.size, OfNat.ofNat],[Option]]
[Lean.Meta.injectionCore,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getLocalDecl, Lean.Meta.whnf, Lean.LocalDecl.type, Unit.unit, Lean.Meta.MetaM, Lean.Meta.InjectionResultCore, Lean.Expr.eq?, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing, Lean.Meta.getMVarType, Lean.MonadEnv.getEnv, Option.none, Option.some, Lean.Expr.isConstructorApp?, Lean.Meta.mkNoConfusion, Lean.mkFVar, ite, Eq, bne, Lean.ConstantVal.name, Lean.ConstructorVal.toConstantVal, Bool.true, Lean.Meta.assignExprMVar, Pure.pure, Lean.Meta.InjectionResultCore.solved, Lean.Meta.inferType, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.getMVarTag, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.mkApp, Lean.Meta.tryClear, Lean.Expr.mvarId!, Lean.Meta.getCtorNumPropFields, Lean.Meta.InjectionResultCore.subgoal, HSub.hSub, Lean.ConstructorVal.numFields],[Lean.Meta.MetaM, Lean.Meta.InjectionResultCore]]
[Mathlib.Tactic.Conv.convRHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[Nat.mul_one,[Nat.zero_add],[Eq, HMul.hMul, OfNat.ofNat]]
[instReprList_1,[Repr.mk, Std.Format, List.cons, Std.Format.text, Std.Format.bracketFill, Std.Format.joinSep, HAppend.hAppend, Std.Format.line],[Repr, List]]
[Lean.Elab.Deriving.Repr.mkReprHeader,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.Elab.Deriving.mkHeader, OfNat.ofNat, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Prod.mk, Lean.Elab.Deriving.Header.mk, Array.push, Lean.Elab.Deriving.Header.binders, Lean.Elab.Deriving.Header.argNames, Lean.Elab.Deriving.Header.targetNames, Lean.Elab.Deriving.Header.targetType],[Lean.Elab.Term.TermElabM, Lean.Elab.Deriving.Header]]
[Lean.PrettyPrinter.Formatter.withOpenDecl.formatter,[],[Lean.PrettyPrinter.Formatter]]
[instDecidableArrow.proof_3,[absurd],[]]
[Lean.Compiler.foldNatPow,[OptionM.run, Bind.bind, Lean.Compiler.getNumLit, ite, LT.lt, Lean.Compiler.natPowThreshold, Pure.pure, Lean.mkRawNatLit, HPow.hPow, Alternative.failure],[Option, Lean.Expr]]
[Lean.IR.Decl.isExtern,[Lean.IR.Decl.fdecl, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Server.Watchdog.mkLeanServerCapabilities,[Lean.Lsp.ServerCapabilities.mk, Option.some, Lean.Lsp.TextDocumentSyncOptions.mk, Bool.true, Lean.Lsp.TextDocumentSyncKind.incremental, Bool.false, Option.none, Lean.Lsp.CompletionOptions.mk, List.toArray, List.cons, List.nil, Lean.Lsp.SemanticTokensOptions.mk, Lean.Lsp.SemanticTokensLegend.mk, Lean.Lsp.SemanticTokenType.names],[Lean.Lsp.ServerCapabilities]]
[Lean.Elab.Term.Do.ToTerm.Context.noConfusionType,[],[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.inspectOutParams,[Bind.bind, liftM, Lean.Meta.inferType, Lean.Expr.getAppFn, OfNat.ofNat, Lean.Expr.getAppArgs, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.inspectOutParams.inspectAux],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM, Unit]]
[Lean.Parser.Command.structCtor.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Command.declModifiers.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.inferMod.formatter, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Environment.constants,[],[Lean.ConstMap]]
[Lean.Option.noConfusionType,[],[]]
[Lean.Parser.Command.openDecl.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.openHiding.formatter, Lean.Parser.Command.openRenaming.formatter, Lean.Parser.Command.openOnly.formatter, Lean.Parser.Command.openSimple.formatter, Lean.Parser.Command.openScoped.formatter],[Lean.PrettyPrinter.Formatter]]
[sizeOfWFRel,[measure, SizeOf.sizeOf],[WellFoundedRelation]]
[Lean.PersistentEnvExtensionDescr.noConfusionType,[],[]]
[Lean.Elab.Term.Quotation.ArrayStxBuilder.append,[Sum.inr, Lean.Syntax.mkCApp, List.toArray, List.cons, Lean.Elab.Term.Quotation.ArrayStxBuilder.build, List.nil],[Lean.Elab.Term.Quotation.ArrayStxBuilder]]
[Std.RBTree.toArray,[Std.RBTree.fold, Array.push, List.toArray, List.nil],[Array]]
[Lean.Parser.Term.strictImplicitBinder,[Lean.Parser.ppGroup, Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.strictImplicitLeftBracket, Lean.Parser.many1, Lean.Parser.Term.binderIdent, Lean.Parser.Term.binderType, Lean.Parser.Term.strictImplicitRightBracket],[Lean.Parser.Parser]]
[Set.union,[setOf, Or, Mem.mem],[Set]]
[Lean.Meta.RecursorInfo.univLevelPos,[],[List, Lean.Meta.RecursorUnivLevelPos]]
[Lean.JsonRpc.instBEqRequestID,[BEq.mk, Lean.JsonRpc.RequestID.str, Lean.JsonRpc.RequestID.num, Lean.JsonRpc.RequestID.null, Unit.unit, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.JsonRpc.RequestID]]
[Lean.MetavarContext.LevelMVarToParam.Context.paramNamePrefix,[],[Lean.Name]]
[Lean.Elab.Tactic.evalSplit,[ite, Eq, Lean.Syntax.isNone, Lean.Syntax.getOp, OfNat.ofNat, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Elab.Tactic.Tactic]]
[Lean.Compiler.atMostOnce.seq,[Lean.Compiler.atMostOnce.AtMostOnceData.mk, Bool.true, Lean.Compiler.atMostOnce.AtMostOnceData, Bool.false],[Lean.Compiler.atMostOnce.Visitor]]
[System.FilePath.normalize,[ite, Eq, and, BEq.beq, List.length, System.FilePath.pathSeparators, OfNat.ofNat, not, Bool.true, System.FilePath.mk, String.map, List.contains, System.FilePath.pathSeparator, Char.toLower, System.FilePath.toString],[System.FilePath]]
[Lean.Meta.DiscrTree.insertCore,[ite, Eq, Array.isEmpty, Bool.true, panicWithPosWithDecl, OfNat.ofNat, Unit.unit, Lean.Meta.DiscrTree, Std.PersistentHashMap.find?, Lean.Meta.DiscrTree.root, Lean.Meta.DiscrTree.mk, Std.PersistentHashMap.insert],[Lean.Meta.DiscrTree]]
[Lean.Elab.Term.MVarErrorInfo.mvarId,[],[Lean.MVarId]]
[Lean.Syntax.expandInterpolatedStrChunks,[Bind.bind, ForIn.forIn, MProd.mk, Unit.unit, Lean.MacroM, ForInStep, MProd, Nat, Lean.Syntax, Lean.Syntax.isInterpolatedStrLit?, Lean.Syntax.mkStrLit, Lean.SourceInfo.none, Pure.pure],[Lean.MacroM, Lean.Syntax]]
[Lean.Meta.instInhabitedInstances,[Inhabited.mk, Lean.Meta.Instances.mk, arbitrary],[Inhabited, Lean.Meta.Instances]]
[Quotient.lift₂.proof_2,[Quotient.ind, Setoid.refl],[Eq, Quotient.lift, Setoid.refl]]
[Lean.Parser.many1Unbox,[Lean.Parser.withResultOf, Lean.Parser.many1NoAntiquot, ite, Eq, BEq.beq, Lean.Syntax.getNumArgs, OfNat.ofNat, Bool.true, Lean.Syntax.getArg],[Lean.Parser.Parser]]
[Lean.Parser.FirstTokens.tokens.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.FirstTokens.tokens, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.FirstTokens.tokens]]
[Lean.Elab.Term.MutualClosure.FixPoint.M,[ReaderT, List, Lean.FVarId, StateM, Lean.Elab.Term.MutualClosure.FixPoint.State],[]]
[Lean.Parser.Tactic.discharger,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Meta.Closure.State.nextLevelIdx,[],[Nat]]
[EStateM.run',[Option, EStateM.run, Option.some, Option.none],[Option]]
[Equiv.trans,[Equiv.mk, Function.comp, Equiv.toFun, Equiv.symm, Equiv.trans.proof_1, Equiv.trans.proof_2],[Equiv]]
[StateT.lift,[Bind.bind, Pure.pure, Prod.mk],[StateT]]
[Lean.Level.zero.injEq,[Eq.propIntro, Eq.refl, Lean.Level.zero, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Level.zero]]
[AndOp.and,[],[]]
[Lean.Lsp.DiagnosticWith.source?,[],[Option, String]]
[Nat.succ_sub_succ,[Nat.succ_sub_succ_eq_sub],[Eq, HSub.hSub, Nat.succ]]
[Lean.Server.FileWorker.AsyncElabM,[ExceptT, Lean.Server.FileWorker.ElabTaskError, ReaderT, Lean.Server.FileWorker.WorkerContext, IO],[]]
[IO.FS.Stream.readJson,[Bind.bind, IO.FS.Stream.read, USize.ofNat, IO.ofExcept, Lean.Json.parse],[IO, Lean.Json]]
[Lean.Parser.Command.mutual,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.ppLine, Lean.Parser.notSymbol, Lean.Parser.commandParser, Lean.Parser.ppDedent, Lean.Parser.Command.terminationSuffix],[Lean.Parser.Parser]]
[Lean.Meta.SimpLemma.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SimpLemma.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SimpLemma.mk, And]]
[Lean.Meta.DiscrTree.instHashableKey,[Hashable.mk, Lean.Meta.DiscrTree.Key.hash],[Hashable, Lean.Meta.DiscrTree.Key]]
[Lean.ProjectionFunctionInfo.i,[],[Nat]]
[Fin.checkedSub,[Option, Fin, Fin.underflowingSub, Option.none, Option.some],[Option, Fin]]
[Lean.PrettyPrinter.Delaborator.addTermInfo.mkTermInfo,[Bind.bind, Lean.MonadLCtx.getLCtx, Pure.pure, Lean.Elab.Info.ofTermInfo, Lean.Elab.TermInfo.mk, Lean.Elab.ElabInfo.mk, Lean.Name.mkStr, Lean.Name.anonymous, Option.none],[Lean.PrettyPrinter.Delaborator.DelabM, Lean.Elab.Info]]
[ulift.up.injEq,[Eq.propIntro, Eq.refl, ulift.up, Eq.symm, eq_of_heq, HEq.refl],[Eq, ulift.up]]
[WellFounded.fixFEq.proof_1,[rfl],[Eq, WellFounded.fixF, Acc.inv]]
[Lean.MessageLog.append,[Lean.MessageLog.mk, HAppend.hAppend, Lean.MessageLog.msgs],[Lean.MessageLog]]
[Lean.Parser.sepBy.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.sepByNoAntiquot.parenthesizer, Lean.Parser.sepByElemParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[opt_param_eq,[optParam_eq],[Eq, optParam]]
[Function.surjective.forall₂,[Iff.trans, Function.surjective.forall, forall_congr'],[Iff]]
[Lean.Meta.SynthInstance.State.result?,[],[Option, Lean.Meta.AbstractMVarsResult]]
[Lean.Elab.TermInfo.toElabInfo,[],[Lean.Elab.ElabInfo]]
[Lean.Lsp.Trace.off.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.Trace.off, OfNat.ofNat]]
[IO.AccessRight.read,[],[Bool]]
[Lean.Meta.ReduceMatcherResult.reduced.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.ReduceMatcherResult.reduced, HAdd.hAdd, OfNat.ofNat]]
[USize.add_def,[rfl],[Eq, HAdd.hAdd, USize.mk, USize.val]]
[Thunk.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Thunk.mk, OfNat.ofNat]]
[Nat.mul_mod_left,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HMul.hMul, OfNat.ofNat, Nat.mul_comm, Nat.mul_mod_right, rfl],[Eq, HMod.hMod, HMul.hMul, OfNat.ofNat]]
[or_congr_left,[or_congr, Iff.rfl],[Iff, Or]]
[Nat.lt_of_add_lt_add_left,[Nat.lt_of_le_of_ne, Nat.le_of_add_le_add_left, Nat.le_of_lt, Nat.lt_irrefl, HAdd.hAdd, Eq.mp, Eq.refl, LT.lt],[LT.lt]]
[Lean.Server.FileWorker.RefIdent.const.inj,[],[Eq]]
[Lean.Parser.Command.openRenamingItem,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.unicodeSymbol, Lean.Parser.checkColGt],[Lean.Parser.Parser]]
[Lean.Xml.Parser.elementPrefix,[Bind.bind, Lean.Parsec.skipChar, Char.ofNat, Lean.Xml.Parser.Name, Lean.Parsec.many, SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Xml.Parser.Attribute, optional, Pure.pure, Unit.unit, Lean.Xml.Element.Element, Std.RBMap.fromList, Array.toList, Ord.compare],[Lean.Parsec, Lean.Xml.Element]]
[Lean.IR.mkDecl,[Lean.IR.Decl.fdecl, Lean.IR.DeclInfo.mk],[Lean.IR.Decl]]
[Lean.AttributeKind.scoped.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.AttributeKind.scoped, OfNat.ofNat]]
[Std.PersistentHashSet.find?,[Unit.unit, Option, Std.PersistentHashMap.findEntry?, Std.PersistentHashSet.set, Option.some, Option.none],[Option]]
[FloatArray.get!,[Float, Array.get!],[Float]]
[Lean.Meta.Match.withGoalOf,[Lean.Meta.withMVarContext, Lean.Meta.Match.Problem.mvarId],[Lean.Meta.MetaM]]
[Lean.Elab.Command.withScope,[Bind.bind, MonadState.get, Unit.unit, Lean.Elab.Command.CommandElabM, Lean.Elab.Command.State.scopes, tryFinally, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, List.cons, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState],[Lean.Elab.Command.CommandElabM]]
[Nat.le_lt_antisymm,[Nat.lt_irrefl, Nat.lt_of_le_of_lt],[False]]
[Array.data,[],[List]]
[Nat.div_le_of_le_mul,[LE.le, HDiv.hDiv, of_eq_true, Eq.trans, congrFun, congrArg, Nat.div_zero, eq_true, Nat.zero_le],[LE.le, HDiv.hDiv]]
[Lean.Macro.Context.maxRecDepth,[],[Nat]]
[Lean.Parser.Term.letRecDecl.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.docComment.parenthesizer, Lean.Parser.Term.attributes.parenthesizer, Lean.Parser.Term.letDecl.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.JsonRpc.instOrdRequestID,[Ord.mk, Lean.JsonRpc.RequestID.num, Lean.JsonRpc.RequestID.null, Unit.unit, Ordering, Ord.compare, Ordering.lt, Ordering.gt, Ordering.eq],[Ord, Lean.JsonRpc.RequestID]]
[Lean.Meta.InstanceEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.InstanceEntry.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.InstanceEntry.mk, And]]
[Lean.Meta.ApplyNewGoals.noConfusion,[noConfusionEnum, Lean.Meta.ApplyNewGoals.toCtorIdx],[Lean.Meta.ApplyNewGoals.noConfusionType]]
[Lean.DefinitionSafety.unsafe.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.DefinitionSafety.unsafe, OfNat.ofNat]]
[Lean.Core.instMonadRefCoreM,[Lean.MonadRef.mk, Bind.bind, MonadReader.read, Pure.pure, Lean.Core.Context.ref, MonadWithReader.withReader, Lean.Core.Context.mk, Lean.Core.Context.options, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats],[Lean.MonadRef, Lean.Core.CoreM]]
[instNumericFin,[Numeric.mk, Fin.ofNat', Fin.size_positive'],[Numeric, Fin]]
[Lean.registerBuiltinAttribute,[Bind.bind, ST.Ref.get, Lean.attributeMapRef, ite, Eq, Std.PersistentHashMap.contains, Lean.AttributeImplCore.name, Lean.AttributeImpl.toAttributeImplCore, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Pure.pure, PUnit.unit],[IO, Unit]]
[List.instEmptyCollectionList,[EmptyCollection.mk, List.nil],[EmptyCollection, List]]
[UInt64.instSemiringUInt64.proof_5,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, congrFun, HMul.hMul, UInt64.zero_def, UInt64.mul_def, UInt64.mk, OfNat.ofNat, MonoidWithZero.zero_mul, UInt64.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt64],[Eq, HMul.hMul, OfNat.ofNat]]
[Std.HashSet.isEmpty,[Decidable.decide, Eq, Std.HashSet.size, OfNat.ofNat],[Bool]]
[Array.foldrMUnsafe,[ite, LE.le, Array.size, LT.lt, USize.ofNat, Pure.pure, Array.foldrMUnsafe.fold],[]]
[Lean.Server.FileWorker.handlePlainGoal,[Bind.bind, Lean.Server.FileWorker.getInteractiveGoals, Pure.pure, Task.map, Except.map, Option.map, Lean.Lsp.PlainGoal, ite, Eq, Array.isEmpty, Bool.true, Lean.Lsp.PlainGoal.mk, List.toArray, List.nil, Task.Priority.default],[Lean.Server.RequestM, Lean.Server.RequestTask, Option, Lean.Lsp.PlainGoal]]
[Lean.Elab.Term.TermElabM.run',[Functor.map, Prod.fst, Lean.Elab.Term.TermElabM.run],[Lean.Meta.MetaM]]
[Lean.Elab.Command.mkDefView,[ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Lean.Elab.Command.mkDefViewOfAbbrev, Lean.Elab.Command.mkDefViewOfDef, Lean.Elab.Command.mkDefViewOfTheorem, Lean.Elab.Command.mkDefViewOfConstant, Lean.Elab.Command.mkDefViewOfInstance, Lean.Elab.Command.mkDefViewOfExample, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Elab.Command.CommandElabM, Lean.Elab.DefView]]
[neg_add_self,[add_left_neg],[Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat]]
[Lean.Meta.SizeOfSpecNested.Context.localInsts,[],[Array, Lean.Expr]]
[Lean.Exception.noConfusionType,[],[]]
[Lean.Server.FileWorker.PendingRequestMap,[Std.RBMap, Lean.JsonRpc.RequestID, Task, Except, IO.Error, Unit, Ord.compare],[]]
[Lean.IR.Index,[Nat],[]]
[Array.get,[List.get, Array.data, Fin.val, Array.get.proof_1],[]]
[Lean.Meta.instReprCongrLemmas,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.Meta.CongrLemmas.lemmas],[Repr, Lean.Meta.CongrLemmas]]
[Lean.Parser.sepBy1Info,[Lean.Parser.ParserInfo.mk, Function.comp, Lean.Parser.ParserInfo.collectTokens, Lean.Parser.ParserInfo.collectKinds, Lean.Parser.ParserInfo.firstTokens],[Lean.Parser.ParserInfo]]
[Lean.Elab.GoalsAtResult.tacticInfo,[],[Lean.Elab.TacticInfo]]
[Lean.LocalContext.findDeclRev?,[Id.run, Lean.LocalContext.findDeclRevM?],[Option]]
[Fin.eq_of_val_eq,[Eq.symm, eq_of_heq, Eq.refl, Fin.val, Fin.mk, HEq.refl, Eq, rfl],[Eq]]
[Lean.PrettyPrinter.Parenthesizer.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Parenthesizer.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PrettyPrinter.Parenthesizer.State.mk, And]]
[ReaderT.run_read,[rfl],[Eq, ReaderT.run, ReaderT.read, Pure.pure]]
[Lean.SSet.toList,[Lean.SSet.fold, List.cons, List.nil],[List]]
[Lean.Meta.Closure.ToProcessElement.noConfusionType,[],[]]
[Nat.add_mod_left,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, Nat.add_comm, Nat.add_mod_right, rfl],[Eq, HMod.hMod, HAdd.hAdd]]
[MonadStateOf.get,[],[]]
[Prod.rprod.proof_1,[Subrelation.wf, WellFoundedRelation.wf, Prod.lex, Prod.RProdSubLex],[WellFounded, Prod.RProd, WellFoundedRelation.rel]]
[Lean.Rat.instMulRat,[Mul.mk, Lean.Rat.mul],[Mul, Lean.Rat]]
[Lean.Meta.foldPatValue,[Option.none, Lean.Expr, Lean.Meta.isUIntPatLit?, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, List.nil],[Lean.Expr]]
[Nat.prod_dvd_and_dvd_of_dvd_prod.proof_4,[Eq.symm],[Eq, Nat.succ, Nat.gcd]]
[Lean.Elab.Structural.preprocess,[Lean.Core.transform, Pure.pure, Lean.TransformStep.visit, ite, Eq, Lean.Expr.isHeadBetaTarget, Bool.true, Option.isSome, Lean.Expr.find?, Lean.Expr.isConstOf, Lean.Expr.getAppFn, Bool.false, Lean.Expr.headBeta, Lean.TransformStep.done],[Lean.Core.CoreM, Lean.Expr]]
[Lean.PrettyPrinter.Parenthesizer.suppressInsideQuot.parenthesizer,[],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Compiler.foldUIntMod,[Lean.Compiler.foldBinUInt, Mod.mod],[Option, Lean.Expr]]
[UInt64.instSemiringUInt64.proof_9,[rfl],[Eq, OfNat.ofNat]]
[Lean.IR.NormalizeIds.withJP,[Bind.bind, getModify, HAdd.hAdd, OfNat.ofNat, Lean.IR.JoinPointId.mk, Std.RBMap.insert, Lean.IR.JoinPointId.idx],[Lean.IR.NormalizeIds.N]]
[List.instMemList,[Mem.mk, List.mem],[Mem, List]]
[Lean.Elab.TacticInfo.toElabInfo,[],[Lean.Elab.ElabInfo]]
[Lean.Elab.Term.getMessageLog,[Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Term.State.messages],[Lean.Elab.Term.TermElabM, Lean.MessageLog]]
[Lean.Meta.checkAssignment,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, Lean.Meta.inferType, Lean.Meta.occursCheck, ite, Eq, Bool.true, Pure.pure, ForInStep.yield, ForInStep.done, Option.some, Unit.unit, Lean.Meta.MetaM, Option, Lean.Expr, MProd.fst],[Lean.Meta.MetaM, Option, Lean.Expr]]
[Function.extend,[dite, Exists, Eq, Classical.choose],[]]
[False.elim,[],[]]
[decide_eq_true,[Eq, Decidable.decide, Bool.true, rfl, absurd],[Eq, Decidable.decide, Bool.true]]
[Lean.JsonRpc.instBEqErrorCode,[BEq.mk, BEq.beq, Lean.JsonRpc.ErrorCode.toCtorIdx],[BEq, Lean.JsonRpc.ErrorCode]]
[Lean.Lsp.DefinitionParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DefinitionParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.DefinitionParams.mk]]
[Lean.isClosedTermName,[Lean.NameSet.contains, Lean.ClosedTermCache.constNames, Lean.EnvExtension.getState, Lean.closedTermCacheExt],[Bool]]
[instMonadExcept,[MonadExcept.mk, throwThe, tryCatchThe],[MonadExcept]]
[Std.Format.group.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.tacticAdmit,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[CommRing.mul_comm,[],[Eq, HMul.hMul]]
[Lean.Elab.addDeclarationRanges,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Unit.unit, Bind.bind, Lean.Elab.getDeclarationRange, Lean.Elab.getDeclarationSelectionRef, Lean.addDeclarationRanges, Lean.DeclarationRanges.mk],[Unit]]
[Lean.Meta.Match.Problem.mk.inj,[And.intro],[And, Eq]]
[Lean.Declaration.forExprM,[Lean.Declaration.foldExprM, Unit.unit],[Unit]]
[Lean.EnumAttributes.attrs,[],[List, Lean.AttributeImpl]]
[Lean.Parser.strLit,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.strLitKind, Bool.true, Lean.Parser.strLitNoAntiquot],[Lean.Parser.Parser]]
[Lean.JsonRpc.instToStringRequestID,[ToString.mk, Unit.unit, String, ToString.toString],[ToString, Lean.JsonRpc.RequestID]]
[Lean.Elab.TermInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.TermInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.elabTrailingParserMacro,[Lean.Elab.Term.adaptExpander, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElab]]
[Lean.Meta.ppGoal,[Bind.bind, Lean.MonadMCtx.getMCtx, Unit.unit, Lean.Meta.MetaM, Std.Format, Lean.MetavarContext.findDecl?, Pure.pure, Std.Format.text, Lean.MonadOptions.getOptions, Lean.Meta.withLCtx, Lean.MetavarDecl.localInstances, Lean.Meta.ToHide.collect, Lean.MetavarDecl.type, Lean.LocalContext.foldlM, Prod, List, Lean.Name, Option, Lean.Expr, ite, Eq, or, and, not, Lean.LocalDecl.isAuxDecl, Std.RBTree.contains, Lean.LocalDecl.fvarId, Bool.true, Prod.mk, List.nil, Option.none, Std.Format.nil, OfNat.ofNat, Lean.Meta.instantiateMVars, Lean.Meta.ppExpr, Lean.Name.str, Lean.Name.num, Lean.MetavarDecl.userName, HAppend.hAppend, Std.ToFormat.format, Lean.Name.eraseMacroScopes, Std.Format.line, Lean.Meta.ppGoal.ppVars, Lean.Meta.ppGoal.pushPending],[Lean.Meta.MetaM, Std.Format]]
[Lean.KVMap.get,[Option.getD, Lean.KVMap.get?],[]]
[Lean.Expr.setAppPPExplicitForExposingMVars,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.setPPExplicit, Lean.mkAppN, Bool.true],[Lean.Expr]]
[StateT.run'_eq,[rfl],[Eq, StateT.run', Functor.map, Prod.fst, StateT.run]]
[Lean.KeyedDeclsAttribute.OLeanEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KeyedDeclsAttribute.OLeanEntry.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KeyedDeclsAttribute.OLeanEntry.mk, And]]
[Lean.bracketedExplicitBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.binderIdent, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[Lean.Meta.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.KernelException.invalidProj.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.invalidProj, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KernelException.invalidProj, And]]
[Lean.instDecidableLt,[inferInstanceAs, Decidable, Eq, Lean.Literal.lt, Bool.true],[Decidable, LT.lt]]
[Lean.PrefixTree.insert,[Subtype.mk, Lean.PrefixTreeNode.insert, Subtype.val, Lean.PrefixTree.insert.proof_1],[Lean.PrefixTree]]
[OptionT.instMonadExceptOfUnitOptionT,[MonadExceptOf.mk, OptionT.fail, OptionT.tryCatch],[MonadExceptOf, Unit, OptionT]]
[seq_eq_bind_map,[Eq.mpr, Eq.refl, Eq, Seq.seq, Bind.bind, Functor.map, Eq.symm, LawfulMonad.bind_map, rfl],[Eq, Seq.seq, Bind.bind, Functor.map]]
[StateCpsT.runK_bind_modify,[rfl],[Eq, StateCpsT.runK, Bind.bind, modify, PUnit.unit]]
[Prod.swap_swap,[Eq, Prod.swap, rfl],[Eq, Prod.swap]]
[Lean.Elab.elabModifiers,[Unit.unit, Lean.Elab.Modifiers, Lean.Syntax.getOptional?, Bind.bind, Pure.pure, Option.none, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Lean.Syntax.getOp, OfNat.ofNat, Option.some, String.extract, HSub.hSub, String.bsize, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.ofSyntax],[Lean.Elab.Modifiers]]
[Acc.inv,[Acc.inv.proof_1],[Acc]]
[Lean.PrettyPrinter.Formatter.ite,[ite],[Lean.PrettyPrinter.Formatter]]
[Decidable.by_contradiction,[Decidable.byContradiction],[]]
[Lean.Parser.Term.set_option,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.ppSpace, Lean.Parser.Command.optionValue, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.Parser.ParserState.mkUnexpectedErrorAt,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Array.push, Lean.Syntax.missing, Option.some, Lean.Parser.Error.mk],[Lean.Parser.ParserState]]
[StateCpsT.run'_eq,[rfl],[Eq, StateCpsT.run', StateCpsT.runK, Pure.pure]]
[UInt8.land,[UInt8.mk, Fin.land, UInt8.val],[UInt8]]
[Lean.Meta.CaseValueSubgoal.newH,[],[Lean.FVarId]]
[and_congr_right,[Iff.intro, And, And.intro, Iff.mp, Iff.mpr],[Iff, And]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.AppMatchState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PrettyPrinter.Delaborator.AppMatchState.mk, And]]
[Lean.instInhabitedLocalDecl,[Inhabited.mk, Lean.LocalDecl.cdecl, arbitrary],[Inhabited, Lean.LocalDecl]]
[Std.RBNode.find,[Option, Option.none, Unit.unit, PProd.fst, PProd.snd, Option.some],[Option]]
[Lean.Lsp.MarkupContent.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.MarkupContent.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.MarkupContent.mk, And]]
[Lean.Meta.GeneralizeTelescope.Entry.noConfusionType,[],[]]
[IO.Error.alreadyExists.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.alreadyExists, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.alreadyExists, And]]
[Lean.IR.EmitC.emitDecl,[MonadExcept.tryCatch, Lean.IR.EmitC.emitDeclAux, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.IR.EmitC.M, Unit]]
[Lean.Elab.Term.LValResolution.projFn.inj,[And.intro],[And, Eq]]
[Set.univ,[setOf, True],[Set]]
[Nat.add_left_comm,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Eq.symm, Nat.add_assoc, Nat.add_comm, rfl],[Eq, HAdd.hAdd]]
[Lean.Parser.Term.let.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.letDecl.parenthesizer, Lean.Parser.Term.optSemicolon.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.identFnAux,[Lean.Parser.identFnAux.parse],[Lean.Parser.ParserFn]]
[Lean.LocalContext.getFVarIds,[Std.PersistentArray.foldl, Lean.LocalContext.decls, Unit.unit, Array, Lean.FVarId, Array.push, Lean.LocalDecl.fvarId, List.toArray, List.nil, OfNat.ofNat],[Array, Lean.FVarId]]
[Lean.Elab.instInhabitedContextInfo,[Inhabited.mk, Lean.Elab.ContextInfo.mk, arbitrary],[Inhabited, Lean.Elab.ContextInfo]]
[Lean.Meta.byCases,[Bind.bind, Lean.Meta.assert, Lean.Name.mkStr, Lean.Name.anonymous, Lean.mkOr, Lean.mkNot, Lean.mkEM, Lean.Meta.intro1, Lean.Meta.MetaM, Prod, Lean.Meta.ByCasesSubgoal, Lean.Meta.cases, List.toArray, List.cons, Lean.Meta.AltVarNames.mk, List.nil, dite, Eq, Array.size, Array.getLit, Eq.symm, of_decide_eq_true, id, Eq.refl, Bool.true, Array.toArrayLit_eq, Pure.pure, Prod.mk, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Meta.byCases.toByCasesSubgoal],[Lean.Meta.MetaM, Prod, Lean.Meta.ByCasesSubgoal]]
[Nat.succ_le_succ,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, LE.le, Nat.succ, Nat.le.refl, Nat.le.step, PProd.fst],[LE.le, Nat.succ]]
[Lean.Elab.Term.StructInst.FieldVal.term.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.StructInst.FieldVal.term, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.StructInst.FieldVal.term]]
[List.toPersistentArrayAux,[Std.PersistentArray, PProd.fst, Std.PersistentArray.push],[Std.PersistentArray]]
[instAddCommGroup.proof_2,[Semiring.zero_add],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Nat.pow,[Unit.unit, Nat, OfNat.ofNat, Nat.mul, PProd.fst],[Nat]]
[Tactic.Ring.HornerExpr.instCoeHornerExprExpr,[Coe.mk, Tactic.Ring.HornerExpr.e],[Coe, Tactic.Ring.HornerExpr, Lean.Expr]]
[Lean.Elab.Command.expandNotationItemIntoPattern,[ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Lean.Syntax.mkAntiquotNode, Lean.Syntax.getOp, OfNat.ofNat, Option.none, Lean.strLitKind, Lean.Elab.Command.strLitToPattern, Lean.Macro.throwUnsupported],[Lean.MacroM, Lean.Syntax]]
[Lean.Parser.Term.doBreak.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.ExplicitBoxing.withJDecl,[MonadWithReader.withReader, Lean.IR.ExplicitBoxing.BoxingContext.mk, Lean.IR.ExplicitBoxing.BoxingContext.f, Lean.IR.LocalContext.addJP, Lean.IR.ExplicitBoxing.BoxingContext.localCtx, Lean.IR.ExplicitBoxing.BoxingContext.resultType, Lean.IR.ExplicitBoxing.BoxingContext.decls, Lean.IR.ExplicitBoxing.BoxingContext.env],[Lean.IR.ExplicitBoxing.M]]
[Lean.Lsp.PublishDiagnosticsParams.version?,[],[Option, Int]]
[Lean.Parser.checkLhsPrec,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.checkLhsPrecFn],[Lean.Parser.Parser]]
[Lean.cacheClosedTermName,[Lean.EnvExtension.modifyState, Lean.closedTermCacheExt, Lean.ClosedTermCache.mk, Std.PersistentHashMap.insert, Lean.ClosedTermCache.map, Lean.NameSet.insert, Lean.ClosedTermCache.constNames],[Lean.Environment]]
[IO.Error.unsatisfiedConstraints.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.unsatisfiedConstraints, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.unsatisfiedConstraints, And]]
[FloatArray.foldlM.loop,[dite, LT.lt, Unit.unit, Pure.pure, Bind.bind, FloatArray.get, Fin.mk, FloatArray.foldlM.loop.proof_1, PProd.fst, HAdd.hAdd, OfNat.ofNat],[]]
[HAppend.noConfusionType,[],[]]
[Lean.Parser.Tactic.simpResult,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Lsp.PublishDiagnosticsParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.PublishDiagnosticsParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.BinderView.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.Borrow.ownArgs,[Array.forM, Lean.IR.Borrow.ownArg, OfNat.ofNat, Array.size],[Lean.IR.Borrow.M, Unit]]
[Lean.Parser.Tactic.rcasesPatMed,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.sepBy1, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.symbol, Bool.false],[Lean.ParserDescr]]
[Quotient.exact,[Quot.inductionOn, Setoid.refl],[HasEquiv.Equiv]]
[Lean.Elab.instBEqDefKind,[BEq.mk, BEq.beq, Lean.Elab.DefKind.toCtorIdx],[BEq, Lean.Elab.DefKind]]
[Lean.Parser.withAntiquotFn,[ite, Eq, Lean.Parser.tryAnti, Bool.true, Lean.Parser.orelseFn],[Lean.Parser.ParserFn]]
[Lean.Parser.Tactic.unknown.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.PrettyPrinter.Formatter.errorAtSavedPos.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.mkFreshExprMVar,[Unit.unit, Lean.Meta.MetaM, Lean.Expr, Bind.bind, Lean.MonadLCtx.getLCtx, Lean.Meta.getLocalInstances, Lean.Meta.mkFreshExprMVarAt, OfNat.ofNat, Lean.Meta.mkFreshLevelMVar, Lean.mkSort, Lean.MetavarKind.natural, Lean.Name.anonymous],[Lean.Meta.MetaM, Lean.Expr]]
[Std.ToFormat.noConfusionType,[],[]]
[Std.RBMap.forIn,[Std.RBNode.forIn, Subtype.val, Prod.mk],[]]
[Lean.Expr.getAppFnArgs,[Lean.Expr.withApp, Prod.mk, Lean.Expr.constName],[Prod, Lean.Name, Array, Lean.Expr]]
[Decidable.or_iff_not_and_not,[Eq.mpr, Eq.refl, Iff, Or, Not, And, Eq.symm, propext, not_or_distrib, Decidable.not_not, Iff.rfl],[Iff, Or, Not, And]]
[Lean.Meta.AssertAfterResult.subst,[],[Lean.Meta.FVarSubst]]
[Lean.PrettyPrinter.Delaborator.reifyName,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Name.anonymous, Lean.Name.str, dite, Eq, Eq.symm, Lean.Name.num, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.natVal, Lean.Expr.mdata, Lean.Expr.proj, Lean.Literal.strVal, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Name, Pure.pure, Bind.bind, PProd.fst, PProd.snd, Lean.Name.mkStr, Lean.Name.mkNum, Alternative.failure],[Lean.PrettyPrinter.Delaborator.DelabM, Lean.Name]]
[Lean.PrettyPrinter.Formatter.notFollowedByCategoryToken.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[Char.isLower,[and, Decidable.decide, GE.ge, Char.val, OfNat.ofNat, LE.le],[Bool]]
[Lean.Meta.AuxLemmas.noConfusionType,[],[]]
[EStateM.Result.error.inj,[And.intro],[And, Eq]]
[Tactic.Ring.subst_into_add,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, rfl],[Eq, HAdd.hAdd]]
[Lean.isIOUnitRegularInitFn,[Lean.isIOUnitInitFnCore, Lean.regularInitAttr],[Bool]]
[Lean.Parser.Term.type,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.checkWsBefore, Lean.Parser.checkPrec, Lean.Parser.leadPrec, Lean.Parser.checkColGt, Lean.Parser.levelParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[Lean.Meta.IndPredBelow.proveBrecOn.intros,[Bind.bind, Lean.Meta.introNP, Lean.InductiveVal.numParams, Lean.Meta.MetaM, Prod, Lean.MVarId, Lean.Meta.IndPredBelow.BrecOnVariables, Array.size, Lean.Meta.IndPredBelow.Context.motives, Lean.InductiveVal.numIndices, Lean.Meta.intro1P, Pure.pure, Prod.mk, Lean.Meta.IndPredBelow.BrecOnVariables.mk],[Lean.Meta.MetaM, Prod, Lean.MVarId, Lean.Meta.IndPredBelow.BrecOnVariables]]
[Lean.Parser.indexed,[Prod, Lean.Parser.ParserState, List, Lean.Syntax.missing, Lean.Name.mkSimple, Unit.unit, Lean.identKind, Std.RBMap.find?, Prod.mk, Option.none, HAppend.hAppend, List.nil],[Prod, Lean.Parser.ParserState, List]]
[Nat.find_x.proof_2,[Or.elim, lt_or_eq_of_le, Eq.mpr, Eq.refl, Not],[Not]]
[USize.le,[LE.le, USize.val],[]]
[Lean.Meta.InjectionResult.noConfusionType,[],[]]
[Lean.addAndCompile,[Bind.bind, Lean.addDecl, Lean.compileDecl],[Unit]]
[Lean.Position.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Position.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Position.mk, And]]
[Mathlib.Eval.evalExpr,[Lean.withoutModifyingEnv, Bind.bind, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.inferType, Lean.Meta.isDefEq, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM]]
[Lean.Elab.instInhabitedTermInfo,[Inhabited.mk, Lean.Elab.TermInfo.mk, arbitrary],[Inhabited, Lean.Elab.TermInfo]]
[String.posOf,[String.posOfAux, String.bsize, OfNat.ofNat],[String.Pos]]
[StateCpsT.run,[StateCpsT.runK, Pure.pure, Prod.mk],[Prod]]
[Lean.mkNoConfusionEnum.mkNoConfusionType,[Lean.Meta.withLocalDeclD, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.Meta.mkForallFVars, List.toArray, List.cons, List.nil, Bool.false, Bool.true, Lean.Meta.mkAppM, Lean.Meta.mkLambdaFVars, Lean.addAndCompile, Lean.Declaration.defnDecl, Lean.DefinitionVal.mk, Lean.ConstantVal.mk, Lean.ReducibilityHints.abbrev, Lean.DefinitionSafety.safe],[Lean.Meta.MetaM, Unit]]
[Lean.Syntax.instBEqSyntax,[BEq.mk, Lean.Syntax.structEq],[BEq, Lean.Syntax]]
[Lean.ExternAttrData.arity?,[],[Option, Nat]]
[Std.HashMapBucket.update.proof_1,[Eq.mpr, Eq.refl, GT.gt, Array.size, Array.uset, Subtype.val, OfNat.ofNat, Array.size_set, Fin.mk, USize.toNat, Subtype.property],[GT.gt, Array.size, Array.uset, Subtype.val, OfNat.ofNat]]
[Lean.Widget.exprToInteractive,[Bind.bind, Lean.Widget.formatInfos, Lean.Meta.MetaM, Lean.Widget.CodeWithInfos, Lean.MonadEnv.getEnv, Lean.MonadMCtx.getMCtx, Lean.MonadOptions.getOptions, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, Pure.pure, Lean.Widget.tagExprInfos],[Lean.Meta.MetaM, Lean.Widget.CodeWithInfos]]
[Nat.sub_sub,[Eq, HSub.hSub, HAdd.hAdd, Eq.mpr, Eq.refl, OfNat.ofNat, Nat.add_zero, Nat.sub_zero, rfl, Nat.succ, Nat.add_succ, Nat.sub_succ, Nat.pred, PProd.fst],[Eq, HSub.hSub, HAdd.hAdd]]
[Array.isPrefixOf,[dite, LE.le, Array.size, Array.isPrefixOfAux, OfNat.ofNat, Bool.false],[Bool]]
[instOfNatFloat,[OfNat.mk, Float.ofNat],[OfNat, Float]]
[ST.Prim.Ref.modify,[Bind.bind, ST.Prim.Ref.get, ST.Prim.Ref.set],[ST, Unit]]
[Mathlib.Tactic.Conv.traceLHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Lsp.instToJsonTextDocumentSyncKind,[Lean.ToJson.mk, Unit.unit, Lean.Json, OfNat.ofNat],[Lean.ToJson, Lean.Lsp.TextDocumentSyncKind]]
[Int.subNatNat_add_add,[Int.subNatNat_elim, Eq, Int.subNatNat, HAdd.hAdd, Eq.mpr, Eq.refl, Int.ofNat, Nat.add_assoc, Nat.add_comm, Eq.symm, Int.subNatNat_add_left, OfNat.ofNat, Int.negSucc, Int.subNatNat_add_right],[Eq, Int.subNatNat, HAdd.hAdd]]
[Std.Range.«term[_:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Core.instMonadTraceCoreM,[Lean.MonadTrace.mk, modify, Lean.Core.State.mk, Lean.Core.State.env, Lean.Core.State.nextMacroScope, Lean.Core.State.ngen, Lean.Core.State.traceState, Bind.bind, MonadState.get, Pure.pure],[Lean.MonadTrace, Lean.Core.CoreM]]
[instCommRingFin,[CommRing.mk, instCommRingFin.proof_1],[CommRing, Fin]]
[MonadFunctor.noConfusionType,[],[]]
[Nat.sub_lt_self,[Nat.sub_lt, Nat.lt_of_lt_of_le],[LT.lt, HSub.hSub]]
[Lean.mkCIdentFrom,[Lean.Syntax.ident, Lean.SourceInfo.fromRef, String.toSubstring, ToString.toString, List.cons, Prod.mk, List.nil],[Lean.Syntax]]
[Lean.IR.log,[modify, Lean.IR.CompilerState.mk, Lean.IR.CompilerState.env, Array.push, Lean.IR.CompilerState.log],[Lean.IR.CompilerM, Unit]]
[Lean.Meta.CongrLemmas.get,[Unit.unit, List, Lean.Meta.CongrLemma, Lean.SMap.find?, Lean.Meta.CongrLemmas.lemmas, List.nil],[List, Lean.Meta.CongrLemma]]
[Lean.Elab.Info.pos?,[Lean.Syntax.getPos?, Lean.Elab.Info.stx, Bool.true],[Option, String.Pos]]
[Lean.Elab.instMonadMacroAdapter,[Lean.Elab.MonadMacroAdapter.mk, liftM, Lean.Elab.MonadMacroAdapter.getCurrMacroScope, Lean.Elab.MonadMacroAdapter.getNextMacroScope, Lean.Elab.MonadMacroAdapter.setNextMacroScope],[Lean.Elab.MonadMacroAdapter]]
[Lean.Parser.Term.optExprPrecedence.formatter,[Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.Do.isDoExpr?,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Option.some, Lean.Syntax.getOp, OfNat.ofNat, Option.none],[Option, Lean.Syntax]]
[Lean.Parser.Tactic.rcasesPat.tuple,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.rcasesPatLo, Bool.false],[Lean.ParserDescr]]
[Nat.div_le_self,[LE.le, HDiv.hDiv, Eq.mpr, congrFun, congrArg, Nat.div_zero, Nat.zero_le, Nat.div_le_of_le_mul],[LE.le, HDiv.hDiv]]
[nonempty_of_exists,[Nonempty, Nonempty.intro],[Nonempty]]
[Lean.Expr.ReplaceImpl.replaceUnsafeM.visit,[Bind.bind, MonadState.get, ite, Eq, BEq.beq, ptrAddrUnsafe, Array.uget, Lean.Expr.ReplaceImpl.State.keys, lcProof, Bool.true, Pure.pure, Lean.Expr.ReplaceImpl.State.results, Unit.unit, Lean.Expr.ReplaceImpl.ReplaceM, Lean.Expr, Lean.Expr.ReplaceImpl.cache, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lit, Lean.Expr.ReplaceImpl.replaceUnsafeM.visit, Lean.Expr.updateForallE!, Lean.Expr.updateLambdaE!, Lean.Expr.updateMData!, Lean.Expr.updateLet!, Lean.Expr.updateApp!, Lean.Expr.updateProj!],[Lean.Expr.ReplaceImpl.ReplaceM, Lean.Expr]]
[Lean.Elab.Term.Do.mkFreshJP',[Lean.Elab.Term.Do.mkFreshJP, Array.map, Prod.mk, Bool.true],[Lean.Elab.Term.TermElabM, Lean.Elab.Term.Do.JPDecl]]
[DoResultPR.return.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultPR.return, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Simp.Context.config,[],[Lean.Meta.Simp.Config]]
[Lean.Elab.Term.Do.hasExitPoint,[Lean.Elab.Term.Do.hasExitPointPred, Bool.true],[Bool]]
[Nat.lt_eq,[rfl],[Eq, Nat.lt, LT.lt]]
[Lean.Parser.Term.funSimpleBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.lookahead.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.simpleBinder.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Array.get!,[Array.getD, arbitrary],[]]
[Lean.matchConstInduct,[Lean.matchConst, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Unit.unit],[]]
[Sum.inr.injEq,[Eq.propIntro, Eq.refl, Sum.inr, Eq.symm, eq_of_heq, HEq.refl],[Eq, Sum.inr]]
[Lean.Meta.Simp.instMonadBacktrackSavedStateSimpM,[Lean.MonadBacktrack.mk, liftM, Lean.Meta.saveState, Lean.Meta.SavedState.restore],[Lean.MonadBacktrack, Lean.Meta.SavedState, Lean.Meta.Simp.SimpM]]
[Lean.Literal.natVal.inj,[],[Eq]]
[Lean.Parser.Term.doFor.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.Term.doForDecl.formatter, Bool.false, Lean.Parser.Term.doSeq.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.ParamInfo.isExplicit,[or, BEq.beq, Lean.Meta.ParamInfo.binderInfo, Lean.BinderInfo.default, Lean.BinderInfo.auxDecl],[Bool]]
[Lean.instReprStructureFieldInfo,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.StructureFieldInfo.fieldName, Std.Format.line, Lean.StructureFieldInfo.projFn, Lean.StructureFieldInfo.subobject?, Lean.StructureFieldInfo.binderInfo, Lean.StructureFieldInfo.inferMod],[Repr, Lean.StructureFieldInfo]]
[instXorUInt8,[Xor.mk, UInt8.xor],[Xor, UInt8]]
[Lean.Parser.Term.generalizingParam.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.trueVal.formatter, Lean.Parser.Term.falseVal.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Widget.instFromJsonTaggedText,[Lean.FromJson.mk],[Lean.FromJson, Lean.Widget.TaggedText]]
[Lean.Parser.Term.doSeqIndent,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.many1Indent, Lean.Parser.Term.doSeqItem],[Lean.Parser.Parser]]
[Lean.Parser.Command.constant,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.declId, Lean.Parser.Command.declSig, Lean.Parser.optional, Lean.Parser.Command.declValSimple],[Lean.Parser.Parser]]
[ExceptCpsT.runK,[],[]]
[List.length_repeat,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.length_nil, Nat.zero_eq, eq_true_of_decide, Eq.refl, Bool.true, Eq.mpr, congrFun, List.length_cons, List.repeat, Nat.succ, Nat.succ.injEq, List.length],[Eq, List.length, List.repeat]]
[Lean.mkLit,[Lean.Expr.lit, Lean.Expr.mkData, mixHash, OfNat.ofNat, Hashable.hash, Bool.false],[Lean.Expr]]
[Lean.Expr.isBVar,[Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[Tactic.Ring.HornerExpr.ibelow,[True, And],[]]
[Lean.Elab.Command.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Command.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.getMaxHeight,[Lean.Expr.foldConsts, OfNat.ofNat, Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, UInt32, Lean.Environment.find?, Lean.ReducibilityHints.opaque, Lean.ReducibilityHints.abbrev, Lean.DefinitionVal.hints, ite, GT.gt],[UInt32]]
[Lean.Parser.addToken,[Bind.bind, Lean.MonadEnv.getEnv, Functor.discard, Lean.ofExcept, ite, Eq, BEq.beq, Bool.true, MonadExcept.throw, Unit.unit, Except, String, Lean.Parser.TokenTable, Lean.Parser.Trie.find?, Pure.pure, Lean.Parser.Trie.insert, Lean.Parser.ParserExtension.State.tokens, Lean.ScopedEnvExtension.getState, Lean.Parser.parserExtension, Lean.ScopedEnvExtension.add, Lean.Parser.ParserExtension.Entry.token],[Lean.AttrM, Unit]]
[Nat.mul_lt_mul',[Nat.lt_of_le_of_lt, Nat.mul_le_mul_of_nonneg_right, Nat.mul_lt_mul_of_pos_left],[LT.lt, HMul.hMul]]
[Lean.Parser.Tactic.abstract,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.PrettyPrinter.Delaborator.unexpandCoe,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPCoercions, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Pure.pure, Lean.PrettyPrinter.Delaborator.isCoe, ite, Eq, not, Bool.true, Alternative.failure, PUnit.unit],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.Parser.Command.open,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.withPosition, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.openDecl],[Lean.Parser.Parser]]
[WellFounded.recursion,[WellFounded.apply],[]]
[List.head_eq_of_cons_eq,[],[Eq]]
[Lean.instFromJsonNat,[Lean.FromJson.mk, Lean.Json.getNat?],[Lean.FromJson, Nat]]
[Std.AssocList.noConfusionType,[],[]]
[Std.HashMapImp.reinsertAux.proof_1,[Subtype.property],[GT.gt, Array.size, Subtype.val, OfNat.ofNat]]
[Lean.Parser.Command.terminationSuffix.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.terminationBy.formatter, Lean.Parser.Command.decreasingBy.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.PatternElabException.noConfusionType,[],[]]
[Lean.IR.Checker.checkArg,[Lean.IR.Arg.irrelevant, Lean.IR.Checker.M, Unit, Lean.IR.Checker.checkVar, Pure.pure, Unit.unit],[Lean.IR.Checker.M, Unit]]
[Neg.neg,[],[]]
[Lean.Lsp.DocumentHighlightKind.text.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.DocumentHighlightKind.text, OfNat.ofNat]]
[Int.subNatNat_add_right,[],[Eq, Int.subNatNat, HAdd.hAdd, OfNat.ofNat, Int.negSucc]]
[exists_eq,[Exists.intro, rfl],[Exists, Eq]]
[Decidable.not_iff_not,[Eq.mpr, Eq.refl, Iff, Not, propext, iff_def, And, iff_def', and_congr, Decidable.not_imp_not],[Iff, Not]]
[List.Perm.swap',[],[List.Perm, List.cons]]
[Lean.Elab.Term.Do.ToTerm.Kind.nestedSBC.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.ToTerm.Kind.nestedSBC, OfNat.ofNat]]
[Std.PersistentArray.size,[],[Nat]]
[Lean.Meta.AbstractMVarsResult.paramNames,[],[Array, Lean.Name]]
[Lean.Parser.AliasValue.binary.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.AliasValue.binary, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.AliasValue.binary]]
[Lean.Elab.Term.LetRecToLift.shortDeclName,[],[Lean.Name]]
[Int.ofNat.inj,[],[Eq]]
[Lean.Elab.Term.applyAttributes,[Bind.bind, ForIn.forIn, PUnit.unit, Lean.MonadEnv.getEnv, Lean.Elab.Term.TermElabM, ForInStep, PUnit, Lean.getAttributeImpl, Lean.Elab.Attribute.name, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Pure.pure, ForInStep.yield, Unit.unit, liftM, Lean.AttributeImpl.add, Lean.Elab.Attribute.stx, Lean.Elab.Attribute.kind, ite, Eq, BEq.beq, Lean.AttributeImplCore.applicationTime, Lean.AttributeImpl.toAttributeImplCore, Bool.true, Option.none],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Parser.Tactic.tacticSorry,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Nat.not_lt_of_le,[Nat.not_le_of_gt],[Not, LT.lt]]
[Lean.Name.instReprName,[Repr.mk, Lean.Name.reprPrec],[Repr, Lean.Name]]
[Lean.Parser.ppDedent.parenthesizer,[],[Lean.PrettyPrinter.Parenthesizer]]
[«term_<_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Bool.or_false,[rfl, Eq.symm, Eq.refl],[Eq, or, Bool.false]]
[Lean.Elab.Structural.RecArgInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.quotSeq.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.Tactic.seq1.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.Match.Problem.vars,[],[List, Lean.Expr]]
[Subarray.anyM,[Array.anyM, Subarray.as, Subarray.start, Subarray.stop],[Bool]]
[IO.Error.otherError.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.tacticParser],[Lean.Parser.Parser]]
[Lean.Parser.Command.noncomputableSection,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.ident],[Lean.Parser.Parser]]
[Nat.sub_eq_zero_iff_le,[Iff.intro, Nat.le_of_sub_eq_zero, Nat.sub_eq_zero_of_le],[Iff, Eq, HSub.hSub, OfNat.ofNat, LE.le]]
[Lean.Elab.Term.PatternVar.localVar.inj,[],[Eq]]
[Prod.ext',[Iff.mpr, Prod.ext_iff, And.intro],[Eq]]
[cast_eq,[rfl],[Eq, cast]]
[Lean.Parser.Tactic.match.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.generalizingParam.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.Term.matchDiscr.formatter, Bool.false, Lean.Parser.Term.optType.formatter, Lean.Parser.Tactic.matchAlts.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.whnfReducibleLHS?,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getMVarType', Pure.pure, Lean.Expr.eq?, Option.none, Lean.Meta.MetaM, Option, Lean.MVarId, ite, Eq, bne, Bool.true, Lean.Meta.mkEq, Lean.Meta.replaceTargetDefEq, Option.some, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing],[Lean.Meta.MetaM, Option, Lean.MVarId]]
[Lean.throwErrorAt,[Lean.withRef, Lean.throwError],[]]
[Lean.Elab.Term.Quotation.HeadCheck.shape.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Quotation.HeadCheck.shape, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Quotation.HeadCheck.shape, And]]
[Lean.Elab.sortDeclLevelParams,[Unit.unit, Except, String, List, Lean.Name, List.find?, and, not, Array.contains, List.elem, MonadExcept.throw, HAppend.hAppend, ToString.toString, Pure.pure, Array.toList],[Except, String, List, Lean.Name]]
[Lean.Level.PP.Result.maxNode.injEq,[Eq.propIntro, Eq.refl, Lean.Level.PP.Result.maxNode, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Level.PP.Result.maxNode]]
[Lean.Parser.Tactic.generalizesArg,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[Lean.Server.FileWorker.EditableDocument.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.FileWorker.EditableDocument.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.FileWorker.EditableDocument.mk, And]]
[Lean.Elab.Term.Do.ToTerm.declToTerm,[Lean.withRef, Lean.MonadQuotation.withFreshMacroScope, ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.mkNode, Lean.mkNullNode, Lean.Syntax.getKind, Unit.unit, Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax, Lean.Elab.Term.Do.isDoExpr?, MonadReader.read, Lean.Elab.Term.Do.ToTerm.Context.m, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, liftM, Lean.Macro.throwErrorAt],[Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax]]
[Lean.MetavarContext.LevelMVarToParam.Context.alreadyUsedPred,[],[Bool]]
[Lean.Elab.Term.Do.instInhabitedCode,[Inhabited.mk, Lean.Elab.Term.Do.Code.action, arbitrary],[Inhabited, Lean.Elab.Term.Do.Code]]
[Lean.Elab.Structural.instInhabitedM,[Inhabited.mk, Lean.throwError, Lean.ToMessageData.toMessageData],[Inhabited, Lean.Elab.Structural.M]]
[Lean.Level.PP.Result.max,[Lean.Level.PP.Result.leaf, Lean.Level.PP.Result.num, Lean.Level.PP.Result.offset, Lean.Level.PP.Result.imaxNode, Lean.Level.PP.Result, Lean.Level.PP.Result.maxNode, List.cons, List.nil],[Lean.Level.PP.Result]]
[Lean.Meta.SynthInstance.TableEntry.waiters,[],[Array, Lean.Meta.SynthInstance.Waiter]]
[Lean.Meta.ByCasesSubgoal.noConfusionType,[],[]]
[Lean.getPPAnalyzeOmitMax,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.omitMax, Lean.Option.defValue],[Bool]]
[Lean.Meta.DefaultInstanceEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.DefaultInstanceEntry.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.DefaultInstanceEntry.mk, And]]
[Lean.Elab.Term.StructInst.instInhabitedFieldVal,[Inhabited.mk, Lean.Elab.Term.StructInst.FieldVal.term, arbitrary],[Inhabited, Lean.Elab.Term.StructInst.FieldVal]]
[Lean.Name.isAnonymous,[Unit.unit, Lean.Name.str, Lean.Name.num, Bool, Bool.true, Bool.false],[Bool]]
[List.mem_cons_eq,[rfl],[Eq, Mem.mem, List.cons, Or]]
[Lean.Lsp.instFromJsonLocationLink,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, Lean.Lsp.Range, Lean.Lsp.DocumentUri, Pure.pure, Lean.Lsp.LocationLink.mk],[Lean.FromJson, Lean.Lsp.LocationLink]]
[Lean.Server.FileWorker.Reference.range,[],[Lean.Lsp.Range]]
[Lean.Meta.injection,[Bind.bind, Lean.Meta.injectionCore, Unit.unit, Lean.Meta.MetaM, Lean.Meta.InjectionResult, Pure.pure, Lean.Meta.InjectionResult.solved, Lean.Meta.injectionIntro, Bool.true],[Lean.Meta.MetaM, Lean.Meta.InjectionResult]]
[Quotient.mk,[Quot.mk, Setoid.r],[Quotient]]
[Function.update_eq_iff,[Iff.trans, Function.funext_iff, Function.forall_update_iff, Eq],[Iff, Eq, Function.update, And]]
[instReprBool,[Repr.mk, Std.Format, Std.Format.text],[Repr, Bool]]
[Lean.PrettyPrinter.Parenthesizer.State.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Command.protected.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.DecLevelContext.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.DecLevelContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.DecLevelContext.mk]]
[Lean.LBool.toString,[Unit.unit, String],[String]]
[Lean.Compiler.neutralExpr,[Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.Expr]]
[Lean.IR.Expr.sproj.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Expr.sproj, HAdd.hAdd, OfNat.ofNat]]
[«term_<*_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Parser.ParserExtension.instInhabitedEntry,[Inhabited.mk, Lean.Parser.ParserExtension.Entry.token, arbitrary],[Inhabited, Lean.Parser.ParserExtension.Entry]]
[unsafeCast,[cast, unsafeCast.proof_1, PUnit],[]]
[Lean.Lsp.instFromJsonWorkspaceFolder,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, String, Pure.pure, Lean.Lsp.WorkspaceFolder.mk],[Lean.FromJson, Lean.Lsp.WorkspaceFolder]]
[Lean.Elab.Deriving.Ord.mkMutualBlock,[Bind.bind, ForIn.forIn, Lean.Elab.Deriving.Ord.mkAuxFunction, Pure.pure, PUnit.unit, ForInStep.yield, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Lean.Name.hasLtQuick,[LT.mk, Eq, Lean.Name.quickLt, Bool.true],[LT, Lean.Name]]
[Std.Rbcolor.black.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Std.Rbcolor.black, OfNat.ofNat]]
[instDecidableLt_1,[UInt8.decLt],[Decidable, LT.lt]]
[Lean.PrettyPrinter.Delaborator.delabAppImplicit,[Bind.bind, Lean.PrettyPrinter.Delaborator.getParamKinds, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPExplicit, ite, Eq, Bool.true, Array.any, not, Lean.PrettyPrinter.Delaborator.ParamKind.isRegularExplicit, OfNat.ofNat, Array.size, Alternative.failure, Pure.pure, PUnit.unit],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.LazyInitExtension.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.LazyInitExtension.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.LazyInitExtension.mk, And]]
[Lean.KVMap.Value.noConfusionType,[],[]]
[Lean.PersistentEnvExtension.getState,[Lean.PersistentEnvExtensionState.state, Lean.EnvExtension.getState, Lean.PersistentEnvExtension.toEnvExtension],[]]
[Lean.KernelException.declTypeMismatch.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.completion.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.DataValue.ofString.injEq,[Eq.propIntro, Eq.refl, Lean.DataValue.ofString, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.DataValue.ofString]]
[ForIn.forIn,[],[]]
[Lean.PrettyPrinter.Delaborator.delabProj,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Lean.PrettyPrinter.Delaborator.SubExpr.withProj, Lean.PrettyPrinter.Delaborator.delab, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, panicWithPosWithDecl, OfNat.ofNat],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.Server.FileWorker.Reference.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.FileWorker.Reference.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.State.letRecsToLift,[],[List, Lean.Elab.Term.LetRecToLift]]
[Lean.Syntax.isAnyAntiquot,[or, Lean.Syntax.isAntiquot, Lean.Syntax.isAntiquotSplice, Lean.Syntax.isAntiquotSuffixSplice, Lean.Syntax.isTokenAntiquot],[Bool]]
[Lean.Elab.Term.Do.Code.jmp.inj,[And.intro],[And, Eq]]
[Lean.Expr.isLambda,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[Monoid.toOne,[],[One]]
[Nat.coprime.symm,[Eq.trans, Nat.gcd_comm],[Nat.coprime]]
[Lean.DeclarationRange.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.DeclarationRange.mk, HAdd.hAdd, OfNat.ofNat]]
[MonadReader.read,[],[]]
[instSubNat,[Sub.mk, Nat.sub],[Sub, Nat]]
[Lean.Parser.ParserExtension.Entry.parser.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserExtension.Entry.parser, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.ParserExtension.Entry.parser, And]]
[Lean.PrettyPrinter.Parenthesizer.identEq.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.MessageData.instCoeArrayExprMessageData,[Coe.mk, Lean.MessageData.arrayExpr.toMessageData, OfNat.ofNat, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format],[Coe, Array, Lean.Expr, Lean.MessageData]]
[Lean.Parser.checkOutsideQuotFn,[ite, Eq, or, not, BEq.beq, Lean.Parser.ParserContext.quotDepth, OfNat.ofNat, Lean.Parser.ParserContext.suppressInsideQuot, Bool.true, Lean.Parser.ParserState.mkUnexpectedError, List.nil],[Lean.Parser.ParserFn]]
[Lean.Lsp.ServerInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.ServerInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[List.hasDecEq.proof_2,[],[List.noConfusionType, False, List.cons, List.nil]]
[Lean.Elab.Deriving.Hashable.mkMatch,[Bind.bind, Lean.Elab.Deriving.mkDiscrs, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.Elab.Deriving.Hashable.mkMatch.mkAlts],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Lean.Elab.Level.State.ngen,[],[Lean.NameGenerator]]
[Lean.Lsp.instFromJsonReferenceParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Lean.Lsp.ReferenceContext, Pure.pure, Lean.Lsp.ReferenceParams.mk, Lean.Lsp.TextDocumentPositionParams.mk],[Lean.FromJson, Lean.Lsp.ReferenceParams]]
[instDivFloat,[Div.mk, Float.div],[Div, Float]]
[Lean.Lsp.TextDocumentSyncKind.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.TextDocumentSyncKind.toCtorIdx],[]]
[Lean.Syntax.atom.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Syntax.atom, HAdd.hAdd, OfNat.ofNat]]
[Lean.NameSet.contains,[Std.RBMap.contains],[Bool]]
[UInt8.isLower,[and, Decidable.decide, GE.ge, OfNat.ofNat, LE.le],[Bool]]
[System.FilePath.components,[String.splitOn, System.FilePath.toString, System.FilePath.normalize, Bool.false, Char.toString, System.FilePath.pathSeparator],[List, String]]
[Lean.Server.Watchdog.ServerEvent.clientMsg.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.Watchdog.ServerEvent.clientMsg, HAdd.hAdd, OfNat.ofNat]]
[UInt32.instRingUInt32.proof_5,[UInt32.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, UInt32.val, congrFun, HAdd.hAdd, UInt32.neg_def, UInt32.add_def, UInt32.mk, Neg.neg, add_left_neg, UInt32.zero_def, eq_true_of_decide, Eq.refl, Bool.true],[Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat]]
[Nat.coprime.coprime_mul_right,[Nat.coprime.coprime_dvd_left, Nat.dvd_mul_right],[Nat.coprime]]
[Lean.Elab.Command.ProjectionInfo.inferMod,[],[Bool]]
[List.erasep_of_forall_not,[rfl, of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.erasep_cons_of_neg, Not, eq_false, Or.inl, eq_true_of_decide, Eq.refl, Bool.true, List.cons, List.forall_mem_of_forall_mem_cons, eq_self],[Eq, List.erasep]]
[IO.Error.mkUnsatisfiedConstraints,[IO.Error.unsatisfiedConstraints],[IO.Error]]
[Std.HashMapBucket,[Subtype, GT.gt, Array.size, OfNat.ofNat],[]]
[Lean.IR.UniqueIds.M,[StateT, Lean.IR.IndexSet, Id],[]]
[Std.AssocList.mapVal,[Unit.unit, Std.AssocList, Std.AssocList.nil, Std.AssocList.cons, PProd.fst],[Std.AssocList]]
[Lean.Meta.mkAuxLemma,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.EnvExtension.getState, Lean.Meta.auxLemmasExt, Unit.unit, Lean.Meta.MetaM, Lean.Name, Std.PersistentHashMap.find?, Lean.Meta.AuxLemmas.lemmas, ite, Eq, BEq.beq, Bool.true],[Lean.Meta.MetaM, Lean.Name]]
[StateRefT'.lift,[],[StateRefT']]
[Lean.Parser.ParserExtension.OLeanEntry.token.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.ParserExtension.OLeanEntry.token, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.ParserExtension.OLeanEntry.token]]
[Lean.Elab.RecKind.partial.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.RecKind.partial, OfNat.ofNat]]
[Subarray.as,[],[Array]]
[Lean.Parser.ParserState.shrinkStack,[Lean.Parser.ParserState.mk, Array.shrink, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.pos, Lean.Parser.ParserState.cache, Lean.Parser.ParserState.errorMsg],[Lean.Parser.ParserState]]
[Lean.Parser.Term.letRecDecls,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.sepBy1, Lean.Parser.Term.letRecDecl, Lean.Parser.symbol, Bool.false],[Lean.Parser.Parser]]
[Lean.Elab.Term.elabStateRefT,[Bind.bind, Lean.Elab.Term.elabType, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElab]]
[MonadFinally.tryFinally',[],[Prod]]
[right_commutative,[Eq],[]]
[Lean.Parser.Command.noncomputable.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.WF.TerminationStrategy.terminationBy,[],[Lean.Elab.WF.TerminationHint]]
[Lean.Expr.getAutoParamTactic?,[ite, Eq, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Bool.true, Option.some, Lean.Expr.appArg!, Option.none],[Option, Lean.Expr]]
[Function.surjective.exists₂,[Iff.trans, Function.surjective.exists, exists_congr],[Iff, Exists]]
[instToStreamSubarraySubarray,[ToStream.mk],[ToStream, Subarray]]
[Lean.mkProjEx,[Lean.mkProj],[Lean.Expr]]
[Lean.Parser.Tactic.tacticUnhygienic_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Nat.lcm_one_left,[],[Eq, Nat.lcm, OfNat.ofNat]]
[Lean.ReducibilityHints.regular.inj,[],[Eq]]
[UInt16.instSemiringUInt16.proof_3,[congrArg, UInt16.mk, Semiring.nsmul_zero', UInt16.val],[Eq, UInt16.mk, Semiring.nsmul, OfNat.ofNat, UInt16.val]]
[Lean.Widget.Lean.Widget.InteractiveTermGoal.instToJsonRpcEncodingPacket,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil],[Lean.ToJson]]
[Lean.IR.FnBody.case.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.strictImplicitBinder.formatter,[Lean.ppGroup.formatter, Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.strictImplicitLeftBracket.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.Parser.Term.binderType.formatter, Lean.Parser.Term.strictImplicitRightBracket.formatter],[Lean.PrettyPrinter.Formatter]]
[UInt32.instRingUInt32.proof_1,[congrArg, UInt32.mk, Ring.sub_eq_add_neg, UInt32.val],[Eq, UInt32.mk]]
[Lean.Lsp.PlainGoal.rendered,[],[String]]
[Lean.Elab.MonadMacroAdapter.setNextMacroScope,[],[Unit]]
[Lean.Meta.GeneralizeArg.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.EmitC.emitTailCall,[Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Lean.IR.EmitC.M, Unit, Bind.bind, MonadReader.read, ite, Eq, BEq.beq, Array.size, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw],[Lean.IR.EmitC.M, Unit]]
[mul_inv_self,[mul_right_inv],[Eq, HMul.hMul, Inv.inv, OfNat.ofNat]]
[Lean.Meta.NormNum.instLawfulOne.proof_1,[Lean.Meta.NormNum.LawfulOne.mk, rfl],[Lean.Meta.NormNum.LawfulOne]]
[or_comm,[Or.comm],[Iff, Or]]
[Lean.Meta.InstanceEntry.keys,[],[Array, Lean.Meta.DiscrTree.Key]]
[Std.Format.FlattenBehavior.fill.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Std.Format.FlattenBehavior.fill, OfNat.ofNat]]
[Lean.IR.AltCore.ctor.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.AltCore.ctor, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.AltCore.ctor, And]]
[Prod.Lex.decidable,[decidable_of_decidable_of_iff, inferInstance, Prod.Lex.decidable.proof_1],[DecidableRel, Prod.Lex]]
[stdSplit,[StdGen.mk, Prod, StdGen, Prod.mk],[Prod, StdGen]]
[Lean.Message.toString,[Bind.bind, Lean.MessageData.toString, Lean.Message.data, ite, Eq, BEq.beq, Lean.Message.caption, Bool.true, Pure.pure, PUnit.unit],[IO, String]]
[Nat.lt_of_succ_lt_succ,[Nat.le_of_succ_le_succ],[LT.lt]]
[Lean.Elab.Term.Do.ToTerm.Kind.isRegular,[Unit.unit, Lean.Elab.Term.Do.ToTerm.Kind.forIn, Lean.Elab.Term.Do.ToTerm.Kind.forInWithReturn, Lean.Elab.Term.Do.ToTerm.Kind.nestedBC, Lean.Elab.Term.Do.ToTerm.Kind.nestedPR, Lean.Elab.Term.Do.ToTerm.Kind.nestedSBC, Lean.Elab.Term.Do.ToTerm.Kind.nestedPRBC, Bool, Bool.true, Bool.false],[Bool]]
[Std.RBMap.empty,[Std.mkRBMap],[Std.RBMap]]
[And.rotate,[Eq.mpr, congrArg, Iff, And, Eq.trans, propext, and_comm, And.left_comm, Iff.rfl],[Iff, And]]
[Lean.Elab.Info.ofMacroExpansionInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Info.ofMacroExpansionInfo, HAdd.hAdd, OfNat.ofNat]]
[Lean.ExprStructMap,[Std.HashMap, Lean.ExprStructEq],[]]
[Lean.PrettyPrinter.Formatter.incQuotDepth.formatter,[],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.SynthInstance.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.instAlphaEqvArrayArg,[Lean.IR.AlphaEqv.mk, Lean.IR.args.alphaEqv],[Lean.IR.AlphaEqv, Array, Lean.IR.Arg]]
[or_self,[propext, Iff.intro, Or.inl],[Eq, Or]]
[IO.FS.DirEntry.fileName,[],[String]]
[Lean.Elab.pushInfoTree,[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, ite, Eq, Lean.Elab.InfoState.enabled, Bool.true, Lean.Elab.MonadInfoTree.modifyInfoState, Lean.Elab.InfoState.mk, Lean.Elab.InfoState.assignment, Lean.Elab.InfoState.trees, Std.PersistentArray.push, Pure.pure, PUnit.unit],[Unit]]
[Lean.Syntax.isNatLit?,[Option.none, Option, Nat, Lean.Syntax.isLit?, Lean.Syntax.decodeNatLitVal?, Lean.numLitKind],[Option, Nat]]
[Lean.Meta.SynthInstance.State.resumeStack,[],[Array, Prod, Lean.Meta.SynthInstance.ConsumerNode, Lean.Meta.SynthInstance.Answer]]
[Lean.CollectLevelParams.State.visitedLevel,[],[Lean.LevelSet]]
[instReprUSize,[Repr.mk, repr, USize.toNat],[Repr, USize]]
[Lean.Parser.quotedCharFn,[Lean.Parser.quotedCharCoreFn, Lean.Parser.isQuotableCharDefault],[Lean.Parser.ParserFn]]
[Array.insertionSort.traverse,[Unit.unit, Array, dite, LT.lt, Array.size, PProd.fst, Array.insertionSort.swapLoop, HAdd.hAdd, OfNat.ofNat],[Array]]
[Lean.Xml.Parser.Reference,[HOrElse.hOrElse, Lean.Xml.Parser.EntityRef, Functor.map, Option.some, Lean.Xml.Parser.CharRef],[Lean.Parsec, Option, Lean.Xml.Parser.LeanChar]]
[IO.FileRight.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FileRight.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.FileRight.mk, And]]
[Lean.Meta.reduceBinNatPred,[Lean.Meta.withNatValue, Pure.pure, Option.some, Lean.ToExpr.toExpr],[Lean.Meta.MetaM, Option, Lean.Expr]]
[Std.RBNode.balance1,[Std.RBNode.leaf, Std.RBNode.node, Std.Rbcolor.black, Std.Rbcolor.red, Std.RBNode],[Std.RBNode]]
[Std.Format.nest.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.Format.nest, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.Format.nest, And]]
[Lean.Lsp.Ipc.IpcM,[ReaderT, IO.Process.Child, Lean.Lsp.Ipc.ipcStdioConfig, IO],[]]
[Lean.Elab.Tactic.Conv.evalRewrite,[Bind.bind, liftM, Lean.Elab.Tactic.elabRewriteConfig, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.withRWRulesSeq, Lean.Elab.Term.withSynthesize, Lean.Elab.Tactic.withMainContext, Lean.Elab.Tactic.elabTerm, Option.none, Bool.true, Lean.Elab.Tactic.getMainGoal, Lean.Elab.Tactic.Conv.getLhs, Lean.Meta.rewrite, Lean.Occurrences.all, Lean.Elab.Tactic.Conv.updateLhs, Lean.Meta.RewriteResult.eNew, Lean.Meta.RewriteResult.eqProof, Lean.Elab.Tactic.replaceMainGoal, List.cons, Lean.Meta.RewriteResult.mvarIds, Bool.false],[Lean.Elab.Tactic.Tactic]]
[not,[Unit.unit, Bool, Bool.false, Bool.true],[Bool]]
[Fin.size_positive',[Fin.size_positive, Inhabited.default],[LT.lt, OfNat.ofNat]]
[Lean.Widget.instInhabitedInfoPopup,[Inhabited.mk, Lean.Widget.InfoPopup.mk, arbitrary],[Inhabited, Lean.Widget.InfoPopup]]
[Squash.lift.proof_1,[Subsingleton.elim],[Eq]]
[Lean.IR.Expr.box.inj,[And.intro],[And, Eq]]
[Lean.Meta.Simp.Config.beta,[],[Bool]]
[Function.surjective.of_comp_iff,[Iff.intro, Function.surjective.of_comp, Function.surjective.comp],[Iff, Function.surjective, Function.comp]]
[Lean.Elab.Term.Context.currMacroScope,[],[Lean.MacroScope]]
[Array.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Array.mk, HAdd.hAdd, OfNat.ofNat]]
[System.FilePath.pathSeparator,[ite, Eq, System.Platform.isWindows, Bool.true, Char.ofNat],[Char]]
[Lean.Lsp.ServerCapabilities.completionProvider?,[],[Option, Lean.Lsp.CompletionOptions]]
[Lean.Elab.Term.saveState,[Bind.bind, liftM, Lean.Meta.saveState, MonadState.get, Pure.pure, Lean.Elab.Term.SavedState.mk],[Lean.Elab.Term.TermElabM, Lean.Elab.Term.SavedState]]
[Lean.IR.Expr.pap.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Expr.pap, HAdd.hAdd, OfNat.ofNat]]
[Lean.MessageLog.forM,[Std.PersistentArray.forM, Lean.MessageLog.msgs],[Unit]]
[Lean.Meta.Match.Example.ibelow,[True, And],[]]
[Lean.Elab.Term.Quotation.Precheck.Context.quotLCtx,[],[Lean.NameSet]]
[Tactic.Find.«tactic#find_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Term.CollectPatternVars.M,[StateRefT', IO.RealWorld, Lean.Elab.Term.CollectPatternVars.State, Lean.Elab.Term.TermElabM],[]]
[Lean.Elab.Term.CollectPatternVars.Context.explicit,[],[Bool]]
[Function.partial_inv,[dite, Exists, Eq, Option.some, Classical.choose, Option.none],[Option]]
[Classical.em,[],[Or, Not]]
[Nat.lt_of_le_of_lt,[Nat.le_trans, Nat.succ_le_succ],[LT.lt]]
[Tactic.Find.«command#find_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Std.HashMap.contains,[Bool, Std.HashMapImp.contains],[Bool]]
[Lean.Meta.SizeOfSpecNested.Context.sizeOfFns,[],[Array, Lean.Name]]
[Lean.Meta.SavedState.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.DefKind.isExample,[Lean.Elab.DefKind.def, Lean.Elab.DefKind.theorem, Unit.unit, Lean.Elab.DefKind.opaque, Lean.Elab.DefKind.abbrev, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Parser.Tactic.cancelDenoms,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.sanitizeSyntax,[Bind.bind, MonadState.get, ite, Eq, Lean.getSanitizeNames, Lean.NameSanitizerState.options, Bool.true, Pure.pure],[StateM, Lean.NameSanitizerState, Lean.Syntax]]
[Lean.Parser.Command.whereStructInst.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1Indent.formatter, Lean.Parser.group.formatter, Lean.Parser.Command.whereStructField.formatter, Lean.Parser.optional.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Command.libraryNote,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.IR.ExplicitBoxing.mkCast,[Bind.bind, ite, Eq, not, Lean.IR.IRType.isScalar, Bool.true, Pure.pure, Option.none, Lean.IR.IRType.float, Unit.unit, Lean.IR.IRType.uint32, Lean.IR.IRType.uint64, Lean.IR.IRType.usize, Lean.IR.IRType.irrelevant, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.struct, Lean.IR.IRType.union, Lean.IR.ExplicitBoxing.M, Option, Lean.IR.Expr, Lean.IR.ExplicitBoxing.getLocalContext, Lean.IR.LocalContext.getValue, Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Option.some, BEq.beq, Array.size, OfNat.ofNat, MonadReader.read, MonadState.get, Std.AssocList.find?, Lean.IR.ExplicitBoxing.BoxingState.auxDeclCache, modify, Lean.IR.ExplicitBoxing.BoxingState.mk, Lean.IR.ExplicitBoxing.BoxingState.nextIdx, Array.push, Lean.IR.ExplicitBoxing.BoxingState.auxDecls, Std.AssocList.cons, HAdd.hAdd, Lean.IR.ExplicitBoxing.BoxingState.nextAuxId],[Lean.IR.ExplicitBoxing.M, Lean.IR.Expr]]
[Lean.Lsp.CancelParams.noConfusionType,[],[]]
[Lean.Core.instMonadEnvCoreM,[Lean.MonadEnv.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Core.State.env, modify, Lean.Core.State.mk, Lean.Core.State.nextMacroScope, Lean.Core.State.ngen, Lean.Core.State.traceState],[Lean.MonadEnv, Lean.Core.CoreM]]
[Lean.Expr.lam.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.lam, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Expr.lam, And]]
[Std.HashMapImp.insert.proof_1,[Subtype.property],[GT.gt, Array.size, Subtype.val, OfNat.ofNat]]
[Lean.Meta.instInhabitedInstanceEntry,[Inhabited.mk, Lean.Meta.InstanceEntry.mk, arbitrary],[Inhabited, Lean.Meta.InstanceEntry]]
[Lean.mkForall,[Lean.Expr.forallE, Lean.Expr.mkDataForBinder, mixHash, UInt8.toUInt64, Hashable.hash, max, Lean.Expr.looseBVarRange, HSub.hSub, OfNat.ofNat, or, Lean.Expr.hasFVar, Lean.Expr.hasExprMVar, Lean.Expr.hasLevelMVar, Lean.Expr.hasLevelParam],[Lean.Expr]]
[Lean.Parser.Term.doReassignArrow,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.notFollowedByRedefinedTermToken, Lean.Parser.withPosition, HOrElse.hOrElse, Lean.Parser.Term.doIdDecl, Lean.Parser.Term.doPatDecl],[Lean.Parser.Parser]]
[Lean.Level.PP.Result.below,[PUnit, PProd],[]]
[Lean.Elab.Term.Do.getPatternVarsEx,[HOrElse.hOrElse, Functor.map, Lean.Elab.Term.getPatternVarNames, Lean.Elab.Term.getPatternVars, Array.map, Lean.Syntax.getId, Lean.Elab.Term.Quotation.getPatternVars],[Lean.Elab.Term.TermElabM, Array, Lean.Name]]
[Lean.Widget.instInhabitedEmbedFmt,[Inhabited.mk, arbitrary],[Inhabited]]
[Lean.Meta.CaseValueSubgoal.subst,[],[Lean.Meta.FVarSubst]]
[Lean.Elab.Deriving.DecEq.mkDecEqCmds,[Bind.bind, Lean.Elab.Deriving.mkContext, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Lean.Elab.Deriving.DecEq.mkAuxFunction, Lean.Elab.Deriving.mkInstanceCmds, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Bool.false, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElabM, Array, Lean.Syntax]]
[Lean.Meta.IndPredBelow.proveBrecOn.applyIH,[Bind.bind, Array.findSomeM?, Lean.Meta.IndPredBelow.BrecOnVariables.indHyps, MonadExcept.tryCatch, Lean.Meta.apply, Lean.mkFVar, Pure.pure, Option.some, Option.none, Unit.unit, Lean.Meta.MetaM, List, Lean.MVarId, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MessageData.ofGoal],[Lean.Meta.MetaM, List, Lean.MVarId]]
[Lean.Parser.Tactic.ext,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Char.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Char.mk, HAdd.hAdd, OfNat.ofNat]]
[UInt64.lor,[UInt64.mk, Fin.lor, UInt64.val],[UInt64]]
[Lean.Meta.instInhabitedCongrLemmas,[Inhabited.mk, Lean.Meta.CongrLemmas.mk, arbitrary],[Inhabited, Lean.Meta.CongrLemmas]]
[Lean.Parser.Tactic.simpErase,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[unexpandPSigma,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Lean.Level.find?,[Lean.Level.find?.visit],[Option, Lean.Level]]
[Lean.getClosedTermName?,[Std.PersistentHashMap.find?, Lean.ClosedTermCache.map, Lean.EnvExtension.getState, Lean.closedTermCacheExt],[Option, Lean.Name]]
[USize.instRingUSize,[Ring.mk, USize.instRingUSize.proof_1, USize.mk, Ring.gsmul, USize.val, USize.instRingUSize.proof_2, USize.instRingUSize.proof_3, USize.instRingUSize.proof_4, USize.instRingUSize.proof_5],[Ring, USize]]
[pow_add,[of_eq_true, Eq.trans, congr, congrArg, Eq, HPow.hPow, HAdd.hAdd, Nat.zero_eq, Nat.add_zero, HMul.hMul, pow_zero, mul_one, eq_self, Eq.mpr, Eq.refl, Nat.succ, Nat.add_succ, pow_succ', Eq.symm, mul_assoc, pow_mul_comm, rfl],[Eq, HPow.hPow, HAdd.hAdd, HMul.hMul]]
[Lean.Expr.ReplaceImpl.replaceUnsafe,[StateT.run', Lean.Expr.ReplaceImpl.replaceUnsafeM, Lean.Expr.ReplaceImpl.cacheSize, Lean.Expr.ReplaceImpl.initCache],[Lean.Expr]]
[Lean.Lsp.DocumentSymbolResult.mk.inj,[],[Eq]]
[Lean.CollectMVars.State.result,[],[Array, Lean.MVarId]]
[Lean.Elab.Term.elabCharLit,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Syntax.isCharLit?, Pure.pure, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.mkRawNatLit, Char.toNat, Lean.Elab.throwIllFormedSyntax],[Lean.Elab.Term.TermElab]]
[Lean.PrettyPrinter.Delaborator.SubExpr.getExpr,[Bind.bind, readThe, Lean.PrettyPrinter.Delaborator.SubExpr, Pure.pure, Lean.PrettyPrinter.Delaborator.SubExpr.expr],[Lean.Expr]]
[ne_of_lt,[absurd, lt_irrefl],[Ne]]
[Lean.CollectMVars.State.visitedExpr,[],[Lean.ExprSet]]
[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer,[Bind.bind, Lean.MonadEnv.getEnv, List.nil, Lean.PrettyPrinter.ParenthesizerM, Unit, Lean.KeyedDeclsAttribute.getValues, Lean.PrettyPrinter.categoryParenthesizerAttribute, Lean.PrettyPrinter.Parenthesizer.parenthesizeCategoryCore],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Command.openSimple.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.many1.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Sub.sub,[],[]]
[Lean.Meta.InjectionResult.subgoal.inj,[And.intro],[And, Eq]]
[Lean.Lsp.instToJsonCancelParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.CancelParams.id, List.nil],[Lean.ToJson, Lean.Lsp.CancelParams]]
[Lean.Parser.Tactic.change,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Elab.Command.CtorView.inferMod,[],[Bool]]
[Lean.Parser.ParserExtension.Entry.category.inj,[And.intro],[And, Eq]]
[Lean.Meta.NormNum.instSemiringNat,[inferInstance],[Semiring, Nat]]
[Lean.IR.Sorry.State.localSorryMap,[],[Lean.NameMap, Lean.Name]]
[Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.noConfusionType,[],[]]
[Subrelation.wf,[Subrelation.wf.proof_1],[WellFounded]]
[Lean.KVMap.getNat,[Option.none, Option.some, Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofName, Lean.DataValue.ofInt, Nat, Lean.KVMap.find],[Nat]]
[Lean.Meta.RecursorInfo.recursorName,[],[Lean.Name]]
[Lean.Elab.Tactic.evalApplyLikeTactic,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.elabTermForApply, Bool.true, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Bool.false, Lean.Elab.Tactic.replaceMainGoal],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.Elab.Tactic.Simp.DischargeWrapper.custom.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Tactic.Simp.DischargeWrapper.custom, HAdd.hAdd, OfNat.ofNat]]
[Array.size,[List.length, Array.data],[Nat]]
[Lean.Macro.State.macroScope,[],[Lean.MacroScope]]
[Lean.Elab.WF.TerminationHint.many.inj,[],[Eq]]
[Lean.Elab.Term.BinOp.elabBinCalc,[Bind.bind, ForIn.forIn, MProd.mk, Lean.Elab.Term.elabType, Lean.Syntax.getOp, OfNat.ofNat, liftM, ite, LT.lt, Lean.Expr.getAppNumArgs, Pure.pure, Option.none, Option.some, Prod.mk, Lean.Expr.appFn!, Lean.Expr.appArg!, Lean.Elab.Term.TermElabM, ForInStep, MProd, Array, Lean.Expr, GT.gt, Array.size, Array.back, Lean.Meta.isDefEqGuarded, Eq, Bool.true, PUnit.unit, Lean.Meta.inferType, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, panicWithPosWithDecl, Lean.indentExpr, ForInStep.yield, Lean.Meta.instantiateMVars, Array.getOp, Lean.Meta.getLevel, Lean.Meta.mkArrow, Lean.mkSort, Lean.levelZero, Lean.Meta.mkFreshExprMVar, Lean.MetavarKind.natural, Lean.Name.anonymous, Lean.Meta.trySynthInstance, Lean.LOption.none, Lean.LOption.undef, Option.isSome, Lean.Elab.Term.ensureHasType],[Lean.Elab.Term.TermElab]]
[Lean.IR.ExplicitRC.Context.decls,[],[Array, Lean.IR.Decl]]
[Lean.Elab.CommandInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.CommandInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[UInt16.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, UInt16.mk, HAdd.hAdd, OfNat.ofNat]]
[StateT.run_set,[rfl],[Eq, StateT.run, MonadStateOf.set, Pure.pure, Prod.mk, PUnit.unit]]
[Lean.Xml.Content.ibelow,[And, True],[]]
[Thunk.bind,[Thunk.mk, Thunk.get],[Thunk]]
[Lean.Meta.SavedState.core,[],[Lean.Core.State]]
[Lean.MetavarKind.natural.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.MetavarKind.natural, OfNat.ofNat]]
[ofNat_one,[rfl],[Eq, Numeric.ofNat, OfNat.ofNat]]
[Lean.IR.IndexRenaming,[Std.RBMap, Lean.IR.Index, Ord.compare],[]]
[Lean.Meta.mkSimpAttr,[Lean.registerBuiltinAttribute, Lean.AttributeImpl.mk, Lean.AttributeImplCore.mk, Functor.discard, Lean.Meta.MetaM.run, Lean.Meta.Context.mk, Lean.Meta.State.mk, Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.ScopedEnvExtension.getState, Lean.Meta.SimpLemmas.erase, Lean.MonadEnv.modifyEnv, Lean.ScopedEnvExtension.modifyState],[IO, Unit]]
[Lean.Parser.Term.stateRefT.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.macroArg.parenthesizer, Lean.Parser.Term.macroLastArg.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[ByteArray.get!,[UInt8, Array.get!],[UInt8]]
[List.length_cons,[rfl],[Eq, List.length, List.cons, Nat.succ]]
[Lean.IR.EmitC.declareParams,[Array.forM, Lean.IR.EmitC.declareVar, Lean.IR.Param.x, Lean.IR.Param.ty, OfNat.ofNat, Array.size],[Lean.IR.EmitC.M, Unit]]
[Subsingleton.helim.proof_1,[heq_of_eq, Subsingleton.elim],[HEq]]
[Function.comp.assoc,[rfl],[Eq, Function.comp]]
[Lean.FileMap.utf8PosToLspPos,[Lean.FileMap.leanPosToLspPos, Lean.FileMap.toPosition],[Lean.Lsp.Position]]
[Lean.JsonRpc.ErrorCode.contentModified.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.JsonRpc.ErrorCode.contentModified, OfNat.ofNat]]
[Lean.Lsp.instFileSourcePlainGoalParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.PlainGoalParams.toTextDocumentPositionParams],[Lean.Lsp.FileSource, Lean.Lsp.PlainGoalParams]]
[CoeDep.noConfusionType,[],[]]
[Lean.IR.mkCase,[Lean.IR.FnBody.case, Lean.IR.IRType.object],[Lean.IR.FnBody]]
[Lean.PrettyPrinter.Delaborator.ParamKind.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.ParamKind.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PrettyPrinter.Delaborator.ParamKind.mk, And]]
[List.singleton_disjoint,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, forall_congr, implies_congr, propext, List.mem_singleton, Eq.refl, False, forall_eq, Not, Mem.mem, iff_self],[Iff, List.disjoint, List.cons, List.nil, Not, Mem.mem]]
[Std.Format.MonadPrettyFormat.pushOutput,[],[Unit]]
[Lean.Position.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Tactic.deltaLocalDecl,[Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Meta.getLocalDecl, Lean.Meta.deltaExpand, Lean.LocalDecl.type, BEq.beq, ite, Eq, Bool.true, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.LocalDecl.userName, Lean.Syntax.missing, Pure.pure, PUnit.unit],[Lean.Elab.Tactic.TacticM, Unit]]
[Function.bicompr,[],[]]
[Lean.PrettyPrinter.Delaborator.topDownAnalyze,[Bind.bind, MonadState.get, Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Elab.Term.setElabConfig, Lean.Meta.Context.config, Lean.Meta.Context.lctx, Lean.Meta.Context.localInstances, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth, tryFinally, MonadExcept.tryCatch, Lean.MonadOptions.getOptions, StateRefT'.run', Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk, Lean.PrettyPrinter.Delaborator.SubExpr.mkRoot, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.mk, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, MonadStateOf.set],[Lean.Meta.MetaM, Lean.PrettyPrinter.Delaborator.OptionsPerPos]]
[Function.update_apply,[],[Eq, Function.update, ite]]
[Lean.Server.Watchdog.ServerContext.fileWorkersRef,[],[IO.Ref, Lean.Server.Watchdog.FileWorkerMap]]
[Lean.Elab.Term.LetRecToLift.fvarId,[],[Lean.FVarId]]
[Lean.Elab.Term.Quotation.PrecheckM,[ReaderT, Lean.Elab.Term.Quotation.Precheck.Context, Lean.Elab.Term.TermElabM],[]]
[Lean.Parser.Tactic.rwSearch?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.Parser.Tactic.rwRuleSeq],[Lean.ParserDescr]]
[List.map_eq_mapTR,[funext, of_eq_true, Eq.trans, congrArg, Eq, List.map, List.mapTRAux_eq, List.nil, congrFun, HAppend.hAppend, List.reverse_nil, List.nil_append, eq_self],[Eq, List.map, List.mapTR]]
[Mathlib.Tactic.Lint.Linter.isFast,[],[Bool]]
[Lean.LocalContext.get!,[Unit.unit, Lean.LocalDecl, Lean.LocalContext.find?, panicWithPosWithDecl, OfNat.ofNat],[Lean.LocalDecl]]
[Lean.Widget.InteractiveTermGoal.range,[],[Lean.Lsp.Range]]
[Lean.PrettyPrinter.Delaborator.delabLetE,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Lean.PrettyPrinter.Delaborator.getUnusedName, Lean.PrettyPrinter.Delaborator.SubExpr.descend, OfNat.ofNat, Lean.PrettyPrinter.Delaborator.delab, Lean.Meta.withLetDecl, orM, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPLetVarTypes, Lean.getPPAnalysisLetVarType, ite, Eq, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Lean.mkIdent, List.nil, panicWithPosWithDecl],[Lean.PrettyPrinter.Delaborator.Delab]]
[Decidable.not_and_iff_or_not,[Iff.intro, Decidable.isFalse, Decidable.isTrue, Or, Not, absurd, And.intro, Or.inr, Or.inl, False],[Iff, Not, And, Or]]
[Bool.and_false,[rfl, Eq.symm, Eq.refl],[Eq, and, Bool.false]]
[Nat.succ_sub_one,[rfl],[Eq, HSub.hSub, Nat.succ, OfNat.ofNat]]
[Lean.Json.getObjValD,[Option.getD, Except.toOption, Lean.Json.getObjVal?, Lean.Json.null],[Lean.Json]]
[Lean.Lsp.instFromJsonHover,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.MarkupContent, Option, Lean.Lsp.Range, Pure.pure, Lean.Lsp.Hover.mk],[Lean.FromJson, Lean.Lsp.Hover]]
[Lean.Elab.Term.ElabAppArgs.State.fType,[],[Lean.Expr]]
[Lean.PrettyPrinter.Delaborator.isIdLike,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[pow_succ,[Eq.mpr, Eq.refl, Eq, HPow.hPow, Nat.succ, HMul.hMul, pow_succ', pow_mul_comm, rfl],[Eq, HPow.hPow, Nat.succ, HMul.hMul]]
[Lean.Parser.Term.doAssert.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Function.right_inverse,[Function.left_inverse],[]]
[Lean.PersistentEnvExtensionDescr.exportEntriesFn,[],[Array]]
[MonadExcept.instOrElse,[OrElse.mk, MonadExcept.orElse],[OrElse]]
[AndThen.andThen,[],[]]
[Lean.PrettyPrinter.Formatter.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PrettyPrinter.Formatter.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.AliasState,[Lean.SMap, Lean.Name, List],[]]
[Lean.instBEqInternalExceptionId,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.InternalExceptionId]]
[Lean.Meta.Hypothesis.type,[],[Lean.Expr]]
[Lean.Parser.TokenCacheEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.TokenCacheEntry.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.LeadingIdentBehavior.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Parser.parserOfStackFnUnsafe,[ite, LT.lt, Array.size, HAdd.hAdd, OfNat.ofNat, Lean.Parser.ParserState.mkUnexpectedError, List.nil, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Parser.ParserState, Array.get!, HSub.hSub, Prod.mk, List.cons, Lean.Parser.ParserContext.resolveName, Eq, and, not, Lean.Parser.ParserState.hasError, bne, Lean.Parser.ParserState.stackSize, Bool.true, HAppend.hAppend, ToString.toString],[Lean.Parser.ParserFn]]
[instLENat,[LE.mk, Nat.le],[LE, Nat]]
[IO.FS.Stream.Buffer.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FS.Stream.Buffer.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.FS.Stream.Buffer.mk, And]]
[instAndOpUInt64,[AndOp.mk, UInt64.land],[AndOp, UInt64]]
[Fin.instAndOpFin,[AndOp.mk, Fin.land],[AndOp, Fin]]
[Lean.Elab.Term.Quotation.HeadInfo.doMatch,[],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Lean.Syntax.TopDown.noConfusionType,[],[]]
[Lean.StructureDescr.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.StructureDescr.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.StructureDescr.mk, And]]
[Lean.Elab.Term.Do.ToCodeBlock.Context.mutableVars,[],[Lean.NameSet]]
[Lean.Parser.Term.haveEqnsDecl.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.haveIdLhs.parenthesizer, Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.expandWhereDecls,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Unit.unit, Lean.MacroM, Lean.Syntax, OptionM.run, Array.sequenceMap, Lean.Syntax.getArgs, cond, Lean.Syntax.isNone, Lean.Syntax.matchesNull, OfNat.ofNat, Option.none, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.Syntax.SepArray.elemsAndSeps, Lean.Syntax.SepArray.ofElems, Lean.Macro.throwUnsupported],[Lean.MacroM, Lean.Syntax]]
[Lean.Lsp.LocationLink.targetUri,[],[Lean.Lsp.DocumentUri]]
[Lean.Meta.Cases.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Cases.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Cases.Context.mk, And]]
[Int.negSucc.inj,[],[Eq]]
[Lean.Server.Watchdog.ServerContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.Watchdog.ServerContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.Watchdog.ServerContext.mk, And]]
[Lean.Meta.SynthInstance.MkTableKey.State.noConfusionType,[],[]]
[Std.AssocList.nil.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Std.AssocList.nil, OfNat.ofNat]]
[Lean.Widget.MsgEmbed.goal.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Widget.MsgEmbed.goal, HAdd.hAdd, OfNat.ofNat]]
[le_max_right,[dite, LT.lt, Eq.mpr, congrArg, LE.le, if_pos, le_of_lt, of_eq_true, Eq.trans, if_neg, eq_true, le_refl],[LE.le, max]]
[Std.PShareCommonM.run,[Std.PShareCommonT.run],[]]
[Lean.Elab.toAttributeKind,[ite, Eq, Lean.Syntax.isNone, Lean.Syntax.getOp, OfNat.ofNat, Bool.true, Pure.pure, Lean.AttributeKind.global, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.Macro.getCurrNamespace, Lean.Name.isAnonymous, Lean.MonadRef.getRef, MonadExcept.throw, Lean.Macro.Exception.error, PUnit.unit, Lean.AttributeKind.local],[Lean.MacroM, Lean.AttributeKind]]
[Lean.Parser.ParserState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.ParserState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.syntaxAbbrev,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.docComment, Lean.Parser.symbol, Lean.Parser.ident, Lean.Parser.many1, Lean.Parser.syntaxParser],[Lean.Parser.Parser]]
[Function.left_inverse.injective,[rfl],[Function.injective]]
[Lean.Parser.syntaxParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Parser.Parser]]
[Fin.instOrOpFin,[OrOp.mk, Fin.lor],[OrOp, Fin]]
[Lean.Elab.Structural.RecArgInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Structural.RecArgInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Structural.RecArgInfo.mk, And]]
[Lean.Parser.Tactic.typeCheck,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Fin.sub,[Fin, Fin.mk, HMod.hMod, HAdd.hAdd, HSub.hSub, Fin.sub.proof_1],[Fin]]
[IO.Process.StdioConfig.stdin,[],[IO.Process.Stdio]]
[Lean.SSet,[Lean.SMap, Unit],[]]
[EStateM.instInhabitedResult,[Inhabited.mk, EStateM.Result.error, arbitrary],[Inhabited, EStateM.Result]]
[Lean.FVarId.name,[],[Lean.Name]]
[UInt8.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd],[UInt8]]
[String.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, String.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.app,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.leadPrec, Lean.Parser.maxPrec, Lean.Parser.many1, Lean.Parser.Term.argument],[Lean.Parser.TrailingParser]]
[Nat.dvd_lcm_left,[Exists.intro, HDiv.hDiv, Nat.gcd, Eq.mpr, Eq.refl, Eq, Nat.lcm, HMul.hMul, Eq.symm, Nat.mul_div_assoc, Nat.gcd_dvd_right, rfl],[Dvd.dvd, Nat.lcm]]
[Lean.Lsp.DocumentHighlightParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.DocumentHighlightParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.mkRecOn,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.MonadEnv.modifyEnv, Lean.throwKernelException, Lean.mkRecOnImp],[Unit]]
[Lean.IR.LogEntry.instToFormatLogEntry,[Std.ToFormat.mk, Lean.IR.LogEntry.fmt],[Std.ToFormat, Lean.IR.LogEntry]]
[Lean.Meta.ParamInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Command.StructFieldKind.copiedField.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Command.StructFieldKind.copiedField, OfNat.ofNat]]
[Lean.Server.FileWorker.SemanticTokensContext.mk.inj,[And.intro],[And, Eq]]
[StateRefT',[ReaderT, ST.Ref],[]]
[Lean.getConstInfoInduct,[Bind.bind, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.InductiveVal, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkConst, List.nil],[Lean.InductiveVal]]
[System.Platform.isEmscripten,[System.Platform.getIsEmscripten, Unit.unit],[Bool]]
[Subarray.instForInSubarray,[ForIn.mk, Subarray.forIn],[ForIn, Subarray]]
[Lean.Elab.DerivingClassView.noConfusionType,[],[]]
[Lean.PrettyPrinter.Parenthesizer.visitArgs,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, GT.gt, Array.size, Lean.Syntax.getArgs, OfNat.ofNat, SeqLeft.seqLeft, SeqRight.seqRight, Lean.Syntax.MonadTraverser.goDown, HSub.hSub, Lean.Syntax.MonadTraverser.goUp, Pure.pure, PUnit.unit],[Lean.PrettyPrinter.ParenthesizerM, Unit]]
[Lean.Meta.SizeOfSpecNested.Context.noConfusionType,[],[]]
[ByteArray.instForInByteArrayUInt8,[ForIn.mk, ByteArray.forIn],[ForIn, ByteArray, UInt8]]
[List.erasep_nil,[rfl],[Eq, List.erasep, List.nil]]
[Lean.SimplePersistentEnvExtension.getEntries,[Prod.fst, Lean.PersistentEnvExtension.getState],[List]]
[Lean.Meta.ElimInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.ElimInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.ElimInfo.mk, And]]
[Lean.TransformStep.done.inj,[],[Eq]]
[Lean.Elab.Command.instMonadCommandElabM,[Monad.mk],[Monad, Lean.Elab.Command.CommandElabM]]
[Lean.getPPCoercions,[Lean.KVMap.get, Lean.Option.name, Lean.pp.coercions, not, Lean.getPPAll],[Bool]]
[Lean.Parser.Error.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.Error.mk, HAdd.hAdd, OfNat.ofNat]]
[UInt8.instSemiringUInt8.proof_13,[UInt8.eq_of_val_eq, Eq.mpr, congrArg, Eq, Fin.ofNat', HAdd.hAdd, OfNat.ofNat, Fin.size_positive', UInt8.val, Eq.trans, UInt8.mk, UInt8.one_def, UInt8.add_def],[Eq, Numeric.ofNat, HAdd.hAdd, OfNat.ofNat]]
[Bool.and_self,[rfl, Eq.symm, Eq.refl],[Eq, and]]
[Std.RBNode.erase,[Std.RBNode.setBlack],[Std.RBNode]]
[Lean.Unhygienic.instMonadQuotationUnhygienic,[Lean.MonadQuotation.mk, Bind.bind, MonadReader.read, Pure.pure, Lean.Unhygienic.Context.scope, Lean.Name.mkStr, Lean.Name.anonymous, MonadState.modifyGet, Prod.mk, HAdd.hAdd, OfNat.ofNat, MonadWithReader.withReader, Lean.Unhygienic.Context.mk, Lean.Unhygienic.Context.ref],[Lean.MonadQuotation, Lean.Unhygienic]]
[Lean.Meta.RecursorInfo.produceMotive,[],[List, Bool]]
[Lean.Lsp.SemanticTokenType.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.SemanticTokenType.toCtorIdx],[]]
[Lean.Meta.evalNat.isNatProjInst,[or, and, BEq.beq, OfNat.ofNat, Lean.Name.mkStr, Lean.Name.anonymous],[Bool]]
[Char.isAlphanum,[or, Char.isAlpha, Char.isDigit],[Bool]]
[Lean.Lsp.TypeDefinitionParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.TypeDefinitionParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.DiagnosticRelatedInformation.message,[],[String]]
[Lean.SearchPath.findWithExt,[Bind.bind, List.findM?, orM, liftM, System.FilePath.isDir, HDiv.hDiv, System.FilePath.mk, System.FilePath.pathExists, System.FilePath.withExtension, Pure.pure, Option.map, Lean.modToFilePath],[IO, Option, System.FilePath]]
[Lean.Meta.whnfI,[Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.instances, Lean.Meta.whnf],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Meta.Closure.ToProcessElement.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Closure.ToProcessElement.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Closure.ToProcessElement.mk, And]]
[Subtype.trans,[Setoid.trans],[HasEquiv.Equiv]]
[Std.RBMap.erase.proof_1,[Std.RBNode.WellFormed.eraseWff, rfl],[Std.RBNode.WellFormed, Std.RBNode.erase]]
[Lean.Meta.induction,[Lean.Meta.withMVarContext, Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MessageData.ofGoal, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Array, Lean.Meta.InductionSubgoal]]
[Lean.Elab.Term.ElabAppArgs.State.noConfusionType,[],[]]
[Lean.getStructureFieldsFlattened,[List.toArray, List.nil],[Array, Lean.Name]]
[add_neg_self,[add_right_neg],[Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat]]
[Lean.Elab.Term.Do.homogenize,[Bind.bind, Lean.Elab.Term.Do.extendUpdatedVars, Pure.pure, Prod.mk],[Lean.Elab.Term.TermElabM, Prod, Lean.Elab.Term.Do.CodeBlock]]
[Lean.PrettyPrinter.Delaborator.isCoe,[or, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, and, Lean.Expr.isAppOf, Decidable.decide, GE.ge, Lean.Expr.getAppNumArgs],[Bool]]
[Lean.Parser.Command.openScoped.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.PrettyPrinter.Formatter.checkColGt.formatter, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Expr.constName?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Name, Option.some, Option.none],[Option, Lean.Name]]
[Lean.Parser.Tactic.rwWithRfl,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Option.getD, Lean.Syntax.getHeadInfo?, List.nil],[Lean.MacroM, Lean.Syntax]]
[IO.FS.FileType.file.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.FileType.file, OfNat.ofNat]]
[Array.anyM.loop.proof_1,[Nat.lt_of_lt_of_le],[LT.lt, Array.size]]
[Lean.InductiveVal.isUnsafeEx,[Lean.InductiveVal.isUnsafe],[Bool]]
[Lean.Macro.Context.currMacroScope,[],[Lean.MacroScope]]
[Lean.Lsp.LeanFileProgressParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.LeanFileProgressParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.LeanFileProgressParams.mk, And]]
[Lean.JsonRpc.Message.response.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonRpc.Message.response, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.JsonRpc.Message.response, And]]
[Lean.Meta.Simp.main,[Lean.Meta.withConfig, Lean.Meta.Config.mk, Lean.Meta.Config.foApprox, Lean.Meta.Config.ctxApprox, Lean.Meta.Config.quasiPatternApprox, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Simp.Config.etaStruct, Lean.Meta.Simp.Context.config, Lean.Meta.withReducible, StateRefT'.run', Lean.Meta.Simp.simp, Lean.Meta.Simp.State.mk],[Lean.Meta.MetaM, Lean.Meta.Simp.Result]]
[IO.FS.Stream.readLspNotificationAs,[MonadExcept.tryCatch, Bind.bind, Unit.unit, IO, Nat, List.lookup, String.toNat?, Pure.pure, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, IO.FS.Stream.readNotificationAs],[IO, Lean.JsonRpc.Notification]]
[Lean.Name.appendBefore,[Lean.Name.modifyBase, Unit.unit, Lean.Name, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.Name.mkNum],[Lean.Name]]
[UInt32.isValidChar,[Nat.isValidChar, UInt32.toNat],[]]
[Lean.Meta.Instances.instanceNames,[],[Std.PHashSet, Lean.Name]]
[FloatArray.foldlMUnsafe,[ite, LT.lt, LE.le, FloatArray.size, USize.ofNat, Pure.pure, FloatArray.foldlMUnsafe.fold],[]]
[Nat.min_comm,[Decidable.em, LE.le, Eq.mpr, congr, congrArg, Eq, Eq.trans, ite_congr, eq_true, Eq.refl, ite_true, Nat.le_antisymm, Eq.symm, of_eq_true, eq_false, ite_false, eq_self, not_or_intro, Nat.le_or_le],[Eq, Nat.min]]
[Lean.Parser.Tactic.renameVar,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Parser.priorityParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Parser.Parser]]
[Lean.PrettyPrinter.Formatter.suppressInsideQuot.formatter,[],[Lean.PrettyPrinter.Formatter]]
[Lean.Server.FileWorker.CancelToken.noConfusionType,[],[]]
[Lean.Lsp.DiagnosticCode.int.inj,[],[Eq]]
[Lean.IR.EmitC.getEnv,[Functor.map, Lean.IR.EmitC.Context.env, MonadReader.read],[Lean.IR.EmitC.M, Lean.Environment]]
[Equiv.mk.inj,[And.intro],[And, Eq]]
[IO.Process.SpawnArgs.mk.inj,[And.intro],[And, Eq]]
[instToFormatOption,[Std.ToFormat.mk, Option.format],[Std.ToFormat, Option]]
[Lean.IR.ExplicitBoxing.getDecl,[Bind.bind, MonadReader.read, Unit.unit, Lean.IR.ExplicitBoxing.M, Lean.IR.Decl, Lean.IR.findEnvDecl', Lean.IR.ExplicitBoxing.BoxingContext.env, Lean.IR.ExplicitBoxing.BoxingContext.decls, Pure.pure, arbitrary],[Lean.IR.ExplicitBoxing.M, Lean.IR.Decl]]
[Lean.Parser.Term.doIfLet.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.doIfLetPure.formatter, Lean.Parser.Term.doIfLetBind.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.CompletionList.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.Do.Code.continue.inj,[],[Eq]]
[IO.bindTask,[EIO.bindTask],[BaseIO, Task, Except, IO.Error]]
[Lean.Parser.Tactic.tacticHave_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Function.bicompl,[],[]]
[IO.FS.Mode.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Elab.Tactic.rewriteLocalDecl,[Lean.Elab.Term.withSynthesize, Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.elabTerm, Option.none, Bool.true, liftM, Lean.Meta.getLocalDecl, Lean.Elab.Tactic.getMainGoal, Lean.Meta.rewrite, Lean.LocalDecl.type, Lean.Occurrences.all, Lean.Meta.replaceLocalDecl, Lean.Meta.RewriteResult.eNew, Lean.Meta.RewriteResult.eqProof, Lean.Elab.Tactic.replaceMainGoal, List.cons, Lean.Meta.AssertAfterResult.mvarId, Lean.Meta.RewriteResult.mvarIds, Bool.false],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.ScopedEnvExtension.StateStack.noConfusionType,[],[]]
[Lean.Parser.Command.infix.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.UnificationHints.discrTree,[],[Lean.Meta.DiscrTree, Lean.Name]]
[Lean.Parser.Term.letIdLhs.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.notFollowedBy.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.simpleBinderWithoutType.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Bool.false, Lean.Parser.Term.optType.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.version.specialDesc,[Lean.version.getSpecialDesc, Unit.unit],[String]]
[Mathlib.Tactic.Lint.lintCore,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, Array.mapM, Array.filterM, Mathlib.Tactic.Lint.shouldBeLinted, Mathlib.Tactic.Lint.NamedLinter.name, OfNat.ofNat, Array.size, liftM, BaseIO.asTask, EIO.toBaseIO, Lean.Core.CoreM.run', Lean.Meta.MetaM.run', Mathlib.Tactic.Lint.Linter.test, Mathlib.Tactic.Lint.NamedLinter.toLinter, Lean.Meta.Context.mk, Lean.Meta.State.mk, Lean.Core.Context.mk, Lean.Core.State.mk, BaseIO, Option, Lean.MessageData, Pure.pure, Option.some, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Exception.toMessageData, Task.Priority.default, Prod.mk, Lean.Core.CoreM, Prod, Mathlib.Tactic.Lint.NamedLinter, Std.HashMap, Lean.Name, ForIn.forIn, ForInStep, Option.none, Task.get, PUnit.unit, ForInStep.yield],[Lean.Core.CoreM, Array, Prod, Mathlib.Tactic.Lint.NamedLinter, Std.HashMap, Lean.Name, Lean.MessageData]]
[Lean.Meta.SimpAll.Entry.fvarId,[],[Lean.FVarId]]
[String.isInt,[ite, Eq, String.get, OfNat.ofNat, Char.ofNat, Substring.isNat, Substring.drop, String.toSubstring, String.isNat],[Bool]]
[Std.PersistentArray.get!,[ite, GE.ge, Std.PersistentArray.tailOff, Array.get!, Std.PersistentArray.tail, HSub.hSub, Std.PersistentArray.getAux, Std.PersistentArray.root, USize.ofNat, Std.PersistentArray.shift],[]]
[Lean.Syntax.isTokenAntiquot,[Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous],[Bool]]
[List.append_subset_iff,[Iff.intro, Eq.mpr, congr, congrArg, And, propext, List.subset_def, And.intro, Eq.mp, List.mem_append_left, List.mem_append_right, Subset.subset, HAppend.hAppend, List.append_subset_of_subset_of_subset],[Iff, Subset.subset, HAppend.hAppend, And]]
[Lean.Meta.admit,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType, Lean.Meta.mkSorry, Lean.Meta.assignExprMVar],[Lean.Meta.MetaM, Unit]]
[Lean.LocalDecl.value,[Lean.Expr, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[Lean.PrettyPrinter.Parenthesizer.instCoeParenthesizerParenthesizerAliasValue,[Coe.mk, Lean.Parser.AliasValue.const],[Coe, Lean.PrettyPrinter.Parenthesizer, Lean.PrettyPrinter.Parenthesizer.ParenthesizerAliasValue]]
[Lean.JsonRpc.RequestID.num.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.JsonRpc.RequestID.num, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.AbstractNestedProofs.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.AbstractNestedProofs.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.AbstractNestedProofs.Context.mk]]
[Lean.Parser.Term.doSeqItem.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.ppLine.formatter, Lean.Parser.doElemParser.formatter, Lean.Parser.optional.formatter, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[HPow.noConfusionType,[],[]]
[decidable_of_iff,[decidable_of_decidable_of_iff],[Decidable]]
[List.decidableBexi.proof_2,[Exists.intro, And.intro, List.mem_cons_self],[Exists, And, Mem.mem, List.cons]]
[Lean.Elab.Command.ProjectionInfo.declName,[],[Lean.Name]]
[Lean.mkOr,[Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.Expr]]
[Lean.Parser.Term.funStrictImplicitBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.lookahead.parenthesizer, Lean.Parser.Term.strictImplicitLeftBracket.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.strictImplicitRightBracket.parenthesizer, Lean.Parser.Term.strictImplicitBinder.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Applicative.toPure,[],[Pure]]
[Lean.Expr.updateMData!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateMData, Lean.Expr.mdata, Lean.Expr.updateMData!.proof_1, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[not.decidable_imp_symm,[Decidable.not_imp_symm],[]]
[Lean.SMap.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.SMap.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.mul_le_mul_left,[LE.le, HMul.hMul, Nat.le.dest],[LE.le, HMul.hMul]]
[Lean.getPPInstances,[Lean.KVMap.get, Lean.Option.name, Lean.pp.instances, Lean.Option.defValue],[Bool]]
[Lean.Elab.Term.ToDepElimPattern.State.noConfusionType,[],[]]
[Lean.Elab.Term.LValResolution.projFn.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.LValResolution.projFn, HAdd.hAdd, OfNat.ofNat]]
[Std.PersistentHashMap.toList,[Std.PersistentHashMap.foldl, List.cons, Prod.mk, List.nil],[List, Prod]]
[Lean.Expr.isIte,[Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat],[Bool]]
[Lean.TraceState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.TraceState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.ellipsis,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Array.mapIdxM.map,[Array, Pure.pure],[Array]]
[instSubsingletonStateM.proof_1,[Subsingleton.intro, funext, Eq, Eq.mpr, Eq.refl, Prod.mk, Subsingleton.elim, rfl],[Subsingleton, StateM]]
[Lean.Parser.Command.unsafe.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.allM,[Nat.allM.loop],[Bool]]
[String.length,[Nat, List.length],[Nat]]
[Lean.Parser.Command.in,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.Parser.withOpen, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.commandParser],[Lean.Parser.TrailingParser]]
[UInt32.instAddCommSemigroupUInt32,[AddCommSemigroup.mk, UInt32.instAddCommSemigroupUInt32.proof_1],[AddCommSemigroup, UInt32]]
[Lean.Parser.compileParserDescr,[Lean.Parser.compileParserDescr.visit],[Lean.ImportM, Lean.Parser.Parser]]
[Lean.KeyedDeclsAttribute.getValues,[List.map, Lean.KeyedDeclsAttribute.AttributeEntry.value, Lean.KeyedDeclsAttribute.getEntries],[List]]
[Lean.CollectMVars.instInhabitedState,[Inhabited.mk, Lean.CollectMVars.State.mk],[Inhabited, Lean.CollectMVars.State]]
[PUnit.subsingleton,[rfl, Eq.symm, Eq.refl],[Eq]]
[Iff.elim_right.proof_1,[Iff.mpr],[]]
[Lean.Meta.Match.Pattern.inaccessible.inj,[],[Eq]]
[Lean.IR.UnreachableBranches.Value.instToStringValue,[ToString.mk, Function.comp, Std.Format.pretty, Std.Format.defWidth, Lean.IR.UnreachableBranches.Value.format],[ToString, Lean.IR.UnreachableBranches.Value]]
[GroupWithZero.mul_inv_cancel,[],[Eq, HMul.hMul, Inv.inv, OfNat.ofNat]]
[Lean.IR.ExplicitRC.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.ExplicitRC.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.ExplicitRC.Context.mk, And]]
[Lean.Elab.Deriving.Header.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Deriving.Header.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.doLet.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.letDecl.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Command.ProjectionInfo.noConfusionType,[],[]]
[Lean.Expr.FindImpl.State.keys,[],[Array, Lean.Expr]]
[Lean.Elab.Term.Quotation.match_syntax.expand,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Syntax, OptionM.run, Array.sequenceMap, Array.getSepElems, Lean.Syntax.getArgs, Option.some, Option.none, OptionM, Prod, Array, Prod.mk, not, Array.any, Lean.Syntax.isQuot, Array.size, Bind.bind, Lean.Elab.throwUnsupportedSyntax, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Lean.Meta.GeneralizeArg.hName?,[],[Option, Lean.Name]]
[Lean.Lsp.RpcRef.mk.inj,[],[Eq]]
[Lean.Meta.Cache.whnfAll,[],[Lean.Meta.WhnfCache]]
[Option.some.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Option.some, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.EmitC.emitBox,[Bind.bind, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.emitBoxFn, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn],[Lean.IR.EmitC.M, Unit]]
[Lean.Elab.CompletionInfo.option.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.CompletionInfo.option, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.CompletionInfo.option]]
[Lean.Elab.Term.commitIfNoErrors?,[Bind.bind, Lean.MonadBacktrack.saveState, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.MessageLog.mk, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState, MonadExcept.tryCatch, MonadState.get, ite, Eq, Lean.MessageLog.hasErrors, Lean.Elab.Term.State.messages, Bool.true, Lean.MonadBacktrack.restoreState, Pure.pure, Option.none, HAppend.hAppend, Lean.Elab.Term.SavedState.elab, Option.some],[Lean.Elab.Term.TermElabM, Option]]
[Lean.Meta.IndPredBelow.mkContext,[Bind.bind, Lean.getConstInfoInduct, Array.mapM, List.toArray, Lean.InductiveVal.all, Array.mapIdxM, Fin.val, Pure.pure, Prod.mk, Lean.InductiveVal.numParams, Array.map, HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.IndPredBelow.Context.mk, Lean.Meta.IndPredBelow.mkContext.motiveName, Lean.Meta.IndPredBelow.mkContext.mkHeader, Lean.Meta.IndPredBelow.mkContext.addMotives, Lean.Meta.IndPredBelow.mkContext.motiveType, Lean.Meta.IndPredBelow.mkContext.mkIndValConst],[Lean.Meta.MetaM, Lean.Meta.IndPredBelow.Context]]
[Lean.Meta.isMatcher,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Meta.isMatcherCore],[Bool]]
[Lean.Lsp.instInhabitedDiagnosticCode,[Inhabited.mk, Lean.Lsp.DiagnosticCode.int, arbitrary],[Inhabited, Lean.Lsp.DiagnosticCode]]
[Lean.Lsp.InitializeParams.noConfusionType,[],[]]
[withPtrEqDecEq.proof_3,[ofBoolUsing_eq_false],[Not, Eq]]
[Lean.Compiler.foldNatBinOp,[OptionM.run, Bind.bind, Lean.Compiler.getNumLit, Pure.pure, Lean.mkRawNatLit],[Option, Lean.Expr]]
[Lean.Elab.Tactic.evalSubst,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Tactic.forEachVar, Lean.Meta.subst, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[Lean.EnumAttributes.setValue,[ite, Eq, Option.isSome, Lean.Environment.getModuleIdxFor?, Bool.true, Except.error, HAppend.hAppend, ToString.toString, Lean.PersistentEnvExtension.name, Lean.EnumAttributes.ext, Lean.NameMap.find?, Lean.PersistentEnvExtension.getState, Except.ok, Lean.PersistentEnvExtension.addEntry, Prod.mk],[Except, String, Lean.Environment]]
[Lean.JsonNumber.instLTJsonNumber,[Lean.JsonNumber.ltProp],[LT, Lean.JsonNumber]]
[Lean.Environment.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Environment.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Environment.mk, And]]
[List.mem_bind_of_mem,[Iff.mpr, List.mem_bind, Exists.intro, And.intro],[Mem.mem, List.bind]]
[Lean.Parser.Term.waitIfTypeMVar.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[instCommMonoid_1.proof_1,[Semiring.mul_one],[Eq, HMul.hMul, OfNat.ofNat]]
[MonadReaderOf.read,[],[]]
[Lean.Elab.Info.occursInside?,[OptionM.run, Bind.bind, Lean.Elab.Info.pos?, Lean.Elab.Info.tailPos?, guard, Eq, and, Decidable.decide, LE.le, LT.lt, Bool.true, Pure.pure, HSub.hSub],[Option, Nat]]
[workOnGoal,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Elab.logInfoAt,[Lean.Elab.logAt, Lean.MessageSeverity.information],[Unit]]
[Lean.JsonRpc.instInhabitedErrorCode,[Inhabited.mk, Lean.JsonRpc.ErrorCode.parseError],[Inhabited, Lean.JsonRpc.ErrorCode]]
[Lean.Elab.Command.tmpIndParam,[Lean.mkLevelParam, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Level]]
[Lean.Expr.mkDataForBinder,[ite, GT.gt, HSub.hSub, Nat.pow, OfNat.ofNat, panicWithPosWithDecl, Bool.false],[Lean.Expr.Data]]
[instNegFin.proof_1,[Nat.mod_lt, HSub.hSub, Fin.val, lt_of_le_of_lt, Nat.zero_le, Fin.isLt],[LT.lt, HMod.hMod, HSub.hSub, Fin.val]]
[Lean.Elab.Term.Do.ToTerm.Kind.nestedPR.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.ToTerm.Kind.nestedPR, OfNat.ofNat]]
[Lean.getFieldInfo?,[Option.none, Option, Lean.StructureFieldInfo, Lean.getStructureInfo?, Array.binSearch, Lean.StructureInfo.fieldInfo, Lean.StructureFieldInfo.mk, arbitrary, Bool.false, Lean.StructureFieldInfo.lt, OfNat.ofNat, HSub.hSub, Array.size],[Option, Lean.StructureFieldInfo]]
[Nat.pred,[Unit.unit, Nat, OfNat.ofNat],[Nat]]
[USize.modn_lt,[LT.lt, USize.toNat, HMod.hMod, Fin.modn_lt],[LT.lt, USize.toNat, HMod.hMod]]
[Lean.Elab.Command.ElabHeaderResult.params,[],[Array, Lean.Expr]]
[Lean.Expr.mkData,[ite, GT.gt, HSub.hSub, Nat.pow, OfNat.ofNat, panicWithPosWithDecl, Bool.false, Lean.BinderInfo.default],[Lean.Expr.Data]]
[Lean.IR.Borrow.BorrowInfCtx.paramSet,[],[Lean.IR.IndexSet]]
[Lean.Lsp.instFromJsonRpcReleaseParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, UInt64, Array, Lean.Lsp.RpcRef, Pure.pure, Lean.Lsp.RpcReleaseParams.mk],[Lean.FromJson, Lean.Lsp.RpcReleaseParams]]
[Lean.Export.Entry.name.injEq,[Eq.propIntro, Eq.refl, Lean.Export.Entry.name, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Export.Entry.name]]
[instSemiringFin.proof_10,[Eq.mpr, Eq.refl, Eq, HMul.hMul, OfNat.ofNat, instSemiringFin.proof_4, instSemiringFin.proof_5],[Eq, HMul.hMul, OfNat.ofNat]]
[Array.anyM.proof_1,[Nat.le_refl, Array.size],[LE.le, Array.size]]
[Lean.Constructor.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Constructor.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.getNondepPropHyps.removeDeps,[Bind.bind, Lean.Meta.instantiateMVars, StateRefT'.run'],[Lean.Meta.MetaM, Lean.FVarIdHashSet]]
[Lean.OpenDecl.noConfusionType,[],[]]
[Lean.Elab.Deriving.Repr.mkBodyForStruct,[Bind.bind, Lean.getConstInfoCtor, List.head!, Lean.InductiveVal.ctors, Lean.MonadEnv.getEnv, Pure.pure, Lean.getStructureFields, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Prod.mk, List.nil, ite, Eq, bne, Array.size, HAdd.hAdd, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData, PUnit.unit],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Lean.Elab.Term.Do.mkPureUnitAction,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Elab.Term.Do.mkTerminalAction],[Lean.MacroM, Lean.Elab.Term.Do.CodeBlock]]
[Lean.Elab.Term.Do.Alt.patterns,[],[Lean.Syntax]]
[Lean.Elab.Term.isAuxDiscrName,[and, Lean.Name.hasMacroScopes, BEq.beq, Lean.Name.eraseMacroScopes, Lean.Name.mkStr, Lean.Name.anonymous],[Bool]]
[String.toAsciiByteArray.loop,[WellFounded.fix, String.toAsciiByteArray.loop.proof_1, dite, Eq, String.atEnd, Bool.true, String.next, String.toAsciiByteArray.loop.proof_2, ByteArray.push, Char.toUInt8],[ByteArray]]
[Lean.Elab.Tactic.evalFocus,[Bind.bind, Lean.Elab.Tactic.mkInitialTacticInfo, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.focus, Lean.Elab.withInfoContext, Pure.pure, Unit.unit, Lean.Elab.Tactic.evalTactic],[Lean.Elab.Tactic.Tactic]]
[Lean.Syntax.mkScientificLit,[Lean.Syntax.mkLit, Lean.scientificLitKind],[Lean.Syntax]]
[Nat.toUInt8,[UInt8.ofNat],[UInt8]]
[Prod.swap_inj,[Function.injective.eq_iff, Prod.swap_injective],[Iff, Eq, Prod.swap]]
[Lean.Meta.InfoCacheKey.instHashableInfoCacheKey,[Hashable.mk, UInt64, mixHash, Hashable.hash],[Hashable, Lean.Meta.InfoCacheKey]]
[Lean.Parser.Command.elab_rules.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.suppressInsideQuot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.docComment.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.optKind.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Expr.ReplaceImpl.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Expr.ReplaceImpl.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Group.noConfusionType,[],[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.applyFunBinderHeuristic,[Bind.bind, MonadReader.read, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit, ForIn.forIn, PUnit.unit, Pure.pure, BEq.beq, Array.getOp, Lean.BinderInfo.default, ite, Eq, Bool.true, liftM, Lean.Meta.inferType, Lean.PrettyPrinter.Delaborator.SubExpr.withNaryArg, modify, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.bottomUps, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.higherOrders, Array.set!, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.funBinders, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.provideds, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.namedArgs, ForInStep.yield, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.applyFunBinderHeuristic.core],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit]]
[decide_eq_false_iff_not,[Iff.intro, of_decide_eq_false, decide_eq_false],[Iff, Eq, Decidable.decide, Bool.false, Not]]
[rfl.proof_1,[Eq.refl],[Eq]]
[Nat.dvd_lcm_right,[Nat.dvd_lcm_left, Nat.lcm_comm],[Dvd.dvd, Nat.lcm]]
[Lean.Message.pos,[],[Lean.Position]]
[instStreamSubstringChar,[Stream.mk, ite, LT.lt, Substring.startPos, Substring.stopPos, Option.some, Prod.mk, String.get, Substring.str, Substring.mk, String.next, Option.none],[Stream, Substring, Char]]
[Lean.Parser.mkAntiquot,[Lean.Parser.leadingNode, Lean.Parser.maxPrec, Lean.Parser.atomic, HAndThen.hAndThen, Lean.Parser.setExpected, List.nil, Lean.Parser.symbol, Lean.Parser.manyNoAntiquot, Lean.Parser.checkNoWsBefore, Lean.Parser.antiquotExpr],[Lean.Parser.Parser]]
[Lean.Parser.initCacheForInput,[Lean.Parser.ParserCache.mk, Lean.Parser.TokenCacheEntry.mk, HAdd.hAdd, String.bsize, OfNat.ofNat],[Lean.Parser.ParserCache]]
[and.swap,[And, And.intro],[And]]
[ReprTuple.noConfusionType,[],[]]
[Lean.Parser.setExpected,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.setExpectedFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.Widget.instToJsonTaggedText,[Lean.ToJson.mk],[Lean.ToJson, Lean.Widget.TaggedText]]
[Lean.Meta.Cache.whnfDefault,[],[Lean.Meta.WhnfCache]]
[Lean.PrettyPrinter.Parenthesizer.mkAntiquot.parenthesizer,[Lean.Parser.mkAntiquot.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Tactic.fapply',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Term.CollectPatternVars.Context.ctorVal?,[],[Option, Lean.ConstructorVal]]
[Lean.collectLevelParams,[Lean.CollectLevelParams.main],[Lean.CollectLevelParams.State]]
[Lean.Elab.Term.Context.sectionFVars,[],[Lean.NameMap, Lean.Expr]]
[Lean.Lsp.Ipc.writeNotification,[Bind.bind, Lean.Lsp.Ipc.stdin, liftM, IO.FS.Stream.writeLspNotification],[Lean.Lsp.Ipc.IpcM, Unit]]
[Lean.Parser.Term.parenSpecial,[Lean.Parser.optional, HOrElse.hOrElse, Lean.Parser.Term.tupleTail, Lean.Parser.Term.typeAscription],[Lean.Parser.Parser]]
[CoeHTCT.noConfusionType,[],[]]
[Lean.Elab.Frontend.State.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.Decl.extern.inj,[And.intro],[And, Eq]]
[Lean.instToFormatName,[Std.ToFormat.mk, Std.Format.text, Lean.Name.toString, Bool.true],[Std.ToFormat, Lean.Name]]
[Lean.IR.UnreachableBranches.Value.instToFormatValue,[Std.ToFormat.mk, Lean.IR.UnreachableBranches.Value.format],[Std.ToFormat, Lean.IR.UnreachableBranches.Value]]
[Lean.EnvExtensionInterfaceUnsafe.modifyState,[ite, LT.lt, Lean.EnvExtensionInterfaceUnsafe.Ext.idx, Array.size, Lean.Environment.extensions, Lean.Environment.mk, Lean.Environment.const2ModIdx, Lean.Environment.constants, Array.modify, unsafeCast, Lean.Environment.header, panicWithPosWithDecl, OfNat.ofNat],[Lean.Environment]]
[Lean.Elab.Structural.registerEqnsInfo,[Lean.MonadEnv.modifyEnv, Lean.MapDeclarationExtension.insert, Lean.Elab.Structural.eqnInfoExt, Lean.Elab.PreDefinition.declName, Lean.Elab.Structural.EqnInfo.mk, Lean.Elab.PreDefinition.levelParams, Lean.Elab.PreDefinition.type, Lean.Elab.PreDefinition.value],[Lean.Core.CoreM, Unit]]
[Lean.Parser.nonReservedSymbolFnAux,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Syntax.missing, Lean.Syntax.node, Lean.Parser.ParserState, Array.back, Lean.Parser.ParserState.stxStack, BEq.beq, Lean.Parser.ParserState.mkErrorAt, Option.some, Substring.toString, Lean.Parser.ParserState.pushSyntax, Lean.Syntax.atom],[Lean.Parser.ParserFn]]
[Lean.Parsec.ParseResult.success.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parsec.ParseResult.success, HAdd.hAdd, OfNat.ofNat]]
[Equiv.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Equiv.mk, OfNat.ofNat]]
[Nat.lt.step,[Nat.lt.step.proof_1],[LT.lt, Nat.succ]]
[Lean.Server.FileWorker.RpcSession.mk.inj,[And.intro],[And, Eq]]
[Lean.mkFreshId,[Bind.bind, Lean.MonadNameGenerator.getNGen, Lean.MonadNameGenerator.setNGen, Lean.NameGenerator.next, Pure.pure],[Lean.Name]]
[Lean.Compiler.objectType,[Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.Expr]]
[Lean.Parser.Command.terminationHint1.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[pow_succ',[Monoid.npow_succ'],[Eq, HPow.hPow, Nat.succ, HMul.hMul]]
[Lean.Parser.Term.doElem.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.doElemParser],[Lean.Parser.Parser]]
[Subarray.forM,[Array.forM, Subarray.as, Subarray.start, Subarray.stop],[PUnit]]
[ReaderT.run_seqRight,[Eq.mpr, Eq.refl, Eq, ReaderT.run, SeqRight.seqRight, seqRight_eq_bind, rfl],[Eq, ReaderT.run, SeqRight.seqRight]]
[Nat.gcd_dvd_gcd_mul_right,[Nat.gcd_dvd_gcd_of_dvd_left, Nat.dvd_mul_right],[Dvd.dvd, Nat.gcd, HMul.hMul]]
[Lean.Elab.TerminationHints.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.TerminationHints.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.CollectPatternVars.Context.ellipsis,[],[Bool]]
[Lean.IR.Sorry.M,[StateT, Lean.IR.Sorry.State, Lean.IR.CompilerM],[]]
[Lean.Parser.ParserState.keepPrevError,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Array.shrink],[Lean.Parser.ParserState]]
[Lean.Parser.Command.mutual.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.Parser.notSymbol.parenthesizer, Lean.Parser.commandParser.parenthesizer, Lean.Parser.ppDedent.parenthesizer, Lean.Parser.Command.terminationSuffix.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.MVarErrorKind.custom.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.MVarErrorKind.custom, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.MVarErrorKind.custom]]
[Lean.Elab.Visibility.private.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Visibility.private, OfNat.ofNat]]
[Lean.Meta.CaseValuesSubgoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.CaseValuesSubgoal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.CaseValuesSubgoal.mk, And]]
[Lean.Parser.Command.section,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.ident],[Lean.Parser.Parser]]
[Lean.Meta.isLevelDefEq,[Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.Meta.checkpointDefEq, Lean.Meta.isLevelDefEqAux, Bool.true, Lean.isTracingEnabledFor, ite, Eq, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Bool]]
[Lean.Elab.CompletionInfo.noConfusionType,[],[]]
[«term∅»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Xml.Parser.EntityValue,[Bind.bind, HOrElse.hOrElse, Lean.Parsec.skipChar, Char.ofNat, SeqLeft.seqLeft, Lean.Parsec.many, Functor.map, Option.some, Lean.Parsec.satisfy, Decidable.decide, And, Ne, SeqRight.seqRight, Lean.Xml.Parser.PEReference, Pure.pure, Option.none, Lean.Xml.Parser.Reference, Array.foldl, String, String.push, OfNat.ofNat, Array.size],[Lean.Parsec, String]]
[Lean.Elab.Attribute.mk.inj,[And.intro],[And, Eq]]
[IO.AccessRight.mk.inj,[And.intro],[And, Eq]]
[Lean.Xml.instInhabitedContent,[Inhabited.mk, Lean.Xml.Content.Comment, arbitrary],[Inhabited, Lean.Xml.Content]]
[not_not,[Decidable.not_not],[Iff, Not]]
[Array.instEmptyCollectionArray,[EmptyCollection.mk, Array.empty],[EmptyCollection, Array]]
[instReprAtomUInt8,[ReprAtom.mk],[ReprAtom, UInt8]]
[Std.Range.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.Range.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.RequestContext.srcSearchPath,[],[Lean.SearchPath]]
[Nat.lt_or_eq_or_le_succ,[Decidable.byCases, Or.inr],[Or, LE.le, Eq, Nat.succ]]
[Lean.Parser.nodeWithAntiquot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Parser.node],[Lean.Parser.Parser]]
[Lean.IR.CtorInfo.usize,[],[Nat]]
[String.decapitalize,[String.set, OfNat.ofNat, Char.toLower, String.get],[String]]
[Lean.Meta.SynthInstance.Answer.size,[],[Nat]]
[Array.singleton,[Array.mkArray, OfNat.ofNat],[Array]]
[Lean.Lsp.WaitForDiagnosticsParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.WaitForDiagnosticsParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.WaitForDiagnosticsParams.mk, And]]
[«term_<*>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[IO.Error.mkResourceVanished,[IO.Error.resourceVanished],[IO.Error]]
[IO.FS.withIsolatedStreams,[Bind.bind, liftM, IO.mkRef, IO.FS.Stream.Buffer.mk, IO.withStdin, IO.FS.Stream.ofBuffer, IO.withStdout, IO.withStderr, ST.Ref.get, Pure.pure, Prod.mk],[Prod, String]]
[Lean.Elab.Command.StructFieldView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Command.StructFieldView.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Match.AltLHS.noConfusionType,[],[]]
[Lean.Meta.mkEqTrue,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.ScopedEnvExtension.Descr.noConfusionType,[],[]]
[Lean.Server.FileWorker.WorkerState.pendingRequests,[],[Lean.Server.FileWorker.PendingRequestMap]]
[Nat.sub_one_sub_lt,[Eq.mpr, Eq.refl, LT.lt, HSub.hSub, OfNat.ofNat, Nat.sub_sub, Nat.sub_lt, Nat.lt_of_lt_of_le, Nat.zero_lt_succ, HAdd.hAdd, Nat.add_comm],[LT.lt, HSub.hSub, OfNat.ofNat]]
[Lean.Elab.Term.ExtractMonadResult.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Modifiers.attrs,[],[Array, Lean.Elab.Attribute]]
[Lean.Parser.notSymbol,[Lean.Parser.notFollowedBy, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.IR.MapVars.mapExpr,[Lean.IR.Expr.lit, Lean.IR.Expr, Lean.IR.Expr.ctor, Lean.IR.MapVars.mapArgs, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.fap, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr],[Lean.IR.Expr]]
[Lean.Xml.Parser.AttType,[HOrElse.hOrElse, Lean.Xml.Parser.StringType, Lean.Xml.Parser.TokenizedType, Lean.Xml.Parser.EnumeratedType],[Lean.Parsec, Unit]]
[Sub.noConfusionType,[],[]]
[Lean.getBoolOption,[Bind.bind, Lean.MonadOptions.getOptions, Pure.pure, Lean.KVMap.getBool],[Bool]]
[Nat.to_digits_core_length,[of_eq_true, eq_true, Nat.zero_le, False.elim, Nat.lt_irrefl, OfNat.ofNat, Eq.symm, Classical.em, LT.lt, Eq.refl],[LE.le, List.length, Nat.toDigitsCore, List.nil]]
[Lean.IR.FnBody.ret.inj,[],[Eq]]
[Array.pop,[Array.mk, List.dropLast, Array.data],[Array]]
[Lean.Elab.Structural.run,[StateRefT'.run],[Lean.Meta.MetaM, Prod, Lean.Elab.Structural.State]]
[Lean.Lsp.ClientCapabilities.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.ClientCapabilities.mk, OfNat.ofNat]]
[Lean.Export.instInhabitedState,[Inhabited.mk, Lean.Export.State.mk, arbitrary],[Inhabited, Lean.Export.State]]
[Lean.IR.Expr.reset.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.reset, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Expr.reset, And]]
[Lean.Parser.Tactic.letrec,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Nat.mul_div_left,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, Nat.mul_comm, Nat.mul_div_right, rfl],[Eq, HDiv.hDiv, HMul.hMul]]
[Lean.Elab.CompletionInfo.option.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.CompletionInfo.option, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.ClientInfo.name,[],[String]]
[Lean.Parser.Module.header,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Module.prelude, Lean.Parser.ppLine, Lean.Parser.many, Lean.Parser.Module.import],[Lean.Parser.Parser]]
[Nat.mod_eq_of_lt,[],[Eq, HMod.hMod]]
[ReaderT.run_monadMap,[rfl],[Eq, ReaderT.run, MonadFunctorT.monadMap]]
[Lean.Meta.casesOnStuckLHS?,[Bind.bind, MonadExcept.tryCatch, Lean.Meta.casesOnStuckLHS, Pure.pure, DoResultPR.pure, PUnit.unit, DoResultPR.return, Option.none, Lean.Meta.MetaM, Option, Array, Lean.MVarId, Option.some],[Lean.Meta.MetaM, Option, Array, Lean.MVarId]]
[Std.PersistentArray.all,[not, Std.PersistentArray.any],[Bool]]
[Int.div,[Int, Int.ofNat, HDiv.hDiv, Neg.neg, Nat.succ],[Int]]
[Lean.Elab.Frontend.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Frontend.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Frontend.Context.mk]]
[Lean.PrettyPrinter.Delaborator.delabPSigma,[Lean.PrettyPrinter.Delaborator.delabSigmaCore, Bool.false],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.Lsp.TypeDefinitionParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.TypeDefinitionParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.TypeDefinitionParams.mk]]
[Lean.Elab.Term.StructInst.ExplicitSourceInfo.mk.inj,[And.intro],[And, Eq]]
[false_ne_true,[trivial, Eq.symm],[Ne, False, True]]
[Classical.typeDecidable.proof_1,[absurd, Nonempty.intro],[False]]
[Lean.Meta.byCases.toByCasesSubgoal,[Bind.bind, Pure.pure, Lean.Meta.InductionSubgoal.fields, Lean.Meta.CasesSubgoal.toInductionSubgoal, dite, Eq, Array.size, Array.getLit, Eq.symm, of_decide_eq_true, id, Eq.refl, Bool.true, List.toArray, List.cons, Lean.Expr.bvar, List.nil, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Array.toArrayLit_eq, Lean.Meta.MetaM, Lean.Meta.ByCasesSubgoal, Lean.Meta.ByCasesSubgoal.mk, Lean.Meta.InductionSubgoal.mvarId, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM, Lean.Meta.ByCasesSubgoal]]
[Lean.Elab.MonadLog.noConfusionType,[],[]]
[Lean.Parser.ParserExtension,[Lean.ScopedEnvExtension, Lean.Parser.ParserExtension.OLeanEntry, Lean.Parser.ParserExtension.Entry, Lean.Parser.ParserExtension.State],[]]
[Lean.Lsp.DidCloseTextDocumentParams.noConfusionType,[],[]]
[Lean.Meta.MVarRenaming.find!,[Option.get!, Lean.Meta.MVarRenaming.find?],[Lean.MVarId]]
[ToString.toString,[],[String]]
[Lean.ReducibilityStatus.irreducible.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.ReducibilityStatus.irreducible, OfNat.ofNat]]
[Exists.choose,[Classical.choose],[]]
[Lean.PrettyPrinter.Parenthesizer.Context.cat,[],[Lean.Name]]
[Lean.Parser.Tactic.convert,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Meta.Simp.Context.noConfusionType,[],[]]
[Lean.Parser.Tactic.rewriteSeq,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Function.injective_iff_has_left_inverse,[Iff.intro, Function.injective.has_left_inverse, Function.has_left_inverse.injective],[Iff, Function.injective, Function.has_left_inverse]]
[Lean.PrettyPrinter.Formatter.identEq.formatter,[Lean.PrettyPrinter.Formatter.rawIdentNoAntiquot.formatter],[Lean.PrettyPrinter.Formatter]]
[AddMonoid.nsmul,[],[]]
[Lean.PrettyPrinter.Delaborator.getUnusedName,[Bind.bind, Lean.MonadLCtx.getLCtx, ite, Eq, not, Lean.LocalContext.usesUserName, Bool.true, Pure.pure, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPSafeShadowing, and, Lean.LocalContext.getUnusedName, Lean.PrettyPrinter.Delaborator.getUnusedName.bodyUsesSuggestion],[Lean.PrettyPrinter.Delaborator.DelabM, Lean.Name]]
[Lean.Elab.Command.CommandElabM,[Lean.Elab.Command.CommandElabCoreM, Lean.Exception],[]]
[Lean.Server.Watchdog.handleCancelRequest,[Bind.bind, MonadReader.read, ST.Ref.get, Lean.Server.Watchdog.ServerContext.fileWorkersRef, ForIn.forIn, PUnit.unit, Lean.Server.Watchdog.ServerM, ForInStep, PUnit, Lean.Server.Watchdog.FileWorker.pendingRequestsRef, ite, Eq, Std.RBMap.contains, Lean.Lsp.CancelParams.id, Bool.true, Lean.Server.Watchdog.tryWriteMessage, Lean.JsonRpc.Message.notification, Lean.JsonRpc.Notification.method, Lean.JsonRpc.Notification.mk, Except.toOption, Lean.Json.toStructured?, Lean.JsonRpc.Notification.param, Bool.false, Pure.pure, ForInStep.yield],[Lean.Server.Watchdog.ServerM, Unit]]
[Lean.IR.UnreachableBranches.Value.ctor.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, Eq.refl, List.nil, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.IR.UnreachableBranches.Value.ctor, HAdd.hAdd, OfNat.ofNat]]
[Lean.Syntax.getOp,[Lean.Syntax.getArg],[Lean.Syntax]]
[Lean.Lsp.Hover.noConfusionType,[],[]]
[Lean.Parser.interpolatedStr,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.interpolatedStrKind, Bool.true, Lean.Parser.interpolatedStrNoAntiquot],[Lean.Parser.Parser]]
[Lean.MetavarContext.MkBinding.State.noConfusionType,[],[]]
[Lean.Lsp.instToJsonRpcConnectParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.RpcConnectParams.uri, List.nil],[Lean.ToJson, Lean.Lsp.RpcConnectParams]]
[Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1],[Trans, LT.lt]]
[Lean.StructureDescr.noConfusionType,[],[]]
[Lean.Meta.SavedState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SavedState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SavedState.mk, And]]
[NonScalar.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, NonScalar.mk, HAdd.hAdd, OfNat.ofNat]]
[max_comm,[eq_max, le_max_right, le_max_left, max_le],[Eq, max]]
[Lean.Elab.Command.CtorView.modifiers,[],[Lean.Elab.Modifiers]]
[Lean.DeclarationRange.endCharUtf16,[],[Nat]]
[Lean.isPrivateName,[Lean.Name.anonymous, Lean.Name.str, Bool, or, BEq.beq, Lean.privateHeader, PProd.fst, Bool.false],[Bool]]
[Lean.Meta.CheckAssignment.State.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.CheckAssignment.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.CheckAssignment.State.mk]]
[Thunk.map,[Thunk.mk, Thunk.get],[Thunk]]
[Function.inv_fun_surjective,[Function.left_inverse.surjective, Function.left_inverse_inv_fun],[Function.surjective, Function.inv_fun]]
[OptionT.run,[],[Option]]
[Lean.Meta.CheckAssignment.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.CheckAssignment.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.CheckAssignment.Context.mk, And]]
[Lean.Xml.Parser.StringType,[Lean.Parsec.skipString],[Lean.Parsec, Unit]]
[Nat.add_sub_add_left,[Eq.mpr, Eq.refl, Eq, HSub.hSub, HAdd.hAdd, Nat.add_comm, Nat.add_sub_add_right, rfl],[Eq, HSub.hSub, HAdd.hAdd]]
[Quotient.inductionOn₃,[Quotient.ind],[]]
[Lean.Server.Snapshots.Snapshot.infoTree,[ite, Eq, BEq.beq, Std.PersistentArray.size, Lean.Elab.InfoState.trees, Lean.Elab.Command.State.infoState, Lean.Server.Snapshots.Snapshot.cmdState, OfNat.ofNat, Bool.true, Std.PersistentArray.getOp, panicWithPosWithDecl, HAppend.hAppend],[Lean.Elab.InfoTree]]
[Function.«term↿_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Meta.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Context.mk, And]]
[Lean.SSet.empty,[Lean.SMap.empty],[Lean.SSet]]
[Lean.Level.mvar.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Level.mvar, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Level.mvar, And]]
[Lean.Meta.mkEqMP,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Parser.Tactic.matchAlts,[Lean.Parser.Term.matchAlts, Lean.Parser.Tactic.matchRhs],[Lean.Parser.Parser]]
[Decidable.not_not,[Iff.intro, Decidable.by_contradiction, not_not_intro],[Iff, Not]]
[Lean.Expr.hashEx,[Hashable.hash],[UInt64]]
[Lean.IR.UnreachableBranches.updateVarAssignment,[Bind.bind, Lean.IR.UnreachableBranches.findVarValue, MonadReader.read, modify, Lean.IR.UnreachableBranches.InterpState.mk, Array.modify, Lean.IR.UnreachableBranches.InterpState.assignments, Lean.IR.UnreachableBranches.InterpContext.currFnIdx, Std.HashMap.insert, Lean.IR.UnreachableBranches.Value.merge, Lean.IR.UnreachableBranches.InterpState.funVals],[Lean.IR.UnreachableBranches.M, Unit]]
[fixCore2,[bfix2, USize.size],[]]
[Lean.IR.LitVal.num.inj,[],[Eq]]
[Lean.Meta.RewriteResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.RewriteResult.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.mkNumeral,[Bind.bind, Lean.Meta.getDecLevel, Lean.Meta.synthInstance, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil, Lean.mkRawNatLit, Option.none, Pure.pure, Lean.mkApp3],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Meta.Closure.instInhabitedToProcessElement,[Inhabited.mk, Lean.Meta.Closure.ToProcessElement.mk, arbitrary],[Inhabited, Lean.Meta.Closure.ToProcessElement]]
[lt_of_not_ge,[lt_of_le_not_le, Or.resolve_right, le_total],[LT.lt]]
[Lean.Elab.Deriving.Ord.mkMatch,[Bind.bind, Lean.Elab.Deriving.mkDiscrs, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.Elab.Deriving.Ord.mkMatch.mkAlts],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[HShiftLeft.hShiftLeft,[],[]]
[Lean.Expr.natLit!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.strVal, Lean.Expr.mdata, Lean.Expr.proj, Nat, panicWithPosWithDecl, OfNat.ofNat],[Nat]]
[LawfulMonad.bind_map,[],[Eq, Bind.bind, Functor.map, Seq.seq]]
[Lean.LazyInitExtension.fn,[],[]]
[ulift.up_down,[Eq, ulift.up, ulift.down, rfl],[Eq, ulift.up, ulift.down]]
[Lean.Parser.parserOfStack,[Lean.Parser.Parser.mk, Lean.Parser.parserOfStackFn, Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.tokens, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Parser.ParserContext.savedPos?, Lean.Parser.ParserContext.forbiddenTk?],[Lean.Parser.Parser]]
[Std.RBNode.foldM,[Pure.pure, Bind.bind, PProd.fst, PProd.snd],[]]
[UInt8.isAlpha,[or, UInt8.isUpper, UInt8.isLower],[Bool]]
[Lean.Expr.isLet,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Elab.Tactic.filterOldMVars,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Array.filter, Decidable.decide, GE.ge, Lean.MetavarDecl.index, Lean.MetavarContext.getDecl, OfNat.ofNat, Array.size],[Lean.Meta.MetaM, Array, Lean.MVarId]]
[Lean.IR.ExpandResetReuse.CollectProjMap.Collector,[Lean.IR.ExpandResetReuse.ProjMap],[]]
[Lean.MetavarContext.addLevelMVarDecl,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Std.PersistentHashMap.insert, Lean.MetavarContext.lDepth, Lean.MetavarContext.decls, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment],[Lean.MetavarContext]]
[Lean.Meta.ByCasesSubgoal.fvarId,[],[Lean.FVarId]]
[Lean.Lsp.instInhabitedRange,[Inhabited.mk, Lean.Lsp.Range.mk, arbitrary],[Inhabited, Lean.Lsp.Range]]
[Iff.symm,[Iff.intro, Iff.mpr, Iff.mp],[Iff]]
[Mathlib.Tactic.Lint.NamedLinter.declName,[],[Lean.Name]]
[Lean.Elab.Term.Do.ToTerm.mkNestedTerm,[Lean.Elab.Term.Do.ToTerm.run, Lean.Elab.Term.Do.ToTerm.mkNestedKind],[Lean.MacroM, Lean.Syntax]]
[Lean.MessageData.nestD,[Lean.MessageData.nest, OfNat.ofNat],[Lean.MessageData]]
[Lean.Elab.Term.MVarErrorInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.ImportM.Context.opts,[],[Lean.Options]]
[Nat.foldM,[Nat.foldM.loop],[]]
[Lean.Parser.Tactic.trans',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Term.macroArg,[Lean.Parser.termParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[List.isSuffixOf,[List.isPrefixOf, List.reverse],[Bool]]
[imp_congr_left,[Iff.intro, Iff.mpr, Iff.mp],[Iff]]
[Lean.ExternEntry.adhoc.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ExternEntry.adhoc, HAdd.hAdd, OfNat.ofNat]]
[Lean.instDecidableEqJsonNumber,[Decidable, Eq, dite, Decidable.isTrue, rfl, Decidable.isFalse],[DecidableEq, Lean.JsonNumber]]
[Lean.Elab.Term.LValResolution.projIdx.inj,[And.intro],[And, Eq]]
[Lean.Parser.Command.instance,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.attrKind, Lean.Parser.symbol, Lean.Parser.Command.optNamedPrio, Lean.Parser.optional, Lean.Parser.ppSpace, Lean.Parser.Command.declId, Lean.Parser.Command.declSig, Lean.Parser.Command.declVal, Lean.Parser.Command.terminationSuffix],[Lean.Parser.Parser]]
[Lean.SSet.size,[Lean.SMap.size],[Nat]]
[Lean.Lsp.InitializeResult.noConfusionType,[],[]]
[Lean.JsonRpc.Message.responseError.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonRpc.Message.responseError, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.JsonRpc.Message.responseError, And]]
[Lean.ScopedEnvExtension.Descr.finalizeImport,[],[]]
[Set.powerset,[setOf, Subset.subset],[Set]]
[Lean.Lsp.MarkupKind.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.MarkupKind.toCtorIdx],[]]
[Lean.Server.FileWorker.ElabTaskError.ioError.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.FileWorker.ElabTaskError.ioError, HAdd.hAdd, OfNat.ofNat]]
[Lean.ConstructorVal.noConfusionType,[],[]]
[Lean.Elab.Command.resolveSyntaxKind,[Bind.bind, Lean.MonadResolveName.getCurrNamespace, HOrElse.hOrElse, Lean.Elab.checkSyntaxNodeKindAtNamespaces, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Elab.Command.CommandElabM, Lean.Name]]
[Lean.Meta.Simp.State.cache,[],[Lean.Meta.Simp.Cache]]
[Lean.HeadIndex.const.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.HeadIndex.const, HAdd.hAdd, OfNat.ofNat]]
[Lean.KVMap.instValueInt,[Lean.KVMap.Value.mk, Lean.DataValue.ofInt, Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofName, Lean.DataValue.ofNat, Option, Int, Option.some, Option.none],[Lean.KVMap.Value, Int]]
[Lean.Parser.Command.catBehaviorSymbol.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.instFileSourceCompletionParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.CompletionParams.toTextDocumentPositionParams],[Lean.Lsp.FileSource, Lean.Lsp.CompletionParams]]
[Lean.Lsp.SaveOptions.includeText,[],[Bool]]
[Function.involutive_iff_iter_2_eq_id,[Iff.symm, Function.funext_iff],[Iff, Function.involutive, Eq, Nat.iterate, OfNat.ofNat, id]]
[Lean.IR.formatFnBody,[Lean.IR.formatFnBody.loop],[Std.Format]]
[Lean.Elab.DerivingHandlerNoArgs,[Lean.Elab.Command.CommandElabM, Bool],[]]
[List.hasDecidableLt.proof_1,[Eq.refl, List.nil, HEq.refl, False],[False]]
[Lean.Elab.Term.MutualClosure.FreeVarMap,[Lean.FVarIdMap, Array, Lean.FVarId],[]]
[Lean.Widget.tagExprInfos,[Lean.Widget.tagExprInfos.go],[Lean.Widget.CodeWithInfos]]
[String.any,[String.anyAux, String.bsize, OfNat.ofNat],[Bool]]
[Lean.Elab.Deriving.Repr.mkMutualBlock,[Bind.bind, ForIn.forIn, Lean.Elab.Deriving.Repr.mkAuxFunction, Pure.pure, PUnit.unit, ForInStep.yield, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[StateCpsT.run',[StateCpsT.runK, Pure.pure],[]]
[PLift.noConfusionType,[],[]]
[Lean.groupKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Mathlib.ExtendedBinder.«binderTerm<_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Tactic.mvBisim,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.binderIdent],[Lean.ParserDescr]]
[Lean.IR.AltCore.setBody,[Lean.IR.Alt, Lean.IR.Alt.ctor, Lean.IR.Alt.default],[Lean.IR.Alt]]
[Lean.Parser.ParserModuleContext.openDecls,[],[List, Lean.OpenDecl]]
[Lean.addBuiltinDeclarationRanges,[ST.Ref.modify, Lean.builtinDeclRanges, Lean.NameMap.insert],[IO, Unit]]
[Lean.Parser.Tactic.squeezeSimp?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Array.swapAt!,[dite, LT.lt, Array.size, Array.swapAt, Fin.mk],[Prod, Array]]
[Array.findRev?,[Id.run, Array.findRevM?],[Option]]
[Lean.Parser.ParserExtension.OLeanEntry.parser.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserExtension.OLeanEntry.parser, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.ParserExtension.OLeanEntry.parser, And]]
[Lean.Elab.Tactic.Conv.getLhsRhs,[Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Elab.Tactic.Conv.getLhsRhsCore],[Lean.Elab.Tactic.TacticM, Prod, Lean.Expr]]
[Lean.Parser.commandParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Formatter]]
[List.join_nil,[rfl],[Eq, List.join, List.nil]]
[Lean.Meta.Contradiction.Config.searchFuel,[],[Nat]]
[Lean.Compiler.SpecArgKind.noConfusion,[noConfusionEnum, Lean.Compiler.SpecArgKind.toCtorIdx],[Lean.Compiler.SpecArgKind.noConfusionType]]
[Nat.lt.base.proof_1,[Nat.le_refl, Nat.succ],[LE.le, Nat.succ]]
[Applicative.noConfusionType,[],[]]
[Lean.Widget.CodeToken.mk.inj,[],[Eq]]
[Lean.Parser.ParserExtension.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.ParserExtension.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Array.toListLitAux.proof_2,[Nat.lt_of_lt_of_eq, Nat.lt_of_lt_of_le, Nat.lt_succ_self],[LT.lt]]
[Lean.EnvExtensionInterfaceUnsafe.setState,[dite, LT.lt, Lean.EnvExtensionInterfaceUnsafe.Ext.idx, Array.size, Lean.Environment.extensions, Lean.Environment.mk, Lean.Environment.const2ModIdx, Lean.Environment.constants, Array.set, Fin.mk, unsafeCast, Lean.Environment.header, panicWithPosWithDecl, OfNat.ofNat],[Lean.Environment]]
[decidable_of_decidable_of_iff.proof_1,[Iff.mp, not_iff_not_of_iff],[Not]]
[of_iff_true,[Iff.mpr, True.intro],[]]
[Lean.Rat.instAddRat,[Add.mk, Lean.Rat.add],[Add, Lean.Rat]]
[Lean.Literal.natVal.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Literal.natVal, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Tactic.ElimApp.Result.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.ElimApp.Result.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Tactic.ElimApp.Result.mk, And]]
[Lean.Parser.ensureBinaryParserAlias,[Functor.discard, Lean.Parser.getBinaryAlias, Lean.Parser.parserAliasesRef],[IO, Unit]]
[«prio(_)»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.SCC.Data.lowlink?,[],[Option, Nat]]
[Lean.Lsp.instToJsonDiagnosticCode,[Lean.ToJson.mk, Lean.Json, Lean.Json.num, Lean.JsonNumber.fromInt, Lean.Json.str],[Lean.ToJson, Lean.Lsp.DiagnosticCode]]
[Lean.IR.CollectMaps.collectDecl,[Lean.IR.Decl.extern, Lean.IR.CollectMaps.Collector, Function.comp, Lean.IR.CollectMaps.collectParams, Lean.IR.CollectMaps.collectFnBody, id],[Lean.IR.CollectMaps.Collector]]
[IO.RealWorld,[Unit],[]]
[Lean.Lsp.FileSource.fileSource,[],[Lean.Lsp.DocumentUri]]
[FloatArray.uget,[Float, Array.uget],[Float]]
[Lean.mkBRecOn,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.MonadEnv.modifyEnv, Lean.throwKernelException, Lean.mkBRecOnImp],[Unit]]
[Lean.Parser.Tactic.unknown.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.errorAtSavedPos.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.RecursorUnivLevelPos.motive.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.RecursorUnivLevelPos.motive, OfNat.ofNat]]
[Sum.inhabitedLeft,[Inhabited.mk, Sum.inl, arbitrary],[Inhabited, Sum]]
[Mathlib.Tactic.Lint.«command#list_linters»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Parser.withOpenDecl,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.withOpenDeclFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.MetavarContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MetavarContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MetavarContext.mk, And]]
[List.nodup,[List.pairwise, Ne],[]]
[bind_pure,[],[Eq, Bind.bind, Pure.pure]]
[Lean.Widget.InteractiveHypothesis.isInstance,[],[Bool]]
[Lean.AddMessageContext.noConfusionType,[],[]]
[Lean.instMonadRecDepthStateRefT',[inferInstanceAs, Lean.MonadRecDepth, ReaderT, ST.Ref],[Lean.MonadRecDepth, StateRefT']]
[Lean.Meta.zetaReduce,[Bind.bind, Lean.MonadLCtx.getLCtx, liftM, Lean.Core.transform, Pure.pure, Lean.TransformStep.done],[Lean.Meta.MetaM, Lean.Expr]]
[ST.Ref.take,[liftM, ST.Prim.Ref.take],[]]
[«term_⁻¹»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[iff_mpr_iff_true_intro,[rfl],[Eq, Iff.mpr, iff_true_intro, True.intro]]
[coeD,[CoeDep.coe],[]]
[Lean.CollectFVars.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.CollectFVars.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.NamePart.noConfusionType,[],[]]
[Lean.MetavarContext.findUserName?,[Std.PersistentHashMap.find?, Lean.MetavarContext.userNames],[Option, Lean.MVarId]]
[Lean.LocalContext.addDecl,[Lean.LocalContext, Lean.LocalContext.mk, Std.PersistentHashMap.insert, Lean.LocalDecl.fvarId, Std.PersistentArray.push, Option.some],[Lean.LocalContext]]
[Lean.IR.Decl.pushProj,[Lean.IR.Decl.extern, Lean.IR.Decl, Lean.IR.Decl.normalizeIds, Lean.IR.Decl.updateBody!, Lean.IR.FnBody.pushProj],[Lean.IR.Decl]]
[Lean.IR.Borrow.getCurrFn,[Bind.bind, MonadReader.read, Pure.pure, Lean.IR.Borrow.BorrowInfCtx.currFn],[Lean.IR.Borrow.M, Lean.IR.FunId]]
[Lean.getTraces,[Bind.bind, Lean.MonadTrace.getTraceState, Pure.pure, Lean.TraceState.traces],[Std.PersistentArray, Lean.TraceElem]]
[Std.Format.line.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Std.Format.line, OfNat.ofNat]]
[And.right_comm,[Eq.mpr, congr, congrArg, Iff, Eq.trans, propext, and_comm, And, And.left_comm, Iff.rfl],[Iff, And]]
[USize.instSemiringUSize.proof_12,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HMul.hMul, USize.add_def, USize.mul_def, USize.mk, HAdd.hAdd, USize.val, USize.eq_of_val_eq, Semiring.add_mul],[Eq, HMul.hMul, HAdd.hAdd]]
[Lean.MessageData.paren,[Lean.MessageData.bracket],[Lean.MessageData]]
[Std.PShareCommonT.run,[StateT.run', Std.ShareCommon.PersistentState.empty],[]]
[unexpandExists,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Lean.Parser.FirstTokens.epsilon.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Parser.FirstTokens.epsilon, OfNat.ofNat]]
[Lean.Parser.Tactic.apply,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.longestMatchFnAux,[Lean.Parser.longestMatchFnAux.parse],[Lean.Parser.ParserFn]]
[IO.Error.mkAlreadyExistsFile,[Function.comp, IO.Error.alreadyExists, Option.some],[IO.Error]]
[Fin.checked_sub_spec,[Iff.intro, Decidable.em, LT.lt, Fin.val, False.elim, Eq.mp, Eq.trans, congrFun, congrArg, Eq, Unit.unit, Bool, Option, Fin, Prod.mk, Iff.mpr, decide_eq_true_iff, HSub.hSub, Option.none, Option.some, Bool.true, Bool.false, eq_false', Eq.symm, Nat.le_of_not_lt, Eq.refl, of_eq_true, decide_eq_false, Nat.not_lt_of_le, eq_true_of_decide],[Iff, Eq, Option.isSome, Fin.checkedSub, Bool.true, LE.le, Fin.val]]
[Lean.Lsp.Position.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.MatcherApp.alts,[],[Array, Lean.Expr]]
[Nat.zero_add,[Unit.unit, Eq, HAdd.hAdd, OfNat.ofNat, rfl, congrArg, Nat.succ, PProd.fst],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Structural.RecArgInfo.ys,[],[Array, Lean.Expr]]
[Lean.IR.Borrow.ParamMap.Key.jp.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Borrow.ParamMap.Key.jp, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Borrow.ParamMap.Key.jp, And]]
[Lean.Meta.Simp.DefaultMethods.methods,[Lean.Meta.Simp.Methods.mk, Lean.Meta.Simp.DefaultMethods.pre, Lean.Meta.Simp.DefaultMethods.post, Lean.Meta.Simp.DefaultMethods.discharge?],[Lean.Meta.Simp.Methods]]
[Std.PersistentHashMap.mod2Shift,[USize.land, HSub.hSub, USize.shiftLeft, OfNat.ofNat],[USize]]
[Lean.Parser.suppressInsideQuotFn,[Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.prec, Lean.Parser.ParserContext.tokens, Lean.Parser.ParserContext.quotDepth, Bool.true, Lean.Parser.ParserContext.savedPos?, Lean.Parser.ParserContext.forbiddenTk?],[Lean.Parser.ParserFn]]
[Lean.Elab.Info.ofTermInfo.inj,[],[Eq]]
[Lean.Elab.FieldInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.rawIdent.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.identKind, Bool.true, Lean.PrettyPrinter.Formatter.rawIdentNoAntiquot.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.checkTailWs,[Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Bool, Lean.Syntax.getTailInfo, Decidable.decide, GT.gt, Substring.stopPos, Substring.startPos, Bool.false],[Bool]]
[Lean.Elab.WF.packMutual,[ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Pure.pure, Array.getOp, Bind.bind, PUnit.unit],[Lean.Meta.MetaM, Lean.Elab.PreDefinition]]
[Lean.Elab.DefViewElabHeader.type,[],[Lean.Expr]]
[Lean.Elab.Term.SavedContext.noConfusionType,[],[]]
[GroupWithZero.toMonoidWithZero,[MonoidWithZero.mk, GroupWithZero.zero_mul, GroupWithZero.mul_zero],[MonoidWithZero]]
[Lean.Lsp.TextDocumentPositionParams.noConfusionType,[],[]]
[«term_<$>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.moduleNameOfFileName,[Bind.bind, IO.FS.realPath, Unit.unit, IO, Lean.Name, Pure.pure, IO.currentDir],[IO, Lean.Name]]
[Mathlib.Tactic.Lint.LintVerbosity.ofNat_toCtorIdx,[Eq.refl, Mathlib.Tactic.Lint.LintVerbosity.low, Mathlib.Tactic.Lint.LintVerbosity.medium, Mathlib.Tactic.Lint.LintVerbosity.high],[Eq, Mathlib.Tactic.Lint.LintVerbosity.ofNat, Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx]]
[Lean.Lsp.instToJsonDiagnosticTag,[Lean.ToJson.mk, Unit.unit, Lean.Json, Lean.Json.num, Lean.JsonNumber.fromNat, OfNat.ofNat],[Lean.ToJson, Lean.Lsp.DiagnosticTag]]
[Lean.Lsp.instToJsonLineRange,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.LineRange.start, List.nil, Lean.Lsp.LineRange.end],[Lean.ToJson, Lean.Lsp.LineRange]]
[right_identity,[Eq],[]]
[Lean.ReducibilityStatus.noConfusionType,[noConfusionTypeEnum, Lean.ReducibilityStatus.toCtorIdx],[]]
[Lean.Name.mkNum,[Lean.Name.num, mixHash, Hashable.hash, dite, LT.lt, UInt64.size, UInt64.ofNatCore, OfNat.ofNat, Lean.Name.mkNum.proof_1],[Lean.Name]]
[Lean.Widget.instInhabitedInteractiveHypothesis,[Inhabited.mk, Lean.Widget.InteractiveHypothesis.mk, arbitrary],[Inhabited, Lean.Widget.InteractiveHypothesis]]
[Lean.ClassState.switch,[Lean.ClassState.mk, Lean.SMap.switch, Lean.ClassState.hasOutParam],[Lean.ClassState]]
[Decidable.not_imp_not,[Iff.intro, Decidable.by_contradiction, mt],[Iff, Not]]
[Lean.Lsp.instFromJsonSaveOptions,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Bool, Pure.pure, Lean.Lsp.SaveOptions.mk],[Lean.FromJson, Lean.Lsp.SaveOptions]]
[Lean.Lsp.PublishDiagnosticsParams.diagnostics,[],[Array, Lean.Lsp.Diagnostic]]
[neg_neg,[neg_eq_of_add_eq_zero, add_left_neg],[Eq, Neg.neg]]
[Lean.Elab.DefView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.DefView.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.DefView.mk, And]]
[Option.format,[Unit.unit, Std.Format, Std.Format.text, HAppend.hAppend, Std.ToFormat.format],[Std.Format]]
[Lean.Parser.Tactic.renameI,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[mul_inv_cancel_right,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Inv.inv, mul_assoc, mul_right_inv, OfNat.ofNat, mul_one, rfl],[Eq, HMul.hMul, Inv.inv]]
[Lean.ConstructorVal.isUnsafeEx,[Lean.ConstructorVal.isUnsafe],[Bool]]
[List.cons_subset_cons,[Or.elim, List.eq_or_mem_of_mem_cons, Or.inl, Or.inr],[Subset.subset, List.cons]]
[List.repeat,[Unit.unit, List, List.nil, List.cons, PProd.fst],[List]]
[Lean.Parser.Command.printAxioms.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Frontend.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Frontend.State.mk, HAdd.hAdd, OfNat.ofNat]]
[hexDigitRepr,[String.singleton, Nat.digitChar],[String]]
[IO.FS.Stream.writeLspResponseError,[IO.FS.Stream.writeLspMessage, Lean.JsonRpc.Message.responseError, Lean.JsonRpc.ResponseError.id, Lean.JsonRpc.ResponseError.code, Lean.JsonRpc.ResponseError.message, Option.none],[IO, Unit]]
[Lean.Expr.withAppAux,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, PProd.fst, Array.set!, HSub.hSub, OfNat.ofNat],[]]
[DoResultPR.pure.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultPR.pure, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.UnexpandM,[EStateM, Unit],[]]
[Lean.Parser.Command.deriving.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.derivingClasses.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.ident.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.instInhabitedState,[Inhabited.mk, Lean.Elab.Term.State.mk, arbitrary],[Inhabited, Lean.Elab.Term.State]]
[Lean.Parser.ParserState.replaceLongest,[Lean.Parser.ParserState.keepLatest],[Lean.Parser.ParserState]]
[Lean.Syntax.setAtomVal,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.atom],[Lean.Syntax]]
[Lean.Parser.ParserCache.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.ParserCache.mk, HAdd.hAdd, OfNat.ofNat]]
[Std.mkHashSetImp.proof_1,[Eq.mpr, Eq.refl, GT.gt, Array.size, Array.mkArray, ite, Eq, OfNat.ofNat, List.nil, Array.size_mkArray, of_decide_eq_true, Bool.true, Eq.symm, Nat.zero_lt_succ],[GT.gt, Array.size, Array.mkArray, ite, Eq, OfNat.ofNat, List.nil]]
[Lean.Elab.Term.Do.Code.joinpoint.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Code.joinpoint, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.Code.joinpoint, And]]
[Lean.Meta.addDefaultInstanceEntry,[Unit.unit, Lean.Meta.DefaultInstances, Lean.NameMap.find?, Lean.Meta.DefaultInstances.defaultInstances, Lean.Meta.DefaultInstanceEntry.className, Lean.Meta.DefaultInstances.mk, Lean.NameMap.insert, List.cons, Prod.mk, Lean.Meta.DefaultInstanceEntry.instanceName, Lean.Meta.DefaultInstanceEntry.priority, Lean.Meta.DefaultInstances.priorities, List.nil],[Lean.Meta.DefaultInstances]]
[Lean.Meta.Closure.MkValueTypeClosureResult.mk.inj,[And.intro],[And, Eq]]
[Lean.MetavarContext.levelMVarToParam,[Lean.MetavarContext.UnivMVarParamResult, Lean.MetavarContext.UnivMVarParamResult.mk, Lean.MetavarContext.LevelMVarToParam.State.mctx, Lean.MetavarContext.LevelMVarToParam.State.paramNames, Lean.MetavarContext.LevelMVarToParam.State.nextParamIdx],[Lean.MetavarContext.UnivMVarParamResult]]
[CommSemiring.noConfusionType,[],[]]
[Lean.ExportM,[StateT, Lean.Export.State, Lean.Core.CoreM],[]]
[Lean.PrettyPrinter.Delaborator.delabLam,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.PrettyPrinter.Delaborator.SubExpr.withBindingDomain, Lean.PrettyPrinter.Delaborator.delab, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPFunBinderTypes, Lean.getPPExplicit, Pure.pure, Array.any, Lean.PrettyPrinter.Delaborator.hasIdent, Lean.Syntax.getId, OfNat.ofNat, Array.size, ite, Eq, not, Bool.true, Unit.unit, Lean.BinderInfo.auxDecl, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Lean.Expr.binderInfo, GT.gt, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Array.get!, Array.append, List.nil, Array.eraseIdx, Array.back, Lean.Syntax.atom, panicWithPosWithDecl],[Lean.PrettyPrinter.Delaborator.Delab]]
[WellFounded.fix_eq,[WellFounded.fixFEq, WellFounded.apply],[Eq, WellFounded.fix]]
[ST.Ref.ptrEq,[liftM, ST.Prim.Ref.ptrEq],[Bool]]
[Lean.Syntax.isStrLit?,[Option.none, Option, String, Lean.Syntax.isLit?, Lean.strLitKind, Lean.Syntax.decodeStrLit],[Option, String]]
[Std.RBNode.any,[Unit.unit, Bool, Bool.false, or, PProd.fst, PProd.snd],[Bool]]
[Nat.le_antisymm,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Eq, rfl, absurd, Nat.lt_of_le_of_lt, Nat.lt_irrefl],[Eq]]
[Lean.Syntax.decodeQuotedChar,[OptionM.run, ite, Eq, BEq.beq, Char.ofNat, Bool.true, Pure.pure, Prod.mk, Bind.bind, and, Decidable.decide, LE.le, Option.some, HSub.hSub, Char.toNat, HAdd.hAdd, OfNat.ofNat, Option.none, OptionM, Prod, Char, String.Pos, HMul.hMul],[Option, Prod, Char, String.Pos]]
[Lean.Parser.nonReservedSymbolFn,[Lean.Parser.nonReservedSymbolFnAux, HAppend.hAppend],[Lean.Parser.ParserFn]]
[Lean.matchConst,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.Environment.find?],[]]
[instSemiringFin.proof_8,[Eq.mpr, congr, congrArg, Eq, Fin.nsmuls_eq, Nat.succ, HAdd.hAdd, Eq.trans, Fin.mk, HMod.hMod, HMul.hMul, Fin.val, Nat.mod_lt, Fin.size_positive', Fin.add_def, Fin.mk.injEq, Fin.size_positive, Nat.add_mod_mod, Nat.succ_mul, Nat.add_comm],[Eq, HMul.hMul, Fin.ofNat', Fin.size_positive, Nat.succ, HAdd.hAdd]]
[Lean.Elab.Term.throwInvalidNamedArg,[Lean.withRef, Lean.Elab.Term.NamedArg.ref, Unit.unit, Lean.Elab.Term.TermElabM, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.Term.NamedArg.name],[Lean.Elab.Term.TermElabM]]
[Lean.Elab.Term.Do.CodeBlock.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.CodeBlock.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.CodeBlock.mk, And]]
[IO.FS.Stream.readLspResponseAs,[MonadExcept.tryCatch, Bind.bind, Unit.unit, IO, Nat, List.lookup, String.toNat?, Pure.pure, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, IO.FS.Stream.readResponseAs],[IO, Lean.JsonRpc.Response]]
[List.leftpad,[HAppend.hAppend, List.repeat, HSub.hSub, List.length],[List]]
[Lean.Parser.ParserContext.tokens,[],[Lean.Parser.TokenTable]]
[Lean.Elab.Term.Do.JPDecl.mk.inj,[And.intro],[And, Eq]]
[Fin.coeToNat,[Coe.mk, Fin.val],[Coe, Fin, Nat]]
[Lean.Meta.simpLocalDecl,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getLocalDecl, Lean.Meta.instantiateMVars, Lean.LocalDecl.type, Lean.Meta.simpStep, Lean.mkFVar, Unit.unit, Lean.Meta.MetaM, Option, Prod, Lean.FVarId, Lean.MVarId, Pure.pure, Option.none, ite, Eq, bne, Bool.true, Lean.Meta.assert, Lean.LocalDecl.userName, Lean.Meta.tryClear, Lean.LocalDecl.fvarId, Lean.Meta.intro1P, Option.some, Prod.mk],[Lean.Meta.MetaM, Option, Prod, Lean.FVarId, Lean.MVarId]]
[Lean.MessageData.instCoeLevelMessageData,[Coe.mk, Lean.MessageData.ofLevel],[Coe, Lean.Level, Lean.MessageData]]
[Lean.Meta.Closure.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Closure.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Closure.Context.mk]]
[Lean.Elab.Term.CollectPatternVars.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.CollectPatternVars.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.instInhabitedException,[Inhabited.mk, Lean.Exception.error, arbitrary],[Inhabited, Lean.Exception]]
[Lean.Meta.intro1Core,[Bind.bind, Lean.Meta.introNCore, OfNat.ofNat, List.nil, Bool.false, Lean.Meta.MetaM, Prod, Lean.FVarId, Lean.MVarId, Pure.pure, Prod.mk, Array.get!],[Lean.Meta.MetaM, Prod, Lean.FVarId, Lean.MVarId]]
[UInt64.instSemiringUInt64.proof_8,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt64.one_def, UInt64.mul_def, UInt64.mk, OfNat.ofNat, mul_one, UInt64.val, UInt64.mk_val_eq, eq_self, propext, forall_const, UInt64],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Meta.isExprMVarAssigned,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.isExprAssigned],[Lean.Meta.MetaM, Bool]]
[UInt8.one_def,[rfl],[Eq, OfNat.ofNat, UInt8.mk]]
[Lean.instBEqLocalInstance,[BEq.mk, BEq.beq, Lean.LocalInstance.fvar],[BEq, Lean.LocalInstance]]
[bfix4,[PProd.fst],[]]
[Subtype.instSetoidSubtype,[Setoid.mk, HasEquiv.Equiv, Subtype.equivalence],[Setoid, Subtype]]
[Lean.IR.EmitC.getModName,[Functor.map, Lean.IR.EmitC.Context.modName, MonadReader.read],[Lean.IR.EmitC.M, Lean.Name]]
[List.mem_cons_self,[Or.inl, rfl],[Mem.mem, List.cons]]
[Equiv.refl.proof_1,[rfl],[Eq, id]]
[Lean.mkLevelParamEx,[Lean.mkLevelParam],[Lean.Level]]
[Lean.Parser.withResultOf,[Lean.Parser.Parser.mk, Lean.Parser.withResultOfInfo, Lean.Parser.Parser.info, Lean.Parser.withResultOfFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.instToExprString,[Lean.ToExpr.mk, Lean.mkStrLit, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.ToExpr, String]]
[Lean.Elab.Command.ElabHeaderResult.view,[],[Lean.Elab.Command.InductiveView]]
[Lean.Elab.Command.elabAuxDef,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Option.some, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Nat.le_of_mod_lt,[Decidable.byContradiction],[LE.le]]
[System.FilePath.instDivFilePath,[Div.mk, System.FilePath.join],[Div, System.FilePath]]
[Lean.instInhabitedKVMap,[Inhabited.mk, Lean.KVMap.mk, arbitrary],[Inhabited, Lean.KVMap]]
[Lean.Parser.isValidSyntaxNodeKind,[Std.PersistentHashMap.contains],[Bool]]
[Lean.Parser.Attr.toAdditiveIgnoreArgs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[mkStdGen,[StdGen.mk, HAdd.hAdd, OfNat.ofNat],[StdGen]]
[Lean.Elab.Term.NamedArg.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.SynthInstance.MkTableKey.State.mk.inj,[And.intro],[And, Eq]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.noConfusionType,[],[]]
[Lean.Meta.Match.MkMatcherInput.mk.inj,[And.intro],[And, Eq]]
[Lean.KernelException.other.injEq,[Eq.propIntro, Eq.refl, Lean.KernelException.other, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KernelException.other]]
[Lean.IR.EmitC.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.EmitC.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Expr.mdataExpr!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Lean.Expr, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[Lean.Meta.instInhabitedCaseValueSubgoal,[Inhabited.mk, Lean.Meta.CaseValueSubgoal.mk, arbitrary],[Inhabited, Lean.Meta.CaseValueSubgoal]]
[Lean.Lsp.DiagnosticWith.fullRange,[],[Lean.Lsp.Range]]
[Lean.Elab.Term.Do.ToTerm.mkJoinPoint,[Lean.withRef, Lean.MonadQuotation.withFreshMacroScope, Bind.bind, Array.mapM, Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax, ite, Eq, Bool.true, Lean.mkIdentFromRef, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadReader.read, Array.append, Array.map, Array.zip, Lean.Elab.Term.Do.ToTerm.Context.m],[Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax]]
[Lean.Level.updateSucc!.proof_1,[rfl],[Eq, Lean.Level.isSucc, Lean.Level.succ]]
[Lean.Widget.GetInteractiveDiagnosticsParams.lineRange?,[],[Option, Lean.Lsp.LineRange]]
[Lean.Lsp.instFromJsonDidOpenTextDocumentParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentItem, Pure.pure, Lean.Lsp.DidOpenTextDocumentParams.mk],[Lean.FromJson, Lean.Lsp.DidOpenTextDocumentParams]]
[instToFormatArray,[Std.ToFormat.mk, HAppend.hAppend, Std.Format.text, Std.ToFormat.format, Array.toList],[Std.ToFormat, Array]]
[Lean.Meta.map1MetaM,[controlAt, Lean.Meta.MetaM, MonadControlT.stM],[]]
[Lean.defaultMaxRecDepth,[OfNat.ofNat],[Nat]]
[Std.PersistentArray.noConfusionType,[],[]]
[decide_false_eq_false,[Eq, Decidable.decide, False, Bool.false, rfl, False.elim],[Eq, Decidable.decide, False, Bool.false]]
[Lean.Parsec.attempt,[Lean.Parsec.ParseResult, Lean.Parsec.ParseResult.success, Lean.Parsec.ParseResult.error],[Lean.Parsec]]
[List.product,[List.bind, List.map, Prod.mk],[List, Prod]]
[Lean.termEval_prio_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[SizeOfRef,[Measure, SizeOf.sizeOf],[]]
[Lean.Elab.Tactic.closeUsingOrAdmit,[Bind.bind, Lean.Elab.Tactic.getUnsolvedGoals, List.nil, Lean.Elab.Tactic.TacticM, Unit, MonadExcept.tryCatch, Lean.Elab.Tactic.focusAndDone, Lean.Elab.logException, liftM, Lean.Elab.admitGoal, Lean.Elab.Tactic.setGoals, Lean.Elab.Tactic.throwNoGoalsToBeSolved],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.Compiler.NumScalarTypeInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Compiler.NumScalarTypeInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.MetavarContext.incDepth,[Lean.MetavarContext.mk, HAdd.hAdd, Lean.MetavarContext.depth, OfNat.ofNat, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Lean.MetavarContext.decls, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment],[Lean.MetavarContext]]
[Lean.AttributeImplCore.applicationTime,[],[Lean.AttributeApplicationTime]]
[Lean.Parser.registerAliasCore,[Bind.bind, liftM, IO.initializing, ite, Eq, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, coe],[IO, Unit]]
[Lean.IR.instBEqArg,[BEq.mk, Lean.IR.Arg.beq],[BEq, Lean.IR.Arg]]
[Lean.Elab.Command.CommandElabCoreM,[ReaderT, Lean.Elab.Command.Context, StateRefT', IO.RealWorld, Lean.Elab.Command.State, EIO],[]]
[Lean.PrettyPrinter.Formatter.decQuotDepth.formatter,[],[Lean.PrettyPrinter.Formatter]]
[ByteArray.isEmpty,[BEq.beq, ByteArray.size, OfNat.ofNat],[Bool]]
[Lean.Parser.Term.funSimpleBinder.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.lookahead.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.simpleBinder.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.PersistentEnvExtension.noConfusionType,[],[]]
[Set.insertUnexpander,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesIdent, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Char.toString,[String.singleton],[String]]
[Lean.explicitBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.bracketedExplicitBinders, Lean.unbracketedExplicitBinders],[Lean.ParserDescr]]
[left_comm,[],[left_commutative]]
[Lean.Elab.PreDefinition.type,[],[Lean.Expr]]
[MProd.snd,[],[]]
[add_right_cancel_iff,[Iff.intro, add_right_cancel, rfl],[Iff, Eq, HAdd.hAdd]]
[Lean.Syntax.getHeadInfo,[Unit.unit, Lean.SourceInfo, Lean.Syntax.getHeadInfo?, Lean.SourceInfo.none],[Lean.SourceInfo]]
[Lean.Elab.Term.Do.Alt.noConfusionType,[],[]]
[max_eq_right,[Eq.mpr, Eq.refl, Eq, max, Eq.symm, max_comm, max_eq_left],[Eq, max]]
[iff_false_intro,[Iff.intro, False.elim],[Iff, False]]
[Subtype.instDecidableEqSubtype.proof_1,[rfl],[Eq, Subtype.mk]]
[Lean.Level.Data.hasMVar,[BEq.beq, UInt64.land, UInt64.shiftRight, OfNat.ofNat],[Bool]]
[Lean.Lsp.Trace.hasToJson,[Lean.ToJson.mk, Unit.unit, Lean.Json, Lean.Json.str],[Lean.ToJson, Lean.Lsp.Trace]]
[USize.mod,[USize.mk, HMod.hMod, USize.val],[USize]]
[StateT.map,[Bind.bind, Prod, Pure.pure, Prod.mk],[StateT]]
[Classical.epsilon,[Subtype.val, Classical.strongIndefiniteDescription],[]]
[Lean.EnvironmentHeader.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.EnvironmentHeader.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.EnvironmentHeader.mk, And]]
[Prod.mk.inj_left,[And.right, Prod.mk.inj],[Function.injective, Prod.mk]]
[Lean.Expr.updateForall!.proof_1,[rfl],[Eq, Lean.Expr.isForall, Lean.Expr.forallE]]
[Lean.Lsp.instInhabitedDiagnosticSeverity,[Inhabited.mk, Lean.Lsp.DiagnosticSeverity.error],[Inhabited, Lean.Lsp.DiagnosticSeverity]]
[Nat.gcd_eq_zero_iff,[Iff.intro, And.intro, Nat.eq_zero_of_gcd_eq_zero_left, Nat.eq_zero_of_gcd_eq_zero_right, Eq.mpr, Eq.refl, Eq, Nat.gcd, OfNat.ofNat, And.left, And.right, Nat.gcd_zero_right],[Iff, Eq, Nat.gcd, OfNat.ofNat, And]]
[Lean.Parser.Tactic.Conv.convErw_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq],[Lean.ParserDescr]]
[Lean.Lsp.WorkDoneProgressBegin.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.WorkDoneProgressBegin.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.WorkDoneProgressBegin.mk, And]]
[List.getLast!,[Unit.unit, panicWithPosWithDecl, OfNat.ofNat, List.getLast, List.cons, List.getLast!.proof_1],[]]
[instInhabitedPNonScalar,[Inhabited.mk, PNonScalar.mk, arbitrary],[Inhabited, PNonScalar]]
[Lean.expandExplicitBindersAux,[Array.size, Lean.expandExplicitBindersAux.loop],[Lean.MacroM, Lean.Syntax]]
[Lean.unifConstraintElem,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.unifConstraint, Lean.ParserDescr.unary, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Subtype.eta,[rfl, Eq.symm, Eq.refl],[Eq, Subtype.mk, Subtype.val]]
[Lean.Parser.Command.whereStructInst.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1Indent.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.Command.whereStructField.parenthesizer, Lean.Parser.optional.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[instOrdBool,[Ord.mk, Bool.false, Unit.unit, Bool.true, Ordering, Ordering.lt, Ordering.gt, Ordering.eq],[Ord, Bool]]
[MonadLift.monadLift,[],[]]
[Lean.ParserDescr.noConfusionType,[],[]]
[Lean.Meta.caseValue,[Bind.bind, Lean.Meta.withMVarContext, Lean.Meta.getMVarTag, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType, Lean.Meta.mkEq, Lean.mkFVar, Lean.Meta.foldPatValue, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.mkAppOptM, List.toArray, List.cons, Option.none, Option.some, List.nil, Lean.Meta.assignExprMVar, Lean.Meta.intro1P, Lean.Expr.mvarId!, Lean.Meta.MetaM, Prod, Lean.Meta.CaseValueSubgoal, Lean.Meta.substCore, Bool.false, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, List.map, Lean.FVarId.name, Lean.Meta.FVarSubst.domain, Pure.pure, PUnit.unit, Prod.mk, Lean.Meta.FVarSubst.mk, Lean.Meta.appendTagSuffix, Lean.Meta.CaseValueSubgoal.mvarId, Prod.fst, Prod.snd],[Lean.Meta.MetaM, Prod, Lean.Meta.CaseValueSubgoal]]
[USize.instRingUSize.proof_5,[USize.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, USize.val, congrFun, HAdd.hAdd, USize.neg_def, USize.add_def, USize.mk, Neg.neg, add_left_neg, USize.zero_def, eq_self, OfNat.ofNat],[Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat]]
[Lean.getExportNameFor,[Lean.ParametricAttribute.getParam, Lean.exportAttr],[Option, Lean.Name]]
[Lean.IR.NormalizeIds.M,[ReaderT, Lean.IR.IndexRenaming, Id],[]]
[Subtype.coe_mk,[rfl],[Eq, Subtype.val, Subtype.mk]]
[Lean.Meta.SimpLemmas.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SimpLemmas.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SimpLemmas.mk, And]]
[Lean.Parser.Term.termReturn,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, Lean.Parser.withPosition, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.checkLineEq, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[UInt8.lt,[LT.lt, UInt8.val],[]]
[Lean.Meta.getStructureName,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Lean.Name, Lean.Expr.getAppFn, Bind.bind, Lean.MonadEnv.getEnv, ite, Eq, Lean.isStructure, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM, Lean.Name]]
[Lean.Occurrences.contains,[Bool, Bool.true, List.contains, not],[Bool]]
[Lean.IR.EmitC.leanMainFn,[],[String]]
[Lean.Meta.Cases.Context.majorTypeIndices,[],[Array, Lean.Expr]]
[Lean.Lsp.instToJsonInitializeParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Lsp.InitializeParams.processId?, Lean.Lsp.InitializeParams.clientInfo?, Lean.Lsp.InitializeParams.rootUri?, Lean.Lsp.InitializeParams.initializationOptions?, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.InitializeParams.capabilities, List.nil, Lean.Lsp.InitializeParams.trace, Lean.Lsp.InitializeParams.workspaceFolders?],[Lean.ToJson, Lean.Lsp.InitializeParams]]
[Lean.Parser.Tactic.nativeDecide,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.nonReservedSymbol, Bool.false],[Lean.Parser.Parser]]
[Lean.KeyedDeclsAttribute.ext,[],[Lean.KeyedDeclsAttribute.Extension]]
[Lean.Meta.SynthInstance.SynthM,[ReaderT, Lean.Meta.SynthInstance.Context, StateRefT', IO.RealWorld, Lean.Meta.SynthInstance.State, Lean.Meta.MetaM],[]]
[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.toPos,[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.curr],[Lean.PrettyPrinter.Delaborator.Pos]]
[Tactic.LibrarySearch.«termLibrarySearch%»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Elab.Term.getDeclName?,[Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Term.Context.declName?],[Lean.Elab.Term.TermElabM, Option, Lean.Name]]
[String.splitOn,[ite, Eq, BEq.beq, Bool.true, List.cons, List.nil, String.splitOnAux, OfNat.ofNat],[List, String]]
[Lean.IR.ExplicitBoxing.BoxingContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.ExplicitBoxing.BoxingContext.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.andthenInfo,[Lean.Parser.ParserInfo.mk, Function.comp, Lean.Parser.ParserInfo.collectTokens, Lean.Parser.ParserInfo.collectKinds, Lean.Parser.FirstTokens.seq, Lean.Parser.ParserInfo.firstTokens],[Lean.Parser.ParserInfo]]
[Lean.Elab.Tactic.evalAssumption,[Lean.Elab.Tactic.liftMetaTactic, Bind.bind, Lean.Meta.assumption, Pure.pure, List.nil],[Lean.Elab.Tactic.Tactic]]
[Lean.instReprMVarId,[Repr.mk, Repr.reprPrec, Lean.MVarId.name],[Repr, Lean.MVarId]]
[Lean.Syntax.isLit?,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Option, String, ite, Eq, and, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Syntax.node, Array.get!, Option.some, Option.none],[Option, String]]
[WellFounded.apply,[WellFounded.apply.proof_1],[Acc]]
[Lean.Parsec.digit,[Lean.Parsec.attempt, Bind.bind, Lean.Parsec.anyChar, ite, And, LE.le, Char.ofNat, Pure.pure, Lean.Parsec.fail, ToString.toString],[Lean.Parsec, Char]]
[List.length',[Unit.unit, Nat, OfNat.ofNat, Nat.succ, PProd.fst],[Nat]]
[Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer,[],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.add_left_cancel_iff,[Iff.intro, Nat.add_left_cancel, Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Eq, HAdd.hAdd, rfl],[Iff, Eq, HAdd.hAdd]]
[Lean.Meta.FVarSubst.empty,[Lean.Meta.FVarSubst.mk],[Lean.Meta.FVarSubst]]
[Hashable.noConfusionType,[],[]]
[Lean.Parser.isQuotableCharForStrInterpolant,[or, BEq.beq, Char.ofNat, Lean.Parser.isQuotableCharDefault],[Bool]]
[Std.Format.MonadPrettyFormat.startTag,[],[Unit]]
[Lean.Meta.SimpLemmas.addDeclToUnfold,[Lean.Meta.SimpLemmas.mk, Lean.Meta.SimpLemmas.pre, Lean.Meta.SimpLemmas.post, Lean.Meta.SimpLemmas.lemmaNames, Std.PersistentHashSet.insert, Lean.Meta.SimpLemmas.toUnfold, Lean.Meta.SimpLemmas.erased],[Lean.Meta.SimpLemmas]]
[Lean.termThrowError__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.CompletionInfo.id.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.CompletionInfo.id, HAdd.hAdd, OfNat.ofNat]]
[Nat.pow_le_pow_of_le_right,[LE.le, HPow.hPow, Nat.succ, Nat.lt_or_eq_or_le_succ, Nat.le_refl, Eq.symm],[LE.le, HPow.hPow]]
[Lean.Parser.Tactic.decide,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.nonReservedSymbol, Bool.false],[Lean.Parser.Parser]]
[Lean.Lsp.DocumentSymbolAux.noConfusionType,[],[]]
[Lean.Parser.checkLineEqFn,[Unit.unit, Lean.Parser.ParserState, Lean.Parser.ParserContext.savedPos?, ite, Eq, BEq.beq, Lean.Position.line, Bool.true, Lean.Parser.ParserState.mkError],[Lean.Parser.ParserFn]]
[Lean.IR.CollectMaps.collectParams,[Array.foldl, Lean.IR.CollectMaps.collectVar, Lean.IR.Param.x, Lean.IR.Param.ty, OfNat.ofNat, Array.size],[Lean.IR.CollectMaps.Collector]]
[MonadLiftT.noConfusionType,[],[]]
[ReaderT.adapt,[],[ReaderT]]
[Lean.Parser.Tactic.truncCases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.binderIdent],[Lean.ParserDescr]]
[cond,[Unit.unit],[]]
[Lean.Lsp.PlainGoalParams.toTextDocumentPositionParams,[],[Lean.Lsp.TextDocumentPositionParams]]
[Nat.sub_lt_sub_left,[Eq.refl, Nat.zero, HEq.refl, LT.lt, HSub.hSub, Eq.mpr, HAdd.hAdd, OfNat.ofNat, Nat.add_sub_add_right, Nat.lt_succ_of_le, Nat.sub_le, PProd.fst, Nat.lt_of_succ_lt_succ],[LT.lt, HSub.hSub]]
[Lean.Elab.Term.registerSyntheticMVar,[modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, List.cons, Lean.Elab.Term.SyntheticMVarDecl.mk, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.IR.AltCore.body,[Lean.IR.FnBody],[Lean.IR.FnBody]]
[Lean.Elab.Level.Context.ref,[],[Lean.Syntax]]
[Lean.Occurrences.pos.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Occurrences.pos, HAdd.hAdd, OfNat.ofNat]]
[Setoid.symm,[Equivalence.symm, Setoid.iseqv],[HasEquiv.Equiv]]
[Lean.Meta.mkFreshLevelMVar,[Bind.bind, Lean.mkFreshMVarId, Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.addLevelMVarDecl, Pure.pure, Lean.mkLevelMVar],[Lean.Meta.MetaM, Lean.Level]]
[Lean.Lsp.TextDocumentRegistrationOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.TextDocumentRegistrationOptions.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.Formatter.pushTokenCore,[ite, Eq, BEq.beq, Substring.dropRightWhile, String.toSubstring, Char.ofNat, Bool.true, Lean.PrettyPrinter.Formatter.push, Std.Format.text, Bind.bind, Lean.PrettyPrinter.Formatter.pushLine, String.trimRight],[Lean.PrettyPrinter.FormatterM, Unit]]
[instHShiftLeft,[HShiftLeft.mk, ShiftLeft.shiftLeft],[HShiftLeft]]
[Lean.Parser.Tactic.tidy,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Command.elabEnd,[Bind.bind, Lean.Elab.Command.getScopes, ite, LT.lt, List.length, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, List.drop, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, ForIn.forIn, PUnit.unit, Lean.popScope, Pure.pure, ForInStep.yield, MonadState.get, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Elab.Command.CommandElab]]
[Lean.Json.CompressWorkItem.arrayElem.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Json.CompressWorkItem.arrayElem, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Simp.SimpLetCase.nondepDepVar.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.Simp.SimpLetCase.nondepDepVar, OfNat.ofNat]]
[Lean.Elab.Tactic.evalIntros,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Lean.Elab.Tactic.liftMetaTactic, Bind.bind, Lean.Meta.intros, Lean.Meta.MetaM, List, Lean.MVarId, Pure.pure, List.cons, List.nil, Lean.Meta.introN, Array.size, Array.toList, Array.map, Lean.Elab.Tactic.getNameOfIdent', Bool.false, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[IO.FS.SystemTime.nsec,[],[UInt32]]
[Nat.mul_sub_right_distrib,[Eq, HMul.hMul, HSub.hSub, of_eq_true, Eq.trans, congr, congrArg, congrFun, Nat.sub_zero, Nat.zero_mul, eq_self, Eq.mpr, Eq.refl, HAdd.hAdd, OfNat.ofNat, Nat.sub_succ, Nat.pred, Nat.mul_pred_left, PProd.fst, Nat.succ_mul, Nat.sub_sub, rfl],[Eq, HMul.hMul, HSub.hSub]]
[Lean.instInhabitedLocalContext,[Inhabited.mk, Lean.LocalContext.mk, arbitrary],[Inhabited, Lean.LocalContext]]
[Lean.Meta.UnificationHintEntry.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.PublishDiagnosticsParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.PublishDiagnosticsParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.PublishDiagnosticsParams.mk, And]]
[Lean.Elab.Command.StructFieldView.rawName,[],[Lean.Name]]
[Quot.liftOn,[Quot.lift],[]]
[Lean.Parser.Term.strictImplicitLeftBracket,[HOrElse.hOrElse, Lean.Parser.atomic, Lean.Parser.group, HAndThen.hAndThen, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Nat.le_of_mul_le_mul_left,[Iff.mp, not_lt, Iff.mpr, not_le, Nat.mul_lt_mul_of_pos_left],[LE.le]]
[Lean.Meta.withLetDecl,[Lean.Meta.map1MetaM, Bind.bind, Lean.mkFreshFVarId, MonadReader.read, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.localInstances, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth, Lean.Meta.isClass?, Unit.unit, Lean.Meta.MetaM, Lean.Meta.withNewLocalInstance],[]]
[Lean.JsonNumber.toString,[dite, Eq, Eq.symm, String, Int.repr, HAppend.hAppend, ToString.toString],[String]]
[Lean.Meta.CongrLemma.noConfusionType,[],[]]
[Lean.Lsp.CancelParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.CancelParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.mkAppB,[Lean.mkApp],[Lean.Expr]]
[and_true,[propext, Iff.intro, And.left, And.intro, trivial],[Eq, And, True]]
[Lean.Expr.updateLambda,[Lean.mkLambda, Lean.Expr.bindingName!],[Lean.Expr]]
[Nat.sub_induction,[PProd.fst],[]]
[Lean.Meta.instInhabitedCache,[Inhabited.mk, Lean.Meta.Cache.mk, arbitrary],[Inhabited, Lean.Meta.Cache]]
[UInt64.instSemiringUInt64.proof_12,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HMul.hMul, UInt64.add_def, UInt64.mul_def, UInt64.mk, HAdd.hAdd, UInt64.val, UInt64.eq_of_val_eq, Semiring.add_mul],[Eq, HMul.hMul, HAdd.hAdd]]
[false_of_true_iff_false,[Iff.mp, trivial],[False]]
[Lean.Parser.Tactic.inductionAlts,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlt],[Lean.ParserDescr]]
[Lean.Meta.Match.Pattern.ctor.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.refl, List.nil, Eq.trans, Eq.symm, List.cons.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Meta.Match.Pattern.ctor, HAdd.hAdd, OfNat.ofNat]]
[Task.Priority.dedicated,[OfNat.ofNat],[Task.Priority]]
[Lean.Declaration.quotDecl.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Declaration.quotDecl, OfNat.ofNat]]
[Lean.Elab.Tactic.ElimApp.Result.noConfusionType,[],[]]
[Lean.Parser.instBEqLeadingIdentBehavior,[BEq.mk, BEq.beq, Lean.Parser.LeadingIdentBehavior.toCtorIdx],[BEq, Lean.Parser.LeadingIdentBehavior]]
[List.decidableBexi.proof_3,[False],[False]]
[Lean.Elab.Term.StructInst.findField?,[List.find?, List.nil, List.cons, Lean.Elab.Term.StructInst.FieldLHS.fieldName, Lean.Elab.Term.StructInst.FieldLHS.fieldIndex, Lean.Elab.Term.StructInst.FieldLHS.modifyOp, Bool, Lean.Elab.Term.StructInst.Field.lhs, BEq.beq, Bool.false],[Option, Lean.Elab.Term.StructInst.Field, Lean.Elab.Term.StructInst.Struct]]
[Lean.Widget.Lean.Widget.CodeToken.instToJsonRpcEncodingPacket,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil],[Lean.ToJson]]
[Lean.Elab.Term.Do.elabDo,[Bind.bind, Lean.Elab.Term.tryPostponeIfNoneOrMVar, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Elab.Term.ExtractMonadResult, Lean.throwError, Lean.ToMessageData.toMessageData, liftM, Pure.pure, HAppend.hAppend, Lean.indentExpr, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, List.nil, Lean.Meta.inferType, Lean.Elab.Term.elabTerm, Option.some, Bool.true, Lean.Meta.assignExprMVar, Lean.Expr.mvarId!, Lean.Elab.Term.ExtractMonadResult.m, Lean.Elab.Term.Do.ToCodeBlock.run, Lean.Elab.liftMacroM, Lean.Elab.Term.Do.ToTerm.run, Lean.Elab.Term.Do.CodeBlock.code, Lean.Elab.Term.Do.ToTerm.Kind.regular, Lean.isTracingEnabledFor, ite, Eq, Lean.addTrace, Lean.MessageData.ofSyntax, PUnit.unit],[Lean.Elab.Term.TermElab]]
[Lean.KernelException.typeExpected.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.typeExpected, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KernelException.typeExpected, And]]
[Lean.Meta.DiscrTree.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.DiscrTree.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.DiscrTree.mk]]
[instToStringString,[ToString.mk],[ToString, String]]
[Lean.IR.instToStringFnBody,[ToString.mk, Std.Format.pretty, Std.ToFormat.format, Std.Format.defWidth],[ToString, Lean.IR.FnBody]]
[Lean.Parser.Tactic.continuity!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Meta.ElimEmptyInductive.instMonadBacktrackSavedStateM,[Lean.MonadBacktrack.mk, liftM, Lean.Meta.saveState, Lean.Meta.SavedState.restore],[Lean.MonadBacktrack, Lean.Meta.SavedState, Lean.Meta.ElimEmptyInductive.M]]
[Lean.Parser.Parser.info,[],[Lean.Parser.ParserInfo]]
[String.toFileMap,[Lean.FileMap.ofString],[Lean.FileMap]]
[Lean.Meta.Contradiction.Config.noConfusionType,[],[]]
[PSigma.lexNdep,[PSigma.Lex],[]]
[Lean.Meta.ApplyNewGoals.all.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.ApplyNewGoals.all, OfNat.ofNat]]
[Lean.EnvExtensionInterface.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.EnvExtensionInterface.mk, Eq.symm, eq_of_heq, HEq.refl, Lean.Environment, IO, Inhabited],[Eq, Lean.EnvExtensionInterface.mk, And, HEq]]
[Lean.IR.Checker.CheckerContext.noConfusionType,[],[]]
[Lean.Elab.Term.mkTermInfo,[Bind.bind, Unit.unit, Lean.Elab.Term.TermElabM, Sum, Lean.Elab.Info, Lean.MVarId, Pure.pure, Sum.inr, Lean.MonadLCtx.getLCtx, Sum.inl, Lean.Elab.Info.ofTermInfo, Lean.Elab.TermInfo.mk, Lean.Elab.ElabInfo.mk, Option.getD],[Lean.Elab.Term.TermElabM, Sum, Lean.Elab.Info, Lean.MVarId]]
[Lean.Meta.Simp.Step.visit.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Simp.Step.visit, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Simp.Step.visit]]
[Inhabited.default,[],[]]
[Lean.IR.instToFormatExpr,[Std.ToFormat.mk, Std.Format, HAppend.hAppend, Std.ToFormat.format, Lean.IR.formatArray, Std.Format.text, ite, Eq, Bool.true],[Std.ToFormat, Lean.IR.Expr]]
[Std.HashSet.toList,[Std.HashSet.fold, List.cons, List.nil],[List]]
[Lean.ConstructorVal.isUnsafe,[],[Bool]]
[Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[Std.Format.indentD,[Std.Format.nestD, HAppend.hAppend, Std.Format.line],[Std.Format]]
[UInt8.ofNat,[UInt8.mk, Fin.ofNat],[UInt8]]
[Lean.Syntax.isEscapedAntiquot,[not, Array.isEmpty, Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat],[Bool]]
[Lean.Meta.isUIntPatLit?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Prod, Lean.Name, Lean.Expr, ite, and, Array.contains, List.toArray, List.cons, Lean.Name.mkStr, List.nil, Lean.Meta.isFinPatLit, Bool.true, Option.some, Prod.mk, Lean.Expr.appArg!, Option.none],[Option, Prod, Lean.Name, Lean.Expr]]
[ReaderT.instMonadReaderT,[Monad.mk],[Monad, ReaderT]]
[Lean.Parser.Term.funBinder.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.PrettyPrinter.Parenthesizer.evalInsideQuot.parenthesizer, Lean.Parser.Term.funBinder.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Mathlib.Tactic.Lint.LintVerbosity.ofNat,[cond, Nat.ble, Nat.beq, Mathlib.Tactic.Lint.LintVerbosity.medium, Mathlib.Tactic.Lint.LintVerbosity.high, Mathlib.Tactic.Lint.LintVerbosity.low],[Mathlib.Tactic.Lint.LintVerbosity]]
[Lean.Parser.Tactic.Conv.«convEnter[__]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.ParserDescr.const, Lean.Parser.Tactic.Conv.enterArg],[Lean.ParserDescr]]
[Int.neg,[Int, Int.negOfNat, Int.ofNat, Nat.succ],[Int]]
[Lean.Lsp.DidOpenTextDocumentParams.textDocument,[],[Lean.Lsp.TextDocumentItem]]
[Lean.Meta.CaseValueSubgoal.noConfusionType,[],[]]
[Lean.Parser.Tactic.applyWith,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Meta.TransparencyMode.noConfusionType,[noConfusionTypeEnum, Lean.Meta.TransparencyMode.toCtorIdx],[]]
[Lean.Elab.Term.LetRecDeclView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LetRecDeclView.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.LetRecDeclView.mk, And]]
[Lean.Meta.markSmartUnfoldingMatch,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Expr]]
[Lean.Expr.FoldConstsImpl.FoldM,[StateM, Lean.Expr.FoldConstsImpl.State],[]]
[Lean.Parser.checkLinebreakBefore,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.checkLinebreakBeforeFn],[Lean.Parser.Parser]]
[Lean.Parser.Syntax.paren.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.syntaxParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.LValResolution.noConfusionType,[],[]]
[Lean.Meta.Match.Example.noConfusionType,[],[]]
[Array.instToStringArray,[ToString.mk, HAppend.hAppend, ToString.toString, Array.toList],[ToString, Array]]
[instReprExcept,[Repr.mk, Std.Format, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg],[Repr, Except]]
[Std.PersistentArrayNode.node.inj,[],[Eq]]
[List.maximum?,[Unit.unit, Option, Option.none, Option.some, List.foldl, max],[Option]]
[Lean.Server.FileWorker.RpcSession.aliveRefs,[],[Std.PersistentHashMap, Lean.Lsp.RpcRef, Prod, Lean.Name, NonScalar]]
[String.Iterator.prevn,[String.Iterator, PProd.fst, String.Iterator.prev],[String.Iterator]]
[Lean.getExternEntryForAux,[Unit.unit, Option, Lean.ExternEntry, Option.none, ite, Eq, BEq.beq, Lean.ExternEntry.backend, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Option.some, PProd.fst],[Option, Lean.ExternEntry]]
[Prod.eq_iff_fst_eq_snd_eq,[Iff, Eq, And, Prod.fst, Prod.snd, of_eq_true, Eq.trans, congrFun, congrArg, Prod.mk.injEq, iff_self],[Iff, Eq, And, Prod.fst, Prod.snd]]
[Std.AssocList.instEmptyCollectionAssocList,[EmptyCollection.mk, Std.AssocList.empty],[EmptyCollection, Std.AssocList]]
[Fin.addOverflows?,[Decidable.decide, LE.le, HAdd.hAdd, Fin.val],[Bool]]
[Int.instInhabitedInt,[Inhabited.mk, Int.ofNat, OfNat.ofNat],[Inhabited, Int]]
[Lean.MetavarContext.MkBinding.State.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.LetRecDeclView.shortDeclName,[],[Lean.Name]]
[Subarray.foldlM,[Array.foldlM, Subarray.as, Subarray.start, Subarray.stop],[]]
[Lean.instInhabitedInternalExceptionId,[Inhabited.mk, Lean.InternalExceptionId.mk, arbitrary],[Inhabited, Lean.InternalExceptionId]]
[Lean.Declaration.defnDecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Declaration.defnDecl, HAdd.hAdd, OfNat.ofNat]]
[UInt8.lor,[UInt8.mk, Fin.lor, UInt8.val],[UInt8]]
[Lean.Elab.Term.ToDepElimPattern.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.ToDepElimPattern.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.repr,[List.asString, Nat.toDigits, OfNat.ofNat],[String]]
[IO.Error.fopenErrorToString,[Unit.unit, String, HAppend.hAppend, String.modify, OfNat.ofNat, Char.toLower, ToString.toString],[String]]
[List.zipWith,[List.nil, List.cons, List, PProd.fst],[List]]
[LawfulApplicative.pure_seq,[],[Eq, Seq.seq, Pure.pure, Functor.map]]
[Lean.IR.Expr.ap.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.ap, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Expr.ap, And]]
[Lean.IR.ExpandResetReuse.mkProjMap,[Lean.IR.Decl.extern, Lean.IR.ExpandResetReuse.ProjMap, Lean.IR.ExpandResetReuse.CollectProjMap.collectFnBody, EmptyCollection.emptyCollection],[Lean.IR.ExpandResetReuse.ProjMap]]
[Std.AssocList.replace,[Unit.unit, Std.AssocList, Std.AssocList.nil, BEq.beq, Std.AssocList.cons, PProd.fst],[Std.AssocList]]
[Lean.Elab.Tactic.ElabSimpArgsResult.ctx,[],[Lean.Meta.Simp.Context]]
[Array.extLit,[Array.ext, Eq.trans, Eq.symm],[Eq]]
[Lean.Parser.Term.doExpr,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.notFollowedByRedefinedTermToken, Lean.Parser.termParser, Lean.Parser.notFollowedBy, HOrElse.hOrElse, Lean.Parser.symbol],[Lean.Parser.Parser]]
[List.cons.inj,[And.intro],[And, Eq]]
[Lean.registerLazyInitExtension,[Bind.bind, Lean.registerEnvExtension, Pure.pure, Option.none, Lean.LazyInitExtension.mk],[IO, Lean.LazyInitExtension]]
[Lean.Meta.cleanup.collectUsed,[Bind.bind, liftM, Lean.Meta.getMVarType', Lean.Meta.cleanup.addUsedFVars, Lean.Meta.cleanup.collectProps, MonadState.get, Pure.pure, Prod.snd],[StateRefT', IO.RealWorld, Prod, Bool, Lean.FVarIdSet, Lean.Meta.MetaM]]
[UInt16.lt,[LT.lt, UInt16.val],[]]
[Lean.Meta.mkCongr,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Meta.mkCongrArg, Lean.Expr.appArg!, Lean.Meta.mkCongrFun, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Option.none, Option.some, Prod.mk, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.eq?, Lean.Expr.arrow?, Lean.Meta.getLevel, Pure.pure, Lean.mkApp8, Lean.mkConst, List.cons, List.nil, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Elab.Term.FunBinders.State.localInsts,[],[Lean.LocalInstances]]
[Lean.Parser.Tactic.filterUpwards,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Std.Format.MonadPrettyFormat.noConfusionType,[],[]]
[Quot.indep,[PSigma.mk, Quot.mk],[PSigma]]
[String.dropRightWhile,[Substring.toString, Substring.dropRightWhile, String.toSubstring],[String]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withLetBody,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.withLetDecl, Lean.PrettyPrinter.Delaborator.SubExpr.descend, OfNat.ofNat, panicWithPosWithDecl],[]]
[let_value_eq,[rfl],[Eq]]
[Lean.Elab.Term.Do.ToCodeBlock.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.ToCodeBlock.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.ToCodeBlock.Context.mk, And]]
[Lean.PrettyPrinter.Parenthesizer.lookahead.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Server.FileWorker.noHighlightKinds,[List.toArray, List.cons, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Array, Lean.SyntaxNodeKind]]
[Lean.Parser.Command.openRenaming.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.ident.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.Command.openRenamingItem.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Tactic.replace',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Parser.Term.letRecDecls.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.sepBy1.formatter, Lean.Parser.Term.letRecDecl.formatter, Lean.Parser.symbol.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.ParserExtension.instInhabitedOLeanEntry,[Inhabited.mk, Lean.Parser.ParserExtension.OLeanEntry.token, arbitrary],[Inhabited, Lean.Parser.ParserExtension.OLeanEntry]]
[and_iff_right_iff_imp,[Iff.intro, And.left, Iff.mpr, and_iff_right_of_imp],[Iff, And]]
[Lean.Xml.Parser.PubidLiteral,[HOrElse.hOrElse, SeqLeft.seqLeft, SeqRight.seqRight, Lean.Parsec.pchar, Char.ofNat, Lean.Parsec.manyChars, Lean.Xml.Parser.PubidChar, Lean.Parsec.attempt, Bind.bind, ite, Eq, Lean.Parsec.fail, Pure.pure],[Lean.Parsec, String]]
[Lean.Parser.darrow,[Lean.Parser.symbol],[Lean.Parser.Parser]]
[Tactic.Ring.Cache.univ,[],[Lean.Level]]
[Lean.Server.Watchdog.handleEdits,[Bind.bind, ST.Ref.modifyGet, Lean.Server.Watchdog.FileWorker.groupedEditsRef, Prod.mk, Option.none, Lean.Server.Watchdog.ServerM, Unit, Pure.pure, Lean.Lsp.VersionedTextDocumentIdentifier.version?, ite, LE.le, Lean.Server.DocumentMeta.version, Lean.Server.Watchdog.OpenDocument.meta, liftM, IO.throwServerError, PUnit.unit],[Lean.Server.Watchdog.ServerM, Unit]]
[Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1],[Trans, LT.lt, LE.le]]
[Lean.Elab.getBetterRef,[Unit.unit, Lean.Syntax, Lean.Syntax.getPos?, Bool.false, List.find?, bne, Lean.Elab.MacroStackElem.before, Option.none],[Lean.Syntax]]
[Lean.Meta.isDefEqOffset,[Bind.bind, Lean.Meta.getConfig, ite, Eq, not, Lean.Meta.Config.offsetCnstrs, Bool.true, Pure.pure, Lean.LBool.undef, Unit.unit, Lean.Meta.MetaM, Lean.LBool, BEq.beq, LT.lt, OfNat.ofNat, Lean.Meta.evalNat, Option.none, Bool, Bool.false, Lean.mkNatLit, Lean.Meta.mkAdd, HSub.hSub, GE.ge, Lean.LBool.false, Bool.toLBool],[Lean.Meta.MetaM, Lean.LBool]]
[Lean.Elab.Term.Do.insertVars,[Array.foldl, Lean.NameSet.insert, OfNat.ofNat, Array.size],[Lean.NameSet]]
[Lean.Elab.Term.StructInst.DefaultFields.M,[ReaderT, Lean.Elab.Term.StructInst.DefaultFields.Context, StateRefT', IO.RealWorld, Lean.Elab.Term.StructInst.DefaultFields.State, Lean.Elab.Term.TermElabM],[]]
[Lean.IR.Arg.alphaEqv,[Lean.IR.Arg.var, Lean.IR.Arg.irrelevant, Unit.unit, Bool, Lean.IR.AlphaEqv.aeqv, Bool.true, Bool.false],[Bool]]
[IO.Process.Stdio.piped.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.Process.Stdio.piped, OfNat.ofNat]]
[Lean.Expr.ReplaceImpl.State.results,[],[Array, Lean.Expr]]
[Lean.Parser.categoryParserFnImpl,[Unit.unit, Lean.Parser.ParserState, Lean.Parser.getCategory, Lean.Parser.prattParser, Lean.Parser.ParserCategory.tables, Lean.Parser.ParserCategory.behavior, Lean.Parser.Parser.fn, Lean.Parser.mkCategoryAntiquotParser, Lean.Parser.ParserState.mkUnexpectedError, HAppend.hAppend, ToString.toString, List.nil],[Lean.Parser.ParserFn]]
[Lean.Json.getInt?,[Lean.Json.null, Lean.Json.bool, dite, Eq, Eq.symm, Lean.Json.num, Lean.JsonNumber.mk, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Except, String, Int, Pure.pure, MonadExcept.throw],[Except, String, Int]]
[Lean.Elab.Term.LetRecToLift.lctx,[],[Lean.LocalContext]]
[Function.involutive.ite_not,[Eq.mpr, Eq.refl, Eq, ite, Not, apply_ite, ite_not, rfl],[Eq, ite, Not]]
[Lean.Elab.Frontend.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Frontend.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Frontend.State.mk, And]]
[Lean.getStructureLikeNumFields,[Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, dite, Eq, Lean.ConstantInfo.inductInfo, Lean.InductiveVal.mk, Lean.ConstantVal.mk, List.nil, List.cons, Bool.true, Eq.symm, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Nat, Lean.Environment.find?, OfNat.ofNat],[Nat]]
[gsmul_rec,[nsmul_rec, Neg.neg, Nat.succ],[]]
[Lean.Meta.withAssignableSyntheticOpaque,[Lean.Meta.withConfig, Lean.Meta.Config.mk, Lean.Meta.Config.foApprox, Lean.Meta.Config.ctxApprox, Lean.Meta.Config.quasiPatternApprox, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Bool.true, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct],[]]
[Std.HashMapImp.buckets,[],[Std.HashMapBucket]]
[Lean.Elab.Command.Scope.mk.inj,[And.intro],[And, Eq]]
[Nat.dvd_antisymm,[dite, Eq, Nat.zero, Eq.symm, Nat.succ, Nat.eq_zero_of_zero_dvd, Nat.le_antisymm, Nat.le_of_dvd, Nat.succ_pos],[Eq]]
[Lean.Elab.Term.elabBinRelCore.toBoolIfNecessary,[ite, Eq, Bool.true, Bind.bind, liftM, Lean.Meta.inferType, Lean.Meta.withNewMCtxDepth, Lean.Meta.isDefEq, Lean.mkSort, Lean.levelZero, Lean.Elab.Term.ensureHasType, Option.some, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Option.none, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Lean.Elab.Tactic.Location.targets.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Tactic.Location.targets, HAdd.hAdd, OfNat.ofNat]]
[Std.Range.start,[],[Nat]]
[Int.eq_x_or_neg,[Exists.intro, Int.natAbs, Int.natAbs_eq],[Exists, Or, Eq, Int.ofNat, Neg.neg]]
[Lean.Parser.manyIndent.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.many.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGe.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.Borrow.ParamMap.Key.decl.inj,[],[Eq]]
[Lean.instInhabitedEnvExtensionInterface,[Inhabited.mk, Lean.EnvExtensionInterface.mk, id, Pure.pure, List.toArray, List.nil],[Inhabited, Lean.EnvExtensionInterface]]
[Lean.Widget.InteractiveGoal.noConfusionType,[],[]]
[String.toLower,[String.map, Char.toLower],[String]]
[Lean.Lsp.DeclarationParams.mk.inj,[],[Eq]]
[Or.comm,[Iff.intro, Or.symm],[Iff, Or]]
[Lean.Parser.hexNumberFn,[Lean.Parser.mkNodeToken, Lean.numLitKind],[Lean.Parser.ParserFn]]
[Lean.Elab.TacticInfo.format,[Bind.bind, Lean.Elab.ContextInfo.ppGoals, Lean.Elab.TacticInfo.goalsBefore, Lean.Elab.TacticInfo.goalsAfter, Pure.pure, HAppend.hAppend, Std.ToFormat.format, ite, Eq, Lean.Name.isAnonymous, Lean.Elab.ElabInfo.elaborator, Bool.true, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Std.Format, Lean.Elab.ElabInfo.stx, Lean.Elab.TacticInfo.toElabInfo],[IO, Std.Format]]
[«stx_,+»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[Lean.Level.mkNaryMax,[Unit.unit, List.cons, Lean.Level, Lean.levelZero, Lean.mkLevelMax', PProd.fst],[Lean.Level]]
[instOrdInt,[Ord.mk, compareOfLessAndEq],[Ord, Int]]
[Lean.Expr.FindImpl.visited.proof_2,[lcProof],[LT.lt, USize.toNat, HMod.hMod, ptrAddrUnsafe, Array.size, Lean.Expr.FindImpl.State.keys]]
[Lean.LBool.true.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.LBool.true, OfNat.ofNat]]
[Lean.Parser.Command.setupTacticParser,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Nat.coprime_one_left,[Nat.gcd_one_left],[Nat.coprime, OfNat.ofNat]]
[OptionT.fail,[OptionT.mk, Pure.pure, Option.none],[OptionT]]
[Lean.Elab.Command.instMonadRecDepthCommandElabM,[Lean.MonadRecDepth.mk, MonadWithReader.withReader, Lean.Elab.Command.Context.mk, Lean.Elab.Command.Context.fileName, Lean.Elab.Command.Context.fileMap, Lean.Elab.Command.Context.cmdPos, Lean.Elab.Command.Context.macroStack, Lean.Elab.Command.Context.currMacroScope, Lean.Elab.Command.Context.ref, Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Command.Context.currRecDepth, MonadState.get, Lean.Elab.Command.State.maxRecDepth],[Lean.MonadRecDepth, Lean.Elab.Command.CommandElabM]]
[Prod.swap_right_inverse,[Prod.swap_swap],[Function.right_inverse, Prod.swap]]
[Lean.Meta.ToHide.moveToHiddeProp,[modify, Lean.Meta.ToHide.State.mk, Std.RBTree.insert, Lean.Meta.ToHide.State.hiddenInaccessibleProp, Std.RBTree.erase, Lean.Meta.ToHide.State.hiddenInaccessible, Bool.true],[Lean.Meta.ToHide.M, Unit]]
[Lean.Level.updateMax,[Lean.mkLevelMax'],[Lean.Level]]
[HEq.subst,[HEq.ndrecOn],[]]
[UInt64.instSemiringUInt64.proof_7,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt64.one_def, UInt64.mul_def, UInt64.mk, OfNat.ofNat, one_mul, UInt64.val, UInt64.mk_val_eq, eq_self, propext, forall_const, UInt64],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.PrettyPrinter.Parenthesizer.State.trailCat,[],[Lean.Name]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.hasMVarAtCurrDepth,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Option.isSome, Lean.Expr.findMVar?, Option.none, Bool, Lean.MetavarContext.findDecl?, BEq.beq, Lean.MetavarDecl.depth, Lean.MetavarContext.depth, Bool.false],[Lean.Meta.MetaM, Bool]]
[Lean.Meta.mkMul,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getDecLevel, Lean.Meta.synthInstance, Lean.mkApp3, Lean.mkConst, List.cons, List.nil, Option.none, Pure.pure, Lean.mkApp6, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Core.State.env,[],[Lean.Environment]]
[Lean.Elab.Term.Do.ToCodeBlock.doReturnToCode,[Lean.withRef, Bind.bind, Lean.Elab.Term.Do.ToCodeBlock.ensureEOS, ite, Eq, Lean.Syntax.isNone, Bool.true, Lean.Elab.liftMacroM, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Elab.Term.Do.ToCodeBlock.M, Lean.Elab.Term.Do.CodeBlock]]
[Lean.Elab.Command.StructFieldInfo.value?,[],[Option, Lean.Expr]]
[Lean.Lsp.instFromJsonServerCapabilities,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, Lean.Lsp.TextDocumentSyncOptions, Lean.Lsp.CompletionOptions, Bool, Lean.Lsp.SemanticTokensOptions, Pure.pure, Lean.Lsp.ServerCapabilities.mk],[Lean.FromJson, Lean.Lsp.ServerCapabilities]]
[instAddUInt32,[Add.mk, UInt32.add],[Add, UInt32]]
[Lean.Parser.Term.noindex.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.CheckAssignment.State.mk.inj,[],[Eq]]
[Lean.Meta.Match.Alt.noConfusionType,[],[]]
[Lean.Elab.Term.expandMatchAltsWhereDecls,[Array.size, List.toArray, List.nil, Lean.Elab.Term.expandMatchAltsWhereDecls.loop],[Lean.MacroM, Lean.Syntax]]
[Lean.IR.findDecl,[Bind.bind, MonadState.get, Pure.pure, Lean.IR.findEnvDecl, Lean.IR.CompilerState.env],[Lean.IR.CompilerM, Option, Lean.IR.Decl]]
[Lean.Widget.MsgToInteractive.indent,[],[Nat]]
[Lean.Expr.isConstructorApp,[Option.isSome, Lean.Expr.isConstructorApp?],[Bool]]
[Lean.Parser.Command.declaration.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Command.declModifiers.parenthesizer, Bool.false, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.abbrev.parenthesizer, Lean.Parser.Command.def.parenthesizer, Lean.Parser.Command.theorem.parenthesizer, Lean.Parser.Command.constant.parenthesizer, Lean.Parser.Command.instance.parenthesizer, Lean.Parser.Command.axiom.parenthesizer, Lean.Parser.Command.example.parenthesizer, Lean.Parser.Command.inductive.parenthesizer, Lean.Parser.Command.classInductive.parenthesizer, Lean.Parser.Command.structure.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Term.doDbgTrace.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.interpolatedStr.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[List.getLast?.proof_1,[],[List.noConfusionType, False, List.cons, List.nil]]
[Lean.IR.EmitC.emitSSet,[Unit.unit, Lean.IR.IRType.usize, Lean.IR.IRType.irrelevant, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.struct, Lean.IR.IRType.union, Lean.IR.EmitC.M, Unit, Bind.bind, Lean.IR.EmitC.emit, MonadExcept.throw],[Lean.IR.EmitC.M, Unit]]
[Nat.mul_lt_mul_of_pos_right,[Nat.mul_lt_mul_of_pos_left, Nat.mul_comm],[LT.lt, HMul.hMul]]
[Array.extract,[Array.ofSubarray, Array.toSubarray],[Array]]
[System.Platform.numBits_eq,[Subtype.property, System.Platform.getNumBits, Unit.unit],[Or, Eq, System.Platform.numBits, OfNat.ofNat]]
[Nat.le_of_dvd,[LE.le, Eq.mpr, Eq.refl, HMul.hMul, False.elim, Eq.mp, Eq.trans, congrArg, LT.lt, OfNat.ofNat, Nat.mul_zero, eq_false_of_decide, Bool.false, Nat.succ, Nat.mul_one],[LE.le]]
[Lean.trace,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, Unit.unit, Pure.pure, PUnit.unit],[Unit]]
[Or.elim,[],[]]
[Lean.MessageData.bracket,[Lean.MessageData.group, Lean.MessageData.nest, String.length, HAppend.hAppend, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format],[Lean.MessageData]]
[Lean.Meta.ParamInfo.binderInfo,[],[Lean.BinderInfo]]
[Lean.Meta.TransparencyMode.all.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.TransparencyMode.all, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.withMDataOptions,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, MonadReader.read, Lean.PrettyPrinter.Delaborator.SubExpr.getPos, ForIn.forIn, ForInStep, Lean.PrettyPrinter.Delaborator.OptionsPerPos, ite, Eq, Lean.Name.isPrefixOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, MonadWithReader.withReader, Lean.PrettyPrinter.Delaborator.Context.mk, Lean.PrettyPrinter.Delaborator.Context.defaultOptions, Lean.PrettyPrinter.Delaborator.Context.currNamespace, Lean.PrettyPrinter.Delaborator.Context.openDecls, Lean.PrettyPrinter.Delaborator.Context.inPattern, Lean.PrettyPrinter.Delaborator.Context.subExpr, Lean.PrettyPrinter.Delaborator.SubExpr.withMDataExpr],[Lean.PrettyPrinter.Delaborator.DelabM]]
[Lean.Macro.instInhabitedMethodsRef,[Inhabited.mk, Lean.Macro.mkMethods, arbitrary],[Inhabited, PointedType.type]]
[Nat.dvd_mod_iff,[Eq.mp, Eq.refl, Iff, Dvd.dvd, HMod.hMod, HAdd.hAdd, HMul.hMul, HDiv.hDiv, Nat.mod_add_div],[Iff, Dvd.dvd, HMod.hMod]]
[Lean.PrettyPrinter.ppTerm,[Bind.bind, Lean.MonadOptions.getOptions, Lean.PrettyPrinter.parenthesizeTerm, Lean.PrettyPrinter.formatTerm],[Lean.Core.CoreM, Std.Format]]
[Function.right_inverse.id,[funext],[Eq, Function.comp, id]]
[Std.PersistentHashMap.Node.collision.inj,[And.intro],[And, Eq]]
[Nat.mul_pos,[],[GT.gt, HMul.hMul, OfNat.ofNat]]
[Lean.Elab.Term.LValResolution.localRec.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LValResolution.localRec, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.LValResolution.localRec, And]]
[Lean.Widget.Lean.Widget.MsgToInteractive.instToJsonRpcEncodingPacket,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil],[Lean.ToJson]]
[Lean.EnvExtensionInterface.ext,[],[]]
[Lean.Elab.Term.StructInst.FieldVal.nested.inj,[],[Eq]]
[Lean.Meta.Cache.funInfo,[],[Lean.Meta.FunInfoCache]]
[Lean.Server.Snapshots.instInhabitedSnapshot,[Inhabited.mk, Lean.Server.Snapshots.Snapshot.mk, arbitrary],[Inhabited, Lean.Server.Snapshots.Snapshot]]
[Lean.Elab.InfoTree.hole.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.InfoTree.hole, HAdd.hAdd, OfNat.ofNat]]
[OrOp.noConfusionType,[],[]]
[Lean.OptionDecl.noConfusionType,[],[]]
[Lean.Meta.CongrArgKind.cast.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.CongrArgKind.cast, OfNat.ofNat]]
[le_of_eq,[le_refl],[LE.le]]
[Lean.Meta.SynthInstance.tryResolveCore,[Bind.bind, Lean.Meta.instantiateMVars, Lean.Meta.hasAssignableMVar, ite, Eq, not, Bool.true, Lean.MonadMCtx.getMCtx, Pure.pure, Option.some, Prod.mk, List.nil, PUnit.unit],[Lean.Meta.MetaM, Option, Prod, Lean.MetavarContext, List, Lean.Expr]]
[Lean.Lsp.DocumentHighlight.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.DocumentHighlight.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.DocumentHighlight.mk, And]]
[iff_iff_eq,[Iff.intro, propext, iff_of_eq],[Iff, Eq]]
[Std.PersistentHashMap.getOp,[Std.PersistentHashMap.find?],[Option]]
[Lean.Parser.Term.prop,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Meta.Config.foApprox,[],[Bool]]
[Bool.toUInt64,[ite, Eq, Bool.true, OfNat.ofNat],[UInt64]]
[Lean.Expr.isProj,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Bool, Bool.true, Bool.false],[Bool]]
[UInt64.sub_def,[rfl],[Eq, HSub.hSub, UInt64.mk, UInt64.val]]
[Lean.Parser.FirstTokens.noConfusionType,[],[]]
[ByteSlice.forIn.loop,[WellFounded.fix, Nat.Up.WF, dite, LT.lt, Bind.bind, ByteArray.get!, Pure.pure, HAdd.hAdd, OfNat.ofNat, Nat.Up.next],[]]
[IO.Error.invalidArgument.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.invalidArgument, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.invalidArgument, And]]
[Nat.pred_lt_pred,[Eq.refl, Nat.zero, HEq.refl, LT.lt, Nat.pred, False.elim, rfl, Nat.lt_of_succ_lt_succ],[LT.lt, Nat.pred]]
[Nat.lt_of_lt_of_le,[Nat.le_trans],[LT.lt]]
[Lean.Lsp.PlainGoal.goals,[],[Array, String]]
[Lean.Server.FileWorker.GoToKind.noConfusion,[noConfusionEnum, Lean.Server.FileWorker.GoToKind.toCtorIdx],[Lean.Server.FileWorker.GoToKind.noConfusionType]]
[Lean.Elab.ContextInfo.toPPContext,[Lean.PPContext.mk, Lean.Elab.ContextInfo.env, Lean.Elab.ContextInfo.mctx, Lean.Elab.ContextInfo.options, Lean.Elab.ContextInfo.currNamespace, Lean.Elab.ContextInfo.openDecls],[Lean.PPContext]]
[Lean.Parser.Command.macroTailTactic.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.identEq.parenthesizer, Lean.Name.mkSimple, Lean.Parser.darrow.parenthesizer, Lean.Parser.Command.macroRhs.parenthesizer, Lean.Parser.Tactic.seq1.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Command.openOnly,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.ident, Lean.Parser.symbol, Lean.Parser.many1],[Lean.Parser.Parser]]
[Lean.Meta.SynthInstance.Answer.mk.inj,[And.intro],[And, Eq]]
[Lean.Widget.goalToInteractive.ppVars,[ite, Eq, Std.RBTree.contains, Lean.LocalDecl.fvarId, Bool.true, Bind.bind, Lean.Widget.goalToInteractive.pushPending, Lean.Meta.instantiateMVars, Lean.LocalDecl.type, Lean.Widget.addInteractiveHypothesis, List.toArray, List.nil, Option.none, Pure.pure, Prod.mk, Lean.Meta.MetaM, Prod, Array, Lean.Name, Option, Lean.Expr, Lean.Widget.InteractiveHypothesis, or, BEq.beq, Option.some, Array.push, List.cons],[Lean.Meta.MetaM, Prod, Array, Lean.Name, Option, Lean.Expr, Lean.Widget.InteractiveHypothesis]]
[Nat.exists_eq_succ_of_ne_zero,[Exists.intro, Nat.pred, Or.resolve_left, Nat.eq_zero_or_eq_succ_pred],[Exists, Eq, Nat.succ]]
[List.mem_singleton_self,[List.mem_cons_self, List.nil],[Mem.mem, List.cons, List.nil]]
[Lean.Parser.antiquotNestedExpr.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.symbolNoAntiquot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.decQuotDepth.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Command.declId.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.UnificationConstraint.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.UnificationConstraint.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.matchConstCtor,[Lean.matchConst, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo, Unit.unit],[]]
[Lean.Meta.Match.Unify.Context.mk.inj,[],[Eq]]
[Nat.eq_zero_of_nonpos,[Unit.unit, Eq, OfNat.ofNat, rfl, absurd, Nat.zero_lt_succ],[Eq, OfNat.ofNat]]
[String.foldl,[String.foldlAux, String.bsize, OfNat.ofNat],[]]
[Lean.PrefixTree.find?,[Lean.PrefixTreeNode.find?, Subtype.val],[Option]]
[Lean.IR.mkIf,[Lean.IR.FnBody.case, Lean.Name.mkStr, Lean.Name.anonymous, Lean.IR.IRType.uint8, List.toArray, List.cons, Lean.IR.Alt.ctor, Lean.IR.CtorInfo.mk, OfNat.ofNat, List.nil],[Lean.IR.FnBody]]
[stdNext,[Prod, Nat, StdGen, Prod.mk, Int.toNat, StdGen.mk],[Prod, Nat, StdGen]]
[Subrelation,[],[]]
[Lean.Meta.isListLevelDefEqAux,[Unit.unit, List.nil, List.cons, Lean.Meta.MetaM, Bool, Pure.pure, Bool.true, andM, Lean.Meta.isLevelDefEqAux, PProd.fst, Bool.false],[Lean.Meta.MetaM, Bool]]
[Lean.Widget.TaggedText.stripTags,[List.toArray, List.cons, List.nil, Lean.Widget.TaggedText.stripTags.go],[String]]
[Array.findIdxM?,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, ite, Eq, Bool.true, Pure.pure, ForInStep.done, Option.some, PUnit.unit, Unit.unit, Option, Nat, MProd.fst],[Option, Nat]]
[Lean.Parser.Term.falseVal.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.nonReservedSymbol.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.ReduceMatcherResult.stuck.inj,[],[Eq]]
[Nat.le_succ_of_pred_le,[Unit.unit, LE.le, Nat.succ, Nat.zero_le, Nat.succ_le_succ],[LE.le, Nat.succ]]
[Lean.belowSuffix,[],[String]]
[Lean.HeadIndex.fvar.inj,[],[Eq]]
[Lean.Parser.Term.matchAlts.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.ppDedent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.many1Indent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.Parser.Term.matchAlt.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[IO.Process.StdioConfig.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.Position.line,[],[Nat]]
[UInt16.xor,[UInt16.mk, Fin.xor, UInt16.val],[UInt16]]
[min_self,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, if_t_t, LE.le, eq_self],[Eq, min]]
[Set.diff,[setOf, And, Mem.mem, Not],[Set]]
[Lean.Compiler.isEagerLambdaLiftingName,[Lean.Name.anonymous, Bool, or, String.isPrefixOf, PProd.fst, Bool.false],[Bool]]
[Lean.Lsp.TextDocumentIdentifier.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.TextDocumentIdentifier.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.TextDocumentIdentifier.mk]]
[Lean.PPFns.noConfusionType,[],[]]
[Lean.Parser.Term.explicitBinder.parenthesizer,[Lean.Parser.ppGroup.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.Parser.Term.binderType.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.binderTactic.parenthesizer, Lean.Parser.Term.binderDefault.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.DocumentFilter.language?,[],[Option, String]]
[Lean.Compiler.SpecializeAttributeKind.noConfusion,[noConfusionEnum, Lean.Compiler.SpecializeAttributeKind.toCtorIdx],[Lean.Compiler.SpecializeAttributeKind.noConfusionType]]
[Lean.Compiler.foldNatSucc,[OptionM.run, Bind.bind, Lean.Compiler.getNumLit, Pure.pure, Lean.mkRawNatLit, HAdd.hAdd, OfNat.ofNat],[Option, Lean.Expr]]
[Lean.Meta.IndPredBelow.proveBrecOn.induction,[Bind.bind, Array.mapIdxM, Lean.Meta.IndPredBelow.Context.motives, Lean.Meta.MetaM, Lean.Expr, Lean.Meta.instantiateForall, Lean.Meta.forallTelescopeReducing, Lean.Meta.mkLambdaFVars, Lean.mkAppN, Lean.mkConst, Array.getOp, Lean.Meta.IndPredBelow.Context.belowNames, Fin.val, HAppend.hAppend, Bool.false, Bool.true, Lean.getConstInfo, Lean.mkRecName, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Pure.pure, Lean.ConstantInfo.name, Lean.Meta.apply],[Lean.Meta.MetaM, List, Lean.MVarId]]
[StateT.run_pure,[rfl],[Eq, StateT.run, Pure.pure, Prod.mk]]
[Lean.BinderInfo.default.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.BinderInfo.default, OfNat.ofNat]]
[Lean.PrettyPrinter.Parenthesizer.tactic.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.maybeParenthesize, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false, Lean.Unhygienic.run, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.PrettyPrinter.Parenthesizer.parenthesizeCategoryCore],[Lean.PrettyPrinter.CategoryParenthesizer]]
[Subtype.coind_bijective,[And.intro, Subtype.coind_injective, And.left, Subtype.coind_surjective, And.right],[Function.bijective, Subtype.coind]]
[Lean.Elab.Term.Do.getLetIdDeclVar,[Lean.Syntax.getId, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Name]]
[Lean.ProjectionFunctionInfo.fromClass,[],[Bool]]
[Lean.Lsp.TextDocumentEdit.noConfusionType,[],[]]
[Lean.Parser.Tactic.rsimp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Elab.Term.PatternVar.localVar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.PatternVar.localVar, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.open,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.openDecl, Lean.Parser.withOpenDecl, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.Parser.Tactic.Conv.ring,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[List.countp,[Unit.unit, Nat, OfNat.ofNat, ite, Nat.succ, PProd.fst],[Nat]]
[Lean.Elab.Tactic.evalInduction,[Lean.Elab.Tactic.focus, Bind.bind, Lean.Elab.Tactic.withMainContext, Array.mapM, Lean.Elab.Tactic.elabTerm, Option.none, Bool.false, Lean.Syntax.getSepArgs, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, Array.all, Lean.Expr.isFVar, Array.size, Bool.true, Pure.pure, Lean.Elab.Tactic.liftMetaTacticAux, Lean.Meta.generalize, Array.map, Lean.Meta.GeneralizeArg.mk, Lean.Meta.MetaM, Prod, Array, Lean.Expr, List, Lean.MVarId, Prod.mk, Lean.mkFVar, List.cons, List.nil, Lean.Syntax.isNone, BEq.beq, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.withRef, Lean.Elab.resolveGlobalConstNoOverloadWithInfo, liftM, Lean.Meta.getElimInfo, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.getMainGoal, Lean.MonadMCtx.getMCtx, Lean.Elab.Tactic.getUnsolvedGoals, Lean.MonadRef.getRef, Lean.Elab.Tactic.mkTacticInfo, Lean.Meta.getMVarTag, Lean.Meta.withMVarContext, Lean.Meta.addImplicitTargets, List.toArray, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.Meta.mkGeneralizationForbiddenSet, EmptyCollection.emptyCollection, Lean.Meta.getFVarSetToGeneralize, ForIn.forIn, Std.RBTree.contains, Lean.indentExpr, Lean.Meta.sortFVarIds, Std.RBTree.toArray, Lean.Meta.revert, Nat, Lean.Elab.Tactic.ElimApp.mkElimApp, Lean.Meta.inferType, Array.getOp, Lean.Meta.ElimInfo.motivePos, Lean.Elab.Tactic.ElimApp.setMotiveArg, Lean.Expr.mvarId!, Lean.Meta.assignExprMVar, Lean.Elab.Tactic.ElimApp.Result.elimApp, Lean.Elab.Tactic.ElimApp.evalAlts, Lean.Elab.Tactic.ElimApp.Result.alts, Lean.Elab.Tactic.appendGoals, Array.toList, Lean.Elab.Tactic.ElimApp.Result.others, Lean.Elab.Tactic.evalInduction.checkTargets],[Lean.Elab.Tactic.Tactic]]
[Lean.KVMap.empty,[Lean.KVMap.mk],[Lean.KVMap]]
[associative,[Eq],[]]
[Lean.Meta.CaseValuesSubgoal.subst,[],[Lean.Meta.FVarSubst]]
[Lean.addMainModuleDoc,[Lean.PersistentEnvExtension.addEntry],[Lean.Environment]]
[Lean.Server.Watchdog.GroupedEdits.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Command.print.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.strLit.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.SimplePersistentEnvExtensionDescr.name,[],[Lean.Name]]
[IO.FS.FileType.noConfusion,[noConfusionEnum, IO.FS.FileType.toCtorIdx],[IO.FS.FileType.noConfusionType]]
[Lean.Meta.compatibleCtors,[Bind.bind, Lean.getConstInfoCtor, ite, Eq, bne, Lean.ConstructorVal.induct, Bool.true, Pure.pure, Bool.false, Lean.Meta.forallMetaTelescope, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, Lean.MetavarKind.natural, Lean.Meta.MetaM, Bool, Lean.Meta.isDefEq],[Lean.Meta.MetaM, Bool]]
[Lean.instToJsonList,[Lean.ToJson.mk, Lean.ToJson.toJson, List.toArray],[Lean.ToJson, List]]
[Lean.Server.instRpcEncoding,[Lean.Server.RpcEncoding.mk, Pure.pure],[Lean.Server.RpcEncoding]]
[Lean.KVMap.instToStringKVMap,[ToString.mk, ToString.toString, Lean.KVMap.entries],[ToString, Lean.KVMap]]
[Lean.Syntax.hasArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Bool, Decidable.decide, GT.gt, Array.size, OfNat.ofNat, Bool.false],[Bool]]
[Lean.KernelException.exprTypeMismatch.inj,[And.intro],[And, Eq]]
[Array.binSearchContains,[ite, LT.lt, Array.size, Array.binSearchAux, Option.isSome, Bool.false],[Bool]]
[Lean.Elab.Tactic.evalUnknown,[Bind.bind, Lean.Elab.Tactic.getGoals, Lean.Elab.addCompletionInfo, Lean.Elab.CompletionInfo.tactic],[Lean.Elab.Tactic.Tactic]]
[GroupWithZero.toZero,[],[Zero]]
[Lean.Parser.Attr.macro.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.instToJsonStaticRegistrationOptions,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Lsp.StaticRegistrationOptions.id?, List.nil],[Lean.ToJson, Lean.Lsp.StaticRegistrationOptions]]
[Lean.Elab.Deriving.instBinderF,[Lean.Parser.Term.instBinder],[Lean.Parser.Parser]]
[Lean.Elab.Term.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Context.mk, And]]
[Lean.NameHashSet.contains,[Std.HashSet.contains],[Bool]]
[FloatArray.data,[],[Array, Float]]
[Nat.sub,[Nat, Nat.pred, PProd.fst],[Nat]]
[Lean.Json.getBool?,[Lean.Json.null, Lean.Json.num, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Except, String, Bool, Pure.pure, MonadExcept.throw],[Except, String, Bool]]
[Id.pure_eq,[rfl],[Eq, Pure.pure]]
[Lean.Elab.Deriving.Ord.mkOrdHeader,[Lean.Elab.Deriving.mkHeader, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat],[Lean.Elab.Term.TermElabM, Lean.Elab.Deriving.Header]]
[Lean.Meta.mkArrayLit,[Bind.bind, Lean.Meta.getDecLevel, Lean.Meta.mkListLit, Pure.pure, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[add_zero,[AddMonoid.add_zero],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Nat.not_le_of_gt,[False, Nat.lt_or_ge, absurd, Nat.lt_trans, Nat.lt_irrefl],[Not, LE.le]]
[Lean.Elab.Level.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Level.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Level.Context.mk, And]]
[PProd.snd,[],[]]
[Lean.Elab.Tactic.evalSimp,[Bind.bind, Lean.Elab.Tactic.withMainContext, Lean.Elab.Tactic.mkSimpContext, Bool.false, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.Simp.DischargeWrapper.with, Lean.Elab.Tactic.simpLocation, Lean.Elab.Tactic.expandOptLocation, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Elab.Tactic.Tactic]]
[Lean.Meta.SynthInstance.TableEntry.answers,[],[Array, Lean.Meta.SynthInstance.Answer]]
[Lean.TagAttribute.noConfusionType,[],[]]
[Lean.Meta.tryUnificationHints.tryCandidate,[Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.checkpointDefEq, Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Bool]]
[Lean.ParserDescr.ibelow,[True, And],[]]
[Nat.one_ne_zero,[],[Ne, OfNat.ofNat]]
[non_contradictory_em,[],[Not, Or]]
[Alternative.failure,[],[]]
[Lean.closureMaxArgs,[Lean.closureMaxArgsFn, Unit.unit],[Nat]]
[Nat.mul_self_sub_mul_self_eq,[Eq.mpr, Eq.refl, Eq, HSub.hSub, HMul.hMul, HAdd.hAdd, Nat.mul_sub_left_distrib, Nat.right_distrib, Nat.mul_comm, Nat.add_comm, Nat.add_sub_add_left, rfl],[Eq, HSub.hSub, HMul.hMul, HAdd.hAdd]]
[Lean.IR.EmitC.throwUnknownVar,[MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.IR.EmitC.M]]
[Lean.Elab.Tactic.instOrElseTacticM,[OrElse.mk, Lean.Elab.Tactic.orElse],[OrElse, Lean.Elab.Tactic.TacticM]]
[Lean.Parser.Level.imax.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.levelParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Level.instMonadNameGeneratorLevelElabM,[Lean.MonadNameGenerator.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Level.State.ngen, modify, Lean.Elab.Level.State.mk, Lean.Elab.Level.State.mctx, Lean.Elab.Level.State.levelNames],[Lean.MonadNameGenerator, Lean.Elab.Level.LevelElabM]]
[HShiftRight.hShiftRight,[],[]]
[CommGroup.mul_comm,[],[Eq, HMul.hMul]]
[UInt8.instRingUInt8.proof_1,[congrArg, UInt8.mk, Ring.sub_eq_add_neg, UInt8.val],[Eq, UInt8.mk]]
[Lean.Meta.checkpointDefEq,[Bind.bind, Lean.MonadBacktrack.saveState, Lean.Meta.getResetPostponed, MonadExcept.tryCatch, ite, Eq, Bool.true, Lean.Meta.processPostponed, Bool.false, Lean.Meta.getPostponed, Lean.Meta.setPostponed, HAppend.hAppend, Pure.pure, DoResultPR.return, PUnit.unit, Lean.Meta.SavedState.restore, MonadExcept.throw, DoResultPR.pure, Lean.Meta.MetaM, Bool],[Lean.Meta.MetaM, Bool]]
[instHShiftRight,[HShiftRight.mk, ShiftRight.shiftRight],[HShiftRight]]
[zero_add,[AddMonoid.zero_add],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Closure.State.newLocalDeclsForMVars,[],[Array, Lean.LocalDecl]]
[Lean.Elab.Command.StructView.ref,[],[Lean.Syntax]]
[String.decEq.proof_2,[absurd],[False]]
[nsmul_rec,[OfNat.ofNat, HAdd.hAdd, PProd.fst],[]]
[Lean.Parser.Term.ensureTypeOf,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.maxPrec, Lean.Parser.strLit],[Lean.Parser.Parser]]
[Lean.IR.ExplicitRC.getDecl,[Unit.unit, Lean.IR.Decl, Lean.IR.findEnvDecl', Lean.IR.ExplicitRC.Context.env, Lean.IR.ExplicitRC.Context.decls, panicWithPosWithDecl, OfNat.ofNat],[Lean.IR.Decl]]
[Nat.lt_of_succ_le,[],[LT.lt]]
[Lean.Meta.expandCoe,[Lean.Meta.withReducibleAndInstances, Bind.bind, Lean.Meta.transform, Pure.pure, Lean.TransformStep.done, Lean.Meta.expandCoe.step],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.SCC.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.SCC.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.SCC.State.mk, And]]
[UInt32.instRingUInt32,[Ring.mk, UInt32.instRingUInt32.proof_1, UInt32.mk, Ring.gsmul, UInt32.val, UInt32.instRingUInt32.proof_2, UInt32.instRingUInt32.proof_3, UInt32.instRingUInt32.proof_4, UInt32.instRingUInt32.proof_5],[Ring, UInt32]]
[IO.FS.DirEntry.path,[HDiv.hDiv, IO.FS.DirEntry.root, System.FilePath.mk, IO.FS.DirEntry.fileName],[System.FilePath]]
[Std.HashMap.find?,[Option, Std.HashMapImp.find?],[Option]]
[Lean.MessageDataContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MessageDataContext.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.one_mul,[Nat.mul_one, Nat.mul_comm, OfNat.ofNat],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Meta.Cases.Context.mk.inj,[And.intro],[And, Eq]]
[String.push,[String, String.mk, HAppend.hAppend, List.cons, List.nil],[String]]
[instToStringInt,[ToString.mk, String, ToString.toString, HAppend.hAppend, Nat.succ],[ToString, Int]]
[Nat.eq_zero_of_add_eq_zero_right,[Eq, OfNat.ofNat, of_eq_true, Eq.trans, implies_congr, congrFun, congrArg, Nat.zero_add, eq_true_of_decide, Eq.refl, Bool.true, implies_true, False.elim, Nat.succ_ne_zero, HAdd.hAdd, Eq.mp, Nat.succ, Nat.succ_add, Nat.add_one],[Eq, OfNat.ofNat]]
[Lean.OptionDecl.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.OptionDecl.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.allGoals,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Lsp.SaveOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.SaveOptions.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.DeclInfo.noConfusionType,[],[]]
[Lean.Elab.Term.Do.JPDecl.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.JPDecl.mk, HAdd.hAdd, OfNat.ofNat]]
[instNonempty.proof_1,[Nonempty.intro, arbitrary],[Nonempty]]
[Lean.Parser.Term.basicFun.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.many1.formatter, Lean.ppSpace.formatter, Lean.Parser.Term.funBinder.formatter, Lean.Parser.darrow.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.throwTacticEx,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MessageData.ofGoal],[Lean.Meta.MetaM]]
[instDecidableEqList,[List.hasDecEq],[DecidableEq, List]]
[Lean.PrettyPrinter.Formatter.categoryParserOfStack.formatter,[Bind.bind, MonadState.get, Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Syntax.getId],[Lean.PrettyPrinter.Formatter]]
[Std.PersistentArray.mapM,[Bind.bind, Std.PersistentArray.mapMAux, Std.PersistentArray.root, Array.mapM, Std.PersistentArray.tail, Pure.pure, Std.PersistentArray.mk, Std.PersistentArray.size, Std.PersistentArray.shift, Std.PersistentArray.tailOff],[Std.PersistentArray]]
[Nat.sub_mul_mod,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HSub.hSub, HMul.hMul, Nat.zero, Nat.mul_zero, OfNat.ofNat, Nat.sub_zero, rfl],[Eq, HMod.hMod, HSub.hSub, HMul.hMul]]
[Lean.Parser.Command.commentBody.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.EmitC.hasMainFn,[Bind.bind, Lean.IR.EmitC.getEnv, Pure.pure, List.any, BEq.beq, Lean.IR.Decl.name, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.IR.EmitC.M, Bool]]
[Lean.PrettyPrinter.Formatter.State.stack,[],[Array, Std.Format]]
[Lean.IR.LiveVars.updateJPLiveVarMap,[Std.RBMap.insert],[Lean.IR.JPLiveVarMap]]
[Subtype.restrict_injective,[Function.injective.comp, Subtype.coe_injective],[Function.injective, Subtype.restrict]]
[Function.uncurry,[Prod.fst, Prod.snd],[]]
[Lean.Meta.unfoldDefinition,[Bind.bind, Lean.Meta.unfoldDefinition?, Option.none, Lean.Meta.MetaM, Lean.Expr, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.instHashableFVarId,[Hashable.mk, UInt64, mixHash, OfNat.ofNat, Hashable.hash],[Hashable, Lean.FVarId]]
[Lean.Lsp.InitializationOptions.noConfusionType,[],[]]
[Lean.Parser.ParserState.mk.inj,[And.intro],[And, Eq]]
[List.length_concat,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, List.length_cons, List.concat, Nat.succ, congrFun, HAdd.hAdd, OfNat.ofNat, eq_self, List.length],[Eq, List.length, List.concat, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Closure.collectExpr,[Bind.bind, Lean.Meta.Closure.preprocess, Lean.Meta.Closure.visitExpr, Lean.Meta.Closure.collectExprAux],[Lean.Meta.Closure.ClosureM, Lean.Expr]]
[Lean.Server.Watchdog.ServerContext.hOut,[],[IO.FS.Stream]]
[Lean.Json.mkObj,[Lean.Json.obj, Id.run, Bind.bind, ForIn.forIn, Id, ForInStep, Std.RBNode, String, Lean.Json, Pure.pure, PUnit.unit, ForInStep.yield],[Lean.Json]]
[Lean.Elab.Term.LetRecDeclView.mvar,[],[Lean.Expr]]
[Except.noConfusionType,[],[]]
[Lean.Elab.DerivingHandler,[Lean.Elab.Command.CommandElabM, Bool],[]]
[Lean.Meta.Cases.Context.casesOnVal,[],[Lean.DefinitionVal]]
[Lean.OptionDecl.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.toCtorIfLit,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.mkApp, Lean.mkRawNatLit, HSub.hSub, Lean.ToExpr.toExpr, String.toList],[Lean.Expr]]
[«term_>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Parser.Term.notFollowedByRedefinedTermToken.formatter,[Lean.PrettyPrinter.Formatter.notFollowedBy.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Command.set_option,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident, Lean.Parser.ppSpace, Lean.Parser.Command.optionValue],[Lean.Parser.Parser]]
[Lean.Compiler.getSpecializationInfo,[Lean.SMap.find?, Lean.Compiler.SpecState.specInfo, Lean.SimplePersistentEnvExtension.getState, Lean.Compiler.specExtension],[Option, Lean.Compiler.SpecInfo]]
[Lean.PrettyPrinter.Formatter.charLitNoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.visitAtom, Lean.charLitKind],[Lean.PrettyPrinter.Formatter]]
[UInt32.instSemiringUInt32.proof_1,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt32.zero_def, UInt32.add_def, UInt32.mk, OfNat.ofNat, add_zero, UInt32.val, UInt32.mk_val_eq, eq_self, propext, forall_const, UInt32],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Closure.Context.noConfusionType,[],[]]
[Lean.Widget.TaggedText.prettyTagged,[Prod.snd, Std.Format.prettyM],[Lean.Widget.TaggedText, Prod, Nat]]
[Lean.Elab.Term.Do.DoIfView.cond,[],[Lean.Syntax]]
[Lean.Parser.antiquotExpr.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.identNoAntiquot.formatter, Lean.Parser.antiquotNestedExpr.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.InternalExceptionId.idx,[],[Nat]]
[Nat.add_mul_mod_self_left,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, HMul.hMul, Nat.zero, Nat.mul_zero, OfNat.ofNat, Nat.add_zero, rfl, Nat.succ, Nat.mul_succ, Eq.symm, Nat.add_assoc, Nat.add_mod_right],[Eq, HMod.hMod, HAdd.hAdd, HMul.hMul]]
[Lean.PrettyPrinter.Parenthesizer.checkInsideQuot.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.instantiateLambda,[OfNat.ofNat],[Lean.Meta.MetaM, Lean.Expr]]
[fix,[fixCore1, arbitrary],[]]
[Mathlib.Tactic.Lint.NamedLinter.noConfusionType,[],[]]
[Lean.KVMap.findD,[Option.getD, Lean.KVMap.find],[Lean.DataValue]]
[Lean.getPPFunBinderTypes,[Lean.KVMap.get, Lean.Option.name, Lean.pp.funBinderTypes, Lean.getPPAll],[Bool]]
[Lean.instInhabitedBinderInfo,[Inhabited.mk, Lean.BinderInfo.default],[Inhabited, Lean.BinderInfo]]
[Lean.Unhygienic.Context.scope,[],[Lean.MacroScope]]
[Lean.AttributeKind.noConfusion,[noConfusionEnum, Lean.AttributeKind.toCtorIdx],[Lean.AttributeKind.noConfusionType]]
[Pow.noConfusionType,[],[]]
[Lean.Meta.MVarRenaming.isEmpty,[Std.RBMap.isEmpty, Lean.Meta.MVarRenaming.map],[Bool]]
[UInt8.isAlphanum,[or, UInt8.isAlpha, UInt8.isDigit],[Bool]]
[Lean.Elab.process,[Bind.bind, Lean.Elab.IO.processCommands, Lean.Parser.ModuleParserState.mk, Lean.Elab.Command.mkState, Lean.MessageLog.mk, Pure.pure, Prod.mk, Lean.Elab.Command.State.env, Lean.Elab.Frontend.State.commandState, Lean.Elab.Command.State.messages],[IO, Prod, Lean.Environment, Lean.MessageLog]]
[Lean.PrettyPrinter.Delaborator.delabLetFun,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.withAppArg, Lean.PrettyPrinter.Delaborator.delab, Lean.PrettyPrinter.Delaborator.SubExpr.withAppFn, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Lean.PrettyPrinter.Delaborator.getUnusedName, Lean.PrettyPrinter.Delaborator.SubExpr.withBindingBody, orM, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPLetVarTypes, Lean.getPPAnalysisLetVarType, ite, Eq, Bool.true, Lean.PrettyPrinter.Delaborator.SubExpr.withBindingDomain, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Lean.mkIdent, List.nil, panicWithPosWithDecl, OfNat.ofNat],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.NamingContext.mk.inj,[And.intro],[And, Eq]]
[left_cancelative,[Eq],[]]
[Lean.Parser.attrParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Parenthesizer]]
[Function.bijective_iff_has_inverse,[Iff.intro, Exists.intro, Function.surj_inv, And.right, And.intro, Function.left_inverse_surj_inv, Function.right_inverse_surj_inv, Function.bijective, Function.left_inverse.injective, Function.right_inverse.surjective],[Iff, Function.bijective, Exists, And, Function.left_inverse, Function.right_inverse]]
[Tactic.Cache.get,[Bind.bind, Pure.pure, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, liftM, EIO.asTask, StateRefT'.run, Prod.fst, Task.Priority.default],[]]
[Lean.registerSimpleScopedEnvExtension,[Lean.registerScopedEnvExtension, Lean.ScopedEnvExtension.Descr.mk, Lean.SimpleScopedEnvExtension.Descr.name, Pure.pure, Lean.SimpleScopedEnvExtension.Descr.initial, id, Lean.SimpleScopedEnvExtension.Descr.addEntry, Lean.SimpleScopedEnvExtension.Descr.finalizeImport],[IO, Lean.SimpleScopedEnvExtension]]
[Lean.IR.CollectMaps.Collector,[Prod, Lean.IR.VarTypeMap, Lean.IR.JPParamsMap],[]]
[Lean.Elab.Term.SyntheticMVarDecl.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.SyntheticMVarDecl.mk, HAdd.hAdd, OfNat.ofNat]]
[List.mem_cons_of_mem,[Or.inr],[Mem.mem, List.cons]]
[UInt8.decEq.proof_2,[absurd],[False]]
[Lean.Parser.Tactic.Conv.delta,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Core.Context.options,[],[Lean.Options]]
[Lean.ConstructorVal.cidx,[],[Nat]]
[Lean.FileMap.positions,[],[Array, String.Pos]]
[Lean.Rat.den,[],[Nat]]
[Lean.Expr.app.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.app, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Expr.app, And]]
[Lean.Meta.decLevel?,[Bind.bind, Lean.MonadMCtx.getMCtx, ReaderT.run, Lean.Meta.DecLevelContext.mk, Unit.unit, Lean.Meta.MetaM, Option, Lean.Level, Pure.pure, Option.some, modify, Lean.Meta.State.mk, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed, Option.none],[Lean.Meta.MetaM, Option, Lean.Level]]
[Std.HashSet.fold,[Std.HashSetImp.fold],[]]
[Lean.Meta.CheckAssignment.Context.mvarDecl,[],[Lean.MetavarDecl]]
[Lean.Elab.ExpandDeclIdResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.ExpandDeclIdResult.mk, HAdd.hAdd, OfNat.ofNat]]
[IsAddRightCancel.add_right_cancel,[],[Eq]]
[Int.mul_one,[Eq.mpr, Eq.refl, Eq, HMul.hMul, OfNat.ofNat, Int.mul_comm, Int.one_mul, rfl],[Eq, HMul.hMul, OfNat.ofNat]]
[Std.ShareCommon.PersistentState,[PointedType.type, Std.ShareCommon.PersistentStatePointed],[]]
[Lean.Elab.Term.elabCDotFunctionAlias?.expandCDotArg?,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Lean.Elab.Term.expandCDot?],[Lean.MacroM, Option, Lean.Syntax]]
[System.FilePath.pathSeparators,[ite, Eq, System.Platform.isWindows, Bool.true, List.cons, Char.ofNat, List.nil],[List, Char]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withType,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, liftM, Lean.Meta.inferType, Lean.PrettyPrinter.Delaborator.SubExpr.descend, HSub.hSub, Lean.PrettyPrinter.Delaborator.SubExpr.maxChildren, OfNat.ofNat],[]]
[Lean.IR.instHashableJoinPointId,[Hashable.mk, Hashable.hash, Lean.IR.JoinPointId.idx],[Hashable, Lean.IR.JoinPointId]]
[Mathlib.Tactic.Conv.find,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[Lean.Meta.getMVarType,[Bind.bind, Lean.Meta.getMVarDecl, Pure.pure, Lean.MetavarDecl.type],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.IR.Borrow.InitParamMap.initBorrowIfNotExported,[ite, Eq, Bool.true, Lean.IR.Borrow.InitParamMap.initBorrow],[Array, Lean.IR.Param]]
[instLTProd,[LT.mk, Or, LT.lt, Prod.fst, And, Eq, Prod.snd],[LT, Prod]]
[Lean.Meta.Simp.isOfNatNatLit,[and, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.Expr.isNatLit, Lean.Expr.appArg!, Lean.Expr.appFn!],[Bool]]
[Lean.PrettyPrinter.Delaborator.ParamKind.isRegularExplicit,[and, Lean.BinderInfo.isExplicit, Lean.PrettyPrinter.Delaborator.ParamKind.bInfo, not, Lean.PrettyPrinter.Delaborator.ParamKind.isAutoParam, Option.isNone, Lean.PrettyPrinter.Delaborator.ParamKind.defVal],[Bool]]
[Char.isUpper,[and, Decidable.decide, GE.ge, Char.val, OfNat.ofNat, LE.le],[Bool]]
[Lean.Lsp.instToJsonTextEdit,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextEdit.range, List.nil, Lean.Lsp.TextEdit.newText],[Lean.ToJson, Lean.Lsp.TextEdit]]
[Lean.Elab.Term.FunBinders.State.noConfusionType,[],[]]
[String.instReprRange,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, String.Range.start, Std.Format.line, String.Range.stop],[Repr, String.Range]]
[Lean.ConstantInfo.inductInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ConstantInfo.inductInfo, HAdd.hAdd, OfNat.ofNat]]
[Lean.Expr.hasAnyFVar,[Lean.Expr.hasAnyFVar.visit],[Bool]]
[Lean.Elab.Command.termValue_proj_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.getPPProofs,[Lean.KVMap.get, Lean.Option.name, Lean.pp.proofs, Lean.getPPAll],[Bool]]
[Lean.Meta.Simp.Result.proof?,[],[Option, Lean.Expr]]
[Lean.Meta.instAddMessageContextMetaM,[Lean.AddMessageContext.mk, Lean.addMessageContextFull],[Lean.AddMessageContext, Lean.Meta.MetaM]]
[Lean.IR.CtorInfo.isRef,[or, Decidable.decide, GT.gt, Lean.IR.CtorInfo.size, OfNat.ofNat, Lean.IR.CtorInfo.usize, Lean.IR.CtorInfo.ssize],[Bool]]
[Lean.IR.instAlphaEqvArg,[Lean.IR.AlphaEqv.mk, Lean.IR.Arg.alphaEqv],[Lean.IR.AlphaEqv, Lean.IR.Arg]]
[Lean.Parser.Term.panic.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Expr.isApp,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Parser.Term.simpleBinderWithoutType.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.pushNone.parenthesizer, Bool.true],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.ClientCapabilities.hasToJson,[Lean.ToJson.mk, Lean.Json.mkObj, List.nil],[Lean.ToJson, Lean.Lsp.ClientCapabilities]]
[Lean.withIncRecDepth,[Bind.bind, Lean.MonadRecDepth.getRecDepth, Lean.MonadRecDepth.getMaxRecDepth, ite, Eq, BEq.beq, Bool.true, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.maxRecDepthErrorMessage, Pure.pure, PUnit.unit],[]]
[Lean.Elab.Term.StructInst.instToFormatFieldStruct,[Std.ToFormat.mk, Lean.Elab.Term.StructInst.formatField, Lean.Elab.Term.StructInst.formatStruct],[Std.ToFormat, Lean.Elab.Term.StructInst.Field, Lean.Elab.Term.StructInst.Struct]]
[Lean.Meta.intro1P,[Lean.Meta.intro1Core, Bool.true],[Lean.Meta.MetaM, Prod, Lean.FVarId, Lean.MVarId]]
[Lean.Meta.Simp.withParent,[withTheReader, Lean.Meta.Simp.Context, Lean.Meta.Simp.Context.mk, Lean.Meta.Simp.Context.config, Lean.Meta.Simp.Context.simpLemmas, Lean.Meta.Simp.Context.congrLemmas, Option.some, Lean.Meta.Simp.Context.dischargeDepth],[Lean.Meta.Simp.M]]
[Lean.Meta.injectionIntro,[List.toArray, List.nil, Lean.Meta.injectionIntro.go],[Lean.Meta.MetaM, Lean.Meta.InjectionResult]]
[Substring.toNat?,[ite, Eq, Substring.isNat, Bool.true, Option.some, Substring.foldl, HAdd.hAdd, HMul.hMul, OfNat.ofNat, HSub.hSub, Char.toNat, Char.ofNat, Option.none],[Option, Nat]]
[Lean.Export.instInhabitedEntry,[Inhabited.mk, Lean.Export.Entry.name, arbitrary],[Inhabited, Lean.Export.Entry]]
[Lean.Lsp.instFromJsonCommand,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, String, Option, Array, Lean.Json, Pure.pure, Lean.Lsp.Command.mk],[Lean.FromJson, Lean.Lsp.Command]]
[Lean.Meta.Match.Extension.getMatcherInfo?,[Lean.SMap.find?, Lean.Meta.Match.Extension.State.map, Lean.SimplePersistentEnvExtension.getState, Lean.Meta.Match.Extension.extension],[Option, Lean.Meta.Match.MatcherInfo]]
[PSigma.lexAccessible.proof_1,[Acc.intro, PSigma.mk, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, WellFounded.apply],[Acc, PSigma.Lex, PSigma.mk]]
[Lean.Meta.transform,[Lean.MonadCacheT.run, Lean.Meta.transform.visit],[Lean.Expr]]
[Lean.instHashableName,[Hashable.mk, Lean.Name.hash],[Hashable, Lean.Name]]
[Lean.Widget.InteractiveGoals.goals,[],[Array, Lean.Widget.InteractiveGoal]]
[Lean.IR.AltCore.default.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.AltCore.default, HAdd.hAdd, OfNat.ofNat]]
[instLawfulMonadStateRefT',[instLawfulMonadStateRefT'.proof_1],[LawfulMonad, StateRefT']]
[Lean.Elab.Term.CollectPatternVars.State.found,[],[Lean.NameSet]]
[Lean.Lsp.ProgressParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.ProgressParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Equiv.leftInv,[],[Function.left_inverse, Equiv.invFun, Equiv.toFun]]
[Lean.IR.Borrow.BorrowInfState.paramMap,[],[Lean.IR.Borrow.ParamMap]]
[Lean.DataValue.noConfusionType,[],[]]
[AddCommMonoid.add_comm,[],[Eq, HAdd.hAdd]]
[Lean.Parser.Command.macro_rules.formatter,[Lean.PrettyPrinter.Formatter.suppressInsideQuot.formatter, Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.docComment.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.optKind.formatter, Lean.Parser.Term.matchAlts.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Attr.protectProj,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.LazyInitExtension.get,[Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.EnvExtension.getState, Lean.LazyInitExtension.ext, Pure.pure, Lean.LazyInitExtension.fn, Lean.MonadEnv.modifyEnv, Lean.EnvExtension.setState, Option.some],[]]
[Array.modifyM.proof_1,[Eq.symm, Array.size_set, Fin.mk, arbitrary],[Eq, Array.size, Array.set, Fin.mk, arbitrary]]
[Lean.Parser.Attr.class.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Server.FileWorker.ElabTaskError.eof.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Server.FileWorker.ElabTaskError.eof, OfNat.ofNat]]
[Lean.Meta.CongrTheorem.type,[],[Lean.Expr]]
[Lean.Parser.Tactic.simpPost,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Elab.Command.expandMixfix.withAttrKindGlobal,[Bind.bind, Pure.pure, Lean.Syntax.setArg, OfNat.ofNat],[Lean.MacroM, Lean.Syntax]]
[Lean.Syntax.TopDown.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Syntax.TopDown.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.mkInjectiveTheoremNameFor,[HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Name]]
[System.SearchPath,[List, System.FilePath],[]]
[Set.singleton,[setOf, Eq],[Set]]
[IO.Process.Child.mk.inj,[And.intro],[And, Eq]]
[IO.Error.noConfusionType,[],[]]
[Lean.SimpleScopedEnvExtension.Descr.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.SimpleScopedEnvExtension.Descr.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.SimpleScopedEnvExtension.Descr.mk, And]]
[Lean.Lsp.Ipc.readResponseAs,[Bind.bind, Lean.Lsp.Ipc.stdout, liftM, IO.FS.Stream.readLspResponseAs],[Lean.Lsp.Ipc.IpcM, Lean.JsonRpc.Response]]
[DoResultPR.noConfusionType,[],[]]
[Lean.Parser.Tactic.simpIntro,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg],[Lean.ParserDescr]]
[Lean.Lsp.CompletionParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.CompletionParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.le_of_lt_succ,[Nat.le_of_succ_le_succ],[LE.le]]
[Nat.div_lt_self,[],[LT.lt, HDiv.hDiv]]
[Lean.Parser.Term.nomatch.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.ScopedEnvExtension.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ScopedEnvExtension.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ScopedEnvExtension.mk, And]]
[Lean.Parser.Term.local.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Server.Watchdog.FileWorker.commTask,[],[Task, Lean.Server.Watchdog.WorkerEvent]]
[Lean.Parser.Term.termFor,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.sepBy1, Lean.Parser.Term.doForDecl, Bool.false, Lean.Parser.Term.doSeq],[Lean.Parser.Parser]]
[Nat.anyAux,[Unit.unit, Bool, Bool.false, or, HSub.hSub, Nat.succ, PProd.fst],[Bool]]
[Lean.Meta.getGlobalInstancesIndex,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Meta.Instances.discrTree, Lean.ScopedEnvExtension.getState, Lean.Meta.instanceExtension],[Lean.Core.CoreM, Lean.Meta.DiscrTree, Lean.Meta.InstanceEntry]]
[Lean.Meta.SizeOfSpecNested.throwFailed,[Bind.bind, MonadReader.read, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.SizeOfSpecNested.Context.ctorName],[Lean.Meta.SizeOfSpecNested.M]]
[Lean.Parser.scientificLit.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.scientificLitKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.scientificLitNoAntiquot.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.zero_div,[Eq.trans, Nat.div_eq, OfNat.ofNat, if_neg, Nat.not_le_of_gt],[Eq, HDiv.hDiv, OfNat.ofNat]]
[Lean.Elab.Tactic.elabRewriteConfig,[ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, Lean.Meta.Rewrite.Config.mk, Lean.withoutModifyingState, Lean.Meta.withLCtx, Lean.LocalContext.mk, EmptyCollection.emptyCollection, Lean.Elab.Term.withSynthesize, Bind.bind, Lean.Elab.Term.elabTermEnsuringType, Lean.Syntax.getOp, OfNat.ofNat, Option.some, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Option.none, liftM, Lean.Meta.instantiateMVars, Bool.false],[Lean.Elab.Term.TermElabM, Lean.Meta.Rewrite.Config]]
[Nat.pred_succ,[rfl],[Eq, Nat.pred, Nat.succ]]
[Lean.SimplePersistentEnvExtension.instInhabitedSimplePersistentEnvExtension,[inferInstanceAs, Inhabited, Lean.PersistentEnvExtension, Prod, List],[Inhabited, Lean.SimplePersistentEnvExtension]]
[Tactic.Ring.State.mk.inj,[And.intro],[And, Eq]]
[IO.Error.unsatisfiedConstraints.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.unsatisfiedConstraints, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Structural.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Structural.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.SavedState.elab,[],[Lean.Elab.Term.State]]
[Lean.ParametricAttributeImpl.noConfusionType,[],[]]
[Lean.Elab.WF.TerminationHintValue.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.WF.TerminationHintValue.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.WF.TerminationHintValue.mk, And]]
[Lean.IR.Decl.simpCase,[Lean.IR.Decl.extern, Lean.IR.Decl, Lean.IR.Decl.updateBody!, Lean.IR.FnBody.simpCase],[Lean.IR.Decl]]
[Lean.Server.instMonadRpcSession,[Lean.Server.MonadRpcSession.mk, liftM, Lean.Server.MonadRpcSession.rpcStoreRef, Lean.Server.MonadRpcSession.rpcGetRef, Lean.Server.MonadRpcSession.rpcReleaseRef],[Lean.Server.MonadRpcSession]]
[List.hasDecidableLt,[Unit.unit, Decidable, LT.lt, Decidable.isFalse, List.hasDecidableLt.proof_1, Decidable.isTrue, List.lt.nil, List.hasDecidableLt.proof_2, List.cons, List.lt.head, List.hasDecidableLt.proof_3, PProd.fst, List.lt.tail, List.hasDecidableLt.proof_4],[Decidable, LT.lt]]
[Lean.Parser.Level.addLit.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.numLit.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[UInt8.mul_def,[rfl],[Eq, HMul.hMul, UInt8.mk, UInt8.val]]
[Array.get.proof_1,[Fin.isLt],[LT.lt, Fin.val, Array.size]]
[Lean.Xml.Content.noConfusionType,[],[]]
[Lean.Parser.Level.imax.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.nonReservedSymbol.formatter, Lean.Parser.many1.formatter, Lean.ppSpace.formatter, Lean.Parser.levelParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.modifyTarget,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType, Lean.Meta.change, Bool.false],[Lean.Meta.MetaM, Lean.MVarId]]
[tacticFunext__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.ParserAttributeHook.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.ParserAttributeHook.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.ParserAttributeHook.mk]]
[Lean.Lsp.VersionedTextDocumentIdentifier.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.VersionedTextDocumentIdentifier.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.notFollowedByRedefinedTermToken.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.notFollowedBy.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.ElimAltInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.ElimAltInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[UInt64.instSemigroupUInt64,[Semigroup.mk, UInt64.instSemigroupUInt64.proof_1],[Semigroup, UInt64]]
[Lean.Elab.Command.withMacroExpansion,[MonadWithReader.withReader, Lean.Elab.Command.Context.mk, Lean.Elab.Command.Context.fileName, Lean.Elab.Command.Context.fileMap, Lean.Elab.Command.Context.currRecDepth, Lean.Elab.Command.Context.cmdPos, List.cons, Lean.Elab.MacroStackElem.mk, Lean.Elab.Command.Context.macroStack, Lean.Elab.Command.Context.currMacroScope, Lean.Elab.Command.Context.ref],[Lean.Elab.Command.CommandElabM]]
[Prod.lexAccessible,[Prod.lexAccessible.proof_1],[Acc, Prod.Lex, Prod.mk]]
[Fin.one_def,[],[Eq, Fin.val, OfNat.ofNat, HMod.hMod]]
[Lean.MetavarContext.LevelMVarToParam.M,[ReaderT, Lean.MetavarContext.LevelMVarToParam.Context, StateM, Lean.MetavarContext.LevelMVarToParam.State],[]]
[Lean.Elab.Term.SyntheticMVarKind.coe.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.SyntheticMVarKind.coe, HAdd.hAdd, OfNat.ofNat]]
[instReprUInt16,[Repr.mk, repr, UInt16.toNat],[Repr, UInt16]]
[Std.PersistentArray.map,[Id.run, Std.PersistentArray.mapM],[Std.PersistentArray]]
[Lean.Parser.ppHardSpace.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.skip.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.AttributeApplicationTime.noConfusionType,[noConfusionTypeEnum, Lean.AttributeApplicationTime.toCtorIdx],[]]
[«termΣ_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[instMonadReaderOfReaderT,[MonadReaderOf.mk, ReaderT.read],[MonadReaderOf, ReaderT]]
[Lean.IR.EmitC.emitJmp,[Bind.bind, Lean.IR.EmitC.getJPParams, ite, Eq, BEq.beq, Array.size, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw],[Lean.IR.EmitC.M, Unit]]
[Lean.ExternEntry.noConfusionType,[],[]]
[Lean.Elab.Frontend.getCommandState,[Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Frontend.State.commandState],[Lean.Elab.Frontend.FrontendM, Lean.Elab.Command.State]]
[Lean.Meta.ToHide.hasInaccessibleNameDep,[Bind.bind, MonadState.get, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.findLocalDeclDependsOn, or, Std.RBTree.contains, Lean.Meta.ToHide.State.hiddenInaccessible, Lean.Meta.ToHide.State.hiddenInaccessibleProp],[Lean.Meta.ToHide.M, Bool]]
[Nat.lt_of_not_le,[Or.resolve_right, Nat.lt_or_ge],[LT.lt]]
[Lean.Parser.Tactic.suggest,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg],[Lean.ParserDescr]]
[Fin.mod_eq_of_lt,[Fin.eq_of_val_eq, Eq.mpr, congrFun, congrArg, Eq, Fin.val, Fin.mod_def, Eq.refl, HMod.hMod, Nat.mod_eq_of_lt, Fin.isLt, rfl],[Eq, HMod.hMod]]
[Nat.eq_of_beq_eq_true,[Eq, rfl],[Eq]]
[Setoid.noConfusionType,[],[]]
[Lean.Parser.ParserExtension.OLeanEntry.kind.inj,[],[Eq]]
[Lean.Widget.Lean.Widget.InteractiveTermGoal.instFromJsonRpcEncodingPacket,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Array, Lean.Widget.TaggedText, Lean.Lsp.Range, Pure.pure],[Lean.FromJson]]
[Lean.Meta.Match.assignGoalOf,[Lean.Meta.Match.withGoalOf, Lean.Meta.assignExprMVar, Lean.Meta.Match.Problem.mvarId],[Lean.Meta.MetaM, Unit]]
[Lean.Elab.Term.Do.Code.reassign.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Code.reassign, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.Code.reassign, And]]
[Lean.AttributeApplicationTime.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Elab.instInhabitedModifiers,[Inhabited.mk, Lean.Elab.Modifiers.mk, arbitrary],[Inhabited, Lean.Elab.Modifiers]]
[Lean.Parser.Tactic.simpAll,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma],[Lean.ParserDescr]]
[Lean.IR.Borrow.BorrowInfState.owned,[],[Lean.IR.Borrow.OwnedSet]]
[Lean.Lsp.RpcConnectParams.uri,[],[Lean.Lsp.DocumentUri]]
[Lean.Elab.Command.getLevelNames,[Bind.bind, Lean.Elab.Command.getScope, Pure.pure, Lean.Elab.Command.Scope.levelNames],[Lean.Elab.Command.CommandElabM, List, Lean.Name]]
[Lean.Elab.Term.StructInst.Field.expr?,[],[Option, Lean.Expr]]
[le_of_eq_or_lt,[LE.le, le_of_eq, le_of_lt],[LE.le]]
[Lean.Parser.Term.trueVal,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.nonReservedSymbol, Bool.false],[Lean.Parser.Parser]]
[Lean.Elab.Term.expandHave,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Lean.Syntax.isNone, Unit.unit, Option.none, Option.some, Lean.Macro.throwUnsupported],[Lean.Macro]]
[Fin.instHModFinNatFin,[HMod.mk, Fin.modn],[HMod, Fin, Nat]]
[Lean.Environment.displayStats,[Bind.bind, ST.Ref.get, Lean.persistentEnvExtensionsRef, IO.println, HAppend.hAppend, ToString.toString, Lean.EnvironmentHeader.imports, Lean.Environment.header, Array.size, Lean.EnvironmentHeader.regions, Array.filter, Lean.CompactedRegion.isMemoryMapped, OfNat.ofNat, Lean.SMap.size, Lean.Environment.constants, Prod.fst, Lean.SMap.stageSizes, Prod.snd, Lean.SMap.numBuckets, Lean.EnvironmentHeader.trustLevel, Lean.Environment.extensions, Array.forM, Lean.PersistentEnvExtension.name],[IO, Unit]]
[Lean.Meta.Config.ignoreLevelMVarDepth,[],[Bool]]
[Nat.add_right_comm,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Nat.add_assoc, Nat.add_comm, Eq.symm, rfl],[Eq, HAdd.hAdd]]
[Std.RBMap.insert.proof_1,[Std.RBNode.WellFormed.insertWff, rfl],[Std.RBNode.WellFormed, Std.RBNode.insert]]
[Prod.mk.inj_iff,[Iff.intro, Prod.mk.inj, Eq.mpr, Eq.refl, Eq, Prod.mk, And.left, And.right, rfl],[Iff, Eq, Prod.mk, And]]
[Lean.Elab.Term.elabTermEnsuringType,[Bind.bind, Lean.Elab.Term.elabTerm, Lean.withRef, Lean.Elab.Term.ensureHasType],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[List.reverse,[List.reverseAux, List.nil],[List]]
[Lean.Parser.Term.leading_parser.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.optExprPrecedence.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Std.Format.FlattenBehavior.allOrNone.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Std.Format.FlattenBehavior.allOrNone, OfNat.ofNat]]
[Lean.Meta.DecLevelContext.noConfusionType,[],[]]
[Lean.Meta.Simp.Context.parent?,[],[Option, Lean.Expr]]
[IO.Process.StdioConfig.stderr,[],[IO.Process.Stdio]]
[Lean.Parser.Tactic.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.tacticParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[IO.AsyncList.ofList,[List.foldr, IO.AsyncList.cons, IO.AsyncList.nil],[IO.AsyncList]]
[outParam,[],[]]
[Lean.Parser.Term.haveIdDecl.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Term.haveIdLhs.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.mkCIdentFromRef,[Bind.bind, Lean.MonadRef.getRef, Pure.pure, Lean.mkCIdentFrom],[Lean.Syntax]]
[Lean.Lsp.instFromJsonRpcRef,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, USize, Pure.pure, Lean.Lsp.RpcRef.mk],[Lean.FromJson, Lean.Lsp.RpcRef]]
[UInt32.instNegUInt32,[Neg.mk, UInt32.mk, Neg.neg, UInt32.val],[Neg, UInt32]]
[Lean.ImportState.noConfusionType,[],[]]
[Prod.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Prod.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Prod.mk, And]]
[Lean.instToMessageDataName,[Lean.ToMessageData.mk, Lean.MessageData.ofName],[Lean.ToMessageData, Lean.Name]]
[Lean.Parser.addLeadingParser,[Unit.unit, Except, String, Lean.Parser.ParserCategories, Lean.Parser.getCategory, Lean.Parser.throwUnknownParserCategory, Lean.Parser.FirstTokens.epsilon, Lean.Parser.FirstTokens.unknown, Lean.Parser.ParserInfo.firstTokens, Lean.Parser.Parser.info, Pure.pure, Std.PersistentHashMap.insert, Lean.Parser.ParserCategory.mk, Lean.Parser.ParserCategory.behavior],[Except, String, Lean.Parser.ParserCategories]]
[Lean.Expr.updateLambda!.proof_1,[rfl],[Eq, Lean.Expr.isLambda, Lean.Expr.lam]]
[Lean.Elab.Term.Quotation.precheckApp,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Term.Quotation.precheck, ForIn.forIn, PUnit.unit, Pure.pure, ForInStep.yield, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.Quotation.Precheck]]
[Array.mkEmpty,[Array.mk, List.nil],[Array]]
[Lean.Parser.sepBy.formatter,[Lean.PrettyPrinter.Formatter.sepByNoAntiquot.formatter, Lean.Parser.sepByElemParser.formatter],[Lean.PrettyPrinter.Formatter]]
[le_or_lt,[Or.symm, lt_or_le],[Or, LE.le, LT.lt]]
[List.length_set,[rfl, Eq.symm, of_eq_true, Eq.trans, congr, congrArg, Eq, List.length_cons, List.set, Nat.succ, eq_self, List.length, Eq.refl],[Eq, List.length, List.set]]
[Lean.Json.opt,[Unit.unit, List, Prod, String, Lean.Json, List.nil, List.cons, Prod.mk, Lean.ToJson.toJson],[List, Prod, String, Lean.Json]]
[Lean.Parser.Term.doReturn,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, Lean.Parser.withPosition, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.checkLineEq, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.Meta.testHelper,[Bind.bind, ite, Eq, Bool.true, Pure.pure, Lean.Meta.whnf],[Lean.Meta.MetaM, Bool]]
[Command.initializeSimpsProjections?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const, Command.simpsProj],[Lean.ParserDescr]]
[min_eq_right_of_lt,[min_eq_right, le_of_lt],[Eq, min]]
[Lean.Syntax.SepArray.getElems,[Array.getSepElems, Lean.Syntax.SepArray.elemsAndSeps],[Array, Lean.Syntax]]
[Float.noConfusionType,[],[]]
[Lean.Syntax.matchesIdent,[and, Lean.Syntax.isIdent, BEq.beq, Lean.Syntax.getId],[Bool]]
[Lean.IR.Expr.reuse.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.reuse, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Expr.reuse, And]]
[Lean.Parser.Term.basicFun.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.Term.funBinder.parenthesizer, Lean.Parser.darrow.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Server.FileWorker.EditableDocument.cancelTk,[],[Lean.Server.FileWorker.CancelToken]]
[Lean.PrettyPrinter.Delaborator.ParamKind.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.nodeFn,[Lean.Parser.ParserState.mkNode],[Lean.Parser.ParserFn]]
[String.mkIterator,[String.Iterator.mk, OfNat.ofNat],[String.Iterator]]
[Lean.IR.Borrow.ownArgsUsingParams,[Nat.forM, Array.size, ite, Eq, Lean.IR.Param.borrow, Bool.true, Pure.pure, PUnit.unit, Lean.IR.Borrow.ownArg],[Lean.IR.Borrow.M, Unit]]
[Lean.Elab.Tactic.ElimApp.State.fType,[],[Lean.Expr]]
[Lean.Parser.Tactic.exact,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[List.pairwise_cons,[Iff.intro],[Iff, List.pairwise, List.cons, And]]
[Lean.Meta.MatcherApp.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.MatcherApp.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.instAlternativeMetaM,[Alternative.mk, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Meta.orElse],[Alternative, Lean.Meta.MetaM]]
[Lean.Parser.InputContext.fileMap,[],[Lean.FileMap]]
[Lean.Elab.Term.StructInst.instInhabitedSource,[Inhabited.mk, Lean.Elab.Term.StructInst.Source.none],[Inhabited, Lean.Elab.Term.StructInst.Source]]
[Semiring.add_mul,[],[Eq, HMul.hMul, HAdd.hAdd]]
[Std.PersistentArray.append,[ite, Eq, Std.PersistentArray.isEmpty, Bool.true, Std.PersistentArray.foldl, Std.PersistentArray.push, OfNat.ofNat],[Std.PersistentArray]]
[instReprSubtype,[Repr.mk, Repr.reprPrec, Subtype.val],[Repr, Subtype]]
[Nat.add_one,[rfl],[Eq, HAdd.hAdd, OfNat.ofNat, Nat.succ]]
[Lean.Elab.Deriving.DecEq.mkMatch.mkAlts,[Bind.bind, ForIn.forIn, Lean.getConstInfoCtor, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, PUnit.unit, ForInStep.yield, ite, Eq, BEq.beq, Bool.true, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, liftM, Lean.Core.betaReduce, MProd.mk, Lean.Elab.Term.TermElabM, Lean.Syntax, Lean.Expr.containsFVar, Lean.Expr.fvarId!, Lean.Core.mkFreshUserName, Lean.Meta.inferType, Lean.mkIdent, Array.append, Lean.Elab.Deriving.DecEq.mkMatch.mkSameCtorRhs, Array.toList, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.Meta.compatibleCtors, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Array.push],[Lean.Elab.Term.TermElabM, Array, Lean.Syntax]]
[IO.Process.Child.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Process.Child.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Process.Child.mk, And]]
[Lean.getBuiltinSearchPath,[Bind.bind, Lean.getLibDir, Pure.pure, List.cons, List.nil],[IO, Lean.SearchPath]]
[IO.FS.Stream.read,[],[IO, ByteArray]]
[Lean.Parser.withAntiquotSuffixSpliceFn,[Id.run, ite, Eq, or, Lean.Parser.ParserState.hasError, BEq.beq, Lean.Parser.ParserContext.quotDepth, OfNat.ofNat, not, Lean.Syntax.isAntiquot, Array.back, Lean.Parser.ParserState.stxStack, Bool.true, Pure.pure, Bind.bind, PUnit.unit],[Lean.Parser.ParserFn]]
[Lean.Parser.sepBy1.formatter,[Lean.PrettyPrinter.Formatter.sepBy1NoAntiquot.formatter, Lean.Parser.sepByElemParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.InfoCacheKey.transparency,[],[Lean.Meta.TransparencyMode]]
[Lean.MessageSeverity.information.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.MessageSeverity.information, OfNat.ofNat]]
[OptionT.instMonadExceptOfOptionT,[MonadExceptOf.mk, OptionT.mk, throwThe, tryCatchThe],[MonadExceptOf, OptionT]]
[Lean.getPathToBaseStructure?,[Lean.getPathToBaseStructureAux, List.nil],[Option, List, Lean.Name]]
[Lean.IR.Sorry.visitExpr,[Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, ExceptT, Lean.Name, Lean.IR.Sorry.M, Unit, Pure.pure, Unit.unit, Lean.IR.Sorry.visitExpr.getSorryDepFor?],[ExceptT, Lean.Name, Lean.IR.Sorry.M, Unit]]
[Lean.Lsp.instToJsonDocumentHighlightKind,[Lean.ToJson.mk, Unit.unit, Lean.Json, OfNat.ofNat],[Lean.ToJson, Lean.Lsp.DocumentHighlightKind]]
[Lean.Elab.Command.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Command.State.mk, And]]
[Nat.sub_eq_zero_of_le,[Exists.elim, Nat.le.dest, Eq.mpr, Eq.refl, Eq, HSub.hSub, OfNat.ofNat, Eq.symm, HAdd.hAdd, Nat.sub_self_add, rfl],[Eq, HSub.hSub, OfNat.ofNat]]
[lt_trichotomy,[Or.elim, le_total, Decidable.lt_or_eq_of_le, Or.inl, Or.inr, Eq.symm],[Or, LT.lt, Eq]]
[Lean.Meta.SortLocalDecls.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SortLocalDecls.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SortLocalDecls.State.mk, And]]
[String.Range.start,[],[String.Pos]]
[Lean.Meta.ToHide.M,[ReaderT, Lean.Meta.ToHide.Context, StateRefT', IO.RealWorld, Lean.Meta.ToHide.State, Lean.Meta.MetaM],[]]
[Lean.Elab.Tactic.evalCase,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Bind.bind, Lean.Elab.Tactic.getUnsolvedGoals, Lean.Syntax.isIdent, List.findM?, liftM, Lean.Meta.getMVarDecl, Pure.pure, Lean.Name.isSuffixOf, Lean.MetavarDecl.userName, Unit.unit, Lean.Elab.Tactic.TacticM, Option, Lean.MVarId, Option.some, Lean.Name.isPrefixOf, Option.none, Unit, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Elab.Tactic.getMainGoal, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[Lean.Meta.setMVarType,[Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.setMVarType],[Lean.Meta.MetaM, Unit]]
[Lean.Lsp.LocationLink.targetSelectionRange,[],[Lean.Lsp.Range]]
[Lean.Meta.Simp.Config.maxDischargeDepth,[],[Nat]]
[USize.mod_def,[rfl],[Eq, HMod.hMod, USize.mk, USize.val]]
[Nat.add_self_ne_one,[Eq.refl, OfNat.ofNat, HEq.refl, False],[Ne, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Match.isCurrVarInductive,[Unit.unit, Lean.Meta.MetaM, Bool, Lean.Meta.Match.Problem.vars, Pure.pure, Bool.false, Lean.Meta.Match.withGoalOf, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.InductiveVal, Lean.Expr.getAppFn, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Option.some, Option.none, Option.isSome],[Lean.Meta.MetaM, Bool]]
[Lean.Meta.inferTypeImp,[Lean.withIncRecDepth, Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.default, Lean.Meta.inferTypeImp.infer],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.PrettyPrinter.Formatter.State.stxTrav,[],[Lean.Syntax.Traverser]]
[Lean.Elab.Term.StructInst.CtorHeaderResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.StructInst.CtorHeaderResult.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.HoverParams.mk.inj,[],[Eq]]
[Lean.Tactic.normNum,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Meta.DiscrTree.Key.const.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.DiscrTree.Key.const, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Level.Context.autoBoundImplicit,[],[Bool]]
[Lean.Export.instCoeExprEntry,[Coe.mk, Lean.Export.Entry.expr],[Coe, Lean.Expr, Lean.Export.Entry]]
[Nat.add_mul,[Nat.right_distrib],[Eq, HMul.hMul, HAdd.hAdd]]
[«term_/_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[String.startsWith,[BEq.beq, Substring.take, String.toSubstring, String.length],[Bool]]
[Lean.Parser.Term.letIdDecl,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.Term.letIdLhs, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat, Bool.false],[Lean.Parser.Parser]]
[Lean.PrettyPrinter.Delaborator.Context.openDecls,[],[List, Lean.OpenDecl]]
[Lean.Parser.Tactic.config,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[termDepIfThenElse,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.MetaEval.eval,[],[IO, Lean.Environment]]
[Lean.Expr.const?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Prod, Lean.Name, List, Lean.Level, Option.some, Prod.mk, Option.none],[Option, Prod, Lean.Name, List, Lean.Level]]
[FloatArray.mkEmpty,[FloatArray.mk, List.toArray, List.nil],[FloatArray]]
[Lean.Meta.Match.MatcherResult.mk.inj,[And.intro],[And, Eq]]
[Char.noConfusionType,[],[]]
[Lean.PPContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PPContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PPContext.mk, And]]
[Lean.MonadCache.findCached?,[],[Option]]
[Lean.Meta.savingCache,[Lean.Meta.mapMetaM, Bind.bind, MonadState.get, tryFinally, modify, Lean.Meta.State.mk, Lean.Meta.State.mctx, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed],[]]
[Lean.Meta.AbstractNestedProofs.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.AbstractNestedProofs.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Compiler.foldCharOfNat,[OptionM.run, Bind.bind, guard, Eq, not, Bool.true, Lean.Compiler.getNumLit, ite, isValidChar, Nat.toUInt32, Pure.pure, Lean.Compiler.mkUInt32Lit, OfNat.ofNat],[Option, Lean.Expr]]
[UInt16.toNat,[Fin.val, UInt16.val],[Nat]]
[Lean.Meta.instInhabitedAbstractMVarsResult,[Inhabited.mk, Lean.Meta.AbstractMVarsResult.mk, arbitrary],[Inhabited, Lean.Meta.AbstractMVarsResult]]
[Lean.Parser.Command.exit.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.StructInst.Struct.ibelow,[And, True],[]]
[false_and,[propext, Iff.intro, And.left, False.elim],[Eq, And, False]]
[Lean.Meta.SplitIf.getSimpContext,[Lean.LazyInitExtension.get, Lean.Meta.SplitIf.ext],[Lean.Meta.MetaM, Lean.Meta.Simp.Context]]
[Lean.Elab.Tactic.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Tactic.Context.mk, And]]
[Lean.Elab.Term.toParserDescr.processNullaryOrCat,[Bind.bind, Lean.Elab.Term.toParserDescr.resolveParserName, Lean.Syntax.getOp, OfNat.ofNat, Unit.unit, List.cons, Prod.mk, Bool.false, Bool.true, Lean.Elab.Term.ToParserDescrM, Lean.Syntax, Lean.Elab.Term.toParserDescr.ensureNoPrec, Pure.pure, Lean.mkIdentFrom, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, List.nil, Lean.Quote.quote, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, List.map, Prod.fst, Lean.MonadEnv.getEnv, ite, Eq, Lean.Parser.isParserCategory, Lean.Elab.Term.toParserDescr.processParserCategory, liftM, Lean.Parser.isParserAlias, Lean.Parser.ensureConstantParserAlias],[Lean.Elab.Term.ToParserDescrM, Lean.Syntax]]
[Lean.Parser.Term.doHave.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.haveDecl.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.Quotation.HeadCheck.slice.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Quotation.HeadCheck.slice, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Quotation.HeadCheck.slice, And]]
[Lean.MonadCacheT.instMonadControlMonadCacheT,[inferInstanceAs, MonadControl, StateRefT', Std.HashMap],[MonadControl, Lean.MonadCacheT]]
[Lean.Parser.notSymbol.formatter,[Lean.PrettyPrinter.Formatter.notFollowedBy.formatter, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Server.FileWorker.handleRequest,[Bind.bind, MonadReader.read, MonadState.get, ite, Eq, BEq.beq, Bool.true, MonadExcept.tryCatch, Lean.Server.FileWorker.parseParams, Lean.Lsp.RpcConnectParams, Lean.Server.FileWorker.handleRpcConnect, liftM, IO.FS.Stream.writeLspResponse, Lean.Server.FileWorker.WorkerContext.hOut, Lean.JsonRpc.Response.mk, IO.FS.Stream.writeLspResponseError, Lean.JsonRpc.ResponseError.mk, Lean.JsonRpc.ErrorCode.internalError, ToString.toString, Pure.pure, PUnit.unit],[Lean.Server.FileWorker.WorkerM, Unit]]
[Lean.Parser.isExitCommand,[Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous],[Bool]]
[Lean.AliasEntry,[Prod, Lean.Name],[]]
[Std.Range.forIn.loop,[ite, GE.ge, Std.Range.stop, Pure.pure, Unit.unit, Bind.bind, PProd.fst, HAdd.hAdd, Std.Range.step],[]]
[Lean.Elab.WF.TerminationHintValue.ref,[],[Lean.Syntax]]
[Mathlib.Tactic.Ext.tacticExtOrSkip__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Nat.allM.loop,[Unit.unit, Bool, Pure.pure, Bool.true, Bind.bind, HSub.hSub, OfNat.ofNat, PProd.fst, Bool.false],[Bool]]
[Lean.Literal.strVal.injEq,[Eq.propIntro, Eq.refl, Lean.Literal.strVal, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Literal.strVal]]
[IO.Process.Stdio.toCtorIdx,[OfNat.ofNat],[Nat]]
[Nat.sub_le_sub_right_iff,[Iff.intro, Nat.le_of_le_of_sub_le_sub_right, Nat.sub_le_sub_right],[Iff, LE.le, HSub.hSub]]
[Lean.Macro.resolveNamespace?,[Bind.bind, Lean.Macro.getMethods, Lean.Macro.Methods.resolveNamespace?],[Lean.MacroM, Option, Lean.Name]]
[Lean.instForInOptionsProdNameDataValue,[inferInstanceAs, ForIn, Lean.KVMap, Prod, Lean.Name, Lean.DataValue],[ForIn, Lean.Options, Prod, Lean.Name, Lean.DataValue]]
[Nat.mod_add_mod,[],[Eq, HMod.hMod, HAdd.hAdd]]
[UInt32.div,[UInt32.mk, HDiv.hDiv, UInt32.val],[UInt32]]
[Lean.Lsp.DidOpenTextDocumentParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DidOpenTextDocumentParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.DidOpenTextDocumentParams.mk]]
[Lean.Lsp.instInhabitedCompletionItem,[Inhabited.mk, Lean.Lsp.CompletionItem.mk, arbitrary],[Inhabited, Lean.Lsp.CompletionItem]]
[ByteArray.foldl,[Id.run, ByteArray.foldlM],[]]
[Array.size_swap,[],[Eq, Array.size, Array.swap]]
[Lean.Meta.reduceEval,[Lean.Meta.withAtLeastTransparency, Lean.Meta.TransparencyMode.default, Lean.Meta.ReduceEval.reduceEval],[Lean.Meta.MetaM]]
[Lean.Expr.bvar.inj,[And.intro],[And, Eq]]
[Lean.Meta.mkCongrLemma.onlyMVarsAt,[Option.isNone, Lean.Expr.find?, and, Lean.Expr.isMVar, not, Std.RBTree.contains, Lean.Expr.mvarId!],[Bool]]
[Lean.Server.FileWorker.getInteractiveTermGoal,[Bind.bind, Lean.Server.RequestM.readDoc, Lean.Server.RequestM.withWaitFindSnap, Decidable.decide, GT.gt, Lean.Server.Snapshots.Snapshot.endPos, Pure.pure, Option.none, Option.some, Prod.mk, Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofTermInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.Info.ofCompletionInfo, Lean.Server.RequestM, Option, Lean.Widget.InteractiveTermGoal, Lean.Elab.InfoTree.termGoalAt?, Lean.Server.Snapshots.Snapshot.infoTree, liftM, Lean.Elab.ContextInfo.runMetaM, Lean.Elab.Info.lctx, Lean.Meta.inferType, Lean.Elab.TermInfo.expr, Lean.Meta.instantiateMVars, Option.getD, Lean.Elab.TermInfo.expectedType?, Lean.Meta.mkFreshExprMVar, Lean.MetavarKind.natural, Lean.Name.anonymous, Lean.Meta.withPPInaccessibleNames, Lean.Widget.goalToInteractive, Lean.Expr.mvarId!, Bool.true, Lean.Widget.InteractiveTermGoal.mk, Lean.Widget.InteractiveGoal.hyps, Lean.Widget.InteractiveGoal.type],[Lean.Server.RequestM, Lean.Server.RequestTask, Option, Lean.Widget.InteractiveTermGoal]]
[Mathlib.Tactic.Lint.getDeclsInMathlib,[Bind.bind, Mathlib.Tactic.Lint.getDeclsInCurrModule, Lean.MonadEnv.getEnv, ForIn.forIn, Lean.Core.CoreM, ForInStep, Array, Lean.Name, ite, Eq, Array.getOp, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield],[Lean.Core.CoreM, Array, Lean.Name]]
[Lean.Meta.Match.State.used,[],[Std.HashSet, Nat]]
[Lean.Meta.Match.MkMatcherInput.noConfusionType,[],[]]
[Lean.Level.PP.toResult,[Lean.Level.PP.Result, Lean.Level.PP.Result.num, OfNat.ofNat, Lean.Level.PP.Result.succ, PProd.fst, Lean.Level.PP.Result.max, PProd.snd, Lean.Level.PP.Result.imax, Lean.Level.PP.Result.leaf],[Lean.Level.PP.Result]]
[Nat.add_succ,[rfl],[Eq, HAdd.hAdd, Nat.succ]]
[instToStringULift,[ToString.mk, ToString.toString, ULift.down],[ToString, ULift]]
[Lean.Parser.addBuiltinLeadingParser,[Lean.Parser.addBuiltinParser, Bool.true],[IO, Unit]]
[Lean.IR.Expr.proj.inj,[And.intro],[And, Eq]]
[Lean.IR.Arg.hasFreeVar,[Lean.IR.HasIndex.visitArg, Lean.IR.VarId.idx],[Bool]]
[Lean.Core.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Core.State.mk, HAdd.hAdd, OfNat.ofNat]]
[List.firstM,[Unit.unit, Alternative.failure, HOrElse.hOrElse, PProd.fst],[]]
[List.below,[PUnit, PProd],[]]
[Lean.ConstructorVal.toConstantVal,[],[Lean.ConstantVal]]
[Lean.instMonadWithOptions,[Lean.MonadWithOptions.mk, MonadFunctorT.monadMap, Lean.MonadWithOptions.withOptions],[Lean.MonadWithOptions]]
[Lean.Parser.Command.notation.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optPrecedence.parenthesizer, Lean.Parser.Command.optNamedName.parenthesizer, Lean.Parser.Command.optNamedPrio.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.Command.notationItem.parenthesizer, Lean.Parser.darrow.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Substring.beq,[and, BEq.beq, Substring.bsize, String.substrEq, Substring.str, Substring.startPos],[Bool]]
[Lean.Parser.SyntaxNodeKindSet.insert,[Std.PersistentHashMap.insert, Unit.unit],[Lean.Parser.SyntaxNodeKindSet]]
[IO.Error.mkOtherError,[IO.Error.otherError],[IO.Error]]
[exists_eq_right_right,[Iff.intro, And, And.intro, Exists, Eq, Exists.intro, rfl],[Iff, Exists, And, Eq]]
[Lean.Elab.Deriving.Header.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Deriving.Header.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Deriving.Header.mk, And]]
[Lean.Elab.Command.expandMutualPreamble,[Unit.unit, Lean.MacroM, Lean.Syntax, OfNat.ofNat, Lean.Syntax.getArgs, Lean.Syntax.getOp, Lean.Macro.throwUnsupported, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.mkNullNode, HAppend.hAppend],[Lean.Macro]]
[Lean.Parser.Term.stx.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.syntaxParser],[Lean.Parser.Parser]]
[Lean.Parser.Tactic.set,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[instAddCommSemigroupFin,[AddCommSemigroup.mk, instAddCommSemigroupFin.proof_1],[AddCommSemigroup, Fin]]
[Lean.LocalContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.LocalContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.LocalContext.mk, And]]
[Lean.PersistentEnvExtension.mk.inj,[And.intro],[And, Eq]]
[IO.FS.Mode.write.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.Mode.write, OfNat.ofNat]]
[Lean.Elab.Term.Arg.noConfusionType,[],[]]
[Lean.IR.LocalContextEntry.localVar.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.LocalContextEntry.localVar, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.LocalContextEntry.localVar, And]]
[Lean.Parser.many1.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.many1NoAntiquot.parenthesizer, Lean.Parser.withAntiquotSpliceAndSuffix.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.Match.MatchEqns.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.MatchEqns.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Level.PP.Result.num.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Level.PP.Result.num, HAdd.hAdd, OfNat.ofNat]]
[Lean.Expr.FindImpl.State.noConfusionType,[],[]]
[and_or_distrib_left,[Iff.intro, Or, And, Or.imp, And.intro, And.imp_right, Or.inl, Or.inr],[Iff, And, Or]]
[«term_∩_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Meta.Match.MatcherInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.MatcherInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.MatcherInfo.mk, And]]
[Lean.Elab.Term.withDepElimPatterns,[Bind.bind, StateRefT'.run, Array.mapM, Lean.Elab.Term.ToDepElimPattern.main, Lean.Elab.Term.ToDepElimPattern.State.mk, Lean.Elab.Term.TermElabM, liftM, Lean.Meta.instantiateLocalDeclMVars, Lean.Elab.Term.ToDepElimPattern.State.localDecls, Lean.MonadLCtx.getLCtx, withTheReader, Lean.Meta.Context, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.localInstances, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth],[Lean.Elab.Term.TermElabM]]
[Lean.Meta.Match.InjectionAnyResult.subgoal.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.InjectionAnyResult.subgoal, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.InjectionAnyResult.subgoal]]
[Lean.Lsp.CompletionItem.mk.inj,[And.intro],[And, Eq]]
[Lean.Macro.expandMacro?,[Bind.bind, Lean.Macro.getMethods, Lean.Macro.Methods.expandMacro?],[Lean.MacroM, Option, Lean.Syntax]]
[Lean.Elab.applyAttributesOf,[Bind.bind, ForIn.forIn, PUnit.unit, Lean.Elab.Term.applyAttributesAt, Lean.Elab.PreDefinition.declName, Lean.Elab.Modifiers.attrs, Lean.Elab.PreDefinition.modifiers, Pure.pure, ForInStep.yield],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Server.publishProgressAtPos,[Lean.Server.publishProgress, List.toArray, List.cons, Lean.Lsp.LeanFileProgressProcessingInfo.mk, Lean.Lsp.Range.mk, Lean.FileMap.utf8PosToLspPos, Lean.Server.DocumentMeta.text, String.bsize, Lean.FileMap.source, List.nil],[IO, Unit]]
[Int.instNegInt,[Neg.mk, Int.neg],[Neg, Int]]
[Lean.OpaqueVal.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.CtorInfo.size,[],[Nat]]
[Lean.Parser.errorFn,[Lean.Parser.ParserState.mkUnexpectedError, List.nil],[Lean.Parser.ParserFn]]
[IO.FS.Stream.writeResponseError,[IO.FS.Stream.writeMessage, Lean.JsonRpc.Message.responseError, Lean.JsonRpc.ResponseError.id, Lean.JsonRpc.ResponseError.code, Lean.JsonRpc.ResponseError.message, Option.none],[IO, Unit]]
[instDecidableDite,[Decidable, dite],[Decidable, dite]]
[Lean.Parser.Command.terminationSuffix,[HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.terminationBy, Lean.Parser.Command.decreasingBy],[Lean.Parser.Parser]]
[Nat.mul_sub_left_distrib,[Eq.mpr, Eq.refl, Eq, HMul.hMul, HSub.hSub, Nat.mul_comm, Nat.mul_sub_right_distrib, rfl],[Eq, HMul.hMul, HSub.hSub]]
[Lean.Meta.IndPredBelow.Variables.params,[],[Array, Lean.Expr]]
[Nat.instDvdNat,[Dvd.mk, Exists, Eq, HMul.hMul],[Dvd, Nat]]
[Lean.Elab.Tactic.mkSimpContext,[ite, Eq, and, not, Lean.Syntax.isNone, Lean.Syntax.getOp, OfNat.ofNat, Bool.true, Bind.bind, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Elab.Tactic.TacticM, Lean.Elab.Tactic.MkSimpContextResult]]
[Lean.Parser.TokenCacheEntry.mk.inj,[And.intro],[And, Eq]]
[Lean.Core.instMonadCoreM,[Monad.mk],[Monad, Lean.Core.CoreM]]
[Lean.Parsec.satisfy,[Lean.Parsec.attempt, Bind.bind, Lean.Parsec.anyChar, ite, Eq, Bool.true, Pure.pure, Lean.Parsec.fail],[Lean.Parsec, Char]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isTrivialBottomUp,[Bind.bind, Lean.MonadOptions.getOptions, Pure.pure, or, Lean.Expr.isFVar, Lean.Expr.isConst, Lean.Expr.isMVar, Lean.Expr.isNatLit, Lean.Expr.isStringLit, Lean.Expr.isSort, and, Lean.getPPAnalyzeTrustOfNat, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.getPPAnalyzeTrustOfScientific],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM, Bool]]
[List.length'_eq_length,[Unit.unit, Eq, List.length', List.length, rfl, of_eq_true, Eq.trans, congr, congrArg, Nat.succ, PProd.fst, List.length_cons, eq_self],[Eq, List.length', List.length]]
[String.Iterator.hasPrev,[Bool, Decidable.decide, GT.gt, OfNat.ofNat],[Bool]]
[right_distributive,[Eq],[]]
[instAndOpUInt32,[AndOp.mk, UInt32.land],[AndOp, UInt32]]
[Lean.PrettyPrinter.Delaborator.instOrElseDelabM,[OrElse.mk, Lean.PrettyPrinter.Delaborator.orElse],[OrElse, Lean.PrettyPrinter.Delaborator.DelabM]]
[Lean.Parser.sepBy1NoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.sepBy1Info, Lean.Parser.Parser.info, Lean.Parser.sepBy1Fn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.ResolveName.resolveNamespace?,[Unit.unit, Option, Lean.Name, Lean.ResolveName.resolveNamespaceUsingScope, Option.some, Lean.ResolveName.resolveNamespaceUsingOpenDecls, Option.none],[Option, Lean.Name]]
[IO.Error.mkUnsupportedOperation,[IO.Error.unsupportedOperation],[IO.Error]]
[Lean.MessageData.ofName.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MessageData.ofName, HAdd.hAdd, OfNat.ofNat]]
[Nat.toUSize,[USize.ofNat],[USize]]
[Function.curry,[Prod.mk],[]]
[Lean.ClassState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ClassState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Expr.containsFVar,[Lean.Expr.hasAnyFVar, BEq.beq],[Bool]]
[Lean.Export.runExportM,[StateT.run', arbitrary],[Lean.Core.CoreM]]
[StateT.run_seq,[],[Eq, StateT.run, Seq.seq, Bind.bind, Functor.map, Prod.mk, Prod.fst, Prod.snd]]
[Lean.MetavarContext.instantiateLCtxMVars,[Lean.LocalContext.foldl, Prod, Lean.LocalContext, Lean.MetavarContext, Prod.mk, Lean.LocalContext.mkLocalDecl, Lean.LocalContext.mkLetDecl, Lean.LocalContext.mk, OfNat.ofNat],[Prod, Lean.LocalContext, Lean.MetavarContext]]
[Nat.lt_of_add_lt_add_right,[Nat.lt_of_add_lt_add_left, Eq.mpr, Eq.refl, LT.lt, HAdd.hAdd, Nat.add_comm],[LT.lt]]
[Lean.Meta.Closure.Context.zeta,[],[Bool]]
[Lean.KeyedDeclsAttribute.noConfusionType,[],[]]
[Lean.Elab.Term.instToStringSyntheticMVarKind,[ToString.mk, Unit.unit, String],[ToString, Lean.Elab.Term.SyntheticMVarKind]]
[Lean.Meta.UnificationHintEntry.val,[],[Lean.Name]]
[Fin.val_eq_of_eq,[rfl],[Eq, Fin.val]]
[Lean.Elab.Term.elabArrow,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Term.elabType, Lean.MonadQuotation.addMacroScope, Pure.pure, Lean.mkForall, Lean.BinderInfo.default, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElab]]
[Lean.Compiler.mkEagerLambdaLiftingName,[Lean.Name.mkStr, HAppend.hAppend, ToString.toString],[Lean.Name]]
[UInt32.instRingUInt32.proof_3,[congrArg, UInt32.mk, Ring.gsmul_succ', UInt32.val],[Eq, UInt32.mk, Ring.gsmul, Int.ofNat, Nat.succ, UInt32.val]]
[Lean.Meta.ReduceMatcherResult.noConfusionType,[],[]]
[Lean.Parser.Command.optNamedPrio.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.Command.namedPrio.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[mul_pow,[of_eq_true, Eq.trans, congr, congrArg, Eq, HPow.hPow, HMul.hMul, Nat.zero_eq, pow_zero, mul_one, OfNat.ofNat, eq_self, congrFun, mul_comm, Nat.succ, pow_succ', mul_assoc],[Eq, HPow.hPow, HMul.hMul]]
[Lean.Parser.Term.termBeforeDo,[Lean.Parser.withForbidden, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[UInt16.instSemiringUInt16.proof_4,[congrArg, UInt16.mk, AddMonoid.nsmul_succ', UInt16.val],[Eq, UInt16.mk, Semiring.nsmul, Nat.succ, UInt16.val]]
[Lean.SourceInfo.fromRef,[Option.none, Option.some, Lean.SourceInfo, Lean.Syntax.getPos?, Bool.false, Lean.Syntax.getTailPos?, Lean.SourceInfo.synthetic, Lean.SourceInfo.none],[Lean.SourceInfo]]
[instDecidableEqProd.proof_2,[absurd],[False]]
[Lean.Lsp.TextDocumentEdit.mk.inj,[And.intro],[And, Eq]]
[Decidable.imp_or_distrib,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, Decidable.imp_iff_not_or, Or.left_comm, Or, or_comm, Not, or_self, iff_self],[Iff, Or]]
[Char.val,[],[UInt32]]
[instHMul,[HMul.mk, Mul.mul],[HMul]]
[Lean.IR.NormalizeIds.withVar,[Bind.bind, getModify, HAdd.hAdd, OfNat.ofNat, Lean.IR.VarId.mk, Std.RBMap.insert, Lean.IR.VarId.idx],[Lean.IR.NormalizeIds.N]]
[ExceptT.run_bind_lift,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Bind.bind, map_eq_pure_bind, Except.ok, Except, Pure.pure, Except.error, LawfulMonad.bind_assoc, funext, LawfulMonad.pure_bind, eq_self],[Eq, ExceptT.run, Bind.bind, ExceptT.lift]]
[Lean.IR.Alt.default,[Lean.IR.AltCore.default],[Lean.IR.AltCore, Lean.IR.FnBody]]
[Lean.DataValue.ofString.inj,[],[Eq]]
[List.decidableBall.proof_1,[False.elim, Iff.mp, List.mem_nil],[]]
[Lean.Parser.Tactic.tacticSeq.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Tactic.tacticSeqBracketed.parenthesizer, Lean.Parser.Tactic.tacticSeq1Indented.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.CompletionOptions.noConfusionType,[],[]]
[Lean.PrettyPrinter.Formatter.checkKind,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, bne, Lean.Syntax.getKind, Bool.true, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.PrettyPrinter.FormatterM, Unit]]
[Lean.Elab.CompletionInfo.option.inj,[],[Eq]]
[Nat.beq,[Unit.unit, Bool, Bool.true, Bool.false, PProd.fst],[Bool]]
[Lean.Meta.Simp.Methods.post,[],[Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step]]
[not_iff_comm,[Decidable.not_iff_comm],[Iff, Not]]
[Lean.PrettyPrinter.Formatter.many1Unbox.formatter,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.nullKind, Bool.true, Lean.PrettyPrinter.Formatter.manyNoAntiquot.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.StructInst.Struct.below,[PProd, PUnit],[]]
[of_not_not,[by_contra],[]]
[FloatArray.forIn.loop.proof_1,[Nat.lt_of_le_of_lt, Nat.sub_le, HSub.hSub, FloatArray.size, OfNat.ofNat, Nat.sub_lt, Nat.zero_lt_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self, of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, HSub.hSub, FloatArray.size, OfNat.ofNat]]
[Lean.Parser.Term.inaccessible,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.Expr.replaceFVarId,[Lean.Expr.replaceFVar, Lean.mkFVar],[Lean.Expr]]
[ByteSliceT.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, ByteSliceT.mk, HAdd.hAdd, OfNat.ofNat]]
[Tactic.Ring.horner_add_horner_lt,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Tactic.Ring.horner, Eq.symm, OfNat.ofNat, of_eq_true, Eq.trans, congr, congrArg, add_comm, HMul.hMul, HPow.hPow, add_assoc, congrFun, add_zero, add_mul, mul_assoc, pow_add, eq_self],[Eq, HAdd.hAdd, Tactic.Ring.horner]]
[Lean.Elab.Tactic.evalInjection,[Bind.bind, Lean.Elab.Tactic.elabAsFVar, Lean.Syntax.getOp, OfNat.ofNat, Option.none, Lean.Elab.Tactic.liftMetaTactic, Lean.Meta.injection, Unit.unit, Lean.Meta.MetaM, List, Lean.MVarId, ite, Eq, List.isEmpty, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Syntax.missing, List.nil, List.cons],[Lean.Elab.Tactic.Tactic]]
[Lean.Meta.MVarRenaming.apply,[ite, Eq, not, Lean.Expr.hasMVar, Bool.true, Std.RBMap.isEmpty, Lean.Meta.MVarRenaming.map, Lean.Expr.replace, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Expr, Unit.unit, Std.RBMap.find?, Option.some, Lean.mkMVar, Option.none],[Lean.Expr]]
[Std.RBMap.fold,[Std.RBNode.fold],[]]
[Lean.Environment.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Attr.macro,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident],[Lean.Parser.Parser]]
[Lean.IR.instToFormatParam,[Std.ToFormat.mk, Std.Format, HAppend.hAppend, Std.Format.text, Std.ToFormat.format, ite, Eq, Bool.true],[Std.ToFormat, Lean.IR.Param]]
[Lean.IR.LitVal.num.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.LitVal.num, HAdd.hAdd, OfNat.ofNat]]
[Nat.gcd_dvd_gcd_of_dvd_right,[Nat.dvd_gcd, Nat.gcd_dvd_left, Nat.dvd_trans, Nat.gcd_dvd_right],[Dvd.dvd, Nat.gcd]]
[Lean.Parser.mkEmptySubstringAt,[Substring.mk],[Substring]]
[Id.hasBind,[inferInstance],[Bind, Id]]
[Lean.Lsp.DeclarationParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DeclarationParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.DeclarationParams.mk]]
[namedPattern,[],[]]
[Lean.Parser.Term.structInstField.parenthesizer,[Lean.Parser.ppGroup.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.structInstLVal.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.Do.ToCodeBlock.checkLetArrowRHS,[ite, Eq, or, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Elab.Term.Do.ToCodeBlock.M, Unit]]
[Lean.Expr.hasLevelMVar,[Lean.Expr.Data.hasLevelMVar, Lean.Expr.data],[Bool]]
[Lean.Elab.Term.SyntheticMVarKind.coe.inj,[And.intro],[And, Eq]]
[Lean.Server.RequestError.code,[],[Lean.JsonRpc.ErrorCode]]
[Lean.Syntax.MonadTraverser.st,[],[MonadState, Lean.Syntax.Traverser]]
[Std.Format.group.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.Format.group, HAdd.hAdd, OfNat.ofNat]]
[Function.injective.comp,[],[Function.injective, Function.comp]]
[Lean.Expr.FoldConstsImpl.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Expr.FoldConstsImpl.State.mk, HAdd.hAdd, OfNat.ofNat]]
[UInt16.instSemiringUInt16.proof_1,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt16.zero_def, UInt16.add_def, UInt16.mk, OfNat.ofNat, add_zero, UInt16.val, UInt16.mk_val_eq, eq_self, propext, forall_const, UInt16],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Function.injective2.right,[And.right],[Eq]]
[Lean.Meta.mkInjectiveEqTheoremNameFor,[HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Name]]
[String.Iterator.forward,[String.Iterator, PProd.fst, String.Iterator.next],[String.Iterator]]
[Lean.IR.CtorLayout.noConfusionType,[],[]]
[Nat.lt_succ_self,[Nat.lt.base],[LT.lt, Nat.succ]]
[Lean.Meta.DiscrTree.Key.arrow.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.DiscrTree.Key.arrow, OfNat.ofNat]]
[Nat.add_one_ne_zero,[Nat.succ_ne_zero],[Ne, HAdd.hAdd, OfNat.ofNat]]
[Lean.NamePart.str.inj,[],[Eq]]
[Lean.MessageData.ofFormat.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MessageData.ofFormat, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.structFields.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.manyIndent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGe.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.structExplicitBinder.parenthesizer, Lean.Parser.Command.structImplicitBinder.parenthesizer, Lean.Parser.Command.structInstBinder.parenthesizer, Lean.Parser.Command.structSimpleBinder.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[inv_mul_self,[mul_left_inv],[Eq, HMul.hMul, Inv.inv, OfNat.ofNat]]
[Lean.Elab.Command.expandMacro,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Option.some, Lean.Macro.throwUnsupported],[Lean.Macro]]
[Lean.Meta.Match.InjectionAnyResult.failed.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.Match.InjectionAnyResult.failed, OfNat.ofNat]]
[Lean.PrettyPrinter.Formatter.withMaybeTag,[Option.none, Lean.PrettyPrinter.Formatter, Bind.bind, Lean.PrettyPrinter.Formatter.concat, modify, Lean.PrettyPrinter.Formatter.State.mk, Lean.PrettyPrinter.Formatter.State.stxTrav, Lean.PrettyPrinter.Formatter.State.leadWord, Array.modify, Lean.PrettyPrinter.Formatter.State.stack, HSub.hSub, Array.size, OfNat.ofNat, Std.Format.tag],[Lean.PrettyPrinter.Formatter]]
[IO.FS.Stream.writeResponseErrorWithData,[IO.FS.Stream.writeMessage, Lean.JsonRpc.Message.responseError, Lean.JsonRpc.ResponseError.id, Lean.JsonRpc.ResponseError.code, Lean.JsonRpc.ResponseError.message, Option.map, Lean.ToJson.toJson, Lean.JsonRpc.ResponseError.data?],[IO, Unit]]
[Lean.MessageSeverity.noConfusion,[noConfusionEnum, Lean.MessageSeverity.toCtorIdx],[Lean.MessageSeverity.noConfusionType]]
[Quotient.inductionOn₂,[Quotient.ind],[]]
[USize.instNegUSize,[Neg.mk, USize.mk, Neg.neg, USize.val],[Neg, USize]]
[Lean.NameTrie.foldM,[Lean.NameTrie.foldMatchingM, Lean.Name.anonymous],[]]
[Lean.Elab.Command.instMonadOptionsCommandElabM,[Lean.MonadOptions.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Command.Scope.opts, List.head!, Lean.Elab.Command.State.scopes],[Lean.MonadOptions, Lean.Elab.Command.CommandElabM]]
[Lean.Parser.Command.macroTailCommand.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.identEq.formatter, Lean.Name.mkSimple, Lean.Parser.darrow.formatter, Lean.Parser.Command.macroRhs.formatter, Lean.PrettyPrinter.Formatter.many1Unbox.formatter, Lean.Parser.commandParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Lean.KVMap.findCore,[Option, Lean.DataValue, Option.none, ite, Eq, BEq.beq, Bool.true, Option.some, PProd.fst],[Option, Lean.DataValue]]
[Lean.IR.EmitC.overwriteParam,[Nat.any, Prod.anyI, Lean.IR.EmitC.paramEqArg, Array.getOp, Prod.mk, HAdd.hAdd, OfNat.ofNat],[Bool]]
[Lean.Expr.hasFVarEx,[Lean.Expr.hasFVar],[Bool]]
[Lean.Meta.addSimpLemma,[Bind.bind, Lean.getConstInfo, Lean.Meta.withReducible, Lean.Meta.inferType, Lean.Meta.isProp, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Meta.forallTelescopeReducing, not, Lean.Expr.isEq, or, ForIn.forIn, Lean.Meta.MetaM, ForInStep, Array, Lean.Meta.SimpLemma, Lean.Meta.mkAuxLemma, Lean.ConstantInfo.levelParams, Lean.Meta.instantiateMVars, Lean.Meta.withNewMCtxDepth, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.whnfR, Unit.unit, Lean.Expr.eq?, Lean.Meta.DiscrTree.mkPath, Prod.mk, Lean.mkConst, List.map, Lean.mkLevelParam, List.toArray, List.nil, Option.some, ForInStep.yield, List.cons, Lean.ScopedEnvExtension.add, Lean.Meta.SimpEntry.lemma],[Lean.Meta.MetaM, Unit]]
[Lean.Lsp.WorkspaceFolder.mk.inj,[And.intro],[And, Eq]]
[Lean.Level.getOffset,[Lean.Level.getOffsetAux, OfNat.ofNat],[Nat]]
[Lean.Meta.instInhabitedCaseValuesSubgoal,[Inhabited.mk, Lean.Meta.CaseValuesSubgoal.mk, arbitrary],[Inhabited, Lean.Meta.CaseValuesSubgoal]]
[Lean.Elab.WF.TerminationHint.one.inj,[],[Eq]]
[Lean.Elab.PreDefinition.mk.inj,[And.intro],[And, Eq]]
[«term_≥_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.isIdRest,[or, Char.isAlphanum, Decidable.decide, Eq, Char.ofNat, BEq.beq, Lean.isLetterLike, Lean.isSubScriptAlnum],[Bool]]
[Lean.Elab.Term.Do.convertTerminalActionIntoJmp,[Lean.Elab.Term.Do.convertTerminalActionIntoJmp.loop],[Lean.MacroM, Lean.Elab.Term.Do.Code]]
[Lean.IR.Expr.proj.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Expr.proj, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.IndPredBelow.mkCtorType.replaceTempVars,[Lean.Expr.replaceFVars, Lean.Meta.IndPredBelow.Variables.indVal, Array.map, Lean.mkConst, Lean.Meta.IndPredBelow.Context.belowNames],[Lean.Expr]]
[Lean.Server.DocumentMeta.mk.inj,[And.intro],[And, Eq]]
[Sdiff.noConfusionType,[],[]]
[Lean.Meta.SimpLemmas.erase,[ite, Eq, or, Lean.Meta.SimpLemmas.isLemma, Lean.Meta.SimpLemmas.isDeclToUnfold, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Meta.SimpLemmas]]
[Lean.instDecidableEqModuleIdx,[instDecidableEqNat],[DecidableEq, Lean.ModuleIdx]]
[Monoid.toSemigroup,[],[Semigroup]]
[Std.RBTree.min,[Unit.unit, Option, Std.RBMap.min, Option.some, Option.none],[Option]]
[Lean.Meta.Match.Unify.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.Unify.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.nameLitNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.nameLitFn],[Lean.Parser.Parser]]
[Lean.Elab.InfoTree.context.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.InfoTree.context, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.InfoTree.context, And]]
[Std.Format.appendEx,[Std.Format.append],[Std.Format]]
[Lean.charLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Lean.instInhabitedModuleIdx,[inferInstanceAs, Inhabited, Nat],[Inhabited, Lean.ModuleIdx]]
[Lean.Parser.ppLine.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.skip.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.namedArgs,[],[Array, Lean.Name]]
[Lean.Meta.substEqs,[Bind.bind, Lean.Meta.casesRec, Lean.Meta.instantiateMVars, Lean.LocalDecl.type, Pure.pure, or, Lean.Expr.isEq, Lean.Expr.isHEq, Lean.Meta.exactlyOne, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.Elab.Command.shouldInferResultUniverse,[Bind.bind, liftM, Lean.Meta.instantiateLevelMVars, ite, Eq, Lean.Level.hasMVar, Bool.true, Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Elab.Term.TermElabM, Bool, Lean.Level.getLevelOffset, Lean.Elab.Term.assignLevelMVar, Lean.Elab.Command.tmpIndParam, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkSort, Bool.false],[Lean.Elab.Term.TermElabM, Bool]]
[Nat.toFloat,[Float.ofNat],[Float]]
[Lean.Lsp.TextDocumentContentChangeEvent.fullChange.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.TextDocumentContentChangeEvent.fullChange, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.TextDocumentContentChangeEvent.fullChange]]
[Fin.checkedAdd,[Option, Fin, Fin.overflowingAdd, Option.none, Option.some],[Option, Fin]]
[Lean.Elab.runTactic,[Bind.bind, modifyThe, Lean.Meta.State, Lean.Meta.State.mk, Lean.MetavarContext.instantiateMVarDeclMVars, Lean.Meta.State.mctx, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed, Lean.Elab.Term.TermElabM.run],[Lean.Meta.MetaM, Prod, List, Lean.MVarId, Lean.Elab.Term.State]]
[plift.up.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, plift.up, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.FileWorker.EditableDocument.noConfusionType,[],[]]
[Lean.Elab.Tactic.evalSkip,[Pure.pure, Unit.unit],[Lean.Elab.Tactic.Tactic]]
[Lean.Meta.FVarSubst.any,[Std.AssocList.any, Lean.Meta.FVarSubst.map],[Bool]]
[Lean.Parser.unicodeSymbolFnAux,[Lean.Parser.satisfySymbolFn, or, BEq.beq],[Lean.Parser.ParserFn]]
[Std.Range.step,[],[Nat]]
[Lean.Elab.ElabInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.ElabInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[String.utf8ByteSize,[Nat, PProd.fst, HAdd.hAdd, String.csize, OfNat.ofNat],[Nat]]
[Lean.IR.addParamRename,[ite, Eq, and, BEq.beq, Lean.IR.Param.ty, Decidable.decide, Lean.IR.Param.borrow, Bool.true, Option.some, Lean.IR.addVarRename, Lean.IR.VarId.idx, Lean.IR.Param.x, Option.none],[Option, Lean.IR.IndexRenaming]]
[Lean.Elab.Term.ExtractMonadResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.ExtractMonadResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.ExtractMonadResult.mk, And]]
[Std.PersistentArray.toList,[List.reverse, Std.PersistentArray.foldl, List.cons, List.nil, OfNat.ofNat],[List]]
[Lean.IR.LogEntry.step.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.unfoldCases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[FloatArray.foldl,[Id.run, FloatArray.foldlM],[]]
[Lean.Elab.Command.StructFieldView.noConfusionType,[],[]]
[Lean.Parser.maxPrec,[OfNat.ofNat],[Nat]]
[Task.bind,[Task.pure, Task.get],[Task]]
[Lean.IR.LitVal.str.injEq,[Eq.propIntro, Eq.refl, Lean.IR.LitVal.str, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.LitVal.str]]
[Lean.Parser.Term.app.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.leadPrec, Lean.Parser.maxPrec, Lean.Parser.many1.formatter, Lean.Parser.Term.argument.formatter],[Lean.PrettyPrinter.Formatter]]
[UInt64.instSemiringUInt64.proof_2,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt64.zero_def, UInt64.add_def, UInt64.mk, OfNat.ofNat, zero_add, UInt64.val, UInt64.mk_val_eq, eq_self, propext, forall_const, UInt64],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.manyFn,[Lean.Parser.ParserState.mkNode, Lean.nullKind],[Lean.Parser.ParserFn]]
[Lean.Elab.Info.tailPos?,[Lean.Syntax.getTailPos?, Lean.Elab.Info.stx, Bool.true],[Option, String.Pos]]
[Lean.Elab.Tactic.evalRotateRight,[Bind.bind, Lean.Elab.Tactic.getGoals, Lean.Elab.Tactic.setGoals, List.rotateRight],[Lean.Elab.Tactic.Tactic]]
[Lean.Parser.Term.let_fun,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, HOrElse.hOrElse, Lean.Parser.symbol, Lean.Parser.Term.letDecl, Lean.Parser.Term.optSemicolon, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.Parser.Term.macroLastArg,[HOrElse.hOrElse, Lean.Parser.Term.macroDollarArg, Lean.Parser.Term.macroArg],[Lean.Parser.Parser]]
[UInt8.toUInt32,[Nat.toUInt32, UInt8.toNat],[UInt32]]
[Lean.Lsp.SemanticTokensLegend.tokenTypes,[],[Array, String]]
[Lean.Elab.WF.TerminationHint.many.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.WF.TerminationHint.many, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.WF.TerminationHint.many]]
[Lean.Parser.Term.precheckedQuot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.quot.formatter],[Lean.PrettyPrinter.Formatter]]
[monadFunctorRefl,[MonadFunctorT.mk],[MonadFunctorT]]
[Lean.Parser.Command.syntax.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.docComment.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optPrecedence.parenthesizer, Lean.Parser.Command.optNamedName.parenthesizer, Lean.Parser.Command.optNamedPrio.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.syntaxParser.parenthesizer, Lean.Parser.argPrec, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Tactic.Ring.horner_atom,[of_eq_true, Eq.trans, congrArg, Eq, congrFun, HAdd.hAdd, HMul.hMul, OfNat.ofNat, pow_one, one_mul, add_zero, eq_self],[Eq, Tactic.Ring.horner, OfNat.ofNat]]
[Lean.Elab.Command.Scope.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Command.Scope.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.PlainTermGoal.goal,[],[String]]
[IO.Error.resourceExhausted.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.resourceExhausted, HAdd.hAdd, OfNat.ofNat]]
[Semigroup.toMul,[],[Mul]]
[Lean.instBEqMessageSeverity,[BEq.mk, BEq.beq, Lean.MessageSeverity.toCtorIdx],[BEq, Lean.MessageSeverity]]
[rfl,[rfl.proof_1],[Eq]]
[ByteArray.mk.inj,[],[Eq]]
[Int.add_left_comm,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Eq.symm, Int.add_assoc, Int.add_comm, rfl],[Eq, HAdd.hAdd]]
[Lean.Core.Context.maxRecDepth,[],[Nat]]
[instInhabitedEST,[inferInstanceAs, Inhabited, EStateM],[Inhabited, EST]]
[Lean.Elab.Term.StructInst.Source.noConfusionType,[],[]]
[Lean.Parser.Command.ctor,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.declModifiers, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.Command.inferMod, Lean.Parser.Command.optDeclSig],[Lean.Parser.Parser]]
[Nat.gcd_mul_dvd_mul_gcd,[Dvd.dvd, Nat.gcd, HMul.hMul, Nat.prod_dvd_and_dvd_of_dvd_prod, Nat.gcd_dvd_right],[Dvd.dvd, Nat.gcd, HMul.hMul]]
[HAndThen.hAndThen,[],[]]
[Lean.Meta.throwIncorrectNumberOfLevels,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkConst],[Lean.Meta.MetaM]]
[Lean.Elab.DefView.binders,[],[Lean.Syntax]]
[Lean.NameTrie.insert,[Lean.PrefixTree.insert, List.nil, List, Lean.NamePart, PProd.fst, List.cons, Lean.NamePart.str, Lean.NamePart.num],[Lean.NameTrie]]
[List.decidableBexi.proof_4,[Exists, And, Mem.mem, List.cons],[Exists, And, Mem.mem, List.cons]]
[Lean.Lsp.DiagnosticSeverity.warning.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.DiagnosticSeverity.warning, OfNat.ofNat]]
[Std.RBMap.fromList,[List.foldl, Std.RBMap.insert, Prod.fst, Prod.snd, Std.mkRBMap],[Std.RBMap]]
[Lean.Parser.withForbidden,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.Parser.fn, Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.prec, Lean.Parser.ParserContext.tokens, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Parser.ParserContext.savedPos?, Option.some],[Lean.Parser.Parser]]
[Lean.Meta.DefEqContext.noConfusionType,[],[]]
[Nat.dvd_mul_left,[Exists.intro, Nat.mul_comm],[Dvd.dvd, HMul.hMul]]
[Lean.Elab.Term.elabMutualDef.go,[Bind.bind, Lean.Elab.Term.getLevelNames, ForIn.forIn, Lean.withRef, Lean.Elab.DefView.ref, Lean.MonadResolveName.getCurrNamespace, Lean.Elab.expandDeclId, Lean.Elab.DefView.declId, Lean.Elab.DefView.modifiers, Lean.Elab.Term.TermElabM, Lean.Elab.DefViewElabHeader, Lean.Elab.addDeclarationRanges, Lean.Elab.Term.applyAttributesAt, Lean.Elab.Modifiers.attrs, Lean.AttributeApplicationTime.beforeElaboration, Lean.Elab.Term.withDeclName, Lean.Elab.Term.withAutoBoundImplicit, Lean.Elab.Term.withLevelNames, Lean.Elab.Term.elabBindersEx, Lean.Syntax.getArgs, Lean.Elab.DefView.binders, Unit.unit, Lean.Elab.DefView.type?, Lean.Elab.Term.elabType, Lean.Elab.Term.registerCustomErrorIfMVar, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Pure.pure, PUnit.unit, ForInStep.yield, StateRefT'.run', OfNat.ofNat, Array.mapM, liftM, Lean.Meta.instantiateMVars, Lean.Elab.DefViewElabHeader.type, Lean.Elab.DefViewElabHeader.mk, Lean.Elab.DefViewElabHeader.ref, Lean.Elab.DefViewElabHeader.modifiers, Lean.Elab.DefViewElabHeader.kind, Lean.Elab.DefViewElabHeader.shortDeclName, Lean.Elab.DefViewElabHeader.declName, Lean.Elab.DefViewElabHeader.levelNames, Lean.Elab.DefViewElabHeader.binderIds, Lean.Elab.DefViewElabHeader.numParams, Lean.Elab.DefViewElabHeader.valueStx, MProd.mk, StateRefT', IO.RealWorld, Nat, ForInStep, MProd, Array, Subarray, Stream.next?, ForInStep.done, List.toArray, List.nil, Lean.Elab.liftMacroM, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Term.expandWhereDeclsOpt, Lean.Syntax.getOp, Lean.Elab.Term.expandMatchAltsWhereDecls, Lean.MacroM, Lean.Syntax, OptionM.run, Array.sequenceMap, cond, Lean.Syntax.isNone, Lean.Syntax.matchesNull, Option.none, Lean.Macro.throwErrorAt, Lean.Elab.Term.expandLetEqnsDecl, Lean.Macro.throwUnsupported, Option.some, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, List.cons, Lean.Syntax.atom, Array.append, Array.map, Lean.Syntax.isMissing, Lean.Meta.forallBoundedTelescope, Lean.Elab.Term.addTermInfo, Array.getOp, HAdd.hAdd, HSub.hSub, Array.size, Lean.Elab.Term.elabTermEnsuringType, Lean.Meta.mkLambdaFVars, Bool.false, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Lean.Elab.Term.getLetRecsToLift, List.mapM, Lean.Elab.Term.LetRecToLift.type, Lean.Elab.Term.LetRecToLift.val, Lean.Elab.Term.LetRecToLift.mk, Lean.Elab.Term.LetRecToLift.ref, Lean.Elab.Term.LetRecToLift.fvarId, Lean.Elab.Term.LetRecToLift.attrs, Lean.Elab.Term.LetRecToLift.shortDeclName, Lean.Elab.Term.LetRecToLift.declName, Lean.Elab.Term.LetRecToLift.lctx, Lean.Elab.Term.LetRecToLift.localInstances, Lean.Elab.Term.LetRecToLift.mvarId, List.forM, PUnit, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.FVarId, Lean.Meta.findLocalDecl?, Lean.Name, Lean.LocalDecl.userName, List.findSome?, BEq.beq, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.throwErrorAt, HAppend.hAppend, StateRefT'.run, Array.forM, Lean.Meta.collectUsedFVars, Lean.CollectFVars.State.mk, Prod, Lean.LocalContext, Lean.LocalInstances, Lean.Expr, Lean.Meta.removeUnused, Lean.Meta.withLCtx, Lean.Elab.Term.MutualClosure.main, Lean.isTracingEnabledFor, Lean.addTrace, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.type, Lean.Elab.PreDefinition.value, Lean.Elab.levelMVarToParamPreDecls, Lean.Elab.instantiateMVarsAtPreDecls, Lean.Elab.fixLevelParams, Lean.Elab.addPreDefinitions, Lean.Elab.Term.elabMutualDef.processDeriving],[Lean.Elab.Term.TermElabM, Unit]]
[List.mem_of_mem_remove,[And.left, Eq.mp, Eq.refl, Mem.mem, List.remove, propext, List.mem_remove_iff],[Mem.mem]]
[Lean.Server.FileWorker.handleCompletion,[Bind.bind, Lean.Server.RequestM.readDoc, Lean.Server.RequestM.withWaitFindSnap, Decidable.decide, GE.ge, HAdd.hAdd, Lean.Server.Snapshots.Snapshot.endPos, OfNat.ofNat, Pure.pure, Lean.Lsp.CompletionList.mk, Bool.true, List.toArray, List.nil, liftM, Lean.Server.Completion.find?, Lean.Server.DocumentMeta.text, Lean.Server.FileWorker.EditableDocument.meta, Lean.Server.Snapshots.Snapshot.infoTree, Option.none, Lean.Server.RequestM, Lean.Lsp.CompletionList, PUnit.unit],[Lean.Server.RequestM, Lean.Server.RequestTask, Lean.Lsp.CompletionList]]
[Lean.Elab.Term.Do.ToTerm.Context.kind,[],[Lean.Elab.Term.Do.ToTerm.Kind]]
[Lean.Elab.Command.StructFieldInfo.kind,[],[Lean.Elab.Command.StructFieldKind]]
[Lean.Expr.below,[PUnit, PProd],[]]
[Lean.Meta.Simp.ConfigCtx.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Simp.ConfigCtx.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Simp.ConfigCtx.mk]]
[let_value_heq,[Eq.mpr, Eq.refl, HEq, HEq.rfl],[HEq]]
[Lean.unreachIsNodeIdent.proof_1,[Eq.refl, Lean.Syntax.ident, HEq.refl, False],[False]]
[ByteArray.forIn,[ByteArray.size, Nat.le_refl, ByteArray.forIn.loop],[]]
[Fin.shiftLeft,[Fin, Fin.mk, HMod.hMod, HShiftLeft.hShiftLeft, Fin.shiftLeft.proof_1],[Fin]]
[«term_≤_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Meta.Closure.MkValueTypeClosureResult.noConfusionType,[],[]]
[Nat.gcd_mul_left_left,[Nat.dvd_antisymm, Nat.gcd_dvd_right, HMul.hMul, Nat.dvd_gcd, Nat.dvd_mul_left, Nat.dvd_refl],[Eq, Nat.gcd, HMul.hMul]]
[List.foldlM,[Pure.pure, Bind.bind, PProd.fst],[]]
[Lean.instInhabitedEnvironment,[Inhabited.mk, Lean.Environment.mk, arbitrary],[Inhabited, Lean.Environment]]
[Lean.AddErrorMessageContext.noConfusionType,[],[]]
[MonadControl.restoreM,[],[]]
[Nat.mul_div_mul,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, Eq.symm, Nat.div_div_eq_div_mul, Nat.mul_div_cancel_left, rfl],[Eq, HDiv.hDiv, HMul.hMul]]
[Lean.IR.FnBody.inc.inj,[And.intro],[And, Eq]]
[Lean.Parser.Command.open_locale,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Nat.anyM,[Nat.anyM.loop],[Bool]]
[Lean.JsonRpc.Request.id,[],[Lean.JsonRpc.RequestID]]
[Lean.Server.FileWorker.Reference.noConfusionType,[],[]]
[List.bex_cons,[Iff.intro, Or, Exists, And, Mem.mem, Eq.mp, propext, List.mem_cons_iff, Or.inl, Eq.refl, Eq.symm, Or.inr, Exists.intro, And.intro, Or.elim, List.mem_cons_self, List.cons, List.mem_cons_of_mem],[Iff, Exists, And, Mem.mem, List.cons, Or]]
[Lean.JsonRpc.ErrorCode.invalidRequest.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.JsonRpc.ErrorCode.invalidRequest, OfNat.ofNat]]
[Lean.Parser.Term.termFor.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.Term.doForDecl.formatter, Bool.false, Lean.Parser.Term.doSeq.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Tactic.specialize,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.rhss,[],[Array, Lean.Syntax]]
[Lean.mkLevelMaxEx,[Lean.mkLevelMax],[Lean.Level]]
[Lean.Lsp.instFromJsonCancelParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.JsonRpc.RequestID, Pure.pure, Lean.Lsp.CancelParams.mk],[Lean.FromJson, Lean.Lsp.CancelParams]]
[Lean.Meta.Closure.ToProcessElement.mk.inj,[And.intro],[And, Eq]]
[iff_iff_not_or_and_or_not,[Decidable.iff_iff_not_or_and_or_not],[Iff, And, Or, Not]]
[self_eq_add_right,[Eq.mpr, Eq.refl, Iff, Eq, HAdd.hAdd, OfNat.ofNat, Eq.symm, propext, add_left_cancel_iff, add_zero, eq_comm, Iff.rfl],[Iff, Eq, HAdd.hAdd, OfNat.ofNat]]
[Lean.ExprStructEq.instBEqExprStructEq,[BEq.mk, Lean.ExprStructEq.beq],[BEq, Lean.ExprStructEq]]
[Function.update_noteq,[dif_neg],[Eq, Function.update]]
[Lean.Parser.ParserExtension.State.categories,[],[Lean.Parser.ParserCategories]]
[Lean.Expr.natLit?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.strVal, Lean.Expr.mdata, Lean.Expr.proj, Option, Nat, Option.some, Option.none],[Option, Nat]]
[ge_trans,[le_trans],[GE.ge]]
[Lean.Server.Watchdog.findFileWorker?,[Bind.bind, MonadReader.read, ST.Ref.get, Lean.Server.Watchdog.ServerContext.fileWorkersRef, Pure.pure, Std.RBMap.find?],[Lean.Server.Watchdog.ServerM, Option, Lean.Server.Watchdog.FileWorker]]
[Lean.Parser.Term.termUnless.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withForbidden.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Term.subst.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.termParser.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.MessageData.nest.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MessageData.nest, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MessageData.nest, And]]
[Lean.Parser.Tactic.Conv.rhs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Lsp.CompletionParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.CompletionParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.CompletionParams.mk]]
[PSum.inl.inj,[],[Eq]]
[Lean.PrettyPrinter.Parenthesizer.withoutInfo.parenthesizer,[],[Lean.PrettyPrinter.Parenthesizer]]
[List.length_eq_one,[Iff.intro, Exists, Eq, List.cons, List.nil, Exists.intro, rfl, Eq.mp, Eq.trans, congrFun, congrArg, List.length_cons, Nat.succ, OfNat.ofNat, Nat.succ.injEq, HAdd.hAdd, List.length, Eq.mpr, Eq.refl, of_eq_true, List.length_singleton, eq_true_of_decide, Bool.true],[Iff, Eq, List.length, OfNat.ofNat, Exists, List.cons, List.nil]]
[Std.RBNode.min,[Unit.unit, Std.RBNode.node, Option, Sigma, Option.none, Option.some, Sigma.mk, PProd.fst],[Option, Sigma]]
[Lean.PersistentExprSet,[Std.PHashSet, Lean.Expr],[]]
[Lean.Meta.Closure.ToProcessElement.newFVarId,[],[Lean.FVarId]]
[UInt8.isDigit,[and, Decidable.decide, GE.ge, OfNat.ofNat, LE.le],[Bool]]
[Lean.LocalDecl.noConfusionType,[],[]]
[Lean.Meta.Context.config,[],[Lean.Meta.Config]]
[Lean.PrettyPrinter.Delaborator.orElse,[Lean.catchInternalId, Lean.PrettyPrinter.Delaborator.delabFailureId, Unit.unit],[Lean.PrettyPrinter.Delaborator.DelabM]]
[Lean.Expr.proj.inj,[And.intro],[And, Eq]]
[Lean.Parser.many1Fn,[Lean.Parser.ParserState.mkNode, Lean.nullKind],[Lean.Parser.ParserFn]]
[instMonadWithReader,[MonadWithReader.mk, withTheReader],[MonadWithReader]]
[Lean.FileMap.source,[],[String]]
[Lean.Meta.isDefEqBindingDomain,[OfNat.ofNat, Lean.Meta.isDefEqBindingDomain.loop],[Lean.Meta.MetaM, Bool]]
[Lean.BinderInfo.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Parser.Tactic.ring!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[List.noConfusionType,[],[]]
[exists_imp_distrib,[Iff.intro, Exists.intro],[Iff]]
[exists₂_congr,[exists_congr],[Iff, Exists]]
[floatDecLe,[Float.decLe],[Decidable, LE.le]]
[Lean.LocalContext.contains,[Std.PersistentHashMap.contains, Lean.LocalContext.fvarIdToDecl],[Bool]]
[Lean.Parser.Term.syntheticHole,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, HOrElse.hOrElse, Lean.Parser.Term.ident, Lean.Parser.Term.hole],[Lean.Parser.Parser]]
[Lean.Elab.Term.ppGoal,[liftM, Lean.Meta.ppGoal],[Lean.Elab.Term.TermElabM, Std.Format]]
[Tactic.Ring.mkAppCS,[Bind.bind, MonadReader.read, Pure.pure, Lean.mkAppN, Lean.mkConst, List.cons, Tactic.Ring.Cache.univ, List.nil, HAppend.hAppend, List.toArray, Tactic.Ring.Cache.α, Tactic.Ring.Cache.cs],[Tactic.Ring.RingM, Lean.Expr]]
[Lean.Lsp.instToJsonReferenceContext,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.ReferenceContext.includeDeclaration, List.nil],[Lean.ToJson, Lean.Lsp.ReferenceContext]]
[Lean.Parser.Command.declModifiersF,[Lean.Parser.Command.declModifiers, Bool.false],[Lean.Parser.Parser]]
[Std.PersistentHashMap.mkCollisionNode.proof_1,[rfl],[Eq, Array.size, Array.push, Array.mkEmpty, Std.PersistentHashMap.maxCollisions]]
[Nat.mul_succ,[rfl],[Eq, HMul.hMul, Nat.succ, HAdd.hAdd]]
[System.FilePath.isCaseInsensitive,[or, System.Platform.isWindows, System.Platform.isOSX],[Bool]]
[congr_arg,[congrArg],[Eq]]
[DivInvMonoid.gpow_zero',[],[Eq, DivInvMonoid.gpow, OfNat.ofNat]]
[Nat.instXorNat,[Xor.mk, Nat.xor],[Xor, Nat]]
[Lean.Elab.Term.Do.Code.action.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.Code.action, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.find,[Bind.bind, liftM, Lean.Meta.findCore, ForIn.forIn, Lean.Meta.ppExpr, Lean.ConstantInfo.type, Pure.pure, PUnit.unit, ForInStep.yield],[Lean.Elab.Term.TermElabM, String]]
[Lean.Elab.Term.ExtractMonadResult.m,[],[Lean.Expr]]
[Lean.Meta.SynthInstance.SubgoalsResult.mk.inj,[And.intro],[And, Eq]]
[Lean.getAttributeImpl,[Unit.unit, Except, String, Lean.AttributeImpl, Std.PersistentHashMap.find?, Pure.pure, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Except, String, Lean.AttributeImpl]]
[Inhabited.noConfusionType,[],[]]
[Quotient.recOnSubsingleton₂.proof_2,[],[Subsingleton, Quotient.mk]]
[Lean.Parser.Term.letMVar,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.termParser],[Lean.Parser.Parser]]
[and_iff_right_of_imp,[Iff.intro, And.right, And.intro],[Iff, And]]
[Lean.instToExprName,[Lean.ToExpr.mk, Lean.Name.toExprAux, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.ToExpr, Lean.Name]]
[instHashableUSize,[Hashable.mk, USize.toUInt64],[Hashable, USize]]
[Lean.Elab.Command.InductiveView.mk.inj,[And.intro],[And, Eq]]
[Fin.mod.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod]]
[Nat.gcd_zero_left,[rfl],[Eq, Nat.gcd, OfNat.ofNat]]
[Lean.Meta.setPostponed,[modify, Lean.Meta.State.mk, Lean.Meta.State.mctx, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds],[Lean.Meta.MetaM, Unit]]
[Lean.KeyedDeclsAttribute.ExtensionState.declNames,[],[Std.PHashSet, Lean.Name]]
[instReprId_1,[inferInstanceAs, Repr],[Repr, Id]]
[Tactic.DeclCache.mk,[Bind.bind, Tactic.Cache.mk, Lean.MonadOptions.getOptions, Lean.profileitM, Lean.Exception, Pure.pure, Lean.MonadEnv.getEnv, ForIn.forIn, Lean.Meta.MetaM, ForInStep, PUnit.unit, ForInStep.yield, Prod.mk],[IO, Tactic.DeclCache]]
[Lean.KVMap.set,[Lean.KVMap.insert, Lean.KVMap.Value.toDataValue],[Lean.KVMap]]
[EStateM.dummyRestore,[],[]]
[Lean.DelayedMetavarAssignment.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.instFromJsonInitializeParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.ClientCapabilities, Pure.pure, Lean.Lsp.InitializeParams.mk, Except.toOption],[Lean.FromJson, Lean.Lsp.InitializeParams]]
[Lean.Xml.Parser.markupDecl,[HOrElse.hOrElse, Lean.Xml.Parser.elementDecl, Lean.Xml.Parser.AttlistDecl, Lean.Xml.Parser.EntityDecl, Lean.Xml.Parser.NotationDecl, Lean.Xml.Parser.PI, SeqRight.seqRight, Lean.Xml.Parser.Comment, Pure.pure, Unit.unit],[Lean.Parsec, Unit]]
[Lean.Meta.UnificationConstraint.rhs,[],[Lean.Expr]]
[Lean.Parser.attrParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Parser.Parser]]
[Lean.PrettyPrinter.Parenthesizer.errorAtSavedPos.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.xor,[Nat.bitwise, bne],[Nat]]
[Subtype.equiv_iff,[Iff.rfl],[Iff, HasEquiv.Equiv, Subtype.val]]
[Lean.Server.FileWorker.WorkerContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.FileWorker.WorkerContext.mk, HAdd.hAdd, OfNat.ofNat]]
[NonScalar.val,[],[Nat]]
[Lean.Parser.ParserCache.tokenCache,[],[Lean.Parser.TokenCacheEntry]]
[Lean.Lsp.PlainTermGoal.mk.inj,[And.intro],[And, Eq]]
[Lean.Occurrences.neg.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Occurrences.neg, HAdd.hAdd, OfNat.ofNat]]
[imp_intro,[],[]]
[Lean.Parser.Term.proj,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, HOrElse.hOrElse, Lean.Parser.fieldIdx, Lean.Parser.Term.ident],[Lean.Parser.TrailingParser]]
[Lean.Elab.WF.TerminationStrategy.noConfusionType,[],[]]
[Add.noConfusionType,[],[]]
[Lean.ConstantInfo.inductInfo.injEq,[Eq.propIntro, Eq.refl, Lean.ConstantInfo.inductInfo, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ConstantInfo.inductInfo]]
[Lean.Expr.approxDepth,[Lean.Expr.Data.approxDepth, Lean.Expr.data],[UInt8]]
[Lean.RecursorVal.numParams,[],[Nat]]
[Lean.Elab.pushInfoLeaf,[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, ite, Eq, Lean.Elab.InfoState.enabled, Bool.true, Lean.Elab.pushInfoTree, Lean.Elab.InfoTree.node, Std.PersistentArray.mk, Pure.pure, PUnit.unit],[Unit]]
[Lean.IR.EmitC.emitLit,[Bind.bind, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.M, Unit, Lean.IR.EmitC.emitNumLit, Lean.IR.EmitC.emitLn, Lean.IR.EmitC.emit, Lean.IR.EmitC.quoteString],[Lean.IR.EmitC.M, Unit]]
[instHModUInt8NatUInt8,[HMod.mk, UInt8.modn],[HMod, UInt8, Nat]]
[Lean.IR.Sorry.visitDecl,[Lean.IR.Decl.extern, Lean.IR.Sorry.M, Unit, Bind.bind, MonadState.get, Unit.unit, Lean.NameMap.find?, Lean.IR.Sorry.State.localSorryMap, Pure.pure, ExceptT.run, Lean.IR.Sorry.visitFndBody, modify, Lean.IR.Sorry.State.mk, Lean.NameMap.insert, Bool.true],[Lean.IR.Sorry.M, Unit]]
[Std.HashMapImp.mk.inj,[And.intro],[And, Eq]]
[Lean.QuotVal.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.termReturn.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkLineEq.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.lor,[Nat.bitwise, or],[Nat]]
[Std.HashMapImp.contains,[Bool, Std.AssocList.contains, Array.uget, Subtype.val],[Bool]]
[List.not_mem_append,[mt, Iff.mp, List.mem_append, Iff.mpr, not_or, Mem.mem, And.intro],[Not, Mem.mem, HAppend.hAppend]]
[Lean.Elab.Command.CollectAxioms.State.visited,[],[Lean.NameSet]]
[Squash,[Quot, True],[]]
[Lean.Lsp.PlainTermGoalParams.toTextDocumentPositionParams,[],[Lean.Lsp.TextDocumentPositionParams]]
[Lean.Elab.Term.StructInst.FieldVal.nested.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.StructInst.FieldVal.nested, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.StructInst.FieldVal.nested]]
[Lean.Compiler.instInhabitedSpecState,[Inhabited.mk, Lean.Compiler.SpecState.mk, arbitrary],[Inhabited, Lean.Compiler.SpecState]]
[Lean.IR.ExpandResetReuse.mkSlowPath,[Array.foldl, Unit.unit, Lean.IR.FnBody, Lean.IR.FnBody.inc, OfNat.ofNat, Bool.true, Bool.false, Array.size],[Lean.IR.FnBody]]
[instSubsingletonForall.proof_1,[Subsingleton.intro, funext, Subsingleton.elim],[Subsingleton]]
[Lean.Lsp.instToJsonPlainGoal,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.PlainGoal.rendered, List.nil, Lean.Lsp.PlainGoal.goals],[Lean.ToJson, Lean.Lsp.PlainGoal]]
[Lean.instFromJsonJson,[Lean.FromJson.mk, Except.ok],[Lean.FromJson, Lean.Json]]
[Std.HashSet.toArray,[Std.HashSet.fold, Array.push, List.toArray, List.nil],[Array]]
[Int.quot,[Int, Int.ofNat, HDiv.hDiv, Neg.neg, Nat.succ],[Int]]
[Nat.sub_self,[Unit.unit, Eq, HSub.hSub, OfNat.ofNat, Eq.mpr, Eq.refl, Nat.sub_zero, rfl, Nat.succ, Nat.succ_sub_succ, PProd.fst],[Eq, HSub.hSub, OfNat.ofNat]]
[Lean.Parser.Tactic.unfold1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Parser.Term.doMatch.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.generalizingParam.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.Term.matchDiscr.formatter, Bool.false, Lean.Parser.Term.optType.formatter, Lean.Parser.Term.doMatchAlts.formatter],[Lean.PrettyPrinter.Formatter]]
[List.instSubsetList,[Subset.mk, List.subset],[Subset, List]]
[Lean.MetavarContext.MkBinding.abstractRange,[Bind.bind, Lean.MetavarContext.MkBinding.elimMVarDeps, Pure.pure, Lean.Expr.abstractRange],[Lean.MetavarContext.MkBinding.M, Lean.Expr]]
[Lean.Meta.DiscrTree.Trie.node.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.DiscrTree.Trie.node, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.DiscrTree.Trie.node, And]]
[Lean.OpenDecl.simple.inj,[And.intro],[And, Eq]]
[IO.FS.Stream.chainLeft,[IO.FS.Stream.mk, IO.FS.Stream.isEof, SeqRight.seqRight, IO.FS.Stream.flush, IO.FS.Stream.read, Bind.bind, IO.FS.Stream.write, ite, Eq, Bool.true, Pure.pure, PUnit.unit, IO.FS.Stream.getLine, IO.FS.Stream.putStr],[IO.FS.Stream]]
[EStateM.instMonadExceptOfEStateM,[MonadExceptOf.mk, EStateM.throw, EStateM.tryCatch],[MonadExceptOf, EStateM]]
[Lean.Elab.DefKind.abbrev.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.DefKind.abbrev, OfNat.ofNat]]
[Lean.Meta.CongrTheorem.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.CongrTheorem.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.CongrTheorem.mk, And]]
[Lean.Name.escapePart,[ite, Eq, and, Decidable.decide, GT.gt, String.length, OfNat.ofNat, Lean.isIdFirst, String.getOp, Substring.all, Substring.drop, String.toSubstring, Lean.isIdRest, Bool.true, Option.some, String.any, Lean.isIdEndEscape, Option.none, HAppend.hAppend, Char.toString, Lean.idBeginEscape, Lean.idEndEscape],[Option, String]]
[Lean.«doElemTrace[__]__»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.instInhabitedParserInfo,[Inhabited.mk, Lean.Parser.ParserInfo.mk, arbitrary],[Inhabited, Lean.Parser.ParserInfo]]
[Lean.Parser.Tactic.nthRwLHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Nat.succ.inj,[],[Eq]]
[unsafeIO,[unsafeEIO],[Except, IO.Error]]
[Function.update_comm,[funext, Decidable.em, Eq, Eq.mpr, Eq.refl, dite, Eq.symm, dif_pos, Eq.trans, dif_neg, rfl],[Eq, Function.update]]
[Std.RBMap.max,[Option, Prod, Unit.unit, Std.RBNode.max, Option.some, Prod.mk, Option.none],[Option, Prod]]
[Lean.TraceElem.ref,[],[Lean.Syntax]]
[Lean.Parser.instBEqError,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Parser.Error]]
[List.mem_map_of_mem,[Mem.mem, List.map, List.nil, Eq.refl, Eq.mpr, List.cons, Or.inl, rfl, Eq.symm, Or.inr],[Mem.mem, List.map]]
[Array.anyM,[dite, LE.le, Array.size, Array.anyM.proof_1],[Bool]]
[Lean.Xml.Content.Comment.injEq,[Eq.propIntro, Eq.refl, Lean.Xml.Content.Comment, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Xml.Content.Comment]]
[Prod.map_comp_map,[funext, of_eq_true, Eq.trans, congr, congrArg, Eq, Function.comp_apply, Prod.map, prod_map, Prod.mk, Prod.fst, Prod.snd, Function.comp, eq_self],[Eq, Function.comp, Prod.map]]
[Lean.Name.quickCmp,[Ordering.lt, Unit.unit, Ordering.gt, Ordering, Ord.compare, Lean.Name.hash, Lean.Name.quickCmpAux],[Ordering]]
[Lean.IR.instAlphaEqvExpr,[Lean.IR.AlphaEqv.mk, Lean.IR.Expr.alphaEqv],[Lean.IR.AlphaEqv, Lean.IR.Expr]]
[Array.eraseIdx',[Array.eraseIdxSzAux, HAdd.hAdd, Fin.val, OfNat.ofNat, Array.eraseIdx'.proof_1],[Subtype, Eq, Array.size, HSub.hSub, OfNat.ofNat]]
[Lean.Parser.Tactic.rcases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.casesTarget, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.instReprDeclarationRanges,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.DeclarationRanges.range, Std.Format.line, Lean.DeclarationRanges.selectionRange],[Repr, Lean.DeclarationRanges]]
[Array.binInsertM,[ite, Eq, Array.isEmpty, Bool.true, Bind.bind, Unit.unit, Pure.pure, Array.push, Array.get!, OfNat.ofNat, Array.insertAt, not, Array.modifyM, Array.back, HSub.hSub, Array.size],[Array]]
[Lean.Parser.Syntax.unary.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.syntaxParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.unreachIsNodeIdent,[False.elim, Lean.unreachIsNodeIdent.proof_1],[]]
[List.decidableBexi,[Unit.unit, Decidable, Exists, And, Mem.mem, Decidable.isFalse, List.decidableBexi.proof_1, List.cons, Decidable.isTrue, List.decidableBexi.proof_2, PProd.fst, List.decidableBexi.proof_3, List.decidableBexi.proof_4],[Decidable, Exists, And, Mem.mem]]
[Lean.Lsp.PublishDiagnosticsParams.noConfusionType,[],[]]
[Lean.Elab.Info.stx,[Lean.Syntax, Lean.Elab.ElabInfo.stx, Lean.Elab.TacticInfo.toElabInfo, Lean.Elab.TermInfo.toElabInfo, Lean.Elab.CommandInfo.toElabInfo, Lean.Elab.MacroExpansionInfo.stx, Lean.Elab.FieldInfo.stx, Lean.Elab.CompletionInfo.stx],[Lean.Syntax]]
[instComplementUInt16,[Complement.mk, UInt16.complement],[Complement, UInt16]]
[Lean.Lsp.Trace.messages.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.Trace.messages, OfNat.ofNat]]
[«term_<&&>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.AxiomVal.isUnsafe,[],[Bool]]
[Lean.Parser.Command.check_failure,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.Meta.SimpLemmas.mk.inj,[And.intro],[And, Eq]]
[Set.singletonUnexpander,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesIdent, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[AddGroup.add_left_neg,[],[Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat]]
[Lean.PrettyPrinter.Parenthesizer.manyNoAntiquot.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.PrettyPrinter.Parenthesizer.visitArgs, Nat.forM, Array.size, Lean.Syntax.getArgs],[Lean.PrettyPrinter.Parenthesizer]]
[List.foldl,[PProd.fst],[]]
[Lean.ConstantInfo.ctorInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ConstantInfo.ctorInfo, HAdd.hAdd, OfNat.ofNat]]
[ByteSliceT.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, ByteSliceT.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, ByteSliceT.mk, And]]
[Lean.Export.Entry.defn.injEq,[Eq.propIntro, Eq.refl, Lean.Export.Entry.defn, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Export.Entry.defn]]
[«term_∈_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Meta.RecursorInfo.numIndices,[List.length, Lean.Meta.RecursorInfo.indicesPos],[Nat]]
[Lean.addBuiltinDocString,[ST.Ref.modify, Lean.NameMap.insert],[IO, Unit]]
[Lean.Parser.Tactic.simpa!?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.MetavarContext.hasAssignedLevelMVar,[Bool, and, Lean.Level.hasMVar, PProd.fst, or, PProd.snd, Lean.MetavarContext.isLevelAssigned, Bool.false],[Bool]]
[Lean.Parser.Tactic.assumption,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Parser.Attr.export,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident],[Lean.Parser.Parser]]
[Lean.Parser.incQuotDepth,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.addQuotDepthFn, OfNat.ofNat, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.CollectLevelParams.State.collect,[Lean.collectLevelParams],[Lean.CollectLevelParams.State]]
[Lean.Xml.Parser.CharData,[SeqRight.seqRight, Lean.Parsec.notFollowedBy, Lean.Parsec.skipString, Lean.Parsec.manyChars, Lean.Parsec.satisfy, Decidable.decide, And, Ne, Char.ofNat],[Lean.Parsec, String]]
[AddCommGroup.toAddGroup,[],[AddGroup]]
[Lean.IR.ExplicitBoxing.mkBoxedVersion,[StateT.run', Lean.IR.ExplicitBoxing.mkBoxedVersionAux, OfNat.ofNat],[Lean.IR.Decl]]
[Lean.ScopedEnvExtension.Entry.global.injEq,[Eq.propIntro, Eq.refl, Lean.ScopedEnvExtension.Entry.global, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ScopedEnvExtension.Entry.global]]
[Lean.Server.DocumentMeta.uri,[],[Lean.Lsp.DocumentUri]]
[Nat.lt_add_of_pos_right,[Nat.add_lt_add_left],[LT.lt, HAdd.hAdd]]
[Array.appendCore,[Array.size, OfNat.ofNat, Array.appendCore.loop],[Array]]
[Lean.Meta.ElimAltInfo.numFields,[],[Nat]]
[Lean.Meta.simpStep,[Bind.bind, Lean.Meta.simp, ite, Eq, Lean.Expr.isConstOf, Lean.Meta.Simp.Result.expr, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Unit.unit, Lean.Meta.MetaM, Option, Prod, Lean.Expr, Lean.Meta.Simp.Result.proof?, Lean.Meta.getMVarType, Lean.Meta.mkEqMP, Lean.Meta.mkFalseElim, Lean.Meta.assignExprMVar, Pure.pure, Option.some, Prod.mk, bne, Lean.Meta.mkExpectedTypeHint],[Lean.Meta.MetaM, Option, Prod, Lean.Expr]]
[Lean.hasInitAttr,[Option.isSome, Lean.getInitFnNameFor?],[Bool]]
[Lean.JsonRpc.ResponseError.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.Conv.ringExp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Elab.Tactic.evalParen,[Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Elab.Tactic.Tactic]]
[Prod.fst,[],[]]
[IO.Error.resourceVanished.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.PatternVar.anonymousVar.inj,[],[Eq]]
[instSubsingletonEmpty.proof_1,[Subsingleton.intro, Empty.elim],[Subsingleton, Empty]]
[Array.range,[Nat.fold, flip, Array.push, List.toArray, List.nil],[Array, Nat]]
[instDecidableEq,[Decidable, Eq, Decidable.isTrue, propext, Decidable.isFalse, instDecidableEq.proof_1],[Decidable, Eq]]
[PointedType.val,[],[PointedType.type]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withProj,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.PrettyPrinter.Delaborator.SubExpr.descend, OfNat.ofNat, panicWithPosWithDecl],[]]
[Lean.version.minor,[Unit.unit],[Nat]]
[Lean.MonadEnv.getEnv,[],[Lean.Environment]]
[IO.Process.Child.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Process.Child.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.ExpandResetReuse.CollectProjMap.collectVDecl,[Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.fap, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Lean.IR.ExpandResetReuse.ProjMap, Std.HashMap.insert],[Lean.IR.ExpandResetReuse.CollectProjMap.Collector]]
[Lean.Parser.instAndThenParser,[AndThen.mk, Lean.Parser.andthen, Unit.unit],[AndThen, Lean.Parser.Parser]]
[Lean.IR.UnreachableBranches.instToFormatValue,[Std.ToFormat.mk, Lean.IR.UnreachableBranches.Value.toFormat],[Std.ToFormat, Lean.IR.UnreachableBranches.Value]]
[Lean.RecursorVal.isUnsafeEx,[Lean.RecursorVal.isUnsafe],[Bool]]
[Lean.Parser.Attr.recursor.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.numLit.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.LocalContextEntry.param.injEq,[Eq.propIntro, Eq.refl, Lean.IR.LocalContextEntry.param, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.LocalContextEntry.param]]
[Lean.Parser.Command.derivingClasses.formatter,[Lean.Parser.sepBy1.formatter, Lean.Parser.group.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.structInst.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.IR.HasIndex.visitArgs,[Array.any, Lean.IR.HasIndex.visitArg, OfNat.ofNat, Array.size],[Bool]]
[Std.AssocList.isEmpty,[Unit.unit, Std.AssocList.cons, Bool, Bool.true, Bool.false],[Bool]]
[instSemiringFin.proof_14,[of_eq_true, Eq.trans, congrArg, Eq, Fin.mk, HMod.hMod, HAdd.hAdd, OfNat.ofNat, Nat.mod_lt, Fin.size_positive', Fin.add_def, Fin.mk.injEq, Fin.val, Fin.size_positive, congrFun, Fin.one_def, Nat.add_mod_mod, Nat.mod_add_mod, eq_self],[Eq, Fin.mk, HMod.hMod, HAdd.hAdd, OfNat.ofNat, Nat.mod_lt, Fin.size_positive']]
[Lean.Meta.isTypeFormer,[Bind.bind, Lean.Meta.inferType, Lean.Meta.isTypeFormerType],[Lean.Meta.MetaM, Bool]]
[Lean.MessageData.instCoeOptionExprMessageData,[Coe.mk, Unit.unit, Lean.MessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.MessageData.ofExpr],[Coe, Option, Lean.Expr, Lean.MessageData]]
[Lean.Elab.Term.MutualClosure.FixPoint.State.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.ReferenceContext.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.ReferenceContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.ReferenceContext.mk]]
[Lean.Parser.ppSpace.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.skip.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Fin.add.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, HAdd.hAdd]]
[Std.RBMap.maxDepth,[Std.RBNode.depth, Nat.max, Subtype.val],[Nat]]
[Std.PersistentHashMap.mkCollisionNode,[Std.PersistentHashMap.Node.collision, Std.PersistentHashMap.mkCollisionNode.proof_1],[Std.PersistentHashMap.Node]]
[Lean.Parser.isParserAlias,[Bind.bind, Lean.Parser.getAlias, Lean.Parser.parserAliasesRef, Option.none, IO, Bool, Pure.pure, Bool.true, Bool.false],[IO, Bool]]
[StateT.modifyGet,[Pure.pure],[StateT]]
[List.insert,[ite, Mem.mem, List.cons],[List]]
[Except.map_id,[funext, Eq.mpr, congr, congrArg, Eq, Except, Except.error, Except.ok, id_eq, rfl, Eq.symm, Eq.refl],[Eq, Except.map, id]]
[Lean.Environment.getModuleIdxFor?,[Std.HashMap.find?, Lean.Environment.const2ModIdx],[Option, Lean.ModuleIdx]]
[IO.Process.SpawnArgs.toStdioConfig,[],[IO.Process.StdioConfig]]
[Lean.Level.updateSucc!,[Lean.Level.zero, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Level, Lean.Level.updateSucc, Lean.Level.succ, Lean.Level.updateSucc!.proof_1, panicWithPosWithDecl, OfNat.ofNat],[Lean.Level]]
[Lean.Parser.Tactic.refineStruct,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.instInhabitedError,[Inhabited.mk, Lean.Parser.Error.mk, arbitrary],[Inhabited, Lean.Parser.Error]]
[Lean.Elab.Structural.RecArgInfo.fixedParams,[],[Array, Lean.Expr]]
[Lean.KernelException.unknownConstant.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KernelException.unknownConstant, HAdd.hAdd, OfNat.ofNat]]
[Lean.ReducibilityStatus.noConfusion,[noConfusionEnum, Lean.ReducibilityStatus.toCtorIdx],[Lean.ReducibilityStatus.noConfusionType]]
[Lean.Parsec.fail,[Lean.Parsec.ParseResult.error],[Lean.Parsec]]
[Lean.Elab.Tactic.getCurrMacroScope,[Bind.bind, readThe, Lean.Elab.Term.Context, Pure.pure, Lean.Elab.Term.Context.currMacroScope],[Lean.Elab.Tactic.TacticM, Lean.MacroScope]]
[UInt8.mk_val_eq,[Eq, UInt8.mk, UInt8.val, rfl],[Eq, UInt8.mk, UInt8.val]]
[Lean.MessageLog.noConfusionType,[],[]]
[List.rotateLeft,[ite, LE.le, OfNat.ofNat, HAppend.hAppend],[List]]
[Lean.checkTraceOption,[ite, Eq, Lean.KVMap.isEmpty, Bool.true, Bool.false, Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Bool, or, Lean.KVMap.getBool, and, not, Lean.KVMap.contains, PProd.fst, HAppend.hAppend, Lean.Name.mkStr],[Bool]]
[Equiv.to_fun_as_coe,[rfl],[Eq, Equiv.toFun]]
[Lean.MacroM,[ReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State],[]]
[Lean.Parser.Command.theorem,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.declId, Lean.Parser.Command.declSig, Lean.Parser.Command.declVal, Lean.Parser.Command.terminationSuffix],[Lean.Parser.Parser]]
[Lean.Import.runtimeOnly,[],[Bool]]
[And.symm,[And, And.intro],[And]]
[Lean.Elab.Deriving.Hashable.mkHashableHandler,[Bind.bind, Array.allM, Lean.isInductive, OfNat.ofNat, Array.size, ite, Eq, and, Decidable.decide, GT.gt, Bool.true, Lean.Elab.Command.liftTermElabM, Option.none, Lean.Elab.Deriving.mkContext, Array.getOp, Lean.Elab.Deriving.Hashable.mkHashFuncs, Lean.Elab.Deriving.mkInstanceCmds, Lean.Name.mkStr, Lean.Name.anonymous, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Array.forM, Lean.Elab.Command.elabCommand, Bool.false],[Lean.Elab.Command.CommandElabM, Bool]]
[Semigroup.mul_assoc,[],[Eq, HMul.hMul]]
[Lean.LocalDecl.cdecl.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.LocalDecl.cdecl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.LocalDecl.cdecl, And]]
[«term_+_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.PersistentEnvExtensionDescr.statsFn,[],[Std.Format]]
[Lean.Meta.synthAppInstances,[Nat.forM, Array.size, ite, Eq, Lean.BinderInfo.isInstImplicit, Array.getOp, Bool.true, Bind.bind, Lean.Meta.inferType, Lean.Meta.synthInstance, Option.none, Lean.Meta.isDefEq, Pure.pure, PUnit.unit, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing],[Lean.Meta.MetaM, Unit]]
[ExceptCpsT.instMonadExceptOfExceptCpsT,[MonadExceptOf.mk],[MonadExceptOf, ExceptCpsT]]
[Lean.ExternEntry.adhoc.inj,[],[Eq]]
[Lean.mkDefaultFnOfProjFn,[HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Name]]
[Lean.Meta.instInhabitedUnificationHints,[Inhabited.mk, Lean.Meta.UnificationHints.mk, arbitrary],[Inhabited, Lean.Meta.UnificationHints]]
[optional,[HOrElse.hOrElse, Functor.map, Option.some, Pure.pure, Option.none],[Option]]
[Lean.Elab.Term.StructInst.Struct.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.instBEqJoinPointId,[BEq.mk, BEq.beq, Lean.IR.JoinPointId.idx],[BEq, Lean.IR.JoinPointId]]
[Lean.Expr.bindingName!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Name, panicWithPosWithDecl, OfNat.ofNat],[Lean.Name]]
[Lean.Parser.Tactic.rcasesPatLo,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.Parser.Tactic.rcasesPatMed, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[Lean.MetavarContext.eraseDelayed,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Lean.MetavarContext.decls, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Std.PersistentHashMap.erase, Lean.MetavarContext.dAssignment],[Lean.MetavarContext]]
[Lean.Elab.Tactic.tagUntaggedGoals,[Bind.bind, Lean.MonadMCtx.getMCtx, ForIn.forIn, ite, Eq, Lean.MetavarContext.isAnonymousMVar, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, Lean.MonadMCtx.modifyMCtx, Id.run, MProd.mk, BEq.beq, OfNat.ofNat, Id, Lean.MetavarContext],[Lean.Elab.Tactic.TacticM, Unit]]
[IO.FS.DirEntry.mk.inj,[And.intro],[And, Eq]]
[Std.HashMap.fold,[Std.HashMapImp.fold],[]]
[Lean.Meta.checkApp,[Bind.bind, Lean.Meta.inferType, Lean.Meta.whnf, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Unit, Lean.Meta.isDefEq, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.throwAppTypeMismatch, Lean.MessageData.ofFormat, Std.Format.nil, Lean.Meta.throwFunctionExpected, Lean.mkApp],[Lean.Meta.MetaM, Unit]]
[Lean.Elab.PreDefinition.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.PreDefinition.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.PreDefinition.mk, And]]
[Lean.MetavarContext.mkBinding,[Lean.MetavarContext.MkBinding.mkBinding, Bool.false],[Lean.MetavarContext.MkBindingM, Prod, Lean.Expr, Nat]]
[Std.ShareCommonT,[StateT, Std.ShareCommon.State],[]]
[Lean.Elab.DefView.modifiers,[],[Lean.Elab.Modifiers]]
[Lean.ConstantInfo.defnInfo.injEq,[Eq.propIntro, Eq.refl, Lean.ConstantInfo.defnInfo, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ConstantInfo.defnInfo]]
[Lean.Parser.Term.stx.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.syntaxParser.formatter],[Lean.PrettyPrinter.Formatter]]
[ite_id,[rfl, Eq.symm, Eq.refl],[Eq, ite]]
[Lean.Server.Watchdog.FileWorker.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.Watchdog.FileWorker.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.DocumentSymbolAux.detail?,[],[Option, String]]
[Lean.Meta.ParamInfo.isInstImplicit,[BEq.beq, Lean.Meta.ParamInfo.binderInfo, Lean.BinderInfo.instImplicit],[Bool]]
[bfix1,[PProd.fst],[]]
[Lean.JsonNumber.instCoeNatJsonNumber,[Coe.mk, Lean.JsonNumber.fromNat],[Coe, Nat, Lean.JsonNumber]]
[Lean.Elab.ContextInfo.ppSyntax,[Lean.ppTerm, Lean.Elab.ContextInfo.toPPContext],[IO, Std.Format]]
[IO.Error.resourceExhausted.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.resourceExhausted, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.resourceExhausted, And]]
[Lean.Server.FileWorker.RpcSession.new,[Bind.bind, Functor.map, ByteArray.toUInt64LE!, IO.getRandomBytes, OfNat.ofNat, liftM, IO.monoMsNow, Pure.pure, Prod.mk],[IO, Prod, UInt64, Lean.Server.FileWorker.RpcSession]]
[Lean.IR.getDecls,[Lean.SimplePersistentEnvExtension.getEntries, Lean.IR.declMapExt],[List, Lean.IR.Decl]]
[Lean.Meta.Hypothesis.mk.inj,[And.intro],[And, Eq]]
[noConfusionEnum.proof_1,[Eq.symm, if_pos],[Eq, ite]]
[Lean.Meta.ToHide.State.noConfusionType,[],[]]
[List.mapTRAux,[List, List.reverse, PProd.fst, List.cons],[List]]
[Lean.Elab.tryContradiction,[Bind.bind, MonadExcept.tryCatch, Lean.Meta.contradiction, Lean.Meta.Contradiction.Config.mk, Bool.true, Pure.pure, Bool.false],[Lean.Meta.MetaM, Bool]]
[Function.update_injective,[],[Function.injective, Function.update]]
[Lean.Elab.Term.Do.ToCodeBlock.Catch.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.ToCodeBlock.Catch.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.ToCodeBlock.Catch.mk, And]]
[UInt32.size,[OfNat.ofNat],[Nat]]
[Option.instFunctorOption,[Functor.mk, Option.map],[Functor, Option]]
[List.hasDecEq.proof_1,[rfl],[Eq, List.nil]]
[Lean.mkTagDeclarationExtension,[Lean.registerSimplePersistentEnvExtension, Lean.SimplePersistentEnvExtensionDescr.mk, Lean.NameSet.insert, EmptyCollection.emptyCollection, Array.qsort, List.toArray, Lean.Name.quickLt, OfNat.ofNat, HSub.hSub, Array.size],[IO, Lean.TagDeclarationExtension]]
[Lean.Parser.withoutInfo,[Lean.Parser.Parser.mk, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[instDecidableLt_4,[USize.decLt],[Decidable, LT.lt]]
[Lean.Lsp.PlainGoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.PlainGoal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.PlainGoal.mk, And]]
[Lean.ppTerm,[ite, Eq, Lean.Option.get, Lean.PPContext.opts, Lean.pp.raw, Bool.true, Pure.pure, Unit.unit, MonadExcept.tryCatch, Lean.PPFns.ppTerm, Lean.EnvExtension.getState, Lean.ppExt, Lean.PPContext.env, Lean.pp.rawOnError, HAppend.hAppend, Std.ToFormat.format, Std.Format.line],[IO, Std.Format]]
[Lean.Name.below,[PUnit, PProd],[]]
[Std.HashMapImp.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.HashMapImp.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.HashMapImp.mk, And]]
[USize.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd],[USize]]
[IO.FS.Metadata.noConfusionType,[],[]]
[Lean.IR.LocalContextEntry.joinPoint.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.LocalContextEntry.joinPoint, HAdd.hAdd, OfNat.ofNat]]
[tacticRepeat'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.IR.mkUProjExpr,[Lean.IR.Expr.uproj],[Lean.IR.Expr]]
[Lean.MetavarContext.findDecl?,[Std.PersistentHashMap.find?, Lean.MetavarContext.decls],[Option, Lean.MetavarDecl]]
[List.Perm.refl,[Unit.unit, List.Perm, List.Perm.nil, List.Perm.cons, PProd.fst],[List.Perm]]
[Lean.Parser.Command.namedName.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.NormNum.LawfulOfNat.noConfusionType,[],[]]
[Nat.lcm,[HDiv.hDiv, HMul.hMul, Nat.gcd],[Nat]]
[Lean.MonadStateCacheT.instMonadLiftMonadStateCacheT,[inferInstanceAs, MonadLift, StateT, Std.HashMap],[MonadLift, Lean.MonadStateCacheT]]
[Lean.Expr.app.inj,[And.intro],[And, Eq]]
[Lean.SimpleScopedEnvExtension.Descr.initial,[],[]]
[Lean.IR.IRType.below,[PUnit, PProd],[]]
[String.leftpad_prefix,[String.isPrefix, String.repeat, HSub.hSub, String.length, String.leftpad, of_eq_true, eq_true, List.leftpad_prefix],[String.isPrefix, String.repeat, HSub.hSub, String.length, String.leftpad]]
[Lean.mkApp9,[Lean.mkApp5, Lean.mkApp4],[Lean.Expr]]
[Lean.Meta.Cases.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Cases.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.IndPredBelow.Variables.motives,[],[Array, Lean.Expr]]
[IO.Error.hardwareFault.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.hardwareFault, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.hardwareFault, And]]
[String.leftpad_suffix,[String.isSuffix, String.leftpad, of_eq_true, eq_true, List.leftpad_suffix],[String.isSuffix, String.leftpad]]
[Lean.Elab.Tactic.Conv.getLhsRhsCore,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getMVarType, Lean.Meta.matchEq?, Option.none, Lean.Meta.MetaM, Prod, Lean.Expr, Pure.pure, Prod.mk, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM, Prod, Lean.Expr]]
[List.erasep_cons_of_pos,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.erasep_cons, ite_congr, eq_true, Eq.refl, List.cons, List.erasep, ite_true, eq_self],[Eq, List.erasep, List.cons]]
[Lean.Elab.checkIfShadowingStructureField,[Lean.Name.anonymous, Lean.Name.num, Unit, Bind.bind, Lean.MonadEnv.getEnv, ite, Eq, Lean.isStructure, Bool.true, ForIn.forIn, PUnit.unit, BEq.beq, HAppend.hAppend, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, ForInStep.yield, Unit.unit],[Unit]]
[Lean.Elab.Term.toParserDescr,[Bind.bind, Lean.MonadEnv.getEnv, StateRefT'.run, Lean.Elab.Term.ToParserDescrContext.mk, Bool.true, Option.none, Lean.Elab.Term.toParserDescr.process, Lean.Elab.Term.toParserDescr.processSeq, Lean.Elab.Term.toParserDescr.resolveParserName, Lean.Elab.Term.toParserDescr.ensureNoPrec, Lean.Elab.Term.toParserDescr.processParserCategory, Lean.Elab.Term.toParserDescr.processNullaryOrCat, Lean.Elab.Term.toParserDescr.processUnary, Lean.Elab.Term.toParserDescr.processBinary, Lean.Elab.Term.toParserDescr.processSepBy, Lean.Elab.Term.toParserDescr.processSepBy1, Lean.Elab.Term.toParserDescr.isValidAtom, Lean.Elab.Term.toParserDescr.processAtom, Lean.Elab.Term.toParserDescr.processNonReserved],[Lean.Elab.Term.TermElabM, Prod, Lean.Syntax, Option, Nat]]
[Nat.mod_two_eq_zero_or_one,[Or, Eq, OfNat.ofNat, HMod.hMod, Nat.mod_lt, of_eq_true, eq_true_of_decide, Eq.refl, Bool.true, Or.inl, rfl, Or.inr, absurd, Nat.not_lt_zero, Nat.lt_of_succ_lt_succ],[Or, Eq, HMod.hMod, OfNat.ofNat]]
[Std.RBTree.empty,[Std.RBMap.empty],[Std.RBTree]]
[Int.instModInt,[Mod.mk, Int.mod],[Mod, Int]]
[Lean.LocalDecl.isAuxDecl,[Lean.BinderInfo.isAuxDecl, Lean.LocalDecl.binderInfo],[Bool]]
[Lean.IR.Checker.checkObjVar,[Lean.IR.Checker.checkVarType, Lean.IR.IRType.isObj],[Lean.IR.Checker.M, Unit]]
[Lean.Lsp.ServerCapabilities.definitionProvider,[],[Bool]]
[Lean.Elab.WF.TerminationHint.one.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.WF.TerminationHint.one, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.WF.TerminationHint.one]]
[Std.PersistentHashMap.branching,[USize.ofNat, HPow.hPow, OfNat.ofNat, USize.toNat, Std.PersistentHashMap.shift],[USize]]
[Lean.Meta.mkSizeOfFn,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Unit]]
[Nat.mul_lt_mul_of_pos_left,[Nat.lt_of_lt_of_le, Nat.add_lt_add_left, Nat.mul, Nat.mul_le_mul_left, Nat.succ_le_of_lt, Nat.mul_succ],[LT.lt, HMul.hMul]]
[UInt64.instSemiringUInt64.proof_11,[Eq.mpr, congr, congrArg, Eq, Eq.trans, HMul.hMul, UInt64.add_def, UInt64.mul_def, UInt64.mk, HAdd.hAdd, UInt64.val, UInt64.eq_of_val_eq, Semiring.mul_add],[Eq, HMul.hMul, HAdd.hAdd]]
[Lean.Parser.nonReservedSymbol.formatter,[Lean.PrettyPrinter.Formatter.tokenWithAntiquot.formatter, Lean.PrettyPrinter.Formatter.nonReservedSymbolNoAntiquot.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.mkNullNode,[Lean.mkNode, Lean.nullKind],[Lean.Syntax]]
[Lean.AxiomVal.toConstantVal,[],[Lean.ConstantVal]]
[IO.Error.mkNoFileOrDirectory,[IO.Error.noFileOrDirectory],[IO.Error]]
[Lean.Lsp.RpcReleaseParams.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.ElimInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.KeyedDeclsAttribute.AttributeEntry.toOLeanEntry,[],[Lean.KeyedDeclsAttribute.OLeanEntry]]
[instSubUInt8,[Sub.mk, UInt8.sub],[Sub, UInt8]]
[Lean.IR.EmitC.emitInitFn,[Bind.bind, Lean.IR.EmitC.getEnv, Lean.IR.EmitC.getModName, Array.forM, Lean.IR.EmitC.emitLn, HAppend.hAppend, Lean.mkModuleInitializationFunctionName, Lean.Import.module, Lean.Environment.imports, OfNat.ofNat, Array.size, Lean.IR.EmitC.emitLns, List.cons, List.nil, List.forM, List.reverse, Lean.IR.EmitC.emitDeclInit],[Lean.IR.EmitC.M, Unit]]
[Lean.Parser.Module.module.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Module.header.formatter, Lean.Parser.many.formatter, Lean.Parser.commandParser.formatter, Lean.ppLine.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.ParserState.restore,[Lean.Parser.ParserState.mk, Array.shrink, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.cache, Option.none],[Lean.Parser.ParserState]]
[Lean.KVMap.isEmpty,[Bool, List.isEmpty],[Bool]]
[Lean.Meta.splitAnd,[Lean.Meta.saturate, Lean.observing?, Lean.Meta.apply, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.Meta.MetaM, List, Lean.MVarId]]
[Lean.Lsp.TextDocumentPositionParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.TextDocumentPositionParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.constructor,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType', Lean.matchConstInduct, Lean.Expr.getAppFn, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, MonadExcept.tryCatch, Lean.Meta.apply, Lean.mkConst, Pure.pure, DoResultPR.return, Unit.unit, DoResultPR.pure, Lean.Meta.MetaM, ForInStep, MProd, Option, List, Lean.MVarId, PUnit, ForInStep.yield, ForInStep.done, Option.some, MProd.fst],[Lean.Meta.MetaM, List, Lean.MVarId]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.mk, And]]
[Lean.evalConst,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, Lean.ofExcept, Lean.Environment.evalConst],[]]
[Lean.Elab.Tactic.AuxMatchTermState.noConfusionType,[],[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk, And]]
[variables,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[iff_true_intro,[Iff.intro, True.intro],[Iff, True]]
[Nat.coprime.gcd_right,[Nat.coprime.coprime_dvd_right, Nat.gcd_dvd_right],[Nat.coprime, Nat.gcd]]
[Lean.Elab.Term.expandMacrosInPatterns,[Array.mapM, Bind.bind, Lean.expandMacros, Lean.Elab.Term.MatchAltView.patterns, Pure.pure, Lean.Elab.Term.MatchAltView.mk, Lean.Elab.Term.MatchAltView.ref, Lean.Elab.Term.MatchAltView.rhs],[Lean.MacroM, Array, Lean.Elab.Term.MatchAltView]]
[Lean.Xml.Parser.S,[Lean.Parsec.many1Chars, HOrElse.hOrElse, Lean.Parsec.pchar, Char.ofNat, Lean.Xml.Parser.endl],[Lean.Parsec, String]]
[Lean.Elab.Term.expandMatchAltsIntoMatch,[Lean.withRef, Lean.MacroM, Lean.Syntax, ite, Eq, Bool.true, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.MonadQuotation.withFreshMacroScope, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, PProd.fst, Array.push, Array.size],[Lean.MacroM, Lean.Syntax]]
[Lean.Meta.Split.simpMatch.pre,[Bind.bind, Lean.Meta.matchMatcherApp?, Option.none, Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step, liftM, Lean.Meta.reduceRecMatcher?, Unit.unit, Pure.pure, Lean.Meta.Simp.Step.done, Lean.Meta.Simp.Result.mk, Lean.Meta.Match.getEquationsFor, Lean.Meta.MatcherApp.matcherName, ForIn.forIn, MProd.mk, PUnit.unit, Lean.Meta.withReducible, Lean.Meta.Simp.tryLemma?, Lean.Meta.SimpLemma.mk, Lean.mkConst, List.nil, Option.some, Lean.Meta.SplitIf.discharge?, Bool.false, ForInStep, MProd, Option, PUnit, ForInStep.yield, ForInStep.done, MProd.fst, Lean.Meta.Simp.Step.visit],[Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step]]
[Lean.Meta.InjectionResult.subgoal.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.InjectionResult.subgoal, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.InjectionResult.subgoal, And]]
[Lean.PrettyPrinter.Delaborator.isType2Type,[Bind.bind, Lean.Meta.inferType, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Bool, Pure.pure, Bool.true, Bool.false],[Lean.Meta.MetaM, Bool]]
[Lean.Meta.mkLetValCongr,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Meta.assertHypotheses,[ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Prod.mk, List.toArray, List.nil, Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarTag, Lean.Meta.getMVarType, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.assignExprMVar, Lean.Meta.introNP, Lean.Expr.mvarId!, Array.size],[Lean.Meta.MetaM, Prod, Array, Lean.FVarId, Lean.MVarId]]
[Lean.Server.Watchdog.updateFileWorkers,[Bind.bind, MonadReader.read, ST.Ref.modify, Lean.Server.Watchdog.ServerContext.fileWorkersRef, Std.RBMap.insert, Lean.Server.DocumentMeta.uri, Lean.Server.Watchdog.OpenDocument.meta, Lean.Server.Watchdog.FileWorker.doc],[Lean.Server.Watchdog.ServerM, Unit]]
[Function.extend_comp,[funext, Function.extend_apply],[Eq, Function.comp, Function.extend]]
[Lean.Meta.Match.Pattern.var.inj,[],[Eq]]
[Bool.false_or,[rfl, Eq.symm, Eq.refl],[Eq, or, Bool.false]]
[Lean.Meta.throwIsDefEqStuck,[MonadExcept.throw, Lean.Exception.internal, Lean.Meta.isDefEqStuckExceptionId, Lean.KVMap.mk],[Lean.Meta.MetaM]]
[Lean.Parser.Term.doContinue,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[unexpandSorryAx,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[instToStreamArraySubarray,[ToStream.mk, Array.toSubarray, OfNat.ofNat, Array.size],[ToStream, Array, Subarray]]
[Lean.MessageData.ofGoal.inj,[],[Eq]]
[PSigma.lexNdepWf.proof_1,[WellFounded.intro, Acc, PSigma.lexNdep, PSigma.lexAccessible, WellFounded.apply],[WellFounded, PSigma.lexNdep]]
[Lean.Elab.Command.ElabHeaderResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.ElabHeaderResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Command.ElabHeaderResult.mk, And]]
[IO.mapTask,[EIO.mapTask],[BaseIO, Task, Except, IO.Error]]
[Lean.IR.Borrow.ParamMap.fmt,[HAppend.hAppend, Std.Format.text, Std.Format.nest, OfNat.ofNat],[Std.Format]]
[Lean.Elab.Command.expandNotationItemIntoSyntaxItem,[ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Lean.mkNode, List.toArray, List.cons, Lean.mkIdentFrom, Lean.Syntax.getOp, OfNat.ofNat, List.nil, Lean.strLitKind, Lean.Macro.throwUnsupported],[Lean.MacroM, Lean.Syntax]]
[let_body_eq,[Eq.mpr, Eq.refl, Eq, rfl],[Eq]]
[coeBase,[CoeTC.mk, coeB],[CoeTC]]
[Lean.MacroScopesView.noConfusionType,[],[]]
[Nat.foldRevM.loop,[Pure.pure, Bind.bind, PProd.fst],[]]
[FloatArray.get,[Float, Array.get],[Float]]
[Lean.Expr.forallE.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.forallE, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Expr.forallE, And]]
[Lean.DataValue.ofName.injEq,[Eq.propIntro, Eq.refl, Lean.DataValue.ofName, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.DataValue.ofName]]
[instMulUSize,[Mul.mk, USize.mul],[Mul, USize]]
[unexpandProdMk,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Lean.instToStringImport,[ToString.mk, HAppend.hAppend, ToString.toString, Lean.Import.module, ite, Eq, Lean.Import.runtimeOnly, Bool.true],[ToString, Lean.Import]]
[Lean.Lsp.TextDocumentContentChangeEvent.fullChange.inj,[],[Eq]]
[Lean.Lsp.LineRange.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.LineRange.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.LineRange.mk, And]]
[Lean.Parser.addQuotDepthFn,[Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.prec, Lean.Parser.ParserContext.tokens, Int.toNat, HAdd.hAdd, Int.ofNat, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Parser.ParserContext.savedPos?, Lean.Parser.ParserContext.forbiddenTk?],[Lean.Parser.ParserFn]]
[Lean.PrettyPrinter.Formatter.visitArgs,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, GT.gt, Array.size, Lean.Syntax.getArgs, OfNat.ofNat, SeqLeft.seqLeft, SeqRight.seqRight, Lean.Syntax.MonadTraverser.goDown, HSub.hSub, Lean.Syntax.MonadTraverser.goUp, Pure.pure, PUnit.unit],[Lean.PrettyPrinter.FormatterM, Unit]]
[Int.add_comm,[Eq, HAdd.hAdd, of_eq_true, Eq.trans, congr, congrArg, Int.ofNat_add_ofNat, Int.ofNat, Nat.add_comm, eq_self, rfl, Int.negSucc_ofNat_add_negSucc_ofNat, Int.negSucc, Nat.succ],[Eq, HAdd.hAdd]]
[Lean.Json.instCoeBoolJson,[Coe.mk, Lean.Json.bool],[Coe, Bool, Lean.Json]]
[instMulUInt64,[Mul.mk, UInt64.mul],[Mul, UInt64]]
[Lean.mkMVar,[Lean.Expr.mvar, Lean.Expr.mkData, mixHash, OfNat.ofNat, Hashable.hash, Bool.false, Bool.true],[Lean.Expr]]
[Lean.Parser.Syntax.binary.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.syntaxParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Iff.elim_right,[Iff.elim_right.proof_1],[]]
[le_trans,[Preorder.le_trans],[LE.le]]
[Lean.Parser.Command.mixfixKind,[HOrElse.hOrElse, Lean.Parser.Command.prefix, Lean.Parser.Command.infix, Lean.Parser.Command.infixl, Lean.Parser.Command.infixr, Lean.Parser.Command.postfix],[Lean.Parser.Parser]]
[Lean.Server.FileWorker.RpcSession.noConfusionType,[],[]]
[«termExists_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[UInt16.instNumericUInt16,[Numeric.mk, UInt16.mk, Numeric.ofNat],[Numeric, UInt16]]
[FloatSpec.le,[],[]]
[Lean.Elab.Command.StructFieldInfo.name,[],[Lean.Name]]
[Lean.Syntax.isNodeOf,[and, Lean.Syntax.isOfKind, BEq.beq, Lean.Syntax.getNumArgs],[Bool]]
[IO.Process.run,[Bind.bind, IO.Process.output, ite, Eq, bne, IO.Process.Output.exitCode, OfNat.ofNat, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, IO.Process.SpawnArgs.cmd, ToString.toString, Pure.pure, PUnit.unit],[IO, String]]
[Lean.Meta.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.NameSSet,[Lean.SSet, Lean.Name],[]]
[Lean.DataValue.ofNat.inj,[],[Eq]]
[List.filter,[List.filterAux, List.nil],[List]]
[instReprList,[Repr.mk, Std.Format, List.cons, Std.Format.text, Std.Format.bracket, Std.Format.joinSep, HAppend.hAppend, Std.Format.line],[Repr, List]]
[Lean.MData.empty,[Lean.KVMap.mk],[Lean.MData]]
[Lean.IR.IRType.struct.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, Eq.refl, List.nil, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.IR.IRType.struct, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.saveAndResetSynthInstanceCache,[Bind.bind, MonadState.get, Lean.Meta.modifyCache, Lean.Meta.Cache.mk, Lean.Meta.Cache.inferType, Lean.Meta.Cache.funInfo, Std.PersistentHashMap.mk, Lean.Meta.Cache.whnfDefault, Lean.Meta.Cache.whnfAll, Lean.Meta.Cache.defEqDefault, Lean.Meta.Cache.defEqAll, Pure.pure],[Lean.Meta.MetaM, Lean.Meta.SynthInstanceCache]]
[Lean.PersistentEnvExtension.name,[],[Lean.Name]]
[neg_eq_of_add_eq_zero,[left_neg_eq_right_neg, neg_add_self],[Eq, Neg.neg]]
[Lean.Elab.Tactic.elabSetOption,[Bind.bind, Lean.Elab.elabSetOption, Lean.Syntax.getOp, OfNat.ofNat, withTheReader, Lean.Core.Context, Lean.Core.Context.mk, Lean.Core.Context.currRecDepth, Lean.Option.get, Lean.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats, Lean.Elab.Tactic.evalTactic],[Lean.Elab.Tactic.Tactic]]
[Lean.IR.EmitC.emitSet,[Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitArg, Lean.IR.EmitC.emitLn],[Lean.IR.EmitC.M, Unit]]
[Lean.KVMap.instValueBool,[Lean.KVMap.Value.mk, Lean.DataValue.ofBool, Lean.DataValue.ofString, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Option, Bool, Option.some, Option.none],[Lean.KVMap.Value, Bool]]
[Lean.MessageData.instCoeFormatMessageData,[Coe.mk, Lean.MessageData.ofFormat],[Coe, Std.Format, Lean.MessageData]]
[Lean.Meta.MatcherApp.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.MatcherApp.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.MatcherApp.mk, And]]
[Lean.DataValue.ofBool.injEq,[Eq.propIntro, Eq.refl, Lean.DataValue.ofBool, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.DataValue.ofBool]]
[Lean.Compiler.InlineAttributeKind.noinline.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Compiler.InlineAttributeKind.noinline, OfNat.ofNat]]
[Subtype.eq,[Eq.symm, eq_of_heq, Eq.refl, Subtype.val, Subtype.mk, HEq.refl, Eq, rfl],[Eq]]
[Lean.Meta.abstractRange,[Lean.Meta.liftMkBindingM, Lean.MetavarContext.abstractRange],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.TraceElem.noConfusionType,[],[]]
[Lean.AttributeExtensionOLeanEntry.decl.inj,[],[Eq]]
[Lean.Elab.ElabInfo.elaborator,[],[Lean.Name]]
[Lean.Elab.Level.LevelElabM,[ReaderT, Lean.Elab.Level.Context, EStateM, Lean.Exception, Lean.Elab.Level.State],[]]
[Lean.Syntax.asNode.proof_1,[Lean.IsNode.mk, Lean.SourceInfo.none, Lean.nullKind, List.toArray, List.nil],[Lean.IsNode, Lean.Syntax.node, Lean.SourceInfo.none, Lean.nullKind, List.toArray, List.nil]]
[Lean.Syntax.Traverser.parents,[],[Array, Lean.Syntax]]
[Lean.IR.Checker.checkScalarType,[Lean.IR.Checker.checkType, Lean.IR.IRType.isScalar],[Lean.IR.Checker.M, Unit]]
[List.decidableMem.proof_1,[Or.inl],[Or, Eq, List.mem]]
[Lean.Meta.GeneralizeIndicesSubgoal.indicesFVarIds,[],[Array, Lean.FVarId]]
[Lean.Meta.Cache.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.Quotation.HeadInfo.check,[],[Lean.Elab.Term.Quotation.HeadCheck]]
[«term_≠_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Elab.Term.PatternVarDecl.anonymousVar.inj,[And.intro],[And, Eq]]
[Lean.Parser.Command.mixfix,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.attrKind, Lean.Parser.Command.mixfixKind, Lean.Parser.precedence, Lean.Parser.Command.optNamedName, Lean.Parser.Command.optNamedPrio, Lean.Parser.ppSpace, Lean.Parser.strLit, Lean.Parser.darrow, Lean.Parser.termParser],[Lean.Parser.Parser]]
[ULift.noConfusionType,[],[]]
[Lean.IR.FnBody.jdecl.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.jdecl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.FnBody.jdecl, And]]
[Option.all,[Unit.unit, Bool, Bool.true],[Bool]]
[IO.Process.SpawnArgs.env,[],[Array, Prod, String, Option]]
[Std.AssocList.below,[PUnit, PProd],[]]
[Lean.Parser.TokenMap,[Std.RBMap, Lean.Name, List, Lean.Name.quickCmp],[]]
[Lean.Elab.Command.printPrefix,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.ImportState.regions,[],[Array, Lean.CompactedRegion]]
[Lean.Lsp.TextEdit.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.TextEdit.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Json.Structured.obj.injEq,[Eq.propIntro, Eq.refl, Lean.Json.Structured.obj, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Json.Structured.obj]]
[Lean.Elab.Modifiers.noConfusionType,[],[]]
[Lean.Meta.UnificationHint.noConfusionType,[],[]]
[Lean.Syntax.foldArgsM,[Array.foldlM, flip, Lean.Syntax.getArgs, OfNat.ofNat, Array.size],[]]
[List.ne_and_not_mem_of_not_mem_cons,[And.intro, List.ne_of_not_mem_cons, List.not_mem_of_not_mem_cons],[And, Ne, Not, Mem.mem]]
[System.Platform.isOSX,[System.Platform.getIsOSX, Unit.unit],[Bool]]
[eq_or_lt_of_not_lt,[dite, Eq, Or.inl, Or.inr, lt_of_not_ge, lt_of_le_of_ne],[Or, Eq, LT.lt]]
[Lean.Parser.Term.macroDollarArg,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.MetavarContext.userNames,[],[Std.PersistentHashMap, Lean.Name, Lean.MVarId]]
[Lean.IR.IRType.uint8.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.IR.IRType.uint8, OfNat.ofNat]]
[UInt64.eq_of_val_eq,[Eq, congrArg, UInt64.mk],[Eq]]
[Lean.Option.defValue,[],[]]
[Lean.Server.Watchdog.ServerContext.hIn,[],[IO.FS.Stream]]
[Lean.Elab.OpenDecl.State.mk.inj,[And.intro],[And, Eq]]
[Quot.liftIndepPr1,[Quot.ind, rfl],[Eq, PSigma.fst, Quot.lift, Quot.indep, Quot.indepCoherent]]
[Lean.JsonRpc.instToJsonErrorCode,[Lean.ToJson.mk, Unit.unit, Lean.Json, Lean.Json.num, Lean.JsonNumber.fromInt, Neg.neg, OfNat.ofNat],[Lean.ToJson, Lean.JsonRpc.ErrorCode]]
[Lean.DefinitionVal.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.mkLt,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[USize.size_positive,[usize_size_gt_zero],[LT.lt, OfNat.ofNat, USize.size]]
[Lean.PrettyPrinter.Formatter.throwBacktrack,[MonadExcept.throw, Lean.Exception.internal, Lean.PrettyPrinter.backtrackExceptionId, Lean.KVMap.mk],[Lean.PrettyPrinter.FormatterM]]
[Lean.Elab.WF.TerminationHint.erase,[Unit.unit, Lean.Elab.WF.TerminationHint, Lean.Elab.WF.TerminationHint.none, Id.run, Bind.bind, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, ite, Eq, Lean.NameMap.contains, Bool.true, Std.RBMap.isEmpty, Pure.pure, ForInStep.done, Option.some, Lean.Elab.WF.TerminationHint.many, ForInStep.yield, Id, MProd.fst],[Lean.Elab.WF.TerminationHint]]
[Lean.Elab.Command.failIfSucceeds,[Bind.bind, tryFinally, MonadExcept.tryCatch, Lean.Elab.Command.hasNoErrorMessages, Lean.Exception.error, Lean.Elab.Command.CommandElabM, Bool, Lean.Elab.logException, Pure.pure, Bool.false, liftM, Lean.InternalExceptionId.getName, Lean.Elab.logError, Lean.MessageData.ofName],[Lean.Elab.Command.CommandElabM, Unit]]
[Lean.Elab.Command.StructCtorView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.StructCtorView.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Command.StructCtorView.mk, And]]
[Lean.Lsp.DocumentSymbol.noConfusionType,[],[]]
[Lean.Parser.ParserInfo.collectKinds,[],[Lean.Parser.SyntaxNodeKindSet]]
[Lean.Elab.TermInfo.runMetaM,[Lean.Elab.ContextInfo.runMetaM, Lean.Elab.TermInfo.lctx],[IO]]
[List.length_eq_lenghtTR,[funext, of_eq_true, Eq.trans, congrArg, Eq, List.length, Eq.symm, List.length_add_eq_lengthTRAux, OfNat.ofNat, Nat.add_zero, eq_self],[Eq, List.length, List.lengthTR]]
[Lean.Lsp.instToJsonDiagnosticRelatedInformation,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.DiagnosticRelatedInformation.location, List.nil, Lean.Lsp.DiagnosticRelatedInformation.message],[Lean.ToJson, Lean.Lsp.DiagnosticRelatedInformation]]
[Lean.Unhygienic.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Trie.instEmptyCollectionTrie,[EmptyCollection.mk, Lean.Parser.Trie.empty],[EmptyCollection, Lean.Parser.Trie]]
[Decidable.not_not_iff,[Iff.intro, Decidable.of_not_not, not_not_intro],[Iff, Not]]
[Lean.Meta.SynthInstance.GeneratorNode.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SynthInstance.GeneratorNode.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SynthInstance.GeneratorNode.mk, And]]
[or_iff_right_iff_imp,[Eq.mpr, Eq.refl, Iff, Or, propext, or_comm, or_iff_left_iff_imp, Iff.rfl],[Iff, Or]]
[Std.RBTree.foldM,[Std.RBMap.foldM],[]]
[Lean.Level.param.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Level.param, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Level.param, And]]
[UInt64.decEq.proof_1,[rfl],[Eq, UInt64.mk]]
[Lean.Parser.many1Indent.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGe.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Term.doNested,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.doSeq],[Lean.Parser.Parser]]
[Lean.Meta.NormNum.LawfulZero.noConfusionType,[],[]]
[Lean.Syntax.MonadTraverser.goDown,[modify, Lean.Syntax.Traverser.down],[Unit]]
[Monoid.npow_succ',[],[Eq, Monoid.npow, Nat.succ, HMul.hMul]]
[Lean.ExprStructEq.beq,[Bool, Lean.Expr.equal],[Bool]]
[Lean.Parser.Command.mutual.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.ppLine.formatter, Lean.Parser.notSymbol.formatter, Lean.Parser.commandParser.formatter, Lean.ppDedent.formatter, Lean.Parser.Command.terminationSuffix.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.getAliases,[Unit.unit, List, Lean.Name, Lean.SMap.find?, Lean.SimplePersistentEnvExtension.getState, Lean.aliasExtension, List.nil],[List, Lean.Name]]
[Lean.Elab.Term.Arg.expr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Arg.expr, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.DiagnosticSeverity.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.DiagnosticSeverity.toCtorIdx],[]]
[Lean.IR.Expr.isShared.inj,[],[Eq]]
[Nat.min_eq_left,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, ite_congr, eq_true, Eq.refl, ite_true, eq_self],[Eq, Nat.min]]
[Lean.Parser.Command.partial.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Mathlib.Tactic.Conv.convTry_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[Std.HashMapImp.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.HashMapImp.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.structInstFieldAbbrev.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.notFollowedBy.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[decEq,[],[Decidable, Eq]]
[UInt8.mod,[UInt8.mk, HMod.hMod, UInt8.val],[UInt8]]
[Lean.Meta.Simp.postDefault,[Lean.Meta.Simp.tryRewriteCtorEq, Lean.Meta.Simp.tryRewriteUsingDecide, Lean.Meta.Simp.rewritePost],[Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step]]
[Function.comp_apply,[rfl],[Eq, Function.comp]]
[Lean.Elab.ExpandDeclIdResult.noConfusionType,[],[]]
[FloatArray.forInUnsafe.loop,[ite, LT.lt, Bind.bind, Pure.pure, FloatArray.forInUnsafe.loop, HAdd.hAdd, OfNat.ofNat],[]]
[Std.HashSetImp.expand.proof_1,[Nat.mul_pos, Subtype.property, of_decide_eq_true, Eq.refl, Bool.true],[GT.gt, HMul.hMul, Array.size, Subtype.val, OfNat.ofNat]]
[Fin.add_def,[Eq, HAdd.hAdd, Fin.mk, HMod.hMod, Fin.val, Nat.mod_lt, Fin.size_positive, rfl],[Eq, HAdd.hAdd, Fin.mk, HMod.hMod, Fin.val, Nat.mod_lt, Fin.size_positive]]
[Lean.Expr.FoldConstsImpl.State.visitedConsts,[],[Lean.NameHashSet]]
[Lean.ExprStructEq.val,[],[Lean.Expr]]
[Lean.Meta.deltaLocalDecl,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getLocalDecl, Lean.Meta.getMVarType, liftM, Lean.Meta.deltaExpand, Lean.Meta.changeLocalDecl, Bool.false],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.Meta.Rewrite.Config.mk.inj,[And.intro],[And, Eq]]
[String.codepointPosToUtf16PosFrom,[Nat, PProd.fst, String.next, HAdd.hAdd, UInt32.toNat, Char.utf16Size, String.get, OfNat.ofNat],[Nat]]
[Lean.Expr.FoldConstsImpl.cacheSize,[OfNat.ofNat],[USize]]
[Lean.IR.FnBody.set.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.FnBody.set, HAdd.hAdd, OfNat.ofNat]]
[List.hasDecEq.proof_3,[],[List.noConfusionType, False, List.nil, List.cons]]
[Lean.Meta.mkAbsurd,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getLevel, Pure.pure, Lean.mkApp4, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Lsp.DocumentSymbolResult.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DocumentSymbolResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.DocumentSymbolResult.mk]]
[Lean.Parser.Command.structureTk.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.ScopedEnvExtension.exportEntriesFn,[Array.reverse, List.toArray, Lean.ScopedEnvExtension.StateStack.newEntries],[Array, Lean.ScopedEnvExtension.Entry]]
[Lean.Elab.Tactic.Context.elaborator,[],[Lean.Name]]
[Lean.resolveGlobalConstCore,[Bind.bind, Lean.resolveGlobalName, ite, Eq, List.isEmpty, Bool.true, Lean.throwUnknownConstant, Pure.pure, PUnit.unit],[List, Lean.Name]]
[Lean.MetavarContext.hasAssignedMVar,[Bool, List.any, Lean.MetavarContext.hasAssignedLevelMVar, or, and, Lean.Expr.hasMVar, PProd.fst, PProd.snd, Bool.false, Lean.MetavarContext.isExprAssigned, Lean.MetavarContext.isDelayedAssigned],[Bool]]
[Lean.Lsp.DocumentHighlightKind.write.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.DocumentHighlightKind.write, OfNat.ofNat]]
[Std.Format.nest.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.Format.nest, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.StructInst.Source.implicit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.StructInst.Source.implicit, HAdd.hAdd, OfNat.ofNat]]
[Lean.DelayedMetavarAssignment.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.DelayedMetavarAssignment.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.DelayedMetavarAssignment.mk, And]]
[Lean.IR.Checker.CheckerContext.env,[],[Lean.Environment]]
[Lean.Lsp.ProgressParams.noConfusionType,[],[]]
[Lean.Xml.Parser.quote,[HOrElse.hOrElse, SeqLeft.seqLeft, SeqRight.seqRight, Lean.Parsec.skipChar, Char.ofNat],[Lean.Parsec]]
[Lean.Expr.constructorApp?,[OptionM.run, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.strVal, Lean.Expr.mdata, Lean.Expr.proj, OptionM, Prod, Lean.ConstructorVal, Array, Lean.Expr, ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Bind.bind, Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo, Option, Lean.Environment.find?, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Prod.mk, List.toArray, List.nil, List.cons, Lean.mkNatLit, HSub.hSub, Lean.Expr.getAppFn, HAdd.hAdd, Lean.ConstructorVal.numParams, Lean.ConstructorVal.numFields, Lean.Expr.getAppNumArgs, Lean.Expr.getAppArgs],[Option, Prod, Lean.ConstructorVal, Array, Lean.Expr]]
[Lean.Compiler.findBinFoldFn,[List.lookup, Lean.Compiler.binFoldFns],[Option, Lean.Compiler.BinFoldFn]]
[Lean.CollectLevelParams.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.CollectLevelParams.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.CollectLevelParams.State.mk, And]]
[Lean.Elab.Command.ProjectionInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.ProjectionInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Command.ProjectionInfo.mk, And]]
[List.filterRevM,[List.filterAuxM, List.reverse, List.nil],[List]]
[Nat.add_mod_mod,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, Nat.add_comm, Nat.mod_add_mod, rfl],[Eq, HMod.hMod, HAdd.hAdd]]
[Lean.ExprStructEq.mk.inj,[],[Eq]]
[MonadFunctor.monadMap,[],[]]
[Lean.Elab.DefViewElabHeader.numParams,[],[Nat]]
[Lean.Elab.ContextInfo.openDecls,[],[List, Lean.OpenDecl]]
[UInt16.instSemiringUInt16.proof_6,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, HMul.hMul, UInt16.zero_def, UInt16.mul_def, UInt16.mk, OfNat.ofNat, MonoidWithZero.mul_zero, UInt16.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt16],[Eq, HMul.hMul, OfNat.ofNat]]
[UInt64.div,[UInt64.mk, HDiv.hDiv, UInt64.val],[UInt64]]
[Lean.ExternEntry.inline.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ExternEntry.inline, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ExternEntry.inline, And]]
[List.length_eq_zero,[Iff.intro, List.eq_nil_of_length_eq_zero, Eq.mpr, Eq.refl, Eq, List.length, OfNat.ofNat, rfl],[Iff, Eq, List.length, OfNat.ofNat, List.nil]]
[Lean.Compiler.atMostOnce.skip,[id],[Lean.Compiler.atMostOnce.Visitor]]
[Lean.Compiler.SpecializeAttributeKind.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Meta.kabstract.visit,[ite, Eq, Lean.Expr.hasLooseBVars, Bool.true, Unit.unit, or, bne, Lean.Expr.toHeadIndex, Lean.Expr.headNumArgs, Bind.bind, liftM, Lean.Meta.isDefEq, MonadState.get, MonadStateOf.set, HAdd.hAdd, OfNat.ofNat, Lean.Occurrences.contains, Pure.pure, Lean.mkBVar],[StateRefT', IO.RealWorld, Nat, Lean.Meta.MetaM, Lean.Expr]]
[Lean.PrettyPrinter.Delaborator.instMonadReaderOfSubExprDelabM,[MonadReaderOf.mk, Functor.map, Lean.PrettyPrinter.Delaborator.Context.subExpr, MonadReader.read],[MonadReaderOf, Lean.PrettyPrinter.Delaborator.SubExpr, Lean.PrettyPrinter.Delaborator.DelabM]]
[Lean.Declaration.axiomDecl.injEq,[Eq.propIntro, Eq.refl, Lean.Declaration.axiomDecl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Declaration.axiomDecl]]
[Lean.Parser.nodeWithAntiquot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.PrettyPrinter.Formatter.node.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Command.StructView.scopeVars,[],[Array, Lean.Expr]]
[Lean.Xml.Element.Element.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Xml.Element.Element, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Xml.Element.Element, And]]
[Nat.le_of_add_le_add_right,[Eq.mpr, Eq.refl, LE.le, Nat.add_comm, Nat.le_of_add_le_add_left],[LE.le]]
[Lean.getOptionDecl,[Bind.bind, Lean.getOptionDecls, Pure.pure, Lean.NameMap.find?, Option.none, IO, Lean.OptionDecl, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString],[IO, Lean.OptionDecl]]
[Lean.Level.addOffset,[Lean.Level.addOffsetAux],[Lean.Level]]
[Lean.Meta.IndPredBelow.mkBelowMatcher.toInaccessible,[Lean.Meta.Match.Pattern.ctor, Lean.Meta.Match.Pattern.val, Lean.Meta.Match.Pattern.arrayLit, Lean.Meta.Match.Pattern.as, Lean.Meta.MetaM, Lean.Meta.Match.Pattern, Pure.pure, Lean.Meta.Match.Pattern.inaccessible, Lean.Meta.Match.Pattern.var, Bind.bind, Lean.Meta.Match.Pattern.toExpr, Bool.false],[Lean.Meta.MetaM, Lean.Meta.Match.Pattern]]
[Lean.Lsp.TextDocumentChangeRegistrationOptions.mk.inj,[And.intro],[And, Eq]]
[StateT.instMonadFunctorStateT,[MonadFunctor.mk, Prod],[MonadFunctor, StateT]]
[Lean.Elab.Term.Do.extendUpdatedVarsAux,[Lean.Elab.Term.Do.extendUpdatedVarsAux.update],[Lean.Elab.Term.TermElabM, Lean.Elab.Term.Do.Code]]
[System.FilePath.extSeparator,[Char.ofNat],[Char]]
[IO.AsyncList.asyncTail.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.trans, Eq.refl, SizeOf.sizeOf, Except.error, Except.ok, Eq.symm, Task.pure.sizeOf_spec],[Eq, SizeOf.sizeOf, IO.AsyncList.asyncTail, HAdd.hAdd, OfNat.ofNat]]
[ReaderT.pure,[Pure.pure],[ReaderT]]
[Lean.Parser.Trie.instInhabitedTrie,[Inhabited.mk, Lean.Parser.Trie.Node, Option.none, Std.RBNode.leaf],[Inhabited, Lean.Parser.Trie]]
[MonadExcept.throw,[],[]]
[Lean.Parser.Attr.mono,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.mono.side],[Lean.ParserDescr]]
[exists_eq_right_right',[Iff.intro, And, And.intro, Eq.symm, Exists, Eq, Exists.intro, rfl],[Iff, Exists, And, Eq]]
[Lean.Export.Alloc.next,[],[Nat]]
[Lean.Elab.Term.Do.ToCodeBlock.Catch.x,[],[Lean.Syntax]]
[Lean.instToExprArray,[Lean.ToExpr.mk, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.levelZero, List.nil, Lean.ToExpr.toExpr, Array.toList, Lean.mkApp],[Lean.ToExpr, Array]]
[Lean.Elab.Tactic.logUnassignedAndAbort,[Bind.bind, liftM, Lean.Elab.Term.logUnassignedUsingErrorInfos, Option.none, ite, Eq, Bool.true, Lean.Elab.throwAbortTactic, Pure.pure, PUnit.unit],[Lean.Elab.Tactic.TacticM, Unit]]
[Mathlib.Tactic.Lint.instDecidableEqLintVerbosity.proof_2,[absurd, Eq.refl, Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx],[False]]
[String.str,[String.push],[String]]
[List.iota,[Unit.unit, Nat.succ, List, Nat, List.nil, List.cons, PProd.fst],[List, Nat]]
[Lean.Lsp.LeanFileProgressProcessingInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.LeanFileProgressProcessingInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.DiscrTree.Key.hash,[Unit.unit, UInt64, mixHash, OfNat.ofNat, Hashable.hash],[UInt64]]
[Fin.underflowingSub,[Prod.mk, Decidable.decide, LT.lt, Fin.val, HSub.hSub],[Prod, Bool, Fin]]
[add_add_add_comm,[of_eq_true, Eq.trans, congr, congrArg, Eq, add_left_comm, HAdd.hAdd, add_assoc, eq_self],[Eq, HAdd.hAdd]]
[Lean.mkSortEx,[Lean.mkSort],[Lean.Expr]]
[Lean.Parser.Command.namedName.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.mkLetFunAnnotation,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Expr]]
[Lean.Elab.Tactic.adaptExpander,[Bind.bind, Lean.Elab.Tactic.withMacroExpansion, Lean.Elab.Tactic.evalTactic],[Lean.Elab.Tactic.Tactic]]
[Lean.Meta.SimpLemma.noConfusionType,[],[]]
[Lean.Level.instHashableLevel,[Hashable.mk, Lean.Level.hash],[Hashable, Lean.Level]]
[Lean.IR.mkJDecl,[Lean.IR.FnBody.jdecl],[Lean.IR.FnBody]]
[Lean.runEval,[IO.FS.withIsolatedStreams, liftM, EIO.toBaseIO, Lean.Eval.eval, Bool.false],[IO, Prod, String, Except, IO.Error, Unit]]
[Lean.Parser.Term.letrec.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.Term.letRecDecls.parenthesizer, Lean.Parser.Term.optSemicolon.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[IO.FS.Stream.writeRequest,[IO.FS.Stream.writeMessage, Lean.JsonRpc.Message.request, Lean.JsonRpc.Request.id, Lean.JsonRpc.Request.method, Except.toOption, Lean.Json.toStructured?, Lean.JsonRpc.Request.param],[IO, Unit]]
[Lean.Meta.Split.findSplit?.isCandidate,[Id.run, ite, Eq, or, Lean.Expr.isIte, Lean.Expr.isDIte, Bool.true, not, Lean.Expr.hasLooseBVars, Lean.Expr.getArg!, OfNat.ofNat, Option.none, Id, Bool, Lean.Meta.isMatcherAppCore?, Bind.bind, ForIn.forIn, MProd.mk, PUnit.unit, Array.getOp, Pure.pure, ForInStep.done, Option.some, Bool.false, ForInStep.yield, Unit.unit, MProd.fst],[Bool]]
[Lean.InductiveVal.isRec,[],[Bool]]
[Lean.Meta.throwUnknownFVar,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkFVar],[Lean.Meta.MetaM]]
[Lean.Level.ofNat,[Unit.unit, Lean.Level, Lean.levelZero, Lean.mkLevelSucc, PProd.fst],[Lean.Level]]
[UInt64.decEq,[Decidable, Eq, dite, Decidable.isTrue, UInt64.decEq.proof_1, Decidable.isFalse, UInt64.decEq.proof_2],[Decidable, Eq]]
[Lean.Elab.Tactic.elabSimpConfig,[ite, Eq, Bool.true, Bind.bind, Lean.Elab.Tactic.elabSimpConfigCtxCore, Pure.pure, Lean.Meta.Simp.ConfigCtx.toConfig, Lean.Elab.Tactic.elabSimpConfigCore],[Lean.Elab.Term.TermElabM, Lean.Meta.Simp.Config]]
[Lean.Parser.Tactic.constructor,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Meta.IndPredBelow.mkInductiveType,[Bind.bind, List.mapM, Lean.Meta.IndPredBelow.mkConstructor, Fin.val, Lean.InductiveVal.ctors, Pure.pure, Lean.InductiveType.mk, Array.getOp, Lean.Meta.IndPredBelow.Context.belowNames, Lean.Meta.IndPredBelow.Context.headers],[Lean.Meta.MetaM, Lean.InductiveType]]
[«term_<->_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[let_val_congr,[rfl],[Eq]]
[Lean.PrettyPrinter.Parenthesizer.node.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, bne, Lean.Syntax.getKind, Bool.true, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.IRType.isObj,[Lean.IR.IRType.float, Lean.IR.IRType.uint8, Lean.IR.IRType.uint16, Lean.IR.IRType.uint32, Lean.IR.IRType.uint64, Lean.IR.IRType.usize, Lean.IR.IRType.irrelevant, Unit.unit, Lean.IR.IRType.struct, Lean.IR.IRType.union, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Widget.MsgEmbed.expr.injEq,[Eq.propIntro, Eq.refl, Lean.Widget.MsgEmbed.expr, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Widget.MsgEmbed.expr]]
[gpow_rec,[npow_rec, Inv.inv, Nat.succ],[]]
[Lean.IR.ExplicitRC.VarInfo.mk.inj,[And.intro],[And, Eq]]
[MonadExcept.tryCatch,[],[]]
[Lean.Meta.isMonad?,[MonadExcept.tryCatch, Bind.bind, Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Lean.Meta.trySynthInstance, Option.none, Lean.LOption.none, Lean.LOption.undef, Lean.Meta.MetaM, Option, Lean.Expr, Pure.pure, Option.some],[Lean.Meta.MetaM, Option, Lean.Expr]]
[Lean.Meta.getPostponed,[Bind.bind, MonadState.get, Pure.pure, Lean.Meta.State.postponed],[Lean.Meta.MetaM, Std.PersistentArray, Lean.Meta.PostponedEntry]]
[Lean.PrefixTreeNode.below,[PProd, PUnit],[]]
[Lean.Parser.Term.suffices.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.sufficesDecl.parenthesizer, Lean.Parser.Term.optSemicolon.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.Cases.Context.noConfusionType,[],[]]
[UInt64.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd],[UInt64]]
[Lean.Server.MonadRpcSession.rpcStoreRef,[],[Lean.Lsp.RpcRef]]
[Lean.Meta.SynthInstance.Waiter.consumerNode.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SynthInstance.Waiter.consumerNode, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Command.StructFieldKind.toCtorIdx,[OfNat.ofNat],[Nat]]
[Std.HashSetImp.contains.proof_1,[Subtype.property],[GT.gt, Array.size, Subtype.val, OfNat.ofNat]]
[instInhabitedArrow,[Inhabited.mk, arbitrary],[Inhabited]]
[Lean.Elab.Term.LValResolution.const.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.LValResolution.const, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.simpleBinderWithoutType.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.PrettyPrinter.Formatter.pushNone.formatter, Bool.true],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Tactic.matchRhs,[HOrElse.hOrElse, Lean.Parser.Term.hole, Lean.Parser.Term.syntheticHole, Lean.Parser.Tactic.tacticSeq],[Lean.Parser.Parser]]
[Lean.instBEqLiteral,[BEq.mk, Lean.Literal.natVal, Lean.Literal.strVal, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Literal]]
[Lean.Parser.Error.noConfusionType,[],[]]
[Lean.instBEqFVarId,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.FVarId]]
[instToStringId_1,[inferInstanceAs, ToString],[ToString, Id]]
[Lean.instFromJsonProd,[Lean.FromJson.mk, Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.str, dite, Eq, Array.size, Array.getLit, Eq.symm, of_decide_eq_true, id, Eq.refl, Bool.true, Array.toArrayLit_eq, Lean.Json.arr, Lean.Json.obj, Except, String, Prod, Bind.bind, Lean.FromJson.fromJson?, Pure.pure, Prod.mk, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.FromJson, Prod]]
[Lean.Parser.Tactic.sliceRHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[Lean.PrettyPrinter.Parenthesizer.tokenWithAntiquot.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, Lean.Syntax.isTokenAntiquot, Bool.true, Lean.PrettyPrinter.Parenthesizer.visitArgs],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Expr.ReplaceLevelImpl.replaceUnsafeM.visit,[Bind.bind, MonadState.get, ite, Eq, BEq.beq, ptrAddrUnsafe, Array.uget, Lean.Expr.ReplaceLevelImpl.State.keys, lcProof, Bool.true, Pure.pure, Lean.Expr.ReplaceLevelImpl.State.results, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.lit, Lean.Expr.ReplaceLevelImpl.ReplaceM, Lean.Expr, Lean.Expr.ReplaceLevelImpl.replaceUnsafeM.visit, Lean.Expr.ReplaceLevelImpl.cache, Lean.Expr.updateForallE!, Lean.Expr.updateLambdaE!, Lean.Expr.updateMData!, Lean.Expr.updateLet!, Lean.Expr.updateApp!, Lean.Expr.updateProj!, Lean.Expr.updateSort!, Lean.Level.replace, Lean.Expr.updateConst!, List.map],[Lean.Expr.ReplaceLevelImpl.ReplaceM, Lean.Expr]]
[Lean.Elab.Tactic.renameInaccessibles,[ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Bind.bind, liftM, Lean.Meta.getMVarDecl, ForIn.forIn, MProd.mk, Unit.unit, Lean.Elab.Tactic.TacticM, ForInStep, MProd, Lean.NameSet, Lean.LocalContext, Array, Lean.Syntax, Lean.LocalContext.getAt?, ForInStep.yield, or, Lean.Name.hasMacroScopes, Lean.LocalDecl.userName, Lean.NameSet.contains, Lean.Syntax.isIdent, PUnit.unit, Lean.MVarId, Lean.Elab.logError, Lean.ToMessageData.toMessageData],[Lean.Elab.Tactic.TacticM, Lean.MVarId]]
[Lean.Parser.Tactic.contrapose!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.PrettyPrinter.Parenthesizer.eoi.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[Char.utf8Size.proof_5,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[Lean.Meta.Simp.M,[ReaderT, Lean.Meta.Simp.Methods, Lean.Meta.Simp.SimpM],[]]
[Nat.mul_div_assoc,[Eq, HDiv.hDiv, HMul.hMul, Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, OfNat.ofNat, Nat.div_zero, Nat.mul_zero, rfl],[Eq, HDiv.hDiv, HMul.hMul]]
[Lean.ppHardSpace.formatter,[Lean.PrettyPrinter.Formatter.push, Std.Format.text],[Lean.PrettyPrinter.Formatter]]
[Lean.Compiler.boolFoldFns,[List.cons, Prod.mk, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Compiler.foldStrictOr, Lean.Compiler.foldStrictAnd, List.nil],[List, Prod, Lean.Name, Lean.Compiler.BinFoldFn]]
[Lean.LocalContext.getUnusedName,[ite, Eq, Lean.LocalContext.usesUserName, Bool.true, Prod.fst, OfNat.ofNat],[Lean.Name]]
[List.forall_mem_nil,[Eq.refl],[]]
[Lean.Elab.Term.SyntheticMVarKind.postponed.inj,[],[Eq]]
[List.spanAux,[Prod, List, Prod.mk, List.reverse, List.nil, Unit.unit, PProd.fst, List.cons],[Prod, List]]
[Lean.Syntax.isInterpolatedStrLit?,[Unit.unit, Option, String, Lean.Syntax.isLit?, Lean.interpolatedStrLitKind, Option.none, OfNat.ofNat],[Option, String]]
[Array.binInsert,[Id.run, Array.binInsertM],[Array]]
[Lean.Compiler.SpecEntry.info.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Compiler.SpecEntry.info, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.type.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.checkWsBefore.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.PrettyPrinter.Formatter.checkColGt.formatter, Lean.Parser.levelParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[List.exists_erase_eq,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Exists, And, Not, Mem.mem, Eq, HAppend.hAppend, List.cons, List.erase, List.exists_of_erasep, rfl, Eq.mpr, List.erase_eq_erasep, Exists.intro, And.intro],[Exists, And, Not, Mem.mem, Eq, HAppend.hAppend, List.cons, List.erase]]
[instToStringUInt8,[ToString.mk, ToString.toString, UInt8.toNat],[ToString, UInt8]]
[Std.ShareCommon.State.shareCommon,[Prod.mk],[Prod, Std.ShareCommon.State]]
[Lean.Parser.Command.macroTailCommand,[HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.identEq, Lean.Name.mkSimple, Lean.Parser.darrow, Lean.Parser.Command.macroRhs, Lean.Parser.many1Unbox, Lean.Parser.commandParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Int.subNatNat_of_le,[Int.subNatNat_of_sub_eq_zero, Nat.sub_eq_zero_of_le],[Eq, Int.subNatNat, Int.ofNat, HSub.hSub]]
[Lean.Server.publishProgressDone,[Lean.Server.publishProgress, List.toArray, List.nil],[IO, Unit]]
[Lean.MetavarContext.addExprMVarDecl,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, HAdd.hAdd, Lean.MetavarContext.mvarCounter, OfNat.ofNat, Lean.MetavarContext.lDepth, Std.PersistentHashMap.insert, Lean.MetavarContext.decls, Lean.MetavarDecl.mk, ite, Eq, Lean.Name.isAnonymous, Bool.true, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment],[Lean.MetavarContext]]
[Mathlib.Tactic.Lint.simpNF,[Mathlib.Tactic.Lint.Linter.mk, Bind.bind, Mathlib.Tactic.Lint.isSimpLemma, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Option.none, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format],[Mathlib.Tactic.Lint.Linter]]
[instAddCommSemigroup,[AddCommSemigroup.mk, AddCommMonoid.add_comm],[AddCommSemigroup]]
[Lean.Parser.Command.classTk.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.LetRecView.mk.inj,[And.intro],[And, Eq]]
[Lean.Compiler.atMostOnce.AtMostOnceData.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Compiler.atMostOnce.AtMostOnceData.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Compiler.atMostOnce.AtMostOnceData.mk, And]]
[Lean.Parser.Term.forall.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.unicodeSymbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.simpleBinder.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Bool.false, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.min_le_left,[Decidable.em, LE.le, Eq.mpr, congrFun, congrArg, Eq.trans, ite_congr, eq_true, Eq.refl, ite_true, Nat.le_refl, Eq.symm, eq_false, ite_false, Nat.le_of_not_le],[LE.le, Nat.min]]
[Array.modifyOp,[Array.modify],[Array]]
[IO.FS.Stream.writeLspMessage,[Bind.bind, IO.FS.Stream.putStr, HAppend.hAppend, IO.FS.Stream.flush],[IO, Unit]]
[Lean.Meta.getConst?,[Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.Meta.MetaM, Option, Lean.ConstantInfo, Lean.Environment.find?, Lean.Meta.getTheoremInfo, MonadReader.read, Lean.Meta.TransparencyMode.reducible, Lean.Meta.TransparencyMode.instances, Lean.Meta.Config.transparency, Lean.Meta.Context.config, Pure.pure, Option.some, Lean.isReducible, Lean.ConstantInfo.name, ite, Eq, Bool.true, and, BEq.beq, Lean.Meta.isGlobalInstance, Option.none, Lean.throwUnknownConstant],[Lean.Meta.MetaM, Option, Lean.ConstantInfo]]
[Lean.Lsp.Ipc.stdout,[Bind.bind, MonadReader.read, Pure.pure, IO.FS.Stream.ofHandle, IO.Process.Child.stdout],[Lean.Lsp.Ipc.IpcM, IO.FS.Stream]]
[Lean.Rat.instLERat,[LE.mk, Not, LT.lt],[LE, Lean.Rat]]
[Nat.coprime_mul_iff_left,[Iff.intro, And.intro, Nat.coprime.coprime_mul_right, Nat.coprime.coprime_mul_left, Nat.coprime, HMul.hMul, Eq.mpr, Eq.refl, propext, Nat.coprime_iff_gcd_eq_one, Eq, Nat.gcd, OfNat.ofNat, Nat.coprime.gcd_mul_left_cancel],[Iff, Nat.coprime, HMul.hMul, And]]
[SeqRight.noConfusionType,[],[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.annotateBool,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getPos, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.annotateBoolAt],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM, Unit]]
[Lean.MetavarKind.isSyntheticOpaque,[Lean.MetavarKind.natural, Lean.MetavarKind.synthetic, Unit.unit, Bool, Bool.true, Bool.false],[Bool]]
[Nat.le_of_not_le,[Or.resolve_left, Nat.le_or_le],[LE.le]]
[Lean.Level.succ.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Level.succ, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Level.succ, And]]
[Lean.PrettyPrinter.Formatter.trailingNode.formatter,[Bind.bind, Lean.PrettyPrinter.Formatter.checkKind, Lean.PrettyPrinter.Formatter.visitArgs, Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Formatter]]
[Lean.Compiler.SpecEntry.cache.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Compiler.SpecEntry.cache, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Compiler.SpecEntry.cache, And]]
[Lean.Lsp.instBEqRange,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Lsp.Range]]
[Lean.Parser.manyNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.noFirstTokenInfo, Lean.Parser.Parser.info, Lean.Parser.manyFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[iff_iff_and_or_not_and_not,[Decidable.iff_iff_and_or_not_and_not],[Iff, Or, And, Not]]
[Lean.Elab.Term.SavedState.noConfusionType,[],[]]
[Lean.binderIdent,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Quot.rec,[Quot.liftIndepPr1, PSigma.snd, Quot.lift, Quot.indep, Quot.indepCoherent],[]]
[Lean.Elab.addAsAxiom,[Lean.withRef, Lean.Elab.PreDefinition.ref, Lean.addDecl, Lean.Declaration.axiomDecl, Lean.AxiomVal.mk, Lean.ConstantVal.mk, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.levelParams, Lean.Elab.PreDefinition.type, Lean.Elab.Modifiers.isUnsafe, Lean.Elab.PreDefinition.modifiers],[Lean.Meta.MetaM, Unit]]
[Option.mapM,[Option.none, Option, Bind.bind, Pure.pure, Option.some],[Option]]
[Lean.Parser.Command.alias,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.unary],[Lean.ParserDescr]]
[Substring.toIterator,[String.Iterator, String.Iterator.mk],[String.Iterator]]
[Lean.Lsp.InitializeResult.capabilities,[],[Lean.Lsp.ServerCapabilities]]
[List.instLTList,[LT.mk, List.lt],[LT, List]]
[Lean.Elab.Command.elabGenInjectiveTheorems,[Bind.bind, Lean.resolveGlobalConstNoOverload, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Command.liftTermElabM, Option.none, liftM, Lean.Meta.mkInjectiveTheorems],[Lean.Elab.Command.CommandElab]]
[Lean.Level.isMax,[Lean.Level.zero, Lean.Level.succ, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Bool, Bool.true, Bool.false],[Bool]]
[Lean.IR.CollectMaps.collectJP,[Prod, Lean.IR.VarTypeMap, Lean.IR.JPParamsMap, Prod.mk, Std.HashMap.insert],[Lean.IR.CollectMaps.Collector]]
[List.intercalate,[List.join, List.intersperse],[List]]
[Function.is_partial_inv_left,[Iff.mpr, rfl],[Eq, Option.some]]
[List.hasDecEq,[Unit.unit, Decidable, Eq, Decidable.isTrue, List.hasDecEq.proof_1, Decidable.isFalse, List.hasDecEq.proof_2, List.hasDecEq.proof_3, List.cons, decEq, PProd.fst, List.hasDecEq.proof_4, List.hasDecEq.proof_5, List.hasDecEq.proof_6],[Decidable, Eq]]
[Lean.Parser.Term.binrel_no_prop.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.ppSpace.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[Prod.fst_swap,[rfl],[Eq, Prod.fst, Prod.swap, Prod.snd]]
[Lean.MetavarContext.mkForall,[Bind.bind, Lean.MetavarContext.mkBinding, Bool.false, Lean.MetavarContext.MkBindingM, Lean.Expr, Pure.pure],[Lean.MetavarContext.MkBindingM, Lean.Expr]]
[Lean.Lsp.CompletionOptions.triggerCharacters?,[],[Option, Array, String]]
[dec_em',[Or.swap, dec_em],[Or, Not]]
[Lean.Elab.CommandInfo.noConfusionType,[],[]]
[Lean.instFromJsonList,[Lean.FromJson.mk, Except.map, Array.toList, Lean.FromJson.fromJson?],[Lean.FromJson, List]]
[Lean.Parser.Term.letPatDecl,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.termParser, OfNat.ofNat, Lean.Parser.pushNone, Lean.Parser.Term.optType, Lean.Parser.symbol, Bool.false],[Lean.Parser.Parser]]
[String.toAsciiByteArray.loop.proof_2,[And.intro, Nat.lt_add_of_pos_right, String.csize_pos, String.get, Nat.lt_of_not_le, mt, decide_eq_true],[And, LT.lt, String.next, String.utf8ByteSize]]
[Lean.Parser.Command.def.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.Command.optDeclSig.parenthesizer, Lean.Parser.Command.declVal.parenthesizer, Lean.Parser.Command.optDefDeriving.parenthesizer, Lean.Parser.Command.terminationSuffix.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Classical.axiomOfChoice,[Exists.intro, Classical.choose, Classical.choose_spec],[Exists]]
[Lean.Elab.Term.elabArrayRef,[Bind.bind, List.nil, Bool.false, List.toArray, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.Elab.Term.TermElabM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Pure.pure, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError],[Lean.Elab.Term.TermElab]]
[Lean.Syntax.mkCApp,[Lean.Syntax.mkApp, Lean.mkCIdent],[Lean.Syntax]]
[Lean.Lsp.SemanticTokensOptions.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.SemanticTokensOptions.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.SemanticTokensOptions.mk, And]]
[Lean.Meta.Match.Pattern.as.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.Pattern.as, HAdd.hAdd, OfNat.ofNat]]
[Except.toBool,[Bool, Bool.true, Bool.false],[Bool]]
[Nat.dvd_add_iff_left,[Eq.mpr, Eq.refl, Iff, Dvd.dvd, HAdd.hAdd, Nat.add_comm, Nat.dvd_add_iff_right],[Iff, Dvd.dvd, HAdd.hAdd]]
[UInt64.instSemigroupUInt64.proof_1,[congrArg, UInt64.mk, Semigroup.mul_assoc, UInt64.val],[Eq, UInt64.mk]]
[Lean.Parsec.peek?,[ite, Eq, String.Iterator.hasNext, Bool.true, Lean.Parsec.ParseResult.success, Option.some, String.Iterator.curr, Option.none],[Lean.Parsec, Option, Char]]
[Lean.Meta.SynthInstance.GeneratorNode.currInstanceIdx,[],[Nat]]
[Lean.ClosedTermCache.mk.inj,[And.intro],[And, Eq]]
[Lean.DataValue.ofString.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.DataValue.ofString, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.TransparencyMode.instances.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.TransparencyMode.instances, OfNat.ofNat]]
[Lean.Parser.Tactic.tacticSuffices_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.IR.Expr.unbox.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Expr.unbox, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.RpcRef.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.RpcRef.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.RpcRef.mk]]
[Lean.Meta.mkSimpExt,[Lean.registerSimpleScopedEnvExtension, Lean.SimpleScopedEnvExtension.Descr.mk, Lean.Meta.SimpLemmas, Lean.Meta.addSimpLemmaEntry, Lean.Meta.SimpLemmas.addDeclToUnfold, Lean.Meta.SimpLemmas.mk],[IO, Lean.Meta.SimpExtension]]
[Lean.Elab.InfoTree.foldInfo,[Option.none, Lean.Elab.InfoTree.foldInfo.go],[]]
[Set.insert,[setOf, Or, Eq, Mem.mem],[Set]]
[Lean.ConstantInfo.ctorInfo.inj,[],[Eq]]
[Std.RBTree.seteq,[and, Std.RBTree.subset],[Bool]]
[Lean.Elab.Term.expandMatchAltsWhereDecls.loop,[Unit.unit, Lean.MacroM, Lean.Syntax, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, ite, Eq, Lean.Syntax.isNone, Bool.true, Lean.Elab.Term.expandWhereDeclsOpt, Lean.MonadQuotation.withFreshMacroScope, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, PProd.fst, Array.push],[Lean.MacroM, Lean.Syntax]]
[Lean.Elab.Structural.EqnInfo.mk.inj,[And.intro],[And, Eq]]
[instMonadStateOf,[MonadStateOf.mk, liftM, MonadStateOf.get, MonadStateOf.set, MonadLiftT.monadLift, MonadState.modifyGet],[MonadStateOf]]
[Lean.Parser.Term.doDbgTrace,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, HOrElse.hOrElse, Lean.Parser.interpolatedStr, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.Elab.Term.MutualClosure.ClosureState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.MutualClosure.ClosureState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.MutualClosure.ClosureState.mk, And]]
[List.mem_insert_self,[Iff.mpr, List.mem_insert_iff, Or.inl, rfl],[Mem.mem, List.insert]]
[Array.contains,[Array.any, BEq.beq, OfNat.ofNat, Array.size],[Bool]]
[Lean.Expr.getAppArgs,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Array, Lean.Expr, PProd.fst, Array.set!, HSub.hSub, OfNat.ofNat, Array.mkArray],[Array, Lean.Expr]]
[Lean.Elab.Command.ElabStructResult.noConfusionType,[],[]]
[Lean.mkLevelIMax,[Lean.Level.imax, Lean.Level.mkData, mixHash, OfNat.ofNat, Hashable.hash, HAdd.hAdd, Nat.max, Lean.Level.depth, or, Lean.Level.hasMVar, Lean.Level.hasParam],[Lean.Level]]
[Lean.Parser.Tactic.Conv.simp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpStar, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma],[Lean.ParserDescr]]
[Lean.IR.AltCore.default.injEq,[Eq.propIntro, Eq.refl, Lean.IR.AltCore.default, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.AltCore.default]]
[Lean.MessageLog.instAppendMessageLog,[Append.mk, Lean.MessageLog.append],[Append, Lean.MessageLog]]
[Div.div,[],[]]
[Lean.PrettyPrinter.Formatter.optionalNoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.visitArgs],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.Do.Code.seq.inj,[And.intro],[And, Eq]]
[Lean.Level.succ.inj,[And.intro],[And, Eq]]
[Lean.Parser.checkPrec,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.checkPrecFn],[Lean.Parser.Parser]]
[UInt16.mod_def,[rfl],[Eq, HMod.hMod, UInt16.mk, UInt16.val]]
[Std.Format.instCoeStringFormat,[Coe.mk, Std.Format.text],[Coe, String, Std.Format]]
[Lean.Meta.mkEq,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getLevel, Pure.pure, Lean.mkApp3, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Elab.Term.Context.noConfusionType,[],[]]
[Lean.Meta.SynthInstance.ConsumerNode.mctx,[],[Lean.MetavarContext]]
[Lean.Parser.Term.letMVar.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[IO.sleep,[dbgSleep, EStateM.Result.ok, Unit.unit],[IO, Unit]]
[«term_<&>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Function.Equiv,[Eq],[]]
[Lean.Meta.SynthInstance.Context.maxHeartbeats,[],[Nat]]
[instCoeTail,[CoeTail.mk, coeFun],[CoeTail]]
[Lean.Elab.Term.Quotation.HeadInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Quotation.HeadInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[USize.ofNatCore,[USize.mk, Fin.mk],[USize]]
[Lean.Compiler.CSimp.Entry.toDeclName,[],[Lean.Name]]
[Function.const_comp,[rfl],[Eq, Function.comp, Function.const]]
[Function.eq_update_iff,[Iff.trans, Function.funext_iff, Function.forall_update_iff, Eq],[Iff, Eq, Function.update, And]]
[Lean.Elab.Command.withFreshMacroScope,[Bind.bind, MonadState.modifyGet, Prod.mk, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, HAdd.hAdd, OfNat.ofNat, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, MonadWithReader.withReader, Lean.Elab.Command.Context.mk, Lean.Elab.Command.Context.fileName, Lean.Elab.Command.Context.fileMap, Lean.Elab.Command.Context.currRecDepth, Lean.Elab.Command.Context.cmdPos, Lean.Elab.Command.Context.macroStack, Lean.Elab.Command.Context.ref],[Lean.Elab.Command.CommandElabM]]
[Lean.Elab.Term.PatternVarDecl.noConfusionType,[],[]]
[Lean.Elab.Tactic.evalSimpAll,[Bind.bind, Lean.Elab.Tactic.mkSimpContext, Bool.true, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Meta.simpAll, Unit.unit, Lean.Elab.Tactic.replaceMainGoal, List.nil, List.cons],[Lean.Elab.Tactic.Tactic]]
[Lean.getPPAnalyzeTrustSubst,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.trustSubst, Lean.Option.defValue],[Bool]]
[Lean.Meta.AbstractMVars.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.AbstractMVars.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.instInhabitedEnumAttributes,[Inhabited.mk, Lean.EnumAttributes.mk, arbitrary],[Inhabited, Lean.EnumAttributes]]
[Lean.Lsp.instFileSourceRpcCallParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.RpcCallParams.toTextDocumentPositionParams],[Lean.Lsp.FileSource, Lean.Lsp.RpcCallParams]]
[Lean.Lsp.TextDocumentRegistrationOptions.documentSelector?,[],[Option, Lean.Lsp.DocumentSelector]]
[Lean.addDocString,[Lean.MonadEnv.modifyEnv, Lean.MapDeclarationExtension.insert],[Unit]]
[Lean.ImportState.mk.inj,[And.intro],[And, Eq]]
[Subtype.val_injective,[Subtype.coe_injective],[Function.injective, Subtype.val]]
[Std.Format.MonadPrettyFormat.currColumn,[],[Nat]]
[Lean.Expr.bvarIdx!,[Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Nat, panicWithPosWithDecl, OfNat.ofNat],[Nat]]
[Lean.Lsp.WorkDoneProgressReport.percentage?,[],[Option, Nat]]
[List.erase_of_not_mem,[rfl, Eq.mpr, Eq.refl, Eq, List.erase, List.cons, List.erase_cons, ite, if_neg, Ne.symm, And.left, Eq.mp, Not, Or, Mem.mem, propext, not_or, List.mem_cons, And.right],[Eq, List.erase]]
[Lean.IR.EmitC.emitMarkPersistent,[ite, Eq, Lean.IR.IRType.isObj, Lean.IR.Decl.resultType, Bool.true, Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitCName, Lean.IR.EmitC.emitLn, Pure.pure, PUnit.unit],[Lean.IR.EmitC.M, Unit]]
[instMonadReader,[MonadReader.mk, readThe],[MonadReader]]
[Lean.IR.mkLiveVarSet,[Std.RBTree.insert, Std.RBTree.empty],[Lean.IR.LiveVarSet]]
[Lean.Elab.Term.observing,[Bind.bind, Lean.MonadBacktrack.saveState, MonadExcept.tryCatch, Lean.Elab.Term.SavedState.restore, Bool.true, Pure.pure, EStateM.Result.ok, Lean.Exception.error, Lean.Exception.internal, Lean.Elab.Term.TermElabM, Lean.Elab.Term.TermElabResult, EStateM.Result.error, ite, Eq, BEq.beq, Lean.Elab.postponeExceptionId, PUnit.unit],[Lean.Elab.Term.TermElabM, Lean.Elab.Term.TermElabResult]]
[Lean.Parser.Term.leading_parser,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.optExprPrecedence, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[IO.Error.inappropriateType.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.inappropriateType, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.inappropriateType, And]]
[Lean.Server.Watchdog.ServerEvent.clientMsg.injEq,[Eq.propIntro, Eq.refl, Lean.Server.Watchdog.ServerEvent.clientMsg, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.Watchdog.ServerEvent.clientMsg]]
[Lean.FileMap.toPosition,[Lean.Position, ite, Eq, and, Decidable.decide, GE.ge, Array.size, OfNat.ofNat, LE.le, Array.back, Bool.true, HSub.hSub, Lean.FileMap.toPosition.loop, Lean.FileMap.toPosition.toColumn, Array.isEmpty, Lean.Position.mk],[Lean.Position]]
[Lean.RecursorVal.getInduct,[Lean.Name.getPrefix, Lean.ConstantVal.name, Lean.RecursorVal.toConstantVal],[Lean.Name]]
[Lean.Elab.Term.Do.Code.continue.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.Code.continue, HAdd.hAdd, OfNat.ofNat]]
[observing,[MonadExcept.tryCatch, Bind.bind, Pure.pure, Except.ok, Except.error],[Except]]
[Lean.Meta.MVarRenaming.find?,[Std.RBMap.find?, Lean.Meta.MVarRenaming.map],[Option, Lean.MVarId]]
[IO.AccessRight.flags,[UInt32.lor],[UInt32]]
[Lean.EnvExtension.getState,[Lean.EnvExtensionInterface.getState, Lean.EnvExtensionInterfaceImp],[]]
[Lean.Elab.Term.throwTypeMismatchError,[Unit.unit, Lean.Elab.Term.TermElabM, Bind.bind, Lean.Elab.Term.mkTypeMismatchError, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, liftM, Lean.Meta.throwAppTypeMismatch, Lean.MessageData.ofFormat],[Lean.Elab.Term.TermElabM]]
[Std.instInhabitedRBTree,[Inhabited.mk, Std.RBMap.empty],[Inhabited, Std.RBTree]]
[Lean.IR.UnreachableBranches.Value.widening,[Lean.IR.UnreachableBranches.Value.truncate, Lean.IR.UnreachableBranches.Value.merge, EmptyCollection.emptyCollection],[Lean.IR.UnreachableBranches.Value]]
[Coe.coe,[],[]]
[addParenHeuristic,[ite, Eq, or, String.isPrefixOf, Bool.true, not, String.any, Char.isWhitespace, HAppend.hAppend],[String]]
[Lean.instInhabitedKeyedDeclsAttribute,[Inhabited.mk, Lean.KeyedDeclsAttribute.mk, arbitrary],[Inhabited, Lean.KeyedDeclsAttribute]]
[Lean.IR.modifyEnv,[modify, Lean.IR.CompilerState.mk, Lean.IR.CompilerState.env, Lean.IR.CompilerState.log],[Lean.IR.CompilerM, Unit]]
[Lean.Elab.Command.instAddMessageContextCommandElabM,[Lean.AddMessageContext.mk, Lean.addMessageContextPartial],[Lean.AddMessageContext, Lean.Elab.Command.CommandElabM]]
[Lean.IR.ExplicitBoxing.BoxingContext.localCtx,[],[Lean.IR.LocalContext]]
[List.instForMList,[ForM.mk, List.forM],[ForM, List]]
[Lean.MetavarContext.decls,[],[Std.PersistentHashMap, Lean.MVarId, Lean.MetavarDecl]]
[ExceptCpsT.instMonadLiftExceptCpsT,[MonadLift.mk, ExceptCpsT.lift],[MonadLift, ExceptCpsT]]
[plift.up.inj,[],[Eq]]
[instXorUInt32,[Xor.mk, UInt32.xor],[Xor, UInt32]]
[Lean.Server.Snapshots.Snapshot.interactiveDiags,[],[Std.PersistentArray, Lean.Widget.InteractiveDiagnostic]]
[Lean.IR.FnBody.set.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.set, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.FnBody.set, And]]
[Lean.EnvironmentHeader.noConfusionType,[],[]]
[Lean.Server.instInhabitedWithRpcRef,[Inhabited.mk, Lean.Server.WithRpcRef.mk, arbitrary],[Inhabited, Lean.Server.WithRpcRef]]
[Lean.Json.instCoeArrayJsonStructured,[Coe.mk, Lean.Json.Structured.arr],[Coe, Array, Lean.Json, Lean.Json.Structured]]
[Lean.Meta.SimpAll.State.modified,[],[Bool]]
[Lean.Name.instReprSyntax,[Repr.mk],[Repr, Lean.Syntax]]
[Lean.Elab.Term.CollectPatternVars.instInhabitedContext,[Inhabited.mk, Lean.Elab.Term.CollectPatternVars.Context.mk, arbitrary],[Inhabited, Lean.Elab.Term.CollectPatternVars.Context]]
[Lean.Parser.Tactic.Conv.convSeqBracketed,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[Nat.mul_mod_right,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HMul.hMul, OfNat.ofNat, Eq.symm, Nat.zero_add, HAdd.hAdd, Nat.add_mul_mod_self_left, Nat.zero_mod, rfl],[Eq, HMod.hMod, HMul.hMul, OfNat.ofNat]]
[Lean.Elab.Term.toParserDescr.processParserCategory,[Bind.bind, MonadReader.read, ite, Eq, and, Lean.Elab.Term.ToParserDescrContext.first, BEq.beq, Lean.Elab.Term.ToParserDescrContext.catName, Bool.true, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Elab.Term.ToParserDescrM, Lean.Syntax]]
[Lean.KeyedDeclsAttribute.ExtensionState.erase,[ite, Eq, Std.PersistentHashSet.contains, Lean.KeyedDeclsAttribute.ExtensionState.declNames, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Core.CoreM, Lean.KeyedDeclsAttribute.ExtensionState]]
[Std.PersistentHashMap.forM,[Std.PersistentHashMap.foldlM, PUnit.unit],[PUnit]]
[UInt8.instSemiringUInt8.proof_2,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt8.zero_def, UInt8.add_def, UInt8.mk, OfNat.ofNat, zero_add, UInt8.val, UInt8.mk_val_eq, eq_self, propext, forall_const, UInt8],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Lean.KernelException.declHasMVars.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KernelException.declHasMVars, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.axiom,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.declId, Lean.Parser.Command.declSig],[Lean.Parser.Parser]]
[Lean.Lsp.TextDocumentContentChangeEvent.rangeChange.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.TextDocumentContentChangeEvent.rangeChange, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.TextDocumentContentChangeEvent.rangeChange, And]]
[Std.mkRBMap,[Subtype.mk, Std.RBNode.leaf, Std.mkRBMap.proof_1],[Std.RBMap]]
[Lean.DeclarationRanges.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.DeclarationRanges.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.DeclarationRanges.mk, And]]
[Lean.Option.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Option.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Option.mk, And]]
[Lean.Xml.Parser.Misc,[HOrElse.hOrElse, SeqRight.seqRight, Lean.Xml.Parser.Comment, Pure.pure, Unit.unit, Lean.Xml.Parser.PI, Lean.Xml.Parser.S],[Lean.Parsec, Unit]]
[decidableEq_of_decidableLe.proof_1,[le_refl],[False]]
[Lean.Parser.Attr.simple.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.priorityParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Expr.isNatLit,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.strVal, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[Lean.PrettyPrinter.Delaborator.SubExpr.getPos,[Bind.bind, readThe, Lean.PrettyPrinter.Delaborator.SubExpr, Pure.pure, Lean.PrettyPrinter.Delaborator.SubExpr.pos],[Lean.PrettyPrinter.Delaborator.Pos]]
[Lean.Meta.SynthInstance.GeneratorNode.key,[],[Lean.Expr]]
[Lean.Literal.lt,[Lean.Literal.strVal, Lean.Literal.natVal, Bool, Bool.true, Decidable.decide, LT.lt, Bool.false],[Bool]]
[Int.instCommRingInt.proof_3,[Eq.mpr, Eq.refl, Eq, HPow.hPow, Nat.succ, HMul.hMul, Int.mul_comm, rfl],[Eq, HPow.hPow, Nat.succ, HMul.hMul]]
[Lean.IR.CollectUsedDecls.collectDecl,[Lean.IR.CollectUsedDecls.M, Lean.NameSet, SeqRight.seqRight, Lean.IR.CollectUsedDecls.collectInitDecl, Lean.IR.CollectUsedDecls.collectFnBody, MonadState.get],[Lean.IR.CollectUsedDecls.M, Lean.NameSet]]
[Lean.Elab.Term.Do.ToTerm.returnToTerm,[Bind.bind, MonadReader.read, Lean.Elab.Term.Do.ToTerm.mkUVarTuple, Unit.unit, Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax, Lean.Elab.Term.Do.ToTerm.Context.kind, ite, Eq, Array.isEmpty, Lean.Elab.Term.Do.ToTerm.Context.uvars, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom, panicWithPosWithDecl, OfNat.ofNat],[Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax]]
[instDecidableFalse,[Decidable.isFalse, not_false],[Decidable, False]]
[Lean.Elab.Term.Do.ToCodeBlock.Context.ref,[],[Lean.Syntax]]
[Lean.LBool.neg,[Unit.unit, Lean.LBool, Lean.LBool.false, Lean.LBool.true, Lean.LBool.undef],[Lean.LBool]]
[Nat.sub_eq_sub_min,[dite, GE.ge, Eq.mpr, Eq.refl, Eq, HSub.hSub, min, min_eq_right, rfl, Nat.sub_eq_zero_of_le, le_of_not_ge, OfNat.ofNat, min_eq_left, Nat.sub_self],[Eq, HSub.hSub, min]]
[Lean.Expr.isAppOfArity,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, dite, Eq, Eq.symm, Lean.Expr.const, Lean.Expr.app, Nat.zero, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, BEq.beq, PProd.fst, Bool.false],[Bool]]
[Lean.Macro.Methods.resolveNamespace?,[],[Lean.MacroM, Option, Lean.Name]]
[Lean.Elab.Term.instMonadQuotationTermElabM,[Lean.MonadQuotation.mk, Lean.Elab.Term.getCurrMacroScope, Lean.Elab.Term.getMainModule, Lean.Elab.Term.withFreshMacroScope],[Lean.MonadQuotation, Lean.Elab.Term.TermElabM]]
[Lean.Elab.Attribute.stx,[],[Lean.Syntax]]
[Lean.JsonNumber.instCoeIntJsonNumber,[Coe.mk, Lean.JsonNumber.fromInt],[Coe, Int, Lean.JsonNumber]]
[Lean.Lsp.instBEqDiagnosticSeverity,[BEq.mk, BEq.beq, Lean.Lsp.DiagnosticSeverity.toCtorIdx],[BEq, Lean.Lsp.DiagnosticSeverity]]
[Int.toNat_sub,[rfl],[Eq, Int.toNat, Int.ofNat, HSub.hSub]]
[Lean.IR.EmitC.emitFnDecls,[Bind.bind, Lean.IR.EmitC.getEnv, List.forM, Lean.IR.EmitC.getDecl, Unit.unit, Lean.IR.EmitC.M, PUnit, Lean.getExternNameFor, Lean.Name.mkStr, Lean.Name.anonymous, Lean.IR.Decl.name, Lean.IR.EmitC.emitExternDeclAux, Lean.IR.EmitC.emitFnDecl, not, Lean.NameSet.contains],[Lean.IR.EmitC.M, Unit]]
[Lean.Meta.InfoCacheKey.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.InfoCacheKey.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.InfoCacheKey.mk, And]]
[Lean.Elab.Term.Context.autoBoundImplicits,[],[Std.PArray, Lean.Expr]]
[Lean.SCC.Data.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.SCC.Data.mk, HAdd.hAdd, OfNat.ofNat]]
[Prod.snd_surjective,[Nonempty.elim, Exists.intro, Prod.mk, rfl],[Function.surjective, Prod.snd]]
[Lean.Elab.Command.ElabStructResult.mk.inj,[And.intro],[And, Eq]]
[Lean.Macro.getMethodsImp,[Bind.bind, MonadReader.read, Pure.pure, unsafeCast, Lean.Macro.Context.methods],[Lean.MacroM, Lean.Macro.Methods]]
[Lean.Elab.Command.CommandElab,[Lean.Elab.Command.CommandElabM, Unit],[]]
[instHasEquiv,[HasEquiv.mk, Setoid.r],[HasEquiv]]
[Lean.Parser.Level.max.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.levelParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[String.instAppendString,[Append.mk, String.append],[Append, String]]
[Lean.Compiler.mkUInt32Lit,[Lean.Compiler.mkUIntLit, Lean.Compiler.NumScalarTypeInfo.mk, OfNat.ofNat],[Lean.Expr]]
[Lean.Level.PP.Result.succ,[Lean.Level.PP.Result.leaf, Lean.Level.PP.Result.maxNode, Lean.Level.PP.Result.imaxNode, Lean.Level.PP.Result, Lean.Level.PP.Result.offset, HAdd.hAdd, OfNat.ofNat, Lean.Level.PP.Result.num],[Lean.Level.PP.Result]]
[Lean.mkAppRange,[],[Lean.Expr]]
[instSemiringFin.proof_12,[rfl],[Eq, Nat.succ]]
[Lean.ToExpr.noConfusionType,[],[]]
[Lean.Compiler.instInhabitedInlineAttributeKind,[Inhabited.mk, Lean.Compiler.InlineAttributeKind.inline],[Inhabited, Lean.Compiler.InlineAttributeKind]]
[Lean.Meta.Match.Alt.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.Context.defEqCtx?,[],[Option, Lean.Meta.DefEqContext]]
[Prod.snd_eq_iff,[Iff, Eq, Prod.snd, Prod.mk, Prod.fst, of_eq_true, Eq.trans, congrArg, Prod.mk.injEq, congrFun, And, eq_self, true_and, iff_self],[Iff, Eq, Prod.snd, Prod.mk, Prod.fst]]
[true_ne_false,[ne_false_of_self, trivial],[Not, Eq, True, False]]
[PartialOrder.le_antisymm,[],[Eq]]
[Lean.Xml.Content.Element.inj,[],[Eq]]
[Lean.StructureFieldInfo.inferMod,[],[Bool]]
[Lean.EnvExtensionEntry,[PointedType.type, Lean.EnvExtensionEntrySpec],[]]
[Lean.EnvExtensionInterface.registerExt,[],[IO, Lean.EnvExtensionInterface.ext]]
[ByteArray.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, ByteArray.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Core.CoreM.run,[StateRefT'.run],[EIO, Lean.Exception, Prod, Lean.Core.State]]
[Lean.Elab.Term.instToStringMVarErrorKind,[ToString.mk, Unit.unit, String],[ToString, Lean.Elab.Term.MVarErrorKind]]
[Option.eq_of_eq_some,[Eq, rfl, Iff.mpr, Iff.mp, congrArg, Option.some],[Eq]]
[Lean.Parser.Term.doHave.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.haveDecl.formatter],[Lean.PrettyPrinter.Formatter]]
[Option.instOrElseOption,[OrElse.mk, Option.orElse],[OrElse, Option]]
[Lean.Parser.Command.visibility,[HOrElse.hOrElse, Lean.Parser.Command.private, Lean.Parser.Command.protected],[Lean.Parser.Parser]]
[Lean.Level.instBEqLevel,[BEq.mk, Lean.Level.beq],[BEq, Lean.Level]]
[Lean.Elab.parseImports,[Bind.bind, Lean.Parser.parseHeader, IO, Prod, List, Lean.Import, Lean.Position, Lean.MessageLog, Pure.pure, Prod.mk, Lean.Elab.headerToImports, Lean.FileMap.toPosition, Lean.Parser.InputContext.fileMap, Lean.Parser.ModuleParserState.pos],[IO, Prod, List, Lean.Import, Lean.Position, Lean.MessageLog]]
[Int.repr,[String, Nat.repr, HAppend.hAppend, Nat.succ],[String]]
[Lean.Server.FileWorker.logSnapContent,[IO.eprintln, HAppend.hAppend, ToString.toString, Lean.Server.Snapshots.Snapshot.beginPos, Lean.Server.Snapshots.Snapshot.endPos, String.extract, Lean.FileMap.source, HSub.hSub, OfNat.ofNat],[IO, Unit]]
[Lean.Elab.Command.elabNonComputableSection,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Unit.unit, Lean.Name.num, Lean.Elab.Command.CommandElabM, Unit, Pure.pure, Bind.bind, PProd.fst, Lean.MonadResolveName.getCurrNamespace, modify, Lean.Elab.Command.State.mk, Lean.Environment.registerNamespace, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, List.cons, Lean.Elab.Command.Scope.mk, Lean.Elab.Command.Scope.opts, Lean.Elab.Command.Scope.openDecls, Lean.Elab.Command.Scope.levelNames, Lean.Elab.Command.Scope.varDecls, Lean.Elab.Command.Scope.varUIds, or, Lean.Elab.Command.Scope.isNoncomputable, List.head!, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Lean.pushScope, Lean.activateScoped, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData, Bool.false, Lean.Syntax.getId, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Function.inv_fun_on_mem,[And.left, Function.inv_fun_on_pos],[Mem.mem, Function.inv_fun_on]]
[Lean.Elab.Term.StructInst.Field.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.StructInst.Field.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Command.instInhabitedStructFieldKind,[Inhabited.mk, Lean.Elab.Command.StructFieldKind.newField],[Inhabited, Lean.Elab.Command.StructFieldKind]]
[Lean.Elab.CommandInfo.format,[Pure.pure, HAppend.hAppend, Std.ToFormat.format, ite, Eq, Lean.Name.isAnonymous, Lean.Elab.ElabInfo.elaborator, Bool.true, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Std.Format, Lean.Elab.ElabInfo.stx, Lean.Elab.CommandInfo.toElabInfo],[IO, Std.Format]]
[Lean.Elab.Term.Arg.stx.inj,[],[Eq]]
[Lean.markAuxRecursor,[Lean.TagDeclarationExtension.tag, Lean.auxRecExt],[Lean.Environment]]
[eq_of_heq,[],[Eq]]
[MonadFunctorT.monadMap,[],[]]
[Lean.Parser.Command.example.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declSig.formatter, Lean.Parser.Command.declVal.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Tactic.seq1.formatter,[Lean.PrettyPrinter.Formatter.node.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.sepBy1.formatter, Lean.Parser.tacticParser.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter, Bool.true],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Command.check_failure.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Set.instUnionSet,[Union.mk, Set.union],[Union, Set]]
[StateT.run_modifyGet,[of_eq_true, eq_self, Pure.pure],[Eq, StateT.run, MonadState.modifyGet, Pure.pure, Prod.mk, Prod.fst, Prod.snd]]
[Lean.IR.ExplicitRC.VarInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.ExplicitRC.VarInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.ExplicitRC.VarInfo.mk, And]]
[Int.natAbs_eq,[Or, Eq, Int.ofNat, Int.natAbs, Neg.neg, Or.inl, rfl, Or.inr],[Or, Eq, Int.ofNat, Int.natAbs, Neg.neg]]
[Lean.Parser.isLitKind,[or, BEq.beq, Lean.strLitKind, Lean.numLitKind, Lean.charLitKind, Lean.nameLitKind, Lean.scientificLitKind],[Bool]]
[Lean.Parser.Tactic.wittTruncateFunTac,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[CoeTC.noConfusionType,[],[]]
[Lean.Elab.Term.elabForIn.throwFailure,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[StateT.instMonadLiftStateT,[MonadLift.mk, StateT.lift],[MonadLift, StateT]]
[Lean.Server.RequestM,[ReaderT, Lean.Server.RequestContext, EIO, Lean.Server.RequestError],[]]
[Std.PersistentArray.foldl,[Id.run, Std.PersistentArray.foldlM],[]]
[Lean.Meta.mkAppM,[Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.withNewMCtxDepth, Bind.bind, Lean.getConstInfo, List.mapM, Lean.Meta.mkFreshLevelMVar, Lean.ConstantInfo.levelParams, Pure.pure, Prod.mk, Lean.Meta.MetaM, Lean.Expr, OfNat.ofNat, List.toArray, List.nil, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, PUnit.unit],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Meta.withNewMCtxDepth,[Lean.Meta.mapMetaM, Bind.bind, MonadState.get, modify, Lean.Meta.State.mk, Lean.MetavarContext.incDepth, Lean.Meta.State.mctx, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Std.PersistentArray.mk, tryFinally, Lean.Meta.State.postponed],[]]
[Lean.SimplePersistentEnvExtensionDescr.addEntryFn,[],[]]
[Lean.Elab.Term.MutualClosure.getKindForLetRecs,[ite, Eq, Array.any, Lean.Elab.DefKind.isTheorem, Lean.Elab.DefViewElabHeader.kind, OfNat.ofNat, Array.size, Bool.true, Lean.Elab.DefKind.theorem, Lean.Elab.DefKind.def],[Lean.Elab.DefKind]]
[seqRight_eq_bind,[Eq.mpr, Eq.refl, Eq, SeqRight.seqRight, Bind.bind, LawfulApplicative.seqRight_eq, of_eq_true, Eq.trans, congrFun, congrArg, Seq.seq, map_eq_pure_bind, id, seq_eq_bind_map, Pure.pure, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, id_eq, bind_pure, eq_self],[Eq, SeqRight.seqRight, Bind.bind]]
[Lean.IR.FnBody.unreachable.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.IR.FnBody.unreachable, OfNat.ofNat]]
[Lean.Parser.Term.arrow,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.unicodeSymbol, Lean.Parser.termParser],[Lean.Parser.TrailingParser]]
[Lean.Name.eqStr,[Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Bool, BEq.beq, Bool.false],[Bool]]
[congrFun,[rfl],[Eq]]
[coeTail,[CoeTail.coe],[]]
[Lean.Parser.Syntax.addPrio,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Expr.setOption,[Lean.mkMData, Lean.KVMap.set, Lean.MData.empty],[Lean.Expr]]
[Lean.instToMessageDataFormat,[Lean.ToMessageData.mk, Lean.MessageData.ofFormat],[Lean.ToMessageData, Std.Format]]
[Lean.Elab.Term.elabTypeStx,[Bind.bind, ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, Lean.levelZero, Lean.Elab.Term.elabLevel, Lean.Syntax.getOp, OfNat.ofNat, Lean.mkSort, Lean.mkLevelSucc],[Lean.Elab.Term.TermElab]]
[EIO.bindTask,[BaseIO.bindTask, EIO.catchExceptions, Pure.pure, Task.pure, Except.error],[BaseIO, Task, Except]]
[Lean.Lsp.instFromJsonDidCloseTextDocumentParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Pure.pure, Lean.Lsp.DidCloseTextDocumentParams.mk],[Lean.FromJson, Lean.Lsp.DidCloseTextDocumentParams]]
[Lean.Lsp.RpcKeepAliveParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.RpcKeepAliveParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.RpcKeepAliveParams.mk, And]]
[Lean.IR.ExplicitBoxing.getJPParams,[Bind.bind, Lean.IR.ExplicitBoxing.getLocalContext, Unit.unit, Lean.IR.ExplicitBoxing.M, Array, Lean.IR.Param, Lean.IR.LocalContext.getJPParams, Pure.pure, List.toArray, List.nil],[Lean.IR.ExplicitBoxing.M, Array, Lean.IR.Param]]
[Lean.Expr.mvarId!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.MVarId, panicWithPosWithDecl, OfNat.ofNat],[Lean.MVarId]]
[not_false,[id],[Not, False]]
[Lean.KeyedDeclsAttribute.Def.mk.inj,[And.intro],[And, Eq]]
[Lean.mkStateFromImportedEntries,[Array.foldl, OfNat.ofNat, Array.size],[]]
[Lean.IR.FnBody.setBody,[Lean.IR.FnBody.case, Lean.IR.FnBody.ret, Lean.IR.FnBody.jmp, Lean.IR.FnBody.unreachable, Lean.IR.FnBody, Lean.IR.FnBody.vdecl, Lean.IR.FnBody.jdecl, Lean.IR.FnBody.set, Lean.IR.FnBody.uset, Lean.IR.FnBody.sset, Lean.IR.FnBody.setTag, Lean.IR.FnBody.inc, Lean.IR.FnBody.dec, Lean.IR.FnBody.del, Lean.IR.FnBody.mdata],[Lean.IR.FnBody]]
[SubNegMonoid.toSub,[],[Sub]]
[Lean.RecursorVal.numIndices,[],[Nat]]
[Lean.Parser.Tactic.Conv.simpMatch,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Elab.Term.StructInst.Source.implicit.inj,[],[Eq]]
[List.all,[List.foldr, and, Bool.true],[Bool]]
[Lean.ScopedEnvExtension.StateStack.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ScopedEnvExtension.StateStack.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ScopedEnvExtension.StateStack.mk, And]]
[Lean.instBEqRat,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Rat]]
[Lean.Server.instRpcEncodingOptionOption,[Lean.Server.RpcEncoding.mk, Unit.unit, Option, Pure.pure, Option.none, Functor.map, Option.some, Lean.Server.RpcEncoding.rpcEncode, ExceptT, String, Lean.Server.RpcEncoding.rpcDecode],[Lean.Server.RpcEncoding, Option]]
[Int.distrib_left,[Eq, HMul.hMul, HAdd.hAdd, of_eq_true, Eq.trans, congr, congrArg, Int.ofNat, Int.ofNat_add_ofNat, Int.ofNat_mul_ofNat, Nat.left_distrib, eq_self, Eq.mpr, Int.ofNat_add_negSucc_ofNat, Int.ofNat_mul_subNatNat, Nat.succ, Int.ofNat_mul_negSucc_ofNat, Int.negOfNat_eq_subNatNat_zero, Eq.refl, Int.subNatNat, OfNat.ofNat, Eq.symm, Int.subNatNat_add, rfl, Int.negSucc_ofNat_add_ofNat, Int.add_comm, Int.negSucc_ofNat_add_negSucc_ofNat, Int.negOfNat_add, Int.negOfNat, Nat.succ_add, Int.negSucc, Int.negSucc_ofNat_ofNat, Nat.mul_comm, Nat.right_distrib, Int.negSucc_ofNat_mul_subNatNat, Int.mul_negSucc_ofNat_negSucc_ofNat, Int.ofNat.injEq],[Eq, HMul.hMul, HAdd.hAdd]]
[Lean.Lsp.instToJsonLocation,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.Location.uri, List.nil, Lean.Lsp.Location.range],[Lean.ToJson, Lean.Lsp.Location]]
[Lean.Expr.mvar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Expr.mvar, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.ExpandResetReuse.isSelfUSet,[Option.none, Option.some, Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.sproj, Lean.IR.Expr.fap, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Bool, Std.HashMap.find?, Lean.IR.ExpandResetReuse.Context.projMap, and, BEq.beq, Bool.false],[Bool]]
[Lean.Parser.Term.binop_lazy.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[if_ctx_simp_congr_prop,[if_ctx_congr_prop],[Iff, ite]]
[Lean.Server.MonadRpcSession.rpcGetRef,[],[Option, Prod, Lean.Name, NonScalar]]
[Lean.Parser.Tactic.tacticHave'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Level.normLt,[Lean.Level.normLtAux, OfNat.ofNat],[Bool]]
[Lean.Parser.Term.waitIfTypeContainsMVar.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.MatcherApp.matcherLevels,[],[Array, Lean.Level]]
[Lean.Parser.Tactic.squeezeSimp!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[String.Range.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, String.Range.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.AbstractNestedProofs.State.mk.inj,[],[Eq]]
[not_and_of_not_right,[mt, And.right],[Not, And]]
[Lean.Json.Parser.natNumDigits,[Bind.bind, Lean.Json.Parser.lookahead, And, LE.le, Char.ofNat, Lean.Json.Parser.natCore, OfNat.ofNat],[Lean.Parsec, Prod, Nat]]
[Lean.Parser.termParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Parser.Parser]]
[Lean.Elab.DefView.kind,[],[Lean.Elab.DefKind]]
[Lean.Elab.Tactic.Location.targets.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.Location.targets, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Tactic.Location.targets, And]]
[Lean.Elab.Command.commandStop_at_first_error_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Std.PersistentHashMap.Entry.ref.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.PersistentHashMap.Entry.ref, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.MetaM.toIO,[Bind.bind, Lean.Core.CoreM.toIO, Lean.Meta.MetaM.run, IO, Prod, Lean.Core.State, Lean.Meta.State, Pure.pure, Prod.mk],[IO, Prod, Lean.Core.State, Lean.Meta.State]]
[Lean.Elab.Tactic.ElimApp.Result.alts,[],[Array, Prod, Lean.Name, Lean.MVarId]]
[Lean.PrettyPrinter.delabCore,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Std.ToFormat.format, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Prod, Lean.Syntax, Std.RBMap, Lean.PrettyPrinter.Delaborator.Pos, Lean.Elab.Info, Ord.compare]]
[Lean.IR.Expr.ctor.inj,[And.intro],[And, Eq]]
[IO.FileRight.flags,[UInt32.lor],[UInt32]]
[Lean.Meta.Match.counterExampleToMessageData,[Lean.Meta.Match.examplesToMessageData],[Lean.MessageData]]
[String.endsWith,[BEq.beq, Substring.takeRight, String.toSubstring, String.length],[Bool]]
[Lean.Expr.updateForall,[Lean.mkForall, Lean.Expr.bindingName!],[Lean.Expr]]
[Lean.Expr.occurs,[Option.isSome, Lean.Expr.find?, BEq.beq],[Bool]]
[Lean.Server.Watchdog.FileWorker.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.Watchdog.FileWorker.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.Watchdog.FileWorker.mk, And]]
[Lean.Elab.Tactic.MkSimpContextResult.noConfusionType,[],[]]
[String.Iterator.i,[],[String.Pos]]
[Lean.Widget.InteractiveDiagnostic.instRpcEncodingInteractiveDiagnosticRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Lean.Lsp.DiagnosticWith.message, Pure.pure, Lean.Lsp.DiagnosticWith.mk, Lean.Lsp.DiagnosticWith.range, Lean.Lsp.DiagnosticWith.fullRange, Lean.Lsp.DiagnosticWith.severity?, Lean.Lsp.DiagnosticWith.code?, Lean.Lsp.DiagnosticWith.source?, Lean.Lsp.DiagnosticWith.tags?, Lean.Lsp.DiagnosticWith.relatedInformation?, Lean.Server.RpcEncoding.rpcDecode],[Lean.Server.RpcEncoding, Lean.Widget.InteractiveDiagnostic, Lean.Lsp.DiagnosticWith, Lean.Widget.TaggedText]]
[Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.elabEnsureExpectedType,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Syntax.isStrLit?, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.throwIllFormedSyntax, Lean.Elab.Term.elabTermEnsuringType, Bool.true, Option.some],[Lean.Elab.Term.TermElab]]
[Lean.Server.instRpcEncodingArrayArray,[Lean.Server.RpcEncoding.mk, Array.mapM, Lean.Server.RpcEncoding.rpcEncode, Lean.Server.RpcEncoding.rpcDecode],[Lean.Server.RpcEncoding, Array]]
[Lean.Meta.SimpAll.Entry.userName,[],[Lean.Name]]
[Lean.Meta.mkEqRefl,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getLevel, Pure.pure, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Std.ShareCommon.ObjectPersistentMap.find?,[Std.PersistentHashMap.find?],[Option, Std.ShareCommon.Object]]
[Lean.Parser.Command.synth.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Name.noConfusionType,[],[]]
[Lean.Meta.Config.isDefEqStuckEx,[],[Bool]]
[Lean.Parser.Tactic.Conv.rewrite,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq],[Lean.ParserDescr]]
[Lean.Elab.Term.Do.CodeBlock.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.Match.MatcherInfo.numAlts,[Array.size, Lean.Meta.Match.MatcherInfo.altNumParams],[Nat]]
[String.csize_pos,[Char.utf8Size_pos],[LT.lt, OfNat.ofNat, String.csize]]
[Lean.Xml.Content.Character.inj,[],[Eq]]
[Lean.PrettyPrinter.Delaborator.ParamKind.defVal,[],[Option, Lean.Expr]]
[Char.repr,[Char.quote],[String]]
[Array.findIdx?.loop.proof_1,[absurd, Eq.mp, Eq.refl, LT.lt, Array.size, Eq, HAdd.hAdd, OfNat.ofNat, Nat.zero_add, Nat.lt_irrefl],[False]]
[Lean.Position.column,[],[Nat]]
[Lean.Meta.DiscrTree.instInhabitedKey,[Inhabited.mk, Lean.Meta.DiscrTree.Key.const, arbitrary],[Inhabited, Lean.Meta.DiscrTree.Key]]
[Lean.Widget.InteractiveHypothesis.val?,[],[Option, Lean.Widget.CodeWithInfos]]
[List.erasep_cons_of_neg,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.erasep_cons, ite_congr, eq_false, Eq.refl, List.cons, List.erasep, ite_false, eq_self],[Eq, List.erasep, List.cons]]
[instDecidableLe_5,[LinearOrder.decidable_le],[Decidable, LE.le]]
[Lean.ConstMap,[Lean.SMap, Lean.Name, Lean.ConstantInfo],[]]
[Std.RBMap.max!,[Unit.unit, Prod, Std.RBMap.max, panicWithPosWithDecl, OfNat.ofNat],[Prod]]
[UInt64.instSemiringUInt64,[Semiring.mk, UInt64.instSemiringUInt64.proof_1, UInt64.instSemiringUInt64.proof_2, UInt64.mk, Semiring.nsmul, UInt64.val, UInt64.instSemiringUInt64.proof_3, UInt64.instSemiringUInt64.proof_4, UInt64.instSemiringUInt64.proof_5, UInt64.instSemiringUInt64.proof_6, UInt64.instSemiringUInt64.proof_7, UInt64.instSemiringUInt64.proof_8, UInt64.instSemiringUInt64.proof_9, UInt64.instSemiringUInt64.proof_10, UInt64.instSemiringUInt64.proof_11, UInt64.instSemiringUInt64.proof_12, UInt64.instSemiringUInt64.proof_13],[Semiring, UInt64]]
[Lean.Lsp.instToJsonDocumentSymbolParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.DocumentSymbolParams.textDocument, List.nil],[Lean.ToJson, Lean.Lsp.DocumentSymbolParams]]
[Lean.Parser.Tactic.rintro,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Elab.OpenDecl.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.OpenDecl.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.OpenDecl.State.mk, And]]
[LT.lt,[],[]]
[not_forall_of_exists_not,[False],[Not]]
[Lean.Parser.ParserExtension.OLeanEntry.noConfusionType,[],[]]
[HOrElse.hOrElse,[],[]]
[Std.RBNode.setRed,[Std.RBNode.leaf, Std.RBNode, Std.RBNode.node, Std.Rbcolor.red],[Std.RBNode]]
[set.separates_points,[Exists, And, Mem.mem, Ne],[]]
[Lean.PPContext.runCoreM,[Functor.map, Prod.fst, Lean.Core.CoreM.toIO, Lean.Core.Context.mk, Lean.PPContext.opts, Lean.PPContext.currNamespace, Lean.PPContext.openDecls, Lean.Core.State.mk, Lean.PPContext.env, Lean.NameGenerator.mk, Lean.Name.mkStr, Lean.Name.anonymous],[IO]]
[Lean.instDecidableEqDeclarationRange,[Decidable, Eq, dite, Decidable.isTrue, rfl, Decidable.isFalse],[DecidableEq, Lean.DeclarationRange]]
[Std.AssocList.mapKey,[Unit.unit, Std.AssocList, Std.AssocList.nil, Std.AssocList.cons, PProd.fst],[Std.AssocList]]
[instCommMonoid_1.proof_2,[Semiring.one_mul],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Elab.Term.LetRecView.noConfusionType,[],[]]
[Lean.Expr.lam.inj,[And.intro],[And, Eq]]
[Lean.Occurrences.all.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Occurrences.all, OfNat.ofNat]]
[RandomGen.split,[],[Prod]]
[Std.HashSet.instInhabitedHashSet,[Inhabited.mk, Std.mkHashSet, OfNat.ofNat],[Inhabited, Std.HashSet]]
[Lean.Meta.ParamInfo.noConfusionType,[],[]]
[Lean.JsonRpc.RequestID.null.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.JsonRpc.RequestID.null, OfNat.ofNat]]
[List.getLast.proof_2,[],[List.noConfusionType, False, List.cons, List.nil]]
[Lean.Elab.Term.SyntheticMVarKind.noConfusionType,[],[]]
[Lean.Meta.Match.Unify.State.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Unify.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.Unify.State.mk]]
[Lean.PrettyPrinter.Formatter.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.SynthInstance.Answer.result,[],[Lean.Meta.AbstractMVarsResult]]
[Lean.Parser.precedenceParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Parser.Parser]]
[Lean.Elab.Command.StructView.declName,[],[Lean.Name]]
[Lean.bignumFromJson?,[Bind.bind, Lean.Json.getStr?, Pure.pure, Lean.Syntax.decodeNatLitVal?, Option.none, Except, String, Nat, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Except, String, Nat]]
[Lean.IR.ExplicitRC.addInc,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Lean.IR.FnBody.inc, Lean.IR.ExplicitRC.VarInfo.persistent],[Lean.IR.FnBody]]
[Lean.mkApp8,[Lean.mkApp4],[Lean.Expr]]
[Lean.Expr.updateForallE!.proof_1,[rfl],[Eq, Lean.Expr.isForall, Lean.Expr.forallE]]
[Lean.Elab.logAt,[ite, Eq, and, BEq.beq, Lean.MessageSeverity.error, Lean.MessageData.hasSyntheticSorry, Bool.true, Pure.pure, PUnit.unit, Bind.bind, Lean.Elab.MonadLog.getRef, Lean.MonadFileMap.getFileMap, Lean.AddMessageContext.addMessageContext, Lean.Elab.MonadLog.getFileName, Lean.Elab.MonadLog.logMessage, Lean.Message.mk, Lean.FileMap.toPosition, Option.some],[Unit]]
[instMonadLiftBaseIOEIO,[MonadLift.mk, BaseIO.toEIO],[MonadLift, BaseIO, EIO]]
[Lean.Parser.Tactic.librarySearch!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Parsec.expectedEndOfInput,[],[String]]
[Lean.Declaration.opaqueDecl.inj,[],[Eq]]
[Subarray.forInUnsafe.loop,[ite, LT.lt, Bind.bind, Pure.pure, Subarray.forInUnsafe.loop, HAdd.hAdd, OfNat.ofNat],[]]
[or_of_or_of_imp_of_imp,[Or.imp],[Or]]
[Lean.Elab.mkMacroAttributeUnsafe,[Lean.Elab.mkElabAttribute, Lean.Macro, Lean.Name.mkStr, Lean.Name.anonymous],[IO, Lean.KeyedDeclsAttribute, Lean.Macro]]
[Lean.Syntax.setArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.node],[Lean.Syntax]]
[UInt8.size_positive,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt8.size]]
[Lean.Parser.tryAnti,[Id.run, ite, Eq, BEq.beq, Lean.Parser.ParserContext.quotDepth, OfNat.ofNat, Bool.true, Pure.pure, Bool.false, Bind.bind, PUnit.unit],[Bool]]
[Lean.Meta.Match.processInaccessibleAsCtor,[Bind.bind, Lean.MonadEnv.getEnv, List.nil, Lean.Meta.Match.Pattern.inaccessible, List.cons, Lean.Meta.Match.Pattern.var, Lean.Meta.Match.Pattern.ctor, Lean.Meta.Match.Pattern.val, Lean.Meta.Match.Pattern.arrayLit, Lean.Meta.Match.Pattern.as, Lean.Meta.MetaM, Option, Lean.Meta.Match.Alt, Lean.Meta.Match.Alt.patterns, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, panicWithPosWithDecl, OfNat.ofNat],[Lean.Meta.MetaM, Option, Lean.Meta.Match.Alt]]
[Lean.instToMessageDataArray,[Lean.ToMessageData.mk, Lean.ToMessageData.toMessageData, Array.toList],[Lean.ToMessageData, Array]]
[Lean.resolveGlobalConstNoOverload,[Bind.bind, Lean.resolveGlobalConst, List.nil, List.cons, Lean.Name, Pure.pure, Lean.throwErrorAt, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, HAppend.hAppend, ToString.toString, List.map, Lean.mkConst],[Lean.Name]]
[Lean.Parser.Tactic.choose,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.ReducibilityHints.opaque.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.ReducibilityHints.opaque, OfNat.ofNat]]
[Lean.LocalContext.setBinderInfo,[Lean.LocalContext.modifyLocalDecl, Lean.LocalDecl.setBinderInfo],[Lean.LocalContext]]
[UInt32.mk_val_eq,[Eq, UInt32.mk, UInt32.val, rfl],[Eq, UInt32.mk, UInt32.val]]
[Lean.Meta.Match.Example.var.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Example.var, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.Example.var]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.annotateNamedArg,[Bind.bind, liftM, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.annotateBool, Lean.Name.mkStr, Lean.Name.anonymous, modify, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.bottomUps, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.higherOrders, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.funBinders, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.provideds, Array.push, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.namedArgs],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, Unit]]
[Lean.Meta.Cases.Context.nminors,[],[Nat]]
[Lean.Parser.instInhabitedFirstTokens,[Inhabited.mk, Lean.Parser.FirstTokens.epsilon],[Inhabited, Lean.Parser.FirstTokens]]
[Lean.Declaration.mutualDefnDecl.injEq,[Eq.propIntro, Eq.refl, Lean.Declaration.mutualDefnDecl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Declaration.mutualDefnDecl]]
[Lean.Elab.Tactic.evalGeneralize,[Lean.Elab.Tactic.withMainContext, Bind.bind, Array.mapM, Lean.Elab.Tactic.elabTerm, Lean.Syntax.getOp, OfNat.ofNat, Option.none, Bool.false, Pure.pure, Lean.Meta.GeneralizeArg.mk, Option.some, Lean.Syntax.getId, Lean.Syntax.getSepArgs, Lean.Elab.Tactic.liftMetaTactic, Lean.Meta.generalize, Lean.Meta.MetaM, List, Lean.MVarId, List.cons, List.nil],[Lean.Elab.Tactic.Tactic]]
[Lean.Lsp.SemanticTokensRangeParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.SemanticTokensRangeParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.elabMatch.elabMatchDefault,[Bind.bind, ite, Eq, Lean.Syntax.isNone, Bool.true, Array.allM, Functor.map, Option.isSome, Lean.Elab.Term.isAtomicDiscr?, Lean.Syntax.getOp, OfNat.ofNat, Array.size, Pure.pure, Option.none, Array.toList, List.toArray, List.nil, EmptyCollection.emptyCollection, Option.some, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Syntax, Lean.Syntax.setArg, Lean.Expr.isFVar, PProd.fst, Array.push, Std.RBTree.insert, Lean.Expr.fvarId!, Lean.Expr, Lean.Elab.Term.withMacroExpansion, Lean.Elab.Term.elabTerm, and, not, Array.any, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, PUnit.unit],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[IO.Process.Output.mk.inj,[And.intro],[And, Eq]]
[Std.PersistentHashMap.Stats.numNull,[],[Nat]]
[Lean.Meta.Cache.inferType,[],[Lean.Meta.InferTypeCache]]
[Nat.gcd_pos_of_pos_left,[Nat.pos_of_dvd_of_pos, Nat.gcd_dvd_left],[LT.lt, OfNat.ofNat, Nat.gcd]]
[«term_∧_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Elab.DefKind.theorem.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.DefKind.theorem, OfNat.ofNat]]
[Lean.Lsp.InitializeParams.workspaceFolders?,[],[Option, Array, Lean.Lsp.WorkspaceFolder]]
[Lean.Meta.instInhabitedConstantInfo,[Inhabited.mk, Lean.ConstantInfo.axiomInfo, arbitrary],[Inhabited, Lean.ConstantInfo]]
[Lean.Meta.SimpLemma.mk.inj,[And.intro],[And, Eq]]
[id_map',[LawfulFunctor.id_map],[Eq, Functor.map]]
[Lean.Meta.DefEqContext.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.instReduceEvalNat,[Lean.Meta.ReduceEval.mk, Bind.bind, Lean.Meta.whnf, Lean.Meta.evalNat, Option.none, Lean.Meta.MetaM, Nat, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr],[Lean.Meta.ReduceEval, Nat]]
[List.head,[absurd, Eq.refl, List.nil],[]]
[UInt32.decLt,[Decidable, LT.lt, inferInstanceAs],[Decidable, LT.lt]]
[Lean.ClassState.addEntry,[Lean.ClassState.mk, Lean.SMap.insert, Lean.ClassState.hasOutParam, Lean.ClassEntry.name, Lean.ClassEntry.hasOutParam],[Lean.ClassState]]
[OrElse.noConfusionType,[],[]]
[Lean.IR.ExpandResetReuse.Context.projMap,[],[Lean.IR.ExpandResetReuse.ProjMap]]
[IO.Error.resourceExhausted.inj,[And.intro],[And, Eq]]
[Nat.ibelow,[True, And],[]]
[Lean.MetavarContext.abstractRange,[Lean.MetavarContext.MkBinding.abstractRange, Bool.false],[Lean.MetavarContext.MkBindingM, Lean.Expr]]
[max_eq_left_of_lt,[max_eq_left, le_of_lt],[Eq, max]]
[Lean.Elab.Term.ElabAppArgs.State.namedArgs,[],[List, Lean.Elab.Term.NamedArg]]
[Lean.Parser.Term.paren.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ppDedent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withoutPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withoutForbidden.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.Term.parenSpecial.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Std.PersistentArrayNode.leaf.inj,[],[Eq]]
[Lean.Meta.Match.instInhabitedMatchEqns,[Inhabited.mk, Lean.Meta.Match.MatchEqns.mk, arbitrary],[Inhabited, Lean.Meta.Match.MatchEqns]]
[Lean.Parser.Command.namespace,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident],[Lean.Parser.Parser]]
[Lean.Elab.Term.expandWhereDeclsOpt,[ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, Lean.Elab.Term.expandWhereDecls, Lean.Syntax.getOp, OfNat.ofNat],[Lean.MacroM, Lean.Syntax]]
[Lean.Parser.Term.doIf.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.doIfCond.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer, Lean.Parser.many.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGe.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.Term.elseIf.parenthesizer, Lean.Parser.optional.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[IO.Process.SpawnArgs.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Process.SpawnArgs.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.AttributeExtensionOLeanEntry.noConfusionType,[],[]]
[Lean.Meta.CongrArgKind.noConfusionType,[noConfusionTypeEnum, Lean.Meta.CongrArgKind.toCtorIdx],[]]
[Std.Format.tag.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.Format.tag, HAdd.hAdd, OfNat.ofNat]]
[Lean.Syntax.instToStringSyntax,[ToString.mk, Function.comp, ToString.toString, Std.ToFormat.format],[ToString, Lean.Syntax]]
[Lean.Server.Watchdog.WorkerEvent.ioError.injEq,[Eq.propIntro, Eq.refl, Lean.Server.Watchdog.WorkerEvent.ioError, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.Watchdog.WorkerEvent.ioError]]
[Lean.SSet.instInhabitedSSet,[inferInstanceAs, Inhabited, Lean.SMap, Unit],[Inhabited, Lean.SSet]]
[Lean.Rat.instDecidableLt,[inferInstanceAs, Decidable, Eq, Lean.Rat.lt, Bool.true],[Decidable, LT.lt]]
[Int.sub_eq_add_neg,[rfl],[Eq, HSub.hSub, HAdd.hAdd, Neg.neg]]
[Tactic.Ring.RingM.run,[Bind.bind, Lean.Meta.getLevel, Lean.Level.zero, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Meta.MetaM, Lean.Meta.synthInstance, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil, Option.none, StateRefT'.run', Tactic.Ring.Cache.mk, Tactic.Ring.State.mk, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM]]
[Array.ext',[Eq.symm, eq_of_heq, Eq.refl, Array.data, Array.mk, HEq.refl, Eq, rfl],[Eq]]
[Lean.PrettyPrinter.Parenthesizer.scientificLit.parenthesizer,[Lean.Parser.Term.scientific.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Std.mkRBMap.proof_1,[Std.RBNode.WellFormed.leafWff],[Std.RBNode.WellFormed, Std.RBNode.leaf]]
[Lean.Meta.Simp.Result.expr,[],[Lean.Expr]]
[Lean.IR.instToStringVarId,[ToString.mk, HAppend.hAppend, ToString.toString, Lean.IR.VarId.idx],[ToString, Lean.IR.VarId]]
[Lean.Import.noConfusionType,[],[]]
[Lean.IR.Checker.checkScalarVar,[Lean.IR.Checker.checkVarType, Lean.IR.IRType.isScalar],[Lean.IR.Checker.M, Unit]]
[Decidable.not_imp,[Iff.intro, And.intro, Decidable.of_not_imp, not_of_not_imp, not_imp_of_and_not],[Iff, Not, And]]
[Lean.Meta.getZetaFVarIds,[Bind.bind, MonadState.get, Pure.pure, Lean.Meta.State.zetaFVarIds],[Lean.Meta.MetaM, Lean.FVarIdSet]]
[Lean.PrettyPrinter.Delaborator.Context.currNamespace,[],[Lean.Name]]
[Lean.Meta.UnificationConstraint.mk.inj,[And.intro],[And, Eq]]
[List.mem_filter,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, propext, List.mem_filterAux, List.nil, Or, And, Mem.mem, Eq, Bool.true, List.mem_nil_iff, or_false, iff_self],[Iff, Mem.mem, List.filter, And, Eq, Bool.true]]
[Lean.Meta.IndPredBelow.Variables.innerType,[],[Lean.Expr]]
[instCoeNatInt,[Coe.mk, Int.ofNat],[Coe, Nat, Int]]
[Lean.IR.EmitC.emitPartialApp,[Bind.bind, Lean.IR.EmitC.getDecl, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitCName, Array.size, Lean.IR.EmitC.emitLn, Nat.forM, Lean.IR.EmitC.emitArg],[Lean.IR.EmitC.M, Unit]]
[Nat.succ_ne_self,[False, absurd, Nat.succ_ne_zero, OfNat.ofNat, PProd.fst, id],[Ne, Nat.succ]]
[instDecidableEqQuotient.proof_1,[instSubsingletonDecidable, Eq, Quotient.mk],[Subsingleton, Decidable, Eq, Quotient.mk]]
[Lean.Elab.Term.elabApp,[Lean.Elab.Term.withoutPostponingUniverseConstraints, Bind.bind, Lean.Elab.Term.expandApp, Bool.false, Lean.Elab.Term.TermElabM, Lean.Expr, List.nil, List.toArray, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Pure.pure, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError],[Lean.Elab.Term.TermElab]]
[Lean.Parser.Tactic.Conv.for,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.const, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Ordering.lt.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Ordering.lt, OfNat.ofNat]]
[Lean.getConstInfo,[Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.ConstantInfo, Lean.Environment.find?, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkConst, List.nil],[Lean.ConstantInfo]]
[Lean.Elab.addAndCompileUnsafe,[Lean.withRef, Lean.Elab.PreDefinition.ref, Array.getOp, OfNat.ofNat, Bind.bind, Lean.addDecl, Lean.Elab.withSaveInfoContext, ForIn.forIn, PUnit.unit, Lean.mkConstWithLevelParams, Lean.Elab.PreDefinition.declName, Lean.Elab.Term.addTermInfo, Option.none, Lean.Name.anonymous, Bool.true, Pure.pure, ForInStep.yield, Lean.Elab.applyAttributesOf, Lean.AttributeApplicationTime.afterTypeChecking, MonadExcept.tryCatch, Lean.compileDecl, DoResultPR.pure, MonadReader.read, ite, Eq, Lean.Elab.Term.Context.isNoncomputableSection, DoResultPR.return, Bool.false, MonadExcept.throw, Lean.Elab.Term.TermElabM, Bool, Unit.unit],[Lean.Elab.Term.TermElabM, Unit]]
[List.cons.injEq,[Eq.propIntro, And.intro, Eq.refl, List.cons, Eq.symm, eq_of_heq, HEq.refl],[Eq, List.cons, And]]
[Lean.Elab.Tactic.Conv.evalNestedConv,[Lean.Elab.Tactic.Conv.evalConvSeqBracketed, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Elab.Tactic.Tactic]]
[Lean.Parser.Tactic.applyRules,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.ParserDescr.parser, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Nat.gt_of_not_le,[GT.gt, Nat.lt_or_ge, absurd],[GT.gt]]
[Lean.Server.FileWorker.CancelToken.check,[Bind.bind, ST.Ref.get, Lean.Server.FileWorker.CancelToken.ref, ite, Eq, Bool.true, MonadExcept.throw, Lean.Server.FileWorker.ElabTaskError.aborted, Pure.pure, PUnit.unit],[Unit]]
[Lean.Elab.Tactic.evalRewriteSeq,[Bind.bind, liftM, Lean.Elab.Tactic.elabRewriteConfig, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.withRWRulesSeq, Lean.Elab.Tactic.withLocation, Lean.Elab.Tactic.rewriteLocalDecl, Lean.Elab.Tactic.rewriteTarget, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing],[Lean.Elab.Tactic.Tactic]]
[Lean.IR.EmitC.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.EmitC.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.EmitC.Context.mk, And]]
[Lean.Meta.Simp.instBEqConfig,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Meta.Simp.Config]]
[Lean.Parser.Term.haveDecl.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.haveIdDecl.parenthesizer, Lean.Parser.Term.letPatDecl.parenthesizer, Lean.Parser.Term.haveEqnsDecl.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.IRType.isIrrelevant,[Lean.IR.IRType.float, Lean.IR.IRType.uint8, Lean.IR.IRType.uint16, Lean.IR.IRType.uint32, Lean.IR.IRType.uint64, Lean.IR.IRType.usize, Unit.unit, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.struct, Lean.IR.IRType.union, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Parser.mkAntiquotSplice.formatter,[Lean.Parser.leadingNode.formatter, Lean.Parser.maxPrec, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.setExpected.formatter, List.nil, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.manyNoAntiquot.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.PrettyPrinter.Formatter.node.formatter, Lean.nullKind],[Lean.PrettyPrinter.Formatter]]
[Lean.Syntax.Traverser.down,[ite, LT.lt, Lean.Syntax.getNumArgs, Lean.Syntax.Traverser.cur, Lean.Syntax.Traverser.mk, Lean.Syntax.getArg, Array.push, Lean.Syntax.Traverser.parents, Lean.Syntax.setArg, arbitrary, Lean.Syntax.Traverser.idxs, Lean.Syntax.missing],[Lean.Syntax.Traverser]]
[Lean.Elab.Deriving.DecEq.mkDecEqInstanceHandler,[ite, Eq, bne, Array.size, OfNat.ofNat, Bool.true, Pure.pure, Bool.false, Bind.bind, Lean.isEnumType, Array.getOp, Lean.Elab.Deriving.DecEq.mkDecEqEnum, Lean.Elab.Deriving.DecEq.mkDecEq],[Lean.Elab.Command.CommandElabM, Bool]]
[Nat.zero_eq,[rfl],[Eq, Nat.zero, OfNat.ofNat]]
[Lean.Meta.mkHEqRefl,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getLevel, Pure.pure, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Elab.Term.throwMVarError,[Bind.bind, MonadState.get, ite, Eq, Lean.MessageLog.hasErrors, Lean.Elab.Term.State.messages, Bool.true, Lean.Elab.throwAbortTerm, Lean.throwError],[Lean.Elab.Term.TermElabM]]
[List.reverse_cons,[Eq.mpr, Eq.refl, Eq, List.reverseAux, List.cons, List.nil, HAppend.hAppend, Eq.symm, List.reverseAux_eq_append, rfl],[Eq, List.reverse, List.cons, HAppend.hAppend, List.nil]]
[Lean.Meta.IndPredBelow.Variables.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.IndPredBelow.Variables.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.IndPredBelow.Variables.mk, And]]
[Fin.isLt,[],[LT.lt, Fin.val]]
[Array.mapMUnsafe,[unsafeCast, OfNat.ofNat, Array.mapMUnsafe.map],[Array]]
[Lean.Expr.updateFn,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateApp!, PProd.fst],[Lean.Expr]]
[Lean.Elab.Visibility.noConfusion,[noConfusionEnum, Lean.Elab.Visibility.toCtorIdx],[Lean.Elab.Visibility.noConfusionType]]
[Lean.PrettyPrinter.Parenthesizer.addPrecCheck,[modify, Lean.PrettyPrinter.Parenthesizer.State.mk, Lean.PrettyPrinter.Parenthesizer.State.stxTrav, Option.some, Nat.min, Option.getD, Lean.PrettyPrinter.Parenthesizer.State.contPrec, Lean.PrettyPrinter.Parenthesizer.State.contCat, Lean.PrettyPrinter.Parenthesizer.State.minPrec, Lean.PrettyPrinter.Parenthesizer.State.trailPrec, Lean.PrettyPrinter.Parenthesizer.State.trailCat, Lean.PrettyPrinter.Parenthesizer.State.visitedToken],[Lean.PrettyPrinter.ParenthesizerM, Unit]]
[Lean.Meta.mkEqFalse,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[of_decide_eq_false,[Not, absurd, ne_false_of_eq_true, decide_eq_true],[Not]]
[Lean.IR.ExplicitRC.VarInfo.noConfusionType,[],[]]
[instInhabitedProd,[Inhabited.mk, Prod.mk, arbitrary],[Inhabited, Prod]]
[Lean.Syntax.MonadTraverser.setCur,[modify, Lean.Syntax.Traverser.setCur],[Unit]]
[String.instInhabitedRange,[Inhabited.mk, String.Range.mk, arbitrary],[Inhabited, String.Range]]
[Lean.getBuiltinInitFnNameFor?,[Lean.getInitFnNameForCore?, Lean.builtinInitAttr],[Option, Lean.Name]]
[Tactic.Ring.HornerExpr.isZero,[Tactic.Ring.HornerExpr.xadd, Bool, Decidable.decide, Eq, OfNat.ofNat, Bool.false],[Bool]]
[add_left_inj,[Iff.intro, add_right_cancel, rfl],[Iff, Eq, HAdd.hAdd]]
[Subtype.mk.inj,[],[Eq]]
[Lean.binductionOnSuffix,[],[String]]
[Lean.Meta.reduceUnaryNatOp,[Lean.Meta.withNatValue, Pure.pure, Option.some, Lean.mkRawNatLit],[Lean.Meta.MetaM, Option, Lean.Expr]]
[Lean.Lsp.MarkupContent.mk.inj,[And.intro],[And, Eq]]
[Lean.getReducibilityStatus,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.getReducibilityStatusImp],[Lean.ReducibilityStatus]]
[Pow.pow,[],[]]
[instDecidableEq.proof_1,[Iff.rfl],[False]]
[Lean.Elab.DerivingClassView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.DerivingClassView.mk, HAdd.hAdd, OfNat.ofNat]]
[List.remove_eq_of_not_mem,[Eq, List.remove, of_eq_true, eq_self, List.nil],[Eq, List.remove]]
[Lean.IR.AlphaEqv.aeqv,[],[Bool]]
[Lean.Parser.SyntaxNodeKindSet,[Std.PersistentHashMap, Lean.SyntaxNodeKind, Unit],[]]
[Lean.MetavarDecl.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.attrInstance.parenthesizer,[Lean.Parser.ppGroup.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.attrParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.LOption.some.injEq,[Eq.propIntro, Eq.refl, Lean.LOption.some, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.LOption.some]]
[Lean.Compiler.SpecEntry.info.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Compiler.SpecEntry.info, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Compiler.SpecEntry.info, And]]
[Lean.Parser.withoutForbidden,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.Parser.fn, Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.prec, Lean.Parser.ParserContext.tokens, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Parser.ParserContext.savedPos?, Option.none],[Lean.Parser.Parser]]
[List.subset.refl,[],[Subset.subset]]
[fixCore6,[bfix6, USize.size],[]]
[Lean.Meta.NormNum.LawfulOfNat.isNat_ofNat,[],[Lean.Meta.NormNum.isNat, OfNat.ofNat]]
[Subarray.h₂,[],[LE.le, Subarray.stop, Array.size, Subarray.as]]
[Std.RBNode.revFold,[PProd.fst, PProd.snd],[]]
[Array.ext,[congrArg, Array.mk, Eq.symm, Eq.refl, Array.ext.extAux],[Eq]]
[Nat.not_le_of_not_ble_eq_true,[absurd, Nat.ble_eq_true_of_le],[Not, LE.le]]
[Lean.BinderInfo.instImplicit.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.BinderInfo.instImplicit, OfNat.ofNat]]
[Lean.Server.Watchdog.GroupedEdits.signalTask,[],[Task, Lean.Server.Watchdog.WorkerEvent]]
[Lean.LeanPaths.mk.inj,[And.intro],[And, Eq]]
[Lean.Widget.instInhabitedMsgEmbed,[Inhabited.mk, Lean.Widget.MsgEmbed.expr, arbitrary],[Inhabited, Lean.Widget.MsgEmbed]]
[Lean.instInhabitedStructureDescr,[Inhabited.mk, Lean.StructureDescr.mk, arbitrary],[Inhabited, Lean.StructureDescr]]
[false_implies,[propext, Iff.intro, trivial, absurd, of_decide_eq_false, Eq.refl, Decidable.decide, False],[Eq, True]]
[Lean.Elab.TermInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Tactic.ensureHasNoMVars,[Bind.bind, liftM, Lean.Meta.instantiateMVars, Lean.Meta.getMVars, Functor.discard, Lean.Elab.Term.logUnassignedUsingErrorInfos, Option.none, ite, Eq, Lean.Expr.hasExprMVar, Bool.true, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Pure.pure, PUnit.unit],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.Declaration.inductDecl.inj,[And.intro],[And, Eq]]
[not_iff_false_intro,[iff_false_intro, not_not_intro],[Iff, Not, False]]
[StateRefT'.instMonadStateRefT',[inferInstanceAs, Monad, ReaderT, ST.Ref],[Monad, StateRefT']]
[Lean.Parser.Command.catBehaviorBoth.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.nonReservedSymbol.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.StructInst.FieldVal.noConfusionType,[],[]]
[Lean.Meta.ppExpr,[Bind.bind, readThe, Lean.Core.Context, Lean.MonadEnv.getEnv, Lean.MonadMCtx.getMCtx, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, liftM, Lean.ppExpr, Lean.PPContext.mk, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls],[Lean.Meta.MetaM, Std.Format]]
[Lean.Parser.Command.constant.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.Command.declSig.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.declValSimple.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Group.toDivInvMonoid,[],[DivInvMonoid]]
[Lean.Expr.isHEq,[Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat],[Bool]]
[Std.PersistentArray.tooBig,[HDiv.hDiv, USize.size, OfNat.ofNat],[Nat]]
[Lean.Elab.Command.elabSection,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Unit.unit, Lean.Name.num, Lean.Elab.Command.CommandElabM, Unit, Pure.pure, Bind.bind, PProd.fst, Lean.MonadResolveName.getCurrNamespace, modify, Lean.Elab.Command.State.mk, Lean.Environment.registerNamespace, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, List.cons, Lean.Elab.Command.Scope.mk, Lean.Elab.Command.Scope.opts, Lean.Elab.Command.Scope.openDecls, Lean.Elab.Command.Scope.levelNames, Lean.Elab.Command.Scope.varDecls, Lean.Elab.Command.Scope.varUIds, or, Lean.Elab.Command.Scope.isNoncomputable, List.head!, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Lean.pushScope, Lean.activateScoped, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData, Bool.false, Lean.Syntax.getId, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Lean.Parser.Tactic.normNum1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Nat.ofNat_eq_Nat,[rfl],[Eq, Numeric.ofNat]]
[Lean.ParserCompiler.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.ExplicitBoxing.BoxingState.nextIdx,[],[Lean.IR.Index]]
[Lean.Meta.findCore.check,[ite, Eq, or, Lean.Meta.FindOptions.checkPrivate, not, Lean.isPrivateName, Bool.true, Bind.bind, Pure.pure, Array.push],[Lean.Meta.MetaM, Array, Lean.ConstantInfo]]
[Lean.Meta.CongrArgKind.noConfusion,[noConfusionEnum, Lean.Meta.CongrArgKind.toCtorIdx],[Lean.Meta.CongrArgKind.noConfusionType]]
[Lean.Meta.GetEqnsFn,[Lean.Meta.MetaM, Option, Array, Lean.Name],[]]
[Lean.Parser.Tactic.applyAssumption,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Elab.Command.Context.currRecDepth,[],[Nat]]
[Lean.Elab.Tactic.evalMatch,[Bind.bind, Lean.Elab.Tactic.getMainTag, Lean.Elab.liftMacroM, StateT.run, Array.mapM, Pure.pure, Lean.Elab.Tactic.AuxMatchTermState.mk, Lean.MacroM, Prod, Lean.Syntax, Array, Prod.mk, Lean.Elab.Tactic.AuxMatchTermState.cases, Lean.Elab.Tactic.TacticM, Unit, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Elab.Tactic.withMacroExpansion, Lean.Elab.Tactic.evalTactic],[Lean.Elab.Tactic.Tactic]]
[Lean.Meta.Match.Example.ctor.inj,[And.intro],[And, Eq]]
[Quot.inductionOn,[Quot.ind],[]]
[Nat.log2.proof_1,[],[WellFounded]]
[mul_right_comm,[Eq.mpr, Eq.refl, Eq, HMul.hMul, mul_assoc, mul_comm, rfl],[Eq, HMul.hMul]]
[String.drop,[Substring.toString, Substring.drop, String.toSubstring],[String]]
[Lean.MetavarContext.findLevelDepth?,[Std.PersistentHashMap.find?, Lean.MetavarContext.lDepth],[Option, Nat]]
[Lean.IR.logDecls,[Bind.bind, MonadReader.read, ite, Eq, Option.none, Option.some, Lean.DataValue.ofString, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Bool, Lean.KVMap.find, Lean.KVMap.getBool, Lean.IR.tracePrefixOptionName, Bool.false, Bool.true, Lean.IR.log, Lean.IR.LogEntry.step, Pure.pure, PUnit.unit, HAppend.hAppend],[Lean.IR.CompilerM, Unit]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PrettyPrinter.Delaborator.AppMatchState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.StructInst.expandStructInstExpectedType,[ite, Eq, Lean.Syntax.isNone, Bool.true, Lean.Macro.throwUnsupported, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.Macro]]
[Lean.IR.ExpandResetReuse.expand,[Lean.IR.ExpandResetReuse.M, Lean.IR.FnBody, Bind.bind, Lean.IR.ExpandResetReuse.mkFastPath, List.toArray, List.nil, Lean.IR.ExpandResetReuse.mkFresh, Pure.pure, Lean.IR.reshape],[Lean.IR.ExpandResetReuse.M, Lean.IR.FnBody]]
[Lean.Elab.Term.Quotation.withNewLocals,[MonadWithReader.withReader, Lean.Elab.Term.Quotation.Precheck.Context.mk, Array.foldl, Lean.NameSet.insert, Lean.Elab.Term.Quotation.Precheck.Context.quotLCtx, OfNat.ofNat, Array.size],[Lean.Elab.Term.Quotation.PrecheckM]]
[Lean.Expr.inferImplicit,[dite, Eq, Lean.Expr.bvar, Eq.symm, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.mkForall],[Lean.Expr]]
[Lean.Elab.Deriving.mkImplicitBinders,[Array.mapM, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Lean.mkIdent, List.nil],[Lean.Elab.Term.TermElabM, Array, Lean.Syntax]]
[USize.decEq.proof_1,[rfl],[Eq, USize.mk]]
[Lean.Compiler.foldBinUInt,[OptionM.run, Bind.bind, Lean.Compiler.getNumLit, Lean.Compiler.getInfoFromVal, Pure.pure, Lean.Compiler.mkUIntLit],[Option, Lean.Expr]]
[Lean.Meta.GeneralizeTelescope.Entry.mk.inj,[And.intro],[And, Eq]]
[Lean.Server.FileWorker.RefIdent.const.injEq,[Eq.propIntro, Eq.refl, Lean.Server.FileWorker.RefIdent.const, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.FileWorker.RefIdent.const]]
[Lean.Server.FileWorker.instInhabitedCancelToken,[Inhabited.mk, Lean.Server.FileWorker.CancelToken.mk, arbitrary],[Inhabited, Lean.Server.FileWorker.CancelToken]]
[Lean.Parser.Tactic.transport,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Meta.getConstNoEx?,[Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.Meta.MetaM, Option, Lean.ConstantInfo, Lean.Environment.find?, Lean.Meta.getTheoremInfo, MonadReader.read, Lean.Meta.TransparencyMode.reducible, Lean.Meta.TransparencyMode.instances, Lean.Meta.Config.transparency, Lean.Meta.Context.config, Pure.pure, Option.some, Lean.isReducible, Lean.ConstantInfo.name, ite, Eq, Bool.true, and, BEq.beq, Lean.Meta.isGlobalInstance, Option.none],[Lean.Meta.MetaM, Option, Lean.ConstantInfo]]
[Lean.Name.mkStr,[Lean.Name.str, mixHash, Hashable.hash],[Lean.Name]]
[UInt32.shiftRight,[UInt32.mk, HShiftRight.hShiftRight, UInt32.val, UInt32.modn, OfNat.ofNat],[UInt32]]
[Lean.Meta.Config.ctxApprox,[],[Bool]]
[Lean.Parser.priorityParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.Match.Pattern.ctor.inj,[And.intro],[And, Eq]]
[List.forIn_cons,[rfl],[Eq, ForIn.forIn, List.cons, Bind.bind, Pure.pure]]
[Lean.Elab.Term.LetRecView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.LetRecView.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.AbstractNestedProofs.Context.noConfusionType,[],[]]
[Lean.Lsp.Range.noConfusionType,[],[]]
[System.FilePath.mk.inj,[],[Eq]]
[Lean.Declaration.noConfusionType,[],[]]
[let_eq,[],[Eq]]
[Std.RBNode.all,[Unit.unit, Bool, Bool.true, and, PProd.fst, PProd.snd],[Bool]]
[Lean.Meta.IndPredBelow.mkCtorType.addMotives,[Bind.bind, Array.mapM, Lean.Meta.MetaM, Prod, Lean.Name, Lean.BinderInfo, Lean.Expr, Pure.pure, Prod.mk, Lean.BinderInfo.implicit, Lean.Meta.instantiateForall, Lean.Meta.IndPredBelow.Variables.params, Lean.Meta.IndPredBelow.Context.motives, Lean.Meta.withLocalDecls, Lean.Meta.IndPredBelow.mkCtorType.modifyBinders, Lean.Meta.IndPredBelow.Variables.mk, HAppend.hAppend, Lean.Meta.IndPredBelow.Variables.target, Lean.Meta.IndPredBelow.Variables.indVal, Lean.Meta.IndPredBelow.Variables.args, Lean.Meta.IndPredBelow.Variables.innerType, OfNat.ofNat],[Lean.Meta.MetaM, Lean.Expr]]
[add_right_inj,[Iff.intro, add_left_cancel, congrArg, HAdd.hAdd],[Iff, Eq, HAdd.hAdd]]
[Lean.EnvExtensionInterface.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.EnvExtensionInterface.mk, OfNat.ofNat]]
[USize.instInhabitedFinSize,[Inhabited.mk, Fin.ofNat', OfNat.ofNat, USize.size_positive],[Inhabited, Fin, USize.size]]
[reprStr,[Std.Format.pretty, Repr.reprPrec, OfNat.ofNat, Std.Format.defWidth],[String]]
[Nat.add_div_left,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HAdd.hAdd, Nat.succ, Nat.add_comm, Nat.add_div_right, rfl],[Eq, HDiv.hDiv, HAdd.hAdd, Nat.succ]]
[Lean.Parser.Tactic.Conv.reduce,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Meta.isClass?,[MonadExcept.tryCatch, Bind.bind, Unit.unit, Lean.Meta.MetaM, Option, Lean.Name, Pure.pure, Option.none, Option.some],[Lean.Meta.MetaM, Option, Lean.Name]]
[Lean.Expr.ReplaceLevelImpl.replaceUnsafe,[StateT.run', Lean.Expr.ReplaceLevelImpl.replaceUnsafeM, Lean.Expr.ReplaceLevelImpl.cacheSize, Lean.Expr.ReplaceLevelImpl.initCache],[Lean.Expr]]
[Nat.case_strong_induction_on,[Nat.strong_induction_on, Unit.unit, Nat.lt_succ_of_le],[]]
[Lean.Elab.Term.MutualClosure.FixPoint.State.noConfusionType,[],[]]
[Lean.Parser.Term.instBinder,[Lean.Parser.ppGroup, Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.optIdent, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.Elab.CompletionInfo.tactic.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.CompletionInfo.tactic, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Parser.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.CtorFieldInfo.usize.injEq,[Eq.propIntro, Eq.refl, Lean.IR.CtorFieldInfo.usize, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.CtorFieldInfo.usize]]
[Lean.instFromJsonArray,[Lean.FromJson.mk, Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Lean.Json.obj, Except, String, Array, Array.mapM, Lean.FromJson.fromJson?, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.FromJson, Array]]
[Lean.Server.FileWorker.parseParams,[Lean.Server.FileWorker.WorkerM, Lean.FromJson.fromJson?, Pure.pure, liftM, IO.throwServerError, HAppend.hAppend, ToString.toString, Lean.Json.compress],[Lean.Server.FileWorker.WorkerM]]
[decidableEq_of_decidableLe,[Decidable, Eq, dite, LE.le, Decidable.isTrue, le_antisymm, Decidable.isFalse, decidableEq_of_decidableLe.proof_1, decidableEq_of_decidableLe.proof_2],[DecidableEq]]
[instLEFin,[LE.mk, LE.le, Fin.val],[LE, Fin]]
[Lean.Parser.Term.bracketedBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.none, Bool.false, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.explicitBinder.parenthesizer, Lean.Parser.Term.strictImplicitBinder.parenthesizer, Lean.Parser.Term.implicitBinder.parenthesizer, Lean.Parser.Term.instBinder.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.mkIdentFrom,[Lean.Syntax.ident, Lean.SourceInfo.fromRef, String.toSubstring, ToString.toString, List.nil],[Lean.Syntax]]
[Lean.Parser.Command.structInstBinder,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.Command.declModifiers, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.Command.inferMod, Lean.Parser.Command.declSig],[Lean.Parser.Parser]]
[Lean.Parser.Tactic.anyGoals,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Parser.Tactic.Conv.convLeft,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Elab.Tactic.ElimApp.State.mk.inj,[And.intro],[And, Eq]]
[compareOfLessAndEq,[ite, LT.lt, Ordering.lt, Eq, Ordering.eq, Ordering.gt],[Ordering]]
[Lean.Lsp.TextDocumentSyncOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.TextDocumentSyncOptions.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.mkCategoryParenthesizerAttribute,[Lean.KeyedDeclsAttribute.init, Lean.KeyedDeclsAttribute.Def.mk, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.MonadEnv.getEnv, Lean.Attribute.Builtin.getId, ite, Eq, Lean.Parser.isParserCategory, Bool.true, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, ToString.toString],[IO, Lean.KeyedDeclsAttribute, Lean.PrettyPrinter.CategoryParenthesizer]]
[term!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.mkInaccessible,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Expr]]
[Lean.Server.FileWorker.handleDocumentSymbol,[Bind.bind, Lean.Server.RequestM.readDoc, Lean.Server.RequestM.asTask, liftM, IO.AsyncList.updateFinishedPrefix, Lean.Server.FileWorker.EditableDocument.cmdSnaps, Lean.Server.RequestM, Lean.Lsp.DocumentSymbolResult, Option.none, Unit.unit, Option.some, Lean.Server.FileWorker.ElabTaskError.eof, MonadExcept.throw, Lean.Server.RequestError.fileChanged, Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.internalError, ToString.toString, Pure.pure, Lean.Server.FileWorker.handleDocumentSymbol.toDocumentSymbols, Lean.Server.FileWorker.handleDocumentSymbol.sectionLikeToDocumentSymbols],[Lean.Server.RequestM, Lean.Server.RequestTask, Lean.Lsp.DocumentSymbolResult]]
[Lean.Parser.Tactic.toExpr',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Std.RBNode.isRed,[Std.RBNode.leaf, Std.RBNode.node, Std.Rbcolor.black, Bool, Bool.true, Bool.false],[Bool]]
[Lean.IR.FnBody.uset.inj,[And.intro],[And, Eq]]
[Function.extend_apply,[Eq.mpr, congrFun, congrArg, Eq, Eq.trans, Function.extend_def, dite_congr, eq_true, exists_apply_eq_apply, Eq.refl, Classical.choose, Eq.mpr_prop, dif_pos, of_eq_true, True, congr_arg, Classical.choose_spec],[Eq, Function.extend]]
[Std.Range.«term[_:_:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.LocalDecl.userName,[Lean.Name],[Lean.Name]]
[String.intercalate.go,[Unit.unit, String, PProd.fst, HAppend.hAppend],[String]]
[Lean.Parser.categoryParser,[Lean.Parser.Parser.mk, Lean.Parser.categoryParserFn, Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.tokens, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Parser.ParserContext.savedPos?, Lean.Parser.ParserContext.forbiddenTk?],[Lean.Parser.Parser]]
[Lean.PrettyPrinter.Parenthesizer.instCoeArrowParenthesizerParenthesizerParenthesizerAliasValue,[Coe.mk, Lean.Parser.AliasValue.unary],[Coe, Lean.PrettyPrinter.Parenthesizer, Lean.PrettyPrinter.Parenthesizer.ParenthesizerAliasValue]]
[List.card_le_card_cons,[Decidable.em, Mem.mem, of_eq_true, Eq.trans, congrArg, LE.le, List.card, List.card_cons_of_mem, eq_true, Nat.le_refl, Eq.symm, List.card_cons_of_not_mem, Not, eq_false, eq_true_of_decide, Eq.refl, Bool.true, Nat.le_succ],[LE.le, List.card, List.cons]]
[Semiring.mul_zero,[],[Eq, HMul.hMul, OfNat.ofNat]]
[EStateM.get,[EStateM.Result.ok],[EStateM]]
[IO.Error.otherError.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.otherError, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.otherError, And]]
[Lean.Lsp.instToJsonPlainGoalParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.PlainGoalParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position],[Lean.ToJson, Lean.Lsp.PlainGoalParams]]
[Lean.Meta.ByCasesSubgoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.ByCasesSubgoal.mk, HAdd.hAdd, OfNat.ofNat]]
[eq_rec_heq,[eqRec_heq],[HEq]]
[Function.update_same,[dif_pos, rfl],[Eq, Function.update]]
[Lean.MonadOptions.noConfusionType,[],[]]
[String.front,[String.get, OfNat.ofNat],[Char]]
[Lean.Parser.Tactic.clearAuxDecl,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[instSubsingleton.proof_1,[Subsingleton.intro, proofIrrel],[Subsingleton]]
[Lean.Parser.Tactic.dsimpResult,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Nat.find_x.proof_3,[absurd, Nat.not_lt_zero],[Not]]
[Lean.Elab.Tactic.evalAllGoals,[Bind.bind, Lean.Elab.Tactic.getGoals, ForIn.forIn, liftM, Lean.Meta.isExprMVarAssigned, ite, Eq, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Elab.Tactic.setGoals, List.cons, List.nil, MonadExcept.tryCatch, Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.getUnsolvedGoals, MProd.mk, Lean.Elab.logException, MProd.fst, Array.toList],[Lean.Elab.Tactic.Tactic]]
[coeDecidableEq,[inferInstanceAs, Decidable, Eq, Bool.true],[Decidable, coe]]
[Lean.Expr.hasLooseBVarInExplicitDomain,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, or, and, Lean.BinderInfo.isExplicit, Lean.Expr.Data.binderInfo, Lean.Expr.hasLooseBVar, PProd.fst, PProd.snd, HAdd.hAdd, OfNat.ofNat],[Bool]]
[Lean.Xml.Parser.EncName,[Bind.bind, Lean.Parsec.asciiLetter, Lean.Parsec.manyCharsCore, HOrElse.hOrElse, Lean.Parsec.digit, Lean.Parsec.pchar, Char.ofNat, Char.toString],[Lean.Parsec, String]]
[Lean.Elab.DefViewElabHeader.shortDeclName,[],[Lean.Name]]
[Lean.Compiler.SpecArgKind.other.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Compiler.SpecArgKind.other, OfNat.ofNat]]
[List.exists_of_mem_bind,[Iff.mp, List.mem_bind],[Exists, And, Mem.mem]]
[Lean.Elab.Term.Do.ToCodeBlock.checkReassignable,[Bind.bind, MonadReader.read, ForIn.forIn, PUnit.unit, ite, Eq, Lean.NameSet.contains, Lean.Elab.Term.Do.ToCodeBlock.Context.mutableVars, Bool.true, Pure.pure, ForInStep.yield],[Lean.Elab.Term.Do.ToCodeBlock.M, Unit]]
[Lean.Elab.Term.StructInst.Source.explicit.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.StructInst.Source.explicit, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.StructInst.Source.explicit]]
[instMonadExceptOfExcept,[MonadExceptOf.mk, Except.error, Except.tryCatch],[MonadExceptOf, Except]]
[eq_self_iff_true,[iff_true_intro, rfl],[Iff, Eq, True]]
[Lean.Meta.CheckAssignment.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.CheckAssignment.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.let_tmp.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.letDecl.formatter, Lean.Parser.Term.optSemicolon.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Attr.recursor.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.numLit.formatter],[Lean.PrettyPrinter.Formatter]]
[System.FilePath.isDir,[Bind.bind, EIO.toBaseIO, System.FilePath.metadata, BaseIO, Bool, Pure.pure, BEq.beq, IO.FS.Metadata.type, IO.FS.FileType.dir, Bool.false],[BaseIO, Bool]]
[IO.Error.mkNoSuchThingFile,[Function.comp, IO.Error.noSuchThing, Option.some],[IO.Error]]
[IO.Process.SpawnArgs.cwd,[],[Option, System.FilePath]]
[Lean.Parser.Error.unexpected,[],[String]]
[Function.right_inverse.left_inverse,[],[Function.left_inverse]]
[Lean.Elab.MacroStackElem.mk.inj,[And.intro],[And, Eq]]
[Lean.DelayedMetavarAssignment.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.DelayedMetavarAssignment.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.many.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.manyNoAntiquot.parenthesizer, Lean.Parser.withAntiquotSpliceAndSuffix.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[IO.FS.Stream.writeLspResponse,[IO.FS.Stream.writeLspMessage, Lean.JsonRpc.Message.response, Lean.JsonRpc.Response.id, Lean.ToJson.toJson, Lean.JsonRpc.Response.result],[IO, Unit]]
[Tactic.Cache.mk,[liftM, IO.mkRef, Sum.inl],[IO, Tactic.Cache]]
[Std.HashSetImp.reinsertAux.proof_1,[Subtype.property],[GT.gt, Array.size, Subtype.val, OfNat.ofNat]]
[Lean.Meta.findCore,[ite, Eq, not, Lean.Meta.FindOptions.stage1, Bool.true, Bind.bind, Pure.pure, List.toArray, List.nil, Lean.MonadEnv.getEnv, Std.HashMap.foldM, Lean.SMap.map₁, Lean.Environment.constants, Lean.Meta.findCore.check],[Lean.Meta.MetaM, Array, Lean.ConstantInfo]]
[Lean.Elab.Tactic.simpLocation,[Unit.unit, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.getFVarIds, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Meta.getNondepPropHyps, Bool.true, Lean.Elab.Tactic.simpLocation.go],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.NameGenerator.namePrefix,[],[Lean.Name]]
[Lean.Expr.appFn!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[Lean.Elab.Term.assignLevelMVar,[modifyThe, Lean.Meta.State, Lean.Meta.State.mk, Lean.MetavarContext.assignLevel, Lean.Meta.State.mctx, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed],[Lean.Elab.Term.TermElabM, Unit]]
[IO.Process.Output.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Process.Output.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.isAuxRecursor,[or, Lean.TagDeclarationExtension.isTagged, Lean.auxRecExt, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous],[Bool]]
[Lean.Meta.NormNum.eval,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getLevel, Lean.Level.zero, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Meta.MetaM, Prod, Lean.Expr, Lean.Meta.synthInstance, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil, Option.none, Lean.Meta.NormNum.evalIsNat, Lean.mkApp2, Lean.mkApp4, Pure.pure, Prod.mk, Lean.mkApp3, Lean.mkApp7, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM, Prod, Lean.Expr]]
[Lean.Lsp.DocumentHighlightResult,[Array, Lean.Lsp.DocumentHighlight],[]]
[«term_×_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Lsp.DiagnosticWith.code?,[],[Option, Lean.Lsp.DiagnosticCode]]
[Lean.Elab.MacroExpansionInfo.lctx,[],[Lean.LocalContext]]
[Lean.Lsp.InitializedParams.noConfusion,[noConfusionEnum, Lean.Lsp.InitializedParams.toCtorIdx],[Lean.Lsp.InitializedParams.noConfusionType]]
[Lean.PrettyPrinter.Delaborator.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PrettyPrinter.Delaborator.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.MVarId.name,[],[Lean.Name]]
[Lean.InductiveVal.toConstantVal,[],[Lean.ConstantVal]]
[Lean.Elab.Term.StructInst.FieldLHS.modifyOp.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.StructInst.FieldLHS.modifyOp, HAdd.hAdd, OfNat.ofNat]]
[Lean.Json.parseTagged,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Except, String, Array, Lean.Json, Lean.Json.getStr?, Except.ok, List.toArray, List.nil, MonadExcept.throw, HAppend.hAppend, ToString.toString, Except.error, Lean.Json.getObjVal?, Unit.unit, Bind.bind, ForIn.forIn, Lean.Name.getString!, Pure.pure, PUnit.unit, ForInStep.yield, List.cons, Lean.Json.getArr?, Array.size],[Except, String, Array, Lean.Json]]
[Lean.Elab.Structural.RecArgInfo.indicesPos,[],[Array, Nat]]
[Std.PersistentArray.forM,[SeqRight.seqRight, Std.PersistentArray.forMAux, Std.PersistentArray.root, Array.forM, Std.PersistentArray.tail, OfNat.ofNat, Array.size],[PUnit]]
[Lean.IR.Arg.var.injEq,[Eq.propIntro, Eq.refl, Lean.IR.Arg.var, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Arg.var]]
[Int.coe_nat_inj,[Int.ofNat.inj],[Eq]]
[Lean.mkSimpleThunkType,[Lean.mkForall, Lean.Name.anonymous, Lean.BinderInfo.default, Lean.mkConst, Lean.Name.mkStr, List.nil],[Lean.Expr]]
[Lean.Meta.AuxLemmas.mk.inj,[And.intro],[And, Eq]]
[instDecidableEqSum.proof_5,[],[Sum.noConfusionType, False, Sum.inr, Sum.inl]]
[Lean.Elab.elabSetOption.setOption,[Bind.bind, Lean.MonadRef.getRef, liftM, IO.toEIO, Lean.Exception.error, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, IO.Error.toString, Lean.getOptionDecl, ite, Eq, Lean.DataValue.sameCtor, Lean.OptionDecl.defValue, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Options]]
[Lean.IR.FnBody.setTag.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.explicitUniv,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.checkStackTop, Lean.Parser.Term.isIdent, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, Lean.Parser.sepBy1, Lean.Parser.levelParser, Bool.false],[Lean.Parser.TrailingParser]]
[Lean.Declaration.defnDecl.inj,[],[Eq]]
[Lean.Parser.Syntax.paren,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.syntaxParser],[Lean.Parser.Parser]]
[UInt8.val,[],[Fin, UInt8.size]]
[Lean.Compiler.SpecializeAttributeKind.noConfusionType,[noConfusionTypeEnum, Lean.Compiler.SpecializeAttributeKind.toCtorIdx],[]]
[Lean.Elab.Deriving.BEq.mkMatch,[Bind.bind, Lean.Elab.Deriving.mkDiscrs, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.Elab.Deriving.BEq.mkMatch.mkElseAlt, Lean.Elab.Deriving.BEq.mkMatch.mkAlts],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[inline,[],[]]
[Lean.ConstantInfo.opaqueInfo.inj,[],[Eq]]
[Lean.KernelException.declHasFVars.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KernelException.declHasFVars, HAdd.hAdd, OfNat.ofNat]]
[Int.instCommRingInt.proof_1,[],[Eq, HMul.hMul, Int.ofNat, Nat.succ, HAdd.hAdd]]
[Lean.LOption.some.inj,[],[Eq]]
[Nat.gcd.proof_1,[WellFoundedRelation.wf, measure, id],[WellFounded, WellFoundedRelation.rel, measure, id]]
[Lean.Parser.Command.extends.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.termParser.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Std.PersistentHashMap.Entry.entry.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.PersistentHashMap.Entry.entry, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.PersistentHashMap.Entry.entry, And]]
[Lean.Parser.Error.instToStringError,[ToString.mk, Lean.Parser.Error.toString],[ToString, Lean.Parser.Error]]
[Lean.Compiler.NumScalarTypeInfo.size,[],[Nat]]
[Array.mk.injEq,[Eq.propIntro, Eq.refl, Array.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Array.mk]]
[Lean.Parser.Command.openHiding,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.ident, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.checkColGt],[Lean.Parser.Parser]]
[Lean.Level.mvar.inj,[And.intro],[And, Eq]]
[List.exists_of_erasep,[Exists, And, Not, Eq, List.nil, HAppend.hAppend, List.cons, List.erasep, Eq.refl, Classical.em, Exists.intro, And.intro, List.forall_mem_nil, of_eq_true, Eq.trans, congr, congrArg, List.nil_append, eq_self, List.erasep_cons_of_pos, eq_true, eq_true_of_decide, Bool.true, Eq.symm, False.elim, Eq.mp, Iff.mpr, List.forall_mem_cons, Eq.mpr, List.cons_append, rfl, List.erasep_cons_of_neg, eq_false],[Exists, And, Not, Eq, HAppend.hAppend, List.cons, List.erasep]]
[Nat.pow_zero,[rfl],[Eq, HPow.hPow, OfNat.ofNat]]
[«term_||_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Lsp.DiagnosticSeverity.hint.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.DiagnosticSeverity.hint, OfNat.ofNat]]
[Lean.Parser.Syntax.binary.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.syntaxParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[instLEUInt8,[LE.mk, UInt8.le],[LE, UInt8]]
[EStateM.Result.ok.injEq,[Eq.propIntro, And.intro, Eq.refl, EStateM.Result.ok, Eq.symm, eq_of_heq, HEq.refl],[Eq, EStateM.Result.ok, And]]
[Pure.pure,[],[]]
[Lean.Parser.ParserCache.noConfusionType,[],[]]
[Lean.Elab.Term.Do.mkMatch,[Bind.bind, Array.mapM, Lean.Elab.Term.Do.extendUpdatedVars, Lean.Elab.Term.Do.Alt.rhs, Pure.pure, Lean.Elab.Term.Do.Alt.mk, Lean.Elab.Term.Do.Alt.ref, Lean.Elab.Term.Do.Alt.vars, Lean.Elab.Term.Do.Alt.patterns, Lean.Elab.Term.Do.CodeBlock.code, Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.match],[Lean.Elab.Term.TermElabM, Lean.Elab.Term.Do.CodeBlock]]
[Lean.MetavarContext.LevelMVarToParam.State.cache,[],[Std.HashMap, Lean.ExprStructEq, Lean.Expr]]
[Lean.Meta.Config.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Config.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Config.mk, And]]
[precLead,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[EStateM.Backtrackable.noConfusionType,[],[]]
[Lean.Parser.Term.pipeCompletion.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.minPrec, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.tryClear,[HOrElse.hOrElse, Lean.Meta.clear, Pure.pure],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.IR.FnBody.hasFreeVar,[Lean.IR.HasIndex.visitFnBody, Lean.IR.VarId.idx],[Bool]]
[Lean.IR.LocalContext.getJPBody,[Option.none, Option.some, Lean.IR.LocalContextEntry.param, Lean.IR.LocalContextEntry.localVar, Option, Lean.IR.FnBody, Std.RBMap.find?, Lean.IR.JoinPointId.idx],[Option, Lean.IR.FnBody]]
[Lean.Server.FileWorker.SemanticTokensContext.text,[],[Lean.FileMap]]
[Decidable.not_iff,[Iff, Not, of_eq_true, Eq.trans, congr, congrArg, eq_true, iff_true, iff_self, eq_false, iff_false, propext, not_not],[Iff, Not]]
[Lean.Options,[Lean.KVMap],[]]
[Lean.Elab.Term.Context.implicitLambda,[],[Bool]]
[emptyWf,[WellFoundedRelation.mk, emptyRelation, emptyWf.proof_1],[WellFoundedRelation]]
[Lean.RecursorVal.toConstantVal,[],[Lean.ConstantVal]]
[mul_left_cancel,[IsMulLeftCancel.mul_left_cancel],[Eq]]
[Nat.lt.step.proof_1,[Nat.le_step],[LE.le, Nat.succ]]
[Lean.Meta.SynthInstance.State.generatorStack,[],[Array, Lean.Meta.SynthInstance.GeneratorNode]]
[Lean.Lsp.DiagnosticRelatedInformation.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.DiagnosticRelatedInformation.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.PreDefinition.value,[],[Lean.Expr]]
[System.Platform.getNumBits.proof_1,[Or.inr, rfl],[Or, Eq, OfNat.ofNat]]
[Std.HashSetImp.insert.proof_1,[Subtype.property],[GT.gt, Array.size, Subtype.val, OfNat.ofNat]]
[Lean.Elab.Term.CollectPatternVars.Context.newArgs,[],[Array, Lean.Syntax]]
[Lean.IR.Borrow.BorrowInfCtx.mk.inj,[And.intro],[And, Eq]]
[Lean.Expr.ReplaceLevelImpl.cache.proof_2,[lcProof],[LT.lt, USize.toNat, Array.size, Lean.Expr.ReplaceLevelImpl.State.results]]
[PSigma.noConfusionType,[],[]]
[Lean.Parser.Term.optType,[Lean.Parser.optional, Lean.Parser.Term.typeSpec],[Lean.Parser.Parser]]
[Lean.NameMap.instInhabitedNameMap,[Inhabited.mk, EmptyCollection.emptyCollection],[Inhabited, Lean.NameMap]]
[Lean.Parser.Term.termFor.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.Term.doForDecl.parenthesizer, Bool.false, Lean.Parser.Term.doSeq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.MessageData.group.injEq,[Eq.propIntro, Eq.refl, Lean.MessageData.group, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MessageData.group]]
[Lean.Parser.TokenCacheEntry.startPos,[],[String.Pos]]
[Neg.noConfusionType,[],[]]
[Lean.Parser.Command.eraseAttr,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.rawIdent],[Lean.Parser.Parser]]
[Lean.Elab.Tactic.getMainDecl,[Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Meta.getMVarDecl],[Lean.Elab.Tactic.TacticM, Lean.MetavarDecl]]
[Lean.Server.Watchdog.OpenDocument.meta,[],[Lean.Server.DocumentMeta]]
[Lean.Parser.optional.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.optionalNoAntiquot.parenthesizer, Lean.Parser.withAntiquotSpliceAndSuffix.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.KVMap.setString,[Lean.KVMap.insert, Lean.DataValue.ofString],[Lean.KVMap]]
[GT.gt,[LT.lt],[]]
[Std.PersistentArray.Stats.depth,[],[Nat]]
[Lean.Elab.Term.Do.ToCodeBlock.Catch.noConfusionType,[],[]]
[List.toPersistentArray,[List.toPersistentArrayAux, Std.PersistentArray.mk],[Std.PersistentArray]]
[Lean.Elab.Tactic.simpLocation.go,[Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Meta.simpGoal, Unit.unit, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.replaceMainGoal, List.nil, List.cons],[Lean.Elab.Tactic.TacticM, Unit]]
[ByteArray.findIdx?,[ByteArray.findIdx?.loop],[Option, Nat]]
[instInhabitedUInt32,[Inhabited.mk, UInt32.ofNatCore, OfNat.ofNat, instInhabitedUInt32.proof_1],[Inhabited, UInt32]]
[List.mem_reverse,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, propext, List.mem_reverseAux, List.nil, Or, Mem.mem, List.mem_nil_iff, or_false, iff_self],[Iff, Mem.mem, List.reverse]]
[Lean.IR.addVarRename,[ite, Eq, BEq.beq, Bool.true, Std.RBMap.insert],[Lean.IR.IndexRenaming]]
[Lean.Meta.Match.MatchEqnsExtState.mk.inj,[],[Eq]]
[Lean.Elab.mkInhabitedInstanceHandler,[Bind.bind, Array.allM, Lean.isInductive, OfNat.ofNat, Array.size, ite, Eq, Bool.true, Array.forM, Lean.getConstInfoInduct, orM, Bool.false, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Elab.Command.CommandElabM, Bool]]
[Ordering.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Compiler.preUIntBinFoldFns,[List.cons, Prod.mk, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Compiler.foldUIntAdd, Lean.Compiler.foldUIntMul, Lean.Compiler.foldUIntDiv, Lean.Compiler.foldUIntMod, Lean.Compiler.foldUIntSub, List.nil],[List, Prod, Lean.Name, Lean.Compiler.BinFoldFn]]
[Quot.indepCoherent,[PSigma.eta, Quot.sound],[Eq, Quot.indep]]
[Std.PersistentArrayNode.isNode,[Bool, Bool.true, Bool.false],[Bool]]
[Subtype.map_id,[funext, Eq, Subtype.map, id, rfl],[Eq, Subtype.map, id]]
[Lean.expandExternPattern,[Lean.expandExternPatternAux, String.length, String.mkIterator],[String]]
[HEq.ndrec,[],[]]
[System.instDecidableEqFilePath,[Decidable, Eq, dite, Decidable.isTrue, rfl, Decidable.isFalse],[DecidableEq, System.FilePath]]
[Lean.IR.CompilerState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.CompilerState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.CompilerState.mk, And]]
[Lean.PrettyPrinter.Delaborator.unexpandStructureInstance,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPStructureInstances, Bind.bind, Lean.MonadEnv.getEnv, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Pure.pure, Lean.Expr.isConstructorApp?, Option.none, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, guard, Eq, Lean.isStructure, Lean.ConstructorVal.induct, Bool.true, BEq.beq, Array.size, Lean.Syntax.getNumArgs, Lean.Syntax.getOp, OfNat.ofNat, ForIn.forIn, Lean.PrettyPrinter.Delaborator.SubExpr.nextExtraPos, Lean.PrettyPrinter.Delaborator.addFieldInfo, HAppend.hAppend, Array.getOp, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Lean.Syntax.atom, PUnit.unit, ForInStep.yield, Lean.PrettyPrinter.Delaborator.SubExpr.withType, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPStructureInstanceType, ite, Lean.PrettyPrinter.Delaborator.delab, Function.comp, Option.some, Array.isEmpty, Array.append, Unit.unit, Array, Array.empty, Array.push, Array.map, Alternative.failure],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.Meta.Match.AltLHS.patterns,[],[List, Lean.Meta.Match.Pattern]]
[Trans.trans,[],[]]
[Lean.Parser.ParserState.noConfusionType,[],[]]
[Except.toOption,[Option, Option.some, Option.none],[Option]]
[Lean.Meta.SynthInstance.MkTableKey.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SynthInstance.MkTableKey.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.le.dest,[Exists, Eq, HAdd.hAdd, Exists.intro, OfNat.ofNat, rfl, Nat.succ, Eq.symm, Nat.add_comm, absurd, Nat.not_succ_le_zero],[Exists, Eq, HAdd.hAdd]]
[Lean.Server.FileWorker.handleSemanticTokens,[Bind.bind, Lean.Server.RequestM.readDoc, liftM, IO.AsyncList.waitAll, Decidable.decide, LT.lt, Lean.Server.Snapshots.Snapshot.beginPos, Lean.Server.FileWorker.EditableDocument.cmdSnaps, Lean.Server.RequestM.mapTask, Lean.Server.RequestM, Lean.Lsp.SemanticTokens, StateT.run', ForIn.forIn, PUnit.unit, ite, LE.le, Lean.Server.Snapshots.Snapshot.endPos, Pure.pure, ForInStep.yield, MonadState.get, Lean.Lsp.SemanticTokens.mk, Lean.Server.FileWorker.SemanticTokensState.data, Lean.Server.FileWorker.SemanticTokensState.mk, List.toArray, List.nil, Lean.Lsp.Position.mk, OfNat.ofNat, Lean.Server.FileWorker.handleSemanticTokens.go, Lean.Server.FileWorker.handleSemanticTokens.highlightId, Lean.Server.FileWorker.handleSemanticTokens.highlightKeyword, Lean.Server.FileWorker.handleSemanticTokens.addToken],[Lean.Server.RequestM, Lean.Server.RequestTask, Lean.Lsp.SemanticTokens]]
[Lean.Meta.mkListLit,[Bind.bind, Lean.Meta.getDecLevel, Unit.unit, List.cons, Lean.Meta.MetaM, Lean.Expr, Pure.pure, Lean.mkApp, PProd.fst],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Lsp.VersionedTextDocumentIdentifier.uri,[],[Lean.Lsp.DocumentUri]]
[Lean.IR.Decl.params,[Array, Lean.IR.Param],[Array, Lean.IR.Param]]
[Substring.trimLeft,[Substring.dropWhile, Char.isWhitespace],[Substring]]
[Lean.Lsp.instFromJsonTextDocumentEdit,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.VersionedTextDocumentIdentifier, Lean.Lsp.TextEditBatch, Pure.pure, Lean.Lsp.TextDocumentEdit.mk],[Lean.FromJson, Lean.Lsp.TextDocumentEdit]]
[IO.Error.mkResourceBusy,[IO.Error.resourceBusy],[IO.Error]]
[Lean.Export.Alloc.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Export.Alloc.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Tactic.evalRefine',[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Tactic.refineCore, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[Classical.exists_true_of_nonempty,[Exists, True, Exists.intro, trivial],[Exists, True]]
[Lean.Meta.DefaultInstances.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.DefaultInstances.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.DefaultInstances.mk, And]]
[Function.right_inverse_surj_inv,[Function.surj_inv_eq],[Function.right_inverse, Function.surj_inv]]
[Lean.Meta.getTransparency,[Bind.bind, Lean.Meta.getConfig, Pure.pure, Lean.Meta.Config.transparency],[Lean.Meta.MetaM, Lean.Meta.TransparencyMode]]
[Lean.IR.mkSSet,[Lean.IR.FnBody.sset],[Lean.IR.FnBody]]
[Lean.Meta.DiscrTree.noConfusionType,[],[]]
[Lean.Parser.Term.doIfLetPure,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.Meta.SynthInstance.MkTableKey.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SynthInstance.MkTableKey.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SynthInstance.MkTableKey.State.mk, And]]
[Lean.Parser.Term.doSeq.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.doSeqBracketed.formatter, Lean.Parser.Term.doSeqIndent.formatter],[Lean.PrettyPrinter.Formatter]]
[List.erase_cons_head,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.erase_cons, ite_congr, eq_self, Eq.refl, List.cons, List.erase, ite_true],[Eq, List.erase, List.cons]]
[String.Range.stop,[],[String.Pos]]
[ofNat_zero,[rfl],[Eq, Numeric.ofNat, OfNat.ofNat]]
[Lean.Parser.withPosition,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.Parser.fn, Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.prec, Lean.Parser.ParserContext.tokens, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Option.some, Lean.Parser.ParserState.pos, Lean.Parser.ParserContext.forbiddenTk?],[Lean.Parser.Parser]]
[LinearOrder.noConfusionType,[],[]]
[Lean.instReprRat,[Repr.mk, ite, Eq, BEq.beq, Lean.Rat.den, OfNat.ofNat, Bool.true, repr, Lean.Rat.num, Std.Format.text, HAppend.hAppend, ToString.toString],[Repr, Lean.Rat]]
[Array.anyMUnsafe.any,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bool.false, Bind.bind, Array.uget, lcProof, Array.anyMUnsafe.any, HAdd.hAdd, OfNat.ofNat],[Bool]]
[Lean.IR.Expr.lit.inj,[],[Eq]]
[Mathlib.Tactic.Conv.convRunConv_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Parser.sepBy1,[Lean.Parser.sepBy1NoAntiquot, Lean.Parser.sepByElemParser],[Lean.Parser.Parser]]
[Lean.Parser.checkLhsPrecFn,[ite, GE.ge, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.mkUnexpectedError, List.nil],[Lean.Parser.ParserFn]]
[Tactic.Ring.HornerExpr.below,[PUnit, PProd],[]]
[ByteSliceT.mk.inj,[And.intro],[And, Eq]]
[Lean.PrettyPrinter.Formatter.sepByNoAntiquot.formatter,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.PrettyPrinter.Formatter.visitArgs, List.forM, List.reverse, List.range, Array.size, Lean.Syntax.getArgs, ite, Eq, BEq.beq, HMod.hMod, OfNat.ofNat, Bool.true],[Lean.PrettyPrinter.Formatter]]
[Function.apply_update,[Decidable.em, Eq, of_eq_true, Eq.trans, congr, congrArg, Function.update_same, eq_self, Eq.symm, Function.update_noteq, ne_eq, Not, eq_false, eq_true_of_decide, Eq.refl, Bool.true],[Eq, Function.update]]
[Lean.Parser.Term.Command.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.commandParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[HMul.noConfusionType,[],[]]
[not_lt_of_ge,[not_le_of_gt],[Not, LT.lt]]
[Lean.Meta.reduceBinNatOp,[Lean.Meta.withNatValue, Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Option, Lean.Expr]]
[Lean.Elab.Term.NamedArg.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.NamedArg.mk, HAdd.hAdd, OfNat.ofNat]]
[AddMonoid.noConfusionType,[],[]]
[dite_congr,[Decidable.em, Eq.mpr, Eq.refl, Eq, dite, dif_pos, Eq.symm, dif_neg],[Eq, dite]]
[Lean.Parser.Term.doIf,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.withPosition, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.doIfCond, Lean.Parser.Term.doSeq, Lean.Parser.many, Lean.Parser.checkColGe, Lean.Parser.group, Lean.Parser.Term.elseIf, Lean.Parser.optional],[Lean.Parser.Parser]]
[Lean.Expr.sort.inj,[And.intro],[And, Eq]]
[Lean.PrettyPrinter.Delaborator.unresolveNameGlobal.unresolveNameCore,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, Unit.unit, Lean.PrettyPrinter.Delaborator.DelabM, ForInStep, MProd, Option, Lean.Name, List, Pure.pure, ForInStep.done, Option.some, PUnit.unit, MProd.fst],[Lean.PrettyPrinter.Delaborator.DelabM, Option, Lean.Name]]
[Lean.Meta.isMatchValue,[or, Lean.Expr.isNatLit, Lean.Expr.isCharLit, Lean.Expr.isStringLit, Lean.Meta.isFinPatLit, Lean.Meta.isUIntPatLit],[Bool]]
[Lean.Elab.Tactic.evalChoice,[Lean.Elab.Tactic.evalChoiceAux, Lean.Syntax.getArgs, OfNat.ofNat],[Lean.Elab.Tactic.Tactic]]
[Zero.zero,[],[]]
[gt_trans,[lt_trans],[GT.gt]]
[Lean.ScopedEnvExtension.instInhabitedScopedEntries,[Inhabited.mk, Lean.ScopedEnvExtension.ScopedEntries.mk, arbitrary],[Inhabited, Lean.ScopedEnvExtension.ScopedEntries]]
[Lean.Meta.SynthInstance.MkTableKey.State.nextIdx,[],[Nat]]
[Lean.Parser.AliasValue.noConfusionType,[],[]]
[UInt16.instSemigroupUInt16,[Semigroup.mk, UInt16.instSemigroupUInt16.proof_1],[Semigroup, UInt16]]
[exists_eq_right,[Iff.trans, exists_congr, And.comm, exists_eq_left],[Iff, Exists, And, Eq]]
[Lean.Elab.Term.elabSubst,[Bind.bind, Lean.Elab.Term.tryPostponeIfHasMVars, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Lean.Elab.Term.elabTerm, Option.none, liftM, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Lean.Meta.matchEq?, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Meta.kabstract, Lean.Occurrences.all, Lean.Expr.hasLooseBVars, Pure.pure, PUnit.unit, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElab]]
[Lean.Elab.Level.State.mk.inj,[And.intro],[And, Eq]]
[Lean.Server.FileWorker.WorkerContext.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.MetaM.run',[Functor.map, Prod.fst, Lean.Meta.MetaM.run],[Lean.Core.CoreM]]
[Lean.MetavarContext.setMVarKind,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Std.PersistentHashMap.insert, Lean.MetavarContext.decls, Lean.MetavarDecl.mk, Lean.MetavarDecl.userName, Lean.MetavarDecl.lctx, Lean.MetavarDecl.type, Lean.MetavarDecl.depth, Lean.MetavarDecl.localInstances, Lean.MetavarDecl.numScopeArgs, Lean.MetavarDecl.index, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment],[Lean.MetavarContext]]
[Lean.Lsp.instToJsonMarkupKind,[Lean.ToJson.mk, Unit.unit, Lean.Json, Lean.Json.str],[Lean.ToJson, Lean.Lsp.MarkupKind]]
[Lean.Core.CoreM,[ReaderT, Lean.Core.Context, StateRefT', IO.RealWorld, Lean.Core.State, EIO, Lean.Exception],[]]
[Lean.instInhabitedDeclaration,[Inhabited.mk, Lean.Declaration.axiomDecl, arbitrary],[Inhabited, Lean.Declaration]]
[Lean.Meta.Simp.Result.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.Expr.fap.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.squeezeSimpa,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Elab.Term.Do.ToTerm.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.ToTerm.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.ToTerm.Context.mk, And]]
[Lean.Meta.SynthInstance.findEntry?,[Bind.bind, MonadState.get, Pure.pure, Std.HashMap.find?, Lean.Meta.SynthInstance.State.tableEntries],[Lean.Meta.SynthInstance.SynthM, Option, Lean.Meta.SynthInstance.TableEntry]]
[Lean.Export.Entry.level.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Export.Entry.level, HAdd.hAdd, OfNat.ofNat]]
[Lean.MetavarDecl.noConfusionType,[],[]]
[Lean.Meta.ApplyNewGoals.nonDependentOnly.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.ApplyNewGoals.nonDependentOnly, OfNat.ofNat]]
[Lean.IR.getDecl,[Bind.bind, Lean.IR.findDecl, Option.none, Lean.IR.CompilerM, Lean.IR.Decl, Pure.pure, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.IR.CompilerM, Lean.IR.Decl]]
[Lean.Elab.Tactic.orElse,[MonadExcept.tryCatch, Unit.unit],[Lean.Elab.Tactic.TacticM]]
[Function.right_inverse_iff_comp,[Iff.intro, Function.right_inverse.comp_eq_id, congr_fun],[Iff, Function.right_inverse, Eq, Function.comp, id]]
[MonadState.get,[],[]]
[Lean.PrettyPrinter.mkCombinatorFormatterAttribute,[Lean.ParserCompiler.registerCombinatorAttribute, Lean.Name.mkStr, Lean.Name.anonymous],[IO, Lean.ParserCompiler.CombinatorAttribute]]
[Lean.Elab.Term.StructInst.FieldVal.toSyntax,[Lean.Elab.Term.StructInst.FieldVal.nested, Lean.Elab.Term.StructInst.FieldVal.default, Lean.Syntax, panicWithPosWithDecl, OfNat.ofNat],[Lean.Syntax]]
[Lean.StructureInfo.lt,[Lean.Name.quickLt, Lean.StructureInfo.structName],[Bool]]
[Mathlib.Tactic.Lint.constToSimpDeclMap,[Id.run, Bind.bind, ForIn.forIn, Option.none, Id, ForInStep, Std.HashMap, Lean.Name, Lean.Meta.SimpLemma.name?, Lean.Expr.constName?, Lean.Expr.getAppFn, Lean.Meta.SimpLemma.proof, Pure.pure, PUnit.unit, ForInStep.yield],[Std.HashMap, Lean.Name]]
[Lean.InductiveType.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.InductiveType.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.InductiveType.mk, And]]
[Lean.Parser.Term.letRecDecl,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.docComment, Lean.Parser.Term.attributes, Lean.Parser.Term.letDecl],[Lean.Parser.Parser]]
[Lean.instInhabitedLBool,[Inhabited.mk, Lean.LBool.false],[Inhabited, Lean.LBool]]
[Nat.zero_lt_one,[Nat.zero_lt_succ, OfNat.ofNat],[LT.lt, OfNat.ofNat]]
[Lean.Meta.generalizeTargetsEq,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.forallTelescopeReducing, ite, Eq, BEq.beq, Array.size, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.MetaM, Lean.MVarId, Lean.Meta.getMVarTag, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.assignExprMVar, Lean.mkAppN, Lean.Expr.mvarId!],[Lean.Meta.MetaM, Lean.MVarId]]
[forall_const,[Iff.intro, Nonempty.elim],[Iff]]
[Lean.Parser.Tactic.set_option.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.Command.optionValue.parenthesizer, Lean.Parser.Tactic.tacticSeq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[IO.Process.SpawnArgs.noConfusionType,[],[]]
[Lean.Meta.ppGoal.ppVars,[ite, Eq, Std.RBTree.contains, Lean.LocalDecl.fvarId, Bool.true, Bind.bind, Lean.Meta.ppGoal.pushPending, Lean.Meta.instantiateMVars, Lean.LocalDecl.type, Lean.Meta.ppExpr, Pure.pure, Prod.mk, List.nil, Option.none, Lean.Meta.MetaM, Prod, List, Lean.Name, Option, Lean.Expr, Std.Format, or, BEq.beq, Option.some, List.cons],[Lean.Meta.MetaM, Prod, List, Lean.Name, Option, Lean.Expr, Std.Format]]
[Lean.Parser.Term.structInstArrayRef.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[LawfulApplicative.toLawfulFunctor,[],[LawfulFunctor]]
[Lean.Parser.Command.resolve_name,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident],[Lean.Parser.Parser]]
[Lean.Elab.InfoTree.node.inj,[And.intro],[And, Eq]]
[Lean.Meta.UnificationConstraint.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.UnificationConstraint.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.UnificationConstraint.mk, And]]
[Lean.Elab.WF.mkUnaryArg,[OfNat.ofNat, Lean.Elab.WF.mkUnaryArg.go],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Meta.SynthInstance.Answer.resultType,[],[Lean.Expr]]
[Lean.Parser.ParserState.setPos,[Lean.Parser.ParserState.mk, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.cache, Lean.Parser.ParserState.errorMsg],[Lean.Parser.ParserState]]
[Lean.Compiler.getBoolLit,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Name.anonymous, Lean.Name.str, dite, Eq, Eq.symm, Lean.Name.num, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Bool, Option.some, Bool.true, Bool.false, Option.none],[Option, Bool]]
[Int.add_assoc,[Int.ofNat, Int.negSucc, Eq, HAdd.hAdd, Int.add_assoc_aux1, Eq.mpr, Eq.refl, Int.add_comm, Eq.symm, rfl, Int.add_assoc_aux2, of_eq_true, Eq.trans, congr, congrArg, congrFun, Int.negSucc_ofNat_add_negSucc_ofNat, Nat.succ, Nat.add_comm, Nat.add_succ, Nat.add_left_comm, eq_self],[Eq, HAdd.hAdd]]
[Lean.Widget.instInhabitedInteractiveTermGoal,[Inhabited.mk, Lean.Widget.InteractiveTermGoal.mk, arbitrary],[Inhabited, Lean.Widget.InteractiveTermGoal]]
[gt_irrefl,[lt_irrefl],[Not, GT.gt]]
[FloatArray.foldlM.proof_1,[Nat.le_refl, FloatArray.size],[LE.le, FloatArray.size]]
[Lean.ScopedEnvExtension.ScopedEntries.insert,[Unit.unit, Lean.ScopedEnvExtension.ScopedEntries, Lean.SMap.find?, Lean.ScopedEnvExtension.ScopedEntries.map, Lean.ScopedEnvExtension.ScopedEntries.mk, Lean.SMap.insert, Std.PersistentArray.push, Std.PersistentArray.mk],[Lean.ScopedEnvExtension.ScopedEntries]]
[Lean.Elab.Tactic.Conv.evalConv,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[Lean.Elab.Term.getFVarLocalDecl!,[Bind.bind, Lean.MonadLCtx.getLCtx, Unit.unit, Lean.Elab.Term.TermElabM, Lean.LocalDecl, Lean.LocalContext.find?, Lean.Expr.fvarId!, Pure.pure, panicWithPosWithDecl, OfNat.ofNat],[Lean.Elab.Term.TermElabM, Lean.LocalDecl]]
[Lean.Elab.Term.elabLetDeclAux,[Bind.bind, Lean.Elab.Term.elabBinders, Lean.Elab.Term.elabType, Lean.Elab.Term.registerCustomErrorIfMVar, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, ite, Eq, Bool.true, liftM, Lean.Meta.mkForallFVars, Bool.false, Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.natural, Lean.Name.anonymous, Pure.pure, Prod.mk, Array.size, Lean.Elab.Term.elabTermEnsuringType, Option.none, Lean.Meta.mkLambdaFVars, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Syntax.getId, PUnit.unit],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Lean.BinderInfo.auxDecl.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.BinderInfo.auxDecl, OfNat.ofNat]]
[Lean.PrettyPrinter.ppExprLegacy,[Functor.map, Prod.fst, Lean.Core.CoreM.toIO, Lean.Meta.MetaM.run', Lean.PrettyPrinter.ppExpr, Lean.Name.anonymous, List.nil, Lean.Meta.Context.mk, Lean.Meta.State.mk, Lean.Core.Context.mk, Lean.Core.State.mk],[IO, Std.Format]]
[Lean.Elab.instInhabitedInfo,[Inhabited.mk, Lean.Elab.Info.ofTacticInfo, arbitrary],[Inhabited, Lean.Elab.Info]]
[UInt32.instInhabitedFinSize,[Inhabited.mk, Fin.ofNat', OfNat.ofNat, UInt32.size_positive],[Inhabited, Fin, UInt32.size]]
[Lean.Elab.Info.ofCompletionInfo.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Info.ofCompletionInfo, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Info.ofCompletionInfo]]
[Lean.Meta.mkHEqTrans,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Option.none, Option.some, Prod.mk, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.heq?, Lean.Meta.getLevel, Lean.mkApp8, Lean.mkConst, List.cons, List.nil, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr],[Lean.Meta.MetaM, Lean.Expr]]
[List.subset_append_of_subset_right,[List.subset.trans, List.subset_append_right],[Subset.subset, HAppend.hAppend]]
[Lean.Parser.topLevelCommandParserFn,[Lean.Parser.Parser.fn, Lean.Parser.commandParser, OfNat.ofNat],[Lean.Parser.ParserFn]]
[Lean.Server.MonadRpcSession.noConfusionType,[],[]]
[Lean.IR.formatFnBodyHead,[Unit.unit, Std.Format, HAppend.hAppend, Std.Format.text, Std.ToFormat.format, Lean.IR.formatParams, ite, Eq, bne, OfNat.ofNat, Bool.true, Std.Format.sbracket, Lean.IR.formatArray],[Std.Format]]
[Lean.Meta.Match.Pattern.ctor.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.Pattern.ctor, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.Pattern.ctor, And]]
[Lean.Lsp.LeanFileProgressParams.processing,[],[Array, Lean.Lsp.LeanFileProgressProcessingInfo]]
[Lean.Elab.Command.InductiveView.derivingClasses,[],[Array, Lean.Elab.DerivingClassView]]
[Lean.Macro.Context.currRecDepth,[],[Nat]]
[Lean.Parser.Term.optType.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.Parser.Term.typeSpec.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.mk, And]]
[Lean.mkApp3,[Lean.mkApp, Lean.mkAppB],[Lean.Expr]]
[Std.PersistentHashSet.size,[Std.PersistentHashMap.size, Std.PersistentHashSet.set],[Nat]]
[Lean.Level.noConfusionType,[],[]]
[Attr.simps?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Meta.DefaultInstances.noConfusionType,[],[]]
[UInt16.toUInt64,[Nat.toUInt64, UInt16.toNat],[UInt64]]
[Nat.mul_left_comm,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Eq.symm, Nat.mul_assoc, Nat.mul_comm, rfl],[Eq, HMul.hMul]]
[Lean.IR.Decl.getInfo,[Lean.IR.Decl.extern, Lean.IR.DeclInfo, Lean.IR.DeclInfo.mk],[Lean.IR.DeclInfo]]
[Fin.mod_lt,[LT.lt, HMod.hMod],[LT.lt, HMod.hMod]]
[UInt32.zero_def,[rfl],[Eq, OfNat.ofNat, UInt32.mk]]
[Mathlib.ExtendedBinder.«binderTerm≥_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Term.leading_parser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.optExprPrecedence.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.Simp.instInhabitedStep,[Inhabited.mk, Lean.Meta.Simp.Step.visit, arbitrary],[Inhabited, Lean.Meta.Simp.Step]]
[Lean.TagAttribute.attr,[],[Lean.AttributeImpl]]
[Lean.Meta.SynthInstance.consume,[Unit.unit, Lean.Meta.SynthInstance.SynthM, Unit, Lean.Meta.SynthInstance.ConsumerNode.subgoals, Lean.Meta.SynthInstance.addAnswer, Bind.bind, Lean.Meta.SynthInstance.mkTableKeyFor, Lean.Meta.SynthInstance.ConsumerNode.mctx, Lean.Meta.SynthInstance.findEntry?, liftM, Lean.Meta.withMCtx, Lean.Meta.inferType, Lean.Meta.instantiateMVars, ite, Eq, not, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, or, Lean.Expr.hasLooseBVar, OfNat.ofNat, PProd.fst, PProd.snd, Bool.false, Bool.true, Pure.pure, Option.none, Lean.Meta.forallTelescope, Array.foldrM, Lean.Expr.containsFVar, Lean.Expr.fvarId!, List.cons, List.anyM, List.nil, Array.size, Lean.Meta.mkForallFVars, Lean.Meta.withLocalDeclD, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.mkLambdaFVars, Lean.mkAppN, List.toArray, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, PUnit.unit, Lean.Meta.SynthInstance.newSubgoal, Lean.Meta.SynthInstance.mkTableKey, Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.natural, Lean.MonadMCtx.getMCtx, Prod.mk, Lean.Meta.SynthInstance.Waiter.consumerNode, Lean.Meta.SynthInstance.ConsumerNode.mk, Lean.Meta.SynthInstance.ConsumerNode.mvar, Lean.Meta.SynthInstance.ConsumerNode.key, Lean.Meta.SynthInstance.ConsumerNode.size, Array.mapM, Lean.Meta.AbstractMVarsResult.expr, Lean.Meta.SynthInstance.Answer.result, Lean.Meta.SynthInstance.Answer.mk, Lean.Meta.AbstractMVarsResult.mk, Lean.Meta.AbstractMVarsResult.paramNames, Lean.Meta.AbstractMVarsResult.numMVars, Lean.Meta.SynthInstance.Answer.size, Lean.Meta.SynthInstance.TableEntry.answers, modify, Lean.Meta.SynthInstance.State.mk, Lean.Meta.SynthInstance.State.result?, Lean.Meta.SynthInstance.State.generatorStack, Array.foldl, Array.push, Lean.Meta.SynthInstance.State.resumeStack, Std.HashMap.insert, Lean.Meta.SynthInstance.State.tableEntries, Lean.Meta.SynthInstance.TableEntry.mk, Lean.Meta.SynthInstance.TableEntry.waiters],[Lean.Meta.SynthInstance.SynthM, Unit]]
[Array.size_set,[List.length_set, Array.data, Fin.val],[Eq, Array.size, Array.set]]
[Lean.Parser.Tactic.ring1!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Meta.AbstractMVars.State.paramNames,[],[Array, Lean.Name]]
[Lean.Elab.DerivingClassView.className,[],[Lean.Name]]
[Lean.Elab.Term.liftLevelM,[Bind.bind, MonadReader.read, Lean.MonadMCtx.getMCtx, Lean.MonadNameGenerator.getNGen, Lean.MonadOptions.getOptions, Lean.MonadRef.getRef, Lean.Elab.Term.getLevelNames, Lean.Elab.Term.TermElabM, EStateM.run, Lean.Elab.Level.State.mk, liftM, Lean.Meta.setMCtx, Lean.Elab.Level.State.mctx, Lean.MonadNameGenerator.setNGen, Lean.Elab.Level.State.ngen, Lean.Elab.Term.setLevelNames, Lean.Elab.Level.State.levelNames, Pure.pure, MonadExcept.throw],[Lean.Elab.Term.TermElabM]]
[Lean.Elab.Term.StructInst.DefaultFields.mkDefaultValue?,[Lean.withRef, Lean.Elab.Term.StructInst.Struct.ref, Bind.bind, liftM, Lean.Meta.mkFreshLevelMVarsFor, Lean.Elab.Term.StructInst.DefaultFields.mkDefaultValueAux?, Lean.ConstantInfo.instantiateValueLevelParams],[Lean.Elab.Term.TermElabM, Option, Lean.Expr]]
[Array.forIn.loop.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self],[LE.le, Array.size]]
[Lean.Elab.Term.Do.getDoLetArrowVars,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, List.toArray, List.cons, Lean.Elab.Term.Do.getDoIdDeclVar, List.nil, Lean.Elab.Term.Do.getDoPatDeclVars, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.TermElabM, Array, Lean.Name]]
[Lean.Parser.unicodeSymbolInfo,[Lean.Parser.ParserInfo.mk, List.cons, Lean.Parser.FirstTokens.tokens, List.nil],[Lean.Parser.ParserInfo]]
[Fin.mk.injEq,[Eq.propIntro, Eq.refl, Fin.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Fin.mk]]
[Lean.Meta.AbstractNestedProofs.State.nextIdx,[],[Nat]]
[Array.mapSepElemsM,[OfNat.ofNat, List.toArray, List.nil],[Array, Lean.Syntax]]
[proof_irrel_heq,[],[HEq]]
[withPtrEqDecEq,[Decidable, Eq, Eq.refl, Decidable.isTrue, withPtrEqDecEq.proof_2, Decidable.isFalse, withPtrEqDecEq.proof_3],[Decidable, Eq]]
[Lean.Parser.Tactic.Conv.lhs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Lsp.instBEqPosition,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Lsp.Position]]
[Function.has_uncurry_base,[Function.has_uncurry.mk, id],[Function.has_uncurry]]
[Lean.Elab.Term.LetIdDeclView.value,[],[Lean.Syntax]]
[Lean.MetavarContext.MkBinding.State.mctx,[],[Lean.MetavarContext]]
[Function.has_uncurry.uncurry,[],[]]
[Lean.MessageData.ofSyntax.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MessageData.ofSyntax, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.macroArg.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.syntaxParser.parenthesizer, Lean.Parser.argPrec],[Lean.PrettyPrinter.Parenthesizer]]
[IO.FS.Metadata.modified,[],[IO.FS.SystemTime]]
[Lean.Parser.Command.namedPrio.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.priorityParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[instInhabitedNonScalar,[Inhabited.mk, NonScalar.mk, arbitrary],[Inhabited, NonScalar]]
[Lean.Lsp.instFileSourceTextDocumentIdentifier,[Lean.Lsp.FileSource.mk, Lean.Lsp.TextDocumentIdentifier.uri],[Lean.Lsp.FileSource, Lean.Lsp.TextDocumentIdentifier]]
[String.length_repeat,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.length_repeat, eq_self],[Eq, String.length, String.repeat]]
[List.filterMapM.loop,[List, Pure.pure, Bind.bind, Unit.unit, PProd.fst, List.cons],[List]]
[Lean.PrettyPrinter.Parenthesizer.error.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[CommRing.noConfusionType,[],[]]
[String.Iterator.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, String.Iterator.mk, HAdd.hAdd, OfNat.ofNat]]
[instDecidableEqUInt32,[UInt32.decEq],[DecidableEq, UInt32]]
[Lean.PrettyPrinter.Delaborator.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PrettyPrinter.Delaborator.State.mk, And]]
[as_true,[ite, True, False],[]]
[Equiv.instInhabitedEquiv,[Inhabited.mk, Equiv.refl],[Inhabited, Equiv]]
[Lean.Elab.WF.TerminationHint.ensureIsEmpty,[Lean.Elab.WF.TerminationHint.none, Lean.MacroM, Unit, Lean.Macro.throwErrorAt, Lean.Elab.WF.TerminationHintValue.ref, Std.RBMap.forM, Pure.pure, Unit.unit],[Lean.MacroM, Unit]]
[Lean.Expr.app1?,[ite, Eq, Lean.Expr.isAppOfArity, OfNat.ofNat, Bool.true, Option.some, Lean.Expr.appArg!, Option.none],[Option, Lean.Expr]]
[Lean.Parser.Tactic.done,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Std.PHashMap,[Std.PersistentHashMap],[]]
[Lean.Meta.ElimInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.ElimInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.NormNum.instLawfulOne,[Lean.Meta.NormNum.instLawfulOne.proof_1],[Lean.Meta.NormNum.LawfulOne]]
[Lean.Elab.mkElabAttribute,[Lean.KeyedDeclsAttribute.init, Lean.KeyedDeclsAttribute.Def.mk, HAppend.hAppend, Lean.Elab.syntaxNodeKindOfAttrParam, ite, Eq, Bool.true, Bind.bind, Lean.MonadEnv.getEnv, liftM, Lean.findDocString?, Option.none, Lean.AttrM, Unit, Lean.declareBuiltin, Lean.Name.mkStr, Lean.Name.anonymous, Lean.mkAppN, Lean.mkConst, List.nil, List.toArray, List.cons, Lean.ToExpr.toExpr, Pure.pure, PUnit.unit],[IO, Lean.KeyedDeclsAttribute]]
[Lean.Meta.Match.Pattern.as.inj,[And.intro],[And, Eq]]
[IO.Error.unsupportedOperation.inj,[And.intro],[And, Eq]]
[List.or,[List.any, id],[Bool]]
[Lean.instInhabitedRecursorVal,[Inhabited.mk, Lean.RecursorVal.mk, arbitrary],[Inhabited, Lean.RecursorVal]]
[List.erase,[List, List.nil, Unit.unit, BEq.beq, List.cons, PProd.fst],[List]]
[Lean.Meta.SynthInstance.mkTableKey,[StateT.run', Lean.Meta.SynthInstance.MkTableKey.normExpr, Lean.Meta.SynthInstance.MkTableKey.State.mk],[Lean.Expr]]
[Lean.Expr.const.inj,[And.intro],[And, Eq]]
[Lean.Widget.TaggedText.tag.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Widget.TaggedText.tag, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.InitializeResult.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.instToJsonReferenceParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.ReferenceParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position, Lean.Lsp.ReferenceParams.context],[Lean.ToJson, Lean.Lsp.ReferenceParams]]
[ByteSliceT.noConfusionType,[],[]]
[Lean.ScopedEnvExtension.Descr.mkInitial,[],[IO]]
[instToStringExcept,[ToString.mk, String, HAppend.hAppend, ToString.toString],[ToString, Except]]
[Lean.Parser.Tactic.Conv.applyCongr,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.runFrontend,[Bind.bind, Lean.Parser.parseHeader, IO, Prod, Lean.Environment, Bool, Lean.Elab.processHeader, Lean.Elab.IO.processCommands, Lean.Elab.Command.mkState, ForIn.forIn, PUnit.unit, Lean.Message.toString, Lean.Elab.getPrintMessageEndPos, IO.print, Pure.pure, ForInStep.yield, Prod.mk, Lean.Elab.Command.State.env, Lean.Elab.Frontend.State.commandState, not, Lean.MessageLog.hasErrors, Lean.Elab.Command.State.messages],[IO, Prod, Lean.Environment, Bool]]
[Lean.Rat.neg,[Neg.neg, Lean.Rat.num, Lean.Rat.den],[Lean.Rat]]
[Lean.Elab.Tactic.Tactic,[Lean.Elab.Tactic.TacticM, Unit],[]]
[Lean.Parser.Tactic.haveField,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.IR.ExplicitBoxing.castArgIfNeeded,[Lean.IR.Arg.irrelevant, Lean.IR.ExplicitBoxing.M, Lean.IR.FnBody, Lean.IR.ExplicitBoxing.castVarIfNeeded, Lean.IR.Arg.var],[Lean.IR.ExplicitBoxing.M, Lean.IR.FnBody]]
[Lean.Elab.registerBuiltinDerivingHandler,[Lean.Elab.registerBuiltinDerivingHandlerWithArgs],[IO, Unit]]
[Std.PersistentHashMap.mk.inj,[And.intro],[And, Eq]]
[Lean.Compiler.atMostOnce.AtMostOnceData.mk.inj,[And.intro],[And, Eq]]
[Decidable.ne_or_eq,[dec_em', Eq],[Or, Ne, Eq]]
[Lean.Parser.Term.dbgTrace,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, Lean.Parser.symbol, HOrElse.hOrElse, Lean.Parser.interpolatedStr, Lean.Parser.termParser, OfNat.ofNat, Lean.Parser.Term.optSemicolon],[Lean.Parser.Parser]]
[Lean.Meta.SimpAll.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SimpAll.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SimpAll.State.mk, And]]
[Lean.NamePart.num.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.NamePart.num, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.DocumentSymbol.below,[PProd, PUnit],[]]
[Lean.Elab.expandMacroImpl?,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, MonadExcept.tryCatch, Lean.MonadQuotation.withFreshMacroScope, Lean.KeyedDeclsAttribute.AttributeEntry.value, Pure.pure, DoResultPR.return, Prod.mk, Lean.KeyedDeclsAttribute.OLeanEntry.declName, Lean.KeyedDeclsAttribute.AttributeEntry.toOLeanEntry, Except.ok, Lean.Macro.Exception.error, Unit.unit, Lean.MacroM, DoResultPR, Unit, Prod, Lean.Name, Except, Lean.Macro.Exception, Lean.Syntax, PUnit, DoResultPR.pure, Except.error, ForInStep, MProd, Option, ForInStep.yield, ForInStep.done, Option.some, MProd.fst],[Lean.MacroM, Option, Prod, Lean.Name, Except, Lean.Macro.Exception, Lean.Syntax]]
[instDivUSize,[Div.mk, USize.div],[Div, USize]]
[Lean.Elab.Tactic.withCaseRef,[Lean.withRef, Lean.mkNullNode, List.toArray, List.cons, List.nil],[]]
[Function.injective.ne_iff',[Function.injective.ne_iff],[Iff, Ne]]
[IO.AsyncList.unfoldAsync,[Bind.bind, Functor.map, Task.map, Except, Except.error, Coe.coe, Task.Priority.default, liftM, IO.asTask, Pure.pure, IO.AsyncList.asyncTail, IO.AsyncList.unfoldAsync.step],[IO, IO.AsyncList]]
[Lean.Server.Watchdog.FileWorker.mk.inj,[And.intro],[And, Eq]]
[UInt64.instNumericUInt64,[Numeric.mk, UInt64.mk, Numeric.ofNat],[Numeric, UInt64]]
[ByteArray.get,[UInt8, Array.get],[UInt8]]
[Std.AssocList.forIn,[Std.AssocList.forIn.loop],[]]
[Lean.Meta.Match.AltLHS.fvarDecls,[],[List, Lean.LocalDecl]]
[Lean.Elab.Tactic.ElimApp.Context.elimInfo,[],[Lean.Meta.ElimInfo]]
[WellFounded.apply.proof_1,[],[Acc]]
[Lean.Parser.Tactic.left,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.InductiveVal.isUnsafe,[],[Bool]]
[Lean.Elab.Tactic.elabCasesTargets,[Lean.Elab.Tactic.withMainContext, Bind.bind, Array.mapM, Lean.Elab.Tactic.elabTerm, Lean.Syntax.getOp, OfNat.ofNat, Option.none, Bool.false, Pure.pure, Lean.Meta.GeneralizeArg.mk, ite, Eq, Array.all, and, Lean.Expr.isFVar, Lean.Meta.GeneralizeArg.expr, Option.isNone, Lean.Meta.GeneralizeArg.hName?, Array.size, Bool.true, Array.map, Lean.Elab.Tactic.liftMetaTacticAux, Lean.Meta.generalize, Lean.Meta.MetaM, Prod, Array, Lean.Expr, List, Lean.MVarId, Prod.mk, Lean.mkFVar, Subarray.toArray, Array.toSubarray, List.cons, List.nil],[Lean.Elab.Tactic.TacticM, Array, Lean.Expr]]
[Std.Format.instInhabitedSpaceResult,[Inhabited.mk, arbitrary],[Inhabited]]
[Lean.removeRoot,[Lean.Name.replacePrefix, Lean.rootNamespace, Lean.Name.anonymous],[Lean.Name]]
[Lean.SimpleScopedEnvExtension.Descr.name,[],[Lean.Name]]
[Lean.PrettyPrinter.Parenthesizer.charLitNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.OpaqueVal.noConfusionType,[],[]]
[Lean.IR.IsLive.M,[StateM, Lean.IR.LocalContext],[]]
[Lean.MetavarContext.occursCheck,[ite, Eq, not, Lean.Expr.hasExprMVar, Bool.true, Bool, EStateM.run, EmptyCollection.emptyCollection, Bool.false, Lean.MetavarContext.occursCheck.visitMVar, Lean.MetavarContext.occursCheck.visit],[Bool]]
[Lean.Expr.lit.inj,[And.intro],[And, Eq]]
[Lean.Elab.Command.StructFieldInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.mkNoConfusion,[Bind.bind, Lean.Meta.inferType, Lean.Meta.whnf, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.eq?, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Name.mkStr, Lean.Name.anonymous, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr, Lean.matchConstInduct, Lean.Expr.getAppFn, Lean.Meta.getLevel, Pure.pure, Lean.mkAppN, Lean.mkConst, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, List.cons, Lean.Expr.getAppArgs, List.toArray, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Level.instQuoteLevel,[Lean.Quote.mk, Lean.Level.quote, OfNat.ofNat],[Lean.Quote, Lean.Level]]
[String.next,[HAdd.hAdd, String.csize],[String.Pos]]
[«stx_*»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[Tactic.Ring.horner_add_const,[of_eq_true, Eq.trans, congr, congrArg, Eq, add_assoc, HMul.hMul, HPow.hPow, HAdd.hAdd, Eq.symm, eq_self],[Eq, HAdd.hAdd, Tactic.Ring.horner]]
[Lean.Parser.Command.optDeclSig.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.simpleBinderWithoutType.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Bool.false, Lean.Parser.Term.optType.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parsec.asciiLetter,[Lean.Parsec.attempt, Bind.bind, Lean.Parsec.anyChar, ite, Or, And, LE.le, Char.ofNat, Pure.pure, Lean.Parsec.fail, ToString.toString],[Lean.Parsec, Char]]
[Lean.Meta.getFVarSetToGeneralize,[Bind.bind, Lean.MonadLCtx.getLCtx, ForIn.forIn, MProd.mk, ite, Eq, Std.RBTree.contains, Lean.LocalDecl.fvarId, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, or, Lean.LocalDecl.isAuxDecl, Lean.BinderInfo.isInstImplicit, Lean.LocalDecl.binderInfo, Lean.MonadMCtx.getMCtx, Lean.MetavarContext.findLocalDeclDependsOn, Lean.Meta.MetaM, Lean.FVarIdSet],[Lean.Meta.MetaM, Lean.FVarIdSet]]
[ByteArray.copySlice,[ByteArray.mk, HAppend.hAppend, Array.extract, ByteArray.data, OfNat.ofNat, HAdd.hAdd, Array.size],[ByteArray]]
[Lean.IR.EmitC.emit,[modify, HAppend.hAppend, ToString.toString],[Lean.IR.EmitC.M, Unit]]
[Lean.Lsp.Command.arguments?,[],[Option, Array, Lean.Json]]
[Nat.gcd_dvd_gcd_of_dvd_left,[Nat.dvd_gcd, Nat.dvd_trans, Nat.gcd_dvd_left, Nat.gcd_dvd_right],[Dvd.dvd, Nat.gcd]]
[Lean.Elab.Frontend.State.commands,[],[Array, Lean.Syntax]]
[Lean.Meta.TransparencyMode.default.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.TransparencyMode.default, OfNat.ofNat]]
[Lean.Elab.Term.LValResolution.getOp.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LValResolution.getOp, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.LValResolution.getOp, And]]
[Mathlib.ExtendedBinder.binderPred.quot,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Server.FileWorker.RefIdent.fvar.inj,[],[Eq]]
[Mathlib.Tactic.Lint.checkAllSimpLemmaInfos,[Bind.bind, Mathlib.Tactic.Lint.withSimpLemmaInfos, Option.mapM, Lean.addMessageContextFull, ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Option.none, Option.some, Lean.MessageData.joinSep, Array.toList, Lean.MessageData.ofFormat, Std.Format.line],[Lean.Meta.MetaM, Option, Lean.MessageData]]
[Lean.Elab.Term.ElabAppArgs.State.explicit,[],[Bool]]
[Lean.Elab.MonadLog.toMonadFileMap,[],[Lean.MonadFileMap]]
[Lean.Parser.Command.builtin_initialize,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.visibility, Lean.Parser.symbol, Lean.Parser.atomic, Lean.Parser.ident, Lean.Parser.Term.typeSpec, Lean.Parser.Term.leftArrow, Lean.Parser.Term.doSeq],[Lean.Parser.Parser]]
[Lean.Meta.SortLocalDecls.Context.mk.inj,[],[Eq]]
[Lean.Meta.Match.MkMatcherInput.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.MkMatcherInput.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.MkMatcherInput.mk, And]]
[Lean.Parser.Term.optEllipsis.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.optional.parenthesizer, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Info.noConfusionType,[],[]]
[Std.Format.fill,[Std.Format.group, Std.Format.FlattenBehavior.fill],[Std.Format]]
[Lean.Elab.Command.InductiveView.type?,[],[Option, Lean.Syntax]]
[Lean.LocalDecl.value?,[Option, Lean.Expr, Option.none, Option.some],[Option, Lean.Expr]]
[Lean.Syntax.getArg,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Array.getD],[Lean.Syntax]]
[Lean.Lsp.RpcConnectParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.RpcConnectParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.RpcConnectParams.mk]]
[Lean.Parser.Tactic.unelide,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Std.Format.pretty',[Std.Format.pretty, Lean.Option.get, Std.Format.format.width],[String]]
[Lean.Xml.Parser.SDDecl,[SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Parsec.skipString, Lean.Xml.Parser.Eq, Lean.Xml.Parser.quote, HOrElse.hOrElse, Lean.Parsec.pstring],[Lean.Parsec, String]]
[instDecidableXor.proof_4,[False],[False]]
[Nat.foldRev,[Nat.foldRev.loop],[]]
[Lean.Parser.Term.macroLastArg.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.macroDollarArg.parenthesizer, Lean.Parser.Term.macroArg.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.InitializedParams.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.InitializedParams.toCtorIdx],[]]
[Lean.Meta.Match.AltLHS.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.AltLHS.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Syntax.MonadTraverser.noConfusionType,[],[]]
[Lean.IR.updateSorryDep,[Bind.bind, StateT.run, Lean.IR.Sorry.collect, Lean.IR.Sorry.State.mk, Lean.IR.CompilerM, Array, Lean.IR.Decl, Pure.pure, Array.map, Lean.IR.Decl.extern, Option.none, Lean.NameMap.find?, Lean.IR.Sorry.State.localSorryMap, Lean.IR.Decl.fdecl, Lean.IR.DeclInfo.mk, Option.some],[Lean.IR.CompilerM, Array, Lean.IR.Decl]]
[Lean.Elab.Tactic.ElabSimpArgsResult.noConfusionType,[],[]]
[Lean.Lsp.instFromJsonInitializeResult,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.ServerCapabilities, Option, Lean.Lsp.ServerInfo, Pure.pure, Lean.Lsp.InitializeResult.mk],[Lean.FromJson, Lean.Lsp.InitializeResult]]
[Id.finally,[MonadFinally.mk, Pure.pure, Prod.mk],[MonadFinally, Id]]
[Lean.NameGenerator.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.NameGenerator.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.NameGenerator.mk, And]]
[Std.instInhabitedAssocList,[Inhabited.mk, Std.AssocList.nil],[Inhabited, Std.AssocList]]
[Lean.Meta.Hypothesis.noConfusionType,[],[]]
[Lean.findDocString?,[Bind.bind, ST.Ref.get, Pure.pure, Option.orElse, Lean.NameMap.find?, Lean.MapDeclarationExtension.find?],[IO, Option, String]]
[Lean.instToJsonNat,[Lean.ToJson.mk, Lean.Json.num, Lean.JsonNumber.fromNat],[Lean.ToJson, Nat]]
[Lean.Elab.Command.StructCtorView.modifiers,[],[Lean.Elab.Modifiers]]
[Lean.Server.Watchdog.terminateFileWorker,[Bind.bind, Lean.Server.Watchdog.findFileWorker!, MonadExcept.tryCatch, liftM, IO.FS.Stream.writeLspMessage, Lean.Server.Watchdog.FileWorker.stdin, Lean.JsonRpc.Message.notification, Option.none, Pure.pure, DoResultPR.pure, PUnit.unit, DoResultPR.return, Lean.Server.Watchdog.ServerM, Unit],[Lean.Server.Watchdog.ServerM, Unit]]
[instShiftRightUInt32,[ShiftRight.mk, UInt32.shiftRight],[ShiftRight, UInt32]]
[Lean.Compiler.uintFoldToNatFns,[List.foldl, List.cons, Prod.mk, Lean.Compiler.NumScalarTypeInfo.toNatFn, Lean.Compiler.foldToNat, List.nil, Lean.Compiler.numScalarTypes],[List, Prod, Lean.Name, Lean.Compiler.UnFoldFn]]
[Lean.MessageData.nest.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MessageData.nest, HAdd.hAdd, OfNat.ofNat]]
[Lean.KeyedDeclsAttribute.defn,[],[Lean.KeyedDeclsAttribute.Def]]
[Lean.Meta.ApplyNewGoals.nonDependentFirst.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.ApplyNewGoals.nonDependentFirst, OfNat.ofNat]]
[Std.HashSetImp.find?,[Option, List.find?, BEq.beq, Array.uget, Subtype.val],[Option]]
[Nat.nat_repr_len_aux,[Eq.mpr, implies_congr, congrArg, LT.lt, Nat.pow_succ, Eq.refl, HDiv.hDiv, HPow.hPow, Iff.mpr, Nat.div_lt_iff_lt_mul],[LT.lt, HDiv.hDiv, HPow.hPow]]
[Lean.IR.Log.toString,[Std.Format.pretty, Lean.IR.Log.format, Std.Format.defWidth],[String]]
[Std.PersistentArray.empty,[Std.PersistentArray.mk],[Std.PersistentArray]]
[Lean.MetavarContext.UnivMVarParamResult.nextParamIdx,[],[Nat]]
[Lean.Parser.Tactic.rotateLeft,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.IR.CompilerState.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.char.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.charLit.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Term.ident.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.StructInst.CtorHeaderResult.ctorFnType,[],[Lean.Expr]]
[instLTFloat,[LT.mk, Float.lt],[LT, Float]]
[Mathlib.Prelude.Rename.addNameAlignment,[Lean.MonadEnv.modifyEnv, Lean.PersistentEnvExtension.addEntry, Mathlib.Prelude.Rename.renameExtension, Prod.mk],[Lean.Core.CoreM, Unit]]
[guardTargetStrict,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Term.NamedArg.ref,[],[Lean.Syntax]]
[Int.instHPowIntNatInt,[HPow.mk, Int.pow],[HPow, Int, Nat]]
[Lean.Elab.Term.Quotation.HeadCheck.other.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.Quotation.HeadCheck.other, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Quotation.HeadCheck.other]]
[tacticCalc_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, calcStep],[Lean.ParserDescr]]
[Lean.Environment.hasUnsafe,[Option.isSome],[Bool]]
[Lean.Parser.Term.doUnless,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.withForbidden, Lean.Parser.termParser, Lean.Parser.Term.doSeq],[Lean.Parser.Parser]]
[UInt8.toUInt64,[Nat.toUInt64, UInt8.toNat],[UInt64]]
[Lean.MonadQuotation.toMonadRef,[],[Lean.MonadRef]]
[Lean.Meta.abstractNestedProofs,[StateRefT'.run', Lean.MonadCacheT.run, ReaderT.run, Lean.Meta.AbstractNestedProofs.visit, Lean.Meta.AbstractNestedProofs.Context.mk, Lean.Meta.AbstractNestedProofs.State.mk, OfNat.ofNat],[Lean.Meta.MetaM, Lean.Expr]]
[IO.withStderr,[Bind.bind, liftM, IO.setStderr, tryFinally, Functor.discard],[]]
[Lean.Meta.Match.Alt.toMessageData,[Lean.Meta.withExistingLocalDecls, Lean.Meta.Match.Alt.fvarDecls, Lean.AddMessageContext.addMessageContext],[Lean.Meta.MetaM, Lean.MessageData]]
[Lean.Parser.Tactic.generalizeHyp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Lsp.instToJsonCompletionList,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.CompletionList.isIncomplete, List.nil, Lean.Lsp.CompletionList.items],[Lean.ToJson, Lean.Lsp.CompletionList]]
[Lean.Lsp.CompletionParams.noConfusionType,[],[]]
[Lean.Meta.Simp.post,[Bind.bind, MonadReader.read, liftM, Lean.Meta.Simp.Methods.post],[Lean.Meta.Simp.M, Lean.Meta.Simp.Step]]
[Lean.Elab.Term.MVarErrorInfo.logError.appendExtra,[Unit.unit, Lean.MessageData, HAppend.hAppend],[Lean.MessageData]]
[Lean.Meta.CaseValuesSubgoal.newHs,[],[Array, Lean.FVarId]]
[Lean.Parser.Term.typeSpec.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[UInt8.decLt,[Decidable, LT.lt, inferInstanceAs],[Decidable, LT.lt]]
[Lean.Parser.Command.whereStructField.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.Term.letDecl.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.ParserModuleContext.env,[],[Lean.Environment]]
[Lean.annotation?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Option, Lean.Expr, ite, Eq, and, BEq.beq, Lean.KVMap.size, OfNat.ofNat, Lean.KVMap.getBool, Bool.false, Bool.true, Option.some, Option.none],[Option, Lean.Expr]]
[Lean.Server.Watchdog.initAndRunWatchdog,[Bind.bind, IO.appPath, liftM, IO.getEnv, Option.none, IO, Unit, Pure.pure, PUnit.unit],[IO, Unit]]
[Std.PShareCommonT.monadShareCommon,[Std.MonadShareCommon.mk, Std.PShareCommonT.withShareCommon],[Std.MonadShareCommon, Std.PShareCommonT]]
[Decidable.iff_iff_not_or_and_or_not,[Eq.mpr, Eq.refl, Iff, And, Or, Not, propext, iff_iff_implies_and_implies, congr, congrArg, Eq.trans, Decidable.imp_iff_not_or, or_comm, congrFun, Iff.rfl],[Iff, And, Or, Not]]
[Lean.IR.ExplicitRC.getVarInfo,[Unit.unit, Lean.IR.ExplicitRC.VarInfo, Std.RBMap.find?, Lean.IR.ExplicitRC.Context.varMap, panicWithPosWithDecl, OfNat.ofNat],[Lean.IR.ExplicitRC.VarInfo]]
[Lean.Meta.GeneralizeArg.noConfusionType,[],[]]
[IO.asTask,[EIO.asTask],[BaseIO, Task, Except, IO.Error]]
[Lean.Elab.Frontend.setParserState,[modify, Lean.Elab.Frontend.State.mk, Lean.Elab.Frontend.State.commandState, Lean.Elab.Frontend.State.cmdPos, Lean.Elab.Frontend.State.commands],[Lean.Elab.Frontend.FrontendM, Unit]]
[Lean.Parser.instInhabitedParserFn,[Inhabited.mk],[Inhabited, Lean.Parser.ParserFn]]
[eq_false,[propext, Iff.intro, absurd, False.elim],[Eq, False]]
[Lean.JsonRpc.instCoeRequestMessage,[Coe.mk, Lean.JsonRpc.Message.request, Lean.JsonRpc.Request.id, Lean.JsonRpc.Request.method, Except.toOption, Lean.Json.toStructured?, Lean.JsonRpc.Request.param],[Coe, Lean.JsonRpc.Request, Lean.JsonRpc.Message]]
[Lean.KernelException.declHasMVars.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.declHasMVars, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KernelException.declHasMVars, And]]
[Lean.Meta.withTransparency,[Lean.Meta.mapMetaM, Lean.Meta.withConfig, Lean.Meta.Config.mk, Lean.Meta.Config.foApprox, Lean.Meta.Config.ctxApprox, Lean.Meta.Config.quasiPatternApprox, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct],[]]
[Lean.Parser.checkPrecFn,[ite, LE.le, Lean.Parser.ParserContext.prec, Lean.Parser.ParserState.mkUnexpectedError, List.nil],[Lean.Parser.ParserFn]]
[Lean.Elab.Term.Do.hasBreakContinue,[Lean.Elab.Term.Do.hasExitPointPred, Lean.Elab.Term.Do.Code.decl, Lean.Elab.Term.Do.Code.reassign, Lean.Elab.Term.Do.Code.joinpoint, Lean.Elab.Term.Do.Code.seq, Lean.Elab.Term.Do.Code.action, Lean.Elab.Term.Do.Code.return, Lean.Elab.Term.Do.Code.ite, Lean.Elab.Term.Do.Code.match, Lean.Elab.Term.Do.Code.jmp, Bool, Bool.true, Bool.false],[Bool]]
[Lean.MessageData.ofSyntax.injEq,[Eq.propIntro, Eq.refl, Lean.MessageData.ofSyntax, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MessageData.ofSyntax]]
[Lean.getExternConstArityExport,[MonadExcept.tryCatch, Bind.bind, Lean.Core.CoreM.toIO, Lean.getExternConstArity, Lean.Core.Context.mk, Lean.Core.State.mk, IO, Option, Nat, Pure.pure, Option.none],[IO, Option, Nat]]
[Lean.Meta.Instances.erased,[],[Std.PHashSet, Lean.Name]]
[Lean.Elab.Term.elabNoindex,[Bind.bind, Lean.Elab.Term.elabTerm, Lean.Syntax.getOp, OfNat.ofNat, Bool.true, Pure.pure, Lean.Meta.DiscrTree.mkNoindexAnnotation],[Lean.Elab.Term.TermElab]]
[Lean.PPContext.env,[],[Lean.Environment]]
[Lean.Parser.Tactic.tacticSeq,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HOrElse.hOrElse, Lean.Parser.Tactic.tacticSeqBracketed, Lean.Parser.Tactic.tacticSeq1Indented, Bool.false],[Lean.Parser.Parser]]
[Std.RBNode.forIn,[Bind.bind, Pure.pure, Std.RBNode.forIn.visit],[]]
[Lean.Parser.Term.letIdDecl.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Term.letIdLhs.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.IR.ExplicitBoxing.BoxingContext.env,[],[Lean.Environment]]
[iff_congr,[Iff.intro, Iff.trans, Iff.symm],[Iff]]
[Lean.ScopedEnvExtension.modifyState,[List.nil, Lean.Environment, Lean.ScopedEnvExtension.StateStack.stateStack, Lean.PersistentEnvExtension.setState, Lean.ScopedEnvExtension.ext, Lean.ScopedEnvExtension.StateStack.mk, List.cons, Lean.ScopedEnvExtension.State.mk, Lean.ScopedEnvExtension.State.state, Lean.ScopedEnvExtension.State.activeScopes, Lean.ScopedEnvExtension.StateStack.scopedEntries, Lean.ScopedEnvExtension.StateStack.newEntries],[Lean.Environment]]
[toLBoolM,[Bind.bind, Pure.pure, Bool.toLBool],[Lean.LBool]]
[Fin.ne_of_val_ne,[absurd, Fin.val_eq_of_eq],[Not, Eq]]
[Lean.IR.ExplicitBoxing.BoxingState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.ExplicitBoxing.BoxingState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.ExplicitBoxing.BoxingState.mk, And]]
[heq_of_eqRec_eq,[heq_of_eq],[HEq]]
[Prod.mk.inj_right,[And.left, Prod.mk.inj],[Function.injective, Prod.mk]]
[System.FilePath.mk.injEq,[Eq.propIntro, Eq.refl, System.FilePath.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, System.FilePath.mk]]
[Lean.Elab.Term.Do.ToTerm.Context.mk.inj,[And.intro],[And, Eq]]
[ByteSliceT.arr,[],[ByteArray]]
[Lean.Elab.Term.elabLetMVar,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.MonadMCtx.getMCtx, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.MetavarContext.findUserName?, Lean.Syntax.getId, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.Term.elabTerm, Option.none, liftM, Lean.Meta.inferType, Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.syntheticOpaque, Lean.Meta.assignExprMVar, Lean.Expr.mvarId!, Pure.pure, Lean.Elab.Term.mkSaveInfoAnnotation, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElab]]
[List.subset_def,[Iff.rfl],[Iff, Subset.subset, Mem.mem]]
[EStateM.bind,[EStateM.Result, EStateM.Result.error],[EStateM]]
[termℤ,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.IR.ExpandResetReuse.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.IR.ExpandResetReuse.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.ExpandResetReuse.Context.mk]]
[Array.mapMUnsafe.map,[ite, LT.lt, Bind.bind, unsafeCast, Array.mapMUnsafe.map, HAdd.hAdd, OfNat.ofNat, Array.uset, lcProof, Pure.pure],[Array, PNonScalar]]
[Lean.Meta.instInhabitedSavedState,[Inhabited.mk, Lean.Meta.SavedState.mk, arbitrary],[Inhabited, Lean.Meta.SavedState]]
[Lean.Meta.RecursorInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.RecursorInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Expr.ReplaceLevelImpl.State.results,[],[Array, Lean.Expr]]
[Lean.EnvExtensionInterface.getState,[],[]]
[Lean.NameTrie,[Lean.PrefixTree, Lean.NamePart, Lean.NamePart.cmp],[]]
[Lean.Parser.Command.instance.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.optNamedPrio.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.Command.declSig.parenthesizer, Lean.Parser.Command.declVal.parenthesizer, Lean.Parser.Command.terminationSuffix.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Term.doPatDecl,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.termParser, Lean.Parser.Term.leftArrow, Lean.Parser.doElemParser, Lean.Parser.optional, Lean.Parser.checkColGt, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Elab.Tactic.elabTermForApply,[ite, Eq, Lean.Syntax.isIdent, Bool.true, Bind.bind, liftM, Lean.Elab.Term.resolveId?, Option.none, Lean.Elab.Tactic.TacticM, Lean.Expr, Pure.pure, Unit.unit, PUnit.unit],[Lean.Elab.Tactic.TacticM, Lean.Expr]]
[Lean.Position.instToExprPosition,[Lean.ToExpr.mk, Lean.mkAppN, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, List.toArray, List.cons, Lean.ToExpr.toExpr, Lean.Position.line, Lean.Position.column],[Lean.ToExpr, Lean.Position]]
[Lean.MessageSeverity.noConfusionType,[noConfusionTypeEnum, Lean.MessageSeverity.toCtorIdx],[]]
[instCommMonoid,[CommMonoid.mk, CommGroup.mul_comm],[CommMonoid]]
[Array.forIn.loop,[Pure.pure],[]]
[String.takeWhile,[Substring.toString, Substring.takeWhile, String.toSubstring],[String]]
[Lean.Elab.DefViewElabHeader.valueStx,[],[Lean.Syntax]]
[Lean.NameHashSet.empty,[Std.HashSet.empty],[Lean.NameHashSet]]
[Lean.Meta.Match.Pattern.toExpr,[Lean.Meta.Match.Pattern.toExpr.visit],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Elab.Term.elabInaccessible,[Bind.bind, Lean.Elab.Term.elabTerm, Lean.Syntax.getOp, OfNat.ofNat, Bool.true, Pure.pure, Lean.mkInaccessible],[Lean.Elab.Term.TermElab]]
[Lean.PrettyPrinter.Delaborator.SubExpr.pos,[],[Lean.PrettyPrinter.Delaborator.Pos]]
[Lean.Meta.RecursorInfo.firstIndexPos,[HSub.hSub, Lean.Meta.RecursorInfo.majorPos, Lean.Meta.RecursorInfo.numIndices],[Nat]]
[command_Lemma___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.LBool.instToStringLBool,[ToString.mk, Lean.LBool.toString],[ToString, Lean.LBool]]
[coeB,[Coe.coe],[]]
[IO.Process.Stdio.noConfusionType,[noConfusionTypeEnum, IO.Process.Stdio.toCtorIdx],[]]
[UInt64.instSemiringUInt64.proof_13,[UInt64.eq_of_val_eq, Eq.mpr, congrArg, Eq, Fin.ofNat', HAdd.hAdd, OfNat.ofNat, Fin.size_positive', UInt64.val, Eq.trans, UInt64.mk, UInt64.one_def, UInt64.add_def],[Eq, Numeric.ofNat, HAdd.hAdd, OfNat.ofNat]]
[WellFoundedRelation.rel,[],[]]
[Lean.Expr.ReplaceLevelImpl.initCache.proof_1,[lcProof],[Eq, Unit, Lean.Expr]]
[Lean.Parser.Command.def,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.declId, Lean.Parser.Command.optDeclSig, Lean.Parser.Command.declVal, Lean.Parser.Command.optDefDeriving, Lean.Parser.Command.terminationSuffix],[Lean.Parser.Parser]]
[Lean.Parser.Tactic.continuity!?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Meta.mkCongrLemma,[Lean.Meta.withReducible, Bind.bind, Lean.mkConstWithLevelParams, Lean.Meta.inferType, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.MetaM, Lean.Meta.CongrLemma, Unit.unit, Lean.Expr.eq?, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Expr.withApp, ite, Eq, and, Lean.Expr.isConst, BEq.beq, Lean.Expr.constName!, Array.size, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.mkCongrLemma.onlyMVarsAt],[Lean.Meta.MetaM, Lean.Meta.CongrLemma]]
[Lean.Parser.Term.doCatchMatch,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.doMatchAlts],[Lean.Parser.Parser]]
[Lean.Parser.Command.abbrev,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.declId, Lean.Parser.Command.optDeclSig, Lean.Parser.Command.declVal],[Lean.Parser.Parser]]
[Lean.instToJsonUSize,[Lean.ToJson.mk, Lean.bignumToJson, USize.toNat],[Lean.ToJson, USize]]
[String.trimLeft,[Substring.toString, Substring.trimLeft, String.toSubstring],[String]]
[if_pos,[Eq, ite, rfl, absurd],[Eq, ite]]
[Lean.Meta.FindOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.FindOptions.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.DefViewElabHeader.binderIds,[],[Array, Lean.Syntax]]
[Std.PersistentArray.Stats.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.PersistentArray.Stats.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.PersistentArray.Stats.mk, And]]
[Lean.Meta.CongrArgKind.fixed.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.CongrArgKind.fixed, OfNat.ofNat]]
[Tactic.Find.tacticFind,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[ulift.up.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, ulift.up, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.classInductive,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.group, Lean.Parser.symbol, Lean.Parser.Command.declId, Lean.Parser.Command.optDeclSig, Lean.Parser.optional, HOrElse.hOrElse, Lean.Parser.many, Lean.Parser.Command.ctor, Lean.Parser.Command.optDeriving],[Lean.Parser.Parser]]
[List.equiv,[Iff, Mem.mem],[]]
[instSubUSize,[Sub.mk, USize.sub],[Sub, USize]]
[Mathlib.Tactic.Lint.isAutoDecl,[ite, Eq, Lean.Name.hasMacroScopes, Bool.true, Pure.pure, Bind.bind, PUnit.unit],[Lean.Core.CoreM, Bool]]
[Lean.Parser.Command.visibility.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.private.formatter, Lean.Parser.Command.protected.formatter],[Lean.PrettyPrinter.Formatter]]
[Subtype.instDecidableEqSubtype.proof_2,[absurd],[False]]
[Lean.PrettyPrinter.Parenthesizer.withForbidden.parenthesizer,[],[Lean.PrettyPrinter.Parenthesizer]]
[Function.partial_inv_left,[Function.is_partial_inv_left, Function.partial_inv_of_injective],[Eq, Function.partial_inv, Option.some]]
[Substring.dropRightWhile,[Substring, Substring.mk],[Substring]]
[Lean.Elab.Term.Do.getLetDeclVars,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, List.toArray, List.cons, Lean.Elab.Term.Do.getLetIdDeclVar, List.nil, Lean.Elab.Term.Do.getLetPatDeclVars, Lean.Elab.Term.Do.getLetEqnsDeclVar, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.TermElabM, Array, Lean.Name]]
[Fin.ofNat',[Fin.mk, HMod.hMod, Nat.mod_lt],[Fin]]
[Lean.Lsp.ProgressParams.mk.inj,[And.intro],[And, Eq]]
[Lean.Constructor.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Command.elabVariable,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Command.runTermElabM, Option.none, Lean.Elab.Term.withAutoBoundImplicit, Lean.Elab.Term.elabBinders, Pure.pure, Unit.unit, ForIn.forIn, PUnit.unit, Lean.Elab.Command.CommandElabM, Bool, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Prod.mk, Array.map, Lean.Syntax.getId, Bool.false, Lean.Elab.Command.getScope, MProd.mk, ForInStep, MProd, Array, Lean.Syntax, Lean.Syntax.isNone, List.toArray, List.cons, List.nil, BEq.beq, Array.any, Array.contains, Array.size, Lean.throwError, Lean.ToMessageData.toMessageData, Option.isSome, ForInStep.yield, Lean.Elab.Command.modifyScope, Lean.Elab.Command.Scope.mk, Lean.Elab.Command.Scope.header, Lean.Elab.Command.Scope.opts, Lean.Elab.Command.Scope.currNamespace, Lean.Elab.Command.Scope.openDecls, Lean.Elab.Command.Scope.levelNames, Lean.Elab.Command.Scope.varUIds, Lean.Elab.Command.Scope.isNoncomputable, Array.mapM, Function.comp, Lean.MonadQuotation.withFreshMacroScope, Lean.MonadQuotation.addMacroScope, Lean.Elab.Command.getBracketedBinderIds, Array.push, Lean.Elab.Command.Scope.varDecls, HAppend.hAppend, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Lean.Parser.FirstTokens.seq,[Lean.Parser.FirstTokens.unknown, Lean.Parser.FirstTokens.tokens, Lean.Parser.FirstTokens.optTokens, Lean.Parser.FirstTokens.epsilon, Lean.Parser.FirstTokens, HAppend.hAppend],[Lean.Parser.FirstTokens]]
[Lean.IR.CtorFieldInfo.object.inj,[],[Eq]]
[Lean.DeclarationRange.charUtf16,[],[Nat]]
[Lean.Elab.logDbgTrace,[Lean.Elab.trace, Lean.Name.mkStr, Lean.Name.anonymous],[Unit]]
[Lean.Meta.Simp.Context.congrLemmas,[],[Lean.Meta.CongrLemmas]]
[Lean.Elab.Structural.ensureNoRecFn,[ite, Eq, Option.isSome, Lean.Expr.find?, Lean.Expr.isConstOf, Bool.true, Bind.bind, Lean.Meta.forEachExpr, Lean.Expr.isAppOf, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Parser.Command.declId,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.symbol, Lean.Parser.sepBy1, Bool.false],[Lean.Parser.Parser]]
[Lean.Elab.Term.Do.ToTerm.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.ToTerm.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.GeneralizeArg.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.GeneralizeArg.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.MVarRenaming.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.MVarRenaming.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.MVarRenaming.mk]]
[le_not_le_of_lt,[And, LE.le, Not, Iff.mp, lt_iff_le_not_le],[And, LE.le, Not]]
[Lean.Server.Watchdog.ServerContext.editDelay,[],[Nat]]
[instDecidableEqSum.proof_6,[],[Sum.noConfusionType, False, Sum.inl, Sum.inr]]
[List.disjoint_nil_right,[Eq.mpr, Eq.refl, List.disjoint, List.nil, propext, List.disjoint_comm, List.disjoint_nil_left],[List.disjoint, List.nil]]
[Lean.Meta.SimpAll.M,[StateRefT', IO.RealWorld, Lean.Meta.SimpAll.State, Lean.Meta.MetaM],[]]
[Lean.Elab.Command.StructView.mk.inj,[And.intro],[And, Eq]]
[List.disjoint_of_disjoint_append_left_right,[And.right, Iff.mp, List.disjoint_append_left],[List.disjoint]]
[IO.FS.Metadata.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FS.Metadata.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.FS.Metadata.mk, And]]
[instMonadExceptOfEST,[inferInstanceAs, MonadExceptOf, EStateM],[MonadExceptOf, EST]]
[Lean.Elab.resolveGlobalConstWithInfos,[Bind.bind, Lean.resolveGlobalConst, Lean.Elab.MonadInfoTree.getInfoState, ite, Eq, Lean.Elab.InfoState.enabled, Bool.true, ForIn.forIn, PUnit.unit, Lean.mkConstWithLevelParams, Lean.Elab.pushInfoLeaf, Lean.Elab.Info.ofTermInfo, Lean.Elab.TermInfo.mk, Lean.Elab.ElabInfo.mk, Lean.Name.anonymous, Lean.LocalContext.empty, Pure.pure, ForInStep.yield],[List, Lean.Name]]
[Lean.ProjectionFunctionInfo.noConfusionType,[],[]]
[Lean.Parsec.peek!,[Bind.bind, Lean.Parsec.peek?, Option.none, Lean.Parsec, Char, Pure.pure, Lean.Parsec.fail, Lean.Parsec.unexpectedEndOfInput],[Lean.Parsec, Char]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.Borrow.ownArg,[Lean.IR.Arg.irrelevant, Lean.IR.Borrow.M, Unit, Lean.IR.Borrow.ownVar, Pure.pure, Unit.unit],[Lean.IR.Borrow.M, Unit]]
[ByteSlice.getOp,[ByteArray.get!, ByteSlice.arr, HAdd.hAdd, ByteSlice.off],[UInt8]]
[Lean.PersistentEnvExtensionDescr.addImportedFn,[],[Lean.ImportM]]
[Lean.Compiler.SpecState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Compiler.SpecState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.numberFnAux,[ite, Eq, String.atEnd, Bool.true, Lean.Parser.ParserState.mkEOIError, List.nil, BEq.beq, Char.ofNat, or, Lean.Parser.binNumberFn, Lean.Parser.ParserState.next, Lean.Parser.octalNumberFn, Lean.Parser.hexNumberFn, Lean.Parser.decimalNumberFn, Lean.Parser.ParserState.setPos, Char.isDigit, Lean.Parser.ParserState.mkError],[Lean.Parser.ParserFn]]
[Lean.MonadStateCacheT.instMonadRefMonadStateCacheT,[inferInstanceAs, Lean.MonadRef, StateT, Std.HashMap],[Lean.MonadRef, Lean.MonadStateCacheT]]
[Lean.ParametricAttributeImpl.toAttributeImplCore,[],[Lean.AttributeImplCore]]
[Lean.Parser.Term.attrKind.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.scoped.parenthesizer, Lean.Parser.Term.local.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[List.union,[List.foldr, List.insert],[List]]
[Lean.Syntax.unsetTrailing,[Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Lean.Syntax, Lean.Syntax.getTailInfo, Lean.Syntax.setTailInfo, Lean.SourceInfo.original, String.toSubstring],[Lean.Syntax]]
[Mathlib.Prelude.Rename.RenameMap.insertPair,[Mathlib.Prelude.Rename.RenameMap, Std.HashMap.insert],[Mathlib.Prelude.Rename.RenameMap]]
[instSizeOf,[SizeOf.mk, default.sizeOf],[SizeOf]]
[Std.Format.tag.inj,[And.intro],[And, Eq]]
[Lean.Elab.Structural.State.mk.inj,[],[Eq]]
[Lean.IR.Checker.M,[ReaderT, Lean.IR.Checker.CheckerContext, ExceptT, String, StateT, Lean.IR.Checker.CheckerState, Id],[]]
[Lean.Server.RequestContext.rpcSessions,[],[Std.RBMap, UInt64, IO.Ref, Lean.Server.FileWorker.RpcSession, Ord.compare]]
[Lean.Export.instOfStateExpr,[Lean.Export.OfState.mk, Lean.Export.State.exprs, Lean.Export.State.mk, Lean.Export.State.names, Lean.Export.State.levels, Lean.Export.State.defs, Lean.Export.State.stk],[Lean.Export.OfState, Lean.Expr]]
[Lean.Meta.SynthInstance.SubgoalsResult.subgoals,[],[List, Lean.Expr]]
[Lean.Elab.ElabInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.MonadOptions.getOptions,[],[Lean.Options]]
[Nat.sub_eq_iff_eq_add,[Iff.intro, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Eq.symm, HSub.hSub, Nat.sub_add_cancel, rfl, Nat.add_sub_cancel],[Iff, Eq, HSub.hSub, HAdd.hAdd]]
[Lean.IR.formatArray,[Array.foldl, HAppend.hAppend, Std.Format.text, Std.ToFormat.format, Std.Format.nil, OfNat.ofNat, Array.size],[Std.Format]]
[Lean.PrettyPrinter.Formatter.charLit.formatter,[Lean.Parser.Term.char.formatter],[Lean.PrettyPrinter.Formatter]]
[String.length_eq_list_length,[of_eq_true, eq_self, List.length],[Eq, String.length, String.mk, List.length]]
[Lean.ParserCompiler.Context.combinatorAttr,[],[Lean.ParserCompiler.CombinatorAttribute]]
[Array.allDiff,[OfNat.ofNat],[Bool]]
[Lean.Json.Structured.obj.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Json.Structured.obj, HAdd.hAdd, OfNat.ofNat]]
[StateRefT'.get,[ST.Ref.get],[StateRefT']]
[Lean.Expr.ReplaceImpl.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.ReplaceImpl.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Expr.ReplaceImpl.State.mk, And]]
[Lean.IR.EmitC.emitUnbox,[Bind.bind, Lean.IR.EmitC.emitLhs, Unit.unit, Lean.IR.IRType.uint8, Lean.IR.IRType.uint16, Lean.IR.IRType.irrelevant, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.struct, Lean.IR.IRType.union, Lean.IR.EmitC.M, Unit, Lean.IR.EmitC.emit],[Lean.IR.EmitC.M, Unit]]
[Lean.Meta.ToHide.State.modified,[],[Bool]]
[«term↑_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Term.elabPanic,[Bind.bind, Lean.Elab.getRefPosition, Lean.MonadEnv.getEnv, Lean.Elab.Term.getDeclName?, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Quote.quote, ToString.toString, Lean.Environment.mainModule, Lean.Position.line, Lean.Position.column],[Lean.Elab.Term.TermElab]]
[Lean.instToJsonJsonNumber,[Lean.ToJson.mk, Lean.Json.num],[Lean.ToJson, Lean.JsonNumber]]
[Lean.Meta.SimpLemmas.addConst,[Bind.bind, Lean.getConstInfo, Lean.Meta.withReducible, Lean.Meta.inferType, Lean.Meta.isProp, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Meta.forallTelescopeReducing, not, Lean.Expr.isEq, or, ForIn.forIn, Lean.Meta.MetaM, ForInStep, Array, Lean.Meta.SimpLemma, Lean.Meta.mkAuxLemma, Lean.ConstantInfo.levelParams, Lean.Meta.instantiateMVars, Lean.Meta.withNewMCtxDepth, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.whnfR, Unit.unit, Lean.Expr.eq?, Lean.Meta.DiscrTree.mkPath, Prod.mk, Lean.mkConst, List.map, Lean.mkLevelParam, List.toArray, List.nil, Option.some, ForInStep.yield, List.cons, Array.foldl, Lean.Meta.addSimpLemmaEntry, OfNat.ofNat, Array.size],[Lean.Meta.MetaM, Lean.Meta.SimpLemmas]]
[Nat.succ_add,[Eq, HAdd.hAdd, Nat.succ, rfl, congrArg, PProd.fst],[Eq, HAdd.hAdd, Nat.succ]]
[Lean.JsonRpc.instLTRequestID,[LT.mk, Eq, Lean.JsonRpc.RequestID.str, Lean.JsonRpc.RequestID.num, Lean.JsonRpc.RequestID.null, Bool, Decidable.decide, LT.lt, Bool.true, Bool.false],[LT, Lean.JsonRpc.RequestID]]
[Int.sign_mul_natAbs,[Unit.unit, Eq, HMul.hMul, Int.sign, Int.ofNat, Int.natAbs, Int.one_mul, HAdd.hAdd, OfNat.ofNat, rfl, Eq.symm, Int.neg_eq_neg_one_mul, Int.negSucc],[Eq, HMul.hMul, Int.sign, Int.ofNat, Int.natAbs]]
[Int.mul_zero,[Eq, HMul.hMul, OfNat.ofNat, rfl],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.MonadHashMapCacheAdapter.instMonadCache,[Lean.MonadCache.mk, Lean.MonadHashMapCacheAdapter.findCached?, Lean.MonadHashMapCacheAdapter.cache],[Lean.MonadCache]]
[Lean.Elab.Term.StructInst.DefaultFields.getFieldValue?,[List.findSome?, ite, Eq, BEq.beq, Lean.Elab.Term.StructInst.DefaultFields.getFieldName, Bool.true, Lean.Elab.Term.StructInst.Field.expr?, Option.none, Lean.Elab.Term.StructInst.Struct.fields],[Option, Lean.Expr]]
[Lean.getAliasState,[Lean.SimplePersistentEnvExtension.getState, Lean.aliasExtension],[Lean.AliasState]]
[Std.PersistentHashSet.set,[],[Std.PersistentHashMap, Unit]]
[Lean.IR.instToFormatDecl,[Std.ToFormat.mk, Lean.IR.formatDecl, OfNat.ofNat],[Std.ToFormat, Lean.IR.Decl]]
[Lean.Meta.InjectionResult.subgoal.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.InjectionResult.subgoal, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.CancelParams.id,[],[Lean.JsonRpc.RequestID]]
[Lean.MacroScopesView.name,[],[Lean.Name]]
[or.right_comm,[Eq.mpr, Eq.refl, Iff, Or, propext, or_assoc, or_comm, Iff.rfl],[Iff, Or]]
[Lean.Elab.Term.PatternElabException.mk.inj,[And.intro],[And, Eq]]
[LT.noConfusionType,[],[]]
[List.disjoint_cons_left,[Iff.trans, List.disjoint_append_left, of_eq_true, Eq.trans, congrFun, congrArg, Iff, And, propext, List.singleton_disjoint, List.disjoint, Not, Mem.mem, iff_self],[Iff, List.disjoint, List.cons, And, Not, Mem.mem]]
[Lean.IR.EmitC.emitFnDecl,[Bind.bind, Lean.IR.EmitC.toCName, Lean.IR.Decl.name, Lean.IR.EmitC.emitFnDeclAux],[Lean.IR.EmitC.M, Unit]]
[Lean.Elab.Term.StructInst.CtorHeaderResult.instMVars,[],[Array, Lean.MVarId]]
[Nat.mul_sub_div,[],[Eq, HDiv.hDiv, HSub.hSub, HMul.hMul, Nat.succ]]
[USize.instSemiringUSize.proof_13,[USize.eq_of_val_eq, Eq.mpr, congrArg, Eq, Fin.ofNat', HAdd.hAdd, OfNat.ofNat, Fin.size_positive', USize.val, Eq.trans, USize.mk, USize.one_def, USize.add_def],[Eq, Numeric.ofNat, HAdd.hAdd, OfNat.ofNat]]
[Lean.fieldIdxKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Lean.Parser.tokenFn,[ite, Eq, String.atEnd, Bool.true, Lean.Parser.ParserState.mkEOIError, BEq.beq, Lean.Parser.TokenCacheEntry.startPos, Lean.Parser.ParserState.setPos, Lean.Parser.TokenCacheEntry.stopPos, Lean.Parser.ParserState.mk, Option.some, Lean.Parser.ParserState, Array.size, OfNat.ofNat, Lean.Parser.ParserCache.mk, Lean.Parser.TokenCacheEntry.mk, Option.none],[Lean.Parser.ParserFn]]
[Lean.Elab.Command.elabDeclaration,[Unit.unit, Lean.Elab.Command.CommandElabM, Unit, Lean.Elab.Command.expandDeclNamespace?, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Elab.Command.withMacroExpansion, Lean.Elab.Command.elabCommand, Lean.Elab.elabModifiers, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, BEq.beq, Bool.true, Lean.Elab.Command.elabAxiom, Lean.Elab.Command.elabInductive, Lean.Elab.Command.elabClassInductive, Lean.Elab.Command.elabStructure, Lean.Elab.Command.isDefLike, Lean.Elab.Command.elabMutualDef, Lean.Elab.Command.getTerminationHints, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Elab.Command.CommandElab]]
[Std.HashMap.toArray,[Std.HashMap.fold, Array.push, Prod.mk, List.toArray, List.nil],[Array, Prod]]
[Lean.ExprStructEq.instToStringExprStructEq,[ToString.mk, ToString.toString, Lean.ExprStructEq.val],[ToString, Lean.ExprStructEq]]
[Subtype.existsOfSubtype,[Subtype.existsOfSubtype.proof_1],[Exists]]
[Nat.succ_sub,[Exists.elim, Nat.le.dest, Eq.mpr, Eq.refl, Eq, HSub.hSub, Nat.succ, Eq.symm, HAdd.hAdd, Nat.add_sub_cancel_left, Nat.add_succ, rfl],[Eq, HSub.hSub, Nat.succ]]
[Lean.MessageData.node.inj,[],[Eq]]
[Lean.Meta.smartUnfoldingReduce?,[OptionT.run, Lean.Meta.smartUnfoldingReduce?.go, Lean.Meta.smartUnfoldingReduce?.goMatch],[Lean.Meta.MetaM, Option, Lean.Expr]]
[Lean.Meta.Simp.Config.singlePass,[],[Bool]]
[Lean.Elab.Term.instInhabitedSavedState,[Inhabited.mk, Lean.Elab.Term.SavedState.mk, arbitrary],[Inhabited, Lean.Elab.Term.SavedState]]
[AndOp.noConfusionType,[],[]]
[Lean.Elab.Tactic.MkSimpContextResult.dischargeWrapper,[],[Lean.Elab.Tactic.Simp.DischargeWrapper]]
[Lean.PrettyPrinter.Parenthesizer.strLit.parenthesizer,[Lean.Parser.Term.str.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Command.State.nextMacroScope,[],[Nat]]
[Lean.Syntax.instForInTopDownSyntax,[ForIn.mk, Bind.bind, Inhabited.mk, Pure.pure, Lean.Syntax.instForInTopDownSyntax.loop],[ForIn, Lean.Syntax.TopDown, Lean.Syntax]]
[Lean.IR.UnreachableBranches.Value.noConfusionType,[],[]]
[Lean.Name.quickLt,[BEq.beq, Lean.Name.quickCmp, Ordering.lt],[Bool]]
[Lean.Meta.ElimAltInfo.name,[],[Lean.Name]]
[Std.HashSetImp.erase,[Std.HashSetImp, ite, Eq, List.contains, Bool.true, Std.HashSetImp.mk, HSub.hSub, OfNat.ofNat, Std.HashSetBucket.update, List.erase],[Std.HashSetImp]]
[Array.findIdx?.loop.proof_2,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, OfNat.ofNat, Array.size, Eq.symm, Nat.add_comm, Nat.add_assoc, rfl],[Eq, HAdd.hAdd, OfNat.ofNat, Array.size]]
[Lean.Expr.isAutoParam,[Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat],[Bool]]
[Lean.Meta.instBEqInstanceEntry,[BEq.mk, BEq.beq, Lean.Meta.InstanceEntry.val],[BEq, Lean.Meta.InstanceEntry]]
[Lean.Elab.CompletionInfo.format,[Lean.Elab.CompletionInfo.namespaceId, Lean.Elab.CompletionInfo.option, Lean.Elab.CompletionInfo.endSection, Lean.Elab.CompletionInfo.tactic, IO, Std.Format, Bind.bind, Lean.Elab.TermInfo.format, Pure.pure, HAppend.hAppend, Std.ToFormat.format, Lean.Elab.ContextInfo.runMetaM, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Lean.Elab.CompletionInfo.stx],[IO, Std.Format]]
[Lean.IR.UnreachableBranches.instToStringValue,[ToString.mk, ToString.toString, Std.ToFormat.format],[ToString, Lean.IR.UnreachableBranches.Value]]
[Lean.Server.Watchdog.ServerContext.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Command.macroRhs.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Std.AssocList.forIn.loop,[Pure.pure, Bind.bind, Prod.mk, PProd.fst],[]]
[Lean.JsonNumber.shiftl,[Lean.JsonNumber, Lean.JsonNumber.mk, HMul.hMul, Int.ofNat, HPow.hPow, OfNat.ofNat, HSub.hSub],[Lean.JsonNumber]]
[Lean.commitWhenSome?,[Bind.bind, Lean.MonadBacktrack.saveState, MonadExcept.tryCatch, Unit.unit, Option, Pure.pure, Option.some, Lean.MonadBacktrack.restoreState, Option.none, MonadExcept.throw],[Option]]
[Lean.Elab.Command.instInhabitedScope,[Inhabited.mk, Lean.Elab.Command.Scope.mk, arbitrary],[Inhabited, Lean.Elab.Command.Scope]]
[Lean.Meta.SimpEntry.lemma.inj,[],[Eq]]
[Lean.IR.EmitC.emitProj,[Bind.bind, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn],[Lean.IR.EmitC.M, Unit]]
[Lean.Meta.Closure.State.exprFVarArgs,[],[Array, Lean.Expr]]
[Char.toLower,[ite, And, GE.ge, OfNat.ofNat, LE.le, Char.ofNat, HAdd.hAdd],[Char]]
[Lean.Parser.Command.restateAxiom,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.unary],[Lean.ParserDescr]]
[Lean.Elab.TermInfo.isBinder,[],[Bool]]
[Lean.JsonRpc.Notification.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.JsonRpc.Notification.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.instDivNat,[Div.mk, Nat.div],[Div, Nat]]
[Lean.Parser.Module.import.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.IndPredBelow.Context.motives,[],[Array, Prod, Lean.Name, Lean.Expr]]
[Lean.Elab.Term.Arg.expr.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.Arg.expr, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Arg.expr]]
[Lean.Compiler.CSimp.Entry.noConfusionType,[],[]]
[Lean.Server.FileWorker.SemanticTokensState.data,[],[Array, Nat]]
[not_and_self,[False],[Not, And]]
[Lean.IR.LocalContextEntry.joinPoint.inj,[And.intro],[And, Eq]]
[Lean.Elab.Info.ofCommandInfo.inj,[],[Eq]]
[instCommSemigroup,[CommSemigroup.mk, CommMonoid.mul_comm],[CommSemigroup]]
[Lean.MonadStateCacheT.instMonadMonadStateCacheT,[inferInstanceAs, Monad, StateT, Std.HashMap],[Monad, Lean.MonadStateCacheT]]
[Lean.IR.Borrow.instToStringParamMap,[ToString.mk, Std.Format.pretty, Std.ToFormat.format, Std.Format.defWidth],[ToString, Lean.IR.Borrow.ParamMap]]
[Lean.Level.below,[PUnit, PProd],[]]
[Lean.Xml.Parser.Comment,[SeqLeft.seqLeft, SeqRight.seqRight, Lean.Parsec.skipString, Functor.map, Array.foldl, String.append, OfNat.ofNat, Array.size, Lean.Parsec.many, HOrElse.hOrElse, Bind.bind, Lean.Parsec.pchar, Char.ofNat, Pure.pure, HAppend.hAppend, Char.toString],[Lean.Parsec, String]]
[Lean.Expr.isOptParam,[Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat],[Bool]]
[decidable_eq_inr_neg,[Eq, Decidable.isFalse, absurd, Eq.refl, proof_irrel],[Eq, Decidable.isFalse]]
[Lean.Elab.Term.MatchAltView.rhs,[],[Lean.Syntax]]
[Lean.Xml.Parser.EntityDecl,[HOrElse.hOrElse, Lean.Xml.Parser.GEDecl, Lean.Xml.Parser.PEDecl],[Lean.Parsec, Unit]]
[Lean.DefinitionSafety.toCtorIdx,[OfNat.ofNat],[Nat]]
[iff_self_and,[Eq.mpr, Eq.refl, Iff, And, propext, Iff.comm, and_iff_left_iff_imp, Iff.rfl],[Iff, And]]
[decPropToBool,[CoeDep.mk, Decidable.decide],[CoeDep, Bool]]
[getModify,[MonadState.modifyGet, Prod.mk],[]]
[Lean.Parser.Tactic.«tacticHave'__:=_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Lsp.instToJsonDocumentSelector,[Lean.ToJson.mk, Lean.ToJson.toJson],[Lean.ToJson, Lean.Lsp.DocumentSelector]]
[Lean.Elab.Term.StructInst.throwFailedToElabField,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.TermElabM]]
[Lean.Lsp.TextDocumentSyncOptions.change,[],[Lean.Lsp.TextDocumentSyncKind]]
[Mathlib.Tactic.Lint.NamedLinter.toLinter,[],[Mathlib.Tactic.Lint.Linter]]
[Lean.Server.FileWorker.workerMain,[Bind.bind, liftM, IO.getStdin, IO.getStdout, IO.getStderr, MonadExcept.tryCatch, Functor.map, Function.comp, UInt64.toNat, ByteArray.toUInt64LE!, IO.getRandomBytes, OfNat.ofNat, IO.setRandSeed, Lean.Server.FileWorker.initAndRunWorker, IO.FS.Stream.flush, IO.Process.exit, UInt32.toUInt8, Pure.pure, DoResultPR.pure, PUnit.unit, IO.FS.Stream.putStrLn, HAppend.hAppend, ToString.toString, DoResultPR.return, IO, UInt32],[IO, UInt32]]
[Lean.Parser.Tactic.contradiction,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.NameTrie.forM,[Lean.NameTrie.forMatchingM, Lean.Name.anonymous],[Unit]]
[Lean.Server.FileWorker.ElabTaskError.aborted.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Server.FileWorker.ElabTaskError.aborted, OfNat.ofNat]]
[Lean.Lsp.DidChangeTextDocumentParams.contentChanges,[],[Array, Lean.Lsp.TextDocumentContentChangeEvent]]
[bfix2,[PProd.fst],[]]
[Lean.JsonRpc.Message.notification.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.JsonRpc.Message.notification, HAdd.hAdd, OfNat.ofNat]]
[PointedType.type,[],[]]
[Lean.Elab.MacroExpansionInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.Export.Entry.defn.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Export.Entry.defn, HAdd.hAdd, OfNat.ofNat]]
[Lean.MonadError.noConfusionType,[],[]]
[Lean.Parser.Syntax.addPrec,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Parsec.instMonadParsec,[Monad.mk],[Monad, Lean.Parsec]]
[Lean.SMap.noConfusionType,[],[]]
[Lean.Elab.Term.LetRecView.decls,[],[Array, Lean.Elab.Term.LetRecDeclView]]
[Lean.Parser.Attr.instance.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.priorityParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.DocumentFilter.noConfusionType,[],[]]
[Lean.Name.hashEx,[Lean.Name.hash],[UInt64]]
[Lean.IR.LitVal.num.injEq,[Eq.propIntro, Eq.refl, Lean.IR.LitVal.num, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.LitVal.num]]
[ByteArray.uget,[UInt8, Array.uget],[UInt8]]
[Lean.Elab.Term.Do.ToTerm.Kind.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.MetavarKind.synthetic.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.MetavarKind.synthetic, OfNat.ofNat]]
[Lean.Lsp.DocumentHighlight.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.instToStringIRType,[ToString.mk, Function.comp, ToString.toString, Std.ToFormat.format],[ToString, Lean.IR.IRType]]
[Lean.Widget.InfoPopup.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Widget.InfoPopup.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Widget.InfoPopup.mk, And]]
[CoeTail.noConfusionType,[],[]]
[Lean.Parser.syntaxParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Formatter]]
[Setoid.r,[],[]]
[Lean.Elab.Term.Do.mkIte,[Bind.bind, Lean.Elab.Term.Do.homogenize, Lean.Elab.Term.TermElabM, Lean.Elab.Term.Do.CodeBlock, Pure.pure, Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.ite, Lean.Elab.Term.Do.CodeBlock.code, Lean.Elab.Term.Do.CodeBlock.uvars],[Lean.Elab.Term.TermElabM, Lean.Elab.Term.Do.CodeBlock]]
[Bool.or_self,[rfl, Eq.symm, Eq.refl],[Eq, or]]
[Decidable.le_iff_lt_or_eq,[Iff.intro, Decidable.lt_or_eq_of_le, le_of_lt_or_eq],[Iff, LE.le, Or, LT.lt, Eq]]
[Lean.IR.isTailCallTo,[Lean.IR.FnBody.vdecl, Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.fap, Lean.IR.FnBody.jdecl, Lean.IR.FnBody.set, Lean.IR.FnBody.setTag, Lean.IR.FnBody.uset, Lean.IR.FnBody.sset, Lean.IR.FnBody.inc, Lean.IR.FnBody.dec, Lean.IR.FnBody.del, Lean.IR.FnBody.mdata, Lean.IR.FnBody.case, Lean.IR.FnBody.ret, Lean.IR.Arg.irrelevant, Lean.IR.FnBody.jmp, Lean.IR.FnBody.unreachable, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Bool, and, BEq.beq, Bool.false],[Bool]]
[instHashableInt,[Hashable.mk, UInt64, UInt64.ofNat, HMul.hMul, OfNat.ofNat, HAdd.hAdd],[Hashable, Int]]
[Lean.Parser.Term.forInMacro.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Declaration.inductDecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Declaration.inductDecl, HAdd.hAdd, OfNat.ofNat]]
[instSubsingletonDecidable,[instSubsingletonDecidable.proof_1],[Subsingleton, Decidable]]
[Lean.instEvalIO,[Lean.Eval.mk, Bind.bind, Unit.unit, Lean.Eval.eval, Bool.true],[Lean.Eval, IO]]
[Lean.Elab.Deriving.DecEq.mkMatch,[Bind.bind, Lean.Elab.Deriving.mkDiscrs, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.Elab.Deriving.DecEq.mkMatch.mkSameCtorRhs, Lean.Elab.Deriving.DecEq.mkMatch.mkAlts],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[ExceptT.ext,[id],[Eq]]
[Lean.Elab.Term.ToParserDescrContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.ToParserDescrContext.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.explicitUniv.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkStackTop.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.levelParser.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Term.doReturn.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.checkLineEq.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Term.matchDiscr,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.atomic, Lean.Parser.Term.ident, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, Lean.Parser.termParser],[Lean.Parser.Parser]]
[as_false,[ite, False, True],[]]
[ofNat_eq_ofNat,[rfl],[Eq, Numeric.ofNat, OfNat.ofNat]]
[ExceptCpsT.instMonadExceptCpsT,[Monad.mk],[Monad, ExceptCpsT]]
[pow_mul,[of_eq_true, Eq.trans, congr, congrArg, Eq, HPow.hPow, HMul.hMul, Nat.zero_eq, Nat.mul_zero, pow_zero, eq_self, OfNat.ofNat, Eq.mpr, Eq.refl, Nat.succ, Nat.mul_succ, HAdd.hAdd, pow_add, pow_succ', pow_mul_comm, rfl],[Eq, HPow.hPow, HMul.hMul]]
[Equiv.refl,[Equiv.mk, id, Equiv.refl.proof_1, Equiv.refl.proof_2],[Equiv]]
[Lean.Syntax.asNode,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.SyntaxNode, Subtype.mk, Lean.Syntax.node, Lean.IsNode.mk, Lean.mkNullNode, List.toArray, List.nil, Lean.Syntax.asNode.proof_1],[Lean.SyntaxNode]]
[Lean.Parser.Term.binrel_no_prop.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Command.declaration.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Command.declModifiers.formatter, Bool.false, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.abbrev.formatter, Lean.Parser.Command.def.formatter, Lean.Parser.Command.theorem.formatter, Lean.Parser.Command.constant.formatter, Lean.Parser.Command.instance.formatter, Lean.Parser.Command.axiom.formatter, Lean.Parser.Command.example.formatter, Lean.Parser.Command.inductive.formatter, Lean.Parser.Command.classInductive.formatter, Lean.Parser.Command.structure.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.IR.Borrow.mkInitParamMap,[StateT.run', SeqRight.seqRight, Lean.IR.Borrow.InitParamMap.visitDecls, MonadState.get, EmptyCollection.emptyCollection],[Lean.IR.Borrow.ParamMap]]
[Lean.throwError,[Bind.bind, Lean.MonadRef.getRef, Lean.AddErrorMessageContext.add, MonadExcept.throw, Lean.Exception.error],[]]
[Lean.Meta.SimpEntry.lemma.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SimpEntry.lemma, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.set_option,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident, Lean.Parser.ppSpace, Lean.Parser.Command.optionValue, Lean.Parser.Tactic.tacticSeq],[Lean.Parser.Parser]]
[Lean.Meta.CongrTheorem.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.CongrTheorem.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.EmitC.getJPParams,[Bind.bind, MonadReader.read, Unit.unit, Lean.IR.EmitC.M, Array, Lean.IR.Param, Std.HashMap.find?, Lean.IR.EmitC.Context.jpMap, Pure.pure, MonadExcept.throw],[Lean.IR.EmitC.M, Array, Lean.IR.Param]]
[Lean.Server.Watchdog.watchdogMain,[Bind.bind, liftM, IO.getStdin, IO.getStdout, IO.getStderr, MonadExcept.tryCatch, Lean.Server.Watchdog.initAndRunWatchdog, Pure.pure, OfNat.ofNat, IO.FS.Stream.putStrLn, HAppend.hAppend, ToString.toString],[IO, UInt32]]
[Lean.IR.IRType.usize.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.IR.IRType.usize, OfNat.ofNat]]
[Lean.Meta.Cache.defEqDefault,[],[Lean.Meta.DefEqCache]]
[Lean.Parser.Term.depArrow.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Lean.Parser.unicodeSymbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.StructureFieldInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.StructureFieldInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.StructureFieldInfo.mk, And]]
[Lean.NameHashSet.instInhabitedNameHashSet,[Inhabited.mk, EmptyCollection.emptyCollection],[Inhabited, Lean.NameHashSet]]
[UInt16.mod,[UInt16.mk, HMod.hMod, UInt16.val],[UInt16]]
[Lean.Lsp.SemanticTokens.data,[],[Array, Nat]]
[Lean.instReprMetavarKind,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone],[Repr, Lean.MetavarKind]]
[Lean.Meta.Simp.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.PrettyPrinter.Formatter.errorAtSavedPos.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[Lean.DelayedMetavarAssignment.noConfusionType,[],[]]
[Lean.Elab.Term.Do.ToTerm.breakToTerm,[Bind.bind, MonadReader.read, Lean.Elab.Term.Do.ToTerm.mkUVarTuple, Unit.unit, Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax, Lean.Elab.Term.Do.ToTerm.Context.kind, panicWithPosWithDecl, OfNat.ofNat, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom],[Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax]]
[Lean.Lsp.DocumentSymbolParams.textDocument,[],[Lean.Lsp.TextDocumentIdentifier]]
[Semiring.nsmul,[],[]]
[Option.isNone,[Unit.unit, Bool, Bool.false, Bool.true],[Bool]]
[Semiring.noConfusionType,[],[]]
[Lean.Parser.Tactic.eraseAuxDiscrs,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.maxPrec, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Server.FileWorker.handleRpcRelease,[Bind.bind, MonadState.get, Option.none, Lean.Server.FileWorker.WorkerM, Unit, Std.RBMap.find?, Lean.Server.FileWorker.WorkerState.rpcSessions, Lean.Lsp.RpcReleaseParams.sessionId, ST.Ref.get, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield, liftM, Lean.Server.FileWorker.RpcSession.keptAlive, ST.Ref.set],[Lean.Server.FileWorker.WorkerM, Unit]]
[Mathlib.Tactic.Lint.formatLinterResults,[Bind.bind, Array.filterMapM, Lean.Core.CoreM, Option, Lean.MessageData, ite, Eq, not, Std.HashMap.isEmpty, Bool.true, Mathlib.Tactic.Lint.groupedByFilename, Mathlib.Tactic.Lint.printWarnings, Mathlib.Tactic.Lint.LintVerbosity.high, Pure.pure, Option.some, HAppend.hAppend, Lean.ToMessageData.toMessageData, Mathlib.Tactic.Lint.Linter.noErrorsFound, Mathlib.Tactic.Lint.NamedLinter.toLinter, Option.none, OfNat.ofNat, Array.size, Array.filterM, Mathlib.Tactic.Lint.isAutoDecl],[Lean.Core.CoreM, Lean.MessageData]]
[Lean.Parser.Command.notation,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.attrKind, Lean.Parser.symbol, Lean.Parser.optPrecedence, Lean.Parser.Command.optNamedName, Lean.Parser.Command.optNamedPrio, Lean.Parser.many, Lean.Parser.Command.notationItem, Lean.Parser.darrow, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.BinderInfo.toUInt64,[Unit.unit, UInt64, OfNat.ofNat],[UInt64]]
[Setoid.trans,[Equivalence.trans, Setoid.iseqv],[HasEquiv.Equiv]]
[Lean.Elab.Term.SavedContext.openDecls,[],[List, Lean.OpenDecl]]
[instAndOpUInt16,[AndOp.mk, UInt16.land],[AndOp, UInt16]]
[Lean.Lsp.SemanticTokensRangeParams.range,[],[Lean.Lsp.Range]]
[Lean.getPPSafeShadowing,[Lean.KVMap.get, Lean.Option.name, Lean.pp.safeShadowing, Lean.Option.defValue],[Bool]]
[Lean.Meta.instMonadLCtxMetaM,[Lean.MonadLCtx.mk, Bind.bind, MonadReader.read, Pure.pure, Lean.Meta.Context.lctx],[Lean.MonadLCtx, Lean.Meta.MetaM]]
[Lean.JsonRpc.ErrorCode.methodNotFound.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.JsonRpc.ErrorCode.methodNotFound, OfNat.ofNat]]
[List.toByteArray,[ByteArray.empty, List.toByteArray.loop],[ByteArray]]
[UInt64.val_eq_of_lt,[Fin.val_eq_of_lt],[Eq, Fin.val, UInt64.val, UInt64.ofNat]]
[Lean.Parser.Tactic.elementwise!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Elab.Command.runLinters,[Bind.bind, ST.Ref.get, Lean.Elab.Command.lintersRef, ite, Eq, Array.isEmpty, Bool.true, Pure.pure, PUnit.unit, ForIn.forIn, MonadState.get, tryFinally, MonadExcept.tryCatch, Lean.Elab.logException, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, ForInStep.yield],[Lean.Elab.Command.CommandElabM, Unit]]
[Lean.DataValue.sameCtor,[Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Lsp.SemanticTokenType.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Parser.ParserCache.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.ParserCache.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.ParserCache.mk]]
[Lean.Parser.ModuleParserState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.ModuleParserState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.mkIdent,[Lean.Syntax.ident, List.nil],[Lean.Syntax]]
[Lean.Elab.Term.mkAuxName,[Bind.bind, MonadReader.read, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Name, Lean.Elab.Term.Context.declName?, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.mkAuxName, HAppend.hAppend, OfNat.ofNat],[Lean.Elab.Term.TermElabM, Lean.Name]]
[Mathlib.Tactic.Lint.instReprLintVerbosity,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone],[Repr, Mathlib.Tactic.Lint.LintVerbosity]]
[Lean.Parser.Command.structure.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.structureTk.parenthesizer, Lean.Parser.Command.classTk.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Bool.false, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.extends.parenthesizer, Lean.Parser.Term.optType.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.structCtor.parenthesizer, Lean.Parser.Command.structFields.parenthesizer, Lean.Parser.Command.optDeriving.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.withSynthesize,[MonadFunctorT.monadMap, Bind.bind, MonadState.get, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, List.nil, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState, tryFinally, Lean.Elab.Term.synthesizeSyntheticMVars, Bool.false, ite, Eq, and, Bool.true, Pure.pure, PUnit.unit, HAppend.hAppend, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.TermElabM],[]]
[Lean.Declaration.axiomDecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Declaration.axiomDecl, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.LetRecToLift.mvarId,[],[Lean.MVarId]]
[Lean.Lsp.ServerCapabilities.referencesProvider,[],[Bool]]
[reprArg,[Repr.reprPrec, OfNat.ofNat],[Std.Format]]
[Lean.Parser.Tactic.hGeneralize!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.binderIdent, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[USize.instSemiringUSize.proof_11,[Eq.mpr, congr, congrArg, Eq, Eq.trans, HMul.hMul, USize.add_def, USize.mul_def, USize.mk, HAdd.hAdd, USize.val, USize.eq_of_val_eq, Semiring.mul_add],[Eq, HMul.hMul, HAdd.hAdd]]
[Lean.Lsp.TextDocumentContentChangeEvent.rangeChange.inj,[And.intro],[And, Eq]]
[Lean.IR.Expr.hasFreeVar,[Lean.IR.HasIndex.visitExpr, Lean.IR.VarId.idx],[Bool]]
[Lean.Lsp.instToJsonSemanticTokensLegend,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.SemanticTokensLegend.tokenTypes, List.nil, Lean.Lsp.SemanticTokensLegend.tokenModifiers],[Lean.ToJson, Lean.Lsp.SemanticTokensLegend]]
[Lean.RecursorVal.k,[],[Bool]]
[USize.sub_def,[rfl],[Eq, HSub.hSub, USize.mk, USize.val]]
[Lean.Elab.Command.«termDelta%_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Term.TermElabResult,[EStateM.Result, Lean.Exception, Lean.Elab.Term.SavedState],[]]
[Lean.Parser.Term.doCatch,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.Term.binderIdent, Lean.Parser.optional, Lean.Parser.termParser, Lean.Parser.darrow, Lean.Parser.Term.doSeq],[Lean.Parser.Parser]]
[Lean.Parser.Command.structure,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, HOrElse.hOrElse, Lean.Parser.Command.structureTk, Lean.Parser.Command.classTk, Lean.Parser.Command.declId, Lean.Parser.many, Lean.Parser.ppSpace, Lean.Parser.Term.bracketedBinder, Bool.false, Lean.Parser.optional, Lean.Parser.Command.extends, Lean.Parser.Term.optType, Lean.Parser.symbol, Lean.Parser.Command.structCtor, Lean.Parser.Command.structFields, Lean.Parser.Command.optDeriving],[Lean.Parser.Parser]]
[CoeSort.noConfusionType,[],[]]
[Lean.Elab.Term.LVal.getOp.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LVal.getOp, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.LVal.getOp, And]]
[instReprUnit,[Repr.mk, Std.Format.text],[Repr, Unit]]
[Lean.Elab.Term.elabEnsureTypeOf,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Syntax.isStrLit?, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.throwIllFormedSyntax, Bind.bind, Lean.Elab.Term.elabTerm, Option.none, Bool.true, liftM, Lean.Meta.inferType, Lean.Elab.Term.elabTermEnsuringType, Option.some],[Lean.Elab.Term.TermElab]]
[Lean.Message.severity,[],[Lean.MessageSeverity]]
[IO.Error.inappropriateType.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.inappropriateType, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.export.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.many1.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Tactic.expandOptLocation,[ite, Eq, Lean.Syntax.isNone, Bool.true, Lean.Elab.Tactic.Location.targets, List.toArray, List.nil, Lean.Elab.Tactic.expandLocation, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Elab.Tactic.Location]]
[Lean.Parser.Tactic.Conv.convArgs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Int.neg_zero,[rfl],[Eq, Neg.neg, OfNat.ofNat]]
[Lean.Elab.DerivingClassView.applyHandlers,[Lean.withRef, Lean.Elab.DerivingClassView.ref, Lean.Elab.applyDerivingHandlers, Lean.Elab.DerivingClassView.className, Lean.Elab.DerivingClassView.args?],[Lean.Elab.Command.CommandElabM, Unit]]
[Lean.Parser.Tactic.tacticTrivial,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Elab.Info.ofCommandInfo.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Info.ofCommandInfo, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Info.ofCommandInfo]]
[Lean.EnvironmentHeader.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.EnvironmentHeader.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.GoalsAtResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.GoalsAtResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.GoalsAtResult.mk, And]]
[Lean.Parser.Term.optSemicolon,[Lean.Parser.ppDedent, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.symbol, Lean.Parser.ppLine],[Lean.Parser.Parser]]
[Setoid.refl,[Equivalence.refl, Setoid.iseqv],[HasEquiv.Equiv]]
[Lean.Lsp.DeclarationParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.DeclarationParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.delabSigma,[Lean.PrettyPrinter.Delaborator.delabSigmaCore, Bool.true],[Lean.PrettyPrinter.Delaborator.Delab]]
[decidable_of_decidable_of_eq,[decidable_of_decidable_of_iff, Eq.to_iff],[Decidable]]
[Lean.Parsec.pure,[Lean.Parsec.ParseResult.success],[Lean.Parsec]]
[Lean.Expr.ReplaceLevelImpl.cache,[Bind.bind, modify, Lean.Expr.ReplaceLevelImpl.State.mk, Array.uset, Lean.Expr.ReplaceLevelImpl.State.keys, Lean.Expr.ReplaceLevelImpl.cache.proof_1, Lean.Expr.ReplaceLevelImpl.State.results, Lean.Expr.ReplaceLevelImpl.cache.proof_2, Pure.pure],[Lean.Expr.ReplaceLevelImpl.ReplaceM, Lean.Expr]]
[Lean.Meta.DiscrTree.Trie.noConfusionType,[],[]]
[Lean.Parser.throwUnknownParserCategory,[MonadExcept.throw, HAppend.hAppend, ToString.toString],[ExceptT, String, Id]]
[Subrelation.accessible.proof_1,[Acc.intro],[Acc]]
[instBEqOption,[BEq.mk, Unit.unit, Option.none, Option.some, Bool, Bool.true, and, BEq.beq, Bool.false],[BEq, Option]]
[Iff.comm,[Iff.intro, Iff.symm],[Iff]]
[Lean.Meta.FunInfoCache,[Std.PersistentHashMap, Lean.Meta.InfoCacheKey, Lean.Meta.FunInfo],[]]
[implies.trans,[],[implies]]
[System.SearchPath.separator,[ite, Eq, System.Platform.isWindows, Bool.true, Char.ofNat],[Char]]
[Lean.Parser.optPrecedence,[Lean.Parser.optional, Lean.Parser.atomic, Lean.Parser.precedence],[Lean.Parser.Parser]]
[Std.RBTree.insert,[Std.RBMap.insert, Unit.unit],[Std.RBTree]]
[Lean.Meta.CaseValuesSubgoal.mvarId,[],[Lean.MVarId]]
[imp_and_distrib,[Iff.intro, And.intro, And.left, And.right],[Iff, And]]
[List.mem_erase_of_ne,[Eq.mpr, Eq.refl, Iff, Mem.mem, List.erase, List.erase_eq_erasep, List.mem_erasep_of_neg, Ne.symm],[Iff, Mem.mem, List.erase]]
[Lean.Lsp.CancelParams.mk.inj,[],[Eq]]
[Lean.addProjectionFnInfo,[Lean.MapDeclarationExtension.insert, Lean.projectionFnInfoExt, Lean.ProjectionFunctionInfo.mk],[Lean.Environment]]
[Lean.IR.mmodifyJPs,[Array.mapM, Lean.IR.FnBody.vdecl, Lean.IR.FnBody.set, Lean.IR.FnBody.setTag, Lean.IR.FnBody.uset, Lean.IR.FnBody.sset, Lean.IR.FnBody.inc, Lean.IR.FnBody.dec, Lean.IR.FnBody.del, Lean.IR.FnBody.mdata, Lean.IR.FnBody.case, Lean.IR.FnBody.ret, Lean.IR.FnBody.jmp, Lean.IR.FnBody.unreachable, Lean.IR.FnBody, Bind.bind, Pure.pure, Lean.IR.FnBody.jdecl],[Array, Lean.IR.FnBody]]
[Lean.Parser.Command.decreasingBy.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.terminationHint.formatter, Lean.Parser.Tactic.tacticSeq.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.IR.EmitC.Context.env,[],[Lean.Environment]]
[Lean.Elab.Tactic.evalInjections,[Lean.Elab.Tactic.liftMetaTactic, Bind.bind, Lean.Meta.injections, OfNat.ofNat, Unit.unit, Lean.Meta.MetaM, List, Lean.MVarId, Pure.pure, List.nil, List.cons],[Lean.Elab.Tactic.Tactic]]
[IO.Process.output,[Bind.bind, IO.Process.spawn, IO.Process.SpawnArgs.mk, IO.Process.StdioConfig.mk, IO.Process.StdioConfig.stdin, IO.Process.SpawnArgs.toStdioConfig, IO.Process.Stdio.piped, IO.Process.SpawnArgs.cmd, IO.Process.SpawnArgs.args, IO.Process.SpawnArgs.cwd, IO.Process.SpawnArgs.env, liftM, IO.asTask, IO.FS.Handle.readToEnd, IO.Process.Child.stdout, Task.Priority.dedicated, IO.Process.Child.stderr, IO.Process.Child.wait, IO.ofExcept, Task.get, Pure.pure, IO.Process.Output.mk],[IO, IO.Process.Output]]
[Nat.«term_^[_]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.LocalInstance.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.LocalInstance.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.ParserInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.Decl.extern.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Decl.extern, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.ParserState.next,[Lean.Parser.ParserState.mk, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.lhsPrec, String.next, Lean.Parser.ParserState.cache, Lean.Parser.ParserState.errorMsg],[Lean.Parser.ParserState]]
[Lean.Xml.Parser.SystemLiteral,[HOrElse.hOrElse, SeqLeft.seqLeft, SeqRight.seqRight, Lean.Parsec.pchar, Char.ofNat, Lean.Parsec.manyChars, Lean.Parsec.satisfy, Decidable.decide, Ne, Pure.pure],[Lean.Parsec, String]]
[Lean.Lsp.Trace.toCtorIdx,[OfNat.ofNat],[Nat]]
[ExistsUnique.intro,[Exists.intro, And.intro],[ExistsUnique]]
[Lean.LeanPaths.srcPath,[],[Lean.SearchPath]]
[Lean.Expr.Data.hasExprMVar,[BEq.beq, UInt64.land, UInt64.shiftRight, OfNat.ofNat],[Bool]]
[Nat.gcd_succ,[rfl],[Eq, Nat.gcd, Nat.succ, HMod.hMod]]
[Lean.Expr.natAdd?,[Lean.Expr.app2?, Lean.Name.mkStr, Lean.Name.anonymous],[Option, Prod, Lean.Expr]]
[Fin.instOfNatFinHAdd,[OfNat.mk, Fin.ofNat],[OfNat, Fin]]
[forall₂_congr,[forall_congr'],[Iff]]
[Exists.choose_spec,[Classical.choose_spec],[Exists.choose]]
[Lean.Elab.Term.instMonadMacroAdapterTermElabM,[Lean.Elab.MonadMacroAdapter.mk, Lean.MonadQuotation.getCurrMacroScope, Bind.bind, getThe, Lean.Core.State, Pure.pure, Lean.Core.State.nextMacroScope, modifyThe, Lean.Core.State.mk, Lean.Core.State.env, Lean.Core.State.ngen, Lean.Core.State.traceState],[Lean.Elab.MonadMacroAdapter, Lean.Elab.Term.TermElabM]]
[Lean.Lsp.instToJsonDefinitionParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.DefinitionParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position],[Lean.ToJson, Lean.Lsp.DefinitionParams]]
[Lean.SMap.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.SMap.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.SMap.mk, And]]
[Int.negOfNat_eq_subNatNat_zero,[Unit.unit, Eq, Int.negOfNat, Int.subNatNat, OfNat.ofNat, rfl],[Eq, Int.negOfNat, Int.subNatNat, OfNat.ofNat]]
[Lean.Parser.Priority.numPrio,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.numLit],[Lean.Parser.Parser]]
[Lean.Parser.Level.max,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.nonReservedSymbol, Lean.Parser.many1, Lean.Parser.ppSpace, Lean.Parser.levelParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[Lean.Meta.Simp.Methods.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Command.elabAxiom,[Lean.Elab.Command.CommandElabM, Unit, Bind.bind, Lean.Elab.Command.getLevelNames, Lean.Elab.Command.expandDeclId, Lean.Elab.addDeclarationRanges, Lean.Elab.Command.runTermElabM, Option.some, Lean.Elab.Term.withLevelNames, Lean.Elab.Term.elabBinders, Lean.Syntax.getArgs, Lean.Elab.Term.applyAttributesAt, Lean.Elab.Modifiers.attrs, Lean.AttributeApplicationTime.beforeElaboration, Lean.Elab.Term.elabType, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Bool.false, liftM, Lean.Meta.instantiateMVars, Lean.Meta.mkForallFVars, Bool.true, Lean.Elab.Term.levelMVarToParam, OfNat.ofNat, Lean.Elab.Term.TermElabM, Lean.Elab.sortDeclLevelParams, Lean.throwErrorAt, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Elab.Term.ensureNoUnassignedMVars, Lean.addDecl, Lean.Elab.withSaveInfoContext, Lean.mkConstWithLevelParams, Lean.Elab.Term.addTermInfo, Option.none, Lean.Name.anonymous, Lean.AttributeApplicationTime.afterTypeChecking, Lean.MonadEnv.getEnv, ite, Eq, Lean.isExtern, Lean.compileDecl, Pure.pure, PUnit.unit],[Lean.Elab.Command.CommandElabM, Unit]]
[Lean.SyntaxNode.getIdAt,[Lean.Syntax.getId, Lean.SyntaxNode.getArg],[Lean.Name]]
[Subtype.exists,[Iff.intro, Exists, Subtype.mk, Exists.intro],[Iff, Exists, Subtype.mk]]
[Lean.LevelSet,[Std.HashSet, Lean.Level],[]]
[Lean.PrettyPrinter.Delaborator.unexpandRegularApp,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Pure.pure, Lean.PrettyPrinter.Delaborator.unfoldMDatas, Lean.Expr.getAppFn, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Lean.MonadEnv.getEnv, Lean.KeyedDeclsAttribute.getValues, Lean.PrettyPrinter.Delaborator.appUnexpanderAttribute, List.firstM, EStateM.Result.error, EStateM.run, Unit.unit, Alternative.failure, panicWithPosWithDecl, OfNat.ofNat],[Lean.PrettyPrinter.Delaborator.Delab]]
[List.intersperse,[Unit.unit, List.cons, List, List.nil, PProd.fst],[List]]
[Lean.Elab.Command.Scope.header,[],[String]]
[Lean.Expr.getForallBody,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, PProd.fst, PProd.snd],[Lean.Expr]]
[Lean.Meta.SynthInstance.MkTableKey.State.emap,[],[Std.HashMap, Lean.MVarId, Lean.Expr]]
[Lean.Meta.Match.Problem.noConfusionType,[],[]]
[Lean.Lsp.TextDocumentEdit.edits,[],[Lean.Lsp.TextEditBatch]]
[Lean.Meta.SortLocalDecls.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SortLocalDecls.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Simp.Config.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Simp.Config.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Simp.Config.mk, And]]
[FloatArray.instEmptyCollectionFloatArray,[EmptyCollection.mk, FloatArray.empty],[EmptyCollection, FloatArray]]
[Int.subNatNat_eq_coe,[Int.subNatNat_elim, Eq, HSub.hSub, Int.ofNat, Eq.mpr, congrArg, Eq.trans, congrFun, Int.ofNat_add, Int.sub_eq_add_neg, Int.add_assoc, Neg.neg, Int.add_left_comm, HAdd.hAdd, Int.add_right_neg, rfl, congr, Int.negSucc_ofNat_coe, OfNat.ofNat, Int.neg_add, Eq.symm, Eq.refl, Int.ofNat_sub, Nat.le_refl, Nat.sub_self, Int.ofNat_zero, Int.zero_add],[Eq, Int.subNatNat, HSub.hSub, Int.ofNat]]
[Mathlib.Tactic.Lint.getAllDecls,[Bind.bind, Mathlib.Tactic.Lint.getDeclsInCurrModule, Lean.MonadEnv.getEnv, Pure.pure, HAppend.hAppend, Array.map, Prod.fst, Std.HashMap.toArray, Lean.SMap.map₁, Lean.Environment.constants],[Lean.Core.CoreM, Array, Lean.Name]]
[Nat.add_sub_of_le,[Eq, HAdd.hAdd, HSub.hSub, Eq.mpr, Eq.refl, Eq.symm, Nat.add_sub_cancel_left, rfl],[Eq, HAdd.hAdd, HSub.hSub]]
[Lean.Parser.Tactic.Conv.nestedTacticCore,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Prod.RProdSubLex,[Prod.RProdSubLex.proof_1],[Prod.Lex]]
[Lean.Server.FileWorker.handleNotification,[dite, Eq, Unit.unit, Eq.symm, Lean.Server.FileWorker.WorkerM, Unit, Lean.Lsp.DidChangeTextDocumentParams, Lean.Lsp.instFromJsonDidChangeTextDocumentParams, Lean.Server.FileWorker.handleDidChange, Lean.Lsp.CancelParams, Lean.Lsp.instFromJsonCancelParams, Lean.Server.FileWorker.handleCancelRequest, Lean.Lsp.RpcReleaseParams, Lean.Lsp.instFromJsonRpcReleaseParams, Lean.Server.FileWorker.handleRpcRelease, Lean.Lsp.RpcKeepAliveParams, Lean.Lsp.instFromJsonRpcKeepAliveParams, Lean.Server.FileWorker.handleRpcKeepAlive, liftM, IO.throwServerError, HAppend.hAppend, ToString.toString],[Lean.Server.FileWorker.WorkerM, Unit]]
[Lean.Elab.Term.Do.DoIfView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.DoIfView.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Expr.withAppRev,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, PProd.fst, Array.push, Array.mkEmpty, Lean.Expr.getAppNumArgs],[]]
[Lean.Parser.Term.termBeforeDo.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withForbidden.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.MVarErrorKind.custom.inj,[],[Eq]]
[Lean.Elab.elabDeclAttrs,[Lean.Elab.elabAttrs, Lean.Syntax.getSepArgs, Lean.Syntax.getOp, OfNat.ofNat],[Array, Lean.Elab.Attribute]]
[Lean.Parser.Tactic.tidy?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Lsp.TextDocumentIdentifier.uri,[],[Lean.Lsp.DocumentUri]]
[Tactic.Ring.Cache.cs,[],[Lean.Expr]]
[Lean.Parser.Term.namedArgument,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.IR.findEnvDecl',[Unit.unit, Option, Lean.IR.Decl, Array.find?, BEq.beq, Lean.IR.Decl.name, Option.some, Lean.SMap.find?, Lean.SimplePersistentEnvExtension.getState, Lean.IR.declMapExt],[Option, Lean.IR.Decl]]
[Lean.Meta.injections,[Lean.Meta.withMVarContext, Bind.bind, Lean.MonadLCtx.getLCtx, Array.toList, Lean.Meta.injections.go],[Lean.Meta.MetaM, Option, Lean.MVarId]]
[Lean.Parser.Term.waitIfTypeContainsMVar.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Server.FileWorker.SemanticTokensContext.snap,[],[Lean.Server.Snapshots.Snapshot]]
[instCommMonoid_1.proof_3,[Semiring.npow_zero'],[Eq, Semiring.npow, OfNat.ofNat]]
[Lean.Parser.Tactic.tauto!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Term.dbgTrace.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.interpolatedStr.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Lean.Parser.Term.optSemicolon.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.mkHEqSymm,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.heq?, Lean.Meta.getLevel, Lean.mkApp5, Lean.mkConst, List.cons, List.nil, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Level.PP.Result.imaxNode.inj,[],[Eq]]
[Lean.Elab.Term.StructInst.Struct.mk.sizeOf_spec,[congrFun, congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.refl, List.nil, Eq.trans, congr, Lean.Elab.Term.StructInst.FieldVal.term, Lean.Elab.Term.StructInst.FieldVal.nested, Lean.Elab.Term.StructInst.FieldVal.default, Eq.symm, Lean.Elab.Term.StructInst.Field.mk.sizeOf_spec, List.cons.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Elab.Term.StructInst.Struct.mk, HAdd.hAdd, OfNat.ofNat]]
[Std.PersistentArray.Stats.mk.inj,[And.intro],[And, Eq]]
[Lean.DefinitionSafety.safe.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.DefinitionSafety.safe, OfNat.ofNat]]
[modifyThe,[MonadStateOf.modifyGet, Prod.mk, PUnit.unit],[PUnit]]
[Lean.Xml.Parser.EncodingDecl,[Bind.bind, SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Parsec.skipString, Lean.Xml.Parser.Eq, Lean.Xml.Parser.quote, Lean.Xml.Parser.EncName],[Lean.Parsec, String]]
[Lean.Parser.Tactic.expandRwSeq,[Lean.Parser.Tactic.rwWithRfl, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Macro]]
[Lean.Meta.FVarIdToLemmaId,[Lean.FVarIdMap, Lean.Name],[]]
[Lean.IR.mkParam,[Lean.IR.Param.mk],[Lean.IR.Param]]
[USize.instRingUSize.proof_3,[congrArg, USize.mk, Ring.gsmul_succ', USize.val],[Eq, USize.mk, Ring.gsmul, Int.ofNat, Nat.succ, USize.val]]
[Lean.Lsp.DocumentSymbolResult.syms,[],[Array, Lean.Lsp.DocumentSymbol]]
[Lean.QuotVal.kind,[],[Lean.QuotKind]]
[Lean.Parser.Command.declSig.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.simpleBinderWithoutType.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Bool.false, Lean.Parser.Term.typeSpec.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.getPPStructureInstances,[Lean.KVMap.get, Lean.Option.name, Lean.pp.structureInstances, not, Lean.getPPAll],[Bool]]
[Int.instOfNatInt,[OfNat.mk, Int.ofNat],[OfNat, Int]]
[Lean.Lsp.instFileSourceHoverParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.HoverParams.toTextDocumentPositionParams],[Lean.Lsp.FileSource, Lean.Lsp.HoverParams]]
[String.Iterator.curr,[Char, String.get],[Char]]
[Lean.Meta.mkLevelErrorMessage,[Unit.unit, Lean.Meta.MetaM, Lean.MessageData, Lean.Meta.PostponedEntry.ctx?, Pure.pure, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.Meta.PostponedEntry.lhs, Lean.Meta.PostponedEntry.rhs, Lean.Meta.withLCtx, Lean.Meta.DefEqContext.lctx, Lean.Meta.DefEqContext.localInstances, Bind.bind, Lean.Meta.instantiateMVars, Lean.Meta.DefEqContext.lhs, Lean.Meta.DefEqContext.rhs, MonadExcept.tryCatch, Lean.Meta.inferType, Lean.AddMessageContext.addMessageContext, Lean.MessageData.ofExpr],[Lean.Meta.MetaM, Lean.MessageData]]
[Lean.Lsp.DocumentSymbolAux.range,[],[Lean.Lsp.Range]]
[Lean.EnvExtension,[Lean.EnvExtensionInterface.ext, Lean.EnvExtensionInterfaceImp],[]]
[Lean.Parser.Command.abbrev.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.Command.optDeclSig.formatter, Lean.Parser.Command.declVal.formatter],[Lean.PrettyPrinter.Formatter]]
[List.mem_nil_iff,[Iff.rfl],[Iff, Mem.mem, List.nil, False]]
[Function.comp_const_right,[rfl],[Eq, Function.comp, Function.const]]
[Lean.Meta.SynthInstance.State.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.matchAltsWhereDecls.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.whereDecls.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.MonadHashMapCacheAdapter.getCache,[],[Std.HashMap]]
[Lean.PrettyPrinter.runForNodeKind,[Bind.bind, Lean.MonadEnv.getEnv, List.nil, Lean.Core.CoreM, Lean.KeyedDeclsAttribute.getValues, Pure.pure, Lean.getConstInfo, ite, Eq, or, Lean.Expr.isConstOf, Lean.ConstantInfo.type, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.evalConst, Lean.ParserDescr, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.KeyedDeclsAttribute.Def.name, Lean.KeyedDeclsAttribute.defn],[Lean.Core.CoreM]]
[Lean.IR.Expr.sproj.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.sproj, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Expr.sproj, And]]
[instDecidableLe_3,[UInt64.decLe],[Decidable, LE.le]]
[Lean.Core.instMonadLiftIOCoreM,[MonadLift.mk, Lean.Core.liftIOCore],[MonadLift, IO, Lean.Core.CoreM]]
[Nat.decidable_dvd.proof_1,[Iff.symm, Nat.dvd_iff_mod_eq_zero],[Iff, Eq, HMod.hMod, OfNat.ofNat, Dvd.dvd]]
[Lean.Parser.PrattParsingTables.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.Do.mkJmp,[Bind.bind, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.liftMacroM, Lean.mkIdentFrom, Lean.Elab.Term.Do.addFreshJP, Pure.pure, Lean.Elab.Term.Do.Code.jmp],[StateRefT', IO.RealWorld, Array, Lean.Elab.Term.Do.JPDecl, Lean.Elab.Term.TermElabM, Lean.Elab.Term.Do.Code]]
[Lean.Compiler.SpecArgKind.fixedNeutral.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Compiler.SpecArgKind.fixedNeutral, OfNat.ofNat]]
[Nat.coprime_zero_left,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, Eq, Nat.gcd_zero_left, OfNat.ofNat, iff_self],[Iff, Nat.coprime, OfNat.ofNat, Eq]]
[Lean.Meta.AbstractNestedProofs.State.noConfusionType,[],[]]
[Except.ok.injEq,[Eq.propIntro, Eq.refl, Except.ok, Eq.symm, eq_of_heq, HEq.refl],[Eq, Except.ok]]
[Lean.BinderInfo.isStrictImplicit,[Lean.BinderInfo.default, Lean.BinderInfo.implicit, Unit.unit, Lean.BinderInfo.instImplicit, Lean.BinderInfo.auxDecl, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Elab.Command.CollectAxioms.State.mk.inj,[And.intro],[And, Eq]]
[Lean.AttributeImpl.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.AttributeImpl.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Match.Pattern.ibelow,[True, And],[]]
[Lean.Meta.Match.Example.arrayLit.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Example.arrayLit, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.Example.arrayLit]]
[heq_of_heq_of_eq,[HEq.trans, heq_of_eq],[HEq]]
[Lean.PrettyPrinter.Delaborator.delabFVar,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, MonadExcept.tryCatch, liftM, Lean.Meta.getLocalDecl, Lean.PrettyPrinter.Delaborator.maybeAddBlockImplicit, Lean.mkIdent, Lean.LocalDecl.userName, Lean.FVarId.name, panicWithPosWithDecl, OfNat.ofNat],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.ScopedEnvExtension.Entry.global.inj,[],[Eq]]
[Lean.Declaration.foldExprM,[Unit.unit, Pure.pure, Bind.bind, List.foldlM, Lean.ConstantVal.type, Lean.DefinitionVal.toConstantVal, Lean.DefinitionVal.value, Lean.InductiveType.type, Lean.Constructor.type, Lean.InductiveType.ctors],[]]
[Lean.IR.Checker.markJP,[Lean.IR.Checker.markIndex, Lean.IR.JoinPointId.idx],[Lean.IR.Checker.M, Unit]]
[Lean.ClassEntry.hasOutParam,[],[Bool]]
[Lean.Lsp.MarkupContent.noConfusionType,[],[]]
[Lean.Parser.Command.resolve_name.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Xml.Content.Comment.inj,[],[Eq]]
[Lean.Level.hasParamEx,[Lean.Level.hasParam],[Bool]]
[Lean.Elab.Term.Do.Code.return.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.Code.return, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.explicitBoxing,[Bind.bind, Lean.IR.getEnv, Pure.pure, Lean.IR.ExplicitBoxing.run],[Lean.IR.CompilerM, Array, Lean.IR.Decl]]
[Nat.mul_assoc,[Eq, HMul.hMul, rfl],[Eq, HMul.hMul]]
[Lean.Lsp.TextDocumentChangeRegistrationOptions.noConfusionType,[],[]]
[Lean.Parser.Tactic.casesType!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Exception.internal.inj,[And.intro],[And, Eq]]
[Std.PersistentHashMap.Stats.maxDepth,[],[Nat]]
[Lean.Meta.Simp.Step.result,[Lean.Meta.Simp.Result],[Lean.Meta.Simp.Result]]
[coeSortToCoeTail,[CoeTail.mk, CoeSort.coe],[CoeTail]]
[Semiring.nsmul_zero',[],[Eq, Semiring.nsmul, OfNat.ofNat]]
[Or.imp_left,[Or.imp, id],[Or]]
[Lean.Parser.Tactic.async,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.MessageData.nest.inj,[And.intro],[And, Eq]]
[Function.inv_fun_on_pos,[],[And, Mem.mem, Function.inv_fun_on, Eq]]
[strictAnd,[and],[Bool]]
[Nat.lt_add_of_pos_left,[Eq.mpr, Eq.refl, LT.lt, HAdd.hAdd, Nat.add_comm, Nat.lt_add_of_pos_right],[LT.lt, HAdd.hAdd]]
[UInt32.instSemiringUInt32.proof_8,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt32.one_def, UInt32.mul_def, UInt32.mk, OfNat.ofNat, mul_one, UInt32.val, UInt32.mk_val_eq, eq_self, propext, forall_const, UInt32],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.LocalDecl.ldecl.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.LocalDecl.ldecl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.LocalDecl.ldecl, And]]
[Lean.Elab.Tactic.Conv.mkConvGoalFor,[Bind.bind, Lean.Meta.inferType, Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.natural, Lean.Name.anonymous, Lean.Meta.mkEq, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Pure.pure, Prod.mk],[Lean.Meta.MetaM, Prod, Lean.Expr]]
[Lean.Lsp.Location.noConfusionType,[],[]]
[instReprSubstring,[Repr.mk, Std.Format.text, HAppend.hAppend, String.quote, Substring.toString],[Repr, Substring]]
[Lean.Lsp.SemanticTokensOptions.range,[],[Bool]]
[«term_∪_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Meta.throwTypeExcepted,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr],[Lean.Meta.MetaM]]
[Nat.lt_trans,[Nat.le_trans, Nat.le_step],[LT.lt]]
[Lean.Elab.Tactic.ElimApp.State.noConfusionType,[],[]]
[USize.instAddCommSemigroupUSize.proof_1,[congrArg, USize.mk, AddCommSemigroup.add_comm, USize.val],[Eq, USize.mk]]
[Lean.Elab.Tactic.Conv.getLhs,[Bind.bind, Lean.Elab.Tactic.Conv.getLhsRhs, Pure.pure, Prod.fst],[Lean.Elab.Tactic.TacticM, Lean.Expr]]
[Lean.Parser.Term.doSeqBracketed.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withoutPosition.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.doSeqItem.parenthesizer, Lean.Parser.ppLine.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Preorder.le_trans,[],[LE.le]]
[List.leftpad_length,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.length_append, List.repeat, HSub.hSub, List.length, HAdd.hAdd, List.length_repeat, Nat.sub_add_eq_max, max, eq_self],[Eq, List.length, List.leftpad, max]]
[Function.injective.dite,[],[Function.injective, dite, Subtype.mk]]
[Lean.PrettyPrinter.Delaborator.delabMData,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Option.none, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Lean.inaccessible?, Lean.PrettyPrinter.Delaborator.SubExpr.withMDataExpr, Lean.PrettyPrinter.Delaborator.delab, MonadReader.read, ite, Eq, Lean.PrettyPrinter.Delaborator.Context.inPattern, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.MonadOptions.getOptions, and, Lean.isLetFun, Lean.getPPNotation, Lean.PrettyPrinter.Delaborator.delabLetFun, Lean.isLHSGoal?, Lean.PrettyPrinter.Delaborator.SubExpr.withAppFn, Lean.PrettyPrinter.Delaborator.SubExpr.withAppArg, Lean.PrettyPrinter.Delaborator.withMDataOptions],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.Server.Watchdog.ServerEvent.workerEvent.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.Watchdog.ServerEvent.workerEvent, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.Watchdog.ServerEvent.workerEvent, And]]
[cast_proof_irrel,[rfl],[Eq, cast]]
[Lean.Widget.MsgToInteractive.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Widget.MsgToInteractive.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Widget.MsgToInteractive.mk, And]]
[Mathlib.Tactic.Lint.heuristicallyExtractSimpLemmas,[Mathlib.Tactic.Lint.heuristicallyExtractSimpLemmasCore, Mathlib.Tactic.Lint.constToSimpDeclMap],[Array, Lean.Name]]
[Equiv.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Equiv.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Equiv.mk, And]]
[Lean.Elab.TermInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.TermInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.TermInfo.mk, And]]
[Function.left_inverse.comp_eq_id,[funext],[Eq, Function.comp, id]]
[Lean.Macro.withIncRecDepth,[Bind.bind, MonadReader.read, Unit.unit, Lean.MacroM, BEq.beq, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth, MonadExcept.throw, Lean.Macro.Exception.error, Lean.maxRecDepthErrorMessage, MonadWithReader.withReader, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope, HAdd.hAdd, OfNat.ofNat, Lean.Macro.Context.ref],[Lean.MacroM]]
[UInt8.instRingUInt8.proof_4,[congrArg, UInt8.mk, SubNegMonoid.gsmul_neg', UInt8.val],[Eq, UInt8.mk, Ring.gsmul, Int.negSucc, UInt8.val]]
[Std.Format.instAppendFormat,[Append.mk, Std.Format.append],[Append, Std.Format]]
[Lean.Meta.modifyPostponed,[modify, Lean.Meta.State.mk, Lean.Meta.State.mctx, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed],[Lean.Meta.MetaM, Unit]]
[UInt32.instSemigroupUInt32,[Semigroup.mk, UInt32.instSemigroupUInt32.proof_1],[Semigroup, UInt32]]
[Lean.Elab.Term.isSaveInfoAnnotation?,[Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous],[Option, Lean.Expr]]
[Lean.Elab.Frontend.getInputContext,[Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Frontend.Context.inputCtx],[Lean.Elab.Frontend.FrontendM, Lean.Parser.InputContext]]
[Lean.Elab.Term.elabLetTmpDecl,[Lean.Elab.Term.elabLetDeclCore, Bool.true, Bool.false],[Lean.Elab.Term.TermElab]]
[Lean.Meta.MatcherApp.uElimPos?,[],[Option, Nat]]
[LinearOrder.toPartialOrder,[],[PartialOrder]]
[Lean.Elab.Term.LValResolution.getOp.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.LValResolution.getOp, HAdd.hAdd, OfNat.ofNat]]
[Lean.mkApp7,[Lean.mkApp3, Lean.mkApp4],[Lean.Expr]]
[Lean.Elab.mkFreshInstanceName,[Lean.Name.appendIndexAfter, HAppend.hAppend, Lean.Environment.mainModule, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Name]]
[Lean.IR.reshapeWithoutDead,[Lean.IR.FnBody.freeIndices, Lean.IR.reshapeWithoutDead.reshape],[Lean.IR.FnBody]]
[Lean.Elab.DefViewElabHeader.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.DefViewElabHeader.mk, HAdd.hAdd, OfNat.ofNat]]
[Function.uncurry_apply_pair,[rfl],[Eq, Function.uncurry, Prod.mk]]
[Lean.Parser.Tactic.rintroPat.quot,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[UInt64.shiftLeft,[UInt64.mk, HShiftLeft.hShiftLeft, UInt64.val, UInt64.modn, OfNat.ofNat],[UInt64]]
[Lean.isPrivateNameFromImportedModule,[Option.none, Bool, Lean.privateToUserName?, bne, Lean.mkPrivateName, Bool.false],[Bool]]
[IO.Error.mkPermissionDeniedFile,[Function.comp, IO.Error.permissionDenied, Option.some],[IO.Error]]
[String.mapTokens,[Function.comp, String.intercalate, String.singleton, List.map, String.split, Decidable.decide, Eq],[String]]
[Lean.Elab.instToFormatAttribute,[Std.ToFormat.mk, Std.Format.bracket, HAppend.hAppend, Std.ToFormat.format, Lean.Elab.Attribute.name, ToString.toString, Lean.Elab.Attribute.stx],[Std.ToFormat, Lean.Elab.Attribute]]
[Lean.Server.FileWorker.handleHover,[Bind.bind, Lean.Server.RequestM.readDoc, Lean.Server.RequestM.withWaitFindSnap, Decidable.decide, GT.gt, Lean.Server.Snapshots.Snapshot.endPos, Pure.pure, Option.none, Lean.Server.RequestM, Option, Lean.Lsp.Hover, Lean.Elab.InfoTree.hoverableInfoAt?, Lean.Server.Snapshots.Snapshot.infoTree, liftM, Lean.Elab.Info.fmtHover?, Option.some, ToString.toString, Option.get!, Lean.Elab.Info.pos?, Lean.Elab.Info.tailPos?, PUnit.unit],[Lean.Server.RequestM, Lean.Server.RequestTask, Option, Lean.Lsp.Hover]]
[Lean.getPPAnalyzeExplicitHoles,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.explicitHoles, Lean.Option.defValue],[Bool]]
[Ne,[Not, Eq],[]]
[Lean.Meta.SynthInstance.wakeUp,[Unit.unit, Lean.Meta.SynthInstance.SynthM, Unit, ite, Eq, BEq.beq, Lean.Meta.AbstractMVarsResult.numMVars, Lean.Meta.SynthInstance.Answer.result, OfNat.ofNat, Bool.true, modify, Lean.Meta.SynthInstance.State.mk, Option.some, Lean.Meta.SynthInstance.State.generatorStack, Lean.Meta.SynthInstance.State.resumeStack, Lean.Meta.SynthInstance.State.tableEntries, Bind.bind, liftM, Lean.Meta.openAbstractMVarsResult, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Meta.SynthInstance.State.result?, Array.push, Prod.mk],[Lean.Meta.SynthInstance.SynthM, Unit]]
[Lean.Lsp.SemanticTokensParams.mk.inj,[],[Eq]]
[Function.curry_apply,[rfl],[Eq, Function.curry, Prod.mk]]
[String.replace,[OfNat.ofNat, String.replace.loop],[String]]
[Lean.LocalDecl.cdecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.LocalDecl.cdecl, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.tryUnify,[MonadExcept.tryCatch, Bind.bind, liftM, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isDefEqAssigning, ite, Eq, not, Bool.true, modify, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.mk, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.annotations, Array.push, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.postponed, Prod.mk, Pure.pure, PUnit.unit],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM, Unit]]
[Lean.Meta.modifyInferTypeCache,[Lean.Meta.modifyCache, Lean.Meta.Cache, Lean.Meta.Cache.mk],[Lean.Meta.MetaM, Unit]]
[Lean.Elab.Term.collectPatternVars,[Bind.bind, StateRefT'.run, Lean.Elab.Term.CollectPatternVars.main, Lean.Elab.Term.CollectPatternVars.State.mk, Lean.Elab.Term.TermElabM, Prod, Array, Lean.Elab.Term.PatternVar, Lean.Elab.Term.MatchAltView, Pure.pure, Prod.mk, Lean.Elab.Term.CollectPatternVars.State.vars],[Lean.Elab.Term.TermElabM, Prod, Array, Lean.Elab.Term.PatternVar, Lean.Elab.Term.MatchAltView]]
[Lean.Meta.IndPredBelow.BrecOnVariables.noConfusionType,[],[]]
[Lean.Lsp.instToJsonTextDocumentRegistrationOptions,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Lsp.TextDocumentRegistrationOptions.documentSelector?, List.nil],[Lean.ToJson, Lean.Lsp.TextDocumentRegistrationOptions]]
[Lean.resolveGlobalConst,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Syntax.ident, List, Lean.Name, ite, Eq, List.isEmpty, Bool.true, Lean.withRef, Lean.resolveGlobalConstCore, Pure.pure, Lean.throwErrorAt, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, ToString.toString],[List, Lean.Name]]
[Lean.Parser.Term.paren,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ppDedent, Lean.Parser.withoutPosition, Lean.Parser.withoutForbidden, Lean.Parser.optional, Lean.Parser.termParser, Lean.Parser.Term.parenSpecial],[Lean.Parser.Parser]]
[Lean.Parser.Tactic.simp',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Parser.Term.matchAlts,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.ppDedent, Lean.Parser.withPosition, Lean.Parser.many1Indent, HAndThen.hAndThen, Lean.Parser.ppLine, Lean.Parser.Term.matchAlt],[Lean.Parser.Parser]]
[instIsAddLeftCancel,[IsAddLeftCancel.mk, instIsAddLeftCancel.proof_1],[IsAddLeftCancel]]
[Lean.IR.FreeIndices.Collector,[Lean.IR.IndexSet],[]]
[Array.mapIdxM,[Array.size, OfNat.ofNat, rfl, Array.mkEmpty, Array.mapIdxM.map],[Array]]
[Lean.Syntax.foldArgs,[Id.run, Lean.Syntax.foldArgsM],[]]
[Lean.ReducibilityHints.abbrev.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.ReducibilityHints.abbrev, OfNat.ofNat]]
[Lean.Elab.Command.State.maxRecDepth,[],[Nat]]
[Lean.Meta.FVarSubst.insert,[ite, Eq, Lean.Meta.FVarSubst.contains, Bool.true, Lean.Meta.FVarSubst.mk, Std.AssocList.insert],[Lean.Meta.FVarSubst]]
[IO.FileRight.group,[],[IO.AccessRight]]
[Lean.DataValue.ofNat.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.DataValue.ofNat, HAdd.hAdd, OfNat.ofNat]]
[UInt64.noConfusionType,[],[]]
[Lean.Parser.categoryParserFn,[Lean.EnvExtension.getState, Lean.Parser.categoryParserFnExtension, Lean.Parser.ParserModuleContext.env, Lean.Parser.ParserContext.toParserModuleContext],[Lean.Parser.ParserFn]]
[Lean.Parser.Term.assert.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Lean.Parser.Term.optSemicolon.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Command.expandDeclNamespace?,[ite, Eq, not, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Option.none, or, BEq.beq, Unit.unit, Option, Prod, Lean.Name, Lean.Syntax, Lean.Elab.Command.expandDeclIdNamespace?, Lean.Syntax.getOp, OfNat.ofNat, Option.some, Prod.mk, Lean.Syntax.setArg, Lean.Syntax.isNone],[Option, Prod, Lean.Name, Lean.Syntax]]
[Lean.Lsp.WaitForDiagnosticsParams.uri,[],[Lean.Lsp.DocumentUri]]
[Lean.Elab.Command.ElabStructResult.defaultAuxDecls,[],[Array, Prod, Lean.Name, Lean.Expr]]
[Lean.IR.Borrow.collectDecl,[Lean.IR.Decl.extern, Lean.IR.Borrow.M, Unit, MonadWithReader.withReader, Lean.IR.Borrow.BorrowInfCtx.mk, Lean.IR.Borrow.BorrowInfCtx.env, Lean.IR.Borrow.BorrowInfCtx.decls, Lean.IR.Borrow.BorrowInfCtx.paramSet, Bind.bind, Lean.IR.Borrow.collectFnBody, Lean.IR.Borrow.updateParamMap, Lean.IR.Borrow.ParamMap.Key.decl, Pure.pure, Unit.unit],[Lean.IR.Borrow.M, Unit]]
[Lean.Elab.Term.Do.ToCodeBlock.checkNotShadowingMutable,[Bind.bind, MonadReader.read, ForIn.forIn, PUnit.unit, ite, Eq, Lean.NameSet.contains, Lean.Elab.Term.Do.ToCodeBlock.Context.mutableVars, Bool.true, Pure.pure, ForInStep.yield],[Lean.Elab.Term.Do.ToCodeBlock.M, Unit]]
[Nat.find_min',[Iff.mp, not_lt, Nat.find_min],[LE.le, Nat.find]]
[of_eq_true,[trivial, Eq.symm],[]]
[Lean.Xml.Parser.CDStart,[Lean.Parsec.skipString],[Lean.Parsec, Unit]]
[Lean.Expr.updateMData,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Lean.Expr, Lean.mkMData],[Lean.Expr]]
[Lean.Elab.Command.mkState,[Lean.Elab.Command.State.mk, List.cons, Lean.Elab.Command.Scope.mk, List.nil, Lean.Option.get, Lean.maxRecDepth],[Lean.Elab.Command.State]]
[Lean.Widget.GetInteractiveDiagnosticsParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Widget.GetInteractiveDiagnosticsParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.macroTailDefault,[HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.ident, Lean.Parser.darrow, Lean.Parser.Command.macroRhs, Lean.Parser.categoryParserOfStack, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.Expr.FindImpl.initCache,[Lean.Expr.FindImpl.State.mk, Array.mkArray, USize.toNat, Lean.Expr.FindImpl.cacheSize, cast, Lean.Expr.FindImpl.initCache.proof_1, Unit.unit],[Lean.Expr.FindImpl.State]]
[Lean.Position.noConfusionType,[],[]]
[Lean.Parser.Term.matchDiscr.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.evalInsideQuot, Lean.Parser.Term.matchDiscr],[Lean.Parser.Parser]]
[IO.instMonadLiftSTRealWorldBaseIO,[MonadLift.mk, id],[MonadLift, ST, IO.RealWorld, BaseIO]]
[Lean.Meta.mkAppM',[Bind.bind, Lean.Meta.inferType, Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.withNewMCtxDepth, OfNat.ofNat, List.toArray, List.nil, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Meta.NormNum.instLawfulOfNat_2.proof_1,[Lean.Meta.NormNum.LawfulOfNat.mk, rfl],[Lean.Meta.NormNum.LawfulOfNat]]
[Array.erase,[Unit.unit, Array, Array.indexOf?, Array.feraseIdx],[Array]]
[Lean.Elab.Term.elabLeadingParserMacro,[Lean.Elab.Term.adaptExpander, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.Elab.Term.getDeclName?, Option.none, Lean.Elab.Term.TermElabM, Lean.Syntax, Lean.MacroScopesView.mk, Lean.Name.num, Lean.extractMacroScopes, BEq.beq, List.nil, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Quote.quote, Lean.Parser.maxPrec, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElab]]
[Lean.Meta.reduceProjOf?,[ite, Eq, not, Lean.Expr.isApp, Bool.true, Pure.pure, Option.none, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Option, Lean.Expr, Lean.Expr.getAppFn, Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.Environment.getProjectionStructureName?, Lean.Meta.unfoldDefinition?],[Lean.Meta.MetaM, Option, Lean.Expr]]
[Tactic.Ring.pow_succ_eq,[Eq.mpr, Eq.refl, Eq, HPow.hPow, HAdd.hAdd, OfNat.ofNat, Eq.symm, HMul.hMul, pow_succ, rfl],[Eq, HPow.hPow, HAdd.hAdd, OfNat.ofNat]]
[Lean.MessageData.ofGoal.injEq,[Eq.propIntro, Eq.refl, Lean.MessageData.ofGoal, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MessageData.ofGoal]]
[Lean.TheoremVal.value,[],[Lean.Expr]]
[MProd.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.getAlias,[Bind.bind, ST.Ref.get, Pure.pure, Lean.NameMap.find?],[IO, Option, Lean.Parser.AliasValue]]
[Lean.Elab.Term.instMonadInfoTreeTermElabM,[Lean.Elab.MonadInfoTree.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Term.State.infoState, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift],[Lean.Elab.MonadInfoTree, Lean.Elab.Term.TermElabM]]
[Lean.Meta.IndPredBelow.Variables.args,[],[Array, Lean.Expr]]
[Lean.Literal.strVal.inj,[],[Eq]]
[Array.mapIdxM.map.proof_1,[Eq.mpr, Eq.refl, LT.lt, Array.size, Eq.symm, HAdd.hAdd, OfNat.ofNat, Nat.add_assoc, Nat.add_comm, Nat.le_add_right, Nat.succ],[LT.lt, Array.size]]
[Lean.Elab.Term.Quotation.ArrayStxBuilder,[Sum, Array, Lean.Syntax],[]]
[Lean.Server.Snapshots.Snapshot.env,[Lean.Elab.Command.State.env, Lean.Server.Snapshots.Snapshot.cmdState],[Lean.Environment]]
[Lean.Elab.Modifiers.recKind,[],[Lean.Elab.RecKind]]
[Lean.Elab.Term.MutualClosure.FixPoint.State.usedFVarsMap,[],[Lean.Elab.Term.MutualClosure.UsedFVarsMap]]
[Lean.MonadQuotation.noConfusionType,[],[]]
[LawfulFunctor.map_const,[],[Eq, Functor.mapConst, Function.comp, Functor.map, Function.const]]
[Lean.Export.exportDef.insert,[modify, Lean.Export.State.mk, Lean.Export.State.names, Lean.Export.State.levels, Lean.Export.State.exprs, Std.HashSet.insert, Lean.Export.State.defs, Lean.Export.State.stk],[Lean.ExportM, Unit]]
[Lean.LocalDecl.toExpr,[Lean.mkFVar, Lean.LocalDecl.fvarId],[Lean.Expr]]
[Lean.Elab.Term.elabTermAndSynthesize,[Lean.withRef, Bind.bind, Lean.Elab.Term.withSynthesize, Lean.Elab.Term.elabTerm, Bool.true, Bool.false, liftM, Lean.Meta.instantiateMVars],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[instAddCommGroup,[AddCommGroup.mk, instAddCommGroup.proof_5],[AddCommGroup]]
[Lean.MetavarContext.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Command.theorem.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.Command.declSig.formatter, Lean.Parser.Command.declVal.formatter, Lean.Parser.Command.terminationSuffix.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.Split.simpMatch,[Bind.bind, Lean.Meta.getCongrLemmas, Pure.pure, Lean.Meta.Simp.Context.mk, Lean.Meta.Simp.Config.mk, Bool.false, Lean.Meta.SimpLemmas.mk, Lean.Meta.Simp.main, Lean.Meta.Simp.Methods.mk, Lean.Meta.Split.simpMatch.pre],[Lean.Meta.MetaM, Lean.Meta.Simp.Result]]
[Lean.Elab.Tactic.expandLocation,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Tactic.Location.wildcard, Lean.Elab.Tactic.Location.targets, Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat, not, Lean.Syntax.isNone],[Lean.Elab.Tactic.Location]]
[StateCpsT.instMonadStateOfStateCpsT,[MonadStateOf.mk, PUnit.unit],[MonadStateOf, StateCpsT]]
[Float.mk.inj,[],[Eq]]
[UInt64.instAddCommSemigroupUInt64.proof_1,[congrArg, UInt64.mk, AddCommSemigroup.add_comm, UInt64.val],[Eq, UInt64.mk]]
[Lean.Meta.Match.Pattern.arrayLit.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.Pattern.arrayLit, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.Pattern.arrayLit, And]]
[String.toInt!,[Unit.unit, Int, String.toInt?, panic],[Int]]
[Nat.le_succ,[Nat.le.step, Nat.le.refl],[LE.le, Nat.succ]]
[UInt16.val,[],[Fin, UInt16.size]]
[Lean.Lsp.WorkDoneProgressEnd.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.WorkDoneProgressEnd.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.decide!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Meta.FindOptions.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.FindOptions.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.FindOptions.mk, And]]
[Lean.Elab.trace,[Bind.bind, Lean.MonadOptions.getOptions, ite, Eq, Lean.checkTraceOption, Bool.true, Lean.Elab.logTrace, Unit.unit, Pure.pure, PUnit.unit],[Unit]]
[Lean.Elab.Tactic.evalNativeDecide,[Lean.Elab.Tactic.closeMainGoalUsing, Bind.bind, liftM, Lean.Meta.instantiateMVars, ite, Eq, Lean.Expr.hasFVar, Bool.true, Lean.Meta.zetaReduce, Pure.pure, PUnit.unit, Lean.Meta.mkDecide, Lean.Elab.Term.mkAuxName, Lean.addDecl, Lean.compileDecl, Lean.Name.mkStr, Lean.Name.anonymous, Lean.mkConst, List.nil, Lean.Meta.mkEqRefl, Lean.ToExpr.toExpr, Lean.mkApp3],[Lean.Elab.Tactic.Tactic]]
[Lean.Elab.Term.Do.Code.decl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.Code.decl, HAdd.hAdd, OfNat.ofNat]]
[Nat.mod_one,[],[Eq, HMod.hMod, OfNat.ofNat]]
[Array.set,[Array.mk, List.set, Array.data, Fin.val],[Array]]
[Decidable.predToBool,[CoeDep.mk, Decidable.decide],[CoeDep, Bool]]
[Lean.modToFilePath.go,[Unit.unit, System.FilePath, HDiv.hDiv, PProd.fst, System.FilePath.mk, panicWithPosWithDecl, OfNat.ofNat],[System.FilePath]]
[Nat.foldM.loop,[Pure.pure, Bind.bind, HSub.hSub, OfNat.ofNat, PProd.fst],[]]
[String.mangle,[String, ite, Eq, or, Char.isAlpha, Char.isDigit, Bool.true, PProd.fst, String.Iterator.next, String.push, Char.ofNat, HAppend.hAppend, LT.lt, Char.toNat, OfNat.ofNat, String.length, String.mkIterator],[String]]
[Lean.Meta.CheckAssignment.Context.rhs,[],[Lean.Expr]]
[Lean.PrettyPrinter.Parenthesizer.State.minPrec,[],[Option, Nat]]
[Lean.Parser.Term.doLetRec,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.group, Lean.Parser.symbol, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.Term.letRecDecls],[Lean.Parser.Parser]]
[Lean.Xml.Attributes,[Std.RBMap, String, Ord.compare],[]]
[Lean.instMonadCacheExceptT,[Lean.MonadCache.mk, ExceptT.lift, Lean.MonadCache.findCached?, Lean.MonadCache.cache],[Lean.MonadCache, ExceptT]]
[Lean.Meta.RewriteResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.RewriteResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.RewriteResult.mk, And]]
[Lean.addDeclarationRanges,[Lean.MonadEnv.modifyEnv, Lean.MapDeclarationExtension.insert, Lean.declRangeExt],[Unit]]
[Lean.Parser.ParserContext.noConfusionType,[],[]]
[Lean.Elab.mkUnusedBaseName,[Bind.bind, Lean.Macro.getCurrNamespace, Lean.Macro.hasDecl, HAppend.hAppend, ite, Eq, Bool.true, OfNat.ofNat, Lean.Elab.mkUnusedBaseName.loop, Pure.pure],[Lean.MacroM, Lean.Name]]
[Lean.Rat.lt,[ite, Eq, and, Decidable.decide, LT.lt, Lean.Rat.num, OfNat.ofNat, GE.ge, Bool.true, BEq.beq, GT.gt, LE.le, Bool.false, HMul.hMul, Int.ofNat, Lean.Rat.den],[Bool]]
[Lean.AttributeImplBuilder,[Except, String, Lean.AttributeImpl],[]]
[Lean.Level.updateMax!.proof_1,[rfl],[Eq, Lean.Level.isMax, Lean.Level.max]]
[Lean.PrettyPrinter.Parenthesizer.level.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.maybeParenthesize, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false, Lean.Unhygienic.run, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.PrettyPrinter.Parenthesizer.parenthesizeCategoryCore],[Lean.PrettyPrinter.CategoryParenthesizer]]
[List.eraseRepsAux,[List, List.reverse, List.cons, Unit.unit, BEq.beq, PProd.fst],[List]]
[CommSemigroup.mul_comm,[],[Eq, HMul.hMul]]
[ExceptT.seq_eq,[rfl],[Eq, Seq.seq, Bind.bind, Functor.map]]
[Lean.ScopedEnvExtension.activateScoped,[List.nil, Lean.Environment, Lean.ScopedEnvExtension.StateStack.stateStack, ite, Eq, Lean.NameSet.contains, Lean.ScopedEnvExtension.State.activeScopes, Bool.true, Lean.PersistentEnvExtension.setState, Lean.ScopedEnvExtension.ext, Lean.ScopedEnvExtension.StateStack.mk, List.cons, Lean.ScopedEnvExtension.StateStack.scopedEntries, Lean.ScopedEnvExtension.StateStack.newEntries],[Lean.Environment]]
[UInt64.instSemiringUInt64.proof_6,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, HMul.hMul, UInt64.zero_def, UInt64.mul_def, UInt64.mk, OfNat.ofNat, MonoidWithZero.mul_zero, UInt64.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt64],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Elab.Tactic.replaceMainGoal,[Bind.bind, Lean.Elab.Tactic.getGoals, List.nil, Lean.Elab.Tactic.TacticM, Unit, modify, Lean.Elab.Tactic.State.mk, HAppend.hAppend, Lean.Elab.Tactic.throwNoGoalsToBeSolved],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.Environment.imports,[Lean.EnvironmentHeader.imports, Lean.Environment.header],[Array, Lean.Import]]
[Lean.Server.Watchdog.FileWorker.errorPendingRequests,[Bind.bind, ST.Ref.modifyGet, Lean.Server.Watchdog.FileWorker.pendingRequestsRef, Prod.mk, Std.RBMap.empty, ForIn.forIn, PUnit.unit, IO, ForInStep, PUnit, IO.FS.Stream.writeLspResponseError, Lean.JsonRpc.ResponseError.mk, Pure.pure, ForInStep.yield],[IO, Unit]]
[Lean.Meta.Closure.pushToProcess,[modify, Lean.Meta.Closure.State.mk, Lean.Meta.Closure.State.visitedLevel, Lean.Meta.Closure.State.visitedExpr, Lean.Meta.Closure.State.levelParams, Lean.Meta.Closure.State.nextLevelIdx, Lean.Meta.Closure.State.levelArgs, Lean.Meta.Closure.State.newLocalDecls, Lean.Meta.Closure.State.newLocalDeclsForMVars, Lean.Meta.Closure.State.newLetDecls, Lean.Meta.Closure.State.nextExprIdx, Lean.Meta.Closure.State.exprMVarArgs, Lean.Meta.Closure.State.exprFVarArgs, Array.push, Lean.Meta.Closure.State.toProcess],[Lean.Meta.Closure.ClosureM, Unit]]
[List.reverse_append,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.reverse, List.nil_append, HAppend.hAppend, List.reverse_nil, List.append_nil, eq_self, Eq.mpr, List.cons_append, List.reverse_cons, congrFun, List.cons, List.nil, Eq.refl, List.append_assoc, rfl],[Eq, List.reverse, HAppend.hAppend]]
[Lean.Parsec.anyChar,[ite, Eq, String.Iterator.hasNext, Bool.true, Lean.Parsec.ParseResult.success, String.Iterator.next, String.Iterator.curr, Lean.Parsec.ParseResult.error, Lean.Parsec.unexpectedEndOfInput],[Lean.Parsec, Char]]
[Lean.Meta.UnificationHint.mk.inj,[And.intro],[And, Eq]]
[List.cons_ne_nil,[Eq.refl, List.nil, HEq.refl],[Ne, List.cons, List.nil]]
[Lean.IR.Borrow.OwnedSet,[Std.HashMap, Lean.IR.Borrow.OwnedSet.Key, Unit],[]]
[controlAt,[Bind.bind, MonadControlT.liftWith, MonadControlT.restoreM],[]]
[Lean.Meta.Simp.Config.etaStruct,[],[Bool]]
[Lean.Parser.Term.whereDecls.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1Indent.formatter, Lean.Parser.group.formatter, Lean.Parser.Term.letRecDecl.formatter, Lean.Parser.optional.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.simpIfTarget,[Bind.bind, Lean.Meta.SplitIf.getSimpContext, Lean.Meta.simpTarget, Option.some, Lean.Meta.SplitIf.discharge?, Option.none, Lean.Meta.MetaM, Lean.MVarId, Pure.pure, panicWithPosWithDecl, OfNat.ofNat],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.Elab.Command.CtorView.ref,[],[Lean.Syntax]]
[Lean.Meta.AbstractMVars.State.ngen,[],[Lean.NameGenerator]]
[Lean.MetavarDecl.type,[],[Lean.Expr]]
[Lean.Elab.Term.elabFunBinders,[ite, Eq, Array.isEmpty, Bool.true, List.toArray, List.nil, Bind.bind, Lean.MonadLCtx.getLCtx, liftM, Lean.Meta.getLocalInstances, Lean.Elab.Term.FunBinders.elabFunBindersAux, OfNat.ofNat, Lean.Elab.Term.FunBinders.State.mk, Lean.Meta.resettingSynthInstanceCacheWhen, Decidable.decide, GT.gt, Array.size, Lean.Elab.Term.FunBinders.State.localInsts, Lean.Meta.withLCtx, Lean.Elab.Term.FunBinders.State.lctx, Lean.Elab.Term.FunBinders.State.fvars, Lean.Elab.Term.FunBinders.State.expectedType?],[Lean.Elab.Term.TermElabM]]
[Std.AssocList.cons.inj,[And.intro],[And, Eq]]
[Lean.instInhabitedLiteral,[Inhabited.mk, Lean.Literal.natVal, arbitrary],[Inhabited, Lean.Literal]]
[Lean.Parser.Tactic.fsplit,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Expr.updateApp,[Lean.mkApp],[Lean.Expr]]
[Float.le,[FloatSpec.le, floatSpec, Float.val],[]]
[Lean.Parser.Command.constant.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.Command.declSig.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.declValSimple.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Compiler.foldStrictOr,[Option.none, Option.some, Bool.false, Bool.true, Option, Lean.Expr],[Option, Lean.Expr]]
[Lean.KVMap.size,[List.length, Lean.KVMap.entries],[Nat]]
[UInt32.instSemigroupUInt32.proof_1,[congrArg, UInt32.mk, Semigroup.mul_assoc, UInt32.val],[Eq, UInt32.mk]]
[instMonadStateOfStateT,[MonadStateOf.mk, StateT.get, StateT.set, StateT.modifyGet],[MonadStateOf, StateT]]
[Std.Format.bracketFill,[Std.Format.fill, Std.Format.nest, Int.ofNat, String.length, HAppend.hAppend, Std.Format.text],[Std.Format]]
[Lean.Elab.Term.elabExplicitUniv,[Bind.bind, List.nil, Bool.false, List.toArray, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.Elab.Term.TermElabM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Pure.pure, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError],[Lean.Elab.Term.TermElab]]
[Lean.Elab.Tactic.evalContradiction,[Lean.Elab.Tactic.liftMetaTactic, Bind.bind, Lean.Meta.contradiction, Lean.Meta.Contradiction.Config.mk, Pure.pure, List.nil],[Lean.Elab.Tactic.Tactic]]
[Lean.Elab.Term.Do.ToTerm.continueToTerm,[Bind.bind, MonadReader.read, Lean.Elab.Term.Do.ToTerm.mkUVarTuple, Unit.unit, Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax, Lean.Elab.Term.Do.ToTerm.Context.kind, panicWithPosWithDecl, OfNat.ofNat, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom],[Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax]]
[Lean.IR.LocalContextEntry.param.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.LocalContextEntry.param, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.PatternVar.anonymousVar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.PatternVar.anonymousVar, HAdd.hAdd, OfNat.ofNat]]
[Std.Format.FlattenBehavior.noConfusionType,[noConfusionTypeEnum, Std.Format.FlattenBehavior.toCtorIdx],[]]
[Lean.Parser.Term.trueVal.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.nonReservedSymbol.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.IR.mkNumExpr,[Lean.IR.Expr.lit, Lean.IR.LitVal.num],[Lean.IR.Expr]]
[Lean.Parser.Error.merge,[Lean.Parser.Error, Lean.Parser.Error.mk, ite, Eq, BEq.beq, Bool.true, Lean.Parser.Error.unexpected, HAppend.hAppend, Lean.Parser.Error.expected],[Lean.Parser.Error]]
[Lean.mkLevelSucc,[Lean.Level.succ, Lean.Level.mkData, mixHash, OfNat.ofNat, Hashable.hash, HAdd.hAdd, Lean.Level.depth, Lean.Level.hasMVar, Lean.Level.hasParam],[Lean.Level]]
[Lean.PrettyPrinter.Formatter.checkColGt.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.RpcReleaseParams.uri,[],[Lean.Lsp.DocumentUri]]
[Lean.IR.Expr.reuse.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Expr.reuse, HAdd.hAdd, OfNat.ofNat]]
[Lean.Json.num.inj,[],[Eq]]
[Int.instCommRingInt.proof_4,[rfl],[Eq, Numeric.ofNat, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.TextDocumentChangeRegistrationOptions.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.TextDocumentChangeRegistrationOptions.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.TextDocumentChangeRegistrationOptions.mk, And]]
[instCoeTailNat,[CoeTail.mk, Numeric.ofNat],[CoeTail, Nat]]
[Lean.Server.FileWorker.handleCancelRequest,[Lean.Server.FileWorker.updatePendingRequests, Std.RBMap.erase, Lean.Lsp.CancelParams.id],[Lean.Server.FileWorker.WorkerM, Unit]]
[Lean.Parser.Command.declModifiersT.parenthesizer,[Lean.Parser.Command.declModifiers.parenthesizer, Bool.true],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Syntax.nonReserved.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.strLit.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.le_eq,[rfl],[Eq, Nat.le, LE.le]]
[Lean.Meta.trySubst,[Bind.bind, Lean.observing?, Lean.Meta.subst, Unit.unit, Lean.Meta.MetaM, Lean.MVarId, Pure.pure],[Lean.Meta.MetaM, Lean.MVarId]]
[Std.shareCommonM,[Std.withShareCommon],[]]
[Lean.Server.FileWorker.SemanticTokensContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.FileWorker.SemanticTokensContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.FileWorker.SemanticTokensContext.mk, And]]
[Lean.Elab.Command.expandInitCmd,[ite, Eq, Lean.Syntax.isNone, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.Macro.throwError, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, BEq.beq, Lean.Syntax.getKind, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Macro]]
[Lean.Lsp.instBEqRpcRef,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Lsp.RpcRef]]
[Nat.coprime_zero_right,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, Eq, Nat.gcd_zero_right, OfNat.ofNat, iff_self],[Iff, Nat.coprime, OfNat.ofNat, Eq]]
[FloatArray.toList,[OfNat.ofNat, List.nil, FloatArray.toList.loop],[List, Float]]
[Lean.KVMap.entries,[],[List, Prod, Lean.Name, Lean.DataValue]]
[Lean.Expr.notNot?,[Unit.unit, Option, Lean.Expr, Lean.Expr.not?, Option.none],[Option, Lean.Expr]]
[Lean.Syntax.SepArray.ofElemsUsingRef,[Bind.bind, Lean.MonadRef.getRef, Pure.pure, Lean.Syntax.SepArray.mk, Lean.mkSepArray, Lean.mkAtomFrom],[Lean.Syntax.SepArray]]
[Mathlib.Prelude.Rename.align,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.PrettyPrinter.Parenthesizer.State.visitedToken,[],[Bool]]
[Lean.Parser.Term.let_delayed.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.letDecl.parenthesizer, Lean.Parser.Term.optSemicolon.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.instHashableBinderInfo,[Hashable.mk, Lean.BinderInfo.hash],[Hashable, Lean.BinderInfo]]
[Array.filterSepElems,[Id.run, Array.filterSepElemsM],[Array, Lean.Syntax]]
[Lean.MetavarContext.MkBinding.elimMVarDeps,[ite, Eq, not, Lean.Expr.hasMVar, Bool.true, Pure.pure, Bind.bind, MonadState.modifyGet, Prod.mk, Lean.MetavarContext.MkBinding.State.cache, Lean.MetavarContext.MkBinding.State.mk, Lean.MetavarContext.MkBinding.State.mctx, Lean.MetavarContext.MkBinding.State.ngen, EmptyCollection.emptyCollection, modify],[Lean.MetavarContext.MkBinding.M, Lean.Expr]]
[Option.map,[Option.bind, Function.comp, Option.some],[Option]]
[Lean.IR.findEnvDecl,[Lean.SMap.find?, Lean.SimplePersistentEnvExtension.getState, Lean.IR.declMapExt],[Option, Lean.IR.Decl]]
[Lean.LocalContext.mk.inj,[And.intro],[And, Eq]]
[Lean.Name.toExprAux,[Unit.unit, Lean.Expr, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.mkAppB, PProd.fst, Lean.ToExpr.toExpr],[Lean.Expr]]
[Lean.Meta.isMatcherAppCore,[Option.isSome, Lean.Meta.isMatcherAppCore?],[Bool]]
[Lean.enableInitializersExecution,[ST.Ref.set, Bool.true],[IO, Unit]]
[Char.quote,[HAppend.hAppend, Char.quoteCore],[String]]
[Lean.Lsp.ReferenceContext.mk.inj,[],[Eq]]
[Array.foldlM.loop.proof_1,[Nat.lt_of_lt_of_le],[LT.lt, Array.size]]
[unexpandListNil,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.PrettyPrinter.Unexpander]]
[Lean.Elab.Command.withExpectedType,[Bind.bind, Lean.Elab.Term.tryPostponeIfNoneOrMVar, Pure.pure, Option.none, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Lean.Meta.CongrLemmas.mk.inj,[],[Eq]]
[Lean.PrettyPrinter.Parenthesizer.withOpen.parenthesizer,[],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.CollectLevelParams.instInhabitedState,[Inhabited.mk, Lean.CollectLevelParams.State.mk],[Inhabited, Lean.CollectLevelParams.State]]
[Lean.Elab.Term.Do.Code.return.inj,[And.intro],[And, Eq]]
[Lean.Meta.mkOfNatLit,[Lean.mkApp3, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil],[Lean.Expr]]
[Array.noConfusionType,[],[]]
[Lean.ScopedEnvExtension.mkInitial,[Bind.bind, Lean.ScopedEnvExtension.Descr.mkInitial, Pure.pure, Lean.ScopedEnvExtension.StateStack.mk, List.cons, Lean.ScopedEnvExtension.State.mk, List.nil],[IO, Lean.ScopedEnvExtension.StateStack]]
[IO.eprintln,[IO.eprint, String.push, ToString.toString, Char.ofNat],[IO, Unit]]
[Classical.inhabited_of_nonempty,[Inhabited.mk, Classical.choice],[Inhabited]]
[Char.ofNat.proof_1,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[Lean.SMap.stageSizes,[Prod.mk, Std.HashMap.size, Lean.SMap.map₁, Std.PersistentHashMap.size, Lean.SMap.map₂],[Prod, Nat]]
[UInt32.lor,[UInt32.mk, Fin.lor, UInt32.val],[UInt32]]
[Lean.Lsp.instToJsonServerInfo,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.ServerInfo.name, List.nil, Lean.Json.opt, Lean.Lsp.ServerInfo.version?],[Lean.ToJson, Lean.Lsp.ServerInfo]]
[Lean.DefinitionVal.getSafetyEx,[Lean.DefinitionVal.safety],[Lean.DefinitionSafety]]
[Lean.Lsp.instFileSourceDocumentHighlightParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.DocumentHighlightParams.toTextDocumentPositionParams],[Lean.Lsp.FileSource, Lean.Lsp.DocumentHighlightParams]]
[precMin1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[USize.instAddCommSemigroupUSize,[AddCommSemigroup.mk, USize.instAddCommSemigroupUSize.proof_1],[AddCommSemigroup, USize]]
[Lean.Meta.SynthInstance.ConsumerNode.key,[],[Lean.Expr]]
[Std.RBNode.forIn.visit,[ForInStep, Pure.pure, ForInStep.yield, Bind.bind, PProd.fst, ForInStep.done, PProd.snd],[ForInStep]]
[Lean.Elab.Term.MutualClosure.LetRecClosure.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.MutualClosure.LetRecClosure.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.MutualClosure.LetRecClosure.mk, And]]
[Lean.PrettyPrinter.Delaborator.SubExpr.instInhabitedHoleIterator,[Inhabited.mk, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.mk, arbitrary],[Inhabited, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator]]
[Lean.Lsp.instToJsonSemanticTokensRangeParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.SemanticTokensRangeParams.textDocument, List.nil, Lean.Lsp.SemanticTokensRangeParams.range],[Lean.ToJson, Lean.Lsp.SemanticTokensRangeParams]]
[Lean.Parser.Term.ensureTypeOf.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec, Lean.Parser.strLit.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Term.doLet,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.Term.letDecl],[Lean.Parser.Parser]]
[Lean.Meta.Match.MatcherInfo.numDiscrs,[],[Nat]]
[Lean.Parser.Tactic.subst,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.IR.Checker.withParams,[Bind.bind, MonadReader.read, Array.foldlM, Lean.IR.Checker.markVar, Lean.IR.Param.x, Pure.pure, Lean.IR.LocalContext.addParam, Lean.IR.Checker.CheckerContext.localCtx, OfNat.ofNat, Array.size, MonadWithReader.withReader, Lean.IR.Checker.CheckerContext.mk, Lean.IR.Checker.CheckerContext.env, Lean.IR.Checker.CheckerContext.decls],[Lean.IR.Checker.M, Unit]]
[List.length_erase_of_mem,[Eq.mpr, Eq.refl, Eq, List.length, List.erase, Nat.pred, List.erase_eq_erasep, List.length_erasep_of_mem, rfl],[Eq, List.length, List.erase, Nat.pred]]
[Lean.Parser.Term.binderType,[ite, Eq, Bool.true, Lean.Parser.node, Lean.nullKind, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat, Lean.Parser.optional],[Lean.Parser.Parser]]
[Nat.ble_self_eq_true,[Unit.unit, Eq, Nat.ble, Bool.true, rfl, PProd.fst],[Eq, Nat.ble, Bool.true]]
[Lean.Elab.Command.termEta_helper_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.mkLevelMVar,[Lean.Level.mvar, Lean.Level.mkData, mixHash, OfNat.ofNat, Hashable.hash, Bool.true, Bool.false],[Lean.Level]]
[Lean.instInhabitedTraceElem,[Inhabited.mk, Lean.TraceElem.mk, arbitrary],[Inhabited, Lean.TraceElem]]
[Lean.MetavarDecl.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MetavarDecl.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MetavarDecl.mk, And]]
[Set.compl,[setOf, Not, Mem.mem],[Set]]
[Lean.Parser.Command.infixr,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Json.renderString,[HAppend.hAppend, Lean.Json.escape],[String]]
[Lean.Elab.CompletionInfo.stx,[Lean.Syntax, Lean.Elab.ElabInfo.stx, Lean.Elab.TermInfo.toElabInfo],[Lean.Syntax]]
[Lean.Meta.SynthInstance.SubgoalsResult.instVal,[],[Lean.Expr]]
[List.getLast,[absurd, List.getLast.proof_1, PProd.fst, List.getLast.proof_2],[]]
[Lean.Parser.strLitFn,[ite, Eq, and, not, Lean.Parser.ParserState.hasError, Lean.Syntax.isOfKind, Array.back, Lean.Parser.ParserState.stxStack, Lean.strLitKind, Bool.true, Lean.Parser.ParserState.mkErrorAt, Option.some],[Lean.Parser.ParserFn]]
[Lean.Elab.Term.mkCoe,[Bind.bind, liftM, Lean.Meta.getLevel, Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.synthetic, Lean.Name.anonymous, MonadExcept.tryCatch, Lean.Elab.Term.withoutMacroStackAtErr, Lean.Elab.Term.synthesizeCoeInstMVarCore, ite, Eq, Bool.true, Lean.Meta.expandCoe, Lean.MetavarKind.syntheticOpaque, Lean.Elab.Term.registerSyntheticMVarWithCurrRef, Lean.Expr.mvarId!, Lean.Elab.Term.SyntheticMVarKind.coe, Pure.pure, Lean.Exception.internal, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Elab.Term.throwTypeMismatchError, Option.none],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Lean.Lsp.DiagnosticWith.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.AliasValue.unary.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.AliasValue.unary, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.AliasValue.unary]]
[Lean.Server.Watchdog.OpenDocument.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.Watchdog.OpenDocument.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.isLetRecAuxMVar,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, MonadState.get, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkMVar, List.map, Lean.Elab.Term.LetRecToLift.mvarId, Lean.Elab.Term.State.letRecsToLift, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElabM, Bool]]
[Lean.NamePart.str.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.NamePart.str, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Match.Example.var.inj,[],[Eq]]
[Lean.Elab.Tactic.evalSeq1,[Bind.bind, ForIn.forIn, PUnit.unit, ite, Eq, BEq.beq, HMod.hMod, OfNat.ofNat, Bool.true, Lean.Elab.Tactic.evalTactic, Array.getOp, Pure.pure, ForInStep.yield, Lean.Elab.Tactic.saveTacticInfoForToken],[Lean.Elab.Tactic.Tactic]]
[Lean.Parser.Syntax.cat.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optPrecedence.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Json.CompressWorkItem.arrayElem.inj,[],[Eq]]
[Lean.Parser.parseCommand,[Lean.Parser.parseCommand.parse],[Prod, Lean.Syntax, Lean.Parser.ModuleParserState, Lean.MessageLog]]
[Lean.Parser.Tactic.mfldSetTac,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Nat.mul_le_mul_of_nonneg_right,[Decidable.em, LE.le, Eq.mpr, congrArg, HMul.hMul, congrFun, Nat.le_antisymm, Nat.le_refl, Eq.symm, OfNat.ofNat, of_eq_true, Eq.trans, congr, Nat.zero_le, Nat.mul_zero, eq_true_of_decide, Eq.refl, Bool.true, Nat.le_of_lt, Nat.mul_lt_mul_of_pos_right, Iff.mp, not_le],[LE.le, HMul.hMul]]
[Lean.Environment.mainModule,[Lean.EnvironmentHeader.mainModule, Lean.Environment.header],[Lean.Name]]
[Std.PersistentHashMap.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.PersistentHashMap.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.FindOptions.checkPrivate,[],[Bool]]
[Prod.map_fst,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Prod.fst, prod_map, eq_self],[Eq, Prod.fst, Prod.map]]
[Lean.Syntax.Traverser.setCur,[Lean.Syntax.Traverser.mk, Lean.Syntax.Traverser.parents, Lean.Syntax.Traverser.idxs],[Lean.Syntax.Traverser]]
[Lean.FileMap.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.FileMap.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.FileMap.mk, And]]
[Lean.Elab.Term.withoutAutoBoundImplicit,[MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.Context.declName?, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.currMacroScope, Lean.Elab.Term.Context.mayPostpone, Lean.Elab.Term.Context.errToSorry, Bool.false, Std.PersistentArray.mk, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection],[Lean.Elab.Term.TermElabM]]
[Lean.Lsp.DiagnosticCode.string.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.DiagnosticCode.string, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.instMonadBacktrackSavedStateTermElabM,[Lean.MonadBacktrack.mk, Lean.Elab.Term.saveState, Lean.Elab.Term.SavedState.restore, Bool.false],[Lean.MonadBacktrack, Lean.Elab.Term.SavedState, Lean.Elab.Term.TermElabM]]
[Lean.IR.Expr.isShared.injEq,[Eq.propIntro, Eq.refl, Lean.IR.Expr.isShared, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Expr.isShared]]
[Mathlib.Tactic.Lint.groupedByFilename,[Bind.bind, ForIn.forIn, Lean.Core.CoreM, ForInStep, Std.HashMap, Lean.Name, Lean.MessageData, Lean.findModuleOf?, Lean.MonadEnv.getEnv, Pure.pure, PUnit.unit, ForInStep.yield, List.mapM, Mathlib.Tactic.Lint.printWarnings, HAppend.hAppend, Lean.ToMessageData.toMessageData, Array.toList, Lean.MessageData.joinSep, Lean.MessageData.ofFormat, Std.Format.line],[Lean.Core.CoreM, Lean.MessageData]]
[Acc.inv.proof_1,[],[Acc]]
[Lean.Parser.mkAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.maxPrec, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.setExpected.parenthesizer, List.nil, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.manyNoAntiquot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.antiquotExpr.parenthesizer, Lean.PrettyPrinter.Parenthesizer.ite, Eq, Bool.true, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.PrettyPrinter.Parenthesizer.checkNoImmediateColon.parenthesizer, Lean.PrettyPrinter.Parenthesizer.pushNone.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[or_and_distrib_right,[Iff.trans, And.comm, and_or_distrib_left, or_congr],[Iff, And, Or]]
[Lean.Parser.Tactic.suffices',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.MonadQuotation.withFreshMacroScope,[],[]]
[Lean.Compiler.NumScalarTypeInfo.nbits,[],[Nat]]
[Lean.Server.FileWorker.SemanticTokensContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.FileWorker.SemanticTokensContext.mk, HAdd.hAdd, OfNat.ofNat]]
[Classical.choose_spec,[Subtype.property, Classical.indefiniteDescription],[Classical.choose]]
[Lean.Parser.decimalNumberFn.parseOptExp,[ite, Eq, or, BEq.beq, Char.ofNat, Bool.true, Char.isDigit, Lean.Parser.takeWhileFn, Lean.Parser.ParserState.setPos],[Lean.Parser.ParserState]]
[Subtype.map_injective,[Subtype.coind_injective, Subtype.map.proof_1, Function.injective.comp, Subtype.coe_injective],[Function.injective, Subtype.map]]
[Classical.epsilon_spec_aux,[Subtype.property, Classical.strongIndefiniteDescription],[Classical.epsilon]]
[UInt32.instAddCommSemigroupUInt32.proof_1,[congrArg, UInt32.mk, AddCommSemigroup.add_comm, UInt32.val],[Eq, UInt32.mk]]
[Lean.Xml.Element.below,[PProd, PUnit],[]]
[Lean.Syntax.isOfKind,[BEq.beq, Lean.Syntax.getKind],[Bool]]
[not_and_distrib,[Decidable.not_and_distrib],[Iff, Not, And, Or]]
[Lean.Compiler.numScalarTypes,[List.cons, Lean.Compiler.NumScalarTypeInfo.mk, OfNat.ofNat, System.Platform.numBits, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[List, Lean.Compiler.NumScalarTypeInfo]]
[Lean.Level.imax.inj,[And.intro],[And, Eq]]
[Lean.Parser.Command.optNamedName,[Lean.Parser.optional, Lean.Parser.Command.namedName],[Lean.Parser.Parser]]
[Lean.Elab.Term.elabWaitIfContainsMVar,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, liftM, Lean.MonadMCtx.getMCtx, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.MetavarContext.findUserName?, Lean.Syntax.getId, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.instantiateMVars, Lean.mkMVar, Lean.Expr.hasExprMVar, Lean.Elab.Term.tryPostpone, Pure.pure, PUnit.unit, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElab]]
[Lean.Parser.Command.decreasingBy,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.terminationHint, Lean.Parser.Tactic.tacticSeq],[Lean.Parser.Parser]]
[Lean.Xml.Parser.NotationType,[Bind.bind, Lean.Parsec.skipString, SeqLeft.seqLeft, SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Parsec.skipChar, Char.ofNat, optional, Lean.Xml.Parser.Name, Lean.Parsec.many],[Lean.Parsec, Unit]]
[Lean.Name.getString!,[Lean.Name.anonymous, Lean.Name.num, String, panicWithPosWithDecl, OfNat.ofNat],[String]]
[Lean.Widget.instInhabitedCodeToken,[Inhabited.mk, Lean.Widget.CodeToken.mk, arbitrary],[Inhabited, Lean.Widget.CodeToken]]
[Lean.Parser.Term.doHave,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.haveDecl],[Lean.Parser.Parser]]
[Lean.instFromJsonOption,[Lean.FromJson.mk, Unit.unit, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Except, String, Option, Except.ok, Option.none, Functor.map, Option.some, Lean.FromJson.fromJson?],[Lean.FromJson, Option]]
[EStateM.Result.ok.inj,[And.intro],[And, Eq]]
[Lean.Widget.instInhabitedInfoWithCtx,[Inhabited.mk, Lean.Widget.InfoWithCtx.mk, arbitrary],[Inhabited, Lean.Widget.InfoWithCtx]]
[Lean.Lsp.SemanticTokenType.keyword.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SemanticTokenType.keyword, OfNat.ofNat]]
[Lean.Meta.FVarSubst.mk.inj,[],[Eq]]
[Lean.Elab.Term.getPatternVarNames,[Array.filterMap, Lean.Elab.Term.PatternVar.anonymousVar, Option, Lean.Name, Option.some, Option.none, OfNat.ofNat, Array.size],[Array, Lean.Name]]
[Lean.Elab.Term.hasNoImplicitLambdaAnnotation,[Option.isSome, Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous],[Bool]]
[MonoidWithZero.mul_zero,[],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.IR.LocalContext.getValue,[Option.none, Option.some, Lean.IR.LocalContextEntry.param, Lean.IR.LocalContextEntry.joinPoint, Option, Lean.IR.Expr, Std.RBMap.find?, Lean.IR.VarId.idx],[Option, Lean.IR.Expr]]
[Function.surjective.comp,[Exists.elim, Exists.intro],[Function.surjective, Function.comp]]
[Lean.Parser.Syntax.unary.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.syntaxParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.ensureHasDefault,[ite, Eq, Array.any, Lean.IR.Alt.isDefault, OfNat.ofNat, Array.size, Bool.true, LT.lt, Array.push, Lean.IR.Alt.default, Lean.IR.AltCore.body],[Array, Lean.IR.Alt]]
[Lean.Parser.Level.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.levelParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Option.register,[Bind.bind, Lean.registerOption, Lean.OptionDecl.mk, Lean.KVMap.Value.toDataValue, Lean.Option.Decl.defValue, Lean.Option.Decl.group, Lean.Option.Decl.descr, Pure.pure, Lean.Option.mk],[IO, Lean.Option]]
[eq_comm,[Iff.intro, Eq.symm],[Iff, Eq]]
[Lean.Elab.Term.ElabAppArgs.eraseNamedArgCore,[List.filter, bne, Lean.Elab.Term.NamedArg.name],[List, Lean.Elab.Term.NamedArg]]
[Lean.Parsec.ParseResult.error.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parsec.ParseResult.error, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.expandOptDocComment?,[Unit.unit, Option, String, Lean.Syntax.getOptional?, Pure.pure, Option.none, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Lean.Syntax.getOp, OfNat.ofNat, Option.some, String.extract, HSub.hSub, String.bsize, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.ofSyntax],[Option, String]]
[Lean.Parser.Term.binderType.formatter,[Lean.PrettyPrinter.Formatter.ite, Eq, Bool.true, Lean.PrettyPrinter.Formatter.node.formatter, Lean.nullKind, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Lean.Parser.optional.formatter],[Lean.PrettyPrinter.Formatter]]
[Int.lt,[LE.le, HAdd.hAdd, OfNat.ofNat],[]]
[Nat.lt,[Nat.le, Nat.succ],[]]
[Std.HashSet.foldM,[Std.HashSetImp.foldM],[]]
[Lean.pushScope,[Bind.bind, ST.Ref.get, Lean.scopedEnvExtensionsRef, ForIn.forIn, PUnit.unit, Lean.MonadEnv.modifyEnv, Lean.ScopedEnvExtension.pushScope, Pure.pure, ForInStep.yield],[Unit]]
[String.congr_append,[Eq, HAppend.hAppend, String.mk, String.data, rfl],[Eq, HAppend.hAppend, String.mk, String.data]]
[Lean.Parser.Command.check.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Function.left_inverse_surj_inv,[Function.right_inverse_of_injective_of_left_inverse, And.left, Function.right_inverse_surj_inv, And.right],[Function.left_inverse, Function.surj_inv, And.right]]
[Lean.Meta.CheckAssignment.Context.mk.inj,[And.intro],[And, Eq]]
[«term_*_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[or_assoc,[Or.assoc],[Iff, Or]]
[Lean.Lsp.SemanticTokensOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.SemanticTokensOptions.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Tactic.Simp.DischargeWrapper.with,[Unit.unit, Lean.Elab.Tactic.TacticM, Option.none, Bind.bind, getThe, Lean.Elab.Term.State, ST.Ref.set, tryFinally, Option.some, ST.Ref.get, MonadStateOf.set],[Lean.Elab.Tactic.TacticM]]
[Lean.Parser.Term.funSimpleBinder,[HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.lookahead, Lean.Parser.many1, Lean.Parser.Term.binderIdent, Lean.Parser.symbol, Lean.Parser.Term.simpleBinder],[Lean.Parser.Parser]]
[Lean.Lsp.VersionedTextDocumentIdentifier.version?,[],[Option, Nat]]
[Lean.Elab.Term.expandTermFor,[Lean.withRef, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.Macro]]
[Lean.Parser.Command.openDecl.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.openHiding.parenthesizer, Lean.Parser.Command.openRenaming.parenthesizer, Lean.Parser.Command.openOnly.parenthesizer, Lean.Parser.Command.openSimple.parenthesizer, Lean.Parser.Command.openScoped.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.SavedContext.macroStack,[],[Lean.Elab.MacroStack]]
[Lean.Parser.InputContext.fileName,[],[String]]
[Lean.Expr.app.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Expr.app, HAdd.hAdd, OfNat.ofNat]]
[Lean.MessageData.format,[Lean.MessageData.formatAux, Lean.NamingContext.mk, Lean.Name.anonymous, List.nil, Option.none],[IO, Std.Format]]
[Lean.Meta.DiscrTree.Key.fvar.inj,[And.intro],[And, Eq]]
[DoResultPRBC.pure.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultPRBC.pure, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.UniqueIds.checkId,[MonadState.modifyGet],[Lean.IR.UniqueIds.M, Bool]]
[Lean.Parser.Term.num.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.numLit.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[id.def,[rfl],[Eq, id]]
[Lean.Elab.Tactic.getMainModule,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Environment.mainModule],[Lean.Elab.Tactic.TacticM, Lean.Name]]
[Lean.KeyedDeclsAttribute.AttributeEntry.value,[],[]]
[IO.Error.toString,[Unit.unit, String, IO.Error.fopenErrorToString, Option.some, IO.Error.otherErrorToString, Option.none],[String]]
[Lean.Meta.Match.Example.val.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.Example.val, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.IndPredBelow.Context.headers,[],[Array, Lean.Expr]]
[or_congr,[Iff.intro, Or.imp, Iff.mp, Iff.mpr],[Iff, Or]]
[Lean.mkCIdent,[Lean.mkCIdentFrom, Lean.Syntax.missing],[Lean.Syntax]]
[LawfulApplicative.seq_pure,[],[Eq, Seq.seq, Pure.pure, Functor.map]]
[Std.PersistentHashMap.Entry.ref.injEq,[Eq.propIntro, Eq.refl, Std.PersistentHashMap.Entry.ref, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.PersistentHashMap.Entry.ref]]
[Lean.realPathNormalized,[Bind.bind, IO.FS.realPath, Pure.pure, System.FilePath.normalize, System.FilePath.isCaseInsensitive],[IO, System.FilePath]]
[Lean.Meta.Simp.Context.simpLemmas,[],[Lean.Meta.SimpLemmas]]
[And.left_comm,[Eq.mpr, Eq.refl, Iff, And, Eq.symm, propext, and_assoc, And.comm, Iff.rfl],[Iff, And]]
[Lean.Elab.Command.liftEIO,[liftM],[Lean.Elab.Command.CommandElabM]]
[instPowFloatFloat,[Pow.mk, Float.pow],[Pow, Float]]
[Nat.lt.base,[Nat.lt.base.proof_1],[LT.lt, Nat.succ]]
[Lean.Lsp.DocumentFilter.scheme?,[],[Option, String]]
[Numeric.noConfusionType,[],[]]
[and_iff_left,[Iff.intro, And.left, And.intro],[Iff, And]]
[mul_assoc,[Semigroup.mul_assoc],[Eq, HMul.hMul]]
[Lean.Expr.forEach',[Lean.MonadCacheT.run, Lean.ForEachExpr.visit],[Unit]]
[Lean.Expr.FindImpl.State.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Expr.FindImpl.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Expr.FindImpl.State.mk]]
[Int.negSucc_ofNat_coe',[Eq.mpr, Eq.refl, Eq, Int.negSucc, HSub.hSub, Neg.neg, Int.ofNat, OfNat.ofNat, Int.sub_eq_add_neg, HAdd.hAdd, Eq.symm, Int.neg_add, rfl],[Eq, Int.negSucc, HSub.hSub, Neg.neg, Int.ofNat, OfNat.ofNat]]
[Lean.Meta.IndPredBelow.mkContext.addMotives,[Array.foldrM, Lean.Meta.MetaM, Lean.Expr, Lean.Meta.forallTelescopeReducing, Bind.bind, Lean.Meta.instantiateForall, Array.ofSubarray, Array.toSubarray, OfNat.ofNat, Lean.Meta.withLocalDecl, Lean.BinderInfo.implicit, Lean.Meta.mkForallFVars, Array.insertAt, Bool.false, Bool.true, Array.size],[Lean.Meta.MetaM, Lean.Expr]]
[Functor.noConfusionType,[],[]]
[Lean.Parser.mkCategoryAntiquotParser,[Lean.Parser.mkAntiquot, Lean.Name.toString, Bool.true, Option.none],[Lean.Parser.Parser]]
[UInt32.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, UInt32.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Export.instInhabitedAlloc,[Inhabited.mk, Lean.Export.Alloc.mk, arbitrary],[Inhabited, Lean.Export.Alloc]]
[Array.mapM,[Array.foldlM, Bind.bind, Pure.pure, Array.push, Array.mkEmpty, Array.size, OfNat.ofNat],[Array]]
[Lean.findOLean,[Bind.bind, ST.Ref.get, Lean.searchPathRef, Lean.SearchPath.findWithExt, Option.none, IO, System.FilePath, Pure.pure, IO.currentDir, PUnit.unit, Lean.findOLean.maybeThisOne],[IO, System.FilePath]]
[Lean.Meta.splitIfLocalDecl?,[Lean.commitWhenSome?, Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.inferType, Lean.mkFVar, Lean.Meta.SplitIf.splitIfAt?, Option.none, Lean.Meta.MetaM, Option, Prod, Lean.MVarId, Lean.Meta.simpIfLocalDecl, Lean.Meta.ByCasesSubgoal.mvarId, ite, Eq, and, BEq.beq, Bool.true, Pure.pure, Option.some, Prod.mk],[Lean.Meta.MetaM, Option, Prod, Lean.MVarId]]
[Subsingleton.helim,[Subsingleton.helim.proof_1],[HEq]]
[Lean.Elab.Term.adaptExpander,[Bind.bind, Lean.Elab.Term.withMacroExpansion, Lean.Elab.Term.elabTerm, Bool.true],[Lean.Elab.Term.TermElab]]
[Lean.Parser.Command.infix.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.InfoState.trees,[],[Std.PersistentArray, Lean.Elab.InfoTree]]
[IO.AsyncList.below,[PProd, PUnit],[]]
[Lean.Elab.Structural.structuralRecursion,[ite, Eq, bne, Array.size, OfNat.ofNat, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData, Bind.bind, liftM, Lean.Elab.Structural.run, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.value, Pure.pure, PUnit.unit, Array.getOp, Lean.Elab.Structural.State.mk, Lean.Elab.Term.TermElabM, Unit, Array.forM, Lean.Elab.Structural.State.addMatchers, Lean.Meta.mapError, Lean.Elab.addNonRec, Lean.indentD, Lean.Elab.addAndCompilePartialRec, Lean.Elab.Structural.addSmartUnfoldingDef, Lean.Elab.Structural.registerEqnsInfo],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Widget.GetInteractiveDiagnosticsParams.noConfusionType,[],[]]
[introv,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Attribute.Builtin.ensureNoArgs,[ite, Eq, and, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.isNone, Lean.Syntax.getOp, OfNat.ofNat, Bool.true, Pure.pure, Unit.unit, Lean.Syntax.node, Lean.Syntax.atom, Lean.Syntax.ident, Lean.AttrM, Unit, Lean.throwErrorAt, Lean.ToMessageData.toMessageData],[Lean.AttrM, Unit]]
[Lean.SimpleScopedEnvExtension.Descr.finalizeImport,[],[]]
[Lean.Meta.Simp.defaultMaxSteps,[OfNat.ofNat],[Nat]]
[Lean.getPPAnalysisNamedArg,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false],[Bool]]
[Lean.Elab.Term.LetRecDeclView.binderIds,[],[Array, Lean.Syntax]]
[Lean.Lsp.instFromJsonDeclarationParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.DeclarationParams.mk, Lean.Lsp.TextDocumentPositionParams.mk],[Lean.FromJson, Lean.Lsp.DeclarationParams]]
[Lean.Parser.Term.binop_lazy,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.ppSpace, Lean.Parser.termParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[Std.Format.text.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.Format.text, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.FieldInfo.stx,[],[Lean.Syntax]]
[Lean.Meta.SimpAll.Entry.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.PatternElabException.ex,[],[Lean.Exception]]
[Lean.IR.UnreachableBranches.elimDead,[Lean.IR.Decl.extern, Lean.IR.Decl, Lean.IR.Decl.updateBody!, Lean.IR.UnreachableBranches.elimDeadAux],[Lean.IR.Decl]]
[Lean.Server.FileWorker.GoToKind.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.IR.EmitC.emitLhs,[Bind.bind, Lean.IR.EmitC.emit],[Lean.IR.EmitC.M, Unit]]
[Substring.splitOn,[ite, Eq, BEq.beq, Bool.true, List.cons, List.nil, OfNat.ofNat, Substring.splitOn.loop],[List, Substring]]
[Lean.Elab.Term.StructInst.DefaultFields.isRoundDone,[Bind.bind, MonadState.get, MonadReader.read, Pure.pure, and, Lean.Elab.Term.StructInst.DefaultFields.State.progress, Decidable.decide, GT.gt, Lean.Elab.Term.StructInst.DefaultFields.Context.maxDistance, OfNat.ofNat],[Lean.Elab.Term.StructInst.DefaultFields.M, Bool]]
[Fin.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Fin.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Syntax.MonadTraverser.goRight,[modify, Lean.Syntax.Traverser.right],[Unit]]
[Lean.Widget.MsgToInteractive.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.elide,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Mathlib.Prelude.Rename.elabLookup3,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.Elab.Command.CommandElabM, Unit, Std.HashMap.find?, Mathlib.Prelude.Rename.getRenameMap, Lean.Elab.logInfoAt, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, HAppend.hAppend, ToString.toString, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Lean.Elab.Tactic.Conv.evalSimpMatch,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.Conv.getLhs, liftM, Lean.Meta.Split.simpMatch, Lean.Elab.Tactic.Conv.applySimpResult],[Lean.Elab.Tactic.Tactic]]
[Lean.Compiler.cacheSpecialization,[Lean.PersistentEnvExtension.addEntry, Lean.Compiler.specExtension, Lean.Compiler.SpecEntry.cache],[Lean.Environment]]
[Classical.decidableInhabited,[Inhabited.mk, inferInstance],[Inhabited, Decidable]]
[Function.surjective.forall,[Iff.intro],[Iff]]
[Nat.gcd_self,[of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.gcd, Nat.zero_eq, Nat.gcd_zero_right, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true, Eq.symm, congrFun, Nat.gcd_succ, Nat.succ, Nat.mod_self, Nat.gcd_zero_left, eq_self],[Eq, Nat.gcd]]
[Lean.Meta.CheckAssignmentQuick.check,[Lean.Meta.CheckAssignmentQuick.check.visit],[Bool]]
[Lean.Parser.Term.sorry.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Std.HashMap.instInhabitedHashMap,[Inhabited.mk, Std.mkHashMap, OfNat.ofNat],[Inhabited, Std.HashMap]]
[Lean.Parser.instInhabitedLeadingIdentBehavior,[Inhabited.mk, Lean.Parser.LeadingIdentBehavior.default],[Inhabited, Lean.Parser.LeadingIdentBehavior]]
[Lean.IR.DeclInfo.mk.inj,[],[Eq]]
[Std.PersistentHashMap.Entry.ref.inj,[],[Eq]]
[Lean.Elab.Info.ofCommandInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Info.ofCommandInfo, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Tactic.Conv.evalNestedTactic,[Bind.bind, Lean.Elab.Tactic.getMainTarget, Option.none, Lean.Elab.Tactic.TacticM, Unit, Lean.isLHSGoal?, Lean.Elab.Tactic.liftMetaTactic1, coeM, Lean.Meta.replaceTargetDefEq, Lean.Expr.mdataExpr!, Pure.pure, PUnit.unit],[Lean.Elab.Tactic.Tactic]]
[IO.Error.mkIllegalOperation,[IO.Error.illegalOperation],[IO.Error]]
[Lean.Elab.Command.InductiveView.shortDeclName,[],[Lean.Name]]
[Lean.Parser.Tactic.squeezeSimp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Elab.Command.aux_def,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[SeqRight.seqRight,[],[]]
[Lean.Meta.changeLocalDecl,[Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.revert, List.toArray, List.cons, List.nil, Bool.true, Lean.Meta.MetaM, Lean.MVarId, Lean.Meta.withMVarContext, Lean.Meta.getMVarType, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.mkForall, Lean.Expr.Data.binderInfo, Lean.mkLet, Bool.false, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.Occurrences.pos.injEq,[Eq.propIntro, Eq.refl, Lean.Occurrences.pos, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Occurrences.pos]]
[Lean.Elab.Command.StructFieldView.mk.inj,[And.intro],[And, Eq]]
[Lean.RecursorVal.numMinors,[],[Nat]]
[Nat.div_eq_of_lt_le,[],[Eq, HDiv.hDiv]]
[Std.PersistentHashMap.shift,[OfNat.ofNat],[USize]]
[Lean.MessageData.instCoeNameMessageData,[Coe.mk, Lean.MessageData.ofName],[Coe, Lean.Name, Lean.MessageData]]
[ByteArray.mkEmpty,[ByteArray.mk, List.toArray, List.nil],[ByteArray]]
[Std.PersistentHashSet.empty,[Std.PersistentHashSet.mk, Std.PersistentHashMap.empty],[Std.PersistentHashSet]]
[Lean.Parser.suppressInsideQuot,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.suppressInsideQuotFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Decidable.or_iff_not_imp_right,[Iff.trans, Or.comm, Decidable.or_iff_not_imp_left],[Iff, Or]]
[Mathlib.Tactic.Lint.instDecidableEqLintVerbosity,[dite, Eq, Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx, Decidable.isTrue, Mathlib.Tactic.Lint.instDecidableEqLintVerbosity.proof_1, Decidable.isFalse, Mathlib.Tactic.Lint.instDecidableEqLintVerbosity.proof_2],[DecidableEq, Mathlib.Tactic.Lint.LintVerbosity]]
[Lean.Parser.Term.macroDollarArg.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Server.Completion.M,[OptionT, StateRefT', IO.RealWorld, Lean.Server.Completion.State, Lean.Meta.MetaM],[]]
[Lean.JsonRpc.Request.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.nestedTactic.parenthesizer,[Lean.Parser.Tactic.tacticSeqBracketed.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.gcd_eq_left,[Nat.dvd_antisymm, Nat.gcd_dvd_left, Nat.dvd_gcd, Nat.dvd_refl],[Eq, Nat.gcd]]
[Lean.Name.components,[List.reverse, Lean.Name.components'],[List, Lean.Name]]
[Lean.Level.dec,[Option, Lean.Level, Option.none, Option.some, OptionM.run, Bind.bind, PProd.fst, PProd.snd, Pure.pure, Lean.mkLevelMax],[Option, Lean.Level]]
[Lean.Lsp.DocumentFilter.mk.inj,[And.intro],[And, Eq]]
[Nat.add_le_add_right,[Eq.mpr, Eq.refl, LE.le, HAdd.hAdd, Nat.add_comm, Nat.add_le_add_left],[LE.le, HAdd.hAdd]]
[Lean.Lsp.instFromJsonClientInfo,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, String, Option, Pure.pure, Lean.Lsp.ClientInfo.mk],[Lean.FromJson, Lean.Lsp.ClientInfo]]
[Lean.IR.ExplicitBoxing.BoxingContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.ExplicitBoxing.BoxingContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.ExplicitBoxing.BoxingContext.mk, And]]
[Lean.JsonRpc.instInhabitedNotification,[Inhabited.mk, Lean.JsonRpc.Notification.mk, arbitrary],[Inhabited, Lean.JsonRpc.Notification]]
[evalGuardHyp,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[AddCommMonoid.noConfusionType,[],[]]
[Lean.IR.ExplicitBoxing.getEnv,[Functor.map, Lean.IR.ExplicitBoxing.BoxingContext.env, MonadReader.read],[Lean.IR.ExplicitBoxing.M, Lean.Environment]]
[Lean.NameTrie.find?,[Lean.PrefixTree.find?, List.nil, List, Lean.NamePart, PProd.fst, List.cons, Lean.NamePart.str, Lean.NamePart.num],[Option]]
[DivInvMonoid.gpow_neg',[],[Eq, DivInvMonoid.gpow, Int.negSucc, Inv.inv, Int.ofNat, Nat.succ]]
[Lean.IR.instBEqCtorInfo,[BEq.mk, Lean.IR.CtorInfo.beq],[BEq, Lean.IR.CtorInfo]]
[Lean.Meta.withLocalDeclsD,[Lean.Meta.withLocalDecls, Array.map, Prod, Lean.Name, Lean.BinderInfo, Lean.Expr, Prod.mk, Lean.BinderInfo.default],[]]
[Option.isSome,[Unit.unit, Bool, Bool.true, Bool.false],[Bool]]
[Nat.succ_mul_succ_eq,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Nat.succ, HAdd.hAdd, OfNat.ofNat, Nat.mul_succ, Nat.succ_mul, Nat.add_right_comm, rfl],[Eq, HMul.hMul, Nat.succ, HAdd.hAdd, OfNat.ofNat]]
[MonadControl.liftWith,[],[]]
[Lean.Lsp.instFileSourceDocumentSymbolParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.DocumentSymbolParams.textDocument],[Lean.Lsp.FileSource, Lean.Lsp.DocumentSymbolParams]]
[UInt32.xor,[UInt32.mk, Fin.xor, UInt32.val],[UInt32]]
[Lean.IR.updateLiveVars,[Lean.IR.LiveVars.collectExpr],[Lean.IR.LiveVarSet]]
[Lean.Meta.RecursorInfo.motivePos,[Lean.Meta.RecursorInfo.numParams],[Nat]]
[Lean.Syntax.MonadTraverser.getIdx,[Bind.bind, MonadState.get, Pure.pure, Option.getD, Array.back?, Lean.Syntax.Traverser.idxs, OfNat.ofNat],[Nat]]
[Lean.ExternAttrData.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ExternAttrData.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.instInhabitedReducibilityHints,[Inhabited.mk, Lean.ReducibilityHints.opaque],[Inhabited, Lean.ReducibilityHints]]
[Lean.MessageDataContext.env,[],[Lean.Environment]]
[Lean.Server.Watchdog.shutdown,[Bind.bind, MonadReader.read, ST.Ref.get, Lean.Server.Watchdog.ServerContext.fileWorkersRef, ForIn.forIn, PUnit.unit, Lean.Server.Watchdog.ServerM, ForInStep, PUnit, Lean.Server.Watchdog.terminateFileWorker, Pure.pure, ForInStep.yield, Functor.discard, liftM, IO.wait, Lean.Server.Watchdog.FileWorker.commTask],[Lean.Server.Watchdog.ServerM, Unit]]
[Lean.Lsp.instToJsonCompletionOptions,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Lsp.CompletionOptions.triggerCharacters?, Lean.Lsp.CompletionOptions.allCommitCharacters?, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.CompletionOptions.resolveProvider, List.nil],[Lean.ToJson, Lean.Lsp.CompletionOptions]]
[Lean.MessageData.ofGoal.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MessageData.ofGoal, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.addBuiltinParser,[Bind.bind, ST.Ref.get, Lean.Parser.builtinParserCategoriesRef, IO.ofExcept, Lean.Parser.addParser, ST.Ref.set, ST.Ref.modify, Lean.Parser.builtinSyntaxNodeKindSetRef, Lean.Parser.ParserInfo.collectKinds, Lean.Parser.Parser.info, ST.Ref.swap, Lean.Parser.builtinTokenTable, EmptyCollection.emptyCollection, IO, Unit, Lean.Parser.addParserTokens, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString],[IO, Unit]]
[Std.PersistentHashMap.find!,[Unit.unit, Std.PersistentHashMap.find?, panicWithPosWithDecl, OfNat.ofNat],[]]
[List.nil_append,[rfl],[Eq, HAppend.hAppend, List.nil]]
[Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.Do.ToTerm.matchNestedTermResult,[Bind.bind, Array.mapM, Lean.mkIdentFromRef, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Array.getOp, Array.foldrM, Array.back, Array.extract, HSub.hSub, Unit.unit, Lean.MacroM, List, Lean.Syntax, Array.isEmpty, Functor.map, panicWithPosWithDecl],[Lean.MacroM, List, Lean.Syntax]]
[Lean.Xml.Parser.VersionNum,[SeqLeft.seqLeft, Lean.Parsec.skipString, Lean.Parsec.many1, Lean.Parsec.digit],[Lean.Parsec, Unit]]
[Lean.instInhabitedStructureState,[Inhabited.mk, arbitrary],[Inhabited]]
[Lean.Server.Watchdog.OpenDocument.noConfusionType,[],[]]
[Lean.Parser.Command.private.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Function.left_inverse_iff_comp,[Iff.intro, Function.left_inverse.comp_eq_id, congr_fun],[Iff, Function.left_inverse, Eq, Function.comp, id]]
[Lean.Elab.Term.Do.DoIfView.mk.inj,[And.intro],[And, Eq]]
[Lean.Expr.isConst,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Elab.Term.LVal.fieldName.inj,[And.intro],[And, Eq]]
[Lean.getModuleDoc?,[Option.map, Lean.PersistentEnvExtension.getModuleEntries, Lean.Environment.getModuleIdx?],[Option, Array, String]]
[Classical.byContradiction,[Decidable.byContradiction],[]]
[PLift.down,[],[]]
[UInt32.modn,[UInt32.mk, HMod.hMod, UInt32.val],[UInt32]]
[Std.ShareCommon.Object.ptrEq,[BEq.beq, ptrAddrUnsafe],[Bool]]
[Lean.Lsp.WorkspaceFolder.uri,[],[Lean.Lsp.DocumentUri]]
[IO.FS.Stream.readLspRequestAs,[MonadExcept.tryCatch, Bind.bind, Unit.unit, IO, Nat, List.lookup, String.toNat?, Pure.pure, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, IO.FS.Stream.readRequestAs],[IO, Lean.JsonRpc.Request]]
[Lean.Meta.InductionSubgoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.InductionSubgoal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.InductionSubgoal.mk, And]]
[Lean.Elab.Term.applyResult,[Lean.Elab.Term.TermElabM, Bind.bind, Lean.Elab.Term.SavedState.restore, Bool.true, Pure.pure, MonadExcept.throw],[Lean.Elab.Term.TermElabM]]
[Array.getD,[dite, LT.lt, Array.size, Array.get, Fin.mk],[]]
[Std.HashSet.contains,[Bool, Std.HashSetImp.contains],[Bool]]
[Lean.Parser.Term.doIfCond.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.none, Bool.false, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.doIfLet.parenthesizer, Lean.Parser.Term.doIfProp.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.instToJsonPlainTermGoal,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.PlainTermGoal.goal, List.nil, Lean.Lsp.PlainTermGoal.range],[Lean.ToJson, Lean.Lsp.PlainTermGoal]]
[Lean.Lsp.DiagnosticWith.range,[],[Lean.Lsp.Range]]
[OfScientific.ofScientific,[],[]]
[Lean.Parser.Tactic.symm',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Std.PersistentArray.Stats.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.PersistentArray.Stats.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.Do.isMutableLet,[and, or, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, not, Lean.Syntax.isNone, Lean.Syntax.getOp, OfNat.ofNat],[Bool]]
[Lean.Compiler.SpecEntry.noConfusionType,[],[]]
[Substring.all,[not, Substring.any],[Bool]]
[Lean.Elab.Term.Do.getDoPatDeclVars,[Lean.Elab.Term.Do.getPatternVarsEx],[Lean.Elab.Term.TermElabM, Array, Lean.Name]]
[Lean.Elab.Term.CollectPatternVars.Context.namedArgs,[],[Array, Lean.Elab.Term.NamedArg]]
[Lean.Meta.AbstractMVars.State.lmap,[],[Std.HashMap, Lean.MVarId, Lean.Level]]
[Lean.Compiler.isOfNat,[List.any, Lean.Compiler.numScalarTypes, BEq.beq, Lean.Compiler.NumScalarTypeInfo.ofNatFn],[Bool]]
[Lean.JsonRpc.Message.notification.inj,[And.intro],[And, Eq]]
[Lean.mkProj,[Lean.Expr.proj, Lean.Expr.mkData, mixHash, UInt8.toUInt64, Hashable.hash, Lean.Expr.looseBVarRange, Lean.Expr.hasFVar, Lean.Expr.hasExprMVar, Lean.Expr.hasLevelMVar, Lean.Expr.hasLevelParam],[Lean.Expr]]
[Lean.Lsp.instInhabitedDiagnosticTag,[Inhabited.mk, Lean.Lsp.DiagnosticTag.unnecessary],[Inhabited, Lean.Lsp.DiagnosticTag]]
[Lean.PrettyPrinter.Formatter.ident.formatter,[Lean.Parser.Term.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Command.Scope.varUIds,[],[Array, Lean.Name]]
[Lean.Meta.lambdaMetaTelescope,[List.toArray, List.nil, OfNat.ofNat, Lean.Meta.lambdaMetaTelescope.process],[Lean.Meta.MetaM, Prod, Array, Lean.Expr, Lean.BinderInfo]]
[Lean.MessageData.tagged.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MessageData.tagged, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MessageData.tagged, And]]
[Lean.Parser.Command.axiom.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.Command.declSig.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.scientificLit,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.scientificLitKind, Bool.true, Lean.Parser.scientificLitNoAntiquot],[Lean.Parser.Parser]]
[Lean.Compiler.mkLcProof,[Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.Expr]]
[Lean.Lsp.DocumentHighlightParams.noConfusionType,[],[]]
[Lean.IR.AltCore.default.inj,[],[Eq]]
[Set.«term{_|_}_1»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Mathlib.ExtendedBinder.extBinders],[Lean.ParserDescr]]
[Lean.Elab.Term.levelMVarToParam,[Bind.bind, Lean.MonadMCtx.getMCtx, Lean.Elab.Term.getLevelNames, liftM, Lean.Meta.setMCtx, Lean.MetavarContext.UnivMVarParamResult.mctx, Pure.pure, Prod.mk, Lean.MetavarContext.UnivMVarParamResult.expr, Lean.MetavarContext.UnivMVarParamResult.nextParamIdx],[Lean.Elab.Term.TermElabM, Prod, Lean.Expr, Nat]]
[Lean.ParametricAttributeImpl.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ParametricAttributeImpl.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ParametricAttributeImpl.mk, And]]
[Lean.Meta.MVarRenaming.mk.inj,[],[Eq]]
[Lean.Parser.Term.str.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.strLit.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.instFromJsonDiagnosticCode,[Lean.FromJson.mk, Lean.Json.null, Lean.Json.bool, dite, Eq, Eq.symm, Lean.Json.num, Lean.JsonNumber.mk, Lean.Json.arr, Lean.Json.obj, Except, String, Lean.Lsp.DiagnosticCode, Pure.pure, Lean.Lsp.DiagnosticCode.int, Lean.Lsp.DiagnosticCode.string, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.FromJson, Lean.Lsp.DiagnosticCode]]
[Lean.Xml.Content.Comment.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Xml.Content.Comment, HAdd.hAdd, OfNat.ofNat]]
[Lean.instMonadResolveName,[Lean.MonadResolveName.mk, liftM, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls],[Lean.MonadResolveName]]
[Lean.Meta.mkAppOptM,[Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.withNewMCtxDepth, Bind.bind, Lean.getConstInfo, List.mapM, Lean.Meta.mkFreshLevelMVar, Lean.ConstantInfo.levelParams, Pure.pure, Prod.mk, Lean.Meta.MetaM, Lean.Expr, OfNat.ofNat, List.toArray, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Meta.instOrElseMetaM,[OrElse.mk, Lean.Meta.orElse],[OrElse, Lean.Meta.MetaM]]
[Lean.Elab.Term.expandTermUnless,[Lean.withRef, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.Macro]]
[Lean.Meta.CaseArraySizesSubgoal.diseqs,[],[Array, Lean.FVarId]]
[ST.Ref.noConfusionType,[],[]]
[Lean.StructureFieldInfo.fieldName,[],[Lean.Name]]
[Lean.LocalInstance.className,[],[Lean.Name]]
[FloatArray.foldlMUnsafe.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bind.bind, FloatArray.uget, lcProof, FloatArray.foldlMUnsafe.fold, HAdd.hAdd, OfNat.ofNat],[]]
[IO.FS.Mode.readWrite.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.Mode.readWrite, OfNat.ofNat]]
[Lean.Meta.SynthInstance.instInhabitedConsumerNode,[Inhabited.mk, Lean.Meta.SynthInstance.ConsumerNode.mk, arbitrary],[Inhabited, Lean.Meta.SynthInstance.ConsumerNode]]
[Lean.getPPExplicit,[Lean.KVMap.get, Lean.Option.name, Lean.pp.explicit, Lean.getPPAll],[Bool]]
[Lean.PrettyPrinter.Parenthesizer.symbolNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.throwErrorIfErrors,[Bind.bind, MonadState.get, ite, Eq, Lean.MessageLog.hasErrors, Lean.Elab.Term.State.messages, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElabM, Unit]]
[Nat.coprime.coprime_div_left,[Nat.coprime, HDiv.hDiv, Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, Nat.eq_zero_of_zero_dvd, Eq.mp, Dvd.dvd, congrFun, congrArg, Nat.zero_div, HMul.hMul, Nat.mul_div_cancel_left, Nat.coprime.coprime_mul_left],[Nat.coprime, HDiv.hDiv]]
[Lean.ScopedEnvExtension.Entry.scoped.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ScopedEnvExtension.Entry.scoped, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ScopedEnvExtension.Entry.scoped, And]]
[Lean.NameTrie.foldMatchingM,[Lean.PrefixTree.foldMatchingM, List.nil, List, Lean.NamePart, PProd.fst, List.cons, Lean.NamePart.str, Lean.NamePart.num],[]]
[Lean.Meta.withMCtx,[Lean.Meta.mapMetaM, Bind.bind, Lean.MonadMCtx.getMCtx, Lean.Meta.setMCtx, tryFinally],[]]
[UInt32.instNumericUInt32,[Numeric.mk, UInt32.mk, Numeric.ofNat],[Numeric, UInt32]]
[Lean.Level.isMaxIMax,[Lean.Level.zero, Lean.Level.succ, Lean.Level.param, Lean.Level.mvar, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Parser.Command.optDeclSig,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.many, Lean.Parser.ppSpace, HOrElse.hOrElse, Lean.Parser.Term.simpleBinderWithoutType, Lean.Parser.Term.bracketedBinder, Bool.false, Lean.Parser.Term.optType],[Lean.Parser.Parser]]
[Lean.Elab.Term.Context.mayPostpone,[],[Bool]]
[Lean.KeyedDeclsAttribute.AttributeEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KeyedDeclsAttribute.AttributeEntry.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.DiscrTree.Key.fvar.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.DiscrTree.Key.fvar, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.DiscrTree.Key.fvar, And]]
[IO.toEIO,[EStateM.adaptExcept],[EIO]]
[Tactic.DeclCache.get,[Bind.bind, Tactic.Cache.get, Prod.fst, Lean.MonadEnv.getEnv, ForIn.forIn, Lean.Meta.MetaM, ForInStep, Prod.snd, Pure.pure, PUnit.unit, ForInStep.yield],[Lean.Meta.MetaM]]
[Lean.instInhabitedMessage,[Inhabited.mk, Lean.Message.mk, arbitrary],[Inhabited, Lean.Message]]
[Lean.Elab.Term.elabForall,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Term.elabBinders, Bind.bind, Lean.Elab.Term.elabType, liftM, Lean.Meta.mkForallFVars, Bool.false, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElab]]
[Lean.Elab.Term.ElabAppArgs.synthesizeAppInstMVars,[Bind.bind, MonadState.get, modify, Lean.Elab.Term.ElabAppArgs.State.mk, Lean.Elab.Term.ElabAppArgs.State.explicit, Lean.Elab.Term.ElabAppArgs.State.f, Lean.Elab.Term.ElabAppArgs.State.fType, Lean.Elab.Term.ElabAppArgs.State.args, Lean.Elab.Term.ElabAppArgs.State.namedArgs, Lean.Elab.Term.ElabAppArgs.State.ellipsis, Lean.Elab.Term.ElabAppArgs.State.expectedType?, Lean.Elab.Term.ElabAppArgs.State.etaArgs, Lean.Elab.Term.ElabAppArgs.State.toSetErrorCtx, List.toArray, List.nil, Lean.Elab.Term.ElabAppArgs.State.propagateExpected, liftM, Lean.Elab.Term.synthesizeAppInstMVars],[Lean.Elab.Term.ElabAppArgs.M, Unit]]
[Lean.Widget.InfoPopup.type,[],[Option, Lean.Widget.CodeWithInfos]]
[instMonadExceptOfEIO,[inferInstanceAs, MonadExceptOf, EStateM, IO.RealWorld],[MonadExceptOf, EIO]]
[Lean.Meta.CongrArgKind.fixedNoParam.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.CongrArgKind.fixedNoParam, OfNat.ofNat]]
[CommGroup.noConfusionType,[],[]]
[Nat.noConfusionType,[],[]]
[Lean.JsonRpc.RequestID.str.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.JsonRpc.RequestID.str, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.UnreachableBranches.Assignment,[Std.HashMap, Lean.IR.VarId, Lean.IR.UnreachableBranches.Value],[]]
[Lean.Lsp.Command.mk.inj,[And.intro],[And, Eq]]
[noConfusionTypeEnum,[ite, Eq],[]]
[Lean.LocalDecl.hasExprMVar,[Bool, Lean.Expr.hasExprMVar, or],[Bool]]
[Lean.Elab.Term.Quotation.HeadCheck.shape.inj,[And.intro],[And, Eq]]
[Lean.Widget.TaggedText.text.inj,[],[Eq]]
[Lean.Parser.Command.elabTail.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.darrow.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.declareBuiltin,[Bind.bind, Lean.MonadEnv.getEnv, Lean.Core.CoreM, Unit, Lean.Environment.addAndCompile, Lean.KVMap.mk, liftM, Lean.MessageData.toString, Lean.KernelException.toMessageData, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, IO.ofExcept, Lean.setBuiltinInitAttr, Lean.Name.anonymous, Lean.setEnv],[Lean.Core.CoreM, Unit]]
[Decidable.not_imp_self,[],[Iff]]
[Iff.trans,[Iff.intro, Iff.mp, Iff.mpr],[Iff]]
[Lean.Parser.Trie.Node.inj,[And.intro],[And, Eq]]
[Lean.Parser.ParserState.toErrorMsg,[Unit.unit, String, Lean.Parser.ParserState.errorMsg, Lean.mkErrorStringWithPos, Lean.Parser.InputContext.fileName, Lean.Parser.ParserContext.toInputContext, ToString.toString, Option.none],[String]]
[Applicative.toSeq,[],[Seq]]
[Lean.ClassEntry.lt,[Lean.Name.quickLt, Lean.ClassEntry.name],[Bool]]
[Lean.PrettyPrinter.Formatter.withOpen.formatter,[],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.SizeOfSpecNested.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SizeOfSpecNested.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[instMulUInt8,[Mul.mk, UInt8.mul],[Mul, UInt8]]
[Lean.KernelException.declHasMVars.inj,[And.intro],[And, Eq]]
[Lean.IR.LogEntry.message.inj,[],[Eq]]
[UInt8.instRingUInt8.proof_3,[congrArg, UInt8.mk, Ring.gsmul_succ', UInt8.val],[Eq, UInt8.mk, Ring.gsmul, Int.ofNat, Nat.succ, UInt8.val]]
[Lean.ParserCompiler.CombinatorAttribute.setDeclFor,[Lean.PersistentEnvExtension.addEntry, Lean.ParserCompiler.CombinatorAttribute.ext, Prod.mk],[Lean.Environment]]
[Lean.SimplePersistentEnvExtensionDescr.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.SimplePersistentEnvExtensionDescr.mk, HAdd.hAdd, OfNat.ofNat]]
[guard,[ite, Pure.pure, Unit.unit, Alternative.failure],[Unit]]
[Lean.Parser.Term.doSeq.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.doSeqBracketed.parenthesizer, Lean.Parser.Term.doSeqIndent.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Compiler.atMostOnce.AtMostOnceData.noConfusionType,[],[]]
[Lean.unreachIsNodeAtom,[False.elim, Lean.unreachIsNodeAtom.proof_1],[]]
[Lean.LOption.some.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.LOption.some, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.Watchdog.ServerEvent.clientError.inj,[],[Eq]]
[List.mem,[Unit.unit, False, Or, Eq, PProd.fst],[]]
[Lean.Elab.Frontend.updateCmdPos,[modify, Lean.Elab.Frontend.State.mk, Lean.Elab.Frontend.State.commandState, Lean.Elab.Frontend.State.parserState, Lean.Parser.ModuleParserState.pos, Lean.Elab.Frontend.State.commands],[Lean.Elab.Frontend.FrontendM, Unit]]
[String.prev,[String.Pos, ite, Eq, OfNat.ofNat, PProd.fst],[String.Pos]]
[Lean.Parser.Term.quotedName.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.nameLit.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.isPrivateNameExport,[Lean.isPrivateName],[Bool]]
[Lean.Parser.Command.mixfixKind.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.prefix.parenthesizer, Lean.Parser.Command.infix.parenthesizer, Lean.Parser.Command.infixl.parenthesizer, Lean.Parser.Command.infixr.parenthesizer, Lean.Parser.Command.postfix.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[PSigma.lexNdepWf,[PSigma.lexNdepWf.proof_1],[WellFounded, PSigma.lexNdep]]
[Lean.NameSet.empty,[Std.mkRBTree, Lean.Name, Lean.Name.quickCmp],[Lean.NameSet]]
[Lean.Meta.Simp.ConfigCtx.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Simp.ConfigCtx.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.instEmptyCollectionFVarIdMap,[inferInstanceAs, EmptyCollection, Std.RBMap, Lean.FVarId, Lean.Name.quickCmp, Lean.FVarId.name],[EmptyCollection, Lean.FVarIdMap]]
[Lean.Lsp.WorkDoneProgressReport.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.WorkDoneProgressReport.mk, HAdd.hAdd, OfNat.ofNat]]
[Tactic.Ring.horner_const_mul,[of_eq_true, Eq.trans, congr, congrArg, Eq, mul_add, HMul.hMul, HPow.hPow, HAdd.hAdd, congrFun, Eq.symm, mul_assoc, eq_self],[Eq, HMul.hMul, Tactic.Ring.horner]]
[Lean.Lsp.CompletionList.isIncomplete,[],[Bool]]
[ST.Ref.set,[liftM, ST.Prim.Ref.set],[Unit]]
[Lean.TransformStep.visit.injEq,[Eq.propIntro, Eq.refl, Lean.TransformStep.visit, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.TransformStep.visit]]
[IO.Error.mkResourceExhausted,[IO.Error.resourceExhausted, Option.none],[IO.Error]]
[Lean.IR.CompilerState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.CompilerState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Expr.isMData,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Parser.PrattParsingTables.leadingTable,[],[Lean.Parser.TokenMap, Prod, Lean.Parser.Parser, Nat]]
[ReaderT.bind,[Bind.bind],[ReaderT]]
[instIsAddLeftCancel.proof_1,[Eq.mpr, Eq.refl, Eq, Eq.symm, neg_add_cancel_left, HAdd.hAdd, Neg.neg, rfl],[Eq]]
[if_congr_prop,[if_ctx_congr_prop],[Iff, ite]]
[Lean.Level.format,[Lean.Level.PP.Result.format, Lean.Level.PP.toResult, Bool.true],[Std.Format]]
[Lean.Lsp.instFromJsonDiagnosticTag,[Lean.FromJson.mk, Except.error, dite, Eq, Unit.unit, Eq.symm, Except.ok, Except, String, Lean.Lsp.DiagnosticTag, Lean.Json.getNat?, Pure.pure, Lean.Lsp.DiagnosticTag.unnecessary, Lean.Lsp.DiagnosticTag.deprecated, MonadExcept.throw],[Lean.FromJson, Lean.Lsp.DiagnosticTag]]
[Lean.IR.ExpandResetReuse.main,[Lean.IR.Decl.extern, Lean.IR.Decl, Lean.IR.Decl.updateBody!],[Lean.IR.Decl]]
[byContra,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[instDecidableAnd.proof_2,[And.left],[False]]
[Lean.Elab.Command.StructView.parents,[],[Array, Lean.Syntax]]
[Lean.Widget.instInhabitedMsgToInteractive,[Inhabited.mk, Lean.Widget.MsgToInteractive.mk, arbitrary],[Inhabited, Lean.Widget.MsgToInteractive]]
[Std.PersistentArray.isEmpty,[BEq.beq, Std.PersistentArray.size, OfNat.ofNat],[Bool]]
[Lean.Elab.Term.saveContext,[Bind.bind, MonadReader.read, Lean.MonadOptions.getOptions, Lean.MonadResolveName.getOpenDecls, Pure.pure, Lean.Elab.Term.SavedContext.mk, Lean.Elab.Term.Context.declName?, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.errToSorry],[Lean.Elab.Term.TermElabM, Lean.Elab.Term.SavedContext]]
[coeOfTC,[CoeHTCT.mk, coeTC],[CoeHTCT]]
[Lean.ParserCompiler.Context.categoryAttr,[],[Lean.KeyedDeclsAttribute]]
[Lean.Elab.Deriving.Ord.mkAuxFunction,[Bind.bind, Pure.pure, Array.getOp, Lean.Elab.Deriving.Context.auxFunNames, Lean.Elab.Deriving.Context.typeInfos, Lean.Elab.Deriving.Ord.mkOrdHeader, Lean.Elab.Deriving.Ord.mkMatch, ite, Eq, or, Lean.Elab.Deriving.Context.usePartial, Lean.InductiveVal.isRec, Bool.true, Lean.Elab.Deriving.mkLocalInstanceLetDecls, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.Deriving.Header.argNames, Lean.Elab.Deriving.mkLet, PUnit.unit],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Lean.Xml.Parser.EnumeratedType,[HOrElse.hOrElse, Lean.Xml.Parser.NotationType, Lean.Xml.Parser.Enumeration],[Lean.Parsec, Unit]]
[Lean.Elab.addMacroStack,[Bind.bind, Lean.MonadOptions.getOptions, ite, Eq, not, Lean.Option.get, Lean.Elab.pp.macroStack, Bool.true, Pure.pure, Unit.unit, List.cons, Lean.MessageData, List.foldl, HAppend.hAppend, Lean.MessageData.ofFormat, Std.Format.line, Function.comp, Std.ToFormat.format, Lean.indentD, Lean.MessageData.ofSyntax, Lean.Elab.MacroStackElem.before],[Lean.MessageData]]
[Lean.Compiler.CSimp.replaceConstants,[Lean.Expr.replace, ite, Eq, Lean.Expr.isConst, Bool.true, Unit.unit, Option, Lean.Expr, Lean.SMap.find?, Lean.Expr.constName!, Option.some, Lean.mkConst, Lean.Expr.constLevels!, Option.none],[Lean.Expr]]
[Int.sub_nat_self,[Unit.unit, Eq, Int.subNatNat, OfNat.ofNat, rfl, Eq.mpr, Eq.refl, Nat.succ, Int.subNatNat_of_sub_eq_zero, HSub.hSub, Nat.sub_self, Int.ofNat, Int.ofNat_zero],[Eq, Int.subNatNat, OfNat.ofNat]]
[left_inv_eq_right_inv,[Eq.mpr, Eq.refl, Eq, Eq.symm, one_mul, HMul.hMul, OfNat.ofNat, mul_assoc, mul_one, rfl],[Eq]]
[List.mem_of_mem_erasep,[List.erasep_subset],[Mem.mem]]
[Lean.registerInitAttrUnsafe,[Lean.registerParametricAttribute, Lean.ParametricAttributeImpl.mk, Lean.AttributeImplCore.mk, Bind.bind, Lean.getConstInfo, Lean.Attribute.Builtin.getIdent?, Unit.unit, Lean.AttrM, Lean.Name, Lean.resolveGlobalConstNoOverload, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Expr, Option.some, Option.none, Lean.ConstantInfo.type, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, ite, BEq.beq, Bool.true, Pure.pure, Bool, Bool.false, MonadReader.read, liftM, Lean.isInitializerExecutionEnabled, and, ForIn.forIn, PUnit.unit, Lean.ImportM, ForInStep, PUnit, Lean.Name.isAnonymous, IO.ofExcept, Lean.Environment.evalConst, IO, Unit, Lean.ImportM.Context.env, Lean.ImportM.Context.opts, ForInStep.yield, Lean.runInit],[IO, Lean.ParametricAttribute, Lean.Name]]
[Lean.mkSepArray,[Id.run, Bind.bind, ForIn.forIn, MProd.mk, ite, GT.gt, OfNat.ofNat, Pure.pure, PUnit.unit, Id, Array, Lean.Syntax],[Array, Lean.Syntax]]
[Lean.Meta.RecursorInfo.numParams,[List.length, Lean.Meta.RecursorInfo.paramsPos],[Nat]]
[UInt32.val_eq_of_eq,[Eq, UInt32.val, congrArg],[Eq, UInt32.val]]
[Lean.Syntax.forArgsM,[Lean.Syntax.foldArgsM, Unit.unit],[Unit]]
[Lean.SMap.numBuckets,[Std.HashMap.numBuckets, Lean.SMap.map₁],[Nat]]
[Lean.Compiler.foldNatAdd,[Lean.Compiler.foldNatBinOp, Add.add],[Option, Lean.Expr]]
[Squash.lift,[Quot.lift, Squash.lift.proof_1],[]]
[Lean.IR.Borrow.BorrowInfState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Borrow.BorrowInfState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.liftMethod.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.minPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.leftArrow.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Tactic.Conv.convApply_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Server.Snapshots.Snapshot.mk.inj,[And.intro],[And, Eq]]
[Char.instDecidableLt,[UInt32.decLt, Char.val],[Decidable, LT.lt]]
[IO.Error.userError.injEq,[Eq.propIntro, Eq.refl, IO.Error.userError, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.userError]]
[Lean.Parser.ParserExtension.State.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.SimpAll.State.mvarId,[],[Lean.MVarId]]
[Lean.Parser.Command.classTk,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Parser.Attr.recursor,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.numLit],[Lean.Parser.Parser]]
[Lean.Widget.MsgEmbed.lazyTrace.inj,[And.intro],[And, Eq]]
[Lean.MetavarContext.instantiateMVarDeclMVars,[Lean.MetavarContext, Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Std.PersistentHashMap.insert, Lean.MetavarContext.decls, Lean.MetavarDecl.mk, Lean.MetavarDecl.userName, Lean.MetavarDecl.depth, Lean.MetavarDecl.localInstances, Lean.MetavarDecl.kind, Lean.MetavarDecl.numScopeArgs, Lean.MetavarDecl.index, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment],[Lean.MetavarContext]]
[Lean.Parser.Tactic.nthRw,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Lsp.DiagnosticTag.deprecated.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.DiagnosticTag.deprecated, OfNat.ofNat]]
[GroupWithZero.noConfusionType,[],[]]
[Lean.Parsec,[Lean.Parsec.ParseResult],[]]
[Lean.Meta.getParamNames,[Bind.bind, Lean.getConstInfo, Lean.Meta.forallTelescopeReducing, Lean.ConstantInfo.type, Array.mapM, Lean.Meta.getLocalDecl, Lean.Expr.fvarId!, Pure.pure, Lean.LocalDecl.userName],[Lean.Meta.MetaM, Array, Lean.Name]]
[Lean.Lsp.DocumentFilter.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.DocumentFilter.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.DocumentFilter.mk, And]]
[Lean.Elab.Deriving.Repr.mkBody,[Bind.bind, Lean.MonadEnv.getEnv, ite, Eq, Lean.isStructure, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Bool.true, Lean.Elab.Deriving.Repr.mkBodyForStruct, Lean.Elab.Deriving.Repr.mkBodyForInduct],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[control,[controlAt],[]]
[Lean.Lsp.SemanticTokens.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.SemanticTokens.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.ExpandResetReuse.M,[ReaderT, Lean.IR.ExpandResetReuse.Context, StateM, Nat],[]]
[Lean.Json.bool.inj,[],[Eq]]
[ByteArray.instEmptyCollectionByteArray,[EmptyCollection.mk, ByteArray.empty],[EmptyCollection, ByteArray]]
[Lean.Meta.whnfR,[Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.reducible, Lean.Meta.whnf],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Parser.ParserAttributeHook.postAdd,[],[Lean.AttrM, Unit]]
[Lean.Elab.Term.Context.isNoncomputableSection,[],[Bool]]
[AddMonoid.toAddSemigroup,[],[AddSemigroup]]
[Std.PersistentHashMap.div2Shift,[USize.shiftRight],[USize]]
[List.instForInList,[ForIn.mk, List.forIn],[ForIn, List]]
[Lean.instInhabitedDeclarationRanges,[Inhabited.mk, Lean.DeclarationRanges.mk, arbitrary],[Inhabited, Lean.DeclarationRanges]]
[Lean.ScopedEnvExtension.Entry.noConfusionType,[],[]]
[Fin.xor,[Fin, Fin.mk, HMod.hMod, Nat.xor, Fin.xor.proof_1],[Fin]]
[StateT.get,[Pure.pure, Prod.mk],[StateT]]
[Lean.Literal.typeEx,[Lean.Literal.type],[Lean.Expr]]
[Lean.Elab.elabAttrs,[Bind.bind, ForIn.forIn, Lean.Elab.elabAttr, Pure.pure, PUnit.unit, ForInStep.yield],[Array, Lean.Elab.Attribute]]
[Lean.Elab.Command.mkDefViewOfInstance,[Bind.bind, Lean.Elab.liftMacroM, Lean.Elab.toAttributeKind, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.expandOptNamedPrio, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Lean.Quote.quote, List.nil, Lean.Elab.Command.CommandElabM, Lean.Elab.DefView, Unit.unit, Lean.Syntax.getOptional?, Lean.Elab.Command.MkInstanceName.main, Lean.mkNode, Lean.mkIdentFrom, Lean.mkNullNode],[Lean.Elab.Command.CommandElabM, Lean.Elab.DefView]]
[Nat.lcm_assoc,[Nat.dvd_antisymm, Nat.lcm_dvd, Nat.dvd_lcm_left, Nat.lcm, Nat.dvd_trans, Nat.dvd_lcm_right],[Eq, Nat.lcm]]
[Lean.Elab.Tactic.Conv.applySimpResult,[ite, Eq, Option.isNone, Lean.Meta.Simp.Result.proof?, Bool.true, Lean.Elab.Tactic.Conv.changeLhs, Lean.Meta.Simp.Result.expr, Bind.bind, liftM, Lean.Meta.Simp.Result.getProof, Lean.Elab.Tactic.Conv.updateLhs],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.PrettyPrinter.Parenthesizer.unicodeSymbolNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.PrettyPrinter.Formatter.checkOutsideQuot.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.IndPredBelow.getBelowIndices,[Bind.bind, Lean.getConstInfoCtor, Lean.Name.updatePrefix, HAppend.hAppend, Lean.ConstructorVal.induct, Lean.Name.mkStr, Lean.Name.anonymous, Lean.getConstInfoInduct, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, List.toArray, List.nil, OfNat.ofNat, Lean.Meta.IndPredBelow.getBelowIndices.loop],[Lean.Meta.MetaM, Array, Nat]]
[Lean.Xml.instToStringElement,[ToString.mk],[ToString, Lean.Xml.Element]]
[List.insert_of_mem,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, if_pos, List, List.cons, eq_self],[Eq, List.insert]]
[Lean.mkNoConfusion,[Bind.bind, Lean.isEnumType, ite, Eq, Bool.true, Lean.mkNoConfusionEnum, Lean.mkNoConfusionCore],[Lean.Meta.MetaM, Unit]]
[IO.FS.Stream.writeMessage,[IO.FS.Stream.writeJson, Lean.ToJson.toJson],[IO, Unit]]
[Lean.NameSSet.contains,[Lean.SSet.contains],[Bool]]
[Lean.Meta.renameMVar,[Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.renameMVar],[Lean.Meta.MetaM, Unit]]
[instAddCommMonoid,[AddCommMonoid.mk, AddCommGroup.add_comm],[AddCommMonoid]]
[Lean.Parser.FirstTokens.instToStringFirstTokens,[ToString.mk, Lean.Parser.FirstTokens.toStr],[ToString, Lean.Parser.FirstTokens]]
[Lean.Parser.Tactic.applyModCast,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.WF.TerminationHint.many.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.WF.TerminationHint.many, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.DiscrTree.Key.lit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.DiscrTree.Key.lit, HAdd.hAdd, OfNat.ofNat]]
[List.subset_cons,[Or.inr],[Subset.subset, List.cons]]
[List.length_replicate,[List.nil, List.length_replicate.aux],[Eq, List.length, List.replicate]]
[Array.reduceOption,[Array.filterMap, id, OfNat.ofNat, Array.size],[Array]]
[Lean.Lsp.DeclarationParams.toTextDocumentPositionParams,[],[Lean.Lsp.TextDocumentPositionParams]]
[Lean.MetavarContext.elimMVarDeps,[Lean.MetavarContext.MkBinding.elimMVarDeps],[Lean.MetavarContext.MkBindingM, Lean.Expr]]
[Lean.Lsp.PlainTermGoal.noConfusionType,[],[]]
[Lean.Meta.getMVarsNoDelayed,[Bind.bind, Lean.Meta.getMVars, Array.filterM, Functor.map, not, Lean.Meta.isDelayedAssigned, OfNat.ofNat, Array.size],[Lean.Meta.MetaM, Array, Lean.MVarId]]
[Lean.Lsp.DocumentSymbolResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.DocumentSymbolResult.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.ParserCategory.mk.inj,[And.intro],[And, Eq]]
[Lean.PrettyPrinter.Delaborator.delabDIte,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPNotation, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, guard, Eq, BEq.beq, Lean.Expr.getAppNumArgs, OfNat.ofNat, Bool.true, Lean.PrettyPrinter.Delaborator.SubExpr.withAppFn, Lean.PrettyPrinter.Delaborator.SubExpr.withAppArg, Lean.PrettyPrinter.Delaborator.delab, Option.none, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Option.some, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Lean.mkIdent, List.nil, Lean.PrettyPrinter.Delaborator.delabDIte.delabBranch],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.Meta.mkFunExt,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.KeyedDeclsAttribute.AttributeEntry.noConfusionType,[],[]]
[Lean.Expr.FindImpl.visited,[Bind.bind, MonadState.get, ite, Eq, BEq.beq, ptrAddrUnsafe, Bool.true, Pure.pure, modify, Lean.Expr.FindImpl.State.mk, Array.uset, Lean.Expr.FindImpl.State.keys, Lean.Expr.FindImpl.visited.proof_2, Bool.false],[Lean.Expr.FindImpl.FindM, Bool]]
[List.mem_of_ne_of_mem,[Or.elim, List.eq_or_mem_of_mem_cons, absurd],[Mem.mem]]
[Lean.Meta.replaceLocalDeclDefEq,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getMVarDecl, ite, Eq, BEq.beq, Lean.MetavarDecl.type, Bool.true, Pure.pure, Lean.MonadLCtx.getLCtx, Lean.Meta.getLocalInstances, Lean.Meta.mkFreshExprMVarAt, Lean.MetavarDecl.kind, Lean.MetavarDecl.userName, OfNat.ofNat, Lean.Meta.assignExprMVar, Lean.Expr.mvarId!],[Lean.Meta.MetaM, Lean.MVarId]]
[UInt8.le,[LE.le, UInt8.val],[]]
[Std.HashSetBucket.update.proof_1,[Eq.mpr, Eq.refl, GT.gt, Array.size, Array.uset, Subtype.val, OfNat.ofNat, Array.size_set, Fin.mk, USize.toNat, Subtype.property],[GT.gt, Array.size, Array.uset, Subtype.val, OfNat.ofNat]]
[String.nextUntil,[String.nextWhile, not],[String.Pos]]
[Set.term𝒫_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.IR.JoinPointId.mk.inj,[],[Eq]]
[Lean.Meta.SortLocalDecls.State.visited,[],[Lean.NameSet]]
[mul_comm,[CommSemigroup.mul_comm],[Eq, HMul.hMul]]
[Lean.Elab.GoalsAtResult.noConfusionType,[],[]]
[Lean.instFromJsonJsonNumber,[Lean.FromJson.mk, Lean.Json.getNum?],[Lean.FromJson, Lean.JsonNumber]]
[UInt64.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, UInt64.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Level.PP.Result.offset.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Level.PP.Result.offset, HAdd.hAdd, OfNat.ofNat]]
[Lean.PersistentEnvExtensionDescr.mkInitial,[],[IO]]
[Nat.discriminate,[Eq.refl],[]]
[ByteArray.instAppendByteArray,[Append.mk, ByteArray.append],[Append, ByteArray]]
[Lean.Meta.Simp.ConfigCtx.toConfig,[],[Lean.Meta.Simp.Config]]
[UInt32.instCommRingUInt32,[CommRing.mk, UInt32.instCommRingUInt32.proof_1],[CommRing, UInt32]]
[TC.accessible,[TC.accessible.proof_1],[Acc, TC]]
[Lean.NameSSet.instEmptyCollectionNameSSet,[EmptyCollection.mk, Lean.NameSSet.empty],[EmptyCollection, Lean.NameSSet]]
[Lean.Parser.Syntax.sepBy1,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.syntaxParser, Lean.Parser.strLit, Lean.Parser.optional, Lean.Parser.nonReservedSymbol, Bool.false],[Lean.Parser.Parser]]
[instOrdFin,[Ord.mk, Ord.compare, Fin.val],[Ord, Fin]]
[Int.ofNat_mul_negSucc_ofNat,[rfl],[Eq, HMul.hMul, Int.ofNat, Int.negSucc, Int.negOfNat, Nat.succ]]
[HEq.trans,[HEq.subst],[HEq]]
[Lean.Parser.Tactic.padicIndexSimp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[«prec(_)»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Macro.instInhabitedState,[Inhabited.mk, Lean.Macro.State.mk, arbitrary],[Inhabited, Lean.Macro.State]]
[Lean.Meta.Match.MkMatcherInput.numDiscrs,[],[Nat]]
[Int.natMod,[Int.toNat, HMod.hMod],[Nat]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isFunLike,[Bind.bind, Lean.Meta.inferType, Lean.Meta.forallTelescopeReducing, Pure.pure, Decidable.decide, GT.gt, Array.size, OfNat.ofNat],[Lean.Meta.MetaM, Bool]]
[Lean.Meta.SimpLemma.levelParams,[],[Array, Lean.Name]]
[Lean.Elab.Term.MkInstResult.outParams,[],[Array, Lean.Expr]]
[ReaderT,[],[]]
[type_eq_of_heq.proof_1,[HEq.ndrecOn, Eq.refl],[Eq]]
[Lean.Meta.Hypothesis.userName,[],[Lean.Name]]
[Lean.ScopedEnvExtension.State.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.FVarSubst.isEmpty,[Std.AssocList.isEmpty, Lean.Meta.FVarSubst.map],[Bool]]
[dec_em,[Decidable.em],[Or, Not]]
[Lean.Elab.Command.StructFieldView.modifiers,[],[Lean.Elab.Modifiers]]
[Lean.InductiveVal.isRecEx,[Lean.InductiveVal.isRec],[Bool]]
[not_of_eq_false,[],[Not]]
[Set.sUnion,[setOf, Exists, And, Mem.mem],[Set]]
[Lean.Elab.Term.Do.ToTerm.instInhabitedKind,[Inhabited.mk, Lean.Elab.Term.Do.ToTerm.Kind.regular],[Inhabited, Lean.Elab.Term.Do.ToTerm.Kind]]
[Lean.Elab.Command.CtorView.noConfusionType,[],[]]
[Lean.MessageData.instCoeListExprMessageData,[Coe.mk, Lean.MessageData.ofList, List.map, Lean.MessageData.ofExpr],[Coe, List, Lean.Expr, Lean.MessageData]]
[min_le_left,[dite, LE.le, of_eq_true, Eq.trans, congrFun, congrArg, if_pos, eq_true, le_refl, Eq.mpr, if_neg, le_of_not_le],[LE.le, min]]
[Lean.Message.caption,[],[String]]
[Lean.Widget.CodeToken.info,[],[Lean.Server.WithRpcRef, Lean.Widget.InfoWithCtx]]
[Lean.Elab.Frontend.Context.inputCtx,[],[Lean.Parser.InputContext]]
[Lean.Meta.ToHide.fixpointStep,[Bind.bind, MonadReader.read, Lean.Meta.ToHide.visitVisibleExpr, Lean.Meta.ToHide.Context.goalTarget, Lean.MonadLCtx.getLCtx, Lean.LocalContext.forM, MonadState.get, ite, Eq, Std.RBTree.contains, Lean.Meta.ToHide.State.hiddenInaccessible, Bool.true, Lean.Meta.ToHide.hasVisibleDep, Lean.Meta.ToHide.unmark, Pure.pure, PUnit.unit, Lean.LocalDecl.type, Option.none, Lean.Meta.ToHide.M, PUnit, Lean.LocalDecl.value?, Unit.unit],[Lean.Meta.ToHide.M, Unit]]
[Lean.InternalExceptionId.noConfusionType,[],[]]
[Lean.Widget.InteractiveTermGoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Widget.InteractiveTermGoal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Widget.InteractiveTermGoal.mk, And]]
[Lean.IR.FnBody.uset.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.uset, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.FnBody.uset, And]]
[Lean.Elab.Term.Quotation.precheckParen,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Pure.pure, Unit.unit, Bind.bind, Lean.Elab.Term.Quotation.precheck, Array.forM, Lean.Syntax.SepArray.getElems, Array.size, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.Quotation.Precheck]]
[Lean.Elab.Term.expandParen,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, List.cons, Prod.mk, List.nil, Lean.Elab.Term.expandCDot?, Unit.unit, Lean.MacroM, Lean.Syntax, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, Lean.Syntax.atom, Lean.Macro.throwUnsupported, Lean.Elab.Term.mkPairs, HAppend.hAppend, Lean.Syntax.SepArray.getElems, Option.getD, and, not, Lean.Syntax.isMissing, Lean.Syntax.getOp, MonadExcept.throw, Lean.Macro.Exception.error],[Lean.Macro]]
[UInt32.val_eq_of_lt,[Fin.val_eq_of_lt],[Eq, Fin.val, UInt32.val, UInt32.ofNat]]
[not_iff_not_of_iff,[Iff.intro, Iff.elim_right, Iff.elim_left],[Iff, Not]]
[Lean.Lsp.SemanticTokensLegend.noConfusionType,[],[]]
[Lean.instInhabitedMVarId,[Inhabited.mk, Lean.MVarId.mk, arbitrary],[Inhabited, Lean.MVarId]]
[Lean.Parser.Command.structImplicitBinder,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.Command.declModifiers, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.Command.inferMod, Lean.Parser.Command.declSig],[Lean.Parser.Parser]]
[Lean.Meta.postprocessAppMVars,[Bind.bind, Lean.Meta.synthAppInstances, Lean.Meta.appendParentTag],[Lean.Meta.MetaM, Unit]]
[Lean.Meta.CongrLemmas.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.CongrLemmas.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.FileWorker.RefIdent.fvar.injEq,[Eq.propIntro, Eq.refl, Lean.Server.FileWorker.RefIdent.fvar, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.FileWorker.RefIdent.fvar]]
[Lean.mkNameMap,[Std.mkRBMap, Lean.Name, Lean.Name.quickCmp],[Lean.NameMap]]
[Lean.Lsp.SemanticTokenType.noConfusion,[noConfusionEnum, Lean.Lsp.SemanticTokenType.toCtorIdx],[Lean.Lsp.SemanticTokenType.noConfusionType]]
[Lean.Parser.Term.namedArgument.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.LocalContext.foldlM,[Std.PersistentArray.foldlM, Lean.LocalContext.decls, Unit.unit, Pure.pure],[]]
[Lean.Parser.Term.strictImplicitLeftBracket.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.group.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Nat.eq_zero_of_add_eq_zero,[And.intro, Nat.eq_zero_of_add_eq_zero_right, Nat.eq_zero_of_add_eq_zero_left],[And, Eq, OfNat.ofNat]]
[Std.Format.append.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.Format.append, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.BinderView.noConfusionType,[],[]]
[Option.orElse,[Option, Option.some, Unit.unit],[Option]]
[Lean.Meta.SimpLemmas.add.getName?,[Unit.unit, Lean.Meta.MetaM, Option, Lean.Name, Pure.pure, ite, Eq, Lean.Expr.isConst, Bool.true, Option.some, Lean.Expr.constName!, Lean.Expr.isFVar, Bind.bind, Lean.Meta.getFVarLocalDecl, Lean.LocalDecl.userName, Option.none],[Lean.Meta.MetaM, Option, Lean.Name]]
[Lean.Elab.Tactic.getMainGoal,[Bind.bind, Lean.Elab.Tactic.getGoals, Lean.Elab.Tactic.getMainGoal.loop],[Lean.Elab.Tactic.TacticM, Lean.MVarId]]
[Lean.Elab.Command.instMonadMacroAdapterCommandElabM,[Lean.Elab.MonadMacroAdapter.mk, Lean.MonadQuotation.getCurrMacroScope, Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Command.State.nextMacroScope, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState],[Lean.Elab.MonadMacroAdapter, Lean.Elab.Command.CommandElabM]]
[dif_eq_if,[Eq, dite, ite, rfl],[Eq, dite, ite]]
[Lean.TagAttribute.ext,[],[Lean.PersistentEnvExtension, Lean.Name, Lean.NameSet]]
[Lean.Syntax.instCoeArraySyntaxSepArray,[Coe.mk, Lean.Syntax.SepArray.ofElems],[Coe, Array, Lean.Syntax, Lean.Syntax.SepArray]]
[System.FilePath.exeExtension,[ite, Eq, System.Platform.isWindows, Bool.true],[String]]
[Lean.Meta.Match.withMkMatcherInput,[Bind.bind, Lean.Meta.getMatcherInfo?, Option.none, Lean.Meta.MetaM, Lean.getConstInfo, Lean.Meta.forallBoundedTelescope, Lean.ConstantInfo.type, Option.some, Lean.Meta.Match.MatcherInfo.arity, Lean.mkConstWithLevelParams, Lean.ConstantInfo.name, Lean.Meta.matchMatcherApp?, Lean.Meta.Match.getMkMatcherInputInContext, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM]]
[Lean.Lsp.SemanticTokensOptions.noConfusionType,[],[]]
[Lean.List.toExprAux,[Unit.unit, Lean.Expr, Lean.mkApp2, Lean.ToExpr.toExpr, PProd.fst],[Lean.Expr]]
[Lean.Elab.Command.checkValidFieldModifier,[ite, Eq, Lean.Elab.Modifiers.isNoncomputable, Bool.true, Bind.bind, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.MessageData.isNil,[Unit.unit, Lean.MessageData.ofFormat, Std.Format.line, Std.Format.text, Std.Format.nest, Std.Format.append, Std.Format.group, Std.Format.tag, Lean.MessageData.ofSyntax, Lean.MessageData.ofExpr, Lean.MessageData.ofLevel, Lean.MessageData.ofName, Lean.MessageData.ofGoal, Lean.MessageData.withContext, Lean.MessageData.withNamingContext, Lean.MessageData.nest, Lean.MessageData.group, Lean.MessageData.compose, Lean.MessageData.tagged, Lean.MessageData.node, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Core.Context.currRecDepth,[],[Nat]]
[Lean.Elab.Term.withDeclName,[MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Option.some, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.currMacroScope, Lean.Elab.Term.Context.mayPostpone, Lean.Elab.Term.Context.errToSorry, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.Term.Context.autoBoundImplicits, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection],[Lean.Elab.Term.TermElabM]]
[Inter.noConfusionType,[],[]]
[Lean.Parser.Term.doIf.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.doIfCond.formatter, Lean.Parser.Term.doSeq.formatter, Lean.Parser.many.formatter, Lean.PrettyPrinter.Formatter.checkColGe.formatter, Lean.Parser.group.formatter, Lean.Parser.Term.elseIf.formatter, Lean.Parser.optional.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.Match.Pattern.inaccessible.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.Pattern.inaccessible, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.ToHide.visitVisibleExpr,[Bind.bind, liftM, Lean.Meta.instantiateMVars, Lean.MonadCacheT.run, Lean.Meta.ToHide.visitVisibleExpr.visit],[Lean.Meta.ToHide.M, Unit]]
[Nat.lcm_one_right,[Nat.lcm_one_left, Nat.lcm_comm, OfNat.ofNat],[Eq, Nat.lcm, OfNat.ofNat]]
[Array.data_toArray,[Eq, List.toArray, Array.data, Array.ext', List.toArray_data],[Eq, List.toArray, Array.data]]
[Lean.Server.Watchdog.ServerEvent.clientMsg.inj,[],[Eq]]
[Lean.Elab.Term.MutualClosure.LetRecClosure.closed,[],[Lean.Expr]]
[Lean.Meta.Match.Alt.ref,[],[Lean.Syntax]]
[Lean.LocalContext.instForInLocalContextLocalDecl,[ForIn.mk, Std.PersistentArray.forIn, Lean.LocalContext.decls, Unit.unit, ForInStep, Pure.pure, ForInStep.yield],[ForIn, Lean.LocalContext, Lean.LocalDecl]]
[Lean.Json.obj.injEq,[Eq.propIntro, Eq.refl, Lean.Json.obj, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Json.obj]]
[Lean.Elab.Term.LetRecDeclView.ref,[],[Lean.Syntax]]
[Lean.Elab.Command.elabModuleDoc,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Lean.Elab.Command.CommandElabM, Unit, Lean.Syntax.getOp, OfNat.ofNat, Lean.MonadEnv.modifyEnv, Lean.addMainModuleDoc, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.ofSyntax],[Lean.Elab.Command.CommandElab]]
[Lean.Level.ctorToNat,[Nat, OfNat.ofNat],[Nat]]
[Lean.IR.Borrow.BorrowInfCtx.env,[],[Lean.Environment]]
[DivInvMonoid.toMonoid,[],[Monoid]]
[Lean.Parsec.instInhabitedParsec,[Inhabited.mk, Lean.Parsec.ParseResult.error],[Inhabited, Lean.Parsec]]
[Lean.Meta.decLevel,[Bind.bind, Lean.Meta.decLevel?, Unit.unit, Lean.Meta.MetaM, Lean.Level, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM, Lean.Level]]
[ne_or_eq,[em', Eq],[Or, Ne, Eq]]
[Lean.PrettyPrinter.Delaborator.instMonadWithReaderOfSubExprDelabM,[MonadWithReaderOf.mk, Lean.PrettyPrinter.Delaborator.Context.mk, Lean.PrettyPrinter.Delaborator.Context.defaultOptions, Lean.PrettyPrinter.Delaborator.Context.optionsPerPos, Lean.PrettyPrinter.Delaborator.Context.currNamespace, Lean.PrettyPrinter.Delaborator.Context.openDecls, Lean.PrettyPrinter.Delaborator.Context.inPattern, Lean.PrettyPrinter.Delaborator.Context.subExpr],[MonadWithReaderOf, Lean.PrettyPrinter.Delaborator.SubExpr, Lean.PrettyPrinter.Delaborator.DelabM]]
[Lean.Lsp.InitializationOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.InitializationOptions.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.ToExpr.toTypeExpr,[],[Lean.Expr]]
[Lean.Expr.FoldConstsImpl.State.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.simpLemma,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.Parser.Tactic.simpPre, Lean.Parser.Tactic.simpPost, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[Lean.Syntax.noConfusionType,[],[]]
[instComplementUInt8,[Complement.mk, UInt8.complement],[Complement, UInt8]]
[Lean.instBEqData,[BEq.mk, BEq.beq],[BEq, Lean.Level.Data]]
[EStateM.orElse',[EStateM.Result.ok, EStateM.Result, EStateM.Backtrackable.restore, EStateM.Result.error, ite, Eq, Bool.true],[EStateM]]
[Lean.Compiler.UnFoldFn,[Option, Lean.Expr],[]]
[Lean.Elab.Tactic.evalAlt,[Lean.Elab.Tactic.withCaseRef, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, Lean.Elab.Tactic.isHoleRHS, Bool.true, Bind.bind, Lean.Meta.withMVarContext, Lean.withRef, liftM, Lean.Meta.getMVarDecl, Lean.Elab.Tactic.elabTermEnsuringType, Option.some, Lean.MetavarDecl.type, Bool.false, Lean.Meta.assignExprMVar, Lean.Meta.getMVarsNoDelayed, Lean.Elab.Tactic.tagUntaggedGoals, Lean.MetavarDecl.userName, Lean.Name.mkStr, Lean.Name.anonymous, Array.toList, Pure.pure, HAppend.hAppend, Lean.Elab.Tactic.setGoals, List.cons, List.nil, Lean.Elab.Tactic.closeUsingOrAdmit, Lean.Elab.Tactic.withTacticInfoContext, Lean.Elab.Tactic.evalTactic],[Lean.Elab.Tactic.TacticM, Array, Lean.MVarId]]
[Array.any,[Id.run, Array.anyM],[Bool]]
[Lean.Server.RpcEncoding.noConfusionType,[],[]]
[Lean.Elab.Tactic.State.goals,[],[List, Lean.MVarId]]
[ExceptCpsT.runCatch,[Pure.pure],[]]
[Lean.Elab.Term.checkLeftRec,[Bind.bind, MonadReader.read, ite, Eq, and, Lean.Elab.Term.ToParserDescrContext.first, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, PUnit.unit, Bool.false],[Lean.Elab.Term.ToParserDescrM, Bool]]
[Lean.Elab.Term.Quotation.Precheck.Context.mk.inj,[],[Eq]]
[Lean.Elab.Term.Do.Code.decl.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Code.decl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.Code.decl, And]]
[Lean.Lsp.instFromJsonMarkupKind,[Lean.FromJson.mk, Lean.Json.null, Lean.Json.bool, Lean.Json.num, dite, Eq, Unit.unit, Eq.symm, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Except, String, Lean.Lsp.MarkupKind, Except.ok, Lean.Lsp.MarkupKind.plaintext, Lean.Lsp.MarkupKind.markdown, MonadExcept.throw],[Lean.FromJson, Lean.Lsp.MarkupKind]]
[Lean.MonadRef.mkInfoFromRefPos,[Bind.bind, Lean.MonadRef.getRef, Pure.pure, Lean.SourceInfo.fromRef],[Lean.SourceInfo]]
[Lean.Meta.forallMetaBoundedTelescope,[List.toArray, List.nil, OfNat.ofNat, Bool.true, Option.some],[Lean.Meta.MetaM, Prod, Array, Lean.Expr, Lean.BinderInfo]]
[Lean.instCoeStringDataValue,[Coe.mk, Lean.DataValue.ofString],[Coe, String, Lean.DataValue]]
[Lean.ConstantInfo.ctorInfo.injEq,[Eq.propIntro, Eq.refl, Lean.ConstantInfo.ctorInfo, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ConstantInfo.ctorInfo]]
[Lean.IR.NormalizeIds.normArgs,[Array.map, Lean.IR.NormalizeIds.normArg],[Lean.IR.NormalizeIds.M, Array, Lean.IR.Arg]]
[Lean.Meta.FVarSubst.contains,[Std.AssocList.contains, Lean.Meta.FVarSubst.map],[Bool]]
[Lean.Parser.Term.doIfCond.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.none, Bool.false, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.doIfLet.formatter, Lean.Parser.Term.doIfProp.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.LazyInitExtension.ext,[],[Lean.EnvExtension, Option]]
[Lean.Elab.Term.elabCDotFunctionAlias?,[Bind.bind, Lean.Elab.liftMacroM, Option.none, Lean.Elab.Term.TermElabM, Option, Lean.Expr, Lean.expandMacros, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, BEq.beq, MonadExcept.tryCatch, Lean.Elab.Term.resolveId?, Bool.false, Pure.pure, DoResultPR.pure, PUnit.unit, DoResultPR.return, List.toArray, List.cons, List.nil, Lean.Elab.Term.elabCDotFunctionAlias?.expandCDotArg?],[Lean.Elab.Term.TermElabM, Option, Lean.Expr]]
[Lean.getExternAttrData,[Lean.ParametricAttribute.getParam, Lean.externAttr],[Option, Lean.ExternAttrData]]
[Lean.Level.quote,[Lean.Level.PP.Result.quote, Lean.Level.PP.toResult],[Lean.Syntax]]
[Lean.Elab.Term.Do.ToTerm.Context.uvars,[],[Array, Lean.Name]]
[Lean.AttributeExtensionState.map,[],[Std.PersistentHashMap, Lean.Name, Lean.AttributeImpl]]
[Lean.Meta.saturate,[Bind.bind, StateRefT'.run, List.toArray, List.nil, Lean.Meta.MetaM, List, Lean.MVarId, Pure.pure, Array.toList, Lean.Meta.saturate.go],[Lean.Meta.MetaM, List, Lean.MVarId]]
[UInt32.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd],[UInt32]]
[Lean.MetavarContext.LevelMVarToParam.instMonadCacheExprStructEqExprM,[Lean.MonadCache.mk, Bind.bind, MonadState.get, Pure.pure, Std.HashMap.find?, Lean.MetavarContext.LevelMVarToParam.State.cache, modify, Lean.MetavarContext.LevelMVarToParam.State.mk, Lean.MetavarContext.LevelMVarToParam.State.mctx, Lean.MetavarContext.LevelMVarToParam.State.paramNames, Lean.MetavarContext.LevelMVarToParam.State.nextParamIdx, Std.HashMap.insert],[Lean.MonadCache, Lean.ExprStructEq, Lean.Expr, Lean.MetavarContext.LevelMVarToParam.M]]
[Lean.JsonRpc.ResponseError.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonRpc.ResponseError.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.JsonRpc.ResponseError.mk, And]]
[USize.size,[HPow.hPow, OfNat.ofNat, System.Platform.numBits],[Nat]]
[Lean.Parser.Tactic.pushCast,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[max_left_comm,[left_comm, max, max_comm, max_assoc],[Eq, max]]
[Lean.Parser.Command.resolve_name.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[List.filterM,[Bind.bind, List.filterAuxM, List.nil, Pure.pure, List.reverse],[List]]
[Lean.ResolveName.resolveNamespaceUsingScope,[Unit.unit, Lean.Name.str, Lean.Name.num, Option, Lean.Name, ite, Eq, Lean.Environment.isNamespace, Bool.true, Option.some, Option.none, HAppend.hAppend, PProd.fst, panicWithPosWithDecl, OfNat.ofNat],[Option, Lean.Name]]
[Lean.Lsp.DiagnosticCode.string.inj,[],[Eq]]
[IO.AsyncList.asyncTail.inj,[],[Eq]]
[Lean.Syntax.identComponents,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, List, Lean.Syntax, ite, Eq, BEq.beq, List.length, Bool.true, List.map, Lean.Syntax.ident, List.nil, List.zip, panicWithPosWithDecl, OfNat.ofNat, HAppend.hAppend, String.toSubstring, Lean.Name.toString, Lean.Syntax.identComponents.nameComps],[List, Lean.Syntax]]
[Array.toSubarray,[dite, LE.le, Array.size, Subarray.mk, Nat.le_refl, Array.toSubarray.proof_1],[Subarray]]
[Lean.Parser.ParserState.pos,[],[String.Pos]]
[Lean.Parser.Term.num,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.numLit],[Lean.Parser.Parser]]
[Lean.Json.getArr?,[Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Lean.Json.obj, Except, String, Array, Lean.Json, Pure.pure, MonadExcept.throw],[Except, String, Array, Lean.Json]]
[Quotient.recOnSubsingleton,[Quot.recOnSubsingleton],[]]
[«term[_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false],[Lean.ParserDescr]]
[Lean.Meta.isDefEqStringLit,[ite, Eq, and, Lean.Expr.isStringLit, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Meta.toCtorIfLit, Pure.pure, Lean.LBool.undef],[Lean.Meta.MetaM, Lean.LBool]]
[Lean.Server.Watchdog.WorkerEvent.crashed.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.Watchdog.WorkerEvent.crashed, HAdd.hAdd, OfNat.ofNat]]
[USize.instSemiringUSize.proof_8,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, USize.one_def, USize.mul_def, USize.mk, OfNat.ofNat, mul_one, USize.val, USize.mk_val_eq, eq_self, propext, forall_const, USize],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Elab.Tactic.Simp.DischargeWrapper.custom.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.Simp.DischargeWrapper.custom, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Tactic.Simp.DischargeWrapper.custom, And]]
[Lean.IR.addDecl,[Lean.IR.modifyEnv, Lean.PersistentEnvExtension.addEntry, Lean.IR.declMapExt],[Lean.IR.CompilerM, Unit]]
[MonoidWithZero.zero_mul,[],[Eq, HMul.hMul, OfNat.ofNat]]
[le_of_not_ge,[Or.resolve_left, le_total],[LE.le]]
[Lean.Exception.getRef,[Lean.Syntax, Lean.Syntax.missing],[Lean.Syntax]]
[Lean.Meta.FVarSubst.apply,[ite, Eq, Std.AssocList.isEmpty, Lean.Meta.FVarSubst.map, Bool.true, not, Lean.Expr.hasFVar, Lean.Expr.replace, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Expr, Unit.unit, Std.AssocList.find?, Option.some, Option.none],[Lean.Expr]]
[Lean.NameSet.instForInNameSetName,[inferInstanceAs, ForIn, Std.RBTree, Lean.Name, Lean.Name.quickCmp],[ForIn, Lean.NameSet, Lean.Name]]
[Lean.Meta.SimpEntry.toUnfold.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SimpEntry.toUnfold, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.structInstFieldAbbrev.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.ident.formatter, Lean.PrettyPrinter.Formatter.notFollowedBy.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.instInhabitedQuotVal,[Inhabited.mk, Lean.QuotVal.mk, arbitrary],[Inhabited, Lean.QuotVal]]
[Lean.KVMap.getString,[Option.none, Option.some, Lean.DataValue.ofBool, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, String, Lean.KVMap.find],[String]]
[MonadControlT.noConfusionType,[],[]]
[Lean.Lsp.RpcCallParams.sessionId,[],[UInt64]]
[Lean.registerAttributeOfBuilder,[Bind.bind, Lean.mkAttributeImplOfBuilder, ite, Eq, Lean.isAttribute, Lean.AttributeImplCore.name, Lean.AttributeImpl.toAttributeImplCore, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Pure.pure, Lean.PersistentEnvExtension.addEntry, Lean.attributeExtension, Prod.mk, Lean.AttributeExtensionOLeanEntry.builder],[IO, Lean.Environment]]
[Lean.Json.compress,[List.cons, Lean.Json.CompressWorkItem.json, List.nil, Lean.Json.compress.go],[String]]
[Lean.Elab.Tactic.Conv.evalSimp,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.mkSimpContext, Bool.false, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.Conv.getLhs, Lean.Elab.Tactic.Simp.DischargeWrapper.with, liftM, Lean.Meta.simp, Lean.Elab.Tactic.Conv.applySimpResult],[Lean.Elab.Tactic.Tactic]]
[HAdd.noConfusionType,[],[]]
[Lean.Meta.AbstractNestedProofs.M,[ReaderT, Lean.Meta.AbstractNestedProofs.Context, Lean.MonadCacheT, Lean.ExprStructEq, Lean.Expr, StateRefT', IO.RealWorld, Lean.Meta.AbstractNestedProofs.State, Lean.Meta.MetaM],[]]
[Lean.IR.Borrow.BorrowInfCtx.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Borrow.BorrowInfCtx.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Borrow.BorrowInfCtx.mk, And]]
[Lean.IR.UnreachableBranches.InterpState.mk.inj,[And.intro],[And, Eq]]
[UInt64.add_def,[rfl],[Eq, HAdd.hAdd, UInt64.mk, UInt64.val]]
[Lean.instQuoteName,[Lean.Quote.mk, Unit.unit, Lean.Syntax, OptionM, List, String, Pure.pure, Bind.bind, Lean.Name.escapePart, PProd.fst, List.cons, Option.none, List.nil, Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, Lean.Syntax.mkNameLit, HAppend.hAppend, String.intercalate, Lean.SourceInfo.none, Lean.mkCIdent, Lean.Syntax.mkCApp, Lean.Quote.quote],[Lean.Quote, Lean.Name]]
[Lean.PersistentEnvExtension.setState,[Lean.EnvExtension.modifyState, Lean.PersistentEnvExtension.toEnvExtension, Lean.PersistentEnvExtensionState.mk, Lean.PersistentEnvExtensionState.importedEntries],[Lean.Environment]]
[Lean.Elab.RecKind.noConfusion,[noConfusionEnum, Lean.Elab.RecKind.toCtorIdx],[Lean.Elab.RecKind.noConfusionType]]
[Lean.Meta.isExprDefEqGuarded,[Bind.bind, MonadExcept.tryCatch, Lean.Meta.isExprDefEq, Pure.pure, DoResultPR.pure, PUnit.unit, DoResultPR.return, Bool.false, Lean.Meta.MetaM, Bool],[Lean.Meta.MetaM, Bool]]
[Lean.PrettyPrinter.Formatter.pushToken,[Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Lean.PrettyPrinter.FormatterM, Unit, ite, Eq, not, Substring.isEmpty, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Unit.unit],[Lean.PrettyPrinter.FormatterM, Unit]]
[Lean.ReducibilityStatus.semireducible.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.ReducibilityStatus.semireducible, OfNat.ofNat]]
[String.Range.mk.inj,[And.intro],[And, Eq]]
[Lean.Option.Decl.mk.inj,[And.intro],[And, Eq]]
[Lean.DeclarationRange.pos,[],[Lean.Position]]
[Int.toNat,[Nat, OfNat.ofNat],[Nat]]
[UInt64.instRingUInt64.proof_3,[congrArg, UInt64.mk, Ring.gsmul_succ', UInt64.val],[Eq, UInt64.mk, Ring.gsmul, Int.ofNat, Nat.succ, UInt64.val]]
[Lean.Lsp.LocationLink.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.FunInfo.getArity,[Array.size, Lean.Meta.FunInfo.paramInfo],[Nat]]
[List.length_pos_of_ne_nil,[Iff.mpr, Nat.pos_iff_ne_zero, Iff.mp, List.length_eq_zero],[LT.lt, OfNat.ofNat, List.length]]
[Lean.Json.Parser.num,[Bind.bind, Lean.Parsec.peek!, ite, Eq, Char.ofNat, Lean.Parsec.skip, Pure.pure, Neg.neg, OfNat.ofNat],[Lean.Parsec, Lean.JsonNumber]]
[true_implies_iff,[Iff.intro, trivial],[Iff]]
[Lean.Elab.Term.LValResolution.projIdx.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.LValResolution.projIdx, HAdd.hAdd, OfNat.ofNat]]
[Set.instLawfulFunctorSet.proof_1,[LawfulFunctor.mk, rfl, funext, propext, Iff.intro, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Exists.intro, And.intro, Functor.map, Function.comp],[LawfulFunctor, Set]]
[instInhabitedUInt16,[Inhabited.mk, UInt16.ofNatCore, OfNat.ofNat, instInhabitedUInt16.proof_1],[Inhabited, UInt16]]
[Lean.IR.mkProjExpr,[Lean.IR.Expr.proj],[Lean.IR.Expr]]
[Lean.Parser.Command.prefix,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.instDecidableEqPosition,[Decidable, Eq, dite, Decidable.isTrue, rfl, Decidable.isFalse],[DecidableEq, Lean.Position]]
[Lean.Expr.hasLevelParam,[Lean.Expr.Data.hasLevelParam, Lean.Expr.data],[Bool]]
[Lean.Widget.TaggedText.text.injEq,[Eq.propIntro, Eq.refl, Lean.Widget.TaggedText.text, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Widget.TaggedText.text]]
[Std.PersistentHashMap.instInhabitedNode,[Inhabited.mk, Std.PersistentHashMap.Node.entries, List.toArray, List.nil],[Inhabited, Std.PersistentHashMap.Node]]
[Lean.Parser.ParserState.mkUnexpectedError,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Array.push, Lean.Syntax.missing, Option.some, Lean.Parser.Error.mk],[Lean.Parser.ParserState]]
[Lean.ScopedEnvExtension.StateStack.scopedEntries,[],[Lean.ScopedEnvExtension.ScopedEntries]]
[Lean.Meta.DiscrTree.Key.fvar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.DiscrTree.Key.fvar, HAdd.hAdd, OfNat.ofNat]]
[Lean.Widget.InteractiveTermGoal.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.DiagnosticWith.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.DiagnosticWith.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.DiagnosticWith.mk, And]]
[Lean.Meta.AltVarNames.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.AltVarNames.mk, HAdd.hAdd, OfNat.ofNat]]
[seqLeft_eq_bind,[Eq.mpr, Eq.refl, Eq, SeqLeft.seqLeft, Bind.bind, Pure.pure, LawfulApplicative.seqLeft_eq, of_eq_true, Eq.trans, congrFun, congrArg, Seq.seq, map_eq_pure_bind, Function.const, seq_eq_bind_map, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, Function.const_apply, eq_self],[Eq, SeqLeft.seqLeft, Bind.bind, Pure.pure]]
[Lean.Elab.FieldInfo.projName,[],[Lean.Name]]
[Lean.LocalContext.forM,[Std.PersistentArray.forM, Lean.LocalContext.decls, Unit.unit, PUnit, Pure.pure, PUnit.unit],[PUnit]]
[Nat.one_eq_succ_zero,[rfl],[Eq, OfNat.ofNat, Nat.succ]]
[Lean.ProjectionFunctionInfo.ctorName,[],[Lean.Name]]
[Lean.RecursorRule.noConfusionType,[],[]]
[Lean.Widget.Lean.Widget.InteractiveHypothesis.instRpcEncodingInteractiveHypothesisRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Lean.Widget.InteractiveHypothesis.names, Lean.Widget.InteractiveHypothesis.type, Lean.Widget.InteractiveHypothesis.val?, Lean.Widget.InteractiveHypothesis.isInstance, Lean.Widget.InteractiveHypothesis.isType, Pure.pure, Lean.Server.RpcEncoding.rpcDecode, Lean.Widget.InteractiveHypothesis.mk],[Lean.Server.RpcEncoding, Lean.Widget.InteractiveHypothesis]]
[UInt16.instRingUInt16,[Ring.mk, UInt16.instRingUInt16.proof_1, UInt16.mk, Ring.gsmul, UInt16.val, UInt16.instRingUInt16.proof_2, UInt16.instRingUInt16.proof_3, UInt16.instRingUInt16.proof_4, UInt16.instRingUInt16.proof_5],[Ring, UInt16]]
[Std.HashMap.toList,[Std.HashMap.fold, List.cons, Prod.mk, List.nil],[List, Prod]]
[Lean.Lsp.DocumentHighlightParams.toTextDocumentPositionParams,[],[Lean.Lsp.TextDocumentPositionParams]]
[Array.elem,[Array.contains],[Bool]]
[Lean.Meta.DefEqContext.lctx,[],[Lean.LocalContext]]
[Lean.Meta.instInhabitedAltVarNames,[Inhabited.mk, Lean.Meta.AltVarNames.mk, arbitrary],[Inhabited, Lean.Meta.AltVarNames]]
[Lean.Elab.Command.ProjectionInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.InitializedParams.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Elab.Term.LVal.getOp.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.LVal.getOp, HAdd.hAdd, OfNat.ofNat]]
[tacticRwa__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[exists_prop,[Iff.intro, And, And.intro, Exists, Exists.intro],[Iff, Exists, And]]
[Lean.Elab.Deriving.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Deriving.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.unreachIsNodeAtom.proof_1,[Eq.refl, Lean.Syntax.atom, HEq.refl, False],[False]]
[Function.bijective.comp,[Function.bijective, Function.comp, And.intro, Function.injective.comp, Function.surjective.comp],[Function.bijective, Function.comp]]
[Lean.Parser.Command.infixl.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.mkSorry,[Bind.bind, Lean.Meta.getLevel, Pure.pure, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil, Lean.ToExpr.toExpr],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.MonadStateCacheT.run,[StateT.run', Std.mkHashMap, OfNat.ofNat],[]]
[Lean.KVMap.subset,[Bool, Lean.KVMap.subsetAux],[Bool]]
[Lean.Parser.Term.doIfLetPure.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[instDecidableEqBool.proof_1,[],[Bool.noConfusionType, False, Bool.false, Bool.true]]
[Set.«term{_}»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.ParserDescr.cat, Bool.false],[Lean.ParserDescr]]
[Lean.Parser.interpolatedStrNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.interpolatedStrFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.KeyedDeclsAttribute.ExtensionState.erased,[],[Std.PHashSet, Lean.Name]]
[Array.«term__[_:_]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Quotient.recOn,[Quot.recOn],[]]
[Lean.LeanPaths.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.LeanPaths.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Deriving.Hashable.mkHashFuncs,[Bind.bind, ForIn.forIn, Lean.Elab.Deriving.Hashable.mkAuxFunction, Pure.pure, PUnit.unit, ForInStep.yield, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Nat.below,[PUnit, PProd],[]]
[Lean.Meta.IndPredBelow.proveBrecOn.closeGoal,[Bind.bind, Lean.Meta.isExprMVarAssigned, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.IndPredBelow.proveBrecOn.introNPRec, Lean.Meta.IndPredBelow.backwardsChaining, Lean.Meta.withMVarContext, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Name.mkStr, Lean.Name.anonymous, Lean.MessageData.ofGoal],[Lean.Meta.MetaM, Unit]]
[Int.mul_assoc,[Eq, HMul.hMul, of_eq_true, Eq.trans, congr, congrArg, congrFun, Int.ofNat_mul_ofNat, Int.ofNat, Nat.mul_assoc, eq_self, Eq.symm, Int.negSucc, Int.ofNat_mul_negSucc_ofNat, Int.negOfNat, Nat.succ, Int.ofNat_mul_negOfNat, Eq.refl, Int.negOfNat_mul_ofNat, Int.negSucc_ofNat_ofNat, Int.negOfNat_mul_negSucc_ofNat, Int.mul_negSucc_ofNat_negSucc_ofNat, Int.negSucc_ofNat_mul_negOfNat],[Eq, HMul.hMul]]
[absurd,[False.elim],[]]
[Lean.Parser.ParserModuleContext.options,[],[Lean.Options]]
[Lean.mkLevelSuccEx,[Lean.mkLevelSucc],[Lean.Level]]
[Lean.Parser.levelParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Formatter]]
[Lean.PrettyPrinter.Delaborator.delabProjectionApp,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPStructureProjections, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Pure.pure, Lean.Expr.getAppFn, Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Lean.MonadEnv.getEnv, Lean.Environment.getProjectionFnInfo?, Option.none, guard, Eq, not, Lean.ProjectionFunctionInfo.fromClass, Bool.true, BEq.beq, Lean.Expr.getAppNumArgs, HAdd.hAdd, Lean.ProjectionFunctionInfo.numParams, OfNat.ofNat, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPExplicit, or, Lean.PrettyPrinter.Delaborator.SubExpr.withAppArg, Lean.PrettyPrinter.Delaborator.delab, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, List.toArray, List.cons, Lean.Syntax.atom, Lean.mkIdent, Lean.Name.mkSimple, List.nil, Alternative.failure],[Lean.PrettyPrinter.Delaborator.Delab]]
[List.decidableBexi.proof_1,[False, False.elim, Iff.mp, List.mem_nil],[False]]
[Lean.ofExcept,[Pure.pure, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, ToString.toString],[]]
[Nat.repeat.loop,[PProd.fst],[]]
[Lean.Elab.Term.resolveLocalName,[Bind.bind, Lean.MonadLCtx.getLCtx, Pure.pure, Lean.MacroScopesView.name, List.nil, Lean.Elab.Term.resolveLocalName.loop],[Lean.Elab.Term.TermElabM, Option, Prod, Lean.Expr, List, String]]
[Lean.Lsp.MarkupContent.kind,[],[Lean.Lsp.MarkupKind]]
[mul_left_cancel_iff,[Iff.intro, mul_left_cancel, congrArg, HMul.hMul],[Iff, Eq, HMul.hMul]]
[Std.Format.bracket,[Std.Format.group, Std.Format.nest, Int.ofNat, String.length, HAppend.hAppend, Std.Format.text, Std.Format.FlattenBehavior.allOrNone],[Std.Format]]
[Lean.Parser.Command.elabArg.formatter,[Lean.Parser.Command.macroArg.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.SSet.forM,[Lean.SMap.forM],[PUnit]]
[Lean.Lsp.DiagnosticRelatedInformation.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.DiagnosticRelatedInformation.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.DiagnosticRelatedInformation.mk, And]]
[Lean.Json.instToFormatJson,[Std.ToFormat.mk, Lean.Json.render],[Std.ToFormat, Lean.Json]]
[Lean.Elab.ExpandDeclIdResult.declName,[],[Lean.Name]]
[Lean.Elab.Command.StructFieldKind.subobject.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Command.StructFieldKind.subobject, OfNat.ofNat]]
[imp.swap,[Iff.intro, Function.swap],[Iff]]
[Lean.Meta.CongrLemma.theoremName,[],[Lean.Name]]
[Lean.Elab.Tactic.elabTerm,[Lean.withRef, Bind.bind, liftM, Lean.Elab.Term.elabTerm, Bool.true, Lean.Elab.Term.synthesizeSyntheticMVars, Bool.false, Lean.Meta.instantiateMVars],[Lean.Elab.Tactic.TacticM, Lean.Expr]]
[Lean.Parser.Term.doLetArrow.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.doIdDecl.formatter, Lean.Parser.Term.doPatDecl.formatter],[Lean.PrettyPrinter.Formatter]]
[not_or_distrib,[Iff.intro, And.intro, Or.inl, Or.inr, False, Or.elim],[Iff, Not, Or, And]]
[String.split,[String.splitAux, OfNat.ofNat, List.nil],[List, String]]
[FloatArray.push,[FloatArray, FloatArray.mk, Array.push],[FloatArray]]
[Lean.Parser.rawIdentNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.rawIdentFn],[Lean.Parser.Parser]]
[Lean.instInhabitedPersistentEnvExtension,[Inhabited.mk, Lean.PersistentEnvExtension.mk, arbitrary, List.toArray, List.nil, Std.Format.nil],[Inhabited, Lean.PersistentEnvExtension]]
[Substring.prev,[String.Pos, ite, Eq, HSub.hSub, String.prev],[String.Pos]]
[Lean.IR.Param.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Param.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.Index.lt,[Decidable.decide, LT.lt],[Bool]]
[heq_of_eq_rec_right,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, HEq, HEq.rfl],[HEq]]
[Lean.MetavarContext.MkBinding.MCore,[EStateM, Lean.MetavarContext.MkBinding.Exception, Lean.MetavarContext.MkBinding.State],[]]
[Substring.str,[],[String]]
[Lean.Elab.Term.ElabAppArgs.eraseNamedArg,[modify, Lean.Elab.Term.ElabAppArgs.State.mk, Lean.Elab.Term.ElabAppArgs.State.explicit, Lean.Elab.Term.ElabAppArgs.State.f, Lean.Elab.Term.ElabAppArgs.State.fType, Lean.Elab.Term.ElabAppArgs.State.args, Lean.Elab.Term.ElabAppArgs.eraseNamedArgCore, Lean.Elab.Term.ElabAppArgs.State.namedArgs, Lean.Elab.Term.ElabAppArgs.State.ellipsis, Lean.Elab.Term.ElabAppArgs.State.expectedType?, Lean.Elab.Term.ElabAppArgs.State.etaArgs, Lean.Elab.Term.ElabAppArgs.State.toSetErrorCtx, Lean.Elab.Term.ElabAppArgs.State.instMVars, Lean.Elab.Term.ElabAppArgs.State.propagateExpected],[Lean.Elab.Term.ElabAppArgs.M, Unit]]
[Lean.Widget.InteractiveGoal.hyps,[],[Array, Lean.Widget.InteractiveHypothesis]]
[Lean.Elab.Term.expandTermTry,[Lean.withRef, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.Macro]]
[Lean.Parser.Term.termTry,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.doSeq, Lean.Parser.many, HOrElse.hOrElse, Lean.Parser.Term.doCatch, Lean.Parser.Term.doCatchMatch, Lean.Parser.optional, Lean.Parser.Term.doFinally],[Lean.Parser.Parser]]
[instDecidableIff.proof_1,[Iff.intro],[Iff]]
[Lean.Parser.Tactic.locationHyp,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Elab.InfoTree.ibelow,[And, True],[]]
[Lean.Parser.rawCh,[Lean.Parser.Parser.mk, Lean.Parser.chFn],[Lean.Parser.Parser]]
[Lean.HeadIndex.const.inj,[],[Eq]]
[Array.getMax?,[dite, LT.lt, OfNat.ofNat, Array.size, Option.some, Array.foldl, ite, Eq, Bool.true, Option.none],[Option]]
[Lean.Meta.mkForallFVars,[ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Lean.Meta.liftMkBindingM, Lean.MetavarContext.mkForall],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.ExternEntry.backend,[Lean.Name],[Lean.Name]]
[heq_iff_eq,[Iff.intro, eq_of_heq, heq_of_eq],[Iff, HEq, Eq]]
[Lean.Meta.saveState,[Bind.bind, getThe, Lean.Core.State, MonadState.get, Pure.pure, Lean.Meta.SavedState.mk],[Lean.Meta.MetaM, Lean.Meta.SavedState]]
[instOrOpUInt16,[OrOp.mk, UInt16.lor],[OrOp, UInt16]]
[Std.Range.forM,[Std.Range.stop, Std.Range.start, Std.Range.forM.loop],[PUnit]]
[Lean.Parser.Command.optDefDeriving.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.notSymbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.ident.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withBindingBody,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Meta.withLocalDecl, Lean.Expr.binderInfo, Lean.Expr.bindingDomain!, Lean.PrettyPrinter.Delaborator.SubExpr.descend, Lean.Expr.instantiate1, Lean.Expr.bindingBody!, OfNat.ofNat],[]]
[Lean.Lsp.TextDocumentItem.version,[],[Nat]]
[Lean.Elab.Command.ElabStructResult.lctx,[],[Lean.LocalContext]]
[Lean.Parser.Term.optEllipsis,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.optional, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Parser.Tactic.paren,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.IR.MapVars.mapArg,[Lean.IR.Arg.irrelevant, Lean.IR.Arg, Lean.IR.Arg.var],[Lean.IR.Arg]]
[Char.valid,[],[UInt32.isValidChar, Char.val]]
[if_neg,[Eq, ite, absurd, rfl],[Eq, ite]]
[Lean.Parser.Command.terminationHintMany,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.lookahead, Lean.Parser.ident, Lean.Parser.symbol, Lean.Parser.many1Indent, Lean.Parser.group, Lean.Parser.ppLine, Lean.Parser.optional],[Lean.Parser.Parser]]
[IO.Error.otherErrorToString,[Unit.unit, String, HAppend.hAppend, String.modify, OfNat.ofNat, Char.toLower, ToString.toString],[String]]
[Lean.Parser.Term.anonymousCtor,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.sepBy, Lean.Parser.termParser, Bool.false],[Lean.Parser.Parser]]
[Lean.Meta.mkSub,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getDecLevel, Lean.Meta.synthInstance, Lean.mkApp3, Lean.mkConst, List.cons, List.nil, Option.none, Pure.pure, Lean.mkApp6, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Parser.ParserFn,[Lean.Parser.ParserState],[]]
[Lean.KVMap.setInt,[Lean.KVMap.insert, Lean.DataValue.ofInt],[Lean.KVMap]]
[Lean.Parser.notFollowedByTermToken,[Lean.Parser.notFollowedByCategoryToken, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Parser.Parser]]
[Lean.instReprBinderInfo,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone],[Repr, Lean.BinderInfo]]
[Lean.Meta.isInductivePredicate,[Bind.bind, Lean.MonadEnv.getEnv, Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.Meta.MetaM, Bool, Lean.Environment.find?, Lean.Meta.forallTelescopeReducing, Lean.Meta.whnfD, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Pure.pure, BEq.beq, Lean.levelZero, Bool.false],[Lean.Meta.MetaM, Bool]]
[Lean.instToExprOption,[Lean.ToExpr.mk, Unit.unit, Lean.Expr, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.levelZero, List.nil, Lean.mkApp2, Lean.ToExpr.toExpr],[Lean.ToExpr, Option]]
[min_left_comm,[left_comm, min, min_comm, min_assoc],[left_commutative, min]]
[Lean.Elab.Deriving.Hashable.mkMatch.mkAlts,[Bind.bind, ForIn.forIn, MProd.mk, Lean.getConstInfoCtor, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, liftM, Lean.Core.betaReduce, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, PUnit.unit, ForInStep.yield, Lean.Quote.quote, Lean.Meta.inferType, Lean.Core.mkFreshUserName, Unit.unit, Lean.Elab.Term.TermElabM, ForInStep, MProd, Array, Lean.Syntax, Array.findIdx?, BEq.beq, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Lean.mkIdent, Array.getOp, Lean.Elab.Deriving.Context.auxFunNames, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom],[Lean.Elab.Term.TermElabM, Array, Lean.Syntax]]
[Lean.Parser.Term.funBinder.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.evalInsideQuot, Lean.Parser.Term.funBinder],[Lean.Parser.Parser]]
[Ne.symm,[Eq.symm],[Ne]]
[UInt64.instSemiringUInt64.proof_10,[rfl],[Eq, Nat.succ]]
[List.instBEqList,[BEq.mk, List.beq],[BEq, List]]
[Lean.Lsp.instToJsonDocumentSymbolResult,[Lean.ToJson.mk, Lean.ToJson.toJson, Lean.Lsp.DocumentSymbolResult.syms],[Lean.ToJson, Lean.Lsp.DocumentSymbolResult]]
[Lean.Parser.Term.binderDefault.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Expr.getArg!,[Lean.Expr.getRevArg!, HSub.hSub, OfNat.ofNat],[Lean.Expr]]
[IO.Error.noFileOrDirectory.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.noFileOrDirectory, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Match.Pattern.as.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.Pattern.as, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.Pattern.as, And]]
[Std.RBMap.revFold,[Std.RBNode.revFold],[]]
[ByteSliceT.toSlice,[ByteSlice, ByteSlice.mk, HSub.hSub, ByteArray.size],[ByteSlice]]
[UInt32.mul,[UInt32.mk, HMul.hMul, UInt32.val],[UInt32]]
[Lean.Parser.Syntax.atom.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.strLit.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Tactic.Context.noConfusionType,[],[]]
[Lean.IR.Checker.CheckerState.foundVars,[],[Lean.IR.IndexSet]]
[Lean.Meta.Match.MatcherResult.addMatcher,[],[Lean.Meta.MetaM, Unit]]
[IO.FS.readFile,[Bind.bind, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.false, IO.FS.Handle.readToEnd],[IO, String]]
[Lean.Meta.SimpAll.State.mk.inj,[And.intro],[And, Eq]]
[Array.mapIdx,[Id.run, Array.mapIdxM],[Array]]
[Lean.Parser.octalNumberFn,[Lean.Parser.mkNodeToken, Lean.numLitKind],[Lean.Parser.ParserFn]]
[Lean.Parser.Term.typeAscription,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.getRegularInitFnNameFor?,[Lean.getInitFnNameForCore?, Lean.regularInitAttr],[Option, Lean.Name]]
[fixCore1,[bfix1, USize.size],[]]
[Lean.Parser.Term.haveIdDecl,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.Term.haveIdLhs, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat, Bool.false],[Lean.Parser.Parser]]
[Lean.Elab.Tactic.getNameOfIdent',[ite, Eq, Lean.Syntax.isIdent, Bool.true, Lean.Syntax.getId, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Name]]
[Lean.ExprStructEq.noConfusionType,[],[]]
[Lean.Lsp.SemanticTokensLegend.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.SemanticTokensLegend.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.SemanticTokensLegend.mk, And]]
[Lean.Meta.IndPredBelow.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.IndPredBelow.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Preorder.lt_iff_le_not_le,[],[Iff, LT.lt, And, LE.le, Not]]
[Lean.Elab.Term.Quotation.Precheck.Context.noConfusionType,[],[]]
[instReprFloat,[Repr.mk, Std.Format.text, Float.toString],[Repr, Float]]
[Lean.Elab.Level.instMonadOptionsLevelElabM,[Lean.MonadOptions.mk, Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Level.Context.options],[Lean.MonadOptions, Lean.Elab.Level.LevelElabM]]
[Lean.Meta.getDecLevel,[Bind.bind, Lean.Meta.getLevel, Lean.Meta.decLevel],[Lean.Meta.MetaM, Lean.Level]]
[Lean.Parser.Tactic.open.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.openDecl.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withOpenDecl.parenthesizer, Lean.Parser.Tactic.tacticSeq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[instOfNatUInt64,[OfNat.mk, UInt64.ofNat],[OfNat, UInt64]]
[Lean.Compiler.uintBinFoldFns,[List.foldl, HAppend.hAppend, List.map, Prod, Lean.Name, Lean.Compiler.BinFoldFn, Prod.mk, Lean.Compiler.NumScalarTypeInfo.id, Lean.Compiler.preUIntBinFoldFns, List.nil, Lean.Compiler.numScalarTypes],[List, Prod, Lean.Name, Lean.Compiler.BinFoldFn]]
[Subtype.instDecidableEqSubtype,[Decidable, Eq, Subtype.mk, dite, Decidable.isTrue, Subtype.instDecidableEqSubtype.proof_1, Decidable.isFalse, Subtype.instDecidableEqSubtype.proof_2],[DecidableEq, Subtype]]
[IO.FS.Stream.readRequestAs,[Bind.bind, IO.FS.Stream.readMessage, Lean.JsonRpc.Message.notification, Lean.JsonRpc.Message.response, Lean.JsonRpc.Message.responseError, IO, Lean.JsonRpc.Request, ite, Eq, Lean.FromJson.fromJson?, Pure.pure, Lean.JsonRpc.Request.mk, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Lean.Json.compress, Lean.ToJson.toJson],[IO, Lean.JsonRpc.Request]]
[Array.append,[Array.foldl, Array.push, OfNat.ofNat, Array.size],[Array]]
[Lean.Elab.logError,[Lean.Elab.log, Lean.MessageSeverity.error],[Unit]]
[Lean.Lsp.instToJsonDocumentSymbol,[Lean.ToJson.mk, Lean.Lsp.instToJsonDocumentSymbol.go],[Lean.ToJson, Lean.Lsp.DocumentSymbol]]
[Lean.Lsp.instFromJsonTextDocumentIdentifier,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, Pure.pure, Lean.Lsp.TextDocumentIdentifier.mk],[Lean.FromJson, Lean.Lsp.TextDocumentIdentifier]]
[Lean.Meta.Match.Pattern.noConfusionType,[],[]]
[Empty.elim,[sorryAx, Bool.true],[]]
[Lean.Elab.Frontend.runCommandElabM,[Bind.bind, MonadReader.read, MonadState.get, liftM, EIO.toIO', StateRefT'.run, Lean.Elab.Frontend.State.commandState, Lean.Elab.Frontend.FrontendM, Lean.MessageData.toString, Lean.Exception.toMessageData, MonadExcept.throw, IO.Error.userError, HAppend.hAppend, ToString.toString, Lean.Elab.Frontend.setCommandState, Pure.pure],[Lean.Elab.Frontend.FrontendM]]
[Lean.Parser.Command.runCmd,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Ring.gsmul,[],[]]
[Lean.TheoremVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.TheoremVal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.TheoremVal.mk, And]]
[Lean.Json.getNat?,[Lean.Json.null, Lean.Json.bool, dite, Eq, Eq.symm, Lean.Json.num, Lean.JsonNumber.mk, Int.ofNat, Int.negSucc, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Except, String, Nat, Pure.pure, MonadExcept.throw],[Except, String, Nat]]
[Lean.Parser.identEq,[Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.identEqFn],[Lean.Parser.Parser]]
[Lean.Widget.InteractiveTermGoal.noConfusionType,[],[]]
[Lean.Meta.mkEqMPR,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Meta.Match.MatcherResult.unusedAltIdxs,[],[List, Nat]]
[not_lt,[Iff.intro, le_of_not_gt, not_lt_of_ge],[Iff, Not, LT.lt, LE.le]]
[Lean.Elab.Command.getRef,[Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Command.Context.ref],[Lean.Elab.Command.CommandElabM, Lean.Syntax]]
[Lean.Meta.getExprMVarAssignment?,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.getExprAssignment?],[Lean.Meta.MetaM, Option, Lean.Expr]]
[Lean.Syntax.decodeScientificLitVal?,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Option.none, Char.isDigit, Lean.Syntax.decodeScientificLitVal?.decodeAfterExp, Lean.Syntax.decodeScientificLitVal?.decodeExp, Lean.Syntax.decodeScientificLitVal?.decodeAfterDot, Lean.Syntax.decodeScientificLitVal?.decode],[Option, Prod, Nat, Bool]]
[Array.foldlMUnsafe.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bind.bind, Array.uget, lcProof, Array.foldlMUnsafe.fold, HAdd.hAdd, OfNat.ofNat],[]]
[Lean.Parser.Term.doPatDecl.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.termParser.formatter, Lean.Parser.Term.leftArrow.formatter, Lean.Parser.doElemParser.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.checkColGt.formatter, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[IO.FS.withFile,[Bind.bind, IO.FS.Handle.mk, Bool.true],[IO]]
[Lean.instQuoteString,[Lean.Quote.mk, Lean.Syntax.mkStrLit, Lean.SourceInfo.none],[Lean.Quote, String]]
[Lean.Elab.Command.instAddErrorMessageContextCommandElabM,[Lean.AddErrorMessageContext.mk, Bind.bind, MonadReader.read, Lean.AddMessageContext.addMessageContext, Lean.Elab.addMacroStack, Lean.Elab.Command.Context.macroStack, Pure.pure, Prod.mk],[Lean.AddErrorMessageContext, Lean.Elab.Command.CommandElabM]]
[Std.RBTree.contains,[Option.isSome, Std.RBTree.find?],[Bool]]
[Lean.Parser.Term.ident,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.ident],[Lean.Parser.Parser]]
[Lean.Parser.Tactic.set_option.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter, Lean.ppSpace.formatter, Lean.Parser.Command.optionValue.formatter, Lean.Parser.Tactic.tacticSeq.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.CollectLevelParams.State.visitedExpr,[],[Lean.ExprSet]]
[Lean.Meta.SortLocalDecls.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SortLocalDecls.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.ReduceEval.reduceEval,[],[Lean.Meta.MetaM]]
[Lean.Exception.error.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Exception.error, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Exception.error, And]]
[Lean.Parser.sepBy1.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.sepBy1NoAntiquot.parenthesizer, Lean.Parser.sepByElemParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.eoi,[Lean.Parser.Parser.mk, Lean.Parser.eoiFn],[Lean.Parser.Parser]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withMDataExpr,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, withTheReader, Lean.PrettyPrinter.Delaborator.SubExpr, Lean.PrettyPrinter.Delaborator.SubExpr.mk, Lean.PrettyPrinter.Delaborator.SubExpr.pos, panicWithPosWithDecl, OfNat.ofNat],[]]
[List.hasDecidableLt.proof_2,[Eq.refl, List.cons, List.nil, HEq.refl, False],[False]]
[Substring.takeRightWhile,[Substring, Substring.mk],[Substring]]
[Lean.LocalContext.findDecl?,[Id.run, Lean.LocalContext.findDeclM?],[Option]]
[Or.by_cases',[dite, Or.resolve_right],[]]
[Prod.allI,[Nat.anyAux, not, Prod.snd, HSub.hSub, Prod.fst],[Bool]]
[Lean.Parser.nameLit,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.nameLitKind, Bool.true, Lean.Parser.nameLitNoAntiquot],[Lean.Parser.Parser]]
[Lean.Parser.checkNoWsBefore,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.checkNoWsBeforeFn],[Lean.Parser.Parser]]
[IO.FS.DirEntry.root,[],[System.FilePath]]
[Std.HashSetImp.erase.proof_1,[Subtype.property],[GT.gt, Array.size, Subtype.val, OfNat.ofNat]]
[instDecidableLt_3,[UInt64.decLt],[Decidable, LT.lt]]
[instModUInt8,[Mod.mk, UInt8.mod],[Mod, UInt8]]
[Lean.PrefixTreeNode.find?,[Lean.PrefixTreeNode.find?.loop],[Option]]
[OrElse.orElse,[],[]]
[Lean.AttributeKind.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.CollectFVars.State.fvarSet,[],[Lean.FVarIdSet]]
[StateCpsT.instLawfulMonadStateCpsT,[StateCpsT.instLawfulMonadStateCpsT.proof_1],[LawfulMonad, StateCpsT]]
[Lean.Parser.Term.binrel.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.traceCtx,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, not, Bool.true, Lean.enableTracing, Bool.false, tryFinally, Lean.MonadRef.getRef, Lean.getTraces, Lean.modifyTraces, Std.PersistentArray.mk, Pure.pure, Std.PersistentArray.isEmpty, Std.PersistentArray.push, Lean.TraceElem.mk],[]]
[IO.AsyncList.cons.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.AsyncList.cons, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.collectTrivialBottomUps,[Bind.bind, MonadReader.read, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit, ForIn.forIn, PUnit.unit, ite, Eq, BEq.beq, Array.getOp, Lean.BinderInfo.default, Bool.true, andM, liftM, Lean.Meta.instantiateMVars, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.hasMVarAtCurrDepth, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isTrivialBottomUp, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.tryUnify, modify, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk, Array.set!, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.bottomUps, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.higherOrders, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.funBinders, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.provideds, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.namedArgs, Pure.pure, ForInStep.yield],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit]]
[Lean.IR.FnBody.inc.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.FnBody.inc, HAdd.hAdd, OfNat.ofNat]]
[Sigma.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Sigma.mk, HAdd.hAdd, OfNat.ofNat]]
[WellFounded.fix'.impl,[WellFounded.fix'.impl],[]]
[Lean.IR.Checker.CheckerState.noConfusionType,[],[]]
[IO.FS.Stream.readNotificationAs,[Bind.bind, IO.FS.Stream.readMessage, Lean.JsonRpc.Message.request, Lean.JsonRpc.Message.response, Lean.JsonRpc.Message.responseError, IO, Lean.JsonRpc.Notification, ite, Eq, Lean.FromJson.fromJson?, Pure.pure, Lean.JsonRpc.Notification.mk, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Lean.Json.compress, Lean.ToJson.toJson],[IO, Lean.JsonRpc.Notification]]
[Lean.Meta.CaseArraySizesSubgoal.mk.inj,[And.intro],[And, Eq]]
[Lean.Server.FileWorker.handleSemanticTokens.highlightId,[Option.none, ReaderT, Lean.Server.FileWorker.SemanticTokensContext, StateT, Lean.Server.FileWorker.SemanticTokensState, Lean.Server.RequestM, PUnit, Lean.Syntax.getRange?, Bool.false, Bind.bind, MonadReader.read, ForIn.forIn, ite, LT.lt, Pure.pure, ForInStep.yield, PUnit.unit],[ReaderT, Lean.Server.FileWorker.SemanticTokensContext, StateT, Lean.Server.FileWorker.SemanticTokensState, Lean.Server.RequestM, PUnit]]
[lt_of_le_not_le,[LT.lt, Iff.mpr, lt_iff_le_not_le, And.intro],[LT.lt]]
[npow_rec,[OfNat.ofNat, HMul.hMul, PProd.fst],[]]
[Lean.JsonRpc.Notification.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Frontend.State.cmdPos,[],[String.Pos]]
[Lean.Level.PP.Result.imaxNode.injEq,[Eq.propIntro, Eq.refl, Lean.Level.PP.Result.imaxNode, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Level.PP.Result.imaxNode]]
[Int.instCommRingInt.proof_2,[rfl],[Eq, HPow.hPow, OfNat.ofNat]]
[Lean.Elab.InfoTree.ofJson.inj,[],[Eq]]
[Lean.Elab.Tactic.ElimApp.State.insts,[],[Array, Lean.MVarId]]
[Lean.IR.DeclInfo.mk.injEq,[Eq.propIntro, Eq.refl, Lean.IR.DeclInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.DeclInfo.mk]]
[Lean.Lsp.PlainGoal.noConfusionType,[],[]]
[Nat.toUInt32,[UInt32.ofNat],[UInt32]]
[List.disjoint_nil_left,[Not.elim, List.not_mem_nil],[List.disjoint, List.nil]]
[Lean.Parser.Term.doSeq,[HOrElse.hOrElse, Lean.Parser.Term.doSeqBracketed, Lean.Parser.Term.doSeqIndent],[Lean.Parser.Parser]]
[Lean.Elab.instInhabitedPreDefinition,[Inhabited.mk, Lean.Elab.PreDefinition.mk, arbitrary],[Inhabited, Lean.Elab.PreDefinition]]
[Lean.SMap.contains,[Bool, Std.HashMap.contains, or, Std.PersistentHashMap.contains],[Bool]]
[Lean.Meta.NormNum.instLawfulOfNat_2,[Lean.Meta.NormNum.instLawfulOfNat_2.proof_1],[Lean.Meta.NormNum.LawfulOfNat]]
[Lean.PrettyPrinter.Formatter.orelse.formatter,[HOrElse.hOrElse],[Lean.PrettyPrinter.Formatter]]
[PProd.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, PProd.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, PProd.mk, And]]
[instReprPUnit,[Repr.mk, Std.Format.text],[Repr, PUnit]]
[Lean.ScopedEnvExtension.noConfusionType,[],[]]
[Lean.Macro.Methods.resolveGlobalName,[],[Lean.MacroM, List, Prod, Lean.Name, String]]
[Tactic.Ring.HornerExpr.xadd.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Tactic.Ring.HornerExpr.xadd, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.matchDiscr.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Level.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Level.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Level.State.mk, And]]
[Lean.Parser.Command.syntax,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.docComment, Lean.Parser.Term.attrKind, Lean.Parser.symbol, Lean.Parser.optPrecedence, Lean.Parser.Command.optNamedName, Lean.Parser.Command.optNamedPrio, Lean.Parser.many1, Lean.Parser.syntaxParser, Lean.Parser.argPrec, Lean.Parser.ident],[Lean.Parser.Parser]]
[Function.bijective.injective,[And.left],[Function.injective]]
[usize_size_gt_zero,[Nat.pos_pow_of_pos, System.Platform.numBits, Nat.zero_lt_succ, OfNat.ofNat],[GT.gt, USize.size, OfNat.ofNat]]
[Function.left_inverse_inv_fun,[],[Function.left_inverse, Function.inv_fun]]
[Lean.isNoConfusion,[Lean.TagDeclarationExtension.isTagged, Lean.noConfusionExt],[Bool]]
[Function.app,[],[]]
[Lean.Elab.Command.StructCtorView.ref,[],[Lean.Syntax]]
[fix5,[fixCore5, arbitrary],[]]
[Lean.Name.getPrefix,[Unit.unit, Lean.Name, Lean.Name.anonymous],[Lean.Name]]
[Lean.IR.FnBody.below,[PProd, PUnit],[]]
[Lean.Elab.Tactic.refineCore,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.getMainTarget, Lean.Elab.Tactic.elabTermWithHoles, Option.some, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Meta.assignExprMVar, Lean.Elab.Tactic.replaceMainGoal],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.Elab.Term.BinderView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.BinderView.mk, HAdd.hAdd, OfNat.ofNat]]
[IO.Process.StdioConfig.stdout,[],[IO.Process.Stdio]]
[List.append_nil,[rfl, of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.cons, id, eq_self],[Eq, HAppend.hAppend, List.nil]]
[Lean.Meta.IndPredBelow.mkConstructor,[Bind.bind, Lean.getConstInfoCtor, Lean.Meta.IndPredBelow.mkCtorType, Pure.pure, Lean.Constructor.mk],[Lean.Meta.MetaM, Lean.Constructor]]
[Lean.IR.mkAlt,[Lean.IR.Alt.ctor, Lean.IR.CtorInfo.mk],[Lean.IR.Alt]]
[Lean.Core.instAddMessageContextCoreM,[Lean.AddMessageContext.mk, Lean.addMessageContextPartial],[Lean.AddMessageContext, Lean.Core.CoreM]]
[Nat.div_one,[],[Eq, HDiv.hDiv, OfNat.ofNat]]
[IO.FS.instOrdSystemTime,[Ord.mk, Ordering, Unit.unit, Ord.compare, Ordering.lt, Ordering.gt, Ordering.eq],[Ord, IO.FS.SystemTime]]
[Lean.PrettyPrinter.Delaborator.instInhabitedDelabM,[Inhabited.mk, MonadExcept.throw, arbitrary],[Inhabited, Lean.PrettyPrinter.Delaborator.DelabM]]
[Lean.PrettyPrinter.Parenthesizer.checkColGe.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Tactic.rcongr,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.LocalContext.mkBinding,[Nat.foldRev, Unit.unit, Lean.Expr, Lean.LocalContext.findFVar?, ite, Eq, Bool.true, Lean.mkLambda, Lean.mkForall, Lean.Expr.hasLooseBVar, OfNat.ofNat, Lean.mkLet, Lean.Expr.lowerLooseBVars, panicWithPosWithDecl, Array.size],[Lean.Expr]]
[Lean.Parser.Term.explicitBinder.formatter,[Lean.ppGroup.formatter, Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.Parser.Term.binderType.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.binderTactic.formatter, Lean.Parser.Term.binderDefault.formatter],[Lean.PrettyPrinter.Formatter]]
[Std.PersistentArray.findSome?,[Id.run, Std.PersistentArray.findSomeM?],[Option]]
[Std.RBTree.find?,[Unit.unit, Option, Std.RBMap.findCore?, Option.some, Option.none],[Option]]
[Lean.Level.hasParam,[Lean.Level.Data.hasParam, Lean.Level.data],[Bool]]
[Lean.IR.ExplicitBoxing.unboxResultIfNeeded,[ite, Eq, Lean.IR.IRType.isScalar, Bool.true, Bind.bind, getModify, Lean.IR.ExplicitBoxing.BoxingState.mk, HAdd.hAdd, Lean.IR.ExplicitBoxing.BoxingState.nextIdx, OfNat.ofNat, Lean.IR.ExplicitBoxing.BoxingState.auxDecls, Lean.IR.ExplicitBoxing.BoxingState.auxDeclCache, Lean.IR.ExplicitBoxing.BoxingState.nextAuxId, Pure.pure, Lean.IR.VarId.mk, Lean.IR.FnBody.vdecl, Lean.IR.IRType.object, Lean.IR.Expr.unbox],[Lean.IR.ExplicitBoxing.M, Lean.IR.FnBody]]
[Mathlib.Tactic.Lint.LintVerbosity.low.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Mathlib.Tactic.Lint.LintVerbosity.low, OfNat.ofNat]]
[Lean.Elab.Term.Do.DoIfView.optIdent,[],[Lean.Syntax]]
[Lean.Compiler.hasNospecializeAttribute,[Lean.Compiler.SpecializeAttributeKind.nospecialize],[Bool]]
[Lean.instMonadOptions,[Lean.MonadOptions.mk, liftM, Lean.MonadOptions.getOptions],[Lean.MonadOptions]]
[Lean.Level.PP.Result.noConfusionType,[],[]]
[Lean.Parser.Attr.extern.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.optional.formatter, Lean.Parser.numLit.formatter, Lean.Parser.many.formatter, Lean.Parser.Attr.externEntry.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.ConstantVal.name,[],[Lean.Name]]
[Lean.Meta.RecursorInfo.numArgs,[],[Nat]]
[Nat.repr_length,[Eq.symm, Classical.em, Eq, HDiv.hDiv, Nat.succ, OfNat.ofNat, Eq.mpr, congrFun, congrArg, LE.le, List.length, ite_congr, Eq.trans, eq_true_of_decide, Eq.refl, Bool.true, List.cons, Nat.digitChar, HMod.hMod, List.nil, congr, Nat.toDigitsCore, Nat.to_digits_core_length, of_decide_eq_true, HAdd.hAdd],[LE.le, String.length, Nat.repr]]
[Lean.Lsp.instToStringRpcRef,[ToString.mk, ToString.toString, Lean.Lsp.RpcRef.p],[ToString, Lean.Lsp.RpcRef]]
[Nat.coprime.mul,[Eq.trans, Nat.coprime.gcd_mul_left_cancel],[Nat.coprime, HMul.hMul]]
[Array.isEqv,[dite, Eq, Array.size, Array.isEqvAux, OfNat.ofNat, Bool.false],[Bool]]
[Lean.BinderInfo.isInstImplicit,[Lean.BinderInfo.default, Lean.BinderInfo.implicit, Lean.BinderInfo.strictImplicit, Unit.unit, Lean.BinderInfo.auxDecl, Bool, Bool.true, Bool.false],[Bool]]
[Lean.resolveGlobalConstNoOverloadCore,[Bind.bind, Lean.resolveGlobalConstCore, List.nil, List.cons, Lean.Name, Pure.pure, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, HAppend.hAppend, ToString.toString, Lean.mkConst, List.map],[Lean.Name]]
[Lean.Meta.AbstractMVars.State.lctx,[],[Lean.LocalContext]]
[Nat.div_mul_le_self,[LE.le, HMul.hMul, HDiv.hDiv, Eq.mpr, congrFun, congrArg, Eq.trans, Nat.div_zero, OfNat.ofNat, Nat.mul_zero, Nat.zero_le, Iff.mp, Nat.le_div_iff_mul_le, Nat.succ_pos, Nat.le_refl, HAdd.hAdd],[LE.le, HMul.hMul, HDiv.hDiv]]
[Lean.DelayedMetavarAssignment.fvars,[],[Array, Lean.Expr]]
[Lean.PrettyPrinter.Formatter.checkInsideQuot.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.Quotation.resolveSectionVariable.loop,[Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, List, Prod, Lean.Name, String, Unit.unit, Lean.NameMap.find?, List.cons, Prod.mk, List.nil, PProd.fst],[List, Prod, Lean.Name, String]]
[Lean.Elab.Term.withoutPostponing,[MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.Context.declName?, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.currMacroScope, Bool.false, Lean.Elab.Term.Context.errToSorry, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.Term.Context.autoBoundImplicits, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection],[Lean.Elab.Term.TermElabM]]
[Lean.IR.tracePrefixOptionName,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Name]]
[Lean.Lsp.DeclarationParams.noConfusionType,[],[]]
[List.length_erasep_of_mem,[Eq, List.length, List.erasep, Nat.pred, List.exists_of_erasep, Eq.mpr, Eq.refl, congr, congrArg, List.length_append, Eq.trans, List.cons, HAdd.hAdd, List.length_cons, rfl],[Eq, List.length, List.erasep, Nat.pred]]
[Lean.Parser.Tactic.recover,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.IR.Arg.beq,[Lean.IR.Arg.var, Lean.IR.Arg.irrelevant, Unit.unit, Bool, BEq.beq, Bool.true, Bool.false],[Bool]]
[IO.throwServerError,[MonadExcept.throw, IO.userError],[IO]]
[Lean.Parser.withOpenFn,[ite, GT.gt, Array.size, Lean.Parser.ParserState.stxStack, OfNat.ofNat, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.withOpenDeclFnCore, Lean.Syntax.getOp],[Lean.Parser.ParserFn]]
[Lean.Name.components',[Unit.unit, List, Lean.Name, List.nil, List.cons, Lean.Name.mkStr, Lean.Name.anonymous, PProd.fst, Lean.Name.mkNum],[List, Lean.Name]]
[Lean.Parser.Term.namedPattern,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.checkStackTop, Lean.Parser.Term.isIdent, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.maxPrec],[Lean.Parser.TrailingParser]]
[Std.RBMap.findCore?,[Option, Sigma, Std.RBNode.findCore],[Option, Sigma]]
[List.take,[List, List.nil, List.cons, PProd.fst],[List]]
[Lean.Parser.parseHeader,[Bind.bind, Lean.mkEmptyEnvironment, OfNat.ofNat, Unit.unit, IO, Prod, Lean.Syntax, Lean.Parser.ModuleParserState, Lean.MessageLog, Lean.Parser.ParserState.errorMsg, Pure.pure, Prod.mk, Lean.Parser.ModuleParserState.mk, Lean.Parser.ParserState.pos, Bool.true, Lean.MessageLog.add, Lean.MessageLog.mk],[IO, Prod, Lean.Syntax, Lean.Parser.ModuleParserState, Lean.MessageLog]]
[Lean.Elab.Tactic.SavedState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Tactic.SavedState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.moreArgs,[],[Array, Lean.Syntax]]
[Lean.Parser.Term.local.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[List.tail?,[Unit.unit, Option, List, Option.none, Option.some],[Option, List]]
[Lean.MessageDataContext.noConfusionType,[],[]]
[Lean.Elab.Deriving.Hashable.mkHashableHeader,[Lean.Elab.Deriving.mkHeader, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat],[Lean.Elab.Term.TermElabM, Lean.Elab.Deriving.Header]]
[Lean.instInhabitedMessageLog,[Inhabited.mk, Lean.MessageLog.mk, arbitrary],[Inhabited, Lean.MessageLog]]
[List.eraseDup,[List.pwFilter, Ne],[List]]
[Lean.Elab.Deriving.Context.auxFunNames,[],[Array, Lean.Name]]
[Lean.Parser.Term.suffices,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, Lean.Parser.symbol, Lean.Parser.Term.sufficesDecl, Lean.Parser.Term.optSemicolon, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.profileitIO,[],[EIO]]
[Lean.Parser.checkStackTopFn,[ite, Eq, Array.back, Lean.Parser.ParserState.stxStack, Bool.true, Lean.Parser.ParserState.mkUnexpectedError, List.nil],[Lean.Parser.ParserFn]]
[Float.ofBinaryScientific,[Float.scaleB, UInt64.toFloat],[Float]]
[Lean.Parser.mergeOrElseErrors,[Lean.Parser.ParserState.mk, Option.none, Lean.Parser.ParserState, ite, Eq, BEq.beq, Bool.true, Option.some, Lean.Parser.Error.merge],[Lean.Parser.ParserState]]
[Lean.Expr.isLit,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[MonadState.set,[],[PUnit]]
[IO.FS.instReprMetadata,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, IO.FS.Metadata.accessed, Std.Format.line, IO.FS.Metadata.modified, IO.FS.Metadata.byteSize, IO.FS.Metadata.type],[Repr, IO.FS.Metadata]]
[instToBoolBool,[ToBool.mk],[ToBool, Bool]]
[Lean.Elab.Visibility.noConfusionType,[noConfusionTypeEnum, Lean.Elab.Visibility.toCtorIdx],[]]
[Lean.Parser.Tactic.casesM,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Std.PersistentArray.div2Shift,[USize.shiftRight],[USize]]
[Lean.Parser.ParserState.stxStack,[],[Array, Lean.Syntax]]
[Iff.mpr,[],[]]
[Lean.Syntax.getAntiquotSpliceSuffix,[ite, Eq, Lean.Syntax.isAntiquotSplice, Bool.true, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Syntax]]
[IO.Error.noSuchThing.inj,[And.intro],[And, Eq]]
[ST.instInhabitedRef,[Inhabited.mk, ST.Ref.mk, PointedType.val, ST.RefPointed, ST.instInhabitedRef.proof_1],[Inhabited, ST.Ref]]
[Fin.div,[Fin, Fin.mk, HMod.hMod, HDiv.hDiv, Fin.div.proof_1],[Fin]]
[Std.Range.noConfusionType,[],[]]
[Lean.LocalDecl.setBinderInfo,[Lean.LocalDecl, Lean.LocalDecl.cdecl, panicWithPosWithDecl, OfNat.ofNat],[Lean.LocalDecl]]
[Lean.Meta.SimpAll.instInhabitedEntry,[Inhabited.mk, Lean.Meta.SimpAll.Entry.mk, arbitrary],[Inhabited, Lean.Meta.SimpAll.Entry]]
[Lean.LBool.undef.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.LBool.undef, OfNat.ofNat]]
[Lean.Elab.Command.exportPrivate,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[lt_by_cases,[dite, LT.lt, lt_by_cases.proof_1],[]]
[Lean.Meta.mkLetFVars,[Lean.Meta.mkLambdaFVars, Bool.false],[Lean.Meta.MetaM, Lean.Expr]]
[ToString.noConfusionType,[],[]]
[Lean.Syntax.isAtom,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Bool, Bool.true, Bool.false],[Bool]]
[Quotient.rec,[Quot.rec],[]]
[Lean.LocalContext.getFVar!,[Lean.LocalContext.get!, Lean.Expr.fvarId!],[Lean.LocalDecl]]
[Nat.dvd_of_mul_dvd_mul_right,[Nat.dvd_of_mul_dvd_mul_left, Eq.mp, Eq.refl, Dvd.dvd, HMul.hMul, Nat.mul_comm],[Dvd.dvd]]
[Lean.Parser.Term.Command.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.commandParser],[Lean.Parser.Parser]]
[PLift.down_up,[rfl],[Eq, PLift.down, PLift.up]]
[Lean.levelOne,[Lean.mkLevelSucc, Lean.levelZero],[Lean.Level]]
[cast,[],[]]
[Std.Format.instBEqFlattenBehavior,[BEq.mk, BEq.beq, Std.Format.FlattenBehavior.toCtorIdx],[BEq, Std.Format.FlattenBehavior]]
[Lean.Parser.ParserExtension.OLeanEntry.kind.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.ParserExtension.OLeanEntry.kind, HAdd.hAdd, OfNat.ofNat]]
[Lean.TagAttribute.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.TagAttribute.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.TagAttribute.mk, And]]
[Lean.Parser.Term.simpleBinderWithoutType,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.many1, Lean.Parser.Term.binderIdent, Lean.Parser.pushNone, Bool.true],[Lean.Parser.Parser]]
[Lean.MetavarContext.setMVarType,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Std.PersistentHashMap.insert, Lean.MetavarContext.decls, Lean.MetavarDecl.mk, Lean.MetavarDecl.userName, Lean.MetavarDecl.lctx, Lean.MetavarDecl.depth, Lean.MetavarDecl.localInstances, Lean.MetavarDecl.kind, Lean.MetavarDecl.numScopeArgs, Lean.MetavarDecl.index, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment],[Lean.MetavarContext]]
[Lean.PrettyPrinter.Parenthesizer.skip.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.InfoState.noConfusionType,[],[]]
[USize.lor,[USize.mk, Fin.lor, USize.val],[USize]]
[Std.RBTree.instForInRBTree,[ForIn.mk, Std.RBTree.forIn],[ForIn, Std.RBTree]]
[Lean.Parser.trailingNode,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.checkLhsPrec, Lean.Parser.trailingNodeAux, Lean.Parser.setLhsPrec],[Lean.Parser.TrailingParser]]
[forall₄_congr,[forall_congr', forall₃_congr],[Iff]]
[Lean.Meta.abstract,[Lean.Meta.abstractRange, Array.size],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Parser.Syntax.cat,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.optPrecedence],[Lean.Parser.Parser]]
[Lean.MetavarContext.MkBinding.instMonadHashMapCacheAdapterExprStructEqExprM,[Lean.MonadHashMapCacheAdapter.mk, Bind.bind, MonadState.get, Pure.pure, Lean.MetavarContext.MkBinding.State.cache, modify, Lean.MetavarContext.MkBinding.State.mk, Lean.MetavarContext.MkBinding.State.mctx, Lean.MetavarContext.MkBinding.State.ngen],[Lean.MonadHashMapCacheAdapter, Lean.ExprStructEq, Lean.Expr, Lean.MetavarContext.MkBinding.M]]
[Lean.Lsp.LeanFileProgressParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.LeanFileProgressParams.mk, HAdd.hAdd, OfNat.ofNat]]
[instLEUInt16,[LE.mk, UInt16.le],[LE, UInt16]]
[Lean.Elab.Term.PatternElabException.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.PatternElabException.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.PatternElabException.mk, And]]
[Lean.Elab.WF.instInhabitedTerminationStrategy,[Inhabited.mk, Lean.Elab.WF.TerminationStrategy.mk, arbitrary],[Inhabited, Lean.Elab.WF.TerminationStrategy]]
[Lean.Elab.Tactic.evalDone,[Lean.Elab.Tactic.done],[Lean.Elab.Tactic.Tactic]]
[Lean.Xml.Parser.PEReference,[SeqRight.seqRight, Lean.Parsec.skipChar, Char.ofNat, Lean.Xml.Parser.Name],[Lean.Parsec, Unit]]
[Lean.Elab.Tactic.Conv.evalReduce,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.Conv.getLhs, liftM, Lean.Meta.reduce, Bool.true, Lean.Elab.Tactic.Conv.changeLhs],[Lean.Elab.Tactic.Tactic]]
[not_false_iff,[iff_true_intro, not_false],[Iff, Not, False, True]]
[System.FilePath.parent,[Functor.map, System.FilePath.mk, String.extract, System.FilePath.toString, OfNat.ofNat, String.revFind, List.contains, System.FilePath.pathSeparators],[Option, System.FilePath]]
[Lean.Meta.Simp.tryLemmaWithExtraArgs?,[Lean.Meta.withNewMCtxDepth, Bind.bind, liftM, Lean.Meta.SimpLemma.getValue, Lean.Meta.inferType, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.Simp.SimpM, Option, Lean.Meta.Simp.Result, Lean.Meta.instantiateMVars, Lean.Meta.whnf, ForIn.forIn, MProd.mk, Pure.pure, PUnit.unit, ForInStep.yield, Unit.unit, Option.some, Lean.Meta.Simp.Result.mk, Lean.mkAppN, Lean.Meta.mkCongrFun, Lean.Meta.isDefEq, ite, Eq, Bool.true, Lean.Meta.Simp.synthesizeArgs, Lean.Meta.SimpLemma.getName, Lean.Expr.isMVar, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Meta.Simp.SimpM, Option, Lean.Meta.Simp.Result]]
[Tactic.Ring.HornerExpr.e,[Lean.Expr],[Lean.Expr]]
[Lean.isIdBeginEscape,[Decidable.decide, Eq, Lean.idBeginEscape],[Bool]]
[Lean.Parser.Command.declModifiers.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.docComment.formatter, Lean.Parser.Term.attributes.formatter, Lean.PrettyPrinter.Formatter.ite, Eq, Lean.PrettyPrinter.Formatter.skip.formatter, Lean.ppDedent.formatter, Lean.ppLine.formatter, Lean.Parser.Command.visibility.formatter, Lean.Parser.Command.noncomputable.formatter, Lean.Parser.Command.unsafe.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.partial.formatter, Lean.Parser.Command.nonrec.formatter],[Lean.PrettyPrinter.Formatter]]
[ExceptT.run_bind,[rfl],[Eq, ExceptT.run, Bind.bind, Except, Pure.pure, Except.error]]
[Lean.Parser.Command.variable.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.mkLetDeclEx,[Lean.LocalDecl.ldecl, Bool.false],[Lean.LocalDecl]]
[Lean.Lsp.TextDocumentEdit.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.TextDocumentEdit.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.TextDocumentEdit.mk, And]]
[Lean.Parser.Command.declModifiersF.parenthesizer,[Lean.Parser.Command.declModifiers.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.elabProp,[Pure.pure, Lean.mkSort, Lean.levelZero],[Lean.Elab.Term.TermElab]]
[decidable_of_bool,[Decidable, Decidable.isTrue, decidable_of_bool.proof_1, Decidable.isFalse, decidable_of_bool.proof_2],[Decidable]]
[Lean.IR.Borrow.ownVar,[Bind.bind, Lean.IR.Borrow.getCurrFn, modify],[Lean.IR.Borrow.M, Unit]]
[Lean.IR.DeclInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.DeclInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.mkReducibilityHintsRegularEx,[Lean.ReducibilityHints.regular],[Lean.ReducibilityHints]]
[ReaderT.ext,[funext, id],[Eq]]
[Lean.Elab.Term.Do.mkVarDeclCore,[Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.decl, Lean.Elab.Term.Do.CodeBlock.code, Lean.Elab.Term.Do.eraseVars, Lean.Elab.Term.Do.CodeBlock.uvars],[Lean.Elab.Term.Do.CodeBlock]]
[Semigroup.noConfusionType,[],[]]
[USize.instSemigroupUSize,[Semigroup.mk, USize.instSemigroupUSize.proof_1],[Semigroup, USize]]
[Lean.MonadError.toMonadRef,[],[Lean.MonadRef]]
[Lean.JsonRpc.instCoeNotificationMessage,[Coe.mk, Lean.JsonRpc.Message.notification, Lean.JsonRpc.Notification.method, Except.toOption, Lean.Json.toStructured?, Lean.JsonRpc.Notification.param],[Coe, Lean.JsonRpc.Notification, Lean.JsonRpc.Message]]
[Lean.Elab.Term.ToDepElimPattern.State.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.IndPredBelow.BrecOnVariables.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.IndPredBelow.BrecOnVariables.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Level.paren.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.levelParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.LocalDecl.setUserName,[Lean.LocalDecl, Lean.LocalDecl.cdecl, Lean.LocalDecl.ldecl],[Lean.LocalDecl]]
[Lean.Lsp.TextDocumentItem.mk.inj,[And.intro],[And, Eq]]
[Lean.instInhabitedQuotKind,[Inhabited.mk, Lean.QuotKind.type],[Inhabited, Lean.QuotKind]]
[UInt8.instSemiringUInt8.proof_4,[congrArg, UInt8.mk, AddMonoid.nsmul_succ', UInt8.val],[Eq, UInt8.mk, Semiring.nsmul, Nat.succ, UInt8.val]]
[Lean.Parser.Term.let_tmp.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.letDecl.parenthesizer, Lean.Parser.Term.optSemicolon.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[unique_of_exists_unique,[Eq, Eq.trans, Eq.symm],[Eq]]
[Nat.eq_or_lt_of_not_lt,[Or.resolve_left, Nat.lt_trichotomy],[Or, Eq, LT.lt]]
[is_dec_refl,[Eq, Bool.true],[]]
[Lean.Parser.Term.doElem.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.doElemParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.JsonRpc.ErrorCode.parseError.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.JsonRpc.ErrorCode.parseError, OfNat.ofNat]]
[instCommRingFin.proof_1,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.mul_def, congrFun, HMod.hMod, Nat.mul_comm, eq_self, HMul.hMul],[Eq, HMul.hMul]]
[Nat.toUInt16,[UInt16.ofNat],[UInt16]]
[Ordering.gt.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Ordering.gt, OfNat.ofNat]]
[Lean.IR.Param.borrow,[],[Bool]]
[Except.instMonadExcept,[Monad.mk],[Monad, Except]]
[Std.PersistentHashMap.Stats.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.PersistentHashMap.Stats.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.PersistentHashMap.Stats.mk, And]]
[IO.Error.permissionDenied.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.permissionDenied, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.permissionDenied, And]]
[Lean.Lsp.Command.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.Command.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.Command.mk, And]]
[Lean.Elab.Modifiers.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Modifiers.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.continuity,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.isAbortExceptionId,[or, BEq.beq, Lean.Elab.abortCommandExceptionId, Lean.Elab.abortTermExceptionId, Lean.Elab.abortTacticExceptionId],[Bool]]
[Lean.IR.CtorFieldInfo.irrelevant.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.IR.CtorFieldInfo.irrelevant, OfNat.ofNat]]
[Lean.Elab.Term.MutualClosure.ClosureState.exprArgs,[],[Array, Lean.Expr]]
[Lean.Lsp.instInhabitedLineRange,[Inhabited.mk, Lean.Lsp.LineRange.mk, arbitrary],[Inhabited, Lean.Lsp.LineRange]]
[Append.noConfusionType,[],[]]
[Lean.importModules,[Lean.profileitIO, Lean.withImporting, Bind.bind, StateRefT'.run, Lean.ImportState.mk, IO, Lean.Environment, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield, MProd.mk, ForInStep, MProd, Std.HashMap, Lean.Name, Lean.ConstantInfo, Lean.ModuleIdx, Std.HashMap.insert', Lean.ConstantInfo.name, ite, Eq, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Nat, Lean.EnvExtensionInterface.mkInitialExtStates, Lean.EnvExtensionInterfaceImp, ST.Ref.get, Lean.persistentEnvExtensionsRef, Lean.EnvExtension.modifyState, Lean.PersistentEnvExtension.toEnvExtension, Lean.PersistentEnvExtensionState.mk, Array.push, Lean.PersistentEnvExtensionState.importedEntries, Lean.PersistentEnvExtensionState.state, Lean.ImportState.moduleData, OfNat.ofNat, Lean.importModules.importMods],[IO, Lean.Environment]]
[Lean.Meta.Instances.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Instances.mk, HAdd.hAdd, OfNat.ofNat]]
[String.map,[String.mapAux, OfNat.ofNat],[String]]
[Lean.instInhabitedMacroScopesView,[Inhabited.mk, Lean.MacroScopesView.mk, arbitrary],[Inhabited, Lean.MacroScopesView]]
[PUnit.unit.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, PUnit.unit, OfNat.ofNat]]
[Lean.ScopedEnvExtension.Descr.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ScopedEnvExtension.Descr.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.getSyntheticMVarDecl?,[Bind.bind, MonadState.get, Pure.pure, List.find?, BEq.beq, Lean.Elab.Term.SyntheticMVarDecl.mvarId, Lean.Elab.Term.State.syntheticMVars],[Lean.Elab.Term.TermElabM, Option, Lean.Elab.Term.SyntheticMVarDecl]]
[Lean.Parser.Attr.export.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Command.elabSyntaxAbbrev,[Bind.bind, Pure.pure, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Option.some, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Lean.Elab.Term.StructInst.FieldVal.term.inj,[],[Eq]]
[Lean.IR.EmitC.Context.mainParams,[],[Array, Lean.IR.Param]]
[false_of_true_eq_false,[trivial],[False]]
[Std.RBMap.min,[Option, Prod, Unit.unit, Std.RBNode.min, Option.some, Prod.mk, Option.none],[Option, Prod]]
[Lean.IR.UnreachableBranches.Value.truncateMaxDepth,[OfNat.ofNat],[Nat]]
[Mathlib.TermUnsafe.termUnsafe_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.CompletionInfo.tactic.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.CompletionInfo.tactic, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.CompletionInfo.tactic, And]]
[Lean.MetavarContext.MkBinding.collectDeps,[ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Pure.pure, Bind.bind, Nat.forM, Lean.MetavarContext.localDeclDependsOn, Lean.Expr.fvarId!, MonadExcept.throw, Lean.MetavarContext.MkBinding.Exception.revertFailure, PUnit.unit],[Except, Lean.MetavarContext.MkBinding.Exception, Array, Lean.Expr]]
[Lean.Lsp.DocumentSymbolParams.noConfusionType,[],[]]
[Lean.IR.CtorLayout.cidx,[],[Nat]]
[USize.instSemiringUSize.proof_3,[congrArg, USize.mk, Semiring.nsmul_zero', USize.val],[Eq, USize.mk, Semiring.nsmul, OfNat.ofNat, USize.val]]
[Lean.Compiler.hasMacroInlineAttribute,[Lean.Compiler.InlineAttributeKind.macroInline],[Bool]]
[Lean.Server.Completion.State.itemsOther,[],[Array, Lean.Lsp.CompletionItem]]
[Lean.IR.inferBorrow,[Bind.bind, Lean.IR.getEnv, Pure.pure, Lean.IR.Borrow.applyParamMap],[Lean.IR.CompilerM, Array, Lean.IR.Decl]]
[FloatArray.empty,[FloatArray.mkEmpty, OfNat.ofNat],[FloatArray]]
[Lean.Compiler.setInlineAttribute,[Lean.EnumAttributes.setValue, Lean.Compiler.inlineAttrs],[Except, String, Lean.Environment]]
[Lean.PrettyPrinter.Parenthesizer.categoryParserOfStack.parenthesizer,[Bind.bind, MonadState.get, Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Syntax.getId],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Widget.Lean.Widget.CodeToken.instFromJsonRpcEncodingPacket,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.RpcRef, Pure.pure],[Lean.FromJson]]
[Lean.Meta.isMatcherApp,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Meta.isMatcherAppCore],[Bool]]
[Lean.Meta.addPPExplicitToExposeDiff,[Bind.bind, Lean.MonadOptions.getOptions, ite, Eq, or, Lean.KVMap.getBool, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false, Bool.true, Pure.pure, Prod.mk, Lean.Meta.instantiateMVars, Lean.Meta.addPPExplicitToExposeDiff.visit, Lean.Meta.addPPExplicitToExposeDiff.hasExplicitDiff?],[Lean.Meta.MetaM, Prod, Lean.Expr]]
[Lean.Json.str.injEq,[Eq.propIntro, Eq.refl, Lean.Json.str, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Json.str]]
[Array.instHAppendArrayListArray,[HAppend.mk, Array.appendList],[HAppend, Array, List]]
[Lean.IR.Sorry.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Sorry.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.CancelParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.CancelParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.CancelParams.mk]]
[Lean.Elab.Term.ToParserDescrContext.behavior,[],[Lean.Parser.LeadingIdentBehavior]]
[Std.PersistentArray.foldlM,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Bind.bind, Std.PersistentArray.root, Array.foldlM, Std.PersistentArray.tail, Array.size, GE.ge, Std.PersistentArray.tailOff, HSub.hSub, USize.ofNat, Std.PersistentArray.shift],[]]
[Function.inv_fun_eq,[Function.inv_fun_on_eq, Exists, And, Mem.mem, Set.univ, Eq, Exists.intro, And.intro, trivial],[Eq, Function.inv_fun]]
[Lean.Server.Watchdog.log,[Bind.bind, MonadReader.read, liftM, IO.FS.Stream.putStrLn, Lean.Server.Watchdog.ServerContext.hLog, IO.FS.Stream.flush],[Lean.Server.Watchdog.ServerM, Unit]]
[Lean.Level.ibelow,[True, And],[]]
[Lean.Parser.ParserExtension.Entry.toOLeanEntry,[Lean.Parser.ParserExtension.OLeanEntry, Lean.Parser.ParserExtension.OLeanEntry.token, Lean.Parser.ParserExtension.OLeanEntry.kind, Lean.Parser.ParserExtension.OLeanEntry.category, Lean.Parser.ParserExtension.OLeanEntry.parser],[Lean.Parser.ParserExtension.OLeanEntry]]
[Lean.ParserCompiler.CombinatorAttribute.mk.inj,[And.intro],[And, Eq]]
[Lean.QuotKind.noConfusionType,[noConfusionTypeEnum, Lean.QuotKind.toCtorIdx],[]]
[IO.AsyncList.noConfusionType,[],[]]
[Lean.Parser.Command.catBehavior.formatter,[Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.catBehaviorBoth.formatter, Lean.Parser.Command.catBehaviorSymbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.IR.EmitC.emitLn,[Bind.bind, Lean.IR.EmitC.emit],[Lean.IR.EmitC.M, Unit]]
[instOfNatUSize,[OfNat.mk, USize.ofNat],[OfNat, USize]]
[IO.lazyPure,[Pure.pure, Unit.unit],[IO]]
[Lean.Parser.Tactic.opInduction,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Meta.synthInstance,[Lean.catchInternalId, Lean.Meta.isDefEqStuckExceptionId, Bind.bind, Lean.Meta.synthInstance?, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.IR.usesModuleFrom,[List.any, Array.toList, Lean.Environment.allImportedModuleNames, Lean.Name.isPrefixOf],[Bool]]
[iff_true_left,[Iff.intro, Iff.mp, iff_of_true],[Iff]]
[System.FilePath.withFileName,[Unit.unit, System.FilePath, System.FilePath.parent, System.FilePath.mk, HDiv.hDiv],[System.FilePath]]
[Lean.Parser.Tactic.revert,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.SyntaxNode.getArg,[Lean.SyntaxNode.withArgs, Array.get!],[Lean.Syntax]]
[String.decEq.proof_1,[congrArg, String.mk],[Eq, String.mk]]
[Lean.Widget.CodeToken.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Widget.CodeToken.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.MatcherApp.params,[],[Array, Lean.Expr]]
[Lean.Compiler.foldNatDecEq,[Lean.Compiler.foldNatBinPred, Lean.Compiler.mkNatEq, Decidable.decide, Eq],[Option, Lean.Expr]]
[Lean.SMap.findD,[Option.getD, Lean.SMap.find?],[]]
[Not,[False],[]]
[Complement.noConfusionType,[],[]]
[Lean.Meta.contradiction,[Bind.bind, Lean.Meta.contradictionCore, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing],[Lean.Meta.MetaM, Unit]]
[UInt32.instSemiringUInt32.proof_5,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, congrFun, HMul.hMul, UInt32.zero_def, UInt32.mul_def, UInt32.mk, OfNat.ofNat, MonoidWithZero.zero_mul, UInt32.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt32],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.MessageData.instantiateMVars,[Lean.MetavarContext.mk, Lean.MessageData.instantiateMVars.visit],[Lean.MessageData]]
[Lean.Parser.symbol.formatter,[Lean.PrettyPrinter.Formatter.tokenWithAntiquot.formatter, Lean.PrettyPrinter.Formatter.symbolNoAntiquot.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.DerivingClassView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.DerivingClassView.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.DerivingClassView.mk, And]]
[Std.ShareCommon.ObjectMap,[Std.HashMap, Std.ShareCommon.Object],[]]
[Lean.Parser.Term.haveIdDecl.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Term.haveIdLhs.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.RecursorUnivLevelPos.noConfusionType,[],[]]
[Lean.IR.EmitC.emitLns,[List.forM, Lean.IR.EmitC.emitLn],[Lean.IR.EmitC.M, Unit]]
[Lean.Elab.OpenDecl.M,[StateRefT', IO.RealWorld, Lean.Elab.OpenDecl.State],[]]
[Lean.LazyInitExtension.noConfusionType,[],[]]
[Mathlib.Tactic.Lint.NamedLinter.name,[Lean.Name.updatePrefix, Mathlib.Tactic.Lint.NamedLinter.declName, Lean.Name.anonymous],[Lean.Name]]
[List.empty_eq,[rfl],[Eq, EmptyCollection.emptyCollection, List.nil]]
[Std.PersistentHashSet.erase,[Std.PersistentHashSet.mk, Std.PersistentHashMap.erase, Std.PersistentHashSet.set],[Std.PersistentHashSet]]
[Lean.Meta.reduceNat?,[ite, Eq, or, Lean.Expr.hasFVar, Lean.Expr.hasMVar, Bool.true, Pure.pure, Option.none, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Option, Lean.Expr, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.reduceUnaryNatOp, Nat.succ, Lean.Meta.reduceBinNatOp, Nat.add, Nat.sub, Nat.mul, Nat.div, Nat.mod, Lean.Meta.reduceBinNatPred, Nat.beq, Nat.ble],[Lean.Meta.MetaM, Option, Lean.Expr]]
[Decidable.byCases,[],[]]
[Lean.Meta.mkHCongr,[Bind.bind, Lean.Meta.getFunInfo, Lean.Meta.mkHCongrWithArity, Lean.Meta.FunInfo.getArity],[Lean.Meta.MetaM, Lean.Meta.CongrTheorem]]
[Lean.IR.ExplicitBoxing.castResultIfNeeded,[ite, Eq, Lean.IR.ExplicitBoxing.eqvTypes, Bool.true, Pure.pure, Lean.IR.FnBody.vdecl, Bind.bind, getModify, Lean.IR.ExplicitBoxing.BoxingState.mk, HAdd.hAdd, Lean.IR.ExplicitBoxing.BoxingState.nextIdx, OfNat.ofNat, Lean.IR.ExplicitBoxing.BoxingState.auxDecls, Lean.IR.ExplicitBoxing.BoxingState.auxDeclCache, Lean.IR.ExplicitBoxing.BoxingState.nextAuxId, Lean.IR.VarId.mk, Lean.IR.ExplicitBoxing.mkCast],[Lean.IR.ExplicitBoxing.M, Lean.IR.FnBody]]
[forall_prop_decidable.proof_1,[Iff.intro],[Iff]]
[Lean.Elab.Term.Do.hasTerminalAction,[Lean.Elab.Term.Do.hasExitPointPred, Lean.Elab.Term.Do.Code.decl, Lean.Elab.Term.Do.Code.reassign, Lean.Elab.Term.Do.Code.joinpoint, Lean.Elab.Term.Do.Code.seq, Lean.Elab.Term.Do.Code.break, Lean.Elab.Term.Do.Code.continue, Lean.Elab.Term.Do.Code.return, Lean.Elab.Term.Do.Code.ite, Lean.Elab.Term.Do.Code.match, Lean.Elab.Term.Do.Code.jmp, Bool, Bool.true, Bool.false],[Bool]]
[List.erasep_subset,[List.exists_or_eq_self_of_erasep, Eq.mpr, Eq.refl, Mem.mem, List.subset.refl, Eq.symm, HAppend.hAppend, List.cons, propext, List.mem_append, Or, Or.inl, Or.inr, List.mem_cons_of_mem],[Subset.subset, List.erasep]]
[IO.FS.Stream.isEof,[],[IO, Bool]]
[Lean.Lsp.instHashableRpcRef,[Hashable.mk, UInt64, mixHash, OfNat.ofNat, Hashable.hash],[Hashable, Lean.Lsp.RpcRef]]
[Lean.instInhabitedSyntax,[Inhabited.mk, Lean.Syntax.missing],[Inhabited, Lean.Syntax]]
[trivial,[True.intro],[True]]
[Lean.Meta.reduceNatNativeUnsafe,[Lean.evalConstCheck, Nat, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Meta.MetaM, Nat]]
[Lean.Parser.addParserCategory,[ite, Eq, Lean.Parser.isParserCategory, Bool.true, MonadExcept.throw, HAppend.hAppend, ToString.toString, Pure.pure, Lean.ScopedEnvExtension.addEntry, Lean.Parser.parserExtension, Lean.Parser.ParserExtension.Entry.category],[Except, String, Lean.Environment]]
[Lean.Parser.Term.fun.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.maxPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.unicodeSymbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.basicFun.parenthesizer, Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.PrettyPrinter.Parenthesizer.State.stxTrav,[],[Lean.Syntax.Traverser]]
[Lean.Widget.MsgToInteractive.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Widget.MsgToInteractive.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.instFromJsonTextEditBatch,[Lean.FromJson.mk, Lean.FromJson.fromJson?],[Lean.FromJson, Lean.Lsp.TextEditBatch]]
[Lean.Expr.FoldConstsImpl.initCache,[Lean.Expr.FoldConstsImpl.State.mk, Array.mkArray, USize.toNat, Lean.Expr.FoldConstsImpl.cacheSize, cast, Lean.Expr.FoldConstsImpl.initCache.proof_1, Unit.unit, EmptyCollection.emptyCollection],[Lean.Expr.FoldConstsImpl.State]]
[Lean.Expr.instantiateLevelParamsCore.visit,[ite, Eq, not, Lean.Expr.hasLevelParam, Bool.true, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.lit, Lean.Expr, Lean.Expr.updateLambdaE!, PProd.fst, PProd.snd, Lean.Expr.updateForallE!, Lean.Expr.updateLet!, Lean.Expr.updateApp!, Lean.Expr.updateProj!, Lean.Expr.updateMData!, Lean.Expr.updateConst!, List.map, Lean.Level.instantiateParams, Lean.Expr.updateSort!],[Lean.Expr]]
[Lean.AttributeImpl.erase,[],[Lean.AttrM, Unit]]
[Lean.Parser.mkAntiquot.formatter,[Lean.Parser.leadingNode.formatter, Lean.Parser.maxPrec, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.setExpected.formatter, List.nil, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.manyNoAntiquot.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.antiquotExpr.formatter, Lean.PrettyPrinter.Formatter.ite, Eq, Bool.true, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.node.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.PrettyPrinter.Formatter.checkNoImmediateColon.formatter, Lean.PrettyPrinter.Formatter.pushNone.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.MonadTrace.modifyTraceState,[],[Unit]]
[tacticMatchTarget_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Compiler.NumScalarTypeInfo.id,[],[Lean.Name]]
[Lean.IR.Decl.insertResetReuse,[Lean.IR.Decl.extern, Lean.IR.Decl, Lean.IR.Decl.updateBody!],[Lean.IR.Decl]]
[Lean.Parser.withOpenDeclFnCore,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.prec, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Parser.ParserContext.savedPos?, Lean.Parser.ParserContext.forbiddenTk?, Array.map, Lean.Syntax.getId, Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat, Bool.false],[Lean.Parser.ParserFn]]
[Lean.Parser.Command.eraseAttr.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.rawIdent.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.instInhabitedMVarErrorKind,[Inhabited.mk, Lean.Elab.Term.MVarErrorKind.implicitArg, arbitrary],[Inhabited, Lean.Elab.Term.MVarErrorKind]]
[Std.RBMap.depth,[Std.RBNode.depth, Subtype.val],[Nat]]
[Array.forM,[Array.foldlM, PUnit.unit],[PUnit]]
[Lean.Elab.WF.mkFix,[Bind.bind, Lean.Meta.forallBoundedTelescope, Lean.Elab.PreDefinition.type, Option.some, OfNat.ofNat, liftM, Lean.Meta.inferType, Lean.Meta.getLevel, Lean.Meta.mkLambdaFVars, List.toArray, List.cons, List.nil, Bool.false, Bool.true, Pure.pure, Lean.mkApp4, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.whnf, Lean.Expr.bindingDomain!, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.mk, Lean.Elab.PreDefinition.ref, Lean.Elab.PreDefinition.kind, Lean.Elab.PreDefinition.levelParams, Lean.Elab.PreDefinition.modifiers, Lean.mkApp],[Lean.Elab.Term.TermElabM, Lean.Elab.PreDefinition]]
[Lean.IR.Log.format,[Array.foldl, HAppend.hAppend, Std.ToFormat.format, Std.Format.line, Std.Format.nil, OfNat.ofNat, Array.size],[Std.Format]]
[Lean.Json.Parser.escapedChar,[Bind.bind, Lean.Parsec.anyChar, dite, Eq, Char.ofNat, Unit.unit, Eq.symm, Lean.Parsec, Char, Pure.pure, Lean.Json.Parser.hexChar, HAdd.hAdd, HMul.hMul, OfNat.ofNat, Lean.Parsec.fail],[Lean.Parsec, Char]]
[Function.involutive.right_inverse,[],[Function.right_inverse]]
[Lean.Parser.Trie.noConfusionType,[],[]]
[Nat.instModNat,[Mod.mk, Nat.mod],[Mod, Nat]]
[Lean.Expr.fvar.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.fvar, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Expr.fvar, And]]
[Lean.Parser.Term.doIfProp.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.optIdent.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.testParseModule,[Bind.bind, Lean.Parser.parseHeader, IO, Lean.Syntax, Lean.Parser.testParseModuleAux, List.toArray, List.nil, Pure.pure, Lean.Syntax.updateLeading],[IO, Lean.Syntax]]
[UInt64.instRingUInt64.proof_1,[congrArg, UInt64.mk, Ring.sub_eq_add_neg, UInt64.val],[Eq, UInt64.mk]]
[Lean.Lsp.RpcConnected.noConfusionType,[],[]]
[Lean.Syntax.getOptional?,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Option, Lean.Syntax, ite, Eq, and, BEq.beq, Lean.nullKind, Array.size, OfNat.ofNat, Bool.true, Option.some, Array.get!, Option.none],[Option, Lean.Syntax]]
[Lean.Elab.Term.Do.ToCodeBlock.run,[ReaderT.run, Lean.Elab.Term.Do.ToCodeBlock.doSeqToCode, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, List.map, Lean.Syntax.getOp, OfNat.ofNat, Array.toList, Lean.Syntax.getArgs, List.nil, Lean.Elab.Term.Do.ToCodeBlock.Context.mk],[Lean.Elab.Term.TermElabM, Lean.Elab.Term.Do.CodeBlock]]
[List.mem_insert_iff,[Classical.em, Mem.mem, Eq.mpr, Eq.refl, Iff, List.insert, Or, Eq, List.insert_of_mem, Iff.intro, Or.inr, Eq.symm, List.insert_of_not_mem, Iff.rfl],[Iff, Mem.mem, List.insert, Or, Eq]]
[Lean.Elab.Term.«termFun.»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Macro.mkMethodsImp,[unsafeCast],[PointedType.type]]
[LawfulFunctor.comp_map,[],[Eq, Functor.map, Function.comp]]
[Lean.instQuoteSyntax,[Lean.Quote.mk, id],[Lean.Quote, Lean.Syntax]]
[Lean.instInhabitedParserDescr,[Inhabited.mk, Lean.ParserDescr.symbol],[Inhabited, Lean.ParserDescr]]
[Function.injective.eq_iff',[Function.injective.eq_iff],[Iff, Eq]]
[randNat,[Prod, Nat, Prod.mk],[Prod, Nat]]
[Lean.mkRat,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Lean.Rat.normalize],[Lean.Rat]]
[liftM,[MonadLiftT.monadLift],[]]
[Lean.Parser.Tactic.convertTo,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[IO.Error.unsupportedOperation.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.unsupportedOperation, HAdd.hAdd, OfNat.ofNat]]
[Std.HashSetImp.WellFormed.brecOn,[Std.HashSetImp.WellFormed.below.mkWff, Std.HashSetImp.WellFormed.below.insertWff, Std.HashSetImp.WellFormed.below.eraseWff],[]]
[Lean.InductiveType.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.ParserState.mkNode,[Lean.Parser.ParserState, ite, Eq, and, bne, Option.none, BEq.beq, Array.size, Bool.true, Lean.Parser.ParserState.mk],[Lean.Parser.ParserState]]
[Lean.Parser.Term.binrel,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.ppSpace, Lean.Parser.termParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[Lean.ExternAttrData.entries,[],[List, Lean.ExternEntry]]
[Lean.Elab.FieldInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.FieldInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.FieldInfo.mk, And]]
[Lean.Expr.FindImpl.FindM,[StateT, Lean.Expr.FindImpl.State, Id],[]]
[Lean.PrettyPrinter.Formatter.strLit.formatter,[Lean.Parser.Term.str.formatter],[Lean.PrettyPrinter.Formatter]]
[UInt64.instAddSemigroupUInt64,[AddSemigroup.mk, UInt64.instAddSemigroupUInt64.proof_1],[AddSemigroup, UInt64]]
[Lean.Meta.IndPredBelow.mkContext.motiveName,[ite, GT.gt, Array.size, OfNat.ofNat, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkSimple, HAppend.hAppend, ToString.toString, Nat.succ],[Lean.Meta.MetaM, Lean.Name]]
[instMonadFinallyEIO,[inferInstanceAs, MonadFinally, EStateM, IO.RealWorld],[MonadFinally, EIO]]
[Array.mapSepElems,[Id.run, Array.mapSepElemsM],[Array, Lean.Syntax]]
[UInt8.toChar,[Char.mk, UInt8.toUInt32, UInt8.toChar.proof_1],[Char]]
[IsAddRightCancel.noConfusionType,[],[]]
[withPtrAddr,[OfNat.ofNat],[]]
[Lean.Meta.UnificationHints.add,[Lean.Meta.UnificationHints.mk, Lean.Meta.DiscrTree.insertCore, Lean.Meta.UnificationHints.discrTree, Lean.Meta.UnificationHintEntry.keys, Lean.Meta.UnificationHintEntry.val],[Lean.Meta.UnificationHints]]
[Lean.Meta.TransparencyMode.hash,[Unit.unit, UInt64, OfNat.ofNat],[UInt64]]
[List.map₂,[List.nil, List.cons, List, PProd.fst],[List]]
[Lean.Elab.Term.LetRecToLift.localInstances,[],[Lean.LocalInstances]]
[Lean.Meta.resetZetaFVarIds,[modify, Lean.Meta.State.mk, Lean.Meta.State.mctx, Lean.Meta.State.cache, EmptyCollection.emptyCollection, Lean.Meta.State.postponed],[Lean.Meta.MetaM, Unit]]
[Lean.Meta.CaseValueSubgoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.CaseValueSubgoal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.CaseValueSubgoal.mk, And]]
[Lean.Meta.Simp.rewriteCtorEq?,[Lean.Meta.withReducibleAndInstances, Unit.unit, Lean.Meta.MetaM, Option, Lean.Meta.Simp.Result, Lean.Expr.eq?, Pure.pure, Option.none, Bind.bind, Lean.Meta.whnf, Lean.MonadEnv.getEnv, Option.some, Prod.mk, Lean.Expr.constructorApp?, ite, Eq, bne, Lean.ConstantVal.name, Lean.ConstructorVal.toConstantVal, Bool.true, Lean.Meta.withLocalDeclD, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.mkNoConfusion, Lean.mkConst, List.nil, Lean.Meta.mkLambdaFVars, List.toArray, List.cons, Bool.false, Lean.Meta.mkEqFalse', Lean.Meta.Simp.Result.mk],[Lean.Meta.MetaM, Option, Lean.Meta.Simp.Result]]
[Nat.decLe,[dite, Eq, Nat.ble, Bool.true, Decidable.isTrue, Nat.le_of_ble_eq_true, Decidable.isFalse, Nat.not_le_of_not_ble_eq_true],[Decidable, LE.le]]
[Lean.Parser.Term.leftArrow.formatter,[Lean.Parser.unicodeSymbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.ConstantInfo.value!,[Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.Expr, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[Substring.trim,[Substring, Substring.mk],[Substring]]
[Lean.DefinitionSafety.noConfusion,[noConfusionEnum, Lean.DefinitionSafety.toCtorIdx],[Lean.DefinitionSafety.noConfusionType]]
[Monoid.npow_zero',[],[Eq, Monoid.npow, OfNat.ofNat]]
[Lean.Meta.Match.Pattern.arrayLit.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.refl, List.nil, Eq.trans, Eq.symm, List.cons.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Meta.Match.Pattern.arrayLit, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.whereStructField.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.Term.letDecl.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Subarray.noConfusionType,[],[]]
[Lean.Elab.Term.StructInst.formatField,[HAppend.hAppend, Std.Format.joinSep, Lean.Elab.Term.StructInst.Field.lhs, Std.Format.text, Unit.unit, Std.Format, Lean.Elab.Term.StructInst.Field.val, Lean.Syntax.prettyPrint],[Std.Format]]
[Lean.PersistentEnvExtensionDescr.name,[],[Lean.Name]]
[Lean.Elab.Structural.EqnsExtState.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Structural.EqnsExtState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Structural.EqnsExtState.mk]]
[List.findSome?,[Unit.unit, Option, Option.none, Option.some, PProd.fst],[Option]]
[IO.FS.Metadata.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.FS.Metadata.mk, HAdd.hAdd, OfNat.ofNat]]
[Function.sometimes,[dite, Nonempty, Classical.choice],[]]
[Quotient,[Quot, Setoid.r],[]]
[UInt16.shiftLeft,[UInt16.mk, HShiftLeft.hShiftLeft, UInt16.val, UInt16.modn, OfNat.ofNat],[UInt16]]
[Lean.Meta.instInhabitedInductionSubgoal,[Inhabited.mk, Lean.Meta.InductionSubgoal.mk, arbitrary],[Inhabited, Lean.Meta.InductionSubgoal]]
[runEST,[Except, Unit, Unit.unit, Except.ok, Except.error],[Except]]
[Lean.Parser.Term.funBinder,[HOrElse.hOrElse, Lean.Parser.Term.funStrictImplicitBinder, Lean.Parser.Term.funImplicitBinder, Lean.Parser.Term.instBinder, Lean.Parser.Term.funSimpleBinder, Lean.Parser.termParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[Lean.instInhabitedAttributeApplicationTime,[Inhabited.mk, Lean.AttributeApplicationTime.afterTypeChecking],[Inhabited, Lean.AttributeApplicationTime]]
[OptionT.instMonadOptionT,[Monad.mk],[Monad, OptionT]]
[Lean.Lsp.instFromJsonSemanticTokensOptions,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.SemanticTokensLegend, Bool, Pure.pure, Lean.Lsp.SemanticTokensOptions.mk],[Lean.FromJson, Lean.Lsp.SemanticTokensOptions]]
[TC.wf.proof_1,[WellFounded.intro, TC.accessible, WellFounded.apply],[WellFounded, TC]]
[Lean.Meta.UnificationHints.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.UnificationHints.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.getPPAll,[Lean.KVMap.get, Lean.Option.name, Lean.pp.all, Bool.false],[Bool]]
[Sum.inl.inj,[],[Eq]]
[Lean.IR.instInhabitedIndexSet,[Inhabited.mk, EmptyCollection.emptyCollection],[Inhabited, Lean.IR.IndexSet]]
[or_iff_not_and_not,[Decidable.or_iff_not_and_not],[Iff, Or, Not, And]]
[EStateM.Result.noConfusionType,[],[]]
[instDecidableIff.proof_2,[Iff.mp],[False]]
[Nat.shiftRight,[Nat, HDiv.hDiv, PProd.fst, OfNat.ofNat],[Nat]]
[Lean.Meta.instToFormatInstanceEntry,[Std.ToFormat.mk, Option.none, Std.Format, Lean.Meta.InstanceEntry.globalName?, Std.ToFormat.format, Std.Format.text],[Std.ToFormat, Lean.Meta.InstanceEntry]]
[Lean.IR.EmitC.emitSetTag,[Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn],[Lean.IR.EmitC.M, Unit]]
[Lean.Meta.ElimInfo.motivePos,[],[Nat]]
[Lean.Parser.Command.nonrec.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.SSet.switch,[Lean.SMap.switch],[Lean.SSet]]
[DivInvMonoid.toDiv,[],[Div]]
[Substring.nextn,[String.Pos, PProd.fst, Substring.next],[String.Pos]]
[Lean.KernelException.other.inj,[],[Eq]]
[Lean.Compiler.instInhabitedSpecInfo,[Inhabited.mk, Lean.Compiler.SpecInfo.mk, arbitrary],[Inhabited, Lean.Compiler.SpecInfo]]
[Lean.Parser.peekToken,[ite, Eq, BEq.beq, Lean.Parser.TokenCacheEntry.startPos, Lean.Parser.ParserState.pos, Bool.true, Prod.mk, Except.ok, Lean.Parser.TokenCacheEntry.token, Lean.Parser.peekTokenAux],[Prod, Lean.Parser.ParserState, Except, Lean.Syntax]]
[plift.down,[],[]]
[Lean.Meta.Simp.Result.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Simp.Result.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.instMonadQuotationUnexpandM,[Lean.MonadQuotation.mk, Pure.pure, OfNat.ofNat, Lean.Name.mkStr, Lean.Name.anonymous, id],[Lean.MonadQuotation, Lean.PrettyPrinter.UnexpandM]]
[Lean.Elab.Term.MutualClosure.ClosureState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.MutualClosure.ClosureState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.mkAtom,[Lean.Syntax.atom],[Lean.Syntax]]
[Lean.IR.EmitC.emitOffset,[ite, GT.gt, OfNat.ofNat, Bind.bind, Lean.IR.EmitC.emit, Pure.pure, PUnit.unit],[Lean.IR.EmitC.M, Unit]]
[Lean.Eval.eval,[],[IO, Unit]]
[Lean.OptionDecl.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.OptionDecl.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.OptionDecl.mk, And]]
[Lean.Compiler.mkUnsafeRecName,[Lean.Name.mkStr],[Lean.Name]]
[Lean.instToJsonName,[Lean.ToJson.mk, Lean.Json.str, ToString.toString],[Lean.ToJson, Lean.Name]]
[not_of_iff_false,[Iff.mp],[Not]]
[Lean.Meta.MatcherApp.toExpr,[Lean.mkAppN, Lean.Meta.MatcherApp.remaining],[Lean.Expr]]
[instReprAtomUSize,[ReprAtom.mk],[ReprAtom, USize]]
[Lean.Parser.Term.attrInstance,[Lean.Parser.ppGroup, Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.attrKind, Lean.Parser.attrParser],[Lean.Parser.Parser]]
[List.isEmpty,[Unit.unit, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Parser.Tactic.ringExp!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.IR.EmitC.emitDeclInit,[Bind.bind, Lean.IR.EmitC.getEnv, ite, Eq, Lean.isIOUnitInitFn, Bool.true, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitCName, Lean.IR.EmitC.emitLn, BEq.beq, Array.size, Lean.IR.Decl.params, OfNat.ofNat, Option.none, Lean.IR.EmitC.M, Unit, Lean.getInitFnNameFor?, Lean.IR.Decl.name, Lean.IR.EmitC.emitMarkPersistent, Lean.IR.EmitC.emitCInitName, Pure.pure, PUnit.unit],[Lean.IR.EmitC.M, Unit]]
[List.find?,[Unit.unit, Option, Option.none, Option.some, PProd.fst],[Option]]
[Lean.Meta.Simp.getCongrLemmas,[Bind.bind, readThe, Lean.Meta.Simp.Context, Pure.pure, Lean.Meta.Simp.Context.congrLemmas],[Lean.Meta.Simp.M, Lean.Meta.CongrLemmas]]
[Lean.CollectMVars.State.noConfusionType,[],[]]
[Except.pure,[Except.ok],[Except]]
[Lean.Parser.Term.letEqnsDecl.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.letIdLhs.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.matchAlts.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.instFromJsonDocumentHighlightParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.DocumentHighlightParams.mk, Lean.Lsp.TextDocumentPositionParams.mk],[Lean.FromJson, Lean.Lsp.DocumentHighlightParams]]
[instToStringId,[inferInstanceAs, ToString],[ToString, id]]
[Lean.Json.bool.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Json.bool, HAdd.hAdd, OfNat.ofNat]]
[Lean.ParserCompiler.Context.noConfusionType,[],[]]
[USize.mul_def,[rfl],[Eq, HMul.hMul, USize.mk, USize.val]]
[instDecidableLe_4,[USize.decLe],[Decidable, LE.le]]
[Lean.mkFVar,[Lean.Expr.fvar, Lean.Expr.mkData, mixHash, OfNat.ofNat, Hashable.hash, Bool.true, Bool.false],[Lean.Expr]]
[Lean.Elab.Command.elabCheck,[Lean.Elab.Command.elabCheckCore, Bool.true],[Lean.Elab.Command.CommandElab]]
[Lean.IR.Borrow.BorrowInfCtx.currFn,[],[Lean.IR.FunId]]
[Array.ofSubarray,[Id.run, Bind.bind, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield],[Array]]
[Lean.Parser.Command.abbrev.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.Command.optDeclSig.parenthesizer, Lean.Parser.Command.declVal.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.Do.JPDecl.body,[],[Lean.Elab.Term.Do.Code]]
[Lean.Parser.Level.max.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.nonReservedSymbol.formatter, Lean.Parser.many1.formatter, Lean.ppSpace.formatter, Lean.Parser.levelParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.LetRecToLift.mk.inj,[And.intro],[And, Eq]]
[List.exists_mem_of_length_pos,[Exists, Mem.mem, Eq.refl, List.length, List.nil, HEq.refl, Exists.intro, List.mem_cons_self],[Exists, Mem.mem]]
[Lean.Expr.isAppOf,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Lean.Expr.getAppFn, BEq.beq, Bool.false],[Bool]]
[Lean.KernelException.other.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KernelException.other, HAdd.hAdd, OfNat.ofNat]]
[Lean.EnvExtensionInterfaceUnsafe.imp,[Lean.EnvExtensionInterface.mk, Lean.EnvExtensionInterfaceUnsafe.Ext, Inhabited.mk, arbitrary, Lean.EnvExtensionInterfaceUnsafe.registerExt, Lean.EnvExtensionInterfaceUnsafe.setState, Lean.EnvExtensionInterfaceUnsafe.modifyState, Lean.EnvExtensionInterfaceUnsafe.getState, Lean.EnvExtensionInterfaceUnsafe.mkInitialExtStates, Lean.EnvExtensionInterfaceUnsafe.ensureExtensionsArraySize],[Lean.EnvExtensionInterface]]
[Lean.Meta.isDefEq,[Lean.Meta.isExprDefEq],[Lean.Meta.MetaM, Bool]]
[Lean.Elab.Term.elabDepArrow,[Lean.Elab.Term.elabBinders, List.toArray, List.cons, List.nil, Bind.bind, Lean.Elab.Term.elabType, liftM, Lean.Meta.mkForallFVars, Bool.false, Bool.true],[Lean.Elab.Term.TermElab]]
[Lean.Parser.ModuleParserState.noConfusionType,[],[]]
[Lean.Elab.Tactic.ElimApp.Result.elimApp,[],[Lean.Expr]]
[«term{}»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.KeyedDeclsAttribute.OLeanEntry.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Command.inductive,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.declId, Lean.Parser.Command.optDeclSig, Lean.Parser.optional, HOrElse.hOrElse, Lean.Parser.many, Lean.Parser.Command.ctor, Lean.Parser.Command.optDeriving],[Lean.Parser.Parser]]
[Lean.Expr.isSorry,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[Lean.mkLambda,[Lean.Expr.lam, Lean.Expr.mkDataForBinder, mixHash, UInt8.toUInt64, Hashable.hash, max, Lean.Expr.looseBVarRange, HSub.hSub, OfNat.ofNat, or, Lean.Expr.hasFVar, Lean.Expr.hasExprMVar, Lean.Expr.hasLevelMVar, Lean.Expr.hasLevelParam],[Lean.Expr]]
[Option.map_id,[funext, Unit.unit, Eq, Option.map, id, rfl],[Eq, Option.map, id]]
[Std.Format.instMonadPrettyFormatStateMState,[Std.Format.MonadPrettyFormat.mk, modify, HAppend.hAppend, HAdd.hAdd, String.length, String.pushn, Char.ofNat, Bind.bind, MonadState.get, Pure.pure, Unit.unit],[Std.Format.MonadPrettyFormat, StateM]]
[ST.Ref.mk.injEq,[Eq.propIntro, Eq.refl, ST.Ref.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, ST.Ref.mk]]
[Option.instDecidableRelLt,[Unit.unit, Decidable, Option.lt, Decidable.isTrue, trivial, Decidable.isFalse, not_false],[DecidableRel, Option.lt]]
[Lean.Parser.termParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Parenthesizer]]
[Mathlib.Tactic.Lint.elements,[Bind.bind, ForIn.forIn, PUnit.unit, StateT, Array, Id, ForInStep, PUnit, Mathlib.Tactic.Lint.trieElements, Pure.pure, ForInStep.yield],[StateT, Array, Id, Unit]]
[Lean.Parser.optionalNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.optionaInfo, Lean.Parser.Parser.info, Lean.Parser.optionalFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.Parser.Term.haveIdLhs.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.simpleBinderWithoutType.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Bool.false, Lean.Parser.Term.optType.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Tactic.evalEraseAuxDiscrs,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.MonadLCtx.getLCtx, Lean.Elab.Tactic.getMainGoal, ForIn.forIn, liftM, Lean.Meta.tryClear, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.nil],[Lean.Elab.Tactic.Tactic]]
[Std.HashMap.findEntry?,[Option, Prod, Std.HashMapImp.findEntry?],[Option, Prod]]
[Lean.Json.Structured.noConfusionType,[],[]]
[Lean.Expr.forallE.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Expr.forallE, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.squeezeDSimp!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Elab.Term.registerMVarErrorImplicitArgInfo,[Lean.Elab.Term.registerMVarErrorInfo, Lean.Elab.Term.MVarErrorInfo.mk, Lean.Elab.Term.MVarErrorKind.implicitArg],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Core.liftIOCore,[Bind.bind, Lean.MonadRef.getRef, liftM, IO.toEIO, Lean.Exception.error, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, ToString.toString],[Lean.Core.CoreM]]
[Lean.Meta.collectUsedFVars,[Bind.bind, liftM, Lean.Meta.instantiateMVars, modify, Lean.collectFVars],[StateRefT', IO.RealWorld, Lean.CollectFVars.State, Lean.Meta.MetaM, Unit]]
[not_imp_of_and_not,[False],[Not]]
[Lean.Meta.SavedState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SavedState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.WF.elabWFRel,[Option.none, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Elab.Term.withDeclName, Lean.Elab.PreDefinition.declName, Bind.bind, liftM, Lean.Meta.getLevel, Lean.Elab.Term.withSynthesize, Lean.Elab.Term.elabTermEnsuringType, Option.some, Bool.true, Bool.false, Lean.Meta.instantiateMVars, Lean.Meta.getMVars, Functor.discard, Lean.Elab.Term.logUnassignedUsingErrorInfos, Pure.pure, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Std.HashSet.numBuckets,[Array.size, Subtype.val, Std.HashSetImp.buckets],[Nat]]
[Char.ne_of_val_ne,[absurd, Char.val_eq_of_eq],[Not, Eq]]
[Lean.Elab.Term.elabByTactic,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Bind.bind, liftM, Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.syntheticOpaque, Lean.Name.anonymous, Lean.MonadRef.getRef, Lean.Elab.Term.getDeclName?, Lean.Elab.Term.saveContext, Lean.Elab.Term.registerSyntheticMVar, Lean.Elab.Term.SyntheticMVarKind.tactic, Pure.pure, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format],[Lean.Elab.Term.TermElab]]
[AddCommSemigroup.noConfusionType,[],[]]
[Lean.Core.Context.openDecls,[],[List, Lean.OpenDecl]]
[Lean.Meta.instToFormatSimpLemma,[Std.ToFormat.mk, HAppend.hAppend, Std.Format.text],[Std.ToFormat, Lean.Meta.SimpLemma]]
[instHashableUInt32,[Hashable.mk, UInt32.toUInt64],[Hashable, UInt32]]
[Lean.Export.Alloc.mk.inj,[And.intro],[And, Eq]]
[List.subset_append_of_subset_left,[List.subset.trans, List.subset_append_left],[Subset.subset, HAppend.hAppend]]
[Lean.Lsp.LeanFileProgressParams.textDocument,[],[Lean.Lsp.VersionedTextDocumentIdentifier]]
[Lean.Meta.Match.Extension.Entry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.Extension.Entry.mk, HAdd.hAdd, OfNat.ofNat]]
[le_of_lt,[LE.le, And.left, le_not_le_of_lt],[LE.le]]
[String.decEq,[Decidable, Eq, dite, Decidable.isTrue, String.decEq.proof_1, Decidable.isFalse, String.decEq.proof_2],[Decidable, Eq]]
[Lean.Parser.Tactic.deltaInstance,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Elab.WF.TerminationHint.noConfusionType,[],[]]
[Lean.Meta.Instances.mk.inj,[And.intro],[And, Eq]]
[Lean.Syntax.Traverser.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Syntax.Traverser.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Syntax.Traverser.mk, And]]
[Lean.PrettyPrinter.Delaborator.mkDelabAttribute,[Lean.KeyedDeclsAttribute.init, Lean.KeyedDeclsAttribute.Def.mk, Lean.Name.mkStr, Lean.Name.anonymous],[IO, Lean.KeyedDeclsAttribute, Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.Meta.InstanceEntry.globalName?,[],[Option, Lean.Name]]
[Lean.Elab.Term.MutualClosure.LetRecClosure.toLift,[],[Lean.Elab.Term.LetRecToLift]]
[Lean.Syntax.instToFormatSyntax,[Std.ToFormat.mk, Lean.Syntax.formatStx, Option.none, Bool.false],[Std.ToFormat, Lean.Syntax]]
[Lean.Meta.orElse,[Bind.bind, Lean.MonadBacktrack.saveState, MonadExcept.tryCatch, Lean.Meta.SavedState.restore, Unit.unit],[Lean.Meta.MetaM]]
[System.instToStringFilePath,[ToString.mk, System.FilePath.toString],[ToString, System.FilePath]]
[Lean.Parser.node,[Lean.Parser.Parser.mk, Lean.Parser.nodeInfo, Lean.Parser.Parser.info, Lean.Parser.nodeFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Stream.next?,[],[Option, Prod]]
[forall_eq,[Iff.intro, rfl, Eq.symm],[Iff]]
[Lean.Parser.Command.where,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.IR.instAlphaEqvVarId,[Lean.IR.AlphaEqv.mk, Lean.IR.VarId.alphaEqv],[Lean.IR.AlphaEqv, Lean.IR.VarId]]
[Lean.Meta.Closure.mkLambda,[Lean.Meta.Closure.mkBinding, Bool.true],[Lean.Expr]]
[Lean.Lsp.instToJsonDocumentFilter,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Lsp.DocumentFilter.language?, Lean.Lsp.DocumentFilter.scheme?, Lean.Lsp.DocumentFilter.pattern?, List.nil],[Lean.ToJson, Lean.Lsp.DocumentFilter]]
[Lean.Widget.InfoPopup.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Widget.InfoPopup.mk, HAdd.hAdd, OfNat.ofNat]]
[UInt8.shiftLeft,[UInt8.mk, HShiftLeft.hShiftLeft, UInt8.val, UInt8.modn, OfNat.ofNat],[UInt8]]
[Lean.isSubobjectField?,[Option.none, Option, Lean.Name, Lean.getFieldInfo?, Lean.StructureFieldInfo.subobject?],[Option, Lean.Name]]
[List.forIn.loop,[Pure.pure, Bind.bind, PProd.fst],[]]
[Lean.IR.Checker.checkObjType,[Lean.IR.Checker.checkType, Lean.IR.IRType.isObj],[Lean.IR.Checker.M, Unit]]
[Std.RBNode.setBlack,[Std.RBNode.leaf, Std.RBNode, Std.RBNode.node, Std.Rbcolor.black],[Std.RBNode]]
[Lean.Elab.CompletionInfo.dot.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.CompletionInfo.dot, HAdd.hAdd, OfNat.ofNat]]
[EStateM.orElse,[EStateM.Result.ok, EStateM.Result, Unit.unit, EStateM.Backtrackable.restore],[EStateM]]
[Lean.Expr.getRevArgD,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, PProd.fst],[Lean.Expr]]
[Lean.instToMessageDataOption,[Lean.ToMessageData.mk, Unit.unit, Lean.MessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.ToMessageData, Option]]
[Lean.isMarkedBorrowed,[Option.isSome, Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous],[Bool]]
[Lean.Elab.Term.StructInst.DefaultFields.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.StructInst.DefaultFields.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.StructInst.DefaultFields.Context.mk, And]]
[Array.qpartition,[Array.qpartition.loop],[Prod, Nat, Array]]
[Lean.Parser.ParserExtension.Entry.parser.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.ParserExtension.Entry.parser, HAdd.hAdd, OfNat.ofNat]]
[Mathlib.Tactic.Lint.instInhabitedLintVerbosity,[Inhabited.mk, Mathlib.Tactic.Lint.LintVerbosity.low],[Inhabited, Mathlib.Tactic.Lint.LintVerbosity]]
[IO.Process.SpawnArgs.args,[],[Array, String]]
[Lean.IR.NormalizeIds.N,[ReaderT, Lean.IR.IndexRenaming, StateM, Nat],[]]
[Lean.Elab.Structural.mkEqns,[Lean.MonadWithOptions.withOptions, Lean.Option.set, Lean.Meta.tactic.hygienic, Bool.false, Bind.bind, Lean.Meta.withNewMCtxDepth, Lean.Meta.lambdaTelescope, Lean.Elab.Structural.EqnInfo.value, Lean.Meta.mkEq, Lean.mkAppN, Lean.mkConst, Lean.Elab.Structural.EqnInfo.declName, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Name.anonymous, StateRefT'.run, ReaderT.run, Lean.Expr.mvarId!, List.toArray, List.nil, Lean.Meta.MetaM, Array, Lean.Expr, Pure.pure, Lean.MonadEnv.getEnv, ForIn.forIn, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Array.getOp, PUnit.unit],[Lean.Meta.MetaM, Array, Lean.Name]]
[Lean.Expr.listLit?,[List.nil, Lean.Expr.listLit?.loop],[Option, Prod, Lean.Expr, List]]
[Sum.inl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Sum.inl, HAdd.hAdd, OfNat.ofNat]]
[Std.HashMapImp.mkIdx,[Subtype.mk, HMod.hMod, USize.modn_lt],[Subtype, LT.lt, USize.toNat]]
[Lean.Parser.Term.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.termParser.formatter, Lean.PrettyPrinter.Formatter.many1Unbox.formatter, Lean.Parser.commandParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.expandFun,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Term.expandFunBinders, Lean.MacroM, Lean.Syntax, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Macro.throwUnsupported, cond, Lean.Elab.Term.expandMatchAltsIntoMatch, Bool.false],[Lean.Macro]]
[stx_?,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[Lean.IR.Borrow.OwnedSet.insert,[Std.HashMap.insert, Unit.unit],[Lean.IR.Borrow.OwnedSet]]
[Lean.Parser.Term.prio.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.priorityParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.StructureFieldInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.StructureFieldInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.coprime_one_left_iff,[of_eq_true, Eq.trans, congr, congrArg, Iff, congrFun, Eq, Nat.gcd_one_left, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true],[Iff, Nat.coprime, OfNat.ofNat, Eq, Bool.true]]
[Lean.Elab.CompletionInfo.dot.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.CompletionInfo.dot, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.CompletionInfo.dot, And]]
[Lean.Elab.OpenDecl.State.openDecls,[],[List, Lean.OpenDecl]]
[Lean.Compiler.getImplementedBy,[Lean.ParametricAttribute.getParam, Lean.Compiler.implementedByAttr],[Option, Lean.Name]]
[Lean.PersistentLevelSet,[Std.PHashSet, Lean.Level],[]]
[Lean.Meta.injectionIntro.go,[Lean.Meta.MetaM, Lean.Meta.InjectionResult, Pure.pure, Lean.Meta.InjectionResult.subgoal, Bind.bind, Lean.Meta.intro, Lean.Meta.withMVarContext, Lean.Meta.getLocalDecl, Lean.Meta.whnf, Lean.LocalDecl.type, Unit.unit, Prod, Lean.FVarId, Lean.MVarId, Lean.Expr.heq?, Prod.mk, Lean.Meta.isDefEq, ite, Eq, Bool.true, Lean.Meta.mkEqOfHEq, Lean.mkFVar, Lean.Meta.mkEq, Lean.Meta.assert, Lean.LocalDecl.userName, Lean.Meta.tryClear, PUnit.unit, PProd.fst, Array.push, Lean.Meta.intro1, List.nil],[Lean.Meta.MetaM, Lean.Meta.InjectionResult]]
[instXorUSize,[Xor.mk, USize.xor],[Xor, USize]]
[Lean.isReducible,[Bind.bind, Lean.getReducibilityStatus, Unit.unit, Lean.ReducibilityStatus.semireducible, Lean.ReducibilityStatus.irreducible, Bool, Pure.pure, Bool.true, Bool.false],[Bool]]
[Array.toListLitAux.proof_1,[Nat.le_of_succ_le],[LE.le, Array.size]]
[Lean.ConstantInfo.hasValue,[Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Meta.SimpEntry.toUnfold.inj,[],[Eq]]
[Lean.ScopedEnvExtension.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ScopedEnvExtension.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.RecursorVal.isUnsafe,[],[Bool]]
[«term_⊕'_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.MetavarContext.instMonadMCtxMetavarContextST,[Lean.MonadMCtx.mk, MonadState.get, modify],[Lean.MonadMCtx, StateRefT', Lean.MetavarContext, ST]]
[Lean.ScopedEnvExtension.mk.inj,[And.intro],[And, Eq]]
[String.atEnd,[Bool, Decidable.decide, GE.ge, String.utf8ByteSize],[Bool]]
[Lean.Lsp.SymbolKind.null.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.null, OfNat.ofNat]]
[Lean.Lsp.DocumentSelector,[Array, Lean.Lsp.DocumentFilter],[]]
[Lean.Level.param.inj,[And.intro],[And, Eq]]
[Nat.sub_add_min_cancel,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HSub.hSub, min, Nat.sub_eq_sub_min, Nat.sub_add_cancel, min_le_left, rfl],[Eq, HAdd.hAdd, HSub.hSub, min]]
[Lean.Elab.Modifiers.isPartial,[Lean.Elab.Modifiers.mk, Lean.Elab.RecKind.nonrec, Lean.Elab.RecKind.default, Bool, Bool.true, Bool.false],[Bool]]
[Lean.PrettyPrinter.Formatter.strLitNoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.visitAtom, Lean.strLitKind],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Command.Scope.isNoncomputable,[],[Bool]]
[Lean.IR.MapVars.mapArgs,[Array.map, Lean.IR.MapVars.mapArg],[Array, Lean.IR.Arg]]
[Lean.CollectMVars.State.mk.inj,[And.intro],[And, Eq]]
[Lean.FVarId.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.FVarId.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Syntax.reprint.reprintLeaf,[Lean.SourceInfo.synthetic, Lean.SourceInfo.none, String, HAppend.hAppend, ToString.toString],[String]]
[Lean.HeadIndex.proj.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.HeadIndex.proj, HAdd.hAdd, OfNat.ofNat]]
[Nat.div_eq_of_eq_mul_right,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, Nat.mul_div_cancel_left, rfl],[Eq, HDiv.hDiv]]
[Array.concatMapM,[Array.foldlM, Bind.bind, Pure.pure, HAppend.hAppend, Array.empty, OfNat.ofNat, Array.size],[Array]]
[Lean.getPPAnalysisSkip,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false],[Bool]]
[Lean.PrettyPrinter.Formatter.State.mk.inj,[And.intro],[And, Eq]]
[Lean.Syntax.getKind,[Unit.unit, Lean.SyntaxNodeKind, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Name.mkSimple, Lean.identKind],[Lean.SyntaxNodeKind]]
[Lean.Expr.isForall,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[let_congr,[],[Eq]]
[Nat.lt_of_le_and_ne,[LT.lt, Nat.eq_or_lt_of_le, absurd],[LT.lt]]
[Lean.Xml.Parser.AttValue,[Bind.bind, HOrElse.hOrElse, Lean.Parsec.skipChar, Char.ofNat, SeqLeft.seqLeft, Lean.Parsec.many, Functor.map, Option.some, Lean.Parsec.satisfy, Decidable.decide, And, Ne, Lean.Xml.Parser.Reference, Pure.pure, Array.foldl, Option.none, String, String.push, OfNat.ofNat, Array.size],[Lean.Parsec, String]]
[Lean.Xml.Element.Element.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, Eq.refl, List.nil, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Xml.Element.Element, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.explicitUniv.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkStackTop.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.levelParser.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Command.copyDocString,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.unary],[Lean.ParserDescr]]
[instSemigroupFin,[Semigroup.mk, instSemigroupFin.proof_1],[Semigroup, Fin]]
[instInhabitedExceptT,[Inhabited.mk, MonadExcept.throw, arbitrary],[Inhabited, ExceptT]]
[not_or_intro,[False, absurd],[Not, Or]]
[Lean.Server.RequestError.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.CompletionOptions.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.CompletionOptions.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.CompletionOptions.mk, And]]
[UInt32.decLe,[Decidable, LE.le, inferInstanceAs],[Decidable, LE.le]]
[Lean.Meta.FVarSubst.find?,[Std.AssocList.find?, Lean.Meta.FVarSubst.map],[Option, Lean.Expr]]
[Lean.IR.Expr.ap.inj,[And.intro],[And, Eq]]
[Std.PersistentHashSet.mk.inj,[],[Eq]]
[Lean.Meta.SimpLemmas.toUnfold,[],[Std.PHashSet, Lean.Name]]
[Lean.Meta.DiscrTree.instLTKey,[LT.mk, Eq, Lean.Meta.DiscrTree.Key.lt, Bool.true],[LT, Lean.Meta.DiscrTree.Key]]
[List.insert_of_not_mem,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, if_neg, List, List.cons, eq_self],[Eq, List.insert, List.cons]]
[List.mem_singleton,[Iff.intro, List.eq_of_mem_singleton, Or.inl],[Iff, Mem.mem, List.cons, List.nil, Eq]]
[Lean.Meta.SynthInstance.tryAnswer,[Lean.Meta.withMCtx, Bind.bind, liftM, Lean.Meta.openAbstractMVarsResult, Lean.Meta.SynthInstance.Answer.result, Lean.Meta.SynthInstance.SynthM, Option, Lean.MetavarContext, Lean.Meta.isDefEq, ite, Eq, Bool.true, Lean.MonadMCtx.getMCtx, Pure.pure, Option.some, Option.none],[Lean.Meta.SynthInstance.SynthM, Option, Lean.MetavarContext]]
[Lean.LBool.noConfusion,[noConfusionEnum, Lean.LBool.toCtorIdx],[Lean.LBool.noConfusionType]]
[Numeric.ofNat,[],[]]
[Lean.Parser.Command.inferMod.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.Position.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.Position.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.Position.mk, And]]
[Lean.Elab.Command.StructView.ctor,[],[Lean.Elab.Command.StructCtorView]]
[Lean.Meta.RecursorInfo.instToStringRecursorInfo,[ToString.mk, HAppend.hAppend, ToString.toString, Lean.Meta.RecursorInfo.recursorName, Lean.Meta.RecursorInfo.typeName, Lean.Meta.RecursorInfo.univLevelPos, Lean.Meta.RecursorInfo.depElim, Lean.Meta.RecursorInfo.recursive, Lean.Meta.RecursorInfo.numArgs, Lean.Meta.RecursorInfo.numParams, Lean.Meta.RecursorInfo.numIndices, Lean.Meta.RecursorInfo.numMinors, Lean.Meta.RecursorInfo.majorPos, Lean.Meta.RecursorInfo.motivePos, Lean.Meta.RecursorInfo.paramsPos, Lean.Meta.RecursorInfo.indicesPos, Lean.Meta.RecursorInfo.produceMotive],[ToString, Lean.Meta.RecursorInfo]]
[Int.noConfusionType,[],[]]
[Task.get,[],[]]
[Lean.Position.lt,[Bool, Decidable.decide, LT.lt, Prod.mk],[Bool]]
[Lean.Elab.Term.addNamedArg,[ite, Eq, Array.any, BEq.beq, Lean.Elab.Term.NamedArg.name, OfNat.ofNat, Array.size, Bool.true, Bind.bind, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElabM, Array, Lean.Elab.Term.NamedArg]]
[Lean.Parser.ParserExtension.instInhabitedState,[Inhabited.mk, Lean.Parser.ParserExtension.State.mk, arbitrary],[Inhabited, Lean.Parser.ParserExtension.State]]
[Lean.Parser.Tactic.ringExp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.isExternC,[Option.none, Option.some, Lean.ExternAttrData.mk, List.nil, List.cons, Lean.ExternEntry.adhoc, Lean.ExternEntry.inline, Lean.ExternEntry.standard, Lean.Name.anonymous, dite, Eq, Lean.Name.str, Eq.symm, Lean.Name.num, Lean.ExternEntry.foreign, Bool, Lean.getExternAttrData, Bool.true, Bool.false],[Bool]]
[Lean.IR.Borrow.isOwned,[Bind.bind, Lean.IR.Borrow.getCurrFn, MonadState.get, Pure.pure, Lean.IR.Borrow.OwnedSet.contains, Lean.IR.Borrow.BorrowInfState.owned, Prod.mk, Lean.IR.VarId.idx],[Lean.IR.Borrow.M, Bool]]
[Lean.Meta.isProp,[Bind.bind, Lean.Meta.isPropQuick, Unit.unit, Lean.Meta.MetaM, Bool, Pure.pure, Bool.true, Bool.false, Lean.Meta.inferType, Lean.Meta.whnfD, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.instantiateLevelMVars, and, PProd.fst, PProd.snd],[Lean.Meta.MetaM, Bool]]
[Int.pow,[Unit.unit, Int, OfNat.ofNat, HMul.hMul, PProd.fst],[Int]]
[Lean.StructureFieldInfo.subobject?,[],[Option, Lean.Name]]
[Lean.IR.IsLive.visitJP,[Pure.pure, Lean.IR.HasIndex.visitJP],[Lean.IR.IsLive.M, Bool]]
[Lean.Elab.Command.instInhabitedCommandElabM,[Inhabited.mk, MonadExcept.throw, arbitrary],[Inhabited, Lean.Elab.Command.CommandElabM]]
[Lean.instFromJsonUInt64,[Lean.FromJson.mk, Bind.bind, Lean.bignumFromJson?, ite, GE.ge, UInt64.size, MonadExcept.throw, Pure.pure, PUnit.unit],[Lean.FromJson, UInt64]]
[Lean.Elab.Deriving.SizeOf.mkSizeOfHandler,[Bind.bind, Array.allM, Lean.isInductive, OfNat.ofNat, Array.size, ite, Eq, and, Decidable.decide, GT.gt, Bool.true, Lean.Elab.Command.liftTermElabM, Option.none, liftM, Lean.Meta.mkSizeOfInstances, Array.getOp, Pure.pure, Bool.false],[Lean.Elab.Command.CommandElabM, Bool]]
[Lean.Meta.IndPredBelow.mkCtorType.mkMotiveBinder,[Lean.Meta.forallTelescopeReducing, Lean.Expr.withApp, Bind.bind, Lean.Meta.mkForallFVars, Bool.false, Bool.true, Lean.Meta.IndPredBelow.mkCtorType.copyVarName, Lean.Expr.fvarId!, Lean.Meta.withLocalDecl, Lean.Expr.binderInfo],[Lean.Meta.MetaM]]
[Lean.LocalDecl.hasValue,[Bool, Bool.false, Bool.true],[Bool]]
[Lean.Meta.simp,[Bind.bind, Lean.MonadOptions.getOptions, Lean.profileitM, Lean.Exception, Unit.unit, Lean.Meta.MetaM, Lean.Meta.Simp.Result, Lean.Meta.Simp.main, Lean.Meta.Simp.DefaultMethods.methods, Lean.Meta.Simp.Methods.mk, Lean.Meta.Simp.preDefault, Lean.Meta.Simp.postDefault],[Lean.Meta.MetaM, Lean.Meta.Simp.Result]]
[Nat.pred_le_pred,[Nat.zero, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Nat.succ, LE.le, Nat.pred, Nat.le.refl, Nat.le_trans, Nat.le_succ],[LE.le, Nat.pred]]
[or_imp_distrib,[Iff.intro, And.intro, Or.inl, Or.inr],[Iff, And]]
[Lean.Parser.Term.scoped,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Classical.inhabited_of_exists,[Classical.inhabited_of_nonempty, Classical.inhabited_of_exists.proof_1],[Inhabited]]
[Lean.Meta.Match.Extension.State.noConfusionType,[],[]]
[Lean.Elab.Term.elabTerm,[Lean.withRef],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Lean.Elab.Modifiers.mk.inj,[And.intro],[And, Eq]]
[Lean.Widget.Lean.Widget.InteractiveGoal.instRpcEncodingInteractiveGoalRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Lean.Widget.InteractiveGoal.hyps, Lean.Widget.InteractiveGoal.type, Lean.Widget.InteractiveGoal.userName?, Pure.pure, Lean.Server.RpcEncoding.rpcDecode, Lean.Widget.InteractiveGoal.mk],[Lean.Server.RpcEncoding, Lean.Widget.InteractiveGoal]]
[Lean.Expr.updateConst!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateConst, Lean.Expr.const, Lean.Expr.updateConst!.proof_1, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[Lean.IR.FnBody.noConfusionType,[],[]]
[String.Iterator.setCurr,[String.Iterator, String.Iterator.mk, String.set],[String.Iterator]]
[Lean.Parser.orelseFnCore,[Unit.unit, Lean.Parser.ParserState, Lean.Parser.ParserState.errorMsg, ite, Eq, BEq.beq, Lean.Parser.ParserState.pos, Bool.true, Lean.Parser.mergeOrElseErrors, Lean.Parser.ParserState.restore],[Lean.Parser.ParserFn]]
[ExceptT.map,[ExceptT.mk, Bind.bind, Except, Pure.pure, Except.ok, Except.error],[ExceptT]]
[Lean.ReducibilityHints.regular.injEq,[Eq.propIntro, Eq.refl, Lean.ReducibilityHints.regular, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ReducibilityHints.regular]]
[Lean.Meta.UnificationConstraint.noConfusionType,[],[]]
[Array.swap!,[dite, LT.lt, Array.size, Array.swap, Fin.mk, panicWithPosWithDecl, OfNat.ofNat],[Array]]
[Lean.Parser.Term.implicitBinder.formatter,[Lean.ppGroup.formatter, Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.Parser.Term.binderType.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.setProtected,[Lean.MonadEnv.modifyEnv, Lean.addProtected],[Unit]]
[Lean.Attribute.Builtin.getIdent,[Bind.bind, Lean.Attribute.Builtin.getIdent?, Unit.unit, Lean.AttrM, Lean.Syntax, Pure.pure, Lean.throwErrorAt, Lean.ToMessageData.toMessageData],[Lean.AttrM, Lean.Syntax]]
[Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Parser.levelParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Parser.Parser]]
[setOf,[],[Set]]
[Lean.Parser.Command.in.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.withOpen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.commandParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.State.mk, And]]
[Lean.expandExplicitBinders,[Bind.bind, Lean.MonadRef.getRef, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.expandExplicitBindersAux, Array.all, Lean.Syntax.getArgs, OfNat.ofNat, Array.size, Lean.expandBrackedBindersAux, Lean.Macro.throwError],[Lean.MacroM, Lean.Syntax]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.analyzeConst,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM, Unit, MonadReader.read, ite, Eq, and, not, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.knowsLevel, List.isEmpty, Bool.true, Lean.MonadOptions.getOptions, Lean.getPPAnalyzeOmitMax, List.any, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.containsBadMax, Pure.pure, PUnit.unit, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.annotateBool, Lean.Name.mkStr, Lean.Name.anonymous, panicWithPosWithDecl, OfNat.ofNat],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM, Unit]]
[Mathlib.Tactic.Lint.Linter.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Mathlib.Tactic.Lint.Linter.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.DiagnosticWith.tags?,[],[Option, Array, Lean.Lsp.DiagnosticTag]]
[Lean.Elab.getResetInfoTrees,[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, Lean.Elab.MonadInfoTree.modifyInfoState, Lean.Elab.InfoState.mk, Lean.Elab.InfoState.enabled, Lean.Elab.InfoState.assignment, Lean.Elab.InfoState.trees, Std.PersistentArray.mk, Pure.pure],[Std.PersistentArray, Lean.Elab.InfoTree]]
[Lean.LBool.noConfusionType,[noConfusionTypeEnum, Lean.LBool.toCtorIdx],[]]
[EStateM.set,[EStateM.Result.ok, PUnit.unit],[EStateM, PUnit]]
[Lean.Parser.ensureUnaryParserAlias,[Functor.discard, Lean.Parser.getUnaryAlias, Lean.Parser.parserAliasesRef],[IO, Unit]]
[StateT.instMonadExceptOfStateT,[MonadExceptOf.mk, Function.comp, StateT.lift, throwThe, tryCatchThe],[MonadExceptOf, StateT]]
[AddMonoid.nsmul_zero',[],[Eq, AddMonoid.nsmul, OfNat.ofNat]]
[Lean.Parser.Term.falseVal.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.ElabAppArgs.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.ElabAppArgs.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.ElabAppArgs.State.mk, And]]
[Nat.le_succ_of_le,[Nat.le_trans, Nat.le_succ],[LE.le, Nat.succ]]
[Lean.Meta.Closure.mkNewLevelParam,[Bind.bind, MonadState.get, modify, Lean.Meta.Closure.State.mk, Lean.Meta.Closure.State.visitedLevel, Lean.Meta.Closure.State.visitedExpr, Array.push, Lean.Meta.Closure.State.levelParams, HAdd.hAdd, Lean.Meta.Closure.State.nextLevelIdx, OfNat.ofNat, Lean.Meta.Closure.State.levelArgs, Lean.Meta.Closure.State.newLocalDecls, Lean.Meta.Closure.State.newLocalDeclsForMVars, Lean.Meta.Closure.State.newLetDecls, Lean.Meta.Closure.State.nextExprIdx, Lean.Meta.Closure.State.exprMVarArgs, Lean.Meta.Closure.State.exprFVarArgs, Lean.Meta.Closure.State.toProcess, Pure.pure, Lean.mkLevelParam],[Lean.Meta.Closure.ClosureM, Lean.Level]]
[Lean.Parser.ParserExtension.Entry.token.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.ParserExtension.Entry.token, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.ParserExtension.Entry.token]]
[Lean.AttributeExtensionState.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.ParserExtension.Entry.category.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserExtension.Entry.category, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.ParserExtension.Entry.category, And]]
[Lean.PrettyPrinter.Delaborator.Context.noConfusionType,[],[]]
[Lean.Elab.Command.getScope,[Bind.bind, MonadState.get, Pure.pure, List.head!, Lean.Elab.Command.State.scopes],[Lean.Elab.Command.CommandElabM, Lean.Elab.Command.Scope]]
[Lean.Rat.num,[],[Int]]
[Lean.Lsp.WorkDoneProgressBegin.mk.inj,[And.intro],[And, Eq]]
[Fin.div.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, HDiv.hDiv]]
[Lean.ScopedEnvExtension.addEntryFn,[Lean.ScopedEnvExtension.StateStack, Lean.ScopedEnvExtension.StateStack.mk, List.map, Lean.ScopedEnvExtension.State.mk, Lean.ScopedEnvExtension.Descr.addEntry, Lean.ScopedEnvExtension.State.state, Lean.ScopedEnvExtension.State.activeScopes, List.cons, Lean.ScopedEnvExtension.Entry.global, Lean.ScopedEnvExtension.Descr.toOLeanEntry, Lean.ScopedEnvExtension.ScopedEntries.insert, Lean.ScopedEnvExtension.Entry.scoped],[Lean.ScopedEnvExtension.StateStack]]
[ReaderT.run,[],[]]
[Lean.NameGenerator.noConfusionType,[],[]]
[instBEqFloat,[BEq.mk, Float.beq],[BEq, Float]]
[Lean.Meta.isReadOnlyOrSyntheticOpaqueExprMVar,[Bind.bind, Lean.Meta.getMVarDecl, Lean.MetavarKind.natural, Lean.MetavarKind.synthetic, Unit.unit, Lean.Meta.MetaM, Bool, Lean.MetavarDecl.kind, Lean.Meta.getConfig, Pure.pure, not, Lean.Meta.Config.assignSyntheticOpaque, Lean.MonadMCtx.getMCtx, bne, Lean.MetavarDecl.depth, Lean.MetavarContext.depth],[Lean.Meta.MetaM, Bool]]
[Lean.Parser.atomic,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.atomicFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.ReducibilityHints.noConfusionType,[],[]]
[Lean.Lsp.ServerInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.ServerInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.ServerInfo.mk, And]]
[«term_>>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Classical.inhabited_of_exists.proof_1,[Exists.elim, Nonempty.intro],[Nonempty]]
[Lean.Meta.Simp.SimpLetCase.dep.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.Simp.SimpLetCase.dep, OfNat.ofNat]]
[Iff.mp,[],[]]
[Lean.Elab.Term.StructInst.ExplicitSourceInfo.structName,[],[Lean.Name]]
[Not.imp,[mt],[Not]]
[Lean.Meta.mkEqFalse',[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[StateT.orElse,[HOrElse.hOrElse, Unit.unit],[StateT]]
[Lean.Elab.Tactic.commandDeclare_config_elab____,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Lsp.SymbolKind.constant.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.constant, OfNat.ofNat]]
[exists_prop_decidable.proof_1,[Iff.intro, Exists.intro],[Iff, Exists]]
[Nat.pow_le_pow_of_le_left,[Unit.unit, LE.le, HPow.hPow, Nat.le_refl, OfNat.ofNat, Nat.mul_le_mul, PProd.fst],[LE.le, HPow.hPow]]
[Lean.Elab.Term.resetMessageLog,[Lean.Elab.Term.setMessageLog, Lean.MessageLog.mk],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Expr.head,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.proj, Lean.Expr, PProd.fst, PProd.snd],[Lean.Expr]]
[Lean.Parser.Command.terminationHint1,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.Compiler.foldNatDiv,[Lean.Compiler.foldNatBinOp, Div.div],[Option, Lean.Expr]]
[Lean.withoutModifyingState,[Bind.bind, Lean.MonadBacktrack.saveState, tryFinally, Lean.MonadBacktrack.restoreState],[]]
[List.hasDecEq.proof_4,[rfl],[Eq, List.cons]]
[List.lookup,[Option, Option.none, Unit.unit, BEq.beq, Option.some, PProd.fst],[Option]]
[Lean.Server.Watchdog.runClientTask,[Bind.bind, MonadReader.read, liftM, IO.asTask, Task.Priority.default, Pure.pure],[Lean.Server.Watchdog.ServerM, Task, Lean.Server.Watchdog.ServerEvent]]
[Lean.Elab.Term.Do.ToTerm.M,[ReaderT, Lean.Elab.Term.Do.ToTerm.Context, Lean.MacroM],[]]
[System.FilePath.instHDivFilePathStringFilePath,[HDiv.mk, System.FilePath.join, System.FilePath.mk],[HDiv, System.FilePath, String]]
[Lean.MacroScopesView.imported,[],[Lean.Name]]
[IO.FS.FileType.other.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.FileType.other, OfNat.ofNat]]
[Lean.Unhygienic.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Unhygienic.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Unhygienic.Context.mk, And]]
[Lean.OptionDecl.descr,[],[String]]
[Lean.Parser.withAntiquotSuffixSplice,[Lean.Parser.Parser.mk, Lean.Parser.andthenInfo, Lean.Parser.Parser.info, Lean.Parser.withAntiquotSuffixSpliceFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.PrettyPrinter.Delaborator.getPPOption,[Bind.bind, Lean.PrettyPrinter.Delaborator.getOptionsAtCurrPos, Pure.pure],[Lean.PrettyPrinter.Delaborator.DelabM, Bool]]
[Nat.coprime.pow_left,[Nat.coprime_one_left],[Nat.coprime, HPow.hPow]]
[Lean.Elab.Command.CtorView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.CtorView.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Command.CtorView.mk, And]]
[Lean.Xml.Content.below,[PProd, PUnit],[]]
[Lean.Elab.isFreshInstanceName,[Lean.Name.anonymous, Lean.Name.num, Bool, String.isPrefixOf, Bool.false],[Bool]]
[PSigma.revLexAccessible,[PSigma.revLexAccessible.proof_1],[Acc, PSigma.RevLex, PSigma.mk]]
[Lean.Lsp.instFileSourcePlainTermGoalParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.PlainTermGoalParams.toTextDocumentPositionParams],[Lean.Lsp.FileSource, Lean.Lsp.PlainTermGoalParams]]
[dite_true,[rfl],[Eq, dite, True, True.intro]]
[Lean.Meta.UnificationHintEntry.noConfusionType,[],[]]
[Lean.PPContext.noConfusionType,[],[]]
[IO.Error.timeExpired.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.timeExpired, HAdd.hAdd, OfNat.ofNat]]
[left_identity,[Eq],[]]
[Lean.Parser.ensureConstantParserAlias,[Functor.discard, Lean.Parser.getConstAlias, Lean.Parser.parserAliasesRef],[IO, Unit]]
[Lean.Meta.RecursorUnivLevelPos.majorType.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.RecursorUnivLevelPos.majorType, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.open,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.openDecl, Lean.Parser.withOpenDecl, Lean.Parser.Tactic.tacticSeq],[Lean.Parser.Parser]]
[Tactic.Ring.State.numAtoms,[],[Nat]]
[Lean.instInhabitedDefinitionVal,[Inhabited.mk, Lean.DefinitionVal.mk, arbitrary],[Inhabited, Lean.DefinitionVal]]
[Lean.Meta.isDefEqGuarded,[Lean.Meta.isExprDefEqGuarded],[Lean.Meta.MetaM, Bool]]
[Lean.IR.LocalContextEntry.param.inj,[],[Eq]]
[Sum.inr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Sum.inr, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.withLCtx,[Lean.Meta.mapMetaM, Bind.bind, Lean.Meta.getLocalInstances, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth, ite, Eq, BEq.beq, Bool.true, Lean.Meta.resettingSynthInstanceCache],[]]
[prioDefault,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Elab.Term.Do.Alt.vars,[],[Array, Lean.Name]]
[Lean.IR.mkVarArg,[Lean.IR.Arg.var],[Lean.IR.Arg]]
[Lean.Lsp.SemanticTokenType.property.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SemanticTokenType.property, OfNat.ofNat]]
[Lean.Meta.PostponedEntry.ref,[],[Lean.Syntax]]
[«term_&&_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Elab.withInfoHole,[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, ite, Eq, Lean.Elab.InfoState.enabled, Bool.true, Lean.Elab.getResetInfoTrees, Functor.map, Prod.fst, MonadFinally.tryFinally', Lean.Elab.MonadInfoTree.modifyInfoState, GT.gt, Std.PersistentArray.size, Lean.Elab.InfoState.trees, OfNat.ofNat, Lean.Elab.InfoState.mk, Std.PersistentHashMap.insert, Lean.Elab.InfoState.assignment, Std.PersistentArray.getOp, HSub.hSub],[]]
[Lean.Expr.ReplaceLevelImpl.replaceUnsafeM,[Lean.Expr.ReplaceLevelImpl.replaceUnsafeM.visit],[Lean.Expr.ReplaceLevelImpl.ReplaceM, Lean.Expr]]
[Lean.Parser.Tactic.match.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.generalizingParam.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.Term.matchDiscr.parenthesizer, Bool.false, Lean.Parser.Term.optType.parenthesizer, Lean.Parser.Tactic.matchAlts.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[instMonadLiftT_1,[MonadLiftT.mk],[MonadLiftT]]
[Lean.Parser.ParserState.hasError,[bne, Lean.Parser.ParserState.errorMsg, Option.none],[Bool]]
[Lean.Parser.Term.optType.formatter,[Lean.Parser.optional.formatter, Lean.Parser.Term.typeSpec.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.StructInst.FieldLHS.fieldIndex.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.StructInst.FieldLHS.fieldIndex, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.StructInst.FieldLHS.fieldIndex, And]]
[Lean.IR.FnBody.setTag.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.setTag, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.FnBody.setTag, And]]
[and_implies,[And.imp],[And]]
[Std.mkHashSetImp,[Std.HashSetImp.mk, OfNat.ofNat, Subtype.mk, Array.mkArray, List.nil, Std.mkHashSetImp.proof_1],[Std.HashSetImp]]
[Lean.Elab.Info.contains,[Option.any, String.Range.contains, Lean.Elab.Info.range?],[Bool]]
[instReprId,[inferInstanceAs, Repr],[Repr, id]]
[Lean.IR.Expr.reset.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Expr.reset, HAdd.hAdd, OfNat.ofNat]]
[Nat.instOrOpNat,[OrOp.mk, Nat.lor],[OrOp, Nat]]
[Lean.Server.FileWorker.RpcSession.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.FileWorker.RpcSession.mk, HAdd.hAdd, OfNat.ofNat]]
[UInt16.mk_val_eq,[Eq, UInt16.mk, UInt16.val, rfl],[Eq, UInt16.mk, UInt16.val]]
[Lean.Parser.Trie.find?,[OfNat.ofNat, Lean.Parser.Trie.find?.loop],[Option]]
[Lean.Parser.Term.doForDecl.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withForbidden.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Command.declSig.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.many.formatter, Lean.ppSpace.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.simpleBinderWithoutType.formatter, Lean.Parser.Term.bracketedBinder.formatter, Bool.false, Lean.Parser.Term.typeSpec.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.mkSaveInfoAnnotation,[ite, Eq, Lean.Expr.isMVar, Bool.true, Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Expr]]
[LawfulMonad.bind_pure_comp,[],[Eq, Bind.bind, Pure.pure, Functor.map]]
[Lean.Server.WithRpcRef.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Server.WithRpcRef.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.WithRpcRef.mk]]
[Nat.mul,[Nat, OfNat.ofNat, Nat.add, PProd.fst],[Nat]]
[Lean.Parser.Tactic.ghostSimp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg],[Lean.ParserDescr]]
[Std.Format.ibelow,[True, And],[]]
[Lean.Expr.findLevelMVar?,[Lean.FindLevelMVar.main, Option.none],[Option, Lean.MVarId]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.replaceLPsWithVars,[ite, Eq, not, Lean.Expr.hasLevelParam, Bool.true, Pure.pure, Bind.bind, PUnit.unit],[Lean.Meta.MetaM, Lean.Expr]]
[List.ne_nil_of_mem,[False, Eq.mp, Eq.refl, Mem.mem],[Ne, List.nil]]
[Lean.LocalContext.mkLetDecl,[Lean.LocalContext, Lean.LocalContext.mk, Std.PersistentHashMap.insert, Std.PersistentArray.push, Option.some],[Lean.LocalContext]]
[Lean.Meta.DiscrTree.root,[],[Std.PersistentHashMap, Lean.Meta.DiscrTree.Key, Lean.Meta.DiscrTree.Trie]]
[Lean.Expr.iff?,[Lean.Expr.app2?, Lean.Name.mkStr, Lean.Name.anonymous],[Option, Prod, Lean.Expr]]
[Lean.InductiveVal.mk.inj,[And.intro],[And, Eq]]
[Function.uncurry_bicompl,[funext, Eq, Function.uncurry, Function.bicompl, Function.comp, Prod.map, rfl],[Eq, Function.uncurry, Function.bicompl, Function.comp, Prod.map]]
[Lean.Lsp.DidCloseTextDocumentParams.textDocument,[],[Lean.Lsp.TextDocumentIdentifier]]
[Lean.MonadRecDepth.withRecDepth,[],[]]
[Nat.mul_dvd_mul_right,[Nat.mul_dvd_mul, Nat.dvd_refl],[Dvd.dvd, HMul.hMul]]
[Lean.IR.Param.mk.inj,[And.intro],[And, Eq]]
[Lean.LocalContext.lastDecl,[Std.PersistentArray.get!, Lean.LocalContext.decls, HSub.hSub, Std.PersistentArray.size, OfNat.ofNat],[Option, Lean.LocalDecl]]
[CommSemigroup.noConfusionType,[],[]]
[Iff.subst,[Eq.subst, propext],[]]
[Mathlib.Tactic.rename',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Meta.addInstanceEntry,[Unit.unit, Lean.Meta.Instances, Lean.Meta.InstanceEntry.globalName?, Lean.Meta.Instances.mk, Lean.Meta.DiscrTree.insertCore, Lean.Meta.Instances.discrTree, Lean.Meta.InstanceEntry.keys, Std.PersistentHashSet.insert, Lean.Meta.Instances.instanceNames, Lean.Meta.Instances.erased],[Lean.Meta.Instances]]
[LawfulApplicative.seqLeft_eq,[],[Eq, SeqLeft.seqLeft, Seq.seq, Functor.map, Function.const]]
[Char.isWhitespace,[or, Decidable.decide, Eq, Char.ofNat],[Bool]]
[Set.instFunctorSet,[Functor.mk, Set.image],[Functor, Set]]
[Lean.Parser.Term.binderType.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.ite, Eq, Bool.true, Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.nullKind, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Lean.Parser.optional.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.mod,[WellFounded.fix, Nat.mod.proof_1, dite, And, LT.lt, OfNat.ofNat, LE.le, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le],[Nat]]
[Lean.PrettyPrinter.parenthesizeCommand,[Lean.PrettyPrinter.parenthesize, Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat],[Lean.Core.CoreM, Lean.Syntax]]
[Lean.IR.FnBody.del.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.FnBody.del, HAdd.hAdd, OfNat.ofNat]]
[Lean.Export.OfState.get,[],[Lean.Export.Alloc]]
[List.pairwise.brecOn,[List.pairwise.below.nil, List.pairwise.below.cons],[]]
[and_congr_left,[Iff.trans, And.comm, and_congr_right],[Iff, And]]
[instLEUSize,[LE.mk, USize.le],[LE, USize]]
[Lean.Json.getObjVal?,[Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Lean.Json.arr, Except, String, Lean.Json, Unit.unit, Std.RBNode.find, Ord.compare, Pure.pure, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Except, String, Lean.Json]]
[Lean.Elab.Tactic.Simp.DischargeWrapper.default.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Tactic.Simp.DischargeWrapper.default, OfNat.ofNat]]
[Lean.Elab.Command.ElabHeaderResult.type,[],[Lean.Expr]]
[List.forall_mem_cons,[List.ball_cons],[Iff, And]]
[Std.HashSetImp.expand,[],[Std.HashSetImp]]
[Lean.Meta.Match.Extension.Entry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.Extension.Entry.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.Extension.Entry.mk, And]]
[Substring.take,[Substring.mk, Substring, HAdd.hAdd, Substring.nextn, OfNat.ofNat],[Substring]]
[List.erase_cons_tail,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.erase_cons, if_neg, List, List.cons, List.erase, eq_self],[Eq, List.erase, List.cons]]
[Lean.Expr.Data.hash,[UInt32.toUInt64, UInt64.toUInt32],[UInt64]]
[Lean.Syntax.node.inj,[And.intro],[And, Eq]]
[Applicative.toSeqRight,[],[SeqRight]]
[Lean.Parser.Tactic.intervalCases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.IR.Checker.checkPartialApp,[Bind.bind, Lean.IR.Checker.getDecl, ite, LT.lt, Array.size, Lean.IR.Decl.params, Pure.pure, PUnit.unit, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.IR.Checker.M, Unit]]
[«binderTerm∈_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[List.allM,[Unit.unit, Bool, Pure.pure, Bool.true, Bind.bind, PProd.fst, Bool.false],[Bool]]
[Lean.Elab.Deriving.FromToJson.mkToJsonInstanceHandler.mkAlts,[Array.mapM, Bind.bind, Lean.getConstInfoCtor, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, ForIn.forIn, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, PUnit.unit, ForInStep.yield, MProd.mk, liftM, Lean.Meta.getLocalDecl, Lean.Expr.fvarId!, ite, Eq, not, Lean.Name.hasMacroScopes, Lean.LocalDecl.userName, Bool.true, Lean.Elab.Term.TermElabM, Lean.Syntax, Lean.mkIdent, Lean.ConstantVal.name, Array.append, BEq.beq, Array.size, Option.some, Option.none, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.InductiveVal.ctors],[Lean.Elab.Term.TermElabM, Array, Lean.Syntax]]
[Lean.Parser.Term.precheckedQuot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.quot],[Lean.Parser.Parser]]
[bool,[Unit.unit, ToBool.toBool],[]]
[Lean.Meta.Match.MatchEqnsExtState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.MatchEqnsExtState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Expr.bindingInfo!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.BinderInfo, Lean.Expr.Data.binderInfo, panicWithPosWithDecl, OfNat.ofNat],[Lean.BinderInfo]]
[Int.coe_nat_sub,[Int.ofNat_sub],[Eq, Int.ofNat, HSub.hSub]]
[System.instCoeStringFilePath,[Coe.mk, System.FilePath.mk],[Coe, String, System.FilePath]]
[Lean.MessageData.ofName.inj,[],[Eq]]
[Lean.isNumericSubscript,[and, Decidable.decide, LE.le, OfNat.ofNat, Char.val],[Bool]]
[Lean.IR.UnreachableBranches.M,[ReaderT, Lean.IR.UnreachableBranches.InterpContext, StateM, Lean.IR.UnreachableBranches.InterpState],[]]
[Lean.Parser.Tactic.subtypeInstance,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Meta.AbstractMVarsResult.noConfusionType,[],[]]
[cast_heq,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, HEq, cast],[HEq, cast]]
[Classical.typeDecidableEq,[inferInstance],[DecidableEq]]
[Lean.ConstantInfo.quotInfo.injEq,[Eq.propIntro, Eq.refl, Lean.ConstantInfo.quotInfo, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ConstantInfo.quotInfo]]
[instToStringPUnit,[ToString.mk],[ToString, PUnit]]
[Lean.Parser.Tactic.squeezeSimpa?!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Parser.Term.cdot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Nat.mul_le_mul_of_nonneg_left,[Decidable.em, LE.le, Eq.mpr, congrArg, HMul.hMul, Nat.le_antisymm, Nat.le_refl, Eq.symm, OfNat.ofNat, of_eq_true, Eq.trans, congr, congrFun, Nat.zero_le, Nat.zero_mul, eq_true_of_decide, Eq.refl, Bool.true, Nat.le_of_lt, Nat.mul_lt_mul_of_pos_left, Iff.mp, not_le],[LE.le, HMul.hMul]]
[ExceptT.run_lift,[rfl],[Eq, ExceptT.run, ExceptT.lift, Functor.map, Except.ok]]
[Lean.IR.EmitC.getDecl,[Bind.bind, Lean.IR.EmitC.getEnv, Unit.unit, Lean.IR.EmitC.M, Lean.IR.Decl, Lean.IR.findEnvDecl, Pure.pure, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.IR.EmitC.M, Lean.IR.Decl]]
[Lean.Lsp.instFileSourceTextDocumentItem,[Lean.Lsp.FileSource.mk, Lean.Lsp.TextDocumentItem.uri],[Lean.Lsp.FileSource, Lean.Lsp.TextDocumentItem]]
[Lean.Elab.Term.ToParserDescrContext.noConfusionType,[],[]]
[Lean.Parser.TokenTable,[Lean.Parser.Trie, Lean.Parser.Token],[]]
[Lean.Xml.Parser.EmptyElemTag,[SeqRight.seqRight, Lean.Parsec.skipString, Pure.pure, List.toArray, List.nil],[Lean.Parsec, Lean.Xml.Element]]
[Lean.Expr.forEach,[Lean.Expr.forEach', Bind.bind, Pure.pure, Bool.true],[Unit]]
[ReaderT.run_seq,[Eq.mpr, Eq.refl, Eq, ReaderT.run, Seq.seq, seq_eq_bind, rfl],[Eq, ReaderT.run, Seq.seq]]
[Lean.ScopedEnvExtension.getState,[List.nil, Lean.ScopedEnvExtension.StateStack.stateStack, Lean.PersistentEnvExtension.getState, Lean.ScopedEnvExtension.ext, Lean.ScopedEnvExtension.State.state, panicWithPosWithDecl, OfNat.ofNat],[]]
[List.drop,[List, List.nil, PProd.fst],[List]]
[fixCore4,[bfix4, USize.size],[]]
[Lean.Parser.Module.prelude.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.IR.IsLive.visitArgs,[Pure.pure, Lean.IR.HasIndex.visitArgs],[Lean.IR.IsLive.M, Bool]]
[instOfScientificFloat,[OfScientific.mk, ite, Eq, Bool.true, Float.ofBinaryScientific, HSub.hSub, HMul.hMul, Neg.neg, OfNat.ofNat, Int.ofNat, HPow.hPow],[OfScientific, Float]]
[Lean.Elab.Term.Do.Code.decl.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.nlinarith!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy],[Lean.ParserDescr]]
[Lean.Widget.Lean.Widget.InfoWithCtx.instRpcEncodingWithRpcRefInfoWithCtxRpcRef,[Lean.Server.RpcEncoding.mk],[Lean.Server.RpcEncoding, Lean.Server.WithRpcRef, Lean.Widget.InfoWithCtx, Lean.Lsp.RpcRef]]
[List.disjoint_right,[List.disjoint_comm],[Iff, List.disjoint, Not, Mem.mem]]
[Lean.Elab.DerivingClassView.mk.inj,[And.intro],[And, Eq]]
[Lean.MessageData.withNamingContext.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MessageData.withNamingContext, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MessageData.withNamingContext, And]]
[Lean.Meta.checkNotAssigned,[Bind.bind, Lean.Meta.isExprMVarAssigned, ite, Eq, Bool.true, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Unit]]
[Lean.Meta.FindOptions.noConfusionType,[],[]]
[Lean.JsonRpc.Response.result,[],[]]
[Lean.Elab.Command.expandMacroArg.mkSplicePat,[Lean.mkNullNode, List.toArray, List.cons, Lean.Syntax.mkAntiquotSuffixSpliceNode, Lean.Syntax.mkAntiquotNode, OfNat.ofNat, Option.none, Lean.Name.anonymous, List.nil],[Lean.Syntax]]
[Lean.IR.CtorFieldInfo.format,[Unit.unit, Std.Format, Std.Format.text, HAppend.hAppend, Std.ToFormat.format],[Std.Format]]
[ByteSlice.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, ByteSlice.mk, HAdd.hAdd, OfNat.ofNat]]
[IO.FS.Stream.writeJson,[Bind.bind, IO.FS.Stream.putStr, Lean.Json.compress, IO.FS.Stream.flush],[IO, Unit]]
[Lean.Parser.registerParserAttributeHook,[ST.Ref.modify, Lean.Parser.parserAttributeHooks, List.cons],[IO, Unit]]
[Lean.Parser.Tactic.decide.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.nonReservedSymbol.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.DiagnosticTag.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Parser.Tactic.rcasesPat.ignore,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[String.capitalize,[String.set, OfNat.ofNat, Char.toUpper, String.get],[String]]
[instToStringFloat,[ToString.mk, Float.toString],[ToString, Float]]
[Lean.Elab.Term.Do.CodeBlock.noConfusionType,[],[]]
[Lean.SMap.fromHashMap,[Lean.SMap.mk],[Lean.SMap]]
[Lean.Parser.Tactic.matchRhs.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.hole.formatter, Lean.Parser.Term.syntheticHole.formatter, Lean.Parser.Tactic.tacticSeq.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.MessageLog.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MessageLog.mk, HAdd.hAdd, OfNat.ofNat]]
[UInt8.instAddCommSemigroupUInt8,[AddCommSemigroup.mk, UInt8.instAddCommSemigroupUInt8.proof_1],[AddCommSemigroup, UInt8]]
[Lean.Elab.Term.Do.mkSimpleJmp,[Bind.bind, Lean.Elab.Term.Do.addFreshJP, Array.map, Prod.mk, Bool.true, ite, Eq, Array.isEmpty, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil, Lean.Elab.Term.Do.Code.jmp, List.toArray, Lean.mkIdentFrom],[StateRefT', IO.RealWorld, Array, Lean.Elab.Term.Do.JPDecl, Lean.Elab.Term.TermElabM, Lean.Elab.Term.Do.Code]]
[ExceptCpsT.instInhabitedExceptCpsT,[Inhabited.mk, arbitrary],[Inhabited, ExceptCpsT]]
[Lean.Meta.Match.MatcherResult.noConfusionType,[],[]]
[Lean.Meta.mkSizeOfSpecLemmaName,[HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Name]]
[Lean.Lsp.LineRange.noConfusionType,[],[]]
[Lean.findModuleOf?,[Bind.bind, Functor.discard, Lean.getConstInfo, Lean.MonadEnv.getEnv, Unit.unit, Option, Lean.Name, Lean.Environment.getModuleIdxFor?, Pure.pure, Option.none, Option.some, Array.getOp, Lean.Environment.allImportedModuleNames],[Option, Lean.Name]]
[Lean.Elab.Term.Do.ToTerm.Kind.regular.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.ToTerm.Kind.regular, OfNat.ofNat]]
[Lean.Parser.Command.nonrec.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Expr.ReplaceImpl.State.mk.inj,[And.intro],[And, Eq]]
[Mathlib.TermUnsafe.mkAuxName,[Lean.MonadQuotation.withFreshMacroScope, Bind.bind, Lean.Elab.Term.getDeclName?, Lean.MonadQuotation.getMainModule, Lean.MonadQuotation.getCurrMacroScope, Pure.pure, Lean.addMacroScope],[Lean.Elab.Term.TermElabM, Lean.Name]]
[Tactic.Ring.tacticRing,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Expr.ReplaceImpl.State.noConfusionType,[],[]]
[imp_not_self,[Iff.intro],[Iff, Not]]
[Int.ofNat_one,[rfl],[Eq, Int.ofNat, OfNat.ofNat]]
[Int.mul,[Int, Int.ofNat, HMul.hMul, Int.negOfNat, Nat.succ],[Int]]
[Lean.Parser.Term.termUnless.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.withForbidden.formatter, Lean.Parser.termParser.formatter, Lean.Parser.Term.doSeq.formatter],[Lean.PrettyPrinter.Formatter]]
[Nat.mod_eq_zero_of_dvd,[Exists.elim, Eq.mpr, Eq.refl, Eq, HMod.hMod, OfNat.ofNat, HMul.hMul, Nat.mul_mod_right, rfl],[Eq, HMod.hMod, OfNat.ofNat]]
[Lean.Elab.Info.fmtHover?,[Lean.Elab.ContextInfo.runMetaM, Lean.Elab.Info.lctx, Bind.bind, MonadExcept.tryCatch, Option.none, Lean.Meta.MetaM, MProd, PUnit, Array, Std.Format, Pure.pure, PUnit.unit, MProd.mk, Unit.unit, MProd.fst, Lean.Elab.Info.docString?, Option, Lean.Elab.Info.fmtHover?.fmtTerm?, Lean.Elab.Info.fmtHover?.isAtomicFormat],[IO, Option, Std.Format]]
[Int.zero_add,[Int.add_zero, Int.add_comm, OfNat.ofNat],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.withMVarContext,[Lean.Meta.mapMetaM, Bind.bind, Lean.Meta.getMVarDecl, Lean.Meta.getLocalInstances, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth, ite, Eq, BEq.beq, Bool.true, Lean.Meta.resettingSynthInstanceCache, Lean.MetavarDecl.lctx, Lean.MetavarDecl.localInstances],[]]
[Lean.Server.Completion.HoverInfo.after.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Server.Completion.HoverInfo.after, OfNat.ofNat]]
[GroupWithZero.mul_zero,[],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Widget.Lean.Widget.InfoPopup.instFromJsonRpcEncodingPacket,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, Lean.Widget.TaggedText, String, Pure.pure],[Lean.FromJson]]
[Lean.Parser.Term.funBinder.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.funStrictImplicitBinder.formatter, Lean.Parser.Term.funImplicitBinder.formatter, Lean.Parser.Term.instBinder.formatter, Lean.Parser.Term.funSimpleBinder.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[Subarray.foldrM,[Array.foldrM, Subarray.as, Subarray.stop, Subarray.start],[]]
[Lean.Lsp.instToJsonCompletionParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.CompletionParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position],[Lean.ToJson, Lean.Lsp.CompletionParams]]
[Lean.OpaqueVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.OpaqueVal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.OpaqueVal.mk, And]]
[Lean.Meta.SimpLemma.getName,[Unit.unit, Lean.Name, Lean.Meta.SimpLemma.name?, Lean.Name.mkSimple],[Lean.Name]]
[Lean.Parser.leadingNode.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.PrettyPrinter.Formatter.node.formatter, Lean.PrettyPrinter.Formatter.setLhsPrec.formatter],[Lean.PrettyPrinter.Formatter]]
[List.ne_of_not_mem_cons,[absurd, Or.inl],[Ne]]
[List.mem_join_of_mem,[Iff.mpr, List.mem_join, Exists.intro, And.intro],[Mem.mem, List.join]]
[Nat.decidable_dvd,[decidable_of_decidable_of_iff, inferInstance, Nat.decidable_dvd.proof_1],[DecidableRel, Dvd.dvd]]
[Function.has_left_inverse,[Exists, Function.left_inverse],[]]
[Std.HashMapImp.forM,[Std.HashMapImp.forBucketsM, Std.HashMapImp.buckets],[PUnit]]
[Lean.JsonNumber.exponent,[],[Nat]]
[Lean.Json.Parser.natNonZero,[Bind.bind, Lean.Json.Parser.lookahead, And, LE.le, Char.ofNat, Lean.Json.Parser.natCore, OfNat.ofNat, Lean.Parsec, Nat, Pure.pure],[Lean.Parsec, Nat]]
[Lean.Server.FileWorker.handleDefinition,[Bind.bind, MonadReader.read, Lean.Server.RequestM.readDoc, Lean.Server.RequestM.withWaitFindSnap, Decidable.decide, GT.gt, Lean.Server.Snapshots.Snapshot.endPos, Pure.pure, List.toArray, List.nil, Option.none, Lean.Server.RequestM, Array, Lean.Lsp.LocationLink, Lean.Elab.InfoTree.hoverableInfoAt?, Lean.Server.Snapshots.Snapshot.infoTree, Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.Info.ofCompletionInfo, ite, Eq, BEq.beq, Lean.Server.FileWorker.GoToKind.type, Bool.true, liftM, Lean.Elab.ContextInfo.runMetaM, Lean.Elab.Info.lctx, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Lean.Expr.getAppFn, PUnit.unit],[Lean.Server.RequestM, Lean.Server.RequestTask, Array, Lean.Lsp.LocationLink]]
[Lean.githash,[Lean.getGithash, Unit.unit],[String]]
[Lean.Compiler.hasInlineAttribute,[Lean.Compiler.InlineAttributeKind.inline],[Bool]]
[List.disjoint_of_subset_right,[],[List.disjoint]]
[Int.ofNat_eq_ofNat_iff,[Iff.intro, Int.ofNat.inj, congr_arg, Int.ofNat],[Iff, Eq, Int.ofNat]]
[instAddFloat,[Add.mk, Float.add],[Add, Float]]
[Lean.Elab.Tactic.tacticToDischarge,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, getThe, Lean.Elab.Term.State, liftM, IO.mkRef, readThe, Lean.Elab.Term.Context, Prod.mk],[Lean.Elab.Tactic.TacticM, Prod, IO.Ref, Lean.Elab.Term.State, Lean.Meta.Simp.Discharge]]
[Lean.evalPrec,[Lean.Macro.withIncRecDepth, Bind.bind, Lean.expandMacros, cond, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Option.getD, Lean.Syntax.isNatLit?, OfNat.ofNat, Lean.Macro.throwErrorAt],[Lean.MacroM, Nat]]
[unexpandListToArray,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Std.PersistentHashMap.getCollisionNodeSize.proof_1,[],[Eq, Array.size]]
[List.length_insert_of_mem,[Eq.mpr, Eq.refl, Eq, List.length, List.insert, List.insert_of_mem, rfl],[Eq, List.length, List.insert]]
[decidable_eq_of_bool_pred.proof_1,[absurd, Eq.mp, Eq.refl, Not, Eq, Bool.true],[False]]
[Lean.ConstantInfo.axiomInfo.injEq,[Eq.propIntro, Eq.refl, Lean.ConstantInfo.axiomInfo, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ConstantInfo.axiomInfo]]
[«term‹_›»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Tactic.injectionsAndClear,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Parser.Command.optionValue,[HOrElse.hOrElse, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.strLit, Lean.Parser.numLit],[Lean.Parser.Parser]]
[List.Perm_comm,[Iff.intro, List.Perm.symm],[Iff, List.Perm]]
[Lean.Name.isInternal,[Lean.Name.anonymous, Bool, or, BEq.beq, String.get, OfNat.ofNat, Char.ofNat, PProd.fst, Bool.false],[Bool]]
[Lean.Elab.getRefPosition,[Bind.bind, Lean.MonadFileMap.getFileMap, Lean.Elab.getRefPos, Pure.pure, Lean.FileMap.toPosition],[Lean.Position]]
[Lean.Parser.Term.noImplicitLambda.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[Lean.AttributeExtensionState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.AttributeExtensionState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.AttributeExtensionState.mk, And]]
[Lean.getPPPiBinderTypes,[Lean.KVMap.get, Lean.Option.name, Lean.pp.piBinderTypes, Lean.Option.defValue],[Bool]]
[Lean.Parser.Term.completion,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol],[Lean.Parser.TrailingParser]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk.inj,[And.intro],[And, Eq]]
[CoeTC.coe,[],[]]
[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.unicodeSymbol,[Lean.Parser.tokenWithAntiquot, Lean.Parser.unicodeSymbolNoAntiquot],[Lean.Parser.Parser]]
[Lean.Lsp.WorkDoneProgressBegin.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.WorkDoneProgressBegin.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.FileWorker.RpcSession.nextRef,[],[USize]]
[Lean.Level.addOffsetAux,[Lean.Level, PProd.fst, Lean.mkLevelSucc],[Lean.Level]]
[Lean.Lsp.RpcReleaseParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.RpcReleaseParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.RpcConnectParams.noConfusionType,[],[]]
[Lean.Elab.Term.instToStringNamedArg,[ToString.mk, HAppend.hAppend, ToString.toString, Lean.Elab.Term.NamedArg.name, Lean.Elab.Term.NamedArg.val],[ToString, Lean.Elab.Term.NamedArg]]
[Lean.PrettyPrinter.Formatter.instMonadTraverserFormatterM,[Lean.Syntax.MonadTraverser.mk, MonadState.mk, Functor.map, Lean.PrettyPrinter.Formatter.State.stxTrav, MonadState.get, modify, Lean.PrettyPrinter.Formatter.State.mk, Lean.PrettyPrinter.Formatter.State.leadWord, Lean.PrettyPrinter.Formatter.State.stack, MonadState.modifyGet, Prod, Lean.PrettyPrinter.Formatter.State, Prod.mk],[Lean.Syntax.MonadTraverser, Lean.PrettyPrinter.FormatterM]]
[Lean.Lsp.InitializationOptions.mk.inj,[],[Eq]]
[Nat.isValidChar,[Or, LT.lt, OfNat.ofNat, And],[]]
[Lean.Elab.Structural.addSmartUnfoldingDefAux,[Bind.bind, Lean.Elab.PreDefinition.value, Pure.pure, Lean.Elab.PreDefinition.mk, Lean.Elab.PreDefinition.ref, Lean.Elab.PreDefinition.kind, Lean.Elab.PreDefinition.levelParams, Lean.Elab.Modifiers.mk, Lean.Meta.mkSmartUnfoldingNameFor, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.type, Lean.Elab.Structural.addSmartUnfoldingDefAux.visit],[Lean.Meta.MetaM, Lean.Elab.PreDefinition]]
[Lean.evalPrio,[Lean.Macro.withIncRecDepth, Bind.bind, Lean.expandMacros, cond, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Option.getD, Lean.Syntax.isNatLit?, OfNat.ofNat, Lean.Macro.throwErrorAt],[Lean.MacroM, Nat]]
[FloatArray.mk.injEq,[Eq.propIntro, Eq.refl, FloatArray.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, FloatArray.mk]]
[Lean.Parser.Command.optDeriving,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.optional, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.notSymbol, Lean.Parser.Command.derivingClasses],[Lean.Parser.Parser]]
[Lean.Elab.withoutModifyingStateWithInfoAndMessages,[controlAt, Lean.Elab.Term.TermElabM, Bind.bind, Lean.MonadBacktrack.saveState, tryFinally, MonadState.get, Lean.MonadBacktrack.restoreState],[]]
[Lean.ModuleData.constants,[],[Array, Lean.ConstantInfo]]
[modifyGetThe,[MonadStateOf.modifyGet],[]]
[Lean.Server.FileWorker.WorkerState.rpcSessions,[],[Std.RBMap, UInt64, IO.Ref, Lean.Server.FileWorker.RpcSession, Ord.compare]]
[Lean.Elab.Command.StructFieldKind.noConfusionType,[noConfusionTypeEnum, Lean.Elab.Command.StructFieldKind.toCtorIdx],[]]
[Lean.Server.WithRpcRef.decodeUnsafeAs,[Bind.bind, Lean.Server.MonadRpcSession.rpcGetRef, Unit.unit, ExceptT, String, Lean.Server.WithRpcRef, MonadExcept.throw, HAppend.hAppend, ToString.toString, ite, Eq, bne, Bool.true, Pure.pure, PUnit.unit],[ExceptT, String, Lean.Server.WithRpcRef]]
[Lean.Lsp.instFileSourceTextDocumentPositionParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.TextDocumentPositionParams.textDocument],[Lean.Lsp.FileSource, Lean.Lsp.TextDocumentPositionParams]]
[Lean.Meta.Simp.Methods.noConfusionType,[],[]]
[Lean.Parsec.bind,[Lean.Parsec.ParseResult, Lean.Parsec.ParseResult.error],[Lean.Parsec]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withAppArg,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.PrettyPrinter.Delaborator.SubExpr.descend, Lean.Expr.appArg!, OfNat.ofNat],[]]
[Std.mkHashMapImp,[],[Std.HashMapImp]]
[String.toFormat,[Std.Format.joinSep, String.splitOn, Std.Format.line],[Std.Format]]
[Int.ofNat_sub,[],[Eq, Int.ofNat, HSub.hSub]]
[Lean.Elab.Tactic.Location.noConfusionType,[],[]]
[Lean.Parser.registerParserCategory,[Bind.bind, IO.ofExcept, Lean.Parser.addParserCategory, Lean.registerAttributeOfBuilder, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.DataValue.ofName, List.nil],[IO, Lean.Environment]]
[Lean.Elab.Tactic.evalDecide,[Lean.Elab.Tactic.closeMainGoalUsing, Bind.bind, liftM, Lean.Meta.instantiateMVars, ite, Eq, Lean.Expr.hasFVar, Bool.true, Lean.Meta.zetaReduce, Pure.pure, PUnit.unit, Lean.Meta.mkDecide, Lean.Meta.withDefault, Lean.Meta.whnf, Lean.Expr.isConstOf, Lean.Name.mkStr, Lean.Name.anonymous, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr],[Lean.Elab.Tactic.Tactic]]
[Std.Format.groupEx,[Std.Format.group, Std.Format.FlattenBehavior.allOrNone],[Std.Format]]
[UInt64.ofNatCore,[UInt64.mk, Fin.mk],[UInt64]]
[Lean.Parser.Tactic.fapply,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Term.Quotation.commandElab_stx_quot__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Elab.Command.StructFieldInfo.noConfusionType,[],[]]
[Lean.EnvExtensionInterfaceUnsafe.instInhabitedExt,[Inhabited.mk, Lean.EnvExtensionInterfaceUnsafe.Ext.mk, arbitrary],[Inhabited, Lean.EnvExtensionInterfaceUnsafe.Ext]]
[Lean.Elab.Info.lctx,[Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofCompletionInfo, Lean.LocalContext, Lean.Elab.TermInfo.lctx, Lean.Elab.FieldInfo.lctx, Lean.LocalContext.empty],[Lean.LocalContext]]
[Lean.EnvExtensionInterfaceUnsafe.getState,[dite, LT.lt, Lean.EnvExtensionInterfaceUnsafe.Ext.idx, Array.size, Lean.Environment.extensions, unsafeCast, panicWithPosWithDecl, OfNat.ofNat],[]]
[Lean.DataValue.getBoolEx,[Lean.DataValue.ofString, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Bool, Bool.false],[Bool]]
[Lean.Lsp.DocumentHighlight.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.DocumentHighlight.mk, HAdd.hAdd, OfNat.ofNat]]
[String.utf16PosToCodepointPos,[String.utf16PosToCodepointPosFrom, OfNat.ofNat],[Nat]]
[Lean.Elab.processHeader,[MonadExcept.tryCatch, Bind.bind, Lean.importModules, Lean.Elab.headerToImports, Pure.pure, Prod.mk, Lean.mkEmptyEnvironment, OfNat.ofNat, Lean.MessageLog.add, Lean.Message.mk, Lean.Parser.InputContext.fileName, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, ToString.toString],[IO, Prod, Lean.Environment, Lean.MessageLog]]
[Lean.mkErrorStringWithPos,[HAppend.hAppend, ToString.toString, Lean.Position.line, Lean.Position.column],[String]]
[Subtype.equivalence,[Equivalence.mk, Subtype.refl, Subtype.symm, Subtype.trans],[Equivalence, HasEquiv.Equiv]]
[if_congr,[if_ctx_congr],[Eq, ite]]
[IO.FS.Stream.writeNotification,[IO.FS.Stream.writeMessage, Lean.JsonRpc.Message.notification, Lean.JsonRpc.Notification.method, Except.toOption, Lean.Json.toStructured?, Lean.JsonRpc.Notification.param],[IO, Unit]]
[Lean.Compiler.foldUIntAdd,[Lean.Compiler.foldBinUInt, Add.add],[Option, Lean.Expr]]
[Lean.PrettyPrinter.Delaborator.delabAppExplicit,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPExplicit, Bind.bind, Lean.PrettyPrinter.Delaborator.getParamKinds, Lean.PrettyPrinter.Delaborator.SubExpr.withAppFnArgs, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, ite, Eq, Lean.Expr.isConst, Bool.true, Lean.PrettyPrinter.Delaborator.delabConst, Lean.PrettyPrinter.Delaborator.delab, Lean.PrettyPrinter.Delaborator.DelabM, Prod, Lean.Syntax, List, Lean.PrettyPrinter.Delaborator.ParamKind, Array, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPAnalysisHole, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, BEq.beq, Lean.getPPInstances, Lean.Syntax.mkApp],[Lean.PrettyPrinter.Delaborator.Delab]]
[instToStringSubstring,[ToString.mk, Substring.toString],[ToString, Substring]]
[Lean.SCC.M,[StateM, Lean.SCC.State],[]]
[Lean.instQuoteBool,[Lean.Quote.mk, Unit.unit, Lean.Syntax, Lean.mkCIdent, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Quote, Bool]]
[Lean.List.toSMap,[List.foldl, Lean.SMap, Lean.SMap.insert, Lean.SMap.mk],[Lean.SMap]]
[Lean.Meta.isDefEqNative,[Bind.bind, Lean.Meta.reduceNative?, Unit.unit, Lean.Meta.MetaM, Lean.LBool, Pure.pure, Lean.LBool.undef],[Lean.Meta.MetaM, Lean.LBool]]
[Lean.Elab.Command.FieldMap,[Lean.NameMap, Lean.Expr],[]]
[Lean.CollectMVars.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.CollectMVars.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.CollectMVars.State.mk, And]]
[Lean.Widget.MsgEmbed.expr.inj,[],[Eq]]
[le_imp_le_of_lt_imp_lt,[le_of_not_lt, not_le_of_gt],[LE.le]]
[instReprTuple,[ReprTuple.mk, List.cons, repr],[ReprTuple]]
[Std.HashSetBucket,[Subtype, GT.gt, Array.size, OfNat.ofNat],[]]
[Lean.Parser.andthen,[Lean.Parser.Parser.mk, Lean.Parser.andthenInfo, Lean.Parser.Parser.info, Lean.Parser.andthenFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.Meta.Match.Extension.State.switch,[Lean.Meta.Match.Extension.State.mk, Lean.SMap.switch, Lean.Meta.Match.Extension.State.map],[Lean.Meta.Match.Extension.State]]
[instMonadControlStateRefT',[inferInstanceAs, MonadControl, ReaderT, ST.Ref],[MonadControl, StateRefT']]
[Equiv.symm_apply_apply,[Equiv.leftInv],[Eq, Equiv.toFun, Equiv.symm]]
[Lean.Parser.Tactic.pushNeg,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Parser.charLit.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.charLitKind, Bool.true, Lean.PrettyPrinter.Formatter.charLitNoAntiquot.formatter],[Lean.PrettyPrinter.Formatter]]
[Int.negSucc_ofNat_coe,[rfl],[Eq, Int.negSucc, Neg.neg, Int.ofNat, HAdd.hAdd, OfNat.ofNat]]
[Lean.DataValue.ofInt.injEq,[Eq.propIntro, Eq.refl, Lean.DataValue.ofInt, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.DataValue.ofInt]]
[eq_self,[propext, Iff.intro, trivial, rfl],[Eq, True]]
[Lean.Parser.Command.deriving,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.derivingClasses, Lean.Parser.sepBy1, Lean.Parser.ident, Bool.false],[Lean.Parser.Parser]]
[Lean.KVMap.setNat,[Lean.KVMap.insert, Lean.DataValue.ofNat],[Lean.KVMap]]
[Lean.Lsp.instToJsonPublishDiagnosticsParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.PublishDiagnosticsParams.uri, List.nil, Lean.Json.opt, Lean.Lsp.PublishDiagnosticsParams.version?, Lean.Lsp.PublishDiagnosticsParams.diagnostics],[Lean.ToJson, Lean.Lsp.PublishDiagnosticsParams]]
[Lean.Lsp.DefinitionParams.mk.inj,[],[Eq]]
[Std.PersistentHashMap.Entry.noConfusionType,[],[]]
[Lean.Meta.SimpLemma.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SimpLemma.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.KernelException.funExpected.inj,[And.intro],[And, Eq]]
[Lean.Elab.Tactic.AuxMatchTermState.nextIdx,[],[Nat]]
[Lean.IR.Decl.maxIndex,[Lean.IR.MaxIndex.collectDecl, OfNat.ofNat],[Lean.IR.Index]]
[Std.PersistentHashMap.findD,[Option.getD, Std.PersistentHashMap.find?],[]]
[Lean.Compiler.foldUIntMul,[Lean.Compiler.foldBinUInt, Mul.mul],[Option, Lean.Expr]]
[Mathlib.Tactic.Ext.«termExtIffProof%»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[IO.setAccessRights,[IO.Prim.setAccessRights, IO.FileRight.flags],[IO, Unit]]
[Lean.MetavarContext.MkBinding.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MetavarContext.MkBinding.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.dependsOnPred,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.findExprDependsOn],[Lean.Meta.MetaM, Bool]]
[Lean.Elab.Term.elabNoMatch,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Term.isLocalIdent?, Option.none, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Elab.Term.tryPostponeIfNoneOrMVar, Unit.unit, Pure.pure, liftM, Lean.Meta.mkFreshTypeMVar, Lean.MetavarKind.natural, not, Lean.Syntax.isNone, BEq.beq, Option.some, Lean.throwError, Lean.ToMessageData.toMessageData, PUnit.unit, List.toArray, List.cons, List.nil, Lean.mkNullNode, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.Elab.Term.withMacroExpansion, Lean.Elab.Term.elabTerm, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElab]]
[Lean.Xml.Parser.ExternalID,[HOrElse.hOrElse, SeqRight.seqRight, Lean.Parsec.skipString, Lean.Xml.Parser.S, Lean.Xml.Parser.SystemLiteral, Pure.pure, Unit.unit, Lean.Xml.Parser.PubidLiteral],[Lean.Parsec, Unit]]
[Lean.Elab.Command.expandNoKindMacroRulesAux,[Bind.bind, Lean.Elab.Command.inferMacroRulesAltKind, Array.getOp, OfNat.ofNat, ite, Eq, and, Lean.Name.isStr, BEq.beq, Lean.Name.getString!, Bool.true, Pure.pure, PUnit.unit],[Lean.Elab.Command.CommandElabM, Lean.Syntax]]
[Set.instLawfulFunctorSet,[Set.instLawfulFunctorSet.proof_1],[LawfulFunctor, Set]]
[Lean.Parser.Command.example.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declSig.parenthesizer, Lean.Parser.Command.declVal.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[instHashable,[Hashable.mk, OfNat.ofNat],[Hashable]]
[Lean.Core.instMonadOptionsCoreM,[Lean.MonadOptions.mk, Bind.bind, MonadReader.read, Pure.pure, Lean.Core.Context.options],[Lean.MonadOptions, Lean.Core.CoreM]]
[Lean.Meta.mkDecide,[Lean.Meta.mkAppOptM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Option.some, Option.none, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Elab.Tactic.evalRename,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.withoutModifyingStateWithInfoAndMessages, Lean.Meta.withNewMCtxDepth, Lean.Elab.Tactic.elabTerm, Option.none, Lean.MonadLCtx.getLCtx, Lean.LocalContext.findDeclRevM?, liftM, Lean.Meta.isDefEq, Lean.LocalDecl.type, Pure.pure, Option.some, Lean.LocalDecl.fvarId, Unit.unit, Lean.Elab.Tactic.TacticM, Lean.FVarId, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Meta.getLocalInstances, Lean.Elab.Tactic.getMainTarget, Lean.Elab.Tactic.getMainTag, Lean.Meta.mkFreshExprMVarAt, Lean.MetavarKind.syntheticOpaque, OfNat.ofNat, Lean.Elab.Tactic.getMainGoal, Lean.Meta.assignExprMVar, Lean.Elab.Tactic.replaceMainGoal, List.cons, Lean.Expr.mvarId!, List.nil, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[ByteArray.extract,[ByteArray.copySlice, ByteArray.empty, OfNat.ofNat, HSub.hSub, Bool.true],[ByteArray]]
[Lean.IR.UnreachableBranches.InterpState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.UnreachableBranches.InterpState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Export.State.stk,[],[Array, Prod, Bool, Lean.Export.Entry]]
[Lean.Meta.AbstractMVars.mkFreshFVarId,[Bind.bind, Lean.Meta.AbstractMVars.mkFreshId, Pure.pure, Lean.FVarId.mk],[Lean.Meta.AbstractMVars.M, Lean.FVarId]]
[Fin.size_positive,[LT.lt, OfNat.ofNat, Nat.eq_or_lt_of_le, Nat.zero_le, Eq.symm, Nat.lt_trans],[LT.lt, OfNat.ofNat]]
[Subtype.coind,[Subtype.mk],[Subtype]]
[Lean.Widget.goalToInteractive,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.findDecl?, Option.none, Lean.Meta.MetaM, Lean.Widget.InteractiveGoal, Lean.MonadOptions.getOptions, Lean.Meta.withLCtx, Lean.MetavarDecl.localInstances, Lean.Meta.ToHide.collect, Lean.MetavarDecl.type, Lean.LocalContext.foldlM, Prod, Array, Lean.Name, Option, Lean.Expr, Lean.Widget.InteractiveHypothesis, ite, Eq, or, and, not, Lean.LocalDecl.isAuxDecl, Std.RBTree.contains, Lean.LocalDecl.fvarId, Bool.true, Prod.mk, List.toArray, List.nil, OfNat.ofNat, Lean.Meta.instantiateMVars, Lean.Widget.exprToInteractive, Lean.Widget.InteractiveGoal.mk, Lean.Widget.goalToInteractive.ppVars, Lean.Widget.goalToInteractive.pushPending, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MVarId.name],[Lean.Meta.MetaM, Lean.Widget.InteractiveGoal]]
[Lean.Parser.Term.pipeProj.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.minPrec, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.fieldIdx.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.Term.argument.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Json.CompressWorkItem.objectField.inj,[And.intro],[And, Eq]]
[unexpandEqNDRec,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Lean.IR.LogEntry.step.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.LogEntry.step, HAdd.hAdd, OfNat.ofNat]]
[Nat.mod_zero,[],[Eq, HMod.hMod, OfNat.ofNat]]
[Lean.Parser.Tactic.clear_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.MetavarContext.isLevelAssignable,[Option.none, Bool, Std.PersistentHashMap.find?, Lean.MetavarContext.lDepth, BEq.beq, Lean.MetavarContext.depth, panicWithPosWithDecl, OfNat.ofNat],[Bool]]
[Lean.Meta.assignLevelMVar,[Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.assignLevel],[Lean.Meta.MetaM, Unit]]
[FloatArray.forInUnsafe,[OfNat.ofNat, FloatArray.forInUnsafe.loop],[]]
[Lean.Elab.Deriving.Ord.mkMatch.mkAlts,[Bind.bind, ForIn.forIn, Lean.getConstInfoCtor, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, liftM, Lean.Core.betaReduce, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, PUnit.unit, ForInStep.yield, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, MProd.mk, Lean.Elab.Term.TermElabM, Array, Lean.Syntax, Lean.Meta.inferType, Lean.Meta.isProp, ite, Eq, or, Lean.Expr.containsFVar, Lean.Expr.fvarId!, Bool.true, Lean.Core.mkFreshUserName, Lean.mkIdent, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Array.pop],[Lean.Elab.Term.TermElabM, Array, Lean.Syntax]]
[Lean.Parser.Term.doLetRec.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.Term.letRecDecls.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Term.doMatchAlts.parenthesizer,[Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.Match.Alt.replaceFVarId,[Lean.Meta.Match.Alt.mk, Lean.Meta.Match.Alt.ref, Lean.Meta.Match.Alt.idx, Lean.Expr.replaceFVarId, Lean.Meta.Match.Alt.rhs, List.map, Lean.replaceFVarIdAtLocalDecl, Lean.Meta.Match.Pattern.replaceFVarId, Lean.Meta.Match.Alt.patterns],[Lean.Meta.Match.Alt]]
[Lean.addAliasEntry,[Unit.unit, Lean.AliasState, Lean.SMap.find?, Prod.fst, Lean.SMap.insert, List.cons, Prod.snd, List.nil, ite, Eq, List.elem, Bool.true],[Lean.AliasState]]
[Nat.add_eq,[rfl],[Eq, Nat.add, HAdd.hAdd]]
[Lean.Meta.Match.instInhabitedMatchEqnsExtState,[Inhabited.mk, Lean.Meta.Match.MatchEqnsExtState.mk, arbitrary],[Inhabited, Lean.Meta.Match.MatchEqnsExtState]]
[UInt64.zero_def,[rfl],[Eq, OfNat.ofNat, UInt64.mk]]
[ByteSlice.len,[],[Nat]]
[Lean.IR.ExplicitRC.getJPParams,[Unit.unit, Array, Lean.IR.Param, Lean.IR.LocalContext.getJPParams, Lean.IR.ExplicitRC.Context.localCtx, panicWithPosWithDecl, OfNat.ofNat],[Array, Lean.IR.Param]]
[Lean.Meta.isLevelDefEqAuxImpl,[Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Meta.MetaM, Bool, Lean.Meta.isLevelDefEqAux, ite, Eq, BEq.beq, Lean.Level.getLevelOffset, Bool.true, Pure.pure, Lean.Level.getOffset, Bind.bind, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, PUnit.unit],[Lean.Meta.MetaM, Bool]]
[Nat.exists_coprime,[Exists.intro, HDiv.hDiv, Nat.gcd, And.intro, Nat.coprime_div_gcd_div_gcd, Eq.symm, Nat.div_mul_cancel, Nat.gcd_dvd_left, Nat.gcd_dvd_right],[Exists, And, Nat.coprime, Eq, HMul.hMul, Nat.gcd]]
[instDecidableIff.proof_4,[Iff.intro, absurd],[Iff]]
[Lean.Elab.Term.StructInst.DefaultFields.State.noConfusionType,[],[]]
[Lean.MessageData.ofLevel.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MessageData.ofLevel, HAdd.hAdd, OfNat.ofNat]]
[Mathlib.Tactic.Lint.Linter.noConfusionType,[],[]]
[Lean.Lsp.SymbolKind.key.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.key, OfNat.ofNat]]
[Subtype.restrict_def,[rfl],[Eq, Subtype.restrict, Function.comp, CoeHead.coe]]
[Lean.Parser.Command.openOnly.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.CollectFVars.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.CollectFVars.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.CollectFVars.State.mk, And]]
[USize.sub,[USize.mk, HSub.hSub, USize.val],[USize]]
[Lean.instInhabitedParametricAttribute,[Inhabited.mk, Lean.ParametricAttribute.mk, arbitrary],[Inhabited, Lean.ParametricAttribute]]
[Std.Format.nil.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Std.Format.nil, OfNat.ofNat]]
[Std.Format.paren,[Std.Format.bracket],[Std.Format]]
[Lean.mkNoConfusionEnum,[Bind.bind, Lean.MonadEnv.getEnv, ite, Eq, Lean.Environment.contains, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.mkNoConfusionCore, Lean.mkNoConfusionEnum.mkToCtorIdx, Lean.mkNoConfusionEnum.mkNoConfusionType, Lean.mkNoConfusionEnum.mkNoConfusion],[Lean.Meta.MetaM, Unit]]
[Std.Format.pretty,[Prod.snd],[String]]
[not_not_not,[Iff.intro, mt, not_not_intro],[Iff, Not]]
[Lean.Rat.div,[Lean.Rat.mul, Lean.Rat.inv],[Lean.Rat]]
[Tactic.Ring.Cache.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Tactic.Ring.Cache.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Tactic.Ring.Cache.mk, And]]
[Lean.IR.EmitC.emitCtorScalarSize,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Lean.IR.EmitC.emit, Bind.bind],[Lean.IR.EmitC.M, Unit]]
[Lean.Elab.TacticInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.TacticInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.TacticInfo.mk, And]]
[Lean.Lsp.DocumentSymbolParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.DocumentSymbolParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.TextDocumentContentChangeEvent.noConfusionType,[],[]]
[UInt32.decEq,[Decidable, Eq, dite, Decidable.isTrue, UInt32.decEq.proof_1, Decidable.isFalse, UInt32.decEq.proof_2],[Decidable, Eq]]
[instSubsingletonForall,[instSubsingletonForall.proof_1],[Subsingleton]]
[Lean.Elab.Term.Do.ToCodeBlock.expandLiftMethod,[ite, Eq, not, Bool.true, Pure.pure, Prod.mk, List.nil, Bind.bind, StateT.run, Bool.false, Lean.Elab.Term.Do.ToCodeBlock.M, Prod, List, Lean.Syntax],[Lean.Elab.Term.Do.ToCodeBlock.M, Prod, List, Lean.Syntax]]
[List.decidableMem,[Unit.unit, Decidable, Mem.mem, Decidable.isFalse, not_false, dite, Eq, Decidable.isTrue, List.decidableMem.proof_1, List.cons, PProd.fst, List.decidableMem.proof_2, List.decidableMem.proof_3],[Decidable, Mem.mem]]
[add_neg_cancel_right,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, add_assoc, add_right_neg, OfNat.ofNat, add_zero, rfl],[Eq, HAdd.hAdd, Neg.neg]]
[Lean.Parser.Term.let_delayed,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, Lean.Parser.symbol, Lean.Parser.Term.letDecl, Lean.Parser.Term.optSemicolon, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[imp_true_iff,[iff_true_intro, trivial],[Iff, True]]
[Lean.DeclarationRange.endPos,[],[Lean.Position]]
[Prod.map,[Prod, Prod.mk],[Prod]]
[Lean.Parser.Term.set_option.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.Command.optionValue.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Command.aliasLR,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.binderIdent],[Lean.ParserDescr]]
[Std.RBMap.instForInRBMapProd,[ForIn.mk, Std.RBMap.forIn],[ForIn, Std.RBMap, Prod]]
[Lean.Parser.Term.char.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.charLit.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Tactic.done,[Bind.bind, Lean.Elab.Tactic.getUnsolvedGoals, ite, Eq, List.isEmpty, Bool.true, Pure.pure, PUnit.unit, liftM, Lean.Elab.Term.reportUnsolvedGoals, Lean.Elab.throwAbortTactic],[Lean.Elab.Tactic.TacticM, Unit]]
[instDecidableXor.proof_2,[Or.inl, And.intro],[Or, And, Not]]
[Lean.InductiveVal.numCtors,[List.length, Lean.InductiveVal.ctors],[Nat]]
[Lean.Expr.FoldConstsImpl.visited.proof_2,[lcProof],[LT.lt, USize.toNat, HMod.hMod, ptrAddrUnsafe, Array.size, Lean.Expr.FoldConstsImpl.State.visitedTerms]]
[instModUSize,[Mod.mk, USize.mod],[Mod, USize]]
[Lean.Parser.Term.trailing_parser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.optExprPrecedence.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[String.leftpad,[String.mk, List.leftpad, String.data],[String]]
[List.append_eq_nil,[of_eq_true, Eq.trans, congr, congrArg, Iff, congrFun, Eq, List.nil_append, List.nil, And, eq_self, true_and, iff_self, Eq.symm, List.cons_append, eq_false', false_and, eq_true_of_decide, Eq.refl, Bool.true],[Iff, Eq, HAppend.hAppend, List.nil, And]]
[Quot.exists_rep,[Quot.inductionOn, Exists.intro, rfl],[Exists, Eq, Quot.mk]]
[Lean.MonadRef.noConfusionType,[],[]]
[Lean.TransformStep.visit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.TransformStep.visit, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.State.noConfusionType,[],[]]
[and,[Unit.unit, Bool, Bool.false],[Bool]]
[Prod.rprod,[WellFoundedRelation.mk, Prod.RProd, WellFoundedRelation.rel, Prod.rprod.proof_1],[WellFoundedRelation, Prod]]
[Lean.Meta.MatcherApp.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Command.variable,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.ppSpace, Lean.Parser.Term.bracketedBinder, Bool.false],[Lean.Parser.Parser]]
[Lean.Meta.MatcherApp.noConfusionType,[],[]]
[Lean.instQuoteNat,[Lean.Quote.mk, Lean.Syntax.mkNumLit, ToString.toString, Lean.SourceInfo.none],[Lean.Quote, Nat]]
[Lean.IR.AltCore.mmodifyBody,[Lean.IR.Alt, Functor.map, Lean.IR.Alt.ctor, Lean.IR.Alt.default],[Lean.IR.Alt]]
[Lean.SimplePersistentEnvExtensionDescr.addImportedFn,[],[]]
[Lean.letFunAnnotation?,[Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous],[Option, Lean.Expr]]
[UInt64.toUInt32,[Nat.toUInt32, UInt64.toNat],[UInt32]]
[Lean.Meta.Match.MatcherResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.MatcherResult.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.WithRpcRef.noConfusionType,[],[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.checkpointDefEq,[Lean.Meta.checkpointDefEq, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isDefEqAssigning, Bool.false],[Lean.Meta.MetaM, Bool]]
[Lean.Elab.Info.ofTermInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Info.ofTermInfo, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Command.Context.currMacroScope,[],[Lean.MacroScope]]
[Tactic.Ring.horner_horner,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HAdd.hAdd, HMul.hMul, add_zero, HPow.hPow, mul_assoc, Eq.symm, pow_add, eq_self],[Eq, Tactic.Ring.horner, OfNat.ofNat]]
[Std.ShareCommonM.run,[Std.ShareCommonT.run],[]]
[EStateM.modifyGet,[EStateM.Result, EStateM.Result.ok],[EStateM]]
[Lean.Elab.Command.StructFieldView.value?,[],[Option, Lean.Syntax]]
[Lean.ScopedEnvExtension.addLocalEntry,[Unit.unit, Lean.Environment, Lean.ScopedEnvExtension.StateStack.stateStack, Lean.PersistentEnvExtension.setState, Lean.ScopedEnvExtension.ext, Lean.ScopedEnvExtension.StateStack.mk, List.cons, Lean.ScopedEnvExtension.StateStack.scopedEntries, Lean.ScopedEnvExtension.StateStack.newEntries],[Lean.Environment]]
[Lean.IR.ExplicitBoxing.getScrutineeType,[Unit.unit, Lean.IR.IRType, Lean.IR.IRType.object, ite, LT.lt, OfNat.ofNat, Lean.IR.IRType.uint8, Lean.IR.IRType.uint16, Lean.IR.IRType.uint32],[Lean.IR.IRType]]
[String.takeRightWhile,[Substring.toString, Substring.takeRightWhile, String.toSubstring],[String]]
[Nat.add,[Nat, Nat.succ, PProd.fst],[Nat]]
[IO.Error.alreadyExists.inj,[And.intro],[And, Eq]]
[Lean.Lsp.DocumentFilter.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.DocumentFilter.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.openRenamingItem.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.unicodeSymbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.checkNoImmediateColon,[Lean.Parser.Parser.mk, ite, Eq, Lean.Parser.checkTailNoWs, Bool.true, String.atEnd, BEq.beq, Char.ofNat, Lean.Parser.ParserState.mkUnexpectedError, List.nil],[Lean.Parser.Parser]]
[Function.left_inverse_of_surjective_of_right_inverse,[Eq, Eq.mpr, Eq.refl, Eq.symm, rfl],[Function.left_inverse]]
[Lean.Compiler.foldNatMul,[Lean.Compiler.foldNatBinOp, Mul.mul],[Option, Lean.Expr]]
[Lean.Parser.Tactic.eraseAuxDiscrs.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.maxPrec, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Tactic.acMono,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[instForIn,[ForIn.mk, Stream.forIn],[ForIn]]
[Nat.gcd_one_left,[Eq.mpr, Eq.refl, Eq, Nat.gcd, OfNat.ofNat, Nat.gcd_succ, HMod.hMod, Nat.succ, Nat.mod_one, rfl],[Eq, Nat.gcd, OfNat.ofNat]]
[Lean.Core.State.traceState,[],[Lean.TraceState]]
[Lean.JsonRpc.instCoeResponseErrorMessage,[Coe.mk, Lean.JsonRpc.Message.responseError, Lean.JsonRpc.ResponseError.id, Lean.JsonRpc.ResponseError.code, Lean.JsonRpc.ResponseError.message, Option.map, Lean.ToJson.toJson, Lean.JsonRpc.ResponseError.data?],[Coe, Lean.JsonRpc.ResponseError, Lean.JsonRpc.Message]]
[Lean.Parser.Command.catBehaviorBoth.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.FunInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.FunInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.FunInfo.mk, And]]
[Lean.IR.Borrow.BorrowInfCtx.noConfusionType,[],[]]
[Lean.KeyedDeclsAttribute.Def.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KeyedDeclsAttribute.Def.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KeyedDeclsAttribute.Def.mk, And]]
[Lean.Meta.AbstractMVars.State.nextParamIdx,[],[Nat]]
[not_and_not_right,[Decidable.not_and_not_right],[Iff, Not, And]]
[Lean.Elab.Command.CollectAxioms.State.axioms,[],[Array, Lean.Name]]
[Monad.noConfusionType,[],[]]
[Lean.CollectMVars.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.CollectMVars.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.RequestError.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.RequestError.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Syntax.Traverser.noConfusionType,[],[]]
[Lean.IR.Checker.CheckerContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Checker.CheckerContext.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Message.fileName,[],[String]]
[Nat.add_lt_add_right,[Nat.add_lt_add_left, Nat.add_comm],[LT.lt, HAdd.hAdd]]
[Lean.Elab.Term.CollectPatternVars.main,[Bind.bind, Array.mapM, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Elab.Term.MatchAltView.patterns, Lean.Elab.Term.MatchAltView.mk, Lean.Elab.Term.MatchAltView.ref, Lean.Elab.Term.MatchAltView.rhs],[Lean.Elab.Term.CollectPatternVars.M, Lean.Elab.Term.MatchAltView]]
[Lean.ParserCompiler.CombinatorAttribute.getDeclFor?,[Lean.NameMap.find?, Lean.SimplePersistentEnvExtension.getState, Lean.ParserCompiler.CombinatorAttribute.ext],[Option, Lean.Name]]
[Lean.Meta.collectMVarsAtDecl,[Lean.Declaration.forExprM, Lean.Meta.collectMVars],[StateRefT', IO.RealWorld, Lean.CollectMVars.State, Lean.Meta.MetaM, Unit]]
[Lean.Elab.InfoTree.hoverableInfoAt?,[Id.run, Option.none, Option.some, Prod.mk, Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.Info.ofCompletionInfo, Id, Option, Prod, Lean.Elab.ContextInfo, Lean.Elab.Info, ite, Eq, Lean.Expr.isSyntheticSorry, Lean.Elab.TermInfo.expr, Bool.true, Pure.pure, Bind.bind, PUnit.unit],[Option, Prod, Lean.Elab.ContextInfo, Lean.Elab.Info]]
[Lean.Parser.Tactic.Conv.nestedConv,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.Parser.Tactic.Conv.convSeqBracketed],[Lean.ParserDescr]]
[Lean.ConstantInfo.thmInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ConstantInfo.thmInfo, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.lookaheadFn,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Parser.ParserState.restore],[Lean.Parser.ParserFn]]
[Std.HashSetImp.foldBucketsM,[Array.foldlM, List.foldlM, Subtype.val, OfNat.ofNat, Array.size],[]]
[Ring.noConfusionType,[],[]]
[Lean.MessageData.nil,[Lean.MessageData.ofFormat, Std.Format.nil],[Lean.MessageData]]
[Lean.Elab.Tactic.liftMetaTactic1,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Option.none, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.nil],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.monadNameGeneratorLift,[Lean.MonadNameGenerator.mk, liftM, Lean.MonadNameGenerator.getNGen, Lean.MonadNameGenerator.setNGen],[Lean.MonadNameGenerator]]
[Lean.Elab.Term.elabBinRelCore,[Bind.bind, Lean.Elab.Term.resolveId?, Lean.Syntax.getOp, OfNat.ofNat, Bool.false, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.MonadBacktrack.saveState, Lean.Elab.Term.withSynthesize, Lean.Elab.Term.elabTerm, Option.none, Bool.true, ite, Eq, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, liftM, Lean.Meta.inferType, Lean.Elab.Term.ensureHasType, Option.some, Pure.pure, PUnit.unit, MonadExcept.tryCatch, Lean.withRef, Prod.mk, Lean.Elab.Term.SavedState.restore, Lean.throwUnknownConstant, Lean.Syntax.getId, Lean.Elab.Term.elabBinRelCore.toBoolIfNecessary],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Lean.MetavarContext.isExprAssigned,[Std.PersistentHashMap.contains, Lean.MetavarContext.eAssignment],[Bool]]
[Lean.Elab.Term.ContainsPendingMVar.M,[Lean.MonadCacheT, Lean.Expr, Unit, OptionT, Lean.Elab.Term.TermElabM],[]]
[Std.AssocList.any,[Unit.unit, Bool, Bool.false, or, PProd.fst],[Bool]]
[Lean.Parser.Tactic.prettyCases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[instShiftLeftUInt64,[ShiftLeft.mk, UInt64.shiftLeft],[ShiftLeft, UInt64]]
[Lean.Server.FileWorker.Reference.isDeclaration,[],[Bool]]
[Lean.Meta.FVarSubst.map,[],[Std.AssocList, Lean.FVarId, Lean.Expr]]
[Lean.getSanitizeNames,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Lean.sanitizeNamesDefault],[Bool]]
[Lean.KernelException.unknownConstant.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.unknownConstant, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KernelException.unknownConstant, And]]
[not_imp_self,[Decidable.not_imp_self],[Iff]]
[Tactic.Ring.evalConstMul,[Tactic.Ring.RingM, Prod, Tactic.Ring.HornerExpr, Lean.Expr, Bind.bind, liftM, Lean.Meta.mkMul, Prod.fst, Lean.Meta.NormNum.eval, Pure.pure, Prod.mk, Tactic.Ring.HornerExpr.const, HMul.hMul, Prod.snd, PProd.fst, PProd.snd, Tactic.Ring.HornerExpr.xadd', Tactic.Ring.mkAppCS, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Tactic.Ring.HornerExpr.e, List.nil],[Tactic.Ring.RingM, Prod, Tactic.Ring.HornerExpr, Lean.Expr]]
[Lean.Elab.Term.ensureNoUnassignedMVars,[Bind.bind, liftM, Lean.Meta.getMVarsAtDecl, Lean.Elab.Term.logUnassignedUsingErrorInfos, Option.none, ite, Eq, Bool.true, Lean.Elab.throwAbortCommand, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Meta.InjectionResultCore.subgoal.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.InjectionResultCore.subgoal, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.declVal.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.declValSimple.parenthesizer, Lean.Parser.Command.declValEqns.parenthesizer, Lean.Parser.Command.whereStructInst.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.coprime.dvd_of_dvd_mul_right,[Eq.mp, Eq.refl, Dvd.dvd, HMul.hMul, OfNat.ofNat, Nat.mul_one, Nat.gcd, Nat.coprime.gcd_eq_one, Nat.gcd_mul_left],[Dvd.dvd]]
[Lean.CompactedRegion,[USize],[]]
[Lean.Parser.Term.open.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.openDecl.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withOpenDecl.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Function.left_inverse.eq_right_inverse,[],[Eq]]
[Lean.Elab.Term.SavedContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.SavedContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.SavedContext.mk, And]]
[Lean.Parser.Attr.class,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Environment.contains,[Lean.SMap.contains, Lean.Environment.constants],[Bool]]
[Lean.Elab.Term.Quotation.Precheck,[Lean.Elab.Term.Quotation.PrecheckM, Unit],[]]
[Std.Format.nestD,[Std.Format.nest, Int.ofNat, Std.Format.defIndent],[Std.Format]]
[Lean.instInhabitedLazyInitExtension,[Inhabited.mk, Lean.LazyInitExtension.mk, arbitrary, Pure.pure],[Inhabited, Lean.LazyInitExtension]]
[Std.RBMap.any,[Bool, Std.RBNode.any],[Bool]]
[Lean.Meta.Closure.State.levelParams,[],[Array, Lean.Name]]
[Lean.Elab.TerminationHints.terminationBy?,[],[Option, Lean.Syntax]]
[Lean.Parser.Command.catBehavior.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.catBehaviorBoth.parenthesizer, Lean.Parser.Command.catBehaviorSymbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Json.obj.inj,[],[Eq]]
[Lean.Parser.ParserExtension.OLeanEntry.category.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.ParserExtension.OLeanEntry.category, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.RpcEncoding.rpcDecode,[],[ExceptT, String]]
[Nat.add_le_to_le_sub,[Eq.mpr, Eq.refl, Iff, LE.le, HAdd.hAdd, HSub.hSub, Eq.symm, Nat.add_sub_cancel, propext, Nat.sub_le_sub_right_iff, Iff.rfl],[Iff, LE.le, HAdd.hAdd, HSub.hSub]]
[Array.swap.proof_1,[Eq.symm, Array.size_set, Array.get],[Eq, Array.size, Array.set, Array.get]]
[Lean.Elab.Term.Quotation.HeadCheck.slice.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Quotation.HeadCheck.slice, HAdd.hAdd, OfNat.ofNat]]
[Lean.MonadError.toAddErrorMessageContext,[],[Lean.AddErrorMessageContext]]
[Lean.Elab.Deriving.mkDiscrs,[Bind.bind, ForIn.forIn, Lean.Elab.Deriving.mkDiscr, Pure.pure, PUnit.unit, ForInStep.yield, Array.mapM, Lean.Elab.Deriving.Header.targetNames, HAppend.hAppend],[Lean.Elab.Term.TermElabM, Array, Lean.Syntax]]
[Lean.IR.Expr.sproj.inj,[And.intro],[And, Eq]]
[Lean.Meta.UnificationHint.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.UnificationHint.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.UnificationHint.mk, And]]
[Lean.Parser.Level.ident.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Command.expandMutualNamespace,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, Option.some, Lean.MacroM, ForInStep, MProd, Array, Lean.Syntax, Option, Lean.Name, Lean.Elab.Command.expandDeclNamespace?, Pure.pure, PUnit.unit, ForInStep.yield, ite, Eq, BEq.beq, Bool.true, Lean.Macro.throwErrorAt, HAppend.hAppend, ToString.toString, Unit.unit, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Macro.throwUnsupported],[Lean.Macro]]
[Lean.Meta.getErasedInstances,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Meta.Instances.erased, Lean.ScopedEnvExtension.getState, Lean.Meta.instanceExtension],[Lean.Core.CoreM, Std.PHashSet, Lean.Name]]
[Lean.PrettyPrinter.registerParserCompilers,[Bind.bind, Lean.ParserCompiler.registerParserCompiler, Lean.ParserCompiler.Context.mk, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.parenthesizerAttribute, Lean.PrettyPrinter.combinatorParenthesizerAttribute, Lean.PrettyPrinter.formatterAttribute, Lean.PrettyPrinter.combinatorFormatterAttribute],[IO, Unit]]
[Lean.Lsp.LineRange.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.LineRange.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.MatcherApp.altNumParams,[],[Array, Nat]]
[Lean.Lsp.RpcCallParams.params,[],[Lean.Json]]
[FloatSpec.noConfusionType,[],[]]
[Lean.JsonRpc.instBEqResponse,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.JsonRpc.Response]]
[Lean.Meta.Closure.MkValueTypeClosureResult.levelParams,[],[Array, Lean.Name]]
[Lean.Elab.Term.MVarErrorInfo.ref,[],[Lean.Syntax]]
[Lean.Elab.Term.MutualClosure.ClosureState.newLocalDecls,[],[Array, Lean.LocalDecl]]
[Nat.anyM.loop,[Unit.unit, Bool, Pure.pure, Bool.false, Bind.bind, HSub.hSub, OfNat.ofNat, Bool.true, PProd.fst],[Bool]]
[Lean.RecursorRule.mk.inj,[And.intro],[And, Eq]]
[Lean.ModuleData.imports,[],[Array, Lean.Import]]
[Lean.Meta.ReduceMatcherResult.notMatcher.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.ReduceMatcherResult.notMatcher, OfNat.ofNat]]
[Array.modifyM,[dite, LT.lt, Array.size, Bind.bind, Pure.pure, Array.set, Array.modifyM.proof_1],[Array]]
[or_iff_not_imp_left,[Decidable.or_iff_not_imp_left],[Iff, Or]]
[Std.PersistentArray.push,[ite, Eq, or, Decidable.decide, LT.lt, Array.size, Std.PersistentArray.tail, USize.toNat, Std.PersistentArray.branching, GE.ge, Std.PersistentArray.size, Std.PersistentArray.tooBig, Bool.true, Std.PersistentArray.mkNewTail],[Std.PersistentArray]]
[Lean.Parser.Tactic.reassoc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Elab.Term.LetRecView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LetRecView.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.LetRecView.mk, And]]
[Lean.Elab.Term.elabProj,[Bind.bind, List.nil, Bool.false, List.toArray, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.Elab.Term.TermElabM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Pure.pure, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError],[Lean.Elab.Term.TermElab]]
[Lean.Elab.Tactic.tryTactic,[MonadExcept.tryCatch, Bind.bind, Functor.discard, Pure.pure, Bool.true, Bool.false],[Lean.Elab.Tactic.TacticM, Bool]]
[Lean.Parser.many1Indent.formatter,[Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.many1.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkColGe.formatter],[Lean.PrettyPrinter.Formatter]]
[UInt32.eq_of_val_eq,[Eq, congrArg, UInt32.mk],[Eq]]
[Lean.Elab.Term.MutualClosure.main,[Bind.bind, Lean.MonadMCtx.getMCtx, liftM, Lean.Meta.resetZetaFVarIds, Lean.Meta.withTrackingZeta, List.forM, Lean.Meta.withLCtx, Lean.Elab.Term.LetRecToLift.lctx, Lean.Elab.Term.LetRecToLift.localInstances, Lean.Meta.check, Lean.Elab.Term.LetRecToLift.type, Lean.Elab.Term.LetRecToLift.val, List.mapM, Lean.Meta.lambdaTelescope, Lean.Meta.instantiateForall, Lean.MonadLCtx.getLCtx, StateRefT'.run, Lean.Elab.Term.MutualClosure.ClosureState.mk, Lean.Elab.Term.TermElabM, Lean.Elab.Term.MutualClosure.ClosureState, Pure.pure, Array.reverse, Lean.Elab.Term.MutualClosure.ClosureState.newLocalDecls, Lean.Elab.Term.MutualClosure.ClosureState.localDecls, Lean.Elab.Term.MutualClosure.ClosureState.newLetDecls, Lean.Elab.Term.MutualClosure.ClosureState.exprArgs, Array.map, Lean.LocalContext.get!, Lean.Expr.fvarId!, Lean.Meta.assignExprMVar, Lean.Elab.Term.LetRecToLift.mvarId, Lean.Elab.Term.MutualClosure.LetRecClosure.mk, Lean.Elab.Term.LetRecToLift.ref, Lean.Elab.Term.LetRecToLift.mk, Lean.Elab.Term.LetRecToLift.fvarId, Lean.Elab.Term.LetRecToLift.attrs, Lean.Elab.Term.LetRecToLift.shortDeclName, Lean.Elab.Term.LetRecToLift.declName, Option.get!, Std.RBMap.find?, Array.mapM, Lean.Meta.instantiateMVars, Lean.Elab.DefViewElabHeader.type, Lean.Elab.DefViewElabHeader.mk, Lean.Elab.DefViewElabHeader.ref, Lean.Elab.DefViewElabHeader.modifiers, Lean.Elab.DefViewElabHeader.kind, Lean.Elab.DefViewElabHeader.shortDeclName, Lean.Elab.DefViewElabHeader.declName, Lean.Elab.DefViewElabHeader.levelNames, Lean.Elab.DefViewElabHeader.binderIds, Lean.Elab.DefViewElabHeader.numParams, Lean.Elab.DefViewElabHeader.valueStx, Lean.Elab.Term.MutualClosure.LetRecClosure.toLift, Lean.Elab.Term.MutualClosure.LetRecClosure.ref, Lean.Elab.Term.MutualClosure.LetRecClosure.localDecls, Lean.Elab.Term.MutualClosure.LetRecClosure.closed, Lean.Elab.Term.MutualClosure.pushMain, Lean.Elab.Term.MutualClosure.pushLetRecs, List.toArray, List.nil],[Lean.Elab.Term.TermElabM, Array, Lean.Elab.PreDefinition]]
[StateT.run_bind_lift,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, LawfulMonad.bind_assoc, Pure.pure, Prod.mk, Bind.bind, funext, LawfulMonad.pure_bind, eq_self],[Eq, StateT.run, Bind.bind, StateT.lift]]
[Lean.Parser.Tactic.induction,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlts],[Lean.ParserDescr]]
[Lean.Parser.ParserContext.suppressInsideQuot,[],[Bool]]
[Lean.Import.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.SynthInstance.Waiter.consumerNode.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.SynthInstance.Waiter.consumerNode, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SynthInstance.Waiter.consumerNode]]
[Lean.Parser.Tactic.rwRuleSeq,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.rwRule, Bool.true],[Lean.ParserDescr]]
[Lean.Parser.antiquotNestedExpr.formatter,[Lean.PrettyPrinter.Formatter.node.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.symbolNoAntiquot.formatter, Lean.PrettyPrinter.Formatter.decQuotDepth.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.mkDecideProof,[Bind.bind, Lean.Meta.mkDecide, Lean.Meta.mkEq, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.Meta.mkEqRefl, Lean.Meta.mkExpectedTypeHint, Lean.Meta.mkAppM, List.toArray, List.cons],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Elab.Term.elabQuotedName,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Syntax.isNameLit?, Lean.Syntax.getOp, OfNat.ofNat, Pure.pure, Lean.ToExpr.toExpr, Lean.Elab.throwIllFormedSyntax],[Lean.Elab.Term.TermElab]]
[List.subset,[Mem.mem],[]]
[Lean.Elab.Command.strLitToPattern,[Unit.unit, Lean.MacroM, Lean.Syntax, Lean.Syntax.isStrLit?, Pure.pure, Lean.mkAtomFrom, Lean.Macro.throwUnsupported],[Lean.MacroM, Lean.Syntax]]
[Lean.PrettyPrinter.formatTerm,[Lean.PrettyPrinter.format, Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Core.CoreM, Std.Format]]
[Lean.Meta.SimpLemma.getValue,[ite, Eq, and, Lean.Expr.isConst, Lean.Meta.SimpLemma.proof, Array.isEmpty, Lean.Meta.SimpLemma.levelParams, Bool.true, Bind.bind, Lean.getConstInfo, Lean.Expr.constName!, List.isEmpty, Lean.ConstantInfo.levelParams, Pure.pure, List.mapM, Lean.Meta.mkFreshLevelMVar, Lean.Expr.updateConst!, Array.mapM, Lean.Expr.instantiateLevelParamsArray],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.PPFns.ppExpr,[],[IO, Std.Format]]
[Decidable.not_iff_comm,[Eq.mpr, Eq.refl, Iff, Not, propext, iff_def, And, and_congr, Decidable.not_imp_comm, imp_not_comm],[Iff, Not]]
[Lean.Parser.Term.argument.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkWsBefore.formatter, Lean.PrettyPrinter.Formatter.checkColGt.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.namedArgument.formatter, Lean.Parser.Term.ellipsis.formatter, Lean.Parser.termParser.formatter, Lean.Parser.argPrec],[Lean.PrettyPrinter.Formatter]]
[Lean.PrettyPrinter.Formatter.group,[Bind.bind, Lean.PrettyPrinter.Formatter.concat, modify, Lean.PrettyPrinter.Formatter.State.mk, Lean.PrettyPrinter.Formatter.State.stxTrav, Lean.PrettyPrinter.Formatter.State.leadWord, Array.modify, Lean.PrettyPrinter.Formatter.State.stack, HSub.hSub, Array.size, OfNat.ofNat, Std.Format.fill],[Lean.PrettyPrinter.Formatter]]
[Lean.Attribute.add,[Bind.bind, Lean.MonadEnv.getEnv, Lean.ofExcept, Lean.getAttributeImpl, Lean.AttributeImpl.add],[Lean.AttrM, Unit]]
[Nat.succ_eq_add_one,[rfl],[Eq, Nat.succ, HAdd.hAdd, OfNat.ofNat]]
[Lean.NameGenerator.mk.inj,[And.intro],[And, Eq]]
[Mathlib.RunTac.tacticRunTac_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[ByteArray.toSliceT,[ByteSliceT.mk, OfNat.ofNat],[ByteSliceT]]
[Function.eval,[],[]]
[Lean.Meta.Match.Problem.toMessageData,[Lean.Meta.Match.withGoalOf, Bind.bind, List.mapM, Lean.Meta.Match.Alt.toMessageData, Lean.Meta.Match.Problem.alts, Lean.Meta.inferType, Pure.pure, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.Match.Problem.vars, Lean.indentD, Lean.MessageData.joinSep, Lean.MessageData.ofFormat, Std.Format.line, Lean.Meta.Match.examplesToMessageData, Lean.Meta.Match.Problem.examples],[Lean.Meta.MetaM, Lean.MessageData]]
[Quotient.liftOn₂,[Quotient.lift₂],[]]
[Lean.Lsp.instBEqDiagnosticRelatedInformation,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Lsp.DiagnosticRelatedInformation]]
[Lean.Server.DocumentMeta.version,[],[Nat]]
[Lean.Parser.sepByFn,[Bool.true],[Lean.Parser.ParserFn]]
[Nat.lt_of_lt_of_eq,[],[LT.lt]]
[Lean.getExternEntryFor,[Lean.getExternEntryForAux, Lean.ExternAttrData.entries],[Option, Lean.ExternEntry]]
[Function.injective.prod_map,[],[Function.injective, Prod.map]]
[Lean.Elab.Tactic.ElabSimpArgsResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Tactic.ElabSimpArgsResult.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Tactic.evalConstructor,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Meta.constructor, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Bool.false, Lean.Elab.Tactic.replaceMainGoal],[Lean.Elab.Tactic.Tactic]]
[Lean.IR.EmitC.emitFns,[Bind.bind, Lean.IR.EmitC.getEnv, List.forM, List.reverse, Lean.IR.EmitC.emitDecl],[Lean.IR.EmitC.M, Unit]]
[Function.funext_iff,[Iff.intro, rfl, funext],[Iff, Eq]]
[Lean.Parser.Command.commentBody,[Lean.Parser.Parser.mk, Lean.Parser.rawFn, Lean.Parser.finishCommentBlock, OfNat.ofNat, Bool.true],[Lean.Parser.Parser]]
[Lean.Server.FileWorker.WorkerState.noConfusionType,[],[]]
[Lean.Parser.Term.doPatDecl.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.Term.leftArrow.parenthesizer, Lean.Parser.doElemParser.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[System.instInhabitedFilePath,[Inhabited.mk, System.FilePath.mk, arbitrary],[Inhabited, System.FilePath]]
[Lean.Parser.Command.mixfix.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.Command.mixfixKind.formatter, Lean.Parser.precedence.formatter, Lean.Parser.Command.optNamedName.formatter, Lean.Parser.Command.optNamedPrio.formatter, Lean.ppSpace.formatter, Lean.Parser.strLit.formatter, Lean.Parser.darrow.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[HSub.hSub,[],[]]
[Subtype.symm,[Setoid.symm],[HasEquiv.Equiv]]
[Lean.Server.RpcEncoding.DerivingParams.withRef,[],[Bool]]
[Lean.Parser.Term.sort.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkWsBefore.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer, Lean.Parser.levelParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.DefViewElabHeader.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.DefViewElabHeader.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.DefViewElabHeader.mk, And]]
[Lean.mkAtomFrom,[Lean.Syntax.atom, Lean.SourceInfo.fromRef],[Lean.Syntax]]
[Std.HashMapImp.findEntry?,[Option, Prod, Std.AssocList.findEntry?, Array.uget, Subtype.val],[Option, Prod]]
[Lean.KeyedDeclsAttribute.ExtensionState.newEntries,[],[List, Lean.KeyedDeclsAttribute.OLeanEntry]]
[Lean.Parser.Command.set_option.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.Command.optionValue.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.elabBinder,[Lean.Elab.Term.elabBinders, List.toArray, List.cons, List.nil, Array.getOp, OfNat.ofNat],[Lean.Elab.Term.TermElabM]]
[Lean.MetavarContext.hasAssignableLevelMVar,[Bool, and, Lean.Level.hasMVar, PProd.fst, or, PProd.snd, Lean.MetavarContext.isLevelAssignable, Bool.false],[Bool]]
[Lean.Lsp.WorkDoneProgressEnd.message?,[],[Option, String]]
[Lean.Parser.Command.protected,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Meta.DecLevelContext.mk.inj,[],[Eq]]
[Function.decidable_eq_pfun,[Decidable, Eq, decidable_of_iff, Function.decidable_eq_pfun.proof_1],[DecidableEq]]
[Lean.Widget.TaggedText.append.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.trans, Eq.refl, SizeOf.sizeOf, List.nil, HAdd.hAdd, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Widget.TaggedText.append, HAdd.hAdd, OfNat.ofNat]]
[instStreamProdProd,[Stream.mk, Option, Prod, Unit.unit, Stream.next?, Option.none, Option.some, Prod.mk],[Stream, Prod]]
[Std.Range.forIn,[Std.Range.stop, Std.Range.start, Std.Range.forIn.loop],[]]
[Lean.instMonadCacheReaderT,[Lean.MonadCache.mk, Lean.MonadCache.findCached?, Lean.MonadCache.cache],[Lean.MonadCache, ReaderT]]
[List.mem_constructor,[Exists, Eq, List.nil, HAppend.hAppend, List.cons, Eq.refl, Eq.mpr, Exists.intro, rfl, Eq.symm, List.cons_append],[Exists, Eq, HAppend.hAppend, List.cons]]
[Lean.Meta.IndPredBelow.Context.belowNames,[],[Array, Lean.Name]]
[Lean.MonadRecDepth.getRecDepth,[],[Nat]]
[Lean.Parser.TokenMap.insert,[Unit.unit, Lean.Parser.TokenMap, Std.RBMap.find?, Std.RBMap.insert, List.cons, List.nil],[Lean.Parser.TokenMap]]
[StateT.bind,[Bind.bind, Prod],[StateT]]
[Lean.Meta.smartUnfoldingMatch?,[Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous],[Option, Lean.Expr]]
[Lean.instInhabitedOptionDecls,[Inhabited.mk, EmptyCollection.emptyCollection],[Inhabited, Lean.OptionDecls]]
[Lean.Meta.getUnfoldEqnFor?,[Bind.bind, ST.Ref.get, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, Lean.Meta.MetaM, ForInStep, MProd, Option, Lean.Name, PUnit, Pure.pure, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, MProd.fst],[Lean.Meta.MetaM, Option, Lean.Name]]
[List.exists_mem_of_ne_nil,[List.exists_mem_of_length_pos, List.length_pos_of_ne_nil],[Exists, Mem.mem]]
[Std.Format.append.inj,[And.intro],[And, Eq]]
[Lean.Syntax.TopDown.firstChoiceOnly,[],[Bool]]
[Lean.Widget.Lean.Widget.InfoPopup.instRpcEncodingInfoPopupRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Lean.Widget.InfoPopup.type, Lean.Widget.InfoPopup.exprExplicit, Lean.Widget.InfoPopup.doc, Pure.pure, Lean.Server.RpcEncoding.rpcDecode, Lean.Widget.InfoPopup.mk],[Lean.Server.RpcEncoding, Lean.Widget.InfoPopup]]
[Std.PersistentArray.pop,[ite, GT.gt, Array.size, Std.PersistentArray.tail, OfNat.ofNat, Std.PersistentArray.mk, Std.PersistentArray.root, Array.pop, HSub.hSub, Std.PersistentArray.size, Std.PersistentArray.shift, Std.PersistentArray.tailOff, Std.PersistentArray, Std.PersistentArray.popLeaf, Eq, and, BEq.beq, Std.PersistentArrayNode.isNode, Array.get!, Bool.true, Std.PersistentArray.initShift, Std.PersistentArrayNode.node],[Std.PersistentArray]]
[Lean.Lsp.InitializeParams.mk.inj,[And.intro],[And, Eq]]
[MonoidWithZero.noConfusionType,[],[]]
[instMonadControlReaderT,[MonadControl.mk, id],[MonadControl, ReaderT]]
[Lean.ConstantInfo.opaqueInfo.injEq,[Eq.propIntro, Eq.refl, Lean.ConstantInfo.opaqueInfo, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ConstantInfo.opaqueInfo]]
[Lean.Elab.TermInfo.lctx,[],[Lean.LocalContext]]
[Nat.any,[Nat.anyAux],[Bool]]
[Lean.Widget.InteractiveGoal.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Syntax.binary,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.syntaxParser],[Lean.Parser.Parser]]
[Lean.Lsp.instFileSourceTypeDefinitionParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.TypeDefinitionParams.toTextDocumentPositionParams],[Lean.Lsp.FileSource, Lean.Lsp.TypeDefinitionParams]]
[Lean.PrettyPrinter.Formatter.formatterForKindUnsafe,[ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.PrettyPrinter.Formatter.push, Std.Format.text, Lean.Syntax.MonadTraverser.goLeft, Lean.Syntax.MonadTraverser.getCur, liftM, Lean.PrettyPrinter.runForNodeKind, Lean.PrettyPrinter.formatterAttribute, Lean.PrettyPrinter.Formatter.interpretParserDescr', Lean.PrettyPrinter.Formatter.withMaybeTag, Unit.unit, Option, Nat, Lean.SourceInfo.original, Lean.SourceInfo.none, Option.some, Option.none],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.Match.Example.var.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.Example.var, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.forall,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.unicodeSymbol, Lean.Parser.many1, Lean.Parser.ppSpace, HOrElse.hOrElse, Lean.Parser.Term.simpleBinder, Lean.Parser.Term.bracketedBinder, Bool.false, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.Meta.Simp.ConfigCtx.noConfusionType,[],[]]
[Std.HashSet.insert,[Std.HashSet, Subtype.mk, Std.HashSetImp.insert, Std.HashSetImp.WellFormed.insertWff],[Std.HashSet]]
[Lean.Meta.CongrLemma.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.CongrLemma.mk, HAdd.hAdd, OfNat.ofNat]]
[eq_or_ne,[em, Eq],[Or, Eq, Ne]]
[Lean.Elab.Term.Do.ToCodeBlock.Context.m,[],[Lean.Syntax]]
[Lean.Export.Entry.noConfusionType,[],[]]
[Lean.DefinitionSafety.noConfusionType,[noConfusionTypeEnum, Lean.DefinitionSafety.toCtorIdx],[]]
[Int.ofNat_add,[rfl],[Eq, Int.ofNat, HAdd.hAdd]]
[Lean.ScopedEnvExtension.add,[Unit.unit, Unit, Lean.MonadEnv.modifyEnv, Lean.ScopedEnvExtension.addEntry, Lean.ScopedEnvExtension.addLocalEntry, Bind.bind, Lean.MonadResolveName.getCurrNamespace, Lean.ScopedEnvExtension.addScopedEntry],[Unit]]
[Lean.Meta.check,[Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.all],[Lean.Meta.MetaM, Unit]]
[Lean.IR.Checker.usizeSize,[Lean.IR.Checker.getUSizeSize, Unit.unit],[Nat]]
[Fin.modn_def,[Eq, HMod.hMod, Fin.mk, Fin.val, Nat.mod_lt, Fin.size_positive, rfl],[Eq, HMod.hMod, Fin.mk, Fin.val, Nat.mod_lt, Fin.size_positive]]
[Lean.Elab.TacticInfo.noConfusionType,[],[]]
[Std.ShareCommon.PState,[Std.ShareCommon.PersistentState],[]]
[Applicative.toSeqLeft,[],[SeqLeft]]
[Std.HashSetImp.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.HashSetImp.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.instToJsonProd,[Lean.ToJson.mk, Lean.Json, Lean.Json.arr, List.toArray, List.cons, Lean.ToJson.toJson, List.nil],[Lean.ToJson, Prod]]
[List.getLastD,[List.getLast, List.cons, List.getLastD.proof_1],[]]
[Lean.IR.ExplicitBoxing.castArgsIfNeededAux,[Bind.bind, ForIn.forIn, MProd.mk, Unit.unit, Lean.IR.ExplicitBoxing.M, ForInStep, MProd, Array, Lean.IR.Arg, Lean.IR.FnBody, Nat, Pure.pure, PUnit.unit, Lean.IR.ExplicitBoxing.getVarType, ite, Eq, Lean.IR.ExplicitBoxing.eqvTypes, Bool.true, getModify, Lean.IR.ExplicitBoxing.BoxingState.mk, HAdd.hAdd, Lean.IR.ExplicitBoxing.BoxingState.nextIdx, OfNat.ofNat, Lean.IR.ExplicitBoxing.BoxingState.auxDecls, Lean.IR.ExplicitBoxing.BoxingState.auxDeclCache, Lean.IR.ExplicitBoxing.BoxingState.nextAuxId, Lean.IR.VarId.mk, Lean.IR.ExplicitBoxing.mkCast, Prod, Prod.mk],[Lean.IR.ExplicitBoxing.M, Prod, Array, Lean.IR.Arg, Lean.IR.FnBody]]
[Lean.Elab.instInhabitedDefViewElabHeader,[Inhabited.mk, Lean.Elab.DefViewElabHeader.mk, arbitrary],[Inhabited, Lean.Elab.DefViewElabHeader]]
[Function.forall_update_iff,[Iff.intro, Function.update],[Iff, Function.update, And]]
[ExceptT.finally,[MonadFinally.mk, ExceptT.mk, Bind.bind, MonadFinally.tryFinally', Option.none, Option.some, Except.error, Except, Except.ok, Prod, Pure.pure, Prod.mk],[MonadFinally, ExceptT]]
[Lean.Parser.checkTailLinebreak,[Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Bool, Lean.Syntax.getTailInfo, Substring.contains, Char.ofNat, Bool.false],[Bool]]
[And.right,[],[]]
[Lean.MessageData.noConfusionType,[],[]]
[Lean.Server.Watchdog.ServerEvent.noConfusionType,[],[]]
[Lean.Meta.simpAll,[Lean.Meta.withMVarContext, StateRefT'.run', Lean.Meta.SimpAll.main, Lean.Meta.SimpAll.State.mk],[Lean.Meta.MetaM, Option, Lean.MVarId]]
[ofNat_mul,[Eq, Numeric.ofNat, HMul.hMul, of_eq_true, Eq.trans, congr, congrArg, Nat.mul_zero, ofNat_zero, MonoidWithZero.mul_zero, eq_self, OfNat.ofNat, Nat.mul_succ, ofNat_add, congrFun, HAdd.hAdd, ofNat_one, mul_add, mul_one],[Eq, Numeric.ofNat, HMul.hMul]]
[Lean.ScopedEnvExtension.addEntry,[Lean.PersistentEnvExtension.addEntry, Lean.ScopedEnvExtension.ext, Lean.ScopedEnvExtension.Entry.global],[Lean.Environment]]
[Lean.Elab.getOptDerivingClasses,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Unit.unit, Array, Lean.Elab.DerivingClassView, OptionM.run, Array.sequenceMap, Array.getSepElems, Lean.Syntax.getArgs, Lean.Syntax.isNone, Option.none, Option.some, Bind.bind, ForIn.forIn, MProd.mk, ForInStep, MProd, Subarray, Option, Lean.Syntax, Stream.next?, Pure.pure, ForInStep.done, Lean.Elab.resolveGlobalConstNoOverloadWithInfo, PUnit.unit, ForInStep.yield, List.toArray, List.nil],[Array, Lean.Elab.DerivingClassView]]
[Lean.Expr.hasLevelMVarEx,[Lean.Expr.hasLevelMVar],[Bool]]
[Lean.Elab.Term.mkFreshIdent,[Bind.bind, Lean.Elab.Term.mkFreshBinderName, Pure.pure, Lean.mkIdentFrom],[Lean.Syntax]]
[Lean.Server.FileWorker.SemanticTokensContext.beginPos,[],[String.Pos]]
[solve,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.getAttributeNames,[Std.PersistentHashMap.foldl, List.cons, List.nil],[List, Lean.Name]]
[ExceptCpsT.run_bind_throw,[rfl],[Eq, ExceptCpsT.run, Bind.bind, MonadExcept.throw]]
[Lean.MetavarContext.MkBinding.State.cache,[],[Std.HashMap, Lean.ExprStructEq, Lean.Expr]]
[Lean.Elab.Deriving.Header.noConfusionType,[],[]]
[Lean.Elab.Tactic.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Tactic.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.unknown,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.withPosition, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.errorAtSavedPos],[Lean.Parser.Parser]]
[Nat.mul_div_cancel,[Eq.mp, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, HAdd.hAdd, OfNat.ofNat, Nat.zero_add, Nat.zero_div],[Eq, HDiv.hDiv, HMul.hMul]]
[Lean.Meta.CheckAssignment.run,[Bind.bind, Lean.Meta.getMVarDecl, StateRefT'.run', ReaderT.run, Lean.Meta.CheckAssignment.State.mk],[Lean.Meta.MetaM, Option, Lean.Expr]]
[Lean.Parser.withResultOfInfo,[Lean.Parser.ParserInfo.mk, Lean.Parser.ParserInfo.collectTokens, Lean.Parser.ParserInfo.collectKinds],[Lean.Parser.ParserInfo]]
[imp_not_comm,[imp.swap],[Iff, Not]]
[Lean.Json.getObjValAs?,[Lean.FromJson.fromJson?, Lean.Json.getObjValD],[Except, String]]
[Lean.Parser.Command.optNamedPrio,[Lean.Parser.optional, HAndThen.hAndThen, Lean.Parser.ppSpace, Lean.Parser.Command.namedPrio],[Lean.Parser.Parser]]
[Lean.Expr.instantiateLevelParamsCore,[Lean.Expr.instantiateLevelParamsCore.visit],[Lean.Expr]]
[Lean.JsonRpc.Response.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.Simp.Cache,[Lean.ExprMap, Lean.Meta.Simp.Result],[]]
[Lean.PrettyPrinter.Parenthesizer.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PrettyPrinter.Parenthesizer.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.EmitC.emitCtor,[Bind.bind, Lean.IR.EmitC.emitLhs, ite, Eq, and, BEq.beq, Lean.IR.CtorInfo.size, OfNat.ofNat, Lean.IR.CtorInfo.usize, Lean.IR.CtorInfo.ssize, Bool.true, Lean.IR.EmitC.emit, Lean.IR.CtorInfo.cidx, Lean.IR.EmitC.emitLn, Lean.IR.EmitC.emitAllocCtor, Lean.IR.EmitC.emitCtorSetArgs],[Lean.IR.EmitC.M, Unit]]
[Lean.IR.ExplicitBoxing.BoxingState.nextAuxId,[],[Nat]]
[Lean.Parser.LeadingIdentBehavior.noConfusionType,[noConfusionTypeEnum, Lean.Parser.LeadingIdentBehavior.toCtorIdx],[]]
[Mathlib.Prelude.Rename.elabAlign,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Lean.Elab.Command.liftCoreM, Mathlib.Prelude.Rename.addNameAlignment, Lean.Syntax.getId, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Lean.instCoeIntDataValue,[Coe.mk, Lean.DataValue.ofInt],[Coe, Int, Lean.DataValue]]
[FloatSpec.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, FloatSpec.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Expr.Data.looseBVarRange,[UInt64.toUInt32, UInt64.shiftRight, OfNat.ofNat],[UInt32]]
[Lean.Elab.Term.mkConst,[Bind.bind, Lean.getConstInfo, ite, GT.gt, List.length, Lean.ConstantInfo.levelParams, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, liftM, Lean.Meta.mkFreshLevelMVars, Pure.pure, Lean.mkConst],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Array.feraseIdx,[Array.eraseIdxAux, HAdd.hAdd, Fin.val, OfNat.ofNat],[Array]]
[Array.insertionSort.swapLoop.proof_2,[Eq.mpr, Eq.refl, LT.lt, Array.size, Array.swap, Fin.mk, Nat.lt_trans, Nat.lt_succ_self, Eq.symm, Array.size_swap],[LT.lt, Array.size, Array.swap, Fin.mk, Nat.lt_trans, Nat.lt_succ_self, Eq.symm]]
[Lean.Elab.Info.format,[IO, Std.Format, Lean.Elab.TacticInfo.format, Lean.Elab.TermInfo.format, Lean.Elab.CommandInfo.format, Lean.Elab.MacroExpansionInfo.format, Lean.Elab.FieldInfo.format, Lean.Elab.CompletionInfo.format],[IO, Std.Format]]
[Lean.Meta.IndPredBelow.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Tactic.withLocation,[Unit.unit, Lean.Elab.Tactic.TacticM, Unit, Bind.bind, Array.forM, Lean.Elab.Tactic.withMainContext, Lean.Elab.Tactic.getFVarId, OfNat.ofNat, Array.size, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Elab.Tactic.tryTactic, Lean.MonadLCtx.getLCtx, ForIn.forIn, ForInStep.yield, Lean.Elab.Tactic.getMainGoal],[Lean.Elab.Tactic.TacticM, Unit]]
[StdGen.s2,[],[Nat]]
[Lean.instMonadQuotation,[Lean.MonadQuotation.mk, liftM, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, MonadFunctorT.monadMap, Lean.MonadQuotation.withFreshMacroScope],[Lean.MonadQuotation]]
[Lean.Lsp.InitializeParams.capabilities,[],[Lean.Lsp.ClientCapabilities]]
[Lean.IR.Expr.alphaEqv,[Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.fap, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Bool, and, BEq.beq, Lean.IR.AlphaEqv.aeqv, Bool.false],[Bool]]
[Lean.Lsp.instFromJsonRpcConnectParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, Pure.pure, Lean.Lsp.RpcConnectParams.mk],[Lean.FromJson, Lean.Lsp.RpcConnectParams]]
[Lean.Meta.ensureAtMostOne,[Unit.unit, List.cons, Lean.Meta.MetaM, Option, Lean.MVarId, Pure.pure, Option.none, Option.some, Lean.throwError],[Lean.Meta.MetaM, Option, Lean.MVarId]]
[Lean.Macro.State.traceMsgs,[],[List, Prod, Lean.Name, String]]
[Char.ofNat,[dite, Nat.isValidChar, Char.mk, UInt32.mk, Fin.mk, LT.lt, UInt32.size, Nat.lt_trans, of_decide_eq_true, Eq.refl, Bool.true, OfNat.ofNat, Char.ofNat.proof_1, Char.ofNat.proof_2],[Char]]
[«term_\/_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Meta.DiscrTree.empty,[Lean.Meta.DiscrTree.mk, Std.PersistentHashMap.mk],[Lean.Meta.DiscrTree]]
[Lean.Parser.optionalFn,[Lean.Parser.ParserState.mkNode, Lean.nullKind],[Lean.Parser.ParserFn]]
[Lean.Meta.GeneralizeTelescope.Entry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.GeneralizeTelescope.Entry.mk, HAdd.hAdd, OfNat.ofNat]]
[UInt8.instAddSemigroupUInt8.proof_1,[congrArg, UInt8.mk, AddSemigroup.add_assoc, UInt8.val],[Eq, UInt8.mk]]
[Lean.Widget.instInhabitedInteractiveGoal,[Inhabited.mk, Lean.Widget.InteractiveGoal.mk, arbitrary],[Inhabited, Lean.Widget.InteractiveGoal]]
[Lean.IR.FnBody.mdata.inj,[And.intro],[And, Eq]]
[Lean.Server.Watchdog.WorkerEvent.noConfusionType,[],[]]
[Lean.Macro.Context.noConfusionType,[],[]]
[Lean.Elab.Term.expandArgs,[Lean.Elab.Term.TermElabM, Prod, Array, Lean.Elab.Term.NamedArg, Lean.Elab.Term.Arg, Bool, Bind.bind, Array.foldlM, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Term.addNamedArg, Lean.Elab.Term.NamedArg.mk, Lean.Elab.Term.Arg.stx, Pure.pure, Prod.mk, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, Array.push, List.toArray, List.nil, OfNat.ofNat, Array.size],[Lean.Elab.Term.TermElabM, Prod, Array, Lean.Elab.Term.NamedArg, Lean.Elab.Term.Arg, Bool]]
[Lean.Meta.SizeOfSpecNested.main.step,[Bind.bind, liftM, Lean.Meta.isDefEq, ite, Eq, Bool.true, Lean.Meta.mkEqRefl, Lean.matchConstRec, Lean.Expr.getAppFn, Lean.Meta.SizeOfSpecNested.throwFailed, MonadReader.read, Unit.unit, Lean.Meta.SizeOfSpecNested.M, Lean.Expr, Lean.NameMap.find?, Lean.Meta.SizeOfSpecNested.Context.recMap, Lean.ConstantVal.name, Lean.RecursorVal.toConstantVal, Lean.Meta.SizeOfSpecNested.throwUnexpected, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Pure.pure, Lean.mkAppN, Lean.mkConst, List.tail!, Lean.Meta.SizeOfSpecNested.Context.params, Lean.Meta.SizeOfSpecNested.Context.localInsts, Array.ofSubarray, List.toArray, List.cons, List.nil],[Lean.Meta.SizeOfSpecNested.M, Lean.Expr]]
[Lean.Meta.Match.Alt.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.Alt.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.elabBinRel,[Lean.Elab.Term.elabBinRelCore, Bool.false],[Lean.Elab.Term.TermElab]]
[Nat.coprime.gcd_mul_right_cancel_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.mul_comm, Nat.coprime.gcd_mul_left_cancel_right, rfl],[Eq, Nat.gcd, HMul.hMul]]
[Lean.Meta.MetaM.run,[StateRefT'.run],[Lean.Core.CoreM, Prod, Lean.Meta.State]]
[Prod.lex,[WellFoundedRelation.mk, Prod.Lex, WellFoundedRelation.rel, Prod.lex.proof_1],[WellFoundedRelation, Prod]]
[of_decide_eq_true,[absurd, ne_true_of_eq_false, decide_eq_false],[]]
[if_t_t,[Eq, ite, rfl],[Eq, ite]]
[Lean.Declaration.mutualDefnDecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Declaration.mutualDefnDecl, HAdd.hAdd, OfNat.ofNat]]
[Mod.mod,[],[]]
[Lean.PrettyPrinter.Parenthesizer.scientificLitNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.instMonadLCtx,[Lean.MonadLCtx.mk, liftM, Lean.MonadLCtx.getLCtx],[Lean.MonadLCtx]]
[Lean.Lsp.PublishDiagnosticsParams.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.LocalContext.isParam,[Option.none, Option.some, Lean.IR.LocalContextEntry.localVar, Lean.IR.LocalContextEntry.joinPoint, Bool, Std.RBMap.find?, Bool.true, Bool.false],[Bool]]
[Lean.Meta.mkPropExt,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[ULift.down,[],[]]
[«term_|>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Widget.Lean.Widget.InteractiveHypothesis.instToJsonRpcEncodingPacket,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil, Lean.Json.opt],[Lean.ToJson]]
[Substring.takeWhile,[Substring, Substring.mk],[Substring]]
[Lean.matchConstStruct,[Lean.matchConstInduct, ite, Eq, or, Lean.InductiveVal.isRec, bne, Lean.InductiveVal.numIndices, OfNat.ofNat, Bool.true, Unit.unit, List.nil, List.cons, Lean.InductiveVal.ctors, Bind.bind, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo],[]]
[Lean.Meta.Simp.Methods.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.Simp.Methods.mk, OfNat.ofNat]]
[Add.add,[],[]]
[Lean.Level.isEquiv,[or, BEq.beq, Lean.Level.normalize],[Bool]]
[Quotient.sound.proof_1,[Quot.sound],[Eq, Quot.mk, HasEquiv.Equiv]]
[Lean.Elab.DefViewElabHeader.noConfusionType,[],[]]
[Lean.Lsp.PublishDiagnosticsParams.uri,[],[Lean.Lsp.DocumentUri]]
[and_iff_not_or_not,[Decidable.and_iff_not_or_not],[Iff, And, Not, Or]]
[Lean.Meta.Match.Unify.State.mk.inj,[],[Eq]]
[Lean.Parser.Term.do.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.argPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.dvd_refl,[Exists.intro, OfNat.ofNat, of_eq_true, Eq.trans, congrArg, Eq, Nat.mul_one, eq_self],[Dvd.dvd]]
[Lean.Macro.Context.methods,[],[PointedType.type]]
[Lean.ppExpr,[ite, Eq, Lean.Option.get, Lean.PPContext.opts, Lean.pp.raw, Bool.true, Pure.pure, Std.ToFormat.format, ToString.toString, MonadExcept.tryCatch, Lean.PPFns.ppExpr, Lean.EnvExtension.getState, Lean.ppExt, Lean.PPContext.env, Lean.pp.rawOnError, HAppend.hAppend, Std.Format.line],[IO, Std.Format]]
[Lean.Parser.Term.funImplicitBinder.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.lookahead.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.implicitBinder.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.IR.FnBody.vdecl.inj,[And.intro],[And, Eq]]
[not_non_contradictory_iff_absurd,[Iff.intro, mt, not_not_intro],[Iff, Not]]
[Lean.Widget.InteractiveHypothesis.type,[],[Lean.Widget.CodeWithInfos]]
[CoeHTCT.coe,[],[]]
[EStateM.instOrElseEStateM,[OrElse.mk, EStateM.orElse],[OrElse, EStateM]]
[«termIfLet_:=_Then_Else_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Meta.instMonadMetaM,[Monad.mk],[Monad, Lean.Meta.MetaM]]
[Lean.InductiveVal.isNested,[],[Bool]]
[Lean.registerAttributeOfDecl,[Bind.bind, Lean.mkAttributeImplOfConstant, ite, Eq, Lean.isAttribute, Lean.AttributeImplCore.name, Lean.AttributeImpl.toAttributeImplCore, Bool.true, MonadExcept.throw, HAppend.hAppend, ToString.toString, Pure.pure, Lean.PersistentEnvExtension.addEntry, Lean.attributeExtension, Prod.mk, Lean.AttributeExtensionOLeanEntry.decl],[Except, String, Lean.Environment]]
[Lean.PrettyPrinter.Formatter.fieldIdx.formatter,[Lean.PrettyPrinter.Formatter.visitAtom, Lean.fieldIdxKind],[Lean.PrettyPrinter.Formatter]]
[Subsingleton.noConfusionType,[],[]]
[xor,[Or, And, Not],[]]
[Lean.Parser.Command.terminationHintMany.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.lookahead.formatter, Lean.Parser.ident.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1Indent.formatter, Lean.Parser.group.formatter, Lean.ppLine.formatter, Lean.Parser.optional.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.isGreek,[and, Decidable.decide, LE.le, OfNat.ofNat, Char.val],[Bool]]
[Lean.Parser.FirstTokens.merge,[Lean.Parser.FirstTokens.epsilon, Lean.Parser.FirstTokens.unknown, Lean.Parser.FirstTokens.tokens, Lean.Parser.FirstTokens.optTokens, Lean.Parser.FirstTokens, Lean.Parser.FirstTokens.toOptional, HAppend.hAppend],[Lean.Parser.FirstTokens]]
[Subarray.forRevM,[Array.forRevM, Subarray.as, Subarray.stop, Subarray.start],[PUnit]]
[ByteArray.toUInt64BE!,[ite, Eq, BEq.beq, ByteArray.size, OfNat.ofNat, Bool.true, HOr.hOr, HShiftLeft.hShiftLeft, UInt8.toUInt64, ByteArray.get!, panicWithPosWithDecl, HAppend.hAppend],[UInt64]]
[Lean.MonadCache.cache,[],[Unit]]
[Lean.MetavarDecl.lctx,[],[Lean.LocalContext]]
[Lean.Meta.Simp.State.mk.inj,[And.intro],[And, Eq]]
[List.mem_of_mem_cons_of_mem,[Or.elim, List.eq_or_mem_of_mem_cons, Eq.symm],[Mem.mem]]
[add_right_neg,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat, Eq.symm, add_left_neg, neg_neg, rfl],[Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat]]
[Lean.EnumAttributes.ext,[],[Lean.PersistentEnvExtension, Prod, Lean.Name, Lean.NameMap]]
[Lean.Meta.InductionSubgoal.mvarId,[],[Lean.MVarId]]
[Lean.Elab.Term.elabSyntheticHole,[ite, Eq, Lean.Name.isAnonymous, Bool.true, Unit.unit, Bind.bind, Lean.MonadMCtx.getMCtx, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.MetavarContext.findUserName?, Lean.Elab.Term.getMVarDecl, Lean.MonadLCtx.getLCtx, Lean.LocalContext.isSubPrefixOf, Lean.MetavarDecl.lctx, List.toArray, List.nil, Pure.pure, Lean.MetavarContext.getExprAssignment?, liftM, Lean.Meta.instantiateMVars, Lean.MetavarContext.isWellFormed, Lean.Meta.withLCtx, Lean.MetavarDecl.localInstances, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.MetavarContext.isDelayedAssigned, Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.assignExpr],[Lean.Elab.Term.TermElab]]
[String.back,[String.get, String.prev, String.bsize],[Char]]
[Lean.Parser.Tactic.acChange,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Elab.Tactic.TacticM,[ReaderT, Lean.Elab.Tactic.Context, StateRefT', IO.RealWorld, Lean.Elab.Tactic.State, Lean.Elab.Term.TermElabM],[]]
[Lean.Xml.Parser.PEDecl,[SeqRight.seqRight, Lean.Parsec.skipString, Lean.Xml.Parser.S, Lean.Parsec.skipChar, Char.ofNat, Lean.Xml.Parser.Name, Lean.Xml.Parser.PEDef, optional],[Lean.Parsec, Unit]]
[Lean.Parser.Tactic.withReducibleAndInstances,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[«stx_,*»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[IO.FS.Mode.noConfusion,[noConfusionEnum, IO.FS.Mode.toCtorIdx],[IO.FS.Mode.noConfusionType]]
[Lean.Meta.UnificationHintEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.UnificationHintEntry.mk, HAdd.hAdd, OfNat.ofNat]]
[String.toNat!,[ite, Eq, String.isNat, Bool.true, String.foldl, HAdd.hAdd, HMul.hMul, OfNat.ofNat, HSub.hSub, Char.toNat, Char.ofNat, panicWithPosWithDecl],[Nat]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.motive,[],[Option, Prod, Lean.Syntax, Lean.Expr]]
[Lean.Lsp.instFromJsonWaitForDiagnosticsParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, Nat, Pure.pure, Lean.Lsp.WaitForDiagnosticsParams.mk],[Lean.FromJson, Lean.Lsp.WaitForDiagnosticsParams]]
[Lean.Parser.Term.typeAscription.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.instMonadRecDepthMonadCacheT,[inferInstanceAs, Lean.MonadRecDepth, StateRefT', Std.HashMap],[Lean.MonadRecDepth, Lean.MonadCacheT]]
[Lean.Meta.forallMetaTelescope,[List.toArray, List.nil, OfNat.ofNat, Bool.false, Option.none],[Lean.Meta.MetaM, Prod, Array, Lean.Expr, Lean.BinderInfo]]
[Lean.AddErrorMessageContext.add,[],[Prod, Lean.Syntax, Lean.MessageData]]
[instDecidableEqPUnit,[Decidable.isTrue, PUnit.subsingleton],[DecidableEq, PUnit]]
[Lean.MessageSeverity.warning.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.MessageSeverity.warning, OfNat.ofNat]]
[Lean.Parsec.ParseResult.success.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parsec.ParseResult.success, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parsec.ParseResult.success, And]]
[Lean.instInhabitedLOption,[Inhabited.mk, Lean.LOption.none],[Inhabited, Lean.LOption]]
[EIO.catchExceptions,[EStateM.Result, Empty, IO.RealWorld, EStateM.Result.ok],[BaseIO]]
[Lean.Parser.sepByElemParser,[Lean.Parser.withAntiquotSpliceAndSuffix, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol, HAppend.hAppend, String.trim],[Lean.Parser.Parser]]
[Lean.Lsp.TextEdit.range,[],[Lean.Lsp.Range]]
[instAndOpUInt8,[AndOp.mk, UInt8.land],[AndOp, UInt8]]
[lt_or_ge,[lt_or_le],[Or, LT.lt, GE.ge]]
[Lean.EnvironmentHeader.quotInit,[],[Bool]]
[WellFounded.fix,[WellFounded.fixF, WellFounded.apply],[]]
[Lean.MessageData.node.injEq,[Eq.propIntro, Eq.refl, Lean.MessageData.node, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MessageData.node]]
[Fin.shiftRight.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, HShiftRight.hShiftRight]]
[Lean.LocalContext.usesUserName,[Option.isSome, Lean.LocalContext.findFromUserName?],[Bool]]
[HMul.hMul,[],[]]
[Lean.Parser.checkStackTop,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.checkStackTopFn],[Lean.Parser.Parser]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.annotations,[],[Std.RBMap, Lean.PrettyPrinter.Delaborator.Pos, Lean.Options, Ord.compare]]
[Lean.Meta.SortLocalDecls.Context.noConfusionType,[],[]]
[Lean.Parser.Command.declModifiersT,[Lean.Parser.Command.declModifiers, Bool.true],[Lean.Parser.Parser]]
[Lean.IR.EmitC.paramEqArg,[Lean.IR.Arg.irrelevant, Bool, BEq.beq, Lean.IR.Param.x, Bool.false],[Bool]]
[Lean.Meta.addSimpLemmaEntry.updateLemmaNames,[Unit.unit, Std.PHashSet, Lean.Name, Lean.Meta.SimpLemma.name?, Std.PersistentHashSet.insert],[Std.PHashSet, Lean.Name]]
[Lean.Lsp.PlainTermGoalParams.mk.inj,[],[Eq]]
[Lean.IR.UnreachableBranches.Value.below,[PUnit, PProd],[]]
[Lean.JsonRpc.Response.noConfusionType,[],[]]
[List.reverseAux_reverseAux_nil,[rfl, of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.cons, List.reverseAux, eq_self],[Eq, List.reverseAux, List.nil]]
[Lean.Elab.Command.Scope.currNamespace,[],[Lean.Name]]
[Lean.Compiler.instBEqInlineAttributeKind,[BEq.mk, BEq.beq, Lean.Compiler.InlineAttributeKind.toCtorIdx],[BEq, Lean.Compiler.InlineAttributeKind]]
[Lean.Lsp.TextDocumentItem.languageId,[],[String]]
[or_and_distrib_left,[Iff.intro, And.intro, Or.inl, And.imp, Or.inr, Function.comp, imp_intro, Or.imp_right],[Iff, Or, And]]
[List.get?,[Nat.zero, List.nil, Nat.succ, Option, Option.some, PProd.fst, Option.none],[Option]]
[StateT.run_lift,[rfl],[Eq, StateT.run, StateT.lift, Bind.bind, Pure.pure, Prod.mk]]
[Lean.DataValue.ofBool.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.DataValue.ofBool, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.ExplicitBoxing.N,[StateM, Nat],[]]
[Lean.Parser.Tactic.«tactic_<;>[_]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false],[Lean.TrailingParserDescr]]
[List.mem_cons_iff,[Iff.rfl],[Iff, Mem.mem, List.cons, Or, Eq]]
[Lean.IR.FnBody.del.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.del, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.FnBody.del, And]]
[Lean.JsonRpc.instInhabitedRequestID,[Inhabited.mk, Lean.JsonRpc.RequestID.str, arbitrary],[Inhabited, Lean.JsonRpc.RequestID]]
[iff_iff_implies_and_implies,[Iff.intro, And.intro, Iff.mp, Iff.mpr, And.left, And.right],[Iff, And]]
[ulift.down_up,[rfl],[Eq, ulift.down, ulift.up]]
[Std.Format.getWidth,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Std.Format.defWidth],[Nat]]
[Lean.Expr.updateMData!.proof_1,[rfl],[Eq, Lean.Expr.isMData, Lean.Expr.mdata]]
[mul_mul_mul_comm,[of_eq_true, Eq.trans, congr, congrArg, Eq, mul_left_comm, HMul.hMul, mul_assoc, eq_self],[Eq, HMul.hMul]]
[Lean.Elab.Term.MutualClosure.ClosureState.localDecls,[],[Array, Lean.LocalDecl]]
[Lean.Elab.Command.getCurrMacroScope,[Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Command.Context.currMacroScope],[Lean.Elab.Command.CommandElabM, Nat]]
[commandGenIntDeclars__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[evalIntrov,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, GE.ge, Lean.Syntax.getNumArgs, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.Elab.Tactic.evalTactic, Lean.Elab.throwUnsupportedSyntax, evalIntrov.introsDep, evalIntrov.intro1PStep],[Lean.Elab.Tactic.Tactic]]
[Lean.instReprFVarId,[Repr.mk, Repr.reprPrec, Lean.FVarId.name],[Repr, Lean.FVarId]]
[Lean.Elab.Term.mkTypeMismatchError,[Bind.bind, liftM, Lean.Meta.mkHasTypeButIsExpectedMsg, Pure.pure, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.TermElabM, Lean.MessageData]]
[Eq.subst,[],[]]
[Lean.Lsp.SymbolKind.class.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.class, OfNat.ofNat]]
[Lean.Expr.ReplaceLevelImpl.cacheSize,[OfNat.ofNat],[USize]]
[String.dropWhile,[Substring.toString, Substring.dropWhile, String.toSubstring],[String]]
[Lean.Expr.applyFVarSubst,[Lean.Meta.FVarSubst.apply],[Lean.Expr]]
[UInt16.instSemiringUInt16,[Semiring.mk, UInt16.instSemiringUInt16.proof_1, UInt16.instSemiringUInt16.proof_2, UInt16.mk, Semiring.nsmul, UInt16.val, UInt16.instSemiringUInt16.proof_3, UInt16.instSemiringUInt16.proof_4, UInt16.instSemiringUInt16.proof_5, UInt16.instSemiringUInt16.proof_6, UInt16.instSemiringUInt16.proof_7, UInt16.instSemiringUInt16.proof_8, UInt16.instSemiringUInt16.proof_9, UInt16.instSemiringUInt16.proof_10, UInt16.instSemiringUInt16.proof_11, UInt16.instSemiringUInt16.proof_12, UInt16.instSemiringUInt16.proof_13],[Semiring, UInt16]]
[Lean.instQuoteList,[Lean.Quote.mk, Unit.unit, Lean.Syntax, Lean.mkCIdent, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.mkCApp, List.toArray, List.cons, Lean.Quote.quote, PProd.fst, List.nil],[Lean.Quote, List]]
[Lean.Expr.mvar.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.mvar, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Expr.mvar, And]]
[Lean.IR.NormalizeIds.normVar,[Functor.map, Lean.IR.VarId.mk, Lean.IR.NormalizeIds.normIndex, Lean.IR.VarId.idx],[Lean.IR.NormalizeIds.M, Lean.IR.VarId]]
[Lean.PrettyPrinter.Formatter.checkWsBefore.formatter,[Bind.bind, MonadState.get, ite, Eq, bne, Lean.PrettyPrinter.Formatter.State.leadWord, Bool.true, Lean.PrettyPrinter.Formatter.pushLine, Pure.pure, PUnit.unit],[Lean.PrettyPrinter.Formatter]]
[MonadExcept.orElse,[MonadExcept.tryCatch, Unit.unit],[]]
[Lean.Parser.doElemParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Parser.Parser]]
[«term_==_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Subarray.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Subarray.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.identNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.identFn],[Lean.Parser.Parser]]
[Tactic.Ring.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Tactic.Ring.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Tactic.Ring.State.mk, And]]
[Lean.Parser.LeadingIdentBehavior.noConfusion,[noConfusionEnum, Lean.Parser.LeadingIdentBehavior.toCtorIdx],[Lean.Parser.LeadingIdentBehavior.noConfusionType]]
[Lean.Meta.CaseArraySizesSubgoal.noConfusionType,[],[]]
[«term~~~_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Lsp.DocumentSymbolAux.children?,[],[Option, Array]]
[Lean.KVMap.instValueDataValue,[Lean.KVMap.Value.mk, id, Option.some],[Lean.KVMap.Value, Lean.DataValue]]
[Lean.Meta.instantiateMVars,[Lean.MonadCacheT.run, Lean.MetavarContext.instantiateExprMVars],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.CollectFVars.State.noConfusionType,[],[]]
[max_le,[dite, LT.lt, Eq.mpr, congrFun, congrArg, LE.le, if_pos, if_neg],[LE.le, max]]
[Array.insertionSort,[OfNat.ofNat, Array.size, Array.insertionSort.traverse, Array.insertionSort.swapLoop],[Array]]
[Mathlib.Tactic.Lint.LintVerbosity.noConfusion,[noConfusionEnum, Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx],[Mathlib.Tactic.Lint.LintVerbosity.noConfusionType]]
[Lean.Parser.ParserState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.ParserState.mk, And]]
[trans_rel_left,[],[]]
[Lean.Meta.trySynthInstance,[Lean.catchInternalId, Lean.Meta.isDefEqStuckExceptionId, toLOptionM, Lean.Meta.synthInstance?, Pure.pure, Lean.LOption.undef],[Lean.Meta.MetaM, Lean.LOption, Lean.Expr]]
[instRingFin.proof_1,[of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.sub_def, Fin.add_def, Fin.mk, HMod.hMod, HSub.hSub, Fin.val, instNegFin.proof_1, Fin.mk.injEq, HAdd.hAdd, Nat.mod_lt, Fin.size_positive, Nat.add_mod_mod, eq_self],[Eq, HSub.hSub, HAdd.hAdd, Fin.mk, HMod.hMod, Fin.val, instNegFin.proof_1]]
[Float.ofInt,[Float, Float.ofNat, Float.neg, Nat.succ],[Float]]
[Lean.Meta.RecursorInfo.indicesPos,[],[List, Nat]]
[Lean.getPPLetVarTypes,[Lean.KVMap.get, Lean.Option.name, Lean.pp.letVarTypes, Lean.getPPAll],[Bool]]
[Lean.Elab.Term.ToDepElimPattern.M,[StateRefT', IO.RealWorld, Lean.Elab.Term.ToDepElimPattern.State, Lean.Elab.Term.TermElabM],[]]
[calcStep,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary],[Lean.ParserDescr]]
[ByteArray.empty,[ByteArray.mkEmpty, OfNat.ofNat],[ByteArray]]
[Lean.Syntax.Traverser.mk.inj,[And.intro],[And, Eq]]
[Array.sequenceMap.loop,[dite, LT.lt, Array.size, Unit.unit, Array, Pure.pure, Bind.bind, Array.get, Fin.mk, PProd.fst, HAdd.hAdd, OfNat.ofNat, Array.push],[Array]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.mvars,[],[Array, Lean.Expr]]
[Lean.Elab.Tactic.pruneSolvedGoals,[Bind.bind, Lean.Elab.Tactic.getGoals, List.filterM, Functor.map, not, liftM, Lean.Meta.isExprMVarAssigned, Lean.Elab.Tactic.setGoals],[Lean.Elab.Tactic.TacticM, Unit]]
[GroupWithZero.toDivInvMonoid,[],[DivInvMonoid]]
[Lean.Lsp.SymbolKind.boolean.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.boolean, OfNat.ofNat]]
[«stx_,+,?»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[Lean.Parser.Command.openSimple,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.many1, HAndThen.hAndThen, Lean.Parser.checkColGt, Lean.Parser.ident],[Lean.Parser.Parser]]
[List.nil_subset,[False.elim, Iff.mp, List.mem_nil_iff],[Subset.subset, List.nil]]
[Lean.Parser.nameLit.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.nameLitKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.nameLitNoAntiquot.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[FloatSpec.lt,[],[]]
[Nat.add_zero,[rfl],[Eq, HAdd.hAdd, OfNat.ofNat]]
[IO.Process.Stdio.toHandleType,[Unit.unit, IO.FS.Handle, Unit],[]]
[IO.Error.interrupted.inj,[And.intro],[And, Eq]]
[Applicative.toFunctor,[],[Functor]]
[Lean.Parser.Term.doForDecl.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.termParser.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.withForbidden.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.State.levelNames,[],[List, Lean.Name]]
[Lean.Meta.SynthInstance.GeneratorNode.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SynthInstance.GeneratorNode.mk, HAdd.hAdd, OfNat.ofNat]]
[Tactic.TryThis.addTermSuggestion,[Bind.bind, Tactic.TryThis.delabToRefinableSyntax, Tactic.TryThis.addSuggestion],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Parser.Term.explicit.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[Lean.Expr.FoldConstsImpl.initCache.proof_1,[lcProof],[Eq, Unit, Lean.Expr]]
[Lean.PersistentEnvExtensionDescr.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PersistentEnvExtensionDescr.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PersistentEnvExtensionDescr.mk, And]]
[Lean.Elab.Term.elabIdent,[Bind.bind, List.nil, Bool.false, List.toArray, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.Elab.Term.TermElabM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Pure.pure, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError],[Lean.Elab.Term.TermElab]]
[Substring.toString,[String, String.extract],[String]]
[Lean.MonadBacktrack.restoreState,[],[Unit]]
[Lean.Core.instInhabitedState,[Inhabited.mk, Lean.Core.State.mk, arbitrary],[Inhabited, Lean.Core.State]]
[Lean.ScopedEnvExtension.descr,[],[Lean.ScopedEnvExtension.Descr]]
[Lean.Parser.Term.structInstLVal.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.ident.formatter, Lean.PrettyPrinter.Formatter.fieldIdx.formatter, Lean.Parser.Term.structInstArrayRef.formatter, Lean.Parser.many.formatter, Lean.Parser.group.formatter, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.SMap.size,[HAdd.hAdd, Std.HashMap.size, Lean.SMap.map₁, Std.PersistentHashMap.size, Lean.SMap.map₂],[Nat]]
[invImage.proof_1,[InvImage.wf, WellFoundedRelation.wf],[WellFounded, InvImage, WellFoundedRelation.rel]]
[Lean.IR.CtorFieldInfo.object.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.CtorFieldInfo.object, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.Do.ToTerm.Kind.nestedPRBC.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.ToTerm.Kind.nestedPRBC, OfNat.ofNat]]
[String.data,[],[List, Char]]
[UInt8.instNumericUInt8,[Numeric.mk, UInt8.mk, Numeric.ofNat],[Numeric, UInt8]]
[List.eq_nil_of_length_eq_zero,[rfl, False.elim, Eq.mp, Eq.trans, congrFun, congrArg, Eq, List.length_cons, OfNat.ofNat, eq_false'],[Eq, List.nil]]
[Lean.ConstructorVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ConstructorVal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ConstructorVal.mk, And]]
[Lean.Elab.Term.StructInst.Struct.modifyFields,[Id.run, Lean.Elab.Term.StructInst.Struct.modifyFieldsM],[Lean.Elab.Term.StructInst.Struct]]
[Lean.Elab.Command.Scope.openDecls,[],[List, Lean.OpenDecl]]
[Lean.Parser.Term.optIdent,[Lean.Parser.optional, Lean.Parser.atomic, HAndThen.hAndThen, Lean.Parser.Term.ident, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.resetTraceState,[Lean.MonadTrace.modifyTraceState, Lean.TraceState.mk],[Unit]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.nameNotRoundtrippable.containsNum,[Unit.unit, Bool, PProd.fst, Bool.true, Bool.false],[Bool]]
[Lean.Widget.formatInfos,[Bind.bind, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, Lean.MonadOptions.getOptions, Lean.Meta.instantiateMVars, Lean.PrettyPrinter.delabCore, Lean.Meta.MetaM, Prod, Std.Format, Std.RBMap, Nat, Lean.Elab.Info, Ord.compare, liftM, Lean.PrettyPrinter.parenthesizeTerm, Lean.PrettyPrinter.formatTerm, Pure.pure, Prod.mk, EmptyCollection.emptyCollection],[Lean.Meta.MetaM, Prod, Std.Format, Std.RBMap, Nat, Lean.Elab.Info, Ord.compare]]
[Lean.getLibDir,[ite, Eq, Unit.unit, Bool.true, Bind.bind, Pure.pure, PUnit.unit],[IO, System.FilePath]]
[Function.uncurry_curry,[funext, Eq, Function.uncurry, Function.curry, rfl],[Eq, Function.uncurry, Function.curry]]
[Lean.Elab.Term.LetIdDeclView.binders,[],[Array, Lean.Syntax]]
[StateT.failure,[Alternative.failure],[StateT]]
[Lean.Lsp.SemanticTokensParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.SemanticTokensParams.mk, HAdd.hAdd, OfNat.ofNat]]
[CommMonoid.mul_comm,[],[Eq, HMul.hMul]]
[Lean.mkStrLit,[Lean.mkLit, Lean.Literal.strVal],[Lean.Expr]]
[Lean.Parser.Tactic.nontriviality,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.simpArg],[Lean.ParserDescr]]
[Lean.ConstantInfo.recInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ConstantInfo.recInfo, HAdd.hAdd, OfNat.ofNat]]
[Tactic.LibrarySearch.librarySearch,[Bind.bind, Lean.MonadOptions.getOptions, Lean.profileitM, Lean.Exception, Lean.Meta.inferType, MonadState.get, MonadExcept.tryCatch, Lean.Meta.solveByElim, Pure.pure, DoResultPR.return, Option.none, PUnit.unit, MonadStateOf.set, DoResultPR.pure, Lean.Meta.MetaM, Option, Array, Prod, Lean.MetavarContext, List, Lean.MVarId],[Lean.Meta.MetaM, Option, Array, Prod, Lean.MetavarContext, List, Lean.MVarId]]
[Nat.mul_add,[Nat.left_distrib],[Eq, HMul.hMul, HAdd.hAdd]]
[Lean.PrettyPrinter.Delaborator.SubExpr.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.SubExpr.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PrettyPrinter.Delaborator.SubExpr.mk, And]]
[Lean.Parser.Tactic.injections',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[OptionT.bind,[OptionT.mk, Bind.bind, Unit.unit, Option, Pure.pure, Option.none],[OptionT]]
[Lean.Parser.Term.fun,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.maxPrec, HAndThen.hAndThen, Lean.Parser.unicodeSymbol, HOrElse.hOrElse, Lean.Parser.Term.basicFun, Lean.Parser.Term.matchAlts, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[UInt64.instRingUInt64.proof_4,[congrArg, UInt64.mk, SubNegMonoid.gsmul_neg', UInt64.val],[Eq, UInt64.mk, Ring.gsmul, Int.negSucc, UInt64.val]]
[Lean.Json.num.injEq,[Eq.propIntro, Eq.refl, Lean.Json.num, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Json.num]]
[Lean.Meta.shouldReduceReducibleOnly,[Bind.bind, Lean.Meta.getTransparency, Pure.pure, BEq.beq, Lean.Meta.TransparencyMode.reducible],[Lean.Meta.MetaM, Bool]]
[FloatSpec.val,[],[FloatSpec.float]]
[dite_false,[rfl],[Eq, dite, False, not_false]]
[Lean.IR.LocalContext.contains,[Std.RBMap.contains],[Bool]]
[Lean.MessageData.mkPPContext,[Lean.PPContext.mk, Lean.MessageDataContext.env, Lean.MessageDataContext.mctx, Lean.MessageDataContext.lctx, Lean.MessageDataContext.opts, Lean.NamingContext.currNamespace, Lean.NamingContext.openDecls],[Lean.PPContext]]
[ByteArray.foldlMUnsafe,[ite, LT.lt, LE.le, ByteArray.size, USize.ofNat, Pure.pure, ByteArray.foldlMUnsafe.fold],[]]
[Lean.PrettyPrinter.Formatter.concat,[Lean.PrettyPrinter.Formatter.fold, Array.foldl, Std.Format.nil, OfNat.ofNat, Array.size],[Lean.PrettyPrinter.FormatterM, Unit]]
[Lean.Meta.CheckAssignment.Context.hasCtxLocals,[],[Bool]]
[implies_true_iff,[Iff.intro, trivial],[Iff, True]]
[Lean.Parser.checkLineEq,[Lean.Parser.Parser.mk, Lean.Parser.checkLineEqFn],[Lean.Parser.Parser]]
[Lean.IR.JoinPointId.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.JoinPointId.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Simp.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Simp.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[ByteSlice.off,[],[Nat]]
[StdGen.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, StdGen.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, StdGen.mk, And]]
[IO.Error.hardwareFault.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.hardwareFault, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Tactic.Conv.evalConvSeq1Indented,[Lean.Elab.Tactic.evalTacticSeq1Indented],[Lean.Elab.Tactic.Tactic]]
[Lean.Parser.Term.attr.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.attrParser],[Lean.Parser.Parser]]
[Lean.Meta.AbstractMVars.State.emap,[],[Std.HashMap, Lean.MVarId, Lean.Expr]]
[List.range,[List.rangeAux, List.nil],[List, Nat]]
[Lean.Lsp.Command.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.Command.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Json.noConfusionType,[],[]]
[Lean.ConstantInfo.axiomInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ConstantInfo.axiomInfo, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.IRType.object.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.IR.IRType.object, OfNat.ofNat]]
[Lean.Quote.quote,[],[Lean.Syntax]]
[Lean.SMap.find?',[Option, Std.HashMap.find?, Option.orElse, Std.PersistentHashMap.find?],[Option]]
[IO,[EIO, IO.Error],[]]
[Lean.IR.Param.ty,[],[Lean.IR.IRType]]
[Lean.JsonRpc.instBEqNotification,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.JsonRpc.Notification]]
[Lean.Elab.Term.MutualClosure.LetRecClosure.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.MutualClosure.LetRecClosure.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.digitChar,[ite, Eq, OfNat.ofNat, Char.ofNat],[Char]]
[Eq.mp,[],[]]
[Lean.IR.Expr.lit.injEq,[Eq.propIntro, Eq.refl, Lean.IR.Expr.lit, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Expr.lit]]
[Lean.IR.instInhabitedVarIdSet,[Inhabited.mk, EmptyCollection.emptyCollection],[Inhabited, Lean.IR.VarIdSet]]
[Lean.Lsp.TextDocumentIdentifier.mk.inj,[],[Eq]]
[Lean.Level.imax.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Level.imax, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Level.imax, And]]
[Lean.MetavarContext.UnivMVarParamResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MetavarContext.UnivMVarParamResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MetavarContext.UnivMVarParamResult.mk, And]]
[Lean.Lsp.instFromJsonSemanticTokensLegend,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Array, String, Pure.pure, Lean.Lsp.SemanticTokensLegend.mk],[Lean.FromJson, Lean.Lsp.SemanticTokensLegend]]
[Lean.Meta.SynthInstance.GeneratorNode.noConfusionType,[],[]]
[Lean.Lsp.DidCloseTextDocumentParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.DidCloseTextDocumentParams.mk, HAdd.hAdd, OfNat.ofNat]]
[«term_<|_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[of_not_imp,[Decidable.of_not_imp],[]]
[Lean.MessageData.sbracket,[Lean.MessageData.bracket],[Lean.MessageData]]
[Function.right_inverse.comp_eq_id,[funext],[Eq, Function.comp, id]]
[Lean.PersistentEnvExtension.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PersistentEnvExtension.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PersistentEnvExtension.mk, And]]
[Lean.ExternEntry.foreign.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ExternEntry.foreign, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.substCore,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getMVarTag, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getLocalDecl, Lean.Meta.matchEq?, Lean.LocalDecl.type, Unit.unit, Lean.Meta.MetaM, Prod, Lean.Meta.FVarSubst, Lean.MVarId, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing, Lean.Meta.instantiateMVars, ite, Eq, Bool.true, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.FVarId.name, Pure.pure, PUnit.unit, Lean.indentExpr],[Lean.Meta.MetaM, Prod, Lean.Meta.FVarSubst, Lean.MVarId]]
[Lean.Parser.Command.declSig,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.many, Lean.Parser.ppSpace, HOrElse.hOrElse, Lean.Parser.Term.simpleBinderWithoutType, Lean.Parser.Term.bracketedBinder, Bool.false, Lean.Parser.Term.typeSpec],[Lean.Parser.Parser]]
[Lean.Parser.Tactic.simpRw,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[UInt64.mod,[UInt64.mk, HMod.hMod, UInt64.val],[UInt64]]
[Lean.MetavarContext.mkLambda,[Bind.bind, Lean.MetavarContext.mkBinding, Bool.true, Lean.MetavarContext.MkBindingM, Lean.Expr, Pure.pure],[Lean.MetavarContext.MkBindingM, Lean.Expr]]
[Lean.Parser.Tactic.injection,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.MonadMCtx.modifyMCtx,[],[Unit]]
[Lean.instReprDefinitionSafety,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone],[Repr, Lean.DefinitionSafety]]
[Lean.MessageData.group.inj,[],[Eq]]
[instReprInt,[Repr.mk, Std.Format.text, Int.repr],[Repr, Int]]
[Lean.IR.Borrow.InitParamMap.initBorrow,[Array.map, Lean.IR.Param.mk, Lean.IR.Param.x, Lean.IR.IRType.isObj, Lean.IR.Param.ty],[Array, Lean.IR.Param]]
[instRingFin.proof_3,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, Semiring.nsmul_succ', HAdd.hAdd, Semiring.nsmul, eq_self, propext, forall_const, Fin, Nat],[Eq, Semiring.nsmul, Nat.succ, HAdd.hAdd]]
[Lean.Widget.TaggedText.instRpcEncodingTaggedTextTaggedText,[Lean.Server.RpcEncoding.mk, Lean.Widget.TaggedText.mapM, Lean.Server.RpcEncoding.rpcEncode, Lean.Server.RpcEncoding.rpcDecode],[Lean.Server.RpcEncoding, Lean.Widget.TaggedText]]
[StateT.instAlternativeStateT,[Alternative.mk, StateT.failure, StateT.orElse],[Alternative, StateT]]
[Lean.Widget.InteractiveTermGoal.type,[],[Lean.Widget.CodeWithInfos]]
[Lean.mkLevelZeroEx,[Lean.levelZero],[Lean.Level]]
[Lean.Core.checkMaxHeartbeatsCore,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Pure.pure, PUnit.unit, Bind.bind, liftM, IO.getNumHeartbeats, MonadReader.read, GT.gt, HSub.hSub, Lean.Core.Context.initHeartbeats, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, HDiv.hDiv],[Lean.Core.CoreM, Unit]]
[Lean.Elab.Tactic.Conv.matchPattern?,[Lean.Meta.withNewMCtxDepth, Bind.bind, Lean.Meta.openAbstractMVarsResult, Lean.Meta.MetaM, Option, Prod, Lean.Expr, Array, Lean.Meta.withReducible, Lean.Elab.Tactic.Conv.matchPattern?.go?],[Lean.Meta.MetaM, Option, Prod, Lean.Expr, Array]]
[Lean.sanitizeNamesDefault,[Bool.true],[Bool]]
[Nat.eq_zero_of_le_zero,[Nat.le_antisymm, Nat.zero_le],[Eq, OfNat.ofNat]]
[Lean.Elab.Term.expandMatchAltsIntoMatchTactic,[Lean.withRef, Lean.MacroM, Lean.Syntax, ite, Eq, Bool.true, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.MonadQuotation.withFreshMacroScope, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, PProd.fst, Array.push, Array.size],[Lean.MacroM, Lean.Syntax]]
[Lean.Meta.SynthInstance.ConsumerNode.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SynthInstance.ConsumerNode.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SynthInstance.ConsumerNode.mk, And]]
[Lean.Elab.Term.Do.Code.break.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.Code.break, HAdd.hAdd, OfNat.ofNat]]
[Lean.Export.State.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.Simp.Step.done.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Simp.Step.done, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Simp.Step.done]]
[Lean.Export.State.names,[],[Lean.Export.Alloc, Lean.Name]]
[Lean.Elab.Term.StructInst.FieldLHS.fieldName.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.StructInst.FieldLHS.fieldName, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.StructInst.FieldLHS.fieldName, And]]
[List.map_map,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.map, List.map_nil, eq_self, List.nil, List.map_cons, List.cons, congrFun, Function.comp_apply, Function.comp],[Eq, List.map, Function.comp]]
[Fin.instModFin,[Mod.mk, Fin.mod],[Mod, Fin]]
[Lean.Meta.setMVarTag,[modify, Lean.Meta.State.mk, Lean.MetavarContext.renameMVar, Lean.Meta.State.mctx, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed],[Lean.Meta.MetaM, Unit]]
[Fin.land.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, Nat.land]]
[OptionT.instMonadLiftOptionT,[MonadLift.mk, OptionT.lift],[MonadLift, OptionT]]
[Lean.PrettyPrinter.Formatter.notFollowedBy.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Tactic.seq1.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.tacticParser.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer, Bool.true],[Lean.PrettyPrinter.Parenthesizer]]
[List.mem_remove_iff,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, List.mem_nil_iff, And, ne_eq, false_and, Not, Eq, eq_true_of_decide, Eq.refl, Bool.true, Eq.mpr, Mem.mem, ite, List.remove, List.cons, List.mem_cons_iff, Decidable.em, congrFun, if_pos, List, Or, Iff.intro, And.intro, Or.inr, Ne, Or.resolve_left, Eq.symm, if_neg, Or.inl, Ne.symm, And.left, And.right],[Iff, Mem.mem, List.remove, And, Ne]]
[List.pure,[List.cons, List.nil],[List]]
[Lean.Meta.Closure.mkBinding,[Nat.foldRev, Lean.Expr, ite, Eq, Bool.true, Lean.mkLambda, Lean.mkForall, Lean.Expr.hasLooseBVar, OfNat.ofNat, Lean.mkLet, Lean.Expr.lowerLooseBVars, Array.size],[Lean.Expr]]
[USize.mk_val_eq,[Eq, USize.mk, USize.val, rfl],[Eq, USize.mk, USize.val]]
[Lean.commitIfNoEx,[Bind.bind, Lean.MonadBacktrack.saveState, MonadExcept.tryCatch, Lean.MonadBacktrack.restoreState, MonadExcept.throw],[]]
[Lean.Elab.TacticInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.instToJsonSaveOptions,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.SaveOptions.includeText, List.nil],[Lean.ToJson, Lean.Lsp.SaveOptions]]
[Lean.Parser.Command.prefix.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[PSum.noConfusionType,[],[]]
[Lean.Meta.instInhabitedFVarSubst,[Inhabited.mk, Lean.Meta.FVarSubst.mk, arbitrary],[Inhabited, Lean.Meta.FVarSubst]]
[Lean.Widget.MsgEmbed.goal.injEq,[Eq.propIntro, Eq.refl, Lean.Widget.MsgEmbed.goal, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Widget.MsgEmbed.goal]]
[Lean.Parser.notSymbol.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.notFollowedBy.parenthesizer, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Tactic.measurability?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.IR.ExplicitBoxing.addBoxedVersions,[HAppend.hAppend],[Array, Lean.IR.Decl]]
[Lean.Meta.addSimpLemmaEntry,[ite, Eq, Lean.Meta.SimpLemma.post, Bool.true, Lean.Meta.SimpLemmas.mk, Lean.Meta.SimpLemmas.pre, Lean.Meta.DiscrTree.insertCore, Lean.Meta.SimpLemmas.post, Lean.Meta.SimpLemma.keys, Lean.Meta.SimpLemmas.lemmaNames, Lean.Meta.SimpLemmas.toUnfold, Lean.Meta.SimpLemmas.erased, Lean.Meta.addSimpLemmaEntry.updateLemmaNames],[Lean.Meta.SimpLemmas]]
[Prod.map_fst',[funext, Prod.map_fst],[Eq, Function.comp, Prod.fst, Prod.map]]
[Lean.Syntax.topDown,[Lean.Syntax.TopDown.mk],[Lean.Syntax.TopDown]]
[instToFormatList,[Std.ToFormat.mk, List.format],[Std.ToFormat, List]]
[Lean.Parser.Tactic.let'',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Parser.Level.hole.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.assignInfoHoleId,[Bind.bind, Lean.Elab.getInfoHoleIdAssignment?, ite, Eq, Option.isNone, Bool.true, Lean.Elab.MonadInfoTree.modifyInfoState, Lean.Elab.InfoState.mk, Lean.Elab.InfoState.enabled, Std.PersistentHashMap.insert, Lean.Elab.InfoState.assignment, Lean.Elab.InfoState.trees, panicWithPosWithDecl, OfNat.ofNat, HAppend.hAppend],[Unit]]
[Lean.KernelException.typeExpected.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KernelException.typeExpected, HAdd.hAdd, OfNat.ofNat]]
[List.groupBy,[Unit.unit, List, List.nil, List.groupByAux, List.cons],[List]]
[Lean.IR.VarId.mk.injEq,[Eq.propIntro, Eq.refl, Lean.IR.VarId.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.VarId.mk]]
[Lean.Elab.Command.State.ngen,[],[Lean.NameGenerator]]
[Std.RBNode.noConfusionType,[],[]]
[instDecidableRelLtLtOfOrd,[inferInstanceAs, DecidableRel, Eq, BEq.beq, Ord.compare, Ordering.lt, Bool.true],[DecidableRel, LT.lt]]
[Lean.Parser.Attr.externEntry,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.ident, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.strLit],[Lean.Parser.Parser]]
[Lean.Parser.Command.listUnusedDecls,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Meta.Match.Pattern.val.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.Pattern.val, HAdd.hAdd, OfNat.ofNat]]
[commandOfNat_class___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Lsp.SymbolKind.typeParameter.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.typeParameter, OfNat.ofNat]]
[Lean.Parser.Term.arrow.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.unicodeSymbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.IRType.uint16.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.IR.IRType.uint16, OfNat.ofNat]]
[Lean.Meta.SynthInstance.main,[Lean.Core.withCurrHeartbeats, Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Option, Lean.Meta.AbstractMVarsResult]]
[Array.instCoeSubarrayArray,[Coe.mk, Array.ofSubarray],[Coe, Subarray, Array]]
[MonadExcept.orelse',[MonadExcept.tryCatch, MonadExcept.throw, ite, Eq, Bool.true],[]]
[UInt16.instRingUInt16.proof_2,[congrArg, UInt16.mk, Ring.gsmul_zero', UInt16.val],[Eq, UInt16.mk, Ring.gsmul, OfNat.ofNat, UInt16.val]]
[ST.Ref.ref,[],[PointedType.type, ST.RefPointed]]
[Lean.instInhabitedFVarId,[Inhabited.mk, Lean.FVarId.mk, arbitrary],[Inhabited, Lean.FVarId]]
[Lean.Meta.InductionSubgoal.fields,[],[Array, Lean.Expr]]
[Lean.Meta.Closure.State.nextExprIdx,[],[Nat]]
[Lean.Parser.isQuotableCharDefault,[or, BEq.beq, Char.ofNat],[Bool]]
[List.exists_or_eq_self_of_erasep,[Classical.em, Exists, And, Mem.mem, Or, Eq, List.erasep, Not, HAppend.hAppend, List.cons, Or.inr, List.exists_of_erasep, Eq.symm, Or.inl, List.erasep_of_forall_not, Eq.mp, Eq.trans, propext, not_exists, forall_congr, not_and, Eq.refl],[Or, Eq, List.erasep, Exists, And, Not, HAppend.hAppend, List.cons]]
[Lean.IR.LitVal.str.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.LitVal.str, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.doMatch.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.generalizingParam.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.Term.matchDiscr.parenthesizer, Bool.false, Lean.Parser.Term.optType.parenthesizer, Lean.Parser.Term.doMatchAlts.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Server.Watchdog.FileWorker.proc,[],[IO.Process.Child, Lean.Server.Watchdog.workerCfg]]
[Lean.Meta.Simp.Config.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.Match.State.counterExamples,[],[List, Lean.Meta.Match.Example]]
[Lean.Parser.Term.waitIfContainsMVar.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.EmitC.argToCString,[Lean.IR.Arg.irrelevant, String, ToString.toString],[String]]
[Lean.Parser.LeadingIdentBehavior.default.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Parser.LeadingIdentBehavior.default, OfNat.ofNat]]
[EmptyCollection.noConfusionType,[],[]]
[ByteArray.foldlM.proof_1,[Nat.le_refl, ByteArray.size],[LE.le, ByteArray.size]]
[Lean.Elab.Term.Do.Code.action.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.Do.Code.action, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.Code.action]]
[Lean.Meta.occursCheck,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.occursCheck],[Lean.Meta.MetaM, Bool]]
[Lean.Elab.Term.SavedContext.options,[],[Lean.Options]]
[Lean.Server.Watchdog.ServerEvent.workerEvent.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.Watchdog.ServerEvent.workerEvent, HAdd.hAdd, OfNat.ofNat]]
[Lean.LocalContext.find?,[Std.PersistentHashMap.find?, Lean.LocalContext.fvarIdToDecl],[Option, Lean.LocalDecl]]
[Lean.KeyedDeclsAttribute.addBuiltin,[ST.Ref.modify, Lean.KeyedDeclsAttribute.tableRef, Unit.unit, Lean.KeyedDeclsAttribute.Table, Lean.SMap.find?, Lean.KeyedDeclsAttribute.OLeanEntry.key, Lean.KeyedDeclsAttribute.AttributeEntry.toOLeanEntry, Lean.SMap.insert, List.cons, List.nil, Lean.KeyedDeclsAttribute.AttributeEntry.mk, Lean.KeyedDeclsAttribute.OLeanEntry.mk],[IO, Unit]]
[exists_apply_eq_apply,[Exists.intro, rfl],[Exists, Eq]]
[coeM,[Bind.bind, Pure.pure, coe],[]]
[MonadStateOf.modifyGet,[],[]]
[Lean.IR.mkJmp,[Lean.IR.FnBody.jmp],[Lean.IR.FnBody]]
[Lean.Elab.Deriving.Repr.mkReprInstanceHandler,[Bind.bind, Array.allM, Lean.isInductive, OfNat.ofNat, Array.size, ite, Eq, and, Decidable.decide, GT.gt, Bool.true, Lean.Elab.Command.liftTermElabM, Option.none, Lean.Elab.Deriving.mkContext, Array.getOp, Lean.Elab.Deriving.Repr.mkMutualBlock, Lean.Elab.Deriving.mkInstanceCmds, Lean.Name.mkStr, Lean.Name.anonymous, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Array.forM, Lean.Elab.Command.elabCommand, Bool.false],[Lean.Elab.Command.CommandElabM, Bool]]
[Lean.IR.ExpandResetReuse.isSelfSet,[Lean.IR.Arg.irrelevant, Bool, Option.none, Option.some, Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.fap, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Std.HashMap.find?, Lean.IR.ExpandResetReuse.Context.projMap, and, BEq.beq, Bool.false],[Bool]]
[Lean.Lsp.ServerCapabilities.mk.inj,[And.intro],[And, Eq]]
[Lean.Core.instMonadNameGeneratorCoreM,[Lean.MonadNameGenerator.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Core.State.ngen, modify, Lean.Core.State.mk, Lean.Core.State.env, Lean.Core.State.nextMacroScope, Lean.Core.State.traceState],[Lean.MonadNameGenerator, Lean.Core.CoreM]]
[Lean.Elab.Term.PatternVarDecl.anonymousVar.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.PatternVarDecl.anonymousVar, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.PatternVarDecl.anonymousVar, And]]
[Lean.Meta.instantiateLocalDeclMVars,[Lean.Meta.MetaM, Lean.LocalDecl, Bind.bind, Lean.Meta.instantiateMVars, Pure.pure, Lean.LocalDecl.cdecl, Lean.LocalDecl.ldecl],[Lean.Meta.MetaM, Lean.LocalDecl]]
[UInt16.instAddCommSemigroupUInt16.proof_1,[congrArg, UInt16.mk, AddCommSemigroup.add_comm, UInt16.val],[Eq, UInt16.mk]]
[Lean.Expr.hash,[Lean.Expr.Data.hash, Lean.Expr.data],[UInt64]]
[Lean.mkApp6,[Lean.mkAppB, Lean.mkApp4],[Lean.Expr]]
[Lean.extractMacroScopes,[Unit.unit, Lean.MacroScopesView, Lean.Name.hasMacroScopes, Lean.Name.anonymous, PProd.fst, List.cons, Lean.Name.str, Lean.Name.num, BEq.beq, Lean.MacroScopesView.mk, Lean.Name, Lean.Name.mkStr, Lean.Name.mkNum, panic, List.nil],[Lean.MacroScopesView]]
[Lean.Server.Watchdog.initAndRunWatchdogAux,[Bind.bind, MonadReader.read, MonadExcept.tryCatch, Functor.discard, liftM, IO.FS.Stream.readLspNotificationAs, Lean.Server.Watchdog.ServerContext.hIn, Lean.Lsp.InitializedParams, Lean.Server.Watchdog.runClientTask, Lean.Server.Watchdog.mainLoop, Lean.Server.Watchdog.shutdown, MonadExcept.throw, IO.FS.Stream.readLspMessage, Pure.pure, Lean.JsonRpc.Message.notification, Option.none],[Lean.Server.Watchdog.ServerM, Unit]]
[Lean.MacroScopesView.review,[Unit.unit, Lean.Name, Lean.MacroScopesView.scopes, Lean.MacroScopesView.name, List.foldl, Lean.Name.mkNum],[Lean.Name]]
[Lean.DeclarationRange.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.DeclarationRange.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.DeclarationRange.mk, And]]
[Lean.Parser.Term.num.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.numLit.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.PrettyPrinter.Formatter.sepBy1NoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.sepByNoAntiquot.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.DefaultInstances.priorities,[],[Lean.Meta.PrioritySet]]
[Lean.Parser.Tactic.equivRw,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Parser.Term.haveDecl.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.haveIdDecl.formatter, Lean.Parser.Term.letPatDecl.formatter, Lean.Parser.Term.haveEqnsDecl.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Set.instEmptyCollectionSet,[EmptyCollection.mk, Eq, Bool.false, Bool.true],[EmptyCollection, Set]]
[min_eq_left_of_lt,[min_eq_left, le_of_lt],[Eq, min]]
[Nat.max,[ite, LE.le],[Nat]]
[Lean.RecursorVal.getFirstMinorIdx,[HAdd.hAdd, Lean.RecursorVal.numParams, Lean.RecursorVal.numMotives],[Nat]]
[String.toList,[String.data],[List, Char]]
[Nat.coprime.mul_right,[Nat.coprime.symm, Nat.coprime.mul],[Nat.coprime, HMul.hMul]]
[Std.PersistentArray.foldrM,[Bind.bind, Array.foldrM, Std.PersistentArray.tail, Array.size, OfNat.ofNat, Std.PersistentArray.root],[]]
[Lean.Parser.Command.openSimple.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.many1.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkColGt.formatter, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Command.ctor.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declModifiers.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.inferMod.parenthesizer, Lean.Parser.Command.optDeclSig.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Command.getBracketedBinderIds,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, List.toArray, List.nil, List.cons, Lean.Syntax.getId],[Array, Lean.Name]]
[Lean.Lsp.instFromJsonSemanticTokensRangeParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Range, Pure.pure, Lean.Lsp.SemanticTokensRangeParams.mk],[Lean.FromJson, Lean.Lsp.SemanticTokensRangeParams]]
[System.FilePath.noConfusionType,[],[]]
[Lean.Parser.ParserContext.resolveName,[Lean.ResolveName.resolveGlobalName, Lean.Parser.ParserModuleContext.env, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserModuleContext.currNamespace, Lean.Parser.ParserModuleContext.openDecls],[List, Prod, Lean.Name, String]]
[Lean.Parser.Tactic.tacticInfer_instance,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.ToJson.noConfusionType,[],[]]
[UInt64.toNat,[Fin.val, UInt64.val],[Nat]]
[Lean.Meta.introNCore,[Bind.bind, Lean.Meta.getHygienicIntro, ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Pure.pure, Prod.mk, List.toArray, List.nil, Lean.Meta.withMVarContext, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType, Lean.MonadLCtx.getLCtx, Lean.Meta.MetaM, Prod, Array, Lean.FVarId, Lean.MVarId, Array.map, Lean.Expr.fvarId!, Unit.unit, Lean.Name, List, and, not, List.cons, bne, Lean.Name.mkSimple, liftM, Lean.Core.mkFreshUserName, Lean.LocalContext.getUnusedName],[Lean.Meta.MetaM, Prod, Array, Lean.FVarId, Lean.MVarId]]
[ReprTuple.reprTuple,[],[List, Std.Format]]
[ByteArray.forIn.loop,[Pure.pure],[]]
[Lean.Elab.levelMVarToParamPreDecls,[StateRefT'.run', Array.mapM, Bind.bind, Lean.Elab.Term.levelMVarToParam', Lean.Elab.PreDefinition.type, Lean.Elab.PreDefinition.value, Pure.pure, Lean.Elab.PreDefinition.mk, Lean.Elab.PreDefinition.ref, Lean.Elab.PreDefinition.kind, Lean.Elab.PreDefinition.levelParams, Lean.Elab.PreDefinition.modifiers, Lean.Elab.PreDefinition.declName, OfNat.ofNat],[Lean.Elab.Term.TermElabM, Array, Lean.Elab.PreDefinition]]
[Lean.IR.EmitC.emitFileFooter,[Lean.IR.EmitC.emitLns, List.cons, List.nil],[Lean.IR.EmitC.M, Unit]]
[Lean.PrettyPrinter.Parenthesizer.dbgTraceState.parenthesizer,[],[Lean.PrettyPrinter.Parenthesizer]]
[Substring.foldl,[String.foldlAux],[]]
[Function.inv_fun_comp,[funext, Function.left_inverse_inv_fun],[Eq, Function.comp, Function.inv_fun, id]]
[LawfulMonad.pure_bind,[],[Eq, Bind.bind, Pure.pure]]
[Function.inv_fun_on_eq,[And.right, Function.inv_fun_on_pos],[Eq, Function.inv_fun_on]]
[Substring.trimRight,[Substring.dropRightWhile, Char.isWhitespace],[Substring]]
[Lean.IR.Checker.getType,[Bind.bind, MonadReader.read, Unit.unit, Lean.IR.Checker.M, Lean.IR.IRType, Lean.IR.LocalContext.getType, Lean.IR.Checker.CheckerContext.localCtx, Pure.pure, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.IR.Checker.M, Lean.IR.IRType]]
[Function.bijective_iff_exists_unique,[Iff.intro, ExistsUnique, Eq, Exists.intro, And.intro, Function.bijective.injective, Eq.trans, Eq.symm, unique_of_exists_unique, rfl, ExistsUnique.exists],[Iff, Function.bijective, ExistsUnique, Eq]]
[Lean.ImportState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ImportState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.QuotKind.noConfusion,[noConfusionEnum, Lean.QuotKind.toCtorIdx],[Lean.QuotKind.noConfusionType]]
[ForM.noConfusionType,[],[]]
[Lean.Parser.Tactic.generalizeProofs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.binderIdent, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[instDecidableOr,[Decidable, Or, Decidable.isTrue, Or.inl, Or.inr, Decidable.isFalse, instDecidableOr.proof_1],[Decidable, Or]]
[StateCpsT.runK_monadLift,[rfl],[Eq, StateCpsT.runK, MonadLiftT.monadLift, Bind.bind]]
[unexpandListCons,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Array.size_push,[List.length_concat, Array.data],[Eq, Array.size, Array.push, HAdd.hAdd, OfNat.ofNat]]
[List.mem_map_of_injective,[Iff.intro, Mem.mem, List.mem_map_of_mem],[Iff, Mem.mem, List.map]]
[decidableLt_of_decidableLe.proof_1,[not_le_of_gt],[False]]
[max_eq_right_of_lt,[max_eq_right, le_of_lt],[Eq, max]]
[Lean.instFromJsonString,[Lean.FromJson.mk, Lean.Json.getStr?],[Lean.FromJson, String]]
[instBEq,[BEq.mk, Decidable.decide, Eq],[BEq]]
[Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.term,[],[Lean.Syntax]]
[Lean.SMap.empty,[Lean.SMap.mk],[Lean.SMap]]
[Lean.Meta.ReduceMatcherResult.partialApp.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.ReduceMatcherResult.partialApp, OfNat.ofNat]]
[Lean.Parser.Tactic.unfoldProjs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.PrettyPrinter.Parenthesizer.sepBy1NoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.sepByNoAntiquot.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Widget.Lean.Widget.InteractiveHypothesis.instFromJsonRpcEncodingPacket,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Array, String, Lean.Widget.TaggedText, Option, Bool, Pure.pure],[Lean.FromJson]]
[Lean.PrettyPrinter.Parenthesizer.interpretParserDescr,[Lean.Core.CoreM, Lean.PrettyPrinter.Parenthesizer, liftM, Lean.Parser.getConstAlias, Lean.PrettyPrinter.Parenthesizer.parenthesizerAliasesRef, Bind.bind, Lean.Parser.getUnaryAlias, Lean.PrettyPrinter.Parenthesizer.interpretParserDescr, Pure.pure, Lean.Parser.getBinaryAlias, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.Parser.sepBy.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Lean.ParserCompiler.CombinatorAttribute.runDeclFor, Lean.PrettyPrinter.combinatorParenthesizerAttribute, Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer],[Lean.Core.CoreM, Lean.PrettyPrinter.Parenthesizer]]
[Lean.Name.mangle,[HAppend.hAppend, Unit.unit, String, Lean.Name.str, Lean.Name.num, PProd.fst, ToString.toString],[String]]
[Lean.Elab.Visibility.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.IR.EmitC.emitBoxFn,[Unit.unit, Lean.IR.IRType.uint8, Lean.IR.IRType.uint16, Lean.IR.IRType.irrelevant, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.struct, Lean.IR.IRType.union, Lean.IR.EmitC.M, Unit, Lean.IR.EmitC.emit],[Lean.IR.EmitC.M, Unit]]
[Array.partition,[Id.run, Bind.bind, ForIn.forIn, MProd.mk, ite, Eq, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, Id, Prod, Array, Prod.mk],[Prod, Array]]
[Lean.ParserCompiler.CombinatorAttribute.runDeclFor,[Bind.bind, Lean.MonadEnv.getEnv, Option.none, Lean.Core.CoreM, Lean.ParserCompiler.CombinatorAttribute.getDeclFor?, Lean.evalConst, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.AttributeImplCore.name, Lean.AttributeImpl.toAttributeImplCore, Lean.ParserCompiler.CombinatorAttribute.impl],[Lean.Core.CoreM]]
[Lean.Meta.SynthInstance.tryResolve,[Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.withMCtx, liftM, Lean.Meta.SynthInstance.tryResolveCore],[Lean.Meta.SynthInstance.SynthM, Option, Prod, Lean.MetavarContext, List, Lean.Expr]]
[Lean.IR.Arg.irrelevant.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.IR.Arg.irrelevant, OfNat.ofNat]]
[Int.ofNat_mul_subNatNat,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HMul.hMul, Int.ofNat, Nat.zero_eq, Int.ofNat_zero, Int.subNatNat, Int.zero_mul, Nat.zero_mul, Int.sub_nat_self, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true, Eq.symm],[Eq, HMul.hMul, Int.ofNat, Int.subNatNat]]
[Lean.instInhabitedClosedTermCache,[Inhabited.mk, Lean.ClosedTermCache.mk, arbitrary],[Inhabited, Lean.ClosedTermCache]]
[Lean.Widget.MsgEmbed.noConfusionType,[],[]]
[And.imp_left,[And.imp, id],[And]]
[Lean.MonadLCtx.noConfusionType,[],[]]
[Lean.Elab.Term.toParserDescr.resolveParserName,[Bind.bind, MonadExcept.tryCatch, Lean.Elab.resolveGlobalConstWithInfos, Option.none, Lean.MonadEnv.getEnv, Pure.pure, List.filterMap, Unit.unit, Option, Prod, Lean.Name, Bool, Lean.Environment.find?, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Name.anonymous, Lean.Name.str, dite, Eq, Eq.symm, Lean.Name.num, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.ConstantInfo.type, Option.some, Prod.mk, Bool.false, Bool.true, DoResultPR.pure, PUnit.unit, DoResultPR.return, List.nil, Lean.Elab.Term.ToParserDescrM, List],[Lean.Elab.Term.ToParserDescrM, List, Prod, Lean.Name, Bool]]
[Lean.IR.UnreachableBranches.inferStep,[Bind.bind, MonadReader.read, modify, Lean.IR.UnreachableBranches.InterpState.mk, Array.map, EmptyCollection.emptyCollection, Lean.IR.UnreachableBranches.InterpContext.decls, Lean.IR.UnreachableBranches.InterpState.funVals, Nat.foldM, Lean.IR.UnreachableBranches.M, Bool, Array.getOp, MonadState.get, MonadWithReader.withReader, Lean.IR.UnreachableBranches.InterpContext.mk, Lean.IR.UnreachableBranches.InterpContext.env, Lean.IR.UnreachableBranches.InterpContext.lctx, Array.forM, Lean.IR.UnreachableBranches.updateVarAssignment, Lean.IR.Param.x, Lean.IR.UnreachableBranches.Value.top, OfNat.ofNat, Array.size, Lean.IR.UnreachableBranches.interpFnBody, Pure.pure, or, bne, Bool.false],[Lean.IR.UnreachableBranches.M, Bool]]
[SubNegMonoid.noConfusionType,[],[]]
[Lean.ClosedTermCache.noConfusionType,[],[]]
[Lean.Server.FileWorker.EditableDocument.meta,[],[Lean.Server.DocumentMeta]]
[Lean.PrettyPrinter.Parenthesizer,[Lean.PrettyPrinter.ParenthesizerM, Unit],[]]
[Nat.mod_self,[Eq.mpr, Eq.refl, Eq, HMod.hMod, OfNat.ofNat, Nat.mod_eq_sub_mod, Nat.le_refl, HSub.hSub, Nat.sub_self, Nat.zero_mod, rfl],[Eq, HMod.hMod, OfNat.ofNat]]
[Equiv.self_comp_symm,[funext, Equiv.apply_symm_apply],[Eq, Function.comp, Equiv.toFun, Equiv.symm, id]]
[Lean.DefinitionVal.noConfusionType,[],[]]
[EStateM.map,[EStateM.Result, EStateM.Result.ok, EStateM.Result.error],[EStateM]]
[Lean.Lsp.DocumentHighlightParams.mk.inj,[],[Eq]]
[Lean.Elab.Term.StructInst.Struct.fields,[Lean.Elab.Term.StructInst.Fields],[Lean.Elab.Term.StructInst.Fields]]
[Lean.IR.Checker.markIndex,[Bind.bind, MonadState.get, ite, Eq, Std.RBTree.contains, Lean.IR.Checker.CheckerState.foundVars, Bool.true, MonadExcept.throw, HAppend.hAppend, ToString.toString, Pure.pure, PUnit.unit],[Lean.IR.Checker.M, Unit]]
[Lean.MetavarContext.addExprMVarDeclExp,[Lean.MetavarContext.addExprMVarDecl, OfNat.ofNat],[Lean.MetavarContext]]
[Lean.collectFVars,[Lean.CollectFVars.main],[Lean.CollectFVars.State]]
[Lean.Elab.Term.elabLetDeclCore,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Elab.Term.elabLetDeclAux, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, List.nil, Lean.Elab.Term.withMacroExpansion, Lean.Elab.Term.elabTerm, Lean.Elab.liftMacroM, Lean.Elab.Term.expandLetEqnsDecl, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Prod.forall,[Iff.intro, Prod.mk],[Iff, Prod.mk]]
[Lean.Parser.ParserCategory.behavior,[],[Lean.Parser.LeadingIdentBehavior]]
[Lean.Meta.forEachExpr,[Lean.Meta.forEachExpr', Bind.bind, Pure.pure, Bool.true],[Lean.Meta.MetaM, Unit]]
[Lean.Server.FileWorker.SemanticTokensState.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.noMatch,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.const, Bool.false],[Lean.ParserDescr]]
[Lean.Parser.Term.borrowed,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.leadPrec],[Lean.Parser.Parser]]
[Lean.Elab.Term.Do.Code.ite.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.tacticDestruct_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Subtype.forall,[Iff.intro, Subtype.mk],[Iff, Subtype.mk]]
[Std.PersistentHashMap.instInhabitedEntry,[Inhabited.mk, Std.PersistentHashMap.Entry.null],[Inhabited, Std.PersistentHashMap.Entry]]
[Lean.Level.PP.Result.offset.inj,[And.intro],[And, Eq]]
[Lean.Meta.GeneralizeTelescope.Entry.type,[],[Lean.Expr]]
[instMonadControlT_1,[MonadControlT.mk, Pure.pure],[MonadControlT]]
[Lean.Lsp.RpcKeepAliveParams.noConfusionType,[],[]]
[Int.negOfNat_mul_negSucc_ofNat,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Int.negOfNat, Int.negSucc, Int.ofNat, Nat.succ, Int.mul_comm, Int.negSucc_ofNat_mul_negOfNat, Nat.mul_comm, rfl],[Eq, HMul.hMul, Int.negOfNat, Int.negSucc, Int.ofNat, Nat.succ]]
[Lean.MessageData.ofArray,[Lean.MessageData.ofList, Array.toList],[Lean.MessageData]]
[Lean.Compiler.SpecArgKind.noConfusionType,[noConfusionTypeEnum, Lean.Compiler.SpecArgKind.toCtorIdx],[]]
[Lean.Parser.withOpenDeclFn,[ite, GT.gt, Array.size, Lean.Parser.ParserState.stxStack, OfNat.ofNat, Lean.Parser.withOpenDeclFnCore],[Lean.Parser.ParserFn]]
[UInt16.land,[UInt16.mk, Fin.land, UInt16.val],[UInt16]]
[Lean.IR.Decl.expandResetReuse,[Lean.IR.Decl.normalizeIds, Lean.IR.ExpandResetReuse.main],[Lean.IR.Decl]]
[List.append'_eq_append,[Eq, List.append', HAppend.hAppend, rfl, of_eq_true, Eq.trans, congr, congrArg, List.cons, PProd.fst, List.cons_append, eq_self],[Eq, List.append', HAppend.hAppend]]
[Lean.Elab.throwAutoBoundImplicitLocal,[MonadExcept.throw, Lean.Exception.internal, Lean.Elab.autoBoundImplicitExceptionId, Lean.KVMap.insert, Lean.KVMap.empty, Lean.Name.mkStr, Lean.Name.anonymous, Lean.DataValue.ofName],[]]
[Lean.Meta.Simp.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Simp.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Simp.Context.mk, And]]
[Lean.Elab.Tactic.evalTacticSeq,[Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Elab.Tactic.Tactic]]
[Function.surjective_iff_has_right_inverse,[Iff.intro, Function.surjective.has_right_inverse, Function.has_right_inverse.surjective],[Iff, Function.surjective, Function.has_right_inverse]]
[List.disjoint_of_subset_left,[],[List.disjoint]]
[Lean.Elab.Command.StructCtorView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Command.StructCtorView.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.notFollowedByCategoryTokenFn,[Unit.unit, Lean.Parser.ParserState, Lean.Parser.getCategory, Lean.Parser.ParserState.mkUnexpectedError, HAppend.hAppend, ToString.toString, List.nil, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, ite, Eq, and, Decidable.decide, GT.gt, Lean.Parser.ParserContext.quotDepth, OfNat.ofNat, BEq.beq, Bool.true, Option.none, Std.RBMap.find?, Lean.Parser.PrattParsingTables.leadingTable, Lean.Parser.ParserCategory.tables, Lean.Name.mkSimple],[Lean.Parser.ParserFn]]
[Lean.LocalInstance.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.LocalInstance.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.LocalInstance.mk, And]]
[Lean.Elab.Term.SavedState.meta,[],[Lean.Meta.SavedState]]
[Lean.Occurrences.isAll,[Unit.unit, Lean.Occurrences.pos, Lean.Occurrences.neg, Bool, Bool.true, Bool.false],[Bool]]
[Lean.IR.ExplicitBoxing.boxArgsIfNeeded,[Bind.bind, Lean.IR.ExplicitBoxing.castArgsIfNeededAux, Lean.IR.IRType.object, Lean.IR.ExplicitBoxing.M, Lean.IR.FnBody, Pure.pure, Lean.IR.reshape],[Lean.IR.ExplicitBoxing.M, Lean.IR.FnBody]]
[instInhabitedList,[Inhabited.mk, List.nil],[Inhabited, List]]
[instToBoolOption,[ToBool.mk, Option.toBool],[ToBool, Option]]
[Lean.PrettyPrinter.Delaborator.instAlternativeDelabM,[Alternative.mk, Lean.PrettyPrinter.Delaborator.failure, Lean.PrettyPrinter.Delaborator.orElse],[Alternative, Lean.PrettyPrinter.Delaborator.DelabM]]
[Equiv.perm,[Equiv],[]]
[Lean.Elab.Term.getLetRecsToLift,[Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Term.State.letRecsToLift],[Lean.Elab.Term.TermElabM, List, Lean.Elab.Term.LetRecToLift]]
[IO.FS.lines,[Bind.bind, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.false, List.toArray, List.nil, IO.FS.lines.read],[IO, Array, String]]
[Lean.KernelException.typeExpected.inj,[And.intro],[And, Eq]]
[Lean.Syntax.ident.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Syntax.ident, HAdd.hAdd, OfNat.ofNat]]
[Nat.coprime_comm,[Iff.intro, Nat.coprime.symm],[Iff, Nat.coprime]]
[Lean.IR.Borrow.collectExpr,[Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Lean.IR.Borrow.M, Unit, SeqRight.seqRight, Lean.IR.Borrow.ownVar, Lean.IR.Borrow.ownArgsIfParam, Bind.bind, Lean.IR.Borrow.isOwned, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.IR.Borrow.getParamInfo, Lean.IR.Borrow.ParamMap.Key.decl, Lean.IR.Borrow.ownArgsUsingParams, Lean.IR.Borrow.ownArgs, Unit.unit],[Lean.IR.Borrow.M, Unit]]
[Lean.Server.FileWorker.initializeWorker,[Bind.bind, Lean.Server.FileWorker.compileHeader, IO, Prod, Lean.Server.FileWorker.WorkerContext, Lean.Server.FileWorker.WorkerState, Lean.Server.FileWorker.CancelToken.new, Lean.Server.FileWorker.unfoldCmdSnaps, Bool.true, Pure.pure, Prod.mk, Lean.Server.FileWorker.WorkerState.mk, Std.RBMap.empty],[IO, Prod, Lean.Server.FileWorker.WorkerContext, Lean.Server.FileWorker.WorkerState]]
[Lean.Parser.ParserContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.ParserContext.mk, And]]
[plift.noConfusionType,[],[]]
[Lean.IR.IRType.uint64.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.IR.IRType.uint64, OfNat.ofNat]]
[Int.decEq.proof_2,[absurd],[False]]
[Lean.Parser.scientificLitFn,[ite, Eq, and, not, Lean.Parser.ParserState.hasError, Lean.Syntax.isOfKind, Array.back, Lean.Parser.ParserState.stxStack, Lean.scientificLitKind, Bool.true, Lean.Parser.ParserState.mkErrorAt, Option.some],[Lean.Parser.ParserFn]]
[AddCommMonoid.toAddMonoid,[],[AddMonoid]]
[System.FilePath.withExtension,[Unit.unit, System.FilePath, System.FilePath.fileStem, System.FilePath.withFileName, ite, Eq, String.isEmpty, Bool.true, HAppend.hAppend],[System.FilePath]]
[ST,[EST, Empty],[]]
[Lean.KeyedDeclsAttribute.OLeanEntry.noConfusionType,[],[]]
[Lean.Meta.withNewBinderInfos,[Lean.Meta.mapMetaM, Bind.bind, Lean.MonadLCtx.getLCtx, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.localInstances, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth],[]]
[«term-_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[mul_right_inj,[Iff.intro, mul_left_cancel, congrArg, HMul.hMul],[Iff, Eq, HMul.hMul]]
[Int.eq_zero_ofNatAbs_eq_zero,[Eq, OfNat.ofNat, congr_arg, Int.ofNat, absurd, Nat.succ_ne_zero],[Eq, OfNat.ofNat]]
[AddMonoid.nsmul_succ',[],[Eq, AddMonoid.nsmul, Nat.succ, HAdd.hAdd]]
[Set.instMemSet,[Mem.mk, Set.mem],[Mem, Set]]
[Lean.Meta.mkHEq,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getLevel, Pure.pure, Lean.mkApp4, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[instLTNat,[LT.mk, Nat.lt],[LT, Nat]]
[tacticAnyGoals_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Decidable.eq_or_ne,[dec_em, Eq],[Or, Eq, Ne]]
[Int.decEq.proof_1,[rfl],[Eq, Int.ofNat]]
[Lean.Elab.Attribute.name,[],[Lean.Name]]
[Subsingleton.elim.proof_1,[Subsingleton.allEq],[Eq]]
[instModUInt16,[Mod.mk, UInt16.mod],[Mod, UInt16]]
[Lean.Parser.Tactic.Conv.convSkip,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.IR.ExplicitRC.VarInfo.consume,[],[Bool]]
[Lean.Meta.SavedState.noConfusionType,[],[]]
[Lean.Meta.getMatcherInfoCore?,[Lean.Meta.Match.Extension.getMatcherInfo?],[Option, Lean.Meta.Match.MatcherInfo]]
[Lean.Meta.IndPredBelow.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.IndPredBelow.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.IndPredBelow.Context.mk, And]]
[Function.surjective.of_comp_iff',[Iff.intro, Exists, Eq, Exists.intro, Function.bijective.injective, Function.surjective.comp, Function.bijective.surjective],[Iff, Function.surjective, Function.comp]]
[Lean.Core.CoreM.run',[Functor.map, Prod.fst, Lean.Core.CoreM.run],[EIO, Lean.Exception]]
[Int.instCommRingInt,[CommRing.mk, Int.mul_comm],[CommRing, Int]]
[Lean.MetavarContext.getLevelAssignment?,[Std.PersistentHashMap.find?, Lean.MetavarContext.lAssignment],[Option, Lean.Level]]
[Lean.Meta.withConfig,[Lean.Meta.mapMetaM, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.lctx, Lean.Meta.Context.localInstances, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth],[]]
[Lean.Elab.Term.StructInst.ExplicitSourceInfo.stx,[],[Lean.Syntax]]
[List.leftpad_suffix,[Exists.intro, List.repeat, HSub.hSub, List.length, rfl],[List.isSuffix, List.leftpad]]
[USize.instSemiringUSize.proof_10,[rfl],[Eq, Nat.succ]]
[fix2,[fixCore2, arbitrary],[]]
[Lean.MetavarContext.UnivMVarParamResult.noConfusionType,[],[]]
[And.assoc,[Iff.intro, And, And.intro],[Iff, And]]
[exists_congr,[Iff.intro, exists_imp_exists, Iff.mp, Iff.mpr],[Iff, Exists]]
[Int.natAbs_pos_of_ne_zero,[Or.resolve_left, Nat.eq_zero_or_pos, Int.natAbs, mt, Int.eq_zero_ofNatAbs_eq_zero],[LT.lt, OfNat.ofNat, Int.natAbs]]
[Fin.nsmuls_eq,[Eq, HMul.hMul, Fin.ofNat', Fin.size_positive', Fin.val, Fin.eq_of_val_eq, Eq.mpr, congrFun, congrArg, Fin.mul_def, Fin.mk, HMod.hMod, Nat.mod_lt, Eq.refl, Eq.symm, Nat.mod_eq_of_lt, Nat.mul_mod, rfl],[Eq, HMul.hMul, Fin.ofNat', Fin.size_positive', Fin.val]]
[USize.ofNat32,[USize.mk, Fin.mk, USize.ofNat32.proof_1],[USize]]
[Lean.Widget.exprToInteractiveExplicit,[Bind.bind, Lean.Widget.formatExplicitInfos, Lean.Meta.MetaM, Lean.Widget.CodeWithInfos, Lean.MonadEnv.getEnv, Lean.MonadMCtx.getMCtx, Lean.MonadOptions.getOptions, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, Pure.pure, Lean.Widget.tagExprInfos],[Lean.Meta.MetaM, Lean.Widget.CodeWithInfos]]
[Lean.Parser.Tactic.guardExprEq,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Std.ShareCommonT.run,[StateT.run', Std.ShareCommon.State.empty],[]]
[Lean.IR.Borrow.applyParamMap,[Lean.IR.Borrow.ApplyParamMap.visitDecls],[Array, Lean.IR.Decl]]
[Lean.Lsp.DiagnosticSeverity.noConfusion,[noConfusionEnum, Lean.Lsp.DiagnosticSeverity.toCtorIdx],[Lean.Lsp.DiagnosticSeverity.noConfusionType]]
[LinearOrder.decidable_le,[],[DecidableRel, LE.le]]
[Equiv.inv_fun_as_coe,[rfl],[Eq, Equiv.invFun, Equiv.toFun, Equiv.symm]]
[Lean.Elab.Tactic.run,[Lean.Meta.withMVarContext, Bind.bind, MonadState.get, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, List.nil, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState, tryFinally, Functor.map, Prod.fst, StateRefT'.run, Lean.Elab.Tactic.Context.mk, Lean.Name.anonymous, Lean.Elab.Tactic.State.mk, List.cons],[Lean.Elab.Term.TermElabM, List, Lean.MVarId]]
[Lean.Meta.NormNum.isNat_rawNat,[rfl],[Lean.Meta.NormNum.isNat]]
[instModUInt64,[Mod.mk, UInt64.mod],[Mod, UInt64]]
[HOr.noConfusionType,[],[]]
[Lean.getPPAnalyze,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze, Lean.Option.defValue],[Bool]]
[List.erasep_append_right,[Eq, List.erasep, HAppend.hAppend, rfl, of_eq_true, Eq.trans, congr, congrArg, List.cons_append, List.erasep_cons_of_neg, Not, eq_false, And.left, Iff.mp, List.forall_mem_cons, eq_true_of_decide, Eq.refl, Bool.true, List.cons, PProd.fst, And.right, eq_self],[Eq, List.erasep, HAppend.hAppend]]
[Lean.Meta.AbstractMVars.M,[StateM, Lean.Meta.AbstractMVars.State],[]]
[Lean.ScopedEnvExtension.popScope,[List.nil, List.cons, Lean.Environment, Lean.ScopedEnvExtension.StateStack.stateStack, Lean.PersistentEnvExtension.setState, Lean.ScopedEnvExtension.ext, Lean.ScopedEnvExtension.StateStack.mk, Lean.ScopedEnvExtension.StateStack.scopedEntries, Lean.ScopedEnvExtension.StateStack.newEntries],[Lean.Environment]]
[Decidable.not_imp_symm,[Decidable.by_contradiction, Function.comp],[]]
[IO.Error.noSuchThing.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.noSuchThing, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Tactic.SavedState.term,[],[Lean.Elab.Term.SavedState]]
[Nat.le_add_right,[LE.le, HAdd.hAdd, Nat.le_refl, Nat.le_succ_of_le, PProd.fst],[LE.le, HAdd.hAdd]]
[Lean.Meta.FVarSubst.get,[Unit.unit, Lean.Expr, Std.AssocList.find?, Lean.Meta.FVarSubst.map, Lean.mkFVar],[Lean.Expr]]
[Lean.PrettyPrinter.Delaborator.ParamKind.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PrettyPrinter.Delaborator.ParamKind.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.abel,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Meta.DiscrTree.mkPath,[Lean.Meta.withReducible, Lean.Meta.DiscrTree.mkPathAux, Bool.true, Array.push],[Lean.Meta.MetaM, Array, Lean.Meta.DiscrTree.Key]]
[Function.right_id,[rfl],[Eq, Function.comp, id]]
[PSigma.skipLeft,[WellFoundedRelation.mk, PSigma.SkipLeft, WellFoundedRelation.rel, PSigma.skipLeft.proof_1],[WellFoundedRelation, PSigma]]
[Lean.Parser.ParserModuleContext.currNamespace,[],[Lean.Name]]
[Lean.Elab.Tactic.liftMetaTacticAux,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Elab.Tactic.TacticM, Lean.Elab.Tactic.replaceMainGoal, Pure.pure],[Lean.Elab.Tactic.TacticM]]
[Lean.IR.Borrow.OwnedSet.Key,[Prod, Lean.IR.FunId, Lean.IR.Index],[]]
[IO.FS.Mode.append.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.Mode.append, OfNat.ofNat]]
[Lean.BinderInfo.hash,[Unit.unit, UInt64, OfNat.ofNat],[UInt64]]
[WellFoundedRelation.mk.inj,[],[Eq]]
[Lean.mkAppRev,[Array.foldr, Lean.mkApp, Array.size, OfNat.ofNat],[Lean.Expr]]
[coeSort,[CoeSort.coe],[]]
[Lean.Parser.ParserState.pushSyntax,[Lean.Parser.ParserState.mk, Array.push, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.pos, Lean.Parser.ParserState.cache, Lean.Parser.ParserState.errorMsg],[Lean.Parser.ParserState]]
[Lean.Elab.isValidAutoBoundLevelName,[Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Bool, and, Decidable.decide, GT.gt, String.length, OfNat.ofNat, Char.isLower, String.getOp, Substring.all, Substring.drop, String.toSubstring, or, Char.isDigit, Lean.isSubScriptAlnum, BEq.beq, Char.ofNat, Bool.false],[Bool]]
[Lean.Meta.CongrArgKind.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Parser.PrattParsingTables.trailingTable,[],[Lean.Parser.TokenMap, Prod, Lean.Parser.Parser, Nat]]
[Lean.Parser.Command.printAxioms.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.doElemParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.instFromJsonName,[Lean.FromJson.mk, Bind.bind, Lean.Json.getStr?, ite, Eq, BEq.beq, Bool.true, Pure.pure, Lean.Name.anonymous, Lean.Syntax.decodeNameLit, HAppend.hAppend, Option.none, Except, String, Lean.Name, MonadExcept.throw, ToString.toString],[Lean.FromJson, Lean.Name]]
[Std.ShareCommon.ObjectSet.insert,[Std.HashSet.insert],[Std.ShareCommon.ObjectSet]]
[Lean.Parser.Command.attribute.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.eraseAttr.parenthesizer, Lean.Parser.Term.attrInstance.parenthesizer, Bool.false, Lean.Parser.many1.parenthesizer, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.CompletionInfo.endSection.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.CompletionInfo.endSection, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.CompletionInfo.endSection, And]]
[Lean.Parser.Tactic.acRfl,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Meta.State.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.DefKind.example.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.DefKind.example, OfNat.ofNat]]
[Nat.zero_mul,[Unit.unit, Eq, HMul.hMul, OfNat.ofNat, rfl, Eq.symm, PProd.fst, Nat.mul_succ],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Parser.Term.doFor.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.Term.doForDecl.parenthesizer, Bool.false, Lean.Parser.Term.doSeq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Frontend.setCommandState,[modify, Lean.Elab.Frontend.State.mk, Lean.Elab.Frontend.State.parserState, Lean.Elab.Frontend.State.cmdPos, Lean.Elab.Frontend.State.commands],[Lean.Elab.Frontend.FrontendM, Unit]]
[repr,[Repr.reprPrec, OfNat.ofNat],[Std.Format]]
[Lean.Lsp.instFromJsonDiagnosticWith,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.Range, Option, Lean.Lsp.DiagnosticSeverity, Lean.Lsp.DiagnosticCode, String, Array, Lean.Lsp.DiagnosticTag, Lean.Lsp.DiagnosticRelatedInformation, Pure.pure, Lean.Lsp.DiagnosticWith.mk],[Lean.FromJson, Lean.Lsp.DiagnosticWith]]
[Lean.Meta.Cases.Context.majorDecl,[],[Lean.LocalDecl]]
[Lean.FileMap.ofString,[OfNat.ofNat, List.toArray, List.cons, List.nil, Lean.FileMap.ofString.loop],[Lean.FileMap]]
[Inter.inter,[],[]]
[Lean.Parser.Term.let.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.letDecl.formatter, Lean.Parser.Term.optSemicolon.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[StateT.pure,[Pure.pure, Prod.mk],[StateT]]
[Lean.Parser.Term.letIdDecl.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Term.letIdLhs.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Expr.Data.hasLevelParam,[BEq.beq, UInt64.land, UInt64.shiftRight, OfNat.ofNat],[Bool]]
[Lean.PrefixTreeNode.ibelow,[And, True],[]]
[Lean.Lsp.instFromJsonMarkupContent,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.MarkupKind, String, Pure.pure, Lean.Lsp.MarkupContent.mk],[Lean.FromJson, Lean.Lsp.MarkupContent]]
[Std.instInhabitedPersistentArrayNode,[Inhabited.mk, Std.PersistentArrayNode.node, arbitrary],[Inhabited, Std.PersistentArrayNode]]
[HAnd.hAnd,[],[]]
[Lean.JsonRpc.Message.responseError.inj,[And.intro],[And, Eq]]
[tryCatchThe,[MonadExceptOf.tryCatch],[]]
[Lean.Parser.Tactic.intro,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Meta.ParamInfo.isImplicit,[BEq.beq, Lean.Meta.ParamInfo.binderInfo, Lean.BinderInfo.implicit],[Bool]]
[Lean.Lsp.DocumentSymbolParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DocumentSymbolParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.DocumentSymbolParams.mk]]
[List.replicate,[List.nil, List.replicate.loop],[List]]
[Lean.Expr.updateLet!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateLet, Lean.Expr.letE, Lean.Expr.updateLet!.proof_1, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[Lean.hasConst,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Environment.contains],[Bool]]
[Lean.Server.FileWorker.RpcSession.keepAliveTimeMs,[OfNat.ofNat],[Nat]]
[Lean.Elab.Command.instInhabitedElabHeaderResult,[Inhabited.mk, Lean.Elab.Command.ElabHeaderResult.mk, arbitrary],[Inhabited, Lean.Elab.Command.ElabHeaderResult]]
[Lean.TagDeclarationExtension.instInhabitedTagDeclarationExtension,[inferInstanceAs, Inhabited, Lean.SimplePersistentEnvExtension, Lean.Name, Lean.NameSet],[Inhabited, Lean.TagDeclarationExtension]]
[ByteSlice.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.ParamInfo.isStrictImplicit,[BEq.beq, Lean.Meta.ParamInfo.binderInfo, Lean.BinderInfo.strictImplicit],[Bool]]
[Lean.Elab.Tactic.evalDelta,[Bind.bind, Lean.resolveGlobalConstNoOverload, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.withLocation, Lean.Elab.Tactic.deltaLocalDecl, Lean.Elab.Tactic.deltaTarget, liftM, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Syntax.missing],[Lean.Elab.Tactic.Tactic]]
[Lean.Elab.Level.instAddMessageContextLevelElabM,[Lean.AddMessageContext.mk, Pure.pure],[Lean.AddMessageContext, Lean.Elab.Level.LevelElabM]]
[Lean.EnumAttributes.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.EnumAttributes.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.expandBrackedBindersAux,[Array.size, Lean.expandBrackedBindersAux.loop],[Lean.MacroM, Lean.Syntax]]
[Option.toMonad,[Unit.unit, Alternative.failure, Pure.pure],[]]
[Std.ShareCommon.mkObjectPersistentSet,[Std.PersistentHashSet.empty],[Std.ShareCommon.ObjectPersistentSet]]
[instDecidableIte,[Decidable, ite],[Decidable, ite]]
[Lean.PersistentExprMap,[Std.PHashMap, Lean.Expr],[]]
[Lean.Compiler.SpecEntry.cache.inj,[And.intro],[And, Eq]]
[Lean.DeclarationRange.noConfusionType,[],[]]
[Lean.Meta.Closure.mkValueTypeClosureAux,[Bind.bind, liftM, Lean.Meta.resetZetaFVarIds, Lean.Meta.withTrackingZeta, Lean.Meta.Closure.collectExpr, Lean.Meta.Closure.process, Pure.pure, Prod.mk],[Lean.Meta.Closure.ClosureM, Prod, Lean.Expr]]
[Lean.Syntax.getAtomVal!,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, String, panicWithPosWithDecl, OfNat.ofNat],[String]]
[Nat.le_of_succ_le_succ,[Nat.pred_le_pred],[LE.le]]
[Lean.Elab.ContextInfo.fileMap,[],[Lean.FileMap]]
[Lean.Parser.Command.declId.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Expr.FindImpl.initCache.proof_1,[lcProof],[Eq, Unit, Lean.Expr]]
[Nat.eq_zero_of_zero_dvd,[Exists.elim, Eq.trans, Nat.zero_mul],[Eq, OfNat.ofNat]]
[min_assoc,[eq_min, le_trans, min_le_left, min, le_min, min_le_right],[Eq, min]]
[npow_eq_pow,[rfl],[Eq, Monoid.npow, HPow.hPow]]
[Lean.Exception.error.inj,[And.intro],[And, Eq]]
[Lean.HeadIndex.sort.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.HeadIndex.sort, OfNat.ofNat]]
[USize.instNumericUSize,[Numeric.mk, USize.mk, Numeric.ofNat],[Numeric, USize]]
[MonadControlT.stM,[],[]]
[Lean.Meta.Match.Extension.Entry.info,[],[Lean.Meta.Match.MatcherInfo]]
[Mathlib.Tactic.Ext.«termExtProof%»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.instMonadMCtx,[Lean.MonadMCtx.mk, liftM, Lean.MonadMCtx.getMCtx, Lean.MonadMCtx.modifyMCtx],[Lean.MonadMCtx]]
[Lean.Parser.withAntiquotSpliceAndSuffix.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquotSplice.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withoutInfo.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquotSuffixSplice.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[instDecidableArrow,[dite, Decidable.isTrue, instDecidableArrow.proof_1, Decidable.isFalse, instDecidableArrow.proof_2, instDecidableArrow.proof_3],[Decidable]]
[Lean.Elab.getPrintMessageEndPos,[Lean.KVMap.getBool, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false],[Bool]]
[Lean.Core.instInhabitedCoreM,[Inhabited.mk, MonadExcept.throw, arbitrary],[Inhabited, Lean.Core.CoreM]]
[Lean.Meta.instInhabitedParamInfo,[Inhabited.mk, Lean.Meta.ParamInfo.mk, arbitrary],[Inhabited, Lean.Meta.ParamInfo]]
[Tactic.Cache,[IO.Ref, Sum, Lean.Meta.MetaM, Task, Except, Lean.Exception],[]]
[Lean.Elab.Term.LetIdDeclView.id,[],[Lean.Syntax]]
[Equivalence.noConfusionType,[],[]]
[Lean.mkMapDeclarationExtension,[Lean.registerSimplePersistentEnvExtension, Lean.SimplePersistentEnvExtensionDescr.mk, Lean.NameMap.insert, Prod.fst, Prod.snd, EmptyCollection.emptyCollection, Array.qsort, List.toArray, Lean.Name.quickLt, OfNat.ofNat, HSub.hSub, Array.size],[IO, Lean.MapDeclarationExtension]]
[HEq.symm,[HEq.ndrecOn, HEq.refl],[HEq]]
[Lean.IR.UnreachableBranches.InterpState.funVals,[],[Std.PArray, Lean.IR.UnreachableBranches.Value]]
[PSum.inr.inj,[],[Eq]]
[Lean.CollectMVars.Visitor,[Lean.CollectMVars.State],[]]
[Lean.Lsp.TextDocumentEdit.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.TextDocumentEdit.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.Quotation.MatchResult.covered.inj,[And.intro],[And, Eq]]
[Lean.Meta.SimpLemma.post,[],[Bool]]
[Lean.Parser.Tactic.eapply,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.TagAttribute.getDecls,[Id.run, Bind.bind, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield],[Array, Lean.Name]]
[Array.foldlM.proof_1,[Nat.le_refl, Array.size],[LE.le, Array.size]]
[Lean.Parser.ParserCategory.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.ParserCategory.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Simp.simp.withNewLemmas,[Bind.bind, Lean.Meta.Simp.getConfig, ite, Eq, Lean.Meta.Simp.Config.contextual, Bool.true, Lean.Meta.Simp.getSimpLemmas, ForIn.forIn, MProd.mk, liftM, Lean.Meta.isProof, Lean.Meta.SimpLemmas.add, List.toArray, List.nil, Bool.false, OfNat.ofNat, Option.none, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Meta.Simp.M, Lean.Meta.Simp.withSimpLemmas],[Lean.Meta.Simp.M]]
[Lean.Parser.Command.omit,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[«term_*>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Elab.Term.elabChoice,[Bind.bind, List.nil, Bool.false, List.toArray, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.Elab.Term.TermElabM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Pure.pure, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError],[Lean.Elab.Term.TermElab]]
[Fin.mul_def,[Eq, HMul.hMul, Fin.mk, HMod.hMod, Fin.val, Nat.mod_lt, Fin.size_positive, rfl],[Eq, HMul.hMul, Fin.mk, HMod.hMod, Fin.val, Nat.mod_lt, Fin.size_positive]]
[ExistsUnique.elim,[Exists.elim, And.left, And.right],[]]
[Lean.Json.instToJsonStructured,[Lean.ToJson.mk, Lean.Json, Lean.Json.arr, Lean.Json.obj],[Lean.ToJson, Lean.Json.Structured]]
[Lean.Elab.Command.StructFieldKind.noConfusion,[noConfusionEnum, Lean.Elab.Command.StructFieldKind.toCtorIdx],[Lean.Elab.Command.StructFieldKind.noConfusionType]]
[Lean.JsonNumber.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.Hover.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.throwPostpone,[MonadExcept.throw, Lean.Exception.internal, Lean.Elab.postponeExceptionId, Lean.KVMap.mk],[]]
[Lean.Meta.getElimInfo,[Bind.bind, Lean.getConstInfo, Lean.Meta.forallTelescopeReducing, Lean.ConstantInfo.type, ite, Eq, and, Lean.Expr.isFVar, Array.all, OfNat.ofNat, Array.size, Decidable.decide, GT.gt, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr],[Lean.Meta.MetaM, Lean.Meta.ElimInfo]]
[Lean.Parser.PrattParsingTables.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.PrattParsingTables.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.PrattParsingTables.mk, And]]
[Lean.IR.Checker.getDecl,[Bind.bind, MonadReader.read, Unit.unit, Lean.IR.Checker.M, Lean.IR.Decl, Lean.IR.findEnvDecl', Lean.IR.Checker.CheckerContext.env, Lean.IR.Checker.CheckerContext.decls, MonadExcept.throw, HAppend.hAppend, ToString.toString, Pure.pure],[Lean.IR.Checker.M, Lean.IR.Decl]]
[Lean.Xml.Content.Character.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Xml.Content.Character, HAdd.hAdd, OfNat.ofNat]]
[Tactic.Ring.instInhabitedHornerExpr,[Inhabited.mk, Tactic.Ring.HornerExpr.const, Lean.mkRawNatLit, OfNat.ofNat],[Inhabited, Tactic.Ring.HornerExpr]]
[instMonadState,[MonadState.mk, getThe, MonadStateOf.set, MonadStateOf.modifyGet],[MonadState]]
[Lean.ReducibilityHints.regular.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ReducibilityHints.regular, HAdd.hAdd, OfNat.ofNat]]
[EStateM.tryCatch,[EStateM.Result.ok, EStateM.Result, EStateM.Backtrackable.restore],[EStateM]]
[Lean.Parser.tacticParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Formatter]]
[Lean.Widget.Lean.Widget.InteractiveGoals.instToJsonRpcEncodingPacket,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil],[Lean.ToJson]]
[Classical.choose,[Subtype.val, Classical.indefiniteDescription],[]]
[imp_or_distrib,[Decidable.imp_or_distrib],[Iff, Or]]
[Lean.Parser.Module.header.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Module.prelude.formatter, Lean.ppLine.formatter, Lean.Parser.many.formatter, Lean.Parser.Module.import.formatter],[Lean.PrettyPrinter.Formatter]]
[UInt16.add_def,[rfl],[Eq, HAdd.hAdd, UInt16.mk, UInt16.val]]
[ExceptCpsT.runCatch_lift,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, bind_pure, eq_self],[Eq, ExceptCpsT.runCatch, ExceptCpsT.lift]]
[Lean.Elab.Term.BinderView.id,[],[Lean.Syntax]]
[Array.foldrM,[dite, LE.le, Array.size, ite, LT.lt, Pure.pure, Nat.le_refl, Array.foldrM.fold],[]]
[Lean.Elab.Term.LetRecToLift.declName,[],[Lean.Name]]
[Lean.PLevelSet,[Lean.PersistentLevelSet],[]]
[Lean.Elab.Tactic.Conv.updateLhs,[Bind.bind, Lean.Elab.Tactic.Conv.getRhs, liftM, Lean.Meta.mkEq, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.mkLHSGoal, Lean.Name.anonymous, Lean.Elab.Tactic.getMainGoal, Lean.Meta.mkEqTrans, Lean.Meta.assignExprMVar, Lean.Elab.Tactic.replaceMainGoal, List.cons, Lean.Expr.mvarId!, List.nil],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.Parser.Term.dbgTrace.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.interpolatedStr.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Lean.Parser.Term.optSemicolon.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.instToStringRecursorUnivLevelPos,[ToString.mk, Unit.unit, String, ToString.toString],[ToString, Lean.Meta.RecursorUnivLevelPos]]
[Lean.Level.Data.depth,[UInt64.toUInt32, UInt64.shiftRight, OfNat.ofNat],[UInt32]]
[Lean.Parser.Command.namespace.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Command.check_failure.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.SynthInstance.addAnswer,[Bind.bind, MonadReader.read, ite, GE.ge, Lean.Meta.SynthInstance.ConsumerNode.size, Lean.Meta.SynthInstance.Context.maxResultSize, Lean.traceM, Lean.Name.mkStr, Lean.Name.anonymous, liftM, Lean.Meta.inferType, Lean.Meta.SynthInstance.ConsumerNode.mvar, Pure.pure, HAppend.hAppend, Lean.ToMessageData.toMessageData, Unit.unit, Lean.Meta.withMCtx, Lean.Meta.SynthInstance.ConsumerNode.mctx, Lean.Meta.instantiateMVars, Lean.isTracingEnabledFor, Eq, Bool.true, Lean.addTrace, PUnit.unit, Lean.Meta.SynthInstance.getEntry, Lean.Meta.SynthInstance.isNewAnswer, Lean.Meta.SynthInstance.TableEntry.answers, modify, Lean.Meta.SynthInstance.State.mk, Lean.Meta.SynthInstance.State.result?, Lean.Meta.SynthInstance.State.generatorStack, Lean.Meta.SynthInstance.State.resumeStack, Std.HashMap.insert, Lean.Meta.SynthInstance.State.tableEntries, Array.forM, Lean.Meta.SynthInstance.wakeUp, Lean.Meta.SynthInstance.TableEntry.waiters, OfNat.ofNat, Array.size],[Lean.Meta.SynthInstance.SynthM, Unit]]
[Lean.Compiler.NumScalarTypeInfo.noConfusionType,[],[]]
[Lean.Meta.InjectionResultCore.subgoal.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.InjectionResultCore.subgoal, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.InjectionResultCore.subgoal, And]]
[List.enumFrom,[List, Prod, Nat, List.nil, List.cons, Prod.mk, PProd.fst, HAdd.hAdd, OfNat.ofNat],[List, Prod, Nat]]
[Lean.Literal.natVal.injEq,[Eq.propIntro, Eq.refl, Lean.Literal.natVal, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Literal.natVal]]
[instSemiringFin,[Semiring.mk, instSemiringFin.proof_6, HMul.hMul, Fin.ofNat', Fin.size_positive, instSemiringFin.proof_7, instSemiringFin.proof_8, instSemiringFin.proof_9, instSemiringFin.proof_10, instSemiringFin.proof_11, instSemiringFin.proof_12, instSemiringFin.proof_13, instSemiringFin.proof_14],[Semiring, Fin]]
[Lean.Level.succ.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Level.succ, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.MonadInfoTree.getInfoState,[],[Lean.Elab.InfoState]]
[Lean.Lsp.SymbolKind.property.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.property, OfNat.ofNat]]
[instMonadLiftSTEST,[MonadLift.mk, EStateM.Result, EStateM.Result.ok],[MonadLift, ST, EST]]
[Lean.Server.FileWorker.instCoeErrorElabTaskError,[Coe.mk, Lean.Server.FileWorker.ElabTaskError.ioError],[Coe, IO.Error, Lean.Server.FileWorker.ElabTaskError]]
[List.toStringAux,[Bool.false, Bool.true, String, HAppend.hAppend, ToString.toString, PProd.fst],[String]]
[Lean.Meta.elimMVarDeps,[ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Lean.Meta.liftMkBindingM, Lean.MetavarContext.elimMVarDeps],[Lean.Meta.MetaM, Lean.Expr]]
[List.map_eq_nil,[Iff.intro, rfl, Eq.symm, Eq.refl, Eq.mpr, Eq, List.map, List.nil],[Iff, Eq, List.map, List.nil]]
[Lean.Parser.Command.inferMod.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.InstanceEntry.noConfusionType,[],[]]
[Lean.Parser.FirstTokens.optTokens.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.FirstTokens.optTokens, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.SemanticTokensParams.textDocument,[],[Lean.Lsp.TextDocumentIdentifier]]
[Lean.Widget.CodeToken.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Widget.CodeToken.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Widget.CodeToken.mk]]
[Lean.mkLevelMVarEx,[Lean.mkLevelMVar],[Lean.Level]]
[Std.AssocList.insert,[Std.AssocList.cons],[Std.AssocList]]
[Lean.StructureInfo.structName,[],[Lean.Name]]
[Lean.PrettyPrinter.Unexpander,[Lean.PrettyPrinter.UnexpandM, Lean.Syntax],[]]
[Lean.IR.args.alphaEqv,[Array.isEqv, Lean.IR.AlphaEqv.aeqv],[Bool]]
[Lean.JsonRpc.Request.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonRpc.Request.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.JsonRpc.Request.mk, And]]
[Lean.Elab.adaptMacro,[Lean.Elab.liftMacroM],[Lean.Syntax]]
[UInt8.mod_def,[rfl],[Eq, HMod.hMod, UInt8.mk, UInt8.val]]
[Lean.Compiler.mkNatLt,[Lean.mkAppN, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.levelZero, List.nil, List.toArray],[Lean.Expr]]
[Mathlib.Tactic.Lint.formatLemmas,[Bind.bind, Array.mapM, Lean.mkConstWithLevelParams, Pure.pure, Lean.ToMessageData.toMessageData],[Lean.Core.CoreM, Lean.MessageData]]
[Array.getLit.proof_1,[Eq.symm],[LT.lt, Array.size]]
[Mathlib.Tactic.Lint.printWarning,[Bind.bind, Lean.mkConstWithLevelParams, Pure.pure, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Core.CoreM, Lean.MessageData]]
[Std.PersistentArray.instAppendPersistentArray,[Append.mk, Std.PersistentArray.append],[Append, Std.PersistentArray]]
[Classical.typeDecidable,[PSum, False, Classical.propDecidable, Nonempty, PSum.inl, arbitrary, PSum.inr, Classical.typeDecidable.proof_1],[PSum, False]]
[instReprTupleProd,[ReprTuple.mk, List, Std.Format, ReprTuple.reprTuple, List.cons, repr],[ReprTuple, Prod]]
[Lean.Lsp.DiagnosticCode.int.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DiagnosticCode.int, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.DiagnosticCode.int]]
[Lean.Lsp.instToJsonProgressParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.ProgressParams.token, List.nil, Lean.Lsp.ProgressParams.value],[Lean.ToJson, Lean.Lsp.ProgressParams]]
[Lean.Lsp.PlainTermGoalParams.noConfusionType,[],[]]
[Lean.Widget.TaggedText.text.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Widget.TaggedText.text, HAdd.hAdd, OfNat.ofNat]]
[FloatArray.foldlM,[dite, LE.le, FloatArray.size, FloatArray.foldlM.proof_1],[]]
[Lean.IR.FnBody.inc.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.inc, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.FnBody.inc, And]]
[Lean.Meta.ReduceMatcherResult.reduced.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.ReduceMatcherResult.reduced, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.ReduceMatcherResult.reduced]]
[Lean.Meta.SynthInstance.Waiter.noConfusionType,[],[]]
[Lean.Server.FileWorker.RefIdent.fvar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.FileWorker.RefIdent.fvar, HAdd.hAdd, OfNat.ofNat]]
[Lean.HeadIndex.const.injEq,[Eq.propIntro, Eq.refl, Lean.HeadIndex.const, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.HeadIndex.const]]
[Lean.Parser.Command.eraseAttr.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.rawIdent.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Term.fromTerm.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.Match.MatchEqns.eqnNames,[],[Array, Lean.Name]]
[Lean.Elab.Term.Do.ToTerm.Kind.nestedBC.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.ToTerm.Kind.nestedBC, OfNat.ofNat]]
[Lean.Lsp.Position.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.Position.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.FileMap.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.elabSorry,[Bind.bind, Lean.Elab.logWarning, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom, Lean.Elab.Term.withMacroExpansion, Lean.Elab.Term.elabTerm, Bool.true],[Lean.Elab.Term.TermElab]]
[Lean.IR.reshape,[Lean.IR.reshapeAux, Array.size],[Lean.IR.FnBody]]
[Lean.Meta.DiscrTree.Key.ctorIdx,[Unit.unit, Nat, OfNat.ofNat],[Nat]]
[Lean.Elab.Term.Do.Code.joinpoint.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.Code.joinpoint, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.Quotation.HeadCheck.noConfusionType,[],[]]
[Lean.Parser.Tactic.matchAlts.parenthesizer,[Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.Tactic.matchRhs.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.strong_induction_on,[Nat.strong_rec_on],[]]
[Lean.Elab.Info.ofMacroExpansionInfo.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Info.ofMacroExpansionInfo, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Info.ofMacroExpansionInfo]]
[Lean.getStructureCtor,[Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.InductiveVal.mk, Lean.ConstantVal.mk, List.nil, List.cons, Bool.true, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.ConstructorVal, Lean.Environment.find?, panicWithPosWithDecl, OfNat.ofNat],[Lean.ConstructorVal]]
[Lean.instInhabitedMessageData,[Inhabited.mk, Lean.MessageData.ofFormat, arbitrary],[Inhabited, Lean.MessageData]]
[Lean.Elab.Tactic.Location.wildcard.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Tactic.Location.wildcard, OfNat.ofNat]]
[And.imp_right,[And.imp, id],[And]]
[Lean.Syntax.ifNode,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Subtype.mk, Lean.Syntax.node, Lean.IsNode.mk, Unit.unit],[]]
[Lean.Parser.Tactic.piInstance,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Std.ShareCommon.ObjectSet.find?,[Std.HashSet.find?],[Option, Std.ShareCommon.Object]]
[Lean.Lsp.instFromJsonTextDocumentRegistrationOptions,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, Lean.Lsp.DocumentSelector, Pure.pure, Lean.Lsp.TextDocumentRegistrationOptions.mk],[Lean.FromJson, Lean.Lsp.TextDocumentRegistrationOptions]]
[Lean.Elab.Command.expandInCmd,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.Macro]]
[Lean.Syntax.ibelow,[True, And],[]]
[Lean.IR.UnreachableBranches.updateCurrFnSummary,[Bind.bind, MonadReader.read, modify, Lean.IR.UnreachableBranches.InterpState.mk, Lean.IR.UnreachableBranches.InterpState.assignments, Std.PersistentArray.modify, Lean.IR.UnreachableBranches.InterpState.funVals, Lean.IR.UnreachableBranches.Value.widening, Lean.IR.UnreachableBranches.InterpContext.env],[Lean.IR.UnreachableBranches.M, Unit]]
[«term_<|>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instMonadControlOptionT,[MonadControl.mk, Option, liftM, OptionT.run],[MonadControl, OptionT]]
[ReaderT.orElse,[HOrElse.hOrElse, Unit.unit],[ReaderT]]
[Lean.IR.Sorry.State.modified,[],[Bool]]
[Lean.Parser.Command.synth.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.RecursorVal.kEx,[Lean.RecursorVal.k],[Bool]]
[Lean.Elab.Term.Do.Code.reassign.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.Code.reassign, HAdd.hAdd, OfNat.ofNat]]
[Lean.Name.isAtomic,[Unit.unit, Lean.Name.str, Lean.Name.num, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Meta.withAtLeastTransparency,[Lean.Meta.withConfig, Lean.Meta.Config.mk, Lean.Meta.Config.foApprox, Lean.Meta.Config.ctxApprox, Lean.Meta.Config.quasiPatternApprox, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct],[]]
[Lean.Literal.strVal.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Literal.strVal, HAdd.hAdd, OfNat.ofNat]]
[UInt8.xor,[UInt8.mk, Fin.xor, UInt8.val],[UInt8]]
[Lean.JsonRpc.RequestID.str.inj,[],[Eq]]
[em',[Or.swap, em],[Or, Not]]
[Lean.MetavarContext.isExprAssignable,[BEq.beq, Lean.MetavarDecl.depth, Lean.MetavarContext.depth],[Bool]]
[Lean.IR.LitVal.beq,[Lean.IR.LitVal.num, Lean.IR.LitVal.str, Bool, BEq.beq, Bool.false],[Bool]]
[coeId,[CoeT.mk],[CoeT]]
[Lean.StructureFieldInfo.lt,[Lean.Name.quickLt, Lean.StructureFieldInfo.fieldName],[Bool]]
[Lean.Lsp.TypeDefinitionParams.toTextDocumentPositionParams,[],[Lean.Lsp.TextDocumentPositionParams]]
[Lean.Parser.Command.elab_rules,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.suppressInsideQuot, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.docComment, Lean.Parser.Term.attrKind, Lean.Parser.symbol, Lean.Parser.Command.optKind, Lean.Parser.ident, Lean.Parser.Term.matchAlts, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.Meta.DefEqContext.localInstances,[],[Lean.LocalInstances]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.higherOrders,[],[Array, Bool]]
[Lean.LocalContext.renameUserName,[Lean.LocalContext, Unit.unit, Lean.LocalContext.findFromUserName?, Lean.LocalContext.mk, Std.PersistentHashMap.insert, Lean.LocalDecl.fvarId, Std.PersistentArray.set, Lean.LocalDecl.index, Option.some],[Lean.LocalContext]]
[Lean.Lsp.TextDocumentEdit.textDocument,[],[Lean.Lsp.VersionedTextDocumentIdentifier]]
[UInt32.instSemiringUInt32.proof_13,[UInt32.eq_of_val_eq, Eq.mpr, congrArg, Eq, Fin.ofNat', HAdd.hAdd, OfNat.ofNat, Fin.size_positive', UInt32.val, Eq.trans, UInt32.mk, UInt32.one_def, UInt32.add_def],[Eq, Numeric.ofNat, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.ExplicitRC.addDec,[Lean.IR.FnBody.dec, OfNat.ofNat, Bool.true, Lean.IR.ExplicitRC.VarInfo.persistent],[Lean.IR.FnBody]]
[Lean.Elab.Command.CtorView.declName,[],[Lean.Name]]
[Std.HashSetImp.reinsertAux,[Std.HashSetBucket, Std.HashSetBucket.update, List.cons, Array.uget, Subtype.val],[Std.HashSetBucket]]
[Lean.mkLevelMax,[Lean.Level.max, Lean.Level.mkData, mixHash, OfNat.ofNat, Hashable.hash, HAdd.hAdd, Nat.max, Lean.Level.depth, or, Lean.Level.hasMVar, Lean.Level.hasParam],[Lean.Level]]
[Lean.mkBVarEx,[Lean.mkBVar],[Lean.Expr]]
[Function.Equiv.symm,[Eq.symm],[Function.Equiv]]
[Lean.Parser.Tactic.squeezeSimpa?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Parser.Tactic.apply',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Tactic.withMainContext,[Bind.bind, Lean.Elab.Tactic.getMainGoal, Lean.Meta.withMVarContext],[Lean.Elab.Tactic.TacticM]]
[Lean.Meta.SizeOfSpecNested.M,[ReaderT, Lean.Meta.SizeOfSpecNested.Context, Lean.Meta.MetaM],[]]
[instDecidableArrow.proof_2,[absurd],[False]]
[Lean.Parser.Term.doContinue.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Char.toUpper,[ite, And, GE.ge, OfNat.ofNat, LE.le, Char.ofNat, HSub.hSub],[Char]]
[Lean.Server.FileWorker.instBEqGoToKind,[BEq.mk, BEq.beq, Lean.Server.FileWorker.GoToKind.toCtorIdx],[BEq, Lean.Server.FileWorker.GoToKind]]
[Ring.gsmul_neg',[],[Eq, Ring.gsmul, Int.negSucc, Neg.neg, Int.ofNat, Nat.succ]]
[Lean.Lsp.TextDocumentSyncOptions.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.Context.macroStack,[],[Lean.Elab.MacroStack]]
[Lean.Parsec.hexDigit,[Lean.Parsec.attempt, Bind.bind, Lean.Parsec.anyChar, ite, Or, And, LE.le, Char.ofNat, Pure.pure, Lean.Parsec.fail, ToString.toString],[Lean.Parsec, Char]]
[Lean.instInhabitedMVarIdMap,[Inhabited.mk, EmptyCollection.emptyCollection],[Inhabited, Lean.MVarIdMap]]
[Lean.NameSet.insert,[Std.RBTree.insert],[Lean.NameSet]]
[Nat.land,[Nat.bitwise, and],[Nat]]
[Lean.Parser.Term.doMatch,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.Term.generalizingParam, Lean.Parser.sepBy1, Lean.Parser.Term.matchDiscr, Bool.false, Lean.Parser.Term.optType, Lean.Parser.Term.doMatchAlts],[Lean.Parser.Parser]]
[Mathlib.ExtendedBinder.«term∀ᵉ_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Mathlib.ExtendedBinder.extBinders, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Meta.NormNum.isNat_add,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, OfNat.ofNat, Lean.Meta.NormNum.isNat, HAdd.hAdd, ofNat_add],[Lean.Meta.NormNum.isNat, HAdd.hAdd]]
[Lean.Widget.InteractiveGoal.type,[],[Lean.Widget.CodeWithInfos]]
[Lean.Parser.Command.structureTk,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[and_assoc,[And.assoc],[Iff, And]]
[Lean.KeyedDeclsAttribute.instInhabitedExtensionState,[Inhabited.mk, Lean.KeyedDeclsAttribute.ExtensionState.mk, arbitrary],[Inhabited, Lean.KeyedDeclsAttribute.ExtensionState]]
[List.instAppendList,[Append.mk, List.append],[Append, List]]
[Nat.add_comm,[Eq, HAdd.hAdd, Eq.symm, Nat.zero_add],[Eq, HAdd.hAdd]]
[Lean.Syntax.mkNumLit,[Lean.Syntax.mkLit, Lean.numLitKind],[Lean.Syntax]]
[Lean.Parser.Term.binderTactic,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.Tactic.tacticSeq],[Lean.Parser.Parser]]
[Or.imp_right,[Or.imp, id],[Or]]
[Int.instNumericInt,[Numeric.mk, Int.ofNat],[Numeric, Int]]
[Lean.Lsp.ClientInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.ClientInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.ClientInfo.mk, And]]
[Array.foldrM.fold.proof_1,[Nat.lt_of_lt_of_le, Nat.lt_succ_self],[LT.lt, Array.size]]
[Lean.Lsp.ReferenceParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.ReferenceParams.mk, HAdd.hAdd, OfNat.ofNat]]
[EIO.mapTask,[BaseIO.mapTask, EIO.toBaseIO],[BaseIO, Task, Except]]
[Lean.Elab.Tactic.ElimApp.Context.noConfusionType,[],[]]
[Lean.PrettyPrinter.Formatter.checkLinebreakBefore.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[instAddCommGroup.proof_3,[Semiring.nsmul_zero'],[Eq, Semiring.nsmul, OfNat.ofNat]]
[ST.Ref.h,[],[Nonempty]]
[Lean.Server.Snapshots.Snapshot.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.Snapshots.Snapshot.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.Expr.proj.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.proj, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Expr.proj, And]]
[Lean.Lsp.instFileSourceSemanticTokensParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.SemanticTokensParams.textDocument],[Lean.Lsp.FileSource, Lean.Lsp.SemanticTokensParams]]
[Lean.Meta.Simp.SimpLetCase.nondep.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.Simp.SimpLetCase.nondep, OfNat.ofNat]]
[Reader,[ReaderT, Id],[]]
[instSemiringFin.proof_1,[Fin.eq_of_val_eq, Eq.mpr, congrFun, congrArg, Eq, Eq.trans, Fin.val, Fin.add_def, OfNat.ofNat, HMod.hMod, HAdd.hAdd, Fin.zero_def, Nat.add_zero, Nat.mod_eq_of_lt, Fin.isLt],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Lean.privateToUserName?,[ite, Eq, Lean.isPrivateName, Bool.true, Option.some, Lean.Name.anonymous, Lean.Name.num, Lean.Name, Lean.Name.mkStr, PProd.fst, Option.none],[Option, Lean.Name]]
[Lean.Meta.MatcherApp.remaining,[],[Array, Lean.Expr]]
[Lean.SCC.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.SCC.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.builtin_initialize.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.visibility.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.Term.typeSpec.parenthesizer, Lean.Parser.Term.leftArrow.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Term.doIfLet,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat, HOrElse.hOrElse, Lean.Parser.Term.doIfLetPure, Lean.Parser.Term.doIfLetBind, Bool.false],[Lean.Parser.Parser]]
[List.disjoint_of_disjoint_cons_left,[List.disjoint_of_subset_left, List.subset_cons],[List.disjoint]]
[Lean.Server.FileWorker.Reference.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.FirstTokens.tokens.inj,[],[Eq]]
[List.erasep,[Unit.unit, List, List.nil, ite, List.cons, PProd.fst],[List]]
[if_false,[if_neg, not_false],[Eq, ite, False]]
[Lean.Parser.Command.optNamedPrio.formatter,[Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.ppSpace.formatter, Lean.Parser.Command.namedPrio.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Widget.instInhabitedGetInteractiveDiagnosticsParams,[Inhabited.mk, Lean.Widget.GetInteractiveDiagnosticsParams.mk, arbitrary],[Inhabited, Lean.Widget.GetInteractiveDiagnosticsParams]]
[Nat.coprime.coprime_mul_right_right,[Nat.coprime.coprime_dvd_right, Nat.dvd_mul_right],[Nat.coprime]]
[Lean.Meta.Simp.Config.proj,[],[Bool]]
[Lean.Meta.Match.MkMatcherInput.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.MkMatcherInput.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.JsonNumber.instDecidableLt,[inferInstanceAs, Decidable, Eq, Lean.JsonNumber.lt, Bool.true],[Decidable, LT.lt]]
[Std.PersistentArray.findSomeM?,[Bind.bind, Std.PersistentArray.findSomeMAux, Std.PersistentArray.root, Unit.unit, Option, Array.findSomeM?, Std.PersistentArray.tail, Pure.pure, Option.some],[Option]]
[Lean.Server.FileWorker.instBEqRefIdent,[BEq.mk, Lean.Server.FileWorker.RefIdent.const, Lean.Server.FileWorker.RefIdent.fvar, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Server.FileWorker.RefIdent]]
[Lean.Lsp.WorkspaceFolder.name,[],[String]]
[instReprAtomFloat,[ReprAtom.mk],[ReprAtom, Float]]
[Lean.Xml.Parser.digitsToNat,[Array.foldl, HAdd.hAdd, HMul.hMul, OfNat.ofNat, Array.size],[Nat]]
[Lean.Elab.Term.LetRecDeclView.attrs,[],[Array, Lean.Elab.Attribute]]
[Lean.mkIdent,[Lean.Syntax.ident, Lean.SourceInfo.none, String.toSubstring, ToString.toString, List.nil],[Lean.Syntax]]
[Lean.Compiler.InlineAttributeKind.inlineIfReduce.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Compiler.InlineAttributeKind.inlineIfReduce, OfNat.ofNat]]
[Lean.Meta.instInhabitedAuxLemmas,[Inhabited.mk, Lean.Meta.AuxLemmas.mk, arbitrary],[Inhabited, Lean.Meta.AuxLemmas]]
[Task.map,[Task.pure, Task.get],[Task]]
[Lean.Meta.Match.Unify.State.noConfusionType,[],[]]
[List.filterAux,[List, List.reverse, Unit.unit, PProd.fst, List.cons],[List]]
[Lean.casesOnSuffix,[],[String]]
[Lean.Export.Entry.expr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Export.Entry.expr, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Level.ident,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.ident],[Lean.Parser.Parser]]
[Lean.Elab.InfoTree.node.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.InfoTree.node, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.InfoTree.node, And]]
[Lean.IR.FnBody.resetBody,[Lean.IR.FnBody.setBody, Lean.IR.FnBody.nil],[Lean.IR.FnBody]]
[Lean.Meta.DiscrTree.Key.proj.inj,[And.intro],[And, Eq]]
[min_comm,[eq_min, min_le_right, min_le_left, le_min],[Eq, min]]
[Lean.IR.Decl.elimDead,[Lean.IR.Decl.extern, Lean.IR.Decl, Lean.IR.Decl.updateBody!, Lean.IR.FnBody.elimDead],[Lean.IR.Decl]]
[Lean.Lsp.TextEditBatch,[Array, Lean.Lsp.TextEdit],[]]
[SeqLeft.seqLeft,[],[]]
[Lean.Expr.setPPExplicit,[Lean.Expr.setOption, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Expr]]
[Lean.Parser.Tactic.finish,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.sepBy1],[Lean.ParserDescr]]
[Lean.Server.FileWorker.ElabTaskError.noConfusionType,[],[]]
[UInt16.ofNat,[UInt16.mk, Fin.ofNat],[UInt16]]
[ForM.forM,[],[PUnit]]
[Lean.Meta.ParamInfo.hasFwdDeps,[],[Bool]]
[Lean.IR.Decl.noConfusionType,[],[]]
[Lean.PrettyPrinter.Parenthesizer.pushNone.parenthesizer,[Lean.Syntax.MonadTraverser.goLeft],[Lean.PrettyPrinter.Parenthesizer]]
[Function.sometimes_eq,[dif_pos, Nonempty.intro],[Eq, Function.sometimes]]
[Lean.Elab.Command.StructCtorView.name,[],[Lean.Name]]
[Lean.Export.Entry.level.inj,[],[Eq]]
[exists_of_exists_unique,[Exists.elim, Exists.intro, And.left],[Exists]]
[Lean.IR.FreeIndices.insertParams,[Array.foldl, Std.RBTree.insert, Lean.IR.VarId.idx, Lean.IR.Param.x, OfNat.ofNat, Array.size],[Lean.IR.IndexSet]]
[AddCommGroup.noConfusionType,[],[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.inBottomUp,[],[Bool]]
[Prod.swap_surjective,[Function.right_inverse.surjective, Prod.swap_left_inverse],[Function.surjective, Prod.swap]]
[Lean.Parser.Term.panic.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[unexpandSubtype,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Option.none.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Option.none, OfNat.ofNat]]
[Lean.Meta.CasesSubgoal.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.uvars,[],[Array, Lean.Name]]
[Lean.Elab.Term.elabBindersEx,[Lean.Elab.Term.withoutPostponingUniverseConstraints, ite, Eq, Array.isEmpty, Bool.true, List.toArray, List.nil, OfNat.ofNat],[Lean.Elab.Term.TermElabM]]
[USize.instSemiringUSize.proof_9,[rfl],[Eq, OfNat.ofNat]]
[Nat.lt_asymm,[Nat.le_lt_antisymm, Nat.le_of_lt],[Not, LT.lt]]
[Lean.unifConstraint,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[timeCmdElab,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, liftM, IO.monoMsNow, Lean.Elab.Command.elabCommand, Lean.Elab.logInfoAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, HSub.hSub, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Lean.IR.Expr.reuse.inj,[And.intro],[And, Eq]]
[Lean.InductiveVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.InductiveVal.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.checkOutParams,[Bind.bind, MonadReader.read, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit, ForIn.forIn, PUnit.unit, ite, Eq, BEq.beq, Array.getOp, Lean.BinderInfo.instImplicit, Bool.true, liftM, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.inspectOutParams, Pure.pure, ForInStep.yield],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit]]
[Lean.PrettyPrinter.Parenthesizer.strLitNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken],[Lean.PrettyPrinter.Parenthesizer]]
[instReprSum,[Repr.mk, Std.Format, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg],[Repr, Sum]]
[Lean.Elab.Term.MutualClosure.FixPoint.State.modified,[],[Bool]]
[Lean.PrettyPrinter.Delaborator.OptionsPerPos,[Std.RBMap, Lean.PrettyPrinter.Delaborator.Pos, Lean.Options, Ord.compare],[]]
[Std.PersistentHashMap.mkEmptyEntriesArray,[Array.mkArray, USize.toNat, Std.PersistentHashMap.branching, Std.PersistentHashMap.Entry.null],[Array, Std.PersistentHashMap.Entry, Std.PersistentHashMap.Node]]
[Lean.Compiler.NumScalarTypeInfo.ofNatFn,[],[Lean.Name]]
[Nat.imax,[ite, Eq, OfNat.ofNat, Nat.max],[Nat]]
[Lean.IR.FnBody.ibelow,[And, True],[]]
[ExceptT.seqLeft_eq,[],[Eq, SeqLeft.seqLeft, Seq.seq, Functor.map, Function.const]]
[Lean.Lsp.Ipc.collectDiagnostics,[Bind.bind, Lean.Lsp.Ipc.writeRequest, Lean.JsonRpc.Request.mk, Lean.Lsp.WaitForDiagnosticsParams.mk, Lean.Lsp.Ipc.collectDiagnostics.loop],[Lean.Lsp.Ipc.IpcM, List, Lean.JsonRpc.Notification, Lean.Lsp.PublishDiagnosticsParams]]
[UInt64.mod_def,[rfl],[Eq, HMod.hMod, UInt64.mk, UInt64.val]]
[Lean.Lsp.instFromJsonPublishDiagnosticsParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, Option, Int, Array, Lean.Lsp.Diagnostic, Pure.pure, Lean.Lsp.PublishDiagnosticsParams.mk],[Lean.FromJson, Lean.Lsp.PublishDiagnosticsParams]]
[Thunk.pure,[Thunk.mk],[Thunk]]
[UInt16.val_eq_of_eq,[Eq, UInt16.val, congrArg],[Eq, UInt16.val]]
[Lean.Widget.InteractiveGoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Widget.InteractiveGoal.mk, HAdd.hAdd, OfNat.ofNat]]
[bfix3,[PProd.fst],[]]
[Lean.Parser.Command.openRenaming,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.ident, Lean.Parser.symbol, Lean.Parser.sepBy1, Lean.Parser.Command.openRenamingItem, Bool.false],[Lean.Parser.Parser]]
[Subtype.heq_iff_coe_heq,[],[Iff, HEq, Subtype.val]]
[Lean.Json.Structured.arr.injEq,[Eq.propIntro, Eq.refl, Lean.Json.Structured.arr, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Json.Structured.arr]]
[List.get_cons_drop,[Eq.refl, List.length, List.nil, HEq.refl, Eq, List.cons, List.get, List.drop, HAdd.hAdd, OfNat.ofNat, rfl, PProd.fst, Nat.le_of_succ_le_succ, List.length_cons, Nat.add],[Eq, List.cons, List.get, List.drop, HAdd.hAdd, OfNat.ofNat]]
[ExceptT.instLawfulMonadExceptT.proof_1,[LawfulMonad.mk, ExceptT.bind_pure_comp, rfl, ExceptT.ext, of_eq_true, Eq.trans, congrFun, congrArg, Eq, ExceptT.run_bind, Pure.pure, Bind.bind, ExceptT.run_pure, Except, ExceptT.run, Except.error, LawfulMonad.pure_bind, Except.ok, eq_self, Eq.mpr, congr, LawfulMonad.bind_assoc, funext, bind_congr, Eq.symm, Eq.refl],[LawfulMonad, ExceptT]]
[Lean.Meta.Match.MatcherInfo.altNumParams,[],[Array, Nat]]
[default.sizeOf,[OfNat.ofNat],[Nat]]
[Lean.Meta.DefaultInstanceEntry.className,[],[Lean.Name]]
[Lean.ConstantInfo.defnInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ConstantInfo.defnInfo, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.DiagnosticRelatedInformation.location,[],[Lean.Lsp.Location]]
[eq_rec_constant,[rfl, Eq.symm, eq_of_heq, Eq.refl, HEq.refl],[Eq]]
[Std.instInhabitedFormat,[Inhabited.mk, Std.Format.nil],[Inhabited, Std.Format]]
[withPtrEqUnsafe,[ite, Eq, BEq.beq, ptrAddrUnsafe, Bool.true, Unit.unit],[Bool]]
[Lean.Elab.Term.FunBinders.State.mk.inj,[And.intro],[And, Eq]]
[decidableEq_of_decidableLe.proof_2,[le_refl],[False]]
[«term_++_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Parser.Command.exit.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.AttributeImpl.add,[],[Lean.AttrM, Unit]]
[List.beq,[Unit.unit, List.nil, List.cons, Bool, Bool.true, and, BEq.beq, PProd.fst, Bool.false],[Bool]]
[Lean.Parser.Command.namespace.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.instFromJsonVersionedTextDocumentIdentifier,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, Option, Nat, Pure.pure, Lean.Lsp.VersionedTextDocumentIdentifier.mk],[Lean.FromJson, Lean.Lsp.VersionedTextDocumentIdentifier]]
[Lean.IR.Borrow.markModified,[modify, Lean.IR.Borrow.BorrowInfState.mk, Lean.IR.Borrow.BorrowInfState.owned, Bool.true, Lean.IR.Borrow.BorrowInfState.paramMap],[Lean.IR.Borrow.M, Unit]]
[Lean.MetavarContext.MkBindingM,[ReaderT, Lean.LocalContext, Lean.MetavarContext.MkBinding.MCore],[]]
[right_inverse,[Eq],[]]
[Option.toLOption,[Unit.unit, Lean.LOption, Lean.LOption.none, Lean.LOption.some],[Lean.LOption]]
[Lean.TraceElem.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.TraceElem.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.TraceElem.mk, And]]
[Lean.ScopedEnvExtension.ScopedEntries.noConfusionType,[],[]]
[Lean.Elab.Term.Do.ToCodeBlock.mkForInBody,[Bind.bind, MonadReader.read, Lean.Elab.liftMacroM, Lean.Elab.Term.Do.ToTerm.run, Lean.Elab.Term.Do.CodeBlock.code, Lean.Elab.Term.Do.ToCodeBlock.Context.m, ite, Eq, Lean.Elab.Term.Do.hasReturn, Bool.true, Lean.Elab.Term.Do.ToTerm.Kind.forInWithReturn, Lean.Elab.Term.Do.ToTerm.Kind.forIn, Pure.pure, Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.mk],[Lean.Elab.Term.Do.ToCodeBlock.M, Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult]]
[Lean.Syntax.getNumArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Nat, Array.size, OfNat.ofNat],[Nat]]
[Lean.instToMessageData,[Lean.ToMessageData.mk, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format],[Lean.ToMessageData]]
[Lean.Elab.Tactic.evalWithReducibleAndInstances,[Lean.Meta.withReducibleAndInstances, Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Elab.Tactic.Tactic]]
[Lean.IR.EmitC.emitMainFn,[Bind.bind, Lean.IR.EmitC.getDecl, Lean.Name.mkStr, Lean.Name.anonymous, Lean.IR.Decl.extern, Lean.IR.EmitC.M, Unit, ite, Eq, or, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw],[Lean.IR.EmitC.M, Unit]]
[Lean.Name.hash,[Unit.unit, UInt64, UInt64.ofNatCore, OfNat.ofNat, Lean.Name.hash.proof_1],[UInt64]]
[Lean.mkAuxName,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure],[Lean.Name]]
[Lean.Parser.Tactic.isBounded_default,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Std.HashMapBucket.update,[Subtype.mk, Array.uset, Subtype.val, Std.HashMapBucket.update.proof_1],[Std.HashMapBucket]]
[Lean.Parser.Command.optionValue.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.strLit.parenthesizer, Lean.Parser.numLit.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.instInhabitedPosition,[Inhabited.mk, Lean.Position.mk, arbitrary],[Inhabited, Lean.Position]]
[Lean.AttributeExtensionState.newEntries,[],[List, Lean.AttributeExtensionOLeanEntry]]
[Lean.Parser.Term.proj.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.fieldIdx.parenthesizer, Lean.Parser.Term.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[implies_true,[propext, Iff.intro, trivial, True.intro],[Eq, True]]
[Lean.Elab.OpenDecl.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.OpenDecl.State.mk, HAdd.hAdd, OfNat.ofNat]]
[unexpandEqRec,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Lean.Meta.Match.Extension.addMatcherInfo,[Lean.PersistentEnvExtension.addEntry, Lean.Meta.Match.Extension.extension, Lean.Meta.Match.Extension.Entry.mk],[Lean.Environment]]
[Lean.Parser.categoryParserOfStack,[Lean.Parser.Parser.mk, Lean.Parser.categoryParserOfStackFn, Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.tokens, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Parser.ParserContext.savedPos?, Lean.Parser.ParserContext.forbiddenTk?],[Lean.Parser.Parser]]
[Function.injective_surj_inv,[Function.right_inverse.injective, Function.right_inverse_surj_inv],[Function.injective, Function.surj_inv]]
[Lean.Elab.Command.expandMutualElement,[Bind.bind, ForIn.forIn, MProd.mk, Lean.Macro.expandMacro?, Unit.unit, Lean.MacroM, ForInStep, MProd, Array, Lean.Syntax, Bool, Pure.pure, PUnit.unit, ForInStep.yield, ite, Eq, Bool.true, Lean.Syntax.setArg, OfNat.ofNat, Lean.mkNullNode, Lean.Macro.throwUnsupported],[Lean.Macro]]
[Lean.IR.FnBody.vdecl.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.vdecl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.FnBody.vdecl, And]]
[Lean.Meta.Closure.State.newLocalDecls,[],[Array, Lean.LocalDecl]]
[Lean.Expr.ReplaceLevelImpl.State.noConfusionType,[],[]]
[Lean.Meta.Simp.withSimpLemmas,[Bind.bind, MonadState.get, modify, Lean.Meta.Simp.State.mk, EmptyCollection.emptyCollection, Lean.Meta.Simp.State.numSteps, tryFinally, withTheReader, Lean.Meta.Simp.Context, Lean.Meta.Simp.Context.mk, Lean.Meta.Simp.Context.config, Lean.Meta.Simp.Context.congrLemmas, Lean.Meta.Simp.Context.parent?, Lean.Meta.Simp.Context.dischargeDepth],[Lean.Meta.Simp.M]]
[Lean.Environment.find?,[Lean.SMap.find?', Lean.Environment.constants],[Option, Lean.ConstantInfo]]
[Lean.Parser.Command.structSimpleBinder,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.Command.declModifiers, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.Command.inferMod, Lean.Parser.Command.optDeclSig, HOrElse.hOrElse, Lean.Parser.Term.binderTactic, Lean.Parser.Term.binderDefault],[Lean.Parser.Parser]]
[Lean.Meta.InfoCacheKey.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.InfoCacheKey.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.KeyedDeclsAttribute.ExtensionState.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.WhnfCache,[Lean.PersistentExprStructMap, Lean.Expr],[]]
[Lean.Elab.OpenDecl.elabOpenDecl,[Bind.bind, Lean.MonadResolveName.getOpenDecls, Lean.MonadResolveName.getCurrNamespace, StateRefT'.run', ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, ForIn.forIn, PUnit.unit, Lean.resolveNamespace, Lean.Syntax.getId, modify, Lean.Elab.OpenDecl.State.mk, List.cons, Lean.Elab.OpenDecl.State.openDecls, Lean.Elab.OpenDecl.State.currNamespace, Lean.OpenDecl.simple, List.nil, Lean.activateScoped, Pure.pure, ForInStep.yield, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.OpenDecl.resolveId, Lean.OpenDecl.explicit],[List, Lean.OpenDecl]]
[Lean.Elab.Term.State.messages,[],[Lean.MessageLog]]
[Array.mkArray,[Array.mk, List.replicate],[Array]]
[Lean.IR.Sorry.visitExpr.getSorryDepFor?,[ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, MonadExcept.throw, Bind.bind, MonadState.get, Option.none, ExceptT, Lean.Name, Lean.IR.Sorry.M, Unit, Lean.NameMap.find?, Lean.IR.Sorry.State.localSorryMap, liftM, Lean.IR.findDecl, Option.some, Lean.IR.Decl.fdecl, Lean.IR.DeclInfo.mk, Lean.IR.Decl.extern, Pure.pure, Unit.unit],[ExceptT, Lean.Name, Lean.IR.Sorry.M, Unit]]
[ReaderT.instMonadExceptOfReaderT,[MonadExceptOf.mk, liftM, MonadExcept.throw, tryCatchThe],[MonadExceptOf, ReaderT]]
[Lean.Parser.identEqFn,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Parser.ParserState, Array.back, Lean.Parser.ParserState.stxStack, bne, Lean.Parser.ParserState.mkErrorAt, HAppend.hAppend, ToString.toString, Option.some],[Lean.Parser.ParserFn]]
[IO.FS.FileType.noConfusionType,[noConfusionTypeEnum, IO.FS.FileType.toCtorIdx],[]]
[Lean.Meta.SynthInstance.mkGeneratorNode?,[Bind.bind, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Lean.Meta.SynthInstance.getInstances, ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Option.none, Lean.MonadMCtx.getMCtx, Option.some, Lean.Meta.SynthInstance.GeneratorNode.mk, Array.size],[Lean.Meta.MetaM, Option, Lean.Meta.SynthInstance.GeneratorNode]]
[Lean.Elab.Tactic.Conv.markAsConvGoal,[Bind.bind, Lean.Meta.getMVarType, ite, Eq, Option.isSome, Lean.isLHSGoal?, Bool.true, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Lean.MVarId]]
[Nat.mul_le_mul_right,[Nat.mul_le_mul_left, Nat.mul_comm],[LE.le, HMul.hMul]]
[Lean.Core.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Core.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Core.Context.mk, And]]
[Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.isDep,[],[Bool]]
[decidableOfDecidableOfIff,[dite, Decidable.isTrue, Iff.mp, Decidable.isFalse, decidableOfDecidableOfIff.proof_1],[Decidable]]
[Lean.Environment.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Environment.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.FunBinders.State.expectedType?,[],[Option, Lean.Expr]]
[UInt64.instNegUInt64,[Neg.mk, UInt64.mk, Neg.neg, UInt64.val],[Neg, UInt64]]
[Lean.Elab.Command.instMonadInfoTreeCommandElabM,[Lean.Elab.MonadInfoTree.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Command.State.infoState, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.traceState],[Lean.Elab.MonadInfoTree, Lean.Elab.Command.CommandElabM]]
[Lean.Elab.Term.ElabAppArgs.State.args,[],[List, Lean.Elab.Term.Arg]]
[Lean.Meta.SimpAll.main,[Bind.bind, MonadState.get, liftM, Lean.Meta.getNondepPropHyps, Lean.Meta.SimpAll.State.mvarId, ForIn.forIn, PUnit.unit, Lean.Meta.getLocalDecl, ite, Eq, Std.PersistentHashSet.contains, Lean.LocalDecl.userName, Bool.true, Pure.pure, ForInStep.yield, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.SimpLemmas.add, Lean.Meta.Simp.Context.simpLemmas, Lean.Meta.SimpAll.State.ctx, List.toArray, List.nil, Bool.false, OfNat.ofNat, Option.some, Lean.Meta.instantiateMVars, Lean.LocalDecl.type, modify, Lean.Meta.SimpAll.State.mk, Lean.Meta.SimpAll.State.modified, Array.push, Lean.Meta.SimpAll.State.entries, Lean.Meta.Simp.Context.mk, Lean.Meta.Simp.Context.config, Lean.Meta.Simp.Context.congrLemmas, Lean.Meta.Simp.Context.parent?, Lean.Meta.Simp.Context.dischargeDepth, Option.none, Lean.Meta.assertHypotheses, Array.map, Lean.Meta.Hypothesis.mk, Lean.Meta.SimpAll.Entry.userName, Lean.Meta.SimpAll.Entry.type, Lean.Meta.SimpAll.Entry.proof, Lean.Meta.SimpAll.M, Option, Lean.MVarId, liftCoeM, Lean.Meta.tryClearMany, Lean.Meta.SimpAll.Entry.fvarId],[Lean.Meta.SimpAll.M, Option, Lean.MVarId]]
[Std.PersistentHashMap.getCollisionNodeSize.proof_2,[Eq.refl, Std.PersistentHashMap.Node.entries, HEq.refl, False],[False]]
[Ring.toSub,[],[Sub]]
[TC.accessible.proof_1,[Acc.intro, Acc.inv],[Acc, TC]]
[Lean.JsonRpc.Message.request.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonRpc.Message.request, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.JsonRpc.Message.request, And]]
[Std.ShareCommon.ObjectMap.insert,[Std.HashMap.insert],[Std.ShareCommon.ObjectMap]]
[Lean.Widget.InteractiveGoals.mk.inj,[],[Eq]]
[Lean.PersistentEnvExtension.statsFn,[],[Std.Format]]
[Lean.Elab.Term.Do.CodeBlock.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.CodeBlock.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.RecursorInfo.noConfusionType,[],[]]
[Lean.IR.IRType.noConfusionType,[],[]]
[Fin.modn,[Fin, Fin.mk, HMod.hMod, Fin.modn.proof_1],[Fin]]
[Lean.IR.Arg.var.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Arg.var, HAdd.hAdd, OfNat.ofNat]]
[Lean.Compiler.getInfoFromVal,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Compiler.NumScalarTypeInfo, Lean.Compiler.getInfoFromFn, Lean.Compiler.numScalarTypes, Option.none],[Option, Lean.Compiler.NumScalarTypeInfo]]
[Lean.Elab.Tactic.ElimApp.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Tactic.ElimApp.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.Do.ToTerm.Kind.noConfusionType,[noConfusionTypeEnum, Lean.Elab.Term.Do.ToTerm.Kind.toCtorIdx],[]]
[Lean.Parser.TokenCacheEntry.noConfusionType,[],[]]
[Lean.JsonNumber.instToStringJsonNumber,[ToString.mk, Lean.JsonNumber.toString],[ToString, Lean.JsonNumber]]
[Lean.HeadIndex.proj.inj,[And.intro],[And, Eq]]
[Lean.PrettyPrinter.Parenthesizer.notFollowedByCategoryToken.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[right_comm,[],[right_commutative]]
[Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.mk, And]]
[Lean.Parser.Tactic.guardTarget,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Meta.Simp.SimpM,[ReaderT, Lean.Meta.Simp.Context, StateRefT', IO.RealWorld, Lean.Meta.Simp.State, Lean.Meta.MetaM],[]]
[UInt8.sub,[UInt8.mk, HSub.hSub, UInt8.val],[UInt8]]
[Lean.PrettyPrinter.Parenthesizer.evalInsideQuot.parenthesizer,[],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.ConstantInfo.numLevelParams,[List.length, Lean.ConstantInfo.levelParams],[Nat]]
[Lean.Meta.SynthInstance.modifyTop,[modify, Lean.Meta.SynthInstance.State.mk, Lean.Meta.SynthInstance.State.result?, Array.modify, Lean.Meta.SynthInstance.State.generatorStack, HSub.hSub, Array.size, OfNat.ofNat, Lean.Meta.SynthInstance.State.resumeStack, Lean.Meta.SynthInstance.State.tableEntries],[Lean.Meta.SynthInstance.SynthM, Unit]]
[Lean.Elab.Term.StructInst.CtorHeaderResult.mk.inj,[And.intro],[And, Eq]]
[instReprOption,[Repr.mk, Std.Format, Std.Format.text, Repr.addAppParen, HAppend.hAppend, reprArg],[Repr, Option]]
[Lean.Elab.Info.isSmaller,[Option.none, Bool, Lean.Elab.Info.size?, Lean.Elab.Info.pos?, Decidable.decide, LT.lt, Bool.true, Bool.false],[Bool]]
[Lean.mkConstWithLevelParams,[Bind.bind, Lean.getConstInfo, Pure.pure, Lean.mkConst, List.map, Lean.mkLevelParam, Lean.ConstantInfo.levelParams],[Lean.Expr]]
[Fin.zero_def,[],[Eq, Fin.val, OfNat.ofNat]]
[ForInStep.done.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, ForInStep.done, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.isGlobalInstance,[Std.PersistentHashMap.contains, Lean.ScopedEnvExtension.getState, Lean.Meta.globalInstanceExtension],[Bool]]
[Lean.Lsp.WaitForDiagnosticsParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.WaitForDiagnosticsParams.mk, HAdd.hAdd, OfNat.ofNat]]
[MonadExceptOf.noConfusionType,[],[]]
[Lean.Meta.mkConstWithFreshMVarLevels,[Bind.bind, Lean.getConstInfo, Lean.Meta.mkFreshLevelMVarsFor, Pure.pure, Lean.mkConst],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.EnvExtensionInterface.noConfusionType,[],[]]
[imp_or_distrib',[Decidable.imp_or_distrib'],[Iff, Or]]
[Array.findIdx?,[Array.size, OfNat.ofNat, rfl, Array.findIdx?.loop],[Option, Nat]]
[Lean.Elab.ElabInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.ElabInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.ElabInfo.mk, And]]
[ofBoolUsing_eq_false,[of_decide_eq_false],[Not]]
[Lean.Parser.Tactic.applyNormed,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Meta.Config.etaStruct,[],[Bool]]
[Lean.Meta.CheckAssignment.throwOutOfScopeFVar,[MonadExcept.throw, Lean.Exception.internal, Lean.Meta.CheckAssignment.outOfScopeExceptionId, Lean.KVMap.mk],[Lean.Meta.CheckAssignment.CheckAssignmentM]]
[Lean.KernelException.alreadyDeclared.inj,[And.intro],[And, Eq]]
[Lean.Xml.Parser.AttlistDecl,[SeqRight.seqRight, Lean.Parsec.skipString, Lean.Xml.Parser.S, Lean.Xml.Parser.Name, Lean.Parsec.many, Lean.Xml.Parser.AttDef, optional, Lean.Parsec.skipChar, Char.ofNat],[Lean.Parsec, Unit]]
[Lean.ConstantVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ConstantVal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ConstantVal.mk, And]]
[decidableLt_of_decidableLe.proof_2,[le_of_lt],[False]]
[instStreamSubarray,[Stream.mk, dite, LT.lt, Subarray.start, Subarray.stop, Option.none],[Stream, Subarray]]
[Nat.le_trans,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, LE.le, Nat.le.step, PProd.fst],[LE.le]]
[Lean.IR.Expr.ctor.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Expr.ctor, HAdd.hAdd, OfNat.ofNat]]
[Lean.RecursorVal.all,[],[List, Lean.Name]]
[ExceptT.instMonadLiftExceptExceptT,[MonadLift.mk, ExceptT.mk, Pure.pure],[MonadLift, Except, ExceptT]]
[Unit,[PUnit],[]]
[Lean.Expr.hasLooseBVars,[Decidable.decide, GT.gt, Lean.Expr.looseBVarRange, OfNat.ofNat],[Bool]]
[Lean.Server.Snapshots.Snapshot.endPos,[Lean.Parser.ModuleParserState.pos, Lean.Server.Snapshots.Snapshot.mpState],[String.Pos]]
[Lean.Elab.Term.LVal.fieldName.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LVal.fieldName, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.LVal.fieldName, And]]
[Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.matchType,[],[Lean.Expr]]
[Function.update_comp_eq_of_forall_ne,[Function.update_comp_eq_of_forall_ne'],[Eq, Function.comp, Function.update]]
[Lean.Parser.Tactic.split,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Mathlib.Prelude.Rename.RenameMap,[Std.HashMap, Lean.Name],[]]
[Lean.Elab.instToFormatModifiers,[Std.ToFormat.mk, Std.Format.bracket, Std.Format.joinSep, HAppend.hAppend, Std.Format.text, Std.Format.line],[Std.ToFormat, Lean.Elab.Modifiers]]
[Lean.Meta.matchEq?,[Lean.Meta.matchHelper?, Pure.pure, Lean.Expr.eq?],[Lean.Meta.MetaM, Option, Prod, Lean.Expr]]
[Lean.Parser.Term.arrayRef,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, Lean.Parser.termParser],[Lean.Parser.TrailingParser]]
[Lean.instToStringAttributeKind,[ToString.mk, Unit.unit, String],[ToString, Lean.AttributeKind]]
[Lean.Meta.Closure.State.toProcess,[],[Array, Lean.Meta.Closure.ToProcessElement]]
[Lean.Elab.Term.SyntheticMVarKind.coe.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.SyntheticMVarKind.coe, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.SyntheticMVarKind.coe, And]]
[Lean.Meta.Simp.Result.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Simp.Result.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Simp.Result.mk, And]]
[Lean.instFromJsonFilePath,[Lean.FromJson.mk, Functor.map, System.FilePath.mk, Lean.Json.getStr?],[Lean.FromJson, System.FilePath]]
[Lean.Meta.openAbstractMVarsResult,[Bind.bind, Array.mapM, Lean.Meta.mkFreshLevelMVar, Lean.Meta.AbstractMVarsResult.paramNames, Lean.Meta.lambdaMetaTelescope, Option.some, Lean.Meta.AbstractMVarsResult.numMVars],[Lean.Meta.MetaM, Prod, Array, Lean.Expr, Lean.BinderInfo]]
[Lean.instCoeExprExprStructEq,[Coe.mk, Lean.ExprStructEq.mk],[Coe, Lean.Expr, Lean.ExprStructEq]]
[Lean.Json.below,[PUnit, PProd],[]]
[instInhabitedPointedType,[Inhabited.mk, PointedType.mk, PUnit, PUnit.unit],[Inhabited, PointedType]]
[Lean.SimplePersistentEnvExtensionDescr.toArrayFn,[],[Array]]
[Lean.Server.FileWorker.CancelToken.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.FileWorker.CancelToken.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Module.header.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Module.prelude.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.Module.import.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[EStateM.adaptExcept,[EStateM.Result, EStateM.Result.error, EStateM.Result.ok],[EStateM]]
[Std.PersistentArray.mkEmptyArray,[Array.mkEmpty, USize.toNat, Std.PersistentArray.branching],[Array]]
[Lean.Meta.ParamInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.ParamInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.ParamInfo.mk, And]]
[flip,[],[]]
[Tactic.Ring.HornerExpr.const.injEq,[Eq.propIntro, And.intro, Eq.refl, Tactic.Ring.HornerExpr.const, Eq.symm, eq_of_heq, HEq.refl],[Eq, Tactic.Ring.HornerExpr.const, And]]
[instReprAtomString,[ReprAtom.mk],[ReprAtom, String]]
[Lean.IR.Borrow.OwnedSet.contains,[Std.HashMap.contains],[Bool]]
[Lean.instMonadRecDepthReaderT,[Lean.MonadRecDepth.mk, Lean.MonadRecDepth.withRecDepth, Lean.MonadRecDepth.getRecDepth, Lean.MonadRecDepth.getMaxRecDepth],[Lean.MonadRecDepth, ReaderT]]
[Lean.Lsp.SemanticTokens.noConfusionType,[],[]]
[Int.negSucc_ofNat_mul_subNatNat,[],[Eq, HMul.hMul, Int.negSucc, Int.subNatNat, Nat.succ]]
[Lean.NameSanitizerState.userName2Sanitized,[],[Lean.NameMap, Lean.Name]]
[Lean.Parser.error,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.errorFn],[Lean.Parser.Parser]]
[Lean.IR.formatParams,[Lean.IR.formatArray],[Std.Format]]
[Lean.Expr.heq?,[Lean.Expr.app4?, Lean.Name.mkStr, Lean.Name.anonymous],[Option, Prod, Lean.Expr]]
[Lean.Elab.ContextInfo.ppGoals,[ite, Eq, List.isEmpty, Bool.true, Pure.pure, Std.Format.text, Lean.Elab.ContextInfo.runMetaM, Lean.LocalContext.mk, Bind.bind, List.mapM, Lean.Meta.ppGoal, Std.Format.prefixJoin],[IO, Std.Format]]
[Lean.Elab.Command.Context.cmdPos,[],[String.Pos]]
[Std.HashMap.getOp,[Std.HashMap.find?],[Option]]
[Lean.Elab.Term.expandSuffices,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Lean.Macro.throwUnsupported],[Lean.Macro]]
[Fin.add,[Fin, Fin.mk, HMod.hMod, HAdd.hAdd, Fin.add.proof_1],[Fin]]
[DoResultPRBC.noConfusionType,[],[]]
[String.isSuffix,[List.isSuffix],[]]
[instDecidableEqSum.proof_4,[absurd],[False]]
[IO.FS.Stream.putStrLn,[IO.FS.Stream.putStr, String.push, Char.ofNat],[IO, Unit]]
[Lean.Expr.isFVar,[Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[instShiftLeftUSize,[ShiftLeft.mk, USize.shiftLeft],[ShiftLeft, USize]]
[Lean.Elab.Command.elabInductive,[Bind.bind, Lean.Elab.Command.checkValidInductiveModifier, Lean.Elab.Command.CommandElabM, Lean.Elab.Command.InductiveView, Lean.Elab.Command.expandDeclId, Lean.Elab.addDeclarationRanges, Array.mapM, Lean.withRef, Lean.Elab.elabModifiers, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, and, Lean.Elab.Modifiers.isPrivate, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Syntax.getArgs, Lean.Elab.getOptDerivingClasses, Lean.Elab.Command.InductiveView.mk, Lean.Elab.Command.elabInductiveViews, List.toArray, List.cons, List.nil],[Lean.Elab.Command.CommandElabM, Unit]]
[Equivalence.trans,[],[]]
[Lean.isSubScriptAlnum,[or, Lean.isNumericSubscript, and, Decidable.decide, LE.le, OfNat.ofNat, Char.val],[Bool]]
[evalIntrov.intro1PStep,[Lean.Elab.Tactic.liftMetaTactic, Bind.bind, Lean.Meta.intro1P, Lean.Meta.MetaM, List, Lean.MVarId, Pure.pure, List.cons, List.nil],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.interpolatedStrLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Lean.instInhabitedProjectionFunctionInfo,[Inhabited.mk, Lean.ProjectionFunctionInfo.mk, arbitrary],[Inhabited, Lean.ProjectionFunctionInfo]]
[Lean.CollectLevelParams.Visitor,[Lean.CollectLevelParams.State],[]]
[Lean.Meta.SynthInstance.MkTableKey.State.lmap,[],[Std.HashMap, Lean.MVarId, Lean.Level]]
[unexpandIte,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Std.RBTree.revFold,[Std.RBMap.revFold],[]]
[List.exists_mem_cons_of_exists,[Exists, And, Mem.mem, List.cons, Exists.intro, And.intro, Or.inr],[Exists, And, Mem.mem, List.cons]]
[Lean.Syntax.Traverser.up,[ite, GT.gt, Array.size, Lean.Syntax.Traverser.parents, OfNat.ofNat, Lean.Syntax.Traverser.mk, Array.pop, Lean.Syntax.Traverser.idxs],[Lean.Syntax.Traverser]]
[Lean.IR.VarTypeMap,[Std.HashMap, Lean.IR.VarId, Lean.IR.IRType],[]]
[Lean.Meta.Simp.Config.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Simp.Config.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.define,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarTag, Lean.Meta.getMVarType, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.assignExprMVar, Pure.pure, Lean.Expr.mvarId!],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.Lsp.RpcCallParams.method,[],[Lean.Name]]
[«term_<<<_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Compiler.SpecEntry.info.inj,[And.intro],[And, Eq]]
[«term_|||_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[invImage,[WellFoundedRelation.mk, InvImage, WellFoundedRelation.rel, invImage.proof_1],[WellFoundedRelation]]
[Lean.IR.LocalContext,[Std.RBMap, Lean.IR.Index, Lean.IR.LocalContextEntry, Ord.compare],[]]
[instDecidableEqSum.proof_3,[rfl],[Eq, Sum.inr]]
[UInt16.toUInt8,[Nat.toUInt8, UInt16.toNat],[UInt8]]
[Lean.Meta.NormNum.eval_of_isNat,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, OfNat.ofNat, HEq.refl, Eq, Lean.Meta.NormNum.LawfulOfNat.isNat_ofNat],[Eq, OfNat.ofNat]]
[UInt64.size_positive,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt64.size]]
[Lean.PrettyPrinter.Delaborator.delabBVar,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Pure.pure, Lean.mkIdent, Lean.Name.mkSimple, HAppend.hAppend, ToString.toString, panicWithPosWithDecl, OfNat.ofNat],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.Parser.ParserExtension.OLeanEntry.category.inj,[And.intro],[And, Eq]]
[List.reverse_nil,[rfl],[Eq, List.reverse, List.nil]]
[HShiftRight.noConfusionType,[],[]]
[Lean.Parser.Command.initialize,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.visibility, Lean.Parser.symbol, Lean.Parser.atomic, Lean.Parser.ident, Lean.Parser.Term.typeSpec, Lean.Parser.Term.leftArrow, Lean.Parser.Term.doSeq],[Lean.Parser.Parser]]
[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.curr,[],[Nat]]
[Lean.Parser.Command.notationItem.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.strLit.parenthesizer, Lean.Parser.Command.identPrec.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Term.doCatch.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.darrow.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.ElabAppArgs.State.propagateExpected,[],[Bool]]
[Lean.Elab.Tactic.getFVarId,[Lean.withRef, Bind.bind, Lean.Elab.Tactic.withMainContext, Lean.Elab.Tactic.elabTermForApply, Bool.false, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Elab.Tactic.TacticM, Lean.FVarId, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Elab.Tactic.TacticM, Lean.FVarId]]
[Lean.IR.ExplicitRC.Context.localCtx,[],[Lean.IR.LocalContext]]
[max_self,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, if_t_t, LT.lt, eq_self],[Eq, max]]
[Lean.IR.NormalizeIds.normArg,[Lean.IR.Arg.irrelevant, Lean.IR.NormalizeIds.M, Lean.IR.Arg, Functor.map, Lean.IR.Arg.var, Lean.IR.NormalizeIds.normVar, Pure.pure],[Lean.IR.NormalizeIds.M, Lean.IR.Arg]]
[Lean.Elab.Command.elabElabRulesAux,[Bind.bind, Array.mapM, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, not, Lean.Syntax.isQuot, Lean.Elab.throwUnsupportedSyntax, Pure.pure, PUnit.unit, Option.none, Option.some, Lean.Elab.Command.CommandElabM, Lean.Syntax, Lean.Syntax.getId, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Elab.Command.CommandElabM, Lean.Syntax]]
[String.find,[String.findAux, String.bsize, OfNat.ofNat],[String.Pos]]
[instSemiringFin.proof_2,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.mul_def, OfNat.ofNat, congrFun, HMod.hMod, HMul.hMul, Fin.zero_def, Nat.zero_mul, Nat.zero_mod, eq_true_of_decide, Eq.refl, Bool.true],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Parser.Command.syntaxCat,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident, Lean.Parser.Command.catBehavior],[Lean.Parser.Parser]]
[Lean.Json.Parser.natMaybeZero,[Bind.bind, Lean.Json.Parser.natNumDigits, Lean.Parsec, Nat, Pure.pure],[Lean.Parsec, Nat]]
[Lean.Elab.Term.SyntheticMVarKind.tactic.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.SyntheticMVarKind.tactic, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.instFromJsonTextEdit,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.Range, String, Pure.pure, Lean.Lsp.TextEdit.mk],[Lean.FromJson, Lean.Lsp.TextEdit]]
[Lean.Elab.Term.CollectPatternVars.Context.paramDeclIdx,[],[Nat]]
[Lean.getPPMotivesPi,[Lean.KVMap.get, Lean.Option.name, Lean.pp.motives.pi, Lean.Option.defValue],[Bool]]
[Lean.Meta.IndPredBelow.findBelowIdx,[Array.findSomeM?, Bind.bind, Lean.Meta.inferType, Lean.Expr.withApp, Option.none, Option.some, Lean.Meta.MetaM, Option, Prod, Lean.Expr, Nat, Lean.Expr.constName?, Array.indexOf?, Lean.Meta.isInductivePredicate, ite, Eq, Bool.true, Array.getOp, Lean.getConstInfoInduct, Pure.pure, Prod.mk, Fin.val, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Name.anonymous, MonadExcept.tryCatch, Lean.isTracingEnabledFor, Lean.Meta.ppGoal, Lean.Expr.mvarId!, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, PUnit.unit],[Lean.Meta.MetaM, Option, Prod, Lean.Expr, Nat]]
[Lean.IR.ExplicitRC.VarInfo.ref,[],[Bool]]
[Lean.Elab.throwIllFormedSyntax,[Lean.throwError, Lean.ToMessageData.toMessageData],[]]
[Lean.Meta.shouldReduceAll,[Bind.bind, Lean.Meta.getTransparency, Pure.pure, BEq.beq, Lean.Meta.TransparencyMode.all],[Lean.Meta.MetaM, Bool]]
[List.map_id,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.map_nil, List.nil, eq_self, List.map_cons, congr, List.cons, id_eq],[Eq, List.map, id]]
[Lean.Parser.Term.funImplicitBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.lookahead.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.implicitBinder.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[UInt8.decLe,[Decidable, LE.le, inferInstanceAs],[Decidable, LE.le]]
[Lean.Elab.Tactic.elabTermWithHoles,[Bind.bind, Lean.MonadMCtx.getMCtx, Lean.Elab.Tactic.elabTermEnsuringType, Bool.false, liftM, Lean.Meta.getMVarsNoDelayed, Array.filterM, Lean.Elab.Term.isLetRecAuxMVar, Pure.pure, not, OfNat.ofNat, Array.size, ite, Eq, Bool.true, Array.toList, Lean.Meta.getMVarDecl, Lean.MetavarKind.isNatural, Lean.MetavarDecl.kind, Lean.Elab.Tactic.filterOldMVars, Lean.Elab.Tactic.logUnassignedAndAbort],[Lean.Elab.Tactic.TacticM, Prod, Lean.Expr, List, Lean.MVarId]]
[Lean.Meta.Closure.State.visitedExpr,[],[Lean.ExprStructMap, Lean.Expr]]
[LawfulMonad.bind_assoc,[],[Eq, Bind.bind]]
[Lean.Elab.Command.elabAttr,[Bind.bind, ForIn.forIn, MProd.mk, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.MonadEnv.getEnv, Lean.isAttribute, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, ForInStep.yield, Lean.Elab.Command.CommandElabM, Unit, Lean.Elab.elabAttrs, Lean.withRef, Lean.Elab.Command.liftTermElabM, Option.none, Lean.Elab.resolveGlobalConstNoOverloadWithInfo, Lean.Elab.Term.applyAttributes, liftM, Lean.Attribute.erase],[Lean.Elab.Command.CommandElab]]
[Lean.Meta.Match.Extension.instInhabitedState,[Inhabited.mk, Lean.Meta.Match.Extension.State.mk],[Inhabited, Lean.Meta.Match.Extension.State]]
[Lean.Parser.Term.letIdLhs.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.ident.formatter, Lean.PrettyPrinter.Formatter.notFollowedBy.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many.formatter, Lean.ppSpace.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.simpleBinderWithoutType.formatter, Lean.Parser.Term.bracketedBinder.formatter, Bool.false, Lean.Parser.Term.optType.formatter],[Lean.PrettyPrinter.Formatter]]
[Option.eq_none_of_isNone,[Eq.refl, Bool.true, HEq.refl, Eq, Option.none, rfl],[Eq, Option.none]]
[CommGroup.toGroup,[],[Group]]
[Lean.IR.FnBody.beq,[Lean.IR.FnBody.alphaEqv, EmptyCollection.emptyCollection],[Bool]]
[Lean.Meta.SplitIf.discharge?,[Bind.bind, liftM, Lean.Meta.instantiateMVars, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Expr.notNot?, Pure.pure, PUnit.unit],[Lean.Meta.Simp.Discharge]]
[Lean.Parser.Term.borrowed.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.leadPrec],[Lean.PrettyPrinter.Formatter]]
[Substring.stopPos,[],[String.Pos]]
[Tactic.Find.findType,[Lean.Meta.withReducible, Bind.bind, liftM, Lean.Meta.instantiateMVars, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.abstractMVars, Lean.MonadEnv.getEnv, Tactic.DeclCache.get, Tactic.Find.findDeclsPerHead, ForIn.forIn, Lean.Meta.mkFreshLevelMVars, Lean.ConstantInfo.numLevelParams, Pure.pure, Lean.ConstantInfo.instantiateTypeLevelParams, Lean.Meta.forallTelescopeReducing, Lean.Meta.AbstractMVarsResult.numMVars, Lean.Expr.instantiateLevelParamsArray, Lean.Meta.AbstractMVarsResult.expr, Lean.Meta.AbstractMVarsResult.paramNames, List.toArray, Lean.Meta.lambdaMetaTelescope, Lean.Elab.Term.TermElabM, Bool, andM, Lean.Meta.isDefEq, Array.toList, List.nil, ite, Eq, Bool.true, GT.gt, OfNat.ofNat, Lean.Elab.logInfo, Lean.ToMessageData.toMessageData, ForInStep.done, PUnit.unit, ForInStep.yield],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Parser.Term.namedPattern.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkStackTop.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[Nat.toDigits,[Nat.toDigitsCore, HAdd.hAdd, OfNat.ofNat, List.nil],[List, Char]]
[Lean.Meta.withNewLocalInstance,[Lean.Meta.mapMetaM, Bind.bind, Lean.Meta.getFVarLocalDecl, Lean.BinderInfo.default, Lean.BinderInfo.implicit, Lean.BinderInfo.strictImplicit, Lean.BinderInfo.instImplicit, Unit.unit, Lean.Meta.MetaM, Lean.LocalDecl.binderInfo, Lean.Meta.resettingSynthInstanceCache, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.lctx, Array.push, Lean.Meta.Context.localInstances, Lean.LocalInstance.mk, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth],[]]
[le_or_gt,[le_or_lt],[Or, LE.le, GT.gt]]
[Lean.IR.ExplicitRC.Context.env,[],[Lean.Environment]]
[Lean.Elab.Tactic.evalClear,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Tactic.getFVarIds, Lean.Elab.Tactic.withMainContext, liftM, Lean.Meta.sortFVarIds, ForIn.forIn, PUnit.unit, Lean.Elab.Tactic.getMainGoal, Lean.Meta.clear, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.nil, Pure.pure, ForInStep.yield, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[Lean.Elab.Term.Quotation.runPrecheck,[Bind.bind, Lean.MonadOptions.getOptions, ite, Eq, and, Lean.Option.get, Lean.Elab.Term.Quotation.quotPrecheck, Lean.Elab.Term.Quotation.hygiene, Bool.true, ReaderT.run, Lean.Elab.Term.Quotation.precheck, Lean.Elab.Term.Quotation.Precheck.Context.mk, EmptyCollection.emptyCollection, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Lsp.DocumentUri,[String],[]]
[Lean.IR.UnreachableBranches.InterpContext.lctx,[],[Lean.IR.LocalContext]]
[Lean.Lsp.instToJsonDidChangeTextDocumentParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.DidChangeTextDocumentParams.textDocument, List.nil, Lean.Lsp.DidChangeTextDocumentParams.contentChanges],[Lean.ToJson, Lean.Lsp.DidChangeTextDocumentParams]]
[Lean.EnvironmentHeader.regions,[],[Array, Lean.CompactedRegion]]
[Set.setOf.unexpander,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesIdent, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Lean.Meta.Simp.instInhabitedContext,[Inhabited.mk, Lean.Meta.Simp.Context.mk, arbitrary],[Inhabited, Lean.Meta.Simp.Context]]
[Lean.Parser.orelseFn,[Lean.Parser.orelseFnCore, Bool.true],[Lean.Parser.ParserFn]]
[Nat.coprime.coprime_mul_left,[Nat.coprime.coprime_dvd_left, Nat.dvd_mul_left],[Nat.coprime]]
[instDecidableEqUInt16,[UInt16.decEq],[DecidableEq, UInt16]]
[Lean.Parser.Tactic.generalize,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.generalizeArg, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.EnvExtensionInterfaceUnsafe.Ext.noConfusionType,[],[]]
[Lean.Lsp.DidChangeTextDocumentParams.textDocument,[],[Lean.Lsp.VersionedTextDocumentIdentifier]]
[Lean.Parser.Tactic.hint,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Std.PersistentArray.foldr,[Id.run, Std.PersistentArray.foldrM],[]]
[Semiring.toNumeric,[],[Numeric]]
[Lean.PrettyPrinter.Parenthesizer.parserOfStack.parenthesizer,[Bind.bind, MonadState.get, Lean.PrettyPrinter.Parenthesizer.parenthesizerForKind, Lean.Syntax.getKind],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.gcd_mul_right_left,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.mul_comm, Nat.gcd_mul_left_left, rfl],[Eq, Nat.gcd, HMul.hMul]]
[Int.fmod,[Int.ofNat, Int.negSucc, Nat.succ, Int, OfNat.ofNat, HMod.hMod, Int.subNatNat, Neg.neg],[Int]]
[List.forA,[Unit.unit, PUnit, Pure.pure, PUnit.unit, SeqRight.seqRight, PProd.fst],[PUnit]]
[Lean.Elab.Term.Do.Code.continue.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.Do.Code.continue, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.Code.continue]]
[USize.decEq.proof_2,[absurd],[False]]
[Lean.EnumAttributes.noConfusionType,[],[]]
[Lean.Syntax.TopDown.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Syntax.TopDown.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Syntax.TopDown.mk, And]]
[Lean.PrefixTree.insert.proof_1,[Lean.PrefixTreeNode.WellFormed.insertWff, Subtype.property],[Lean.PrefixTreeNode.WellFormed, Lean.PrefixTreeNode.insert, Subtype.val]]
[UInt32.toUInt16,[Nat.toUInt16, UInt32.toNat],[UInt16]]
[Lean.Meta.AbstractMVarsResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.AbstractMVarsResult.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Environment.isNamespace,[Lean.NameSSet.contains, Lean.SimplePersistentEnvExtension.getState, Lean.namespacesExt],[Bool]]
[Array.isEmpty,[Decidable.decide, Eq, Array.size, OfNat.ofNat],[Bool]]
[Int.mod,[Int, Int.ofNat, HMod.hMod, Nat.succ, Neg.neg],[Int]]
[Lean.isEnumType,[Bind.bind, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Bool, ite, Eq, and, not, Lean.Expr.isProp, Lean.ConstantVal.type, Lean.InductiveVal.toConstantVal, BEq.beq, List.length, Lean.InductiveVal.all, OfNat.ofNat, Lean.InductiveVal.numIndices, Lean.InductiveVal.numParams, List.isEmpty, Lean.InductiveVal.ctors, Lean.InductiveVal.isRec, Lean.InductiveVal.isNested, Lean.InductiveVal.isUnsafe, Bool.true, List.allM, Lean.ConstantInfo.inductInfo, Pure.pure, Lean.ConstructorVal.numFields, Bool.false],[Bool]]
[Lean.Elab.WF.expandTerminationHint,[Option.none, Lean.MacroM, Lean.Elab.WF.TerminationHint, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Lean.Elab.WF.TerminationHint.one, Lean.Elab.WF.TerminationHintValue.mk, Lean.Syntax.getOp, OfNat.ofNat, Bind.bind, Array.foldlM, Unit.unit, Lean.NameMap, Lean.Elab.WF.TerminationHintValue, Lean.Macro.throwErrorAt, HAppend.hAppend, ToString.toString, Lean.Syntax.getId, Lean.NameMap.insert, EmptyCollection.emptyCollection, Lean.Syntax.getArgs, Array.size, ForIn.forIn, PUnit.unit, ForInStep, Option, Lean.Name, Lean.NameMap.find?, ForInStep.yield, Lean.Elab.WF.TerminationHint.many, Lean.Macro.throwUnsupported, Lean.Elab.WF.TerminationHint.none],[Lean.MacroM, Lean.Elab.WF.TerminationHint]]
[Lean.Xml.Parser.PublicID,[SeqLeft.seqLeft, Lean.Parsec.skipString, Lean.Xml.Parser.S, Lean.Xml.Parser.PubidLiteral],[Lean.Parsec, Unit]]
[Functor.mapRev,[Functor.map],[]]
[Array.«term__[_:]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Lsp.SymbolKind.string.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.string, OfNat.ofNat]]
[Lean.Elab.Command.Context.fileMap,[],[Lean.FileMap]]
[Lean.Elab.RecKind.default.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.RecKind.default, OfNat.ofNat]]
[instOrdChar,[Ord.mk, compareOfLessAndEq],[Ord, Char]]
[Lean.IR.JPLiveVarMap,[Std.RBMap, Lean.IR.JoinPointId, Lean.IR.LiveVarSet, Ord.compare, Lean.IR.JoinPointId.idx],[]]
[Lean.SCC.State.nextIndex,[],[Nat]]
[Lean.Parser.Trie.empty,[Lean.Parser.Trie.Node, Option.none, Std.RBNode.leaf],[Lean.Parser.Trie]]
[Lean.LocalContext.foldl,[Id.run, Lean.LocalContext.foldlM],[]]
[IO.FS.instReprSystemTime,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, IO.FS.SystemTime.sec, Std.Format.line, IO.FS.SystemTime.nsec],[Repr, IO.FS.SystemTime]]
[Lean.ParametricAttribute.attr,[],[Lean.AttributeImpl]]
[Functor.map_map,[Eq.symm, LawfulFunctor.comp_map],[Eq, Functor.map, Function.comp]]
[Lean.IR.FnBody.jdecl.inj,[And.intro],[And, Eq]]
[Measure,[InvImage, LT.lt],[]]
[List.nil_union,[of_eq_true, eq_self],[Eq, List.union, List.nil]]
[Nat.mul_lt_mul,[Nat.lt_of_lt_of_le, Nat.mul_lt_mul_of_pos_right, Nat.mul_le_mul_of_nonneg_left],[LT.lt, HMul.hMul]]
[Lean.Expr.hasExprMVar,[Lean.Expr.Data.hasExprMVar, Lean.Expr.data],[Bool]]
[Lean.IR.Checker.CheckerState.mk.inj,[],[Eq]]
[Std.HashSet.find?,[Option, Std.HashSetImp.find?],[Option]]
[String.toSubstring,[Substring.mk, OfNat.ofNat, String.bsize],[Substring]]
[Lean.Parser.Tactic.ext?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[prodHasDecidableLt,[inferInstanceAs, Decidable, Or, LT.lt, Prod.fst, And, Eq, Prod.snd],[Decidable, LT.lt]]
[Lean.Lsp.instFromJsonPosition,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Nat, Pure.pure, Lean.Lsp.Position.mk],[Lean.FromJson, Lean.Lsp.Position]]
[Lean.Lsp.WorkDoneProgressBegin.toWorkDoneProgressReport,[],[Lean.Lsp.WorkDoneProgressReport]]
[MonadState.noConfusionType,[],[]]
[Lean.mkListNode,[Lean.mkNullNode],[Lean.Syntax]]
[Lean.Parser.Tactic.congr,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Tactic.mapply,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[IO.FS.Stream.Buffer.pos,[],[Nat]]
[Lean.MonadCacheT.instAlternativeMonadCacheT,[inferInstanceAs, Alternative, StateRefT', Std.HashMap],[Alternative, Lean.MonadCacheT]]
[PSigma.snd,[],[PSigma.fst]]
[Lean.Syntax.MonadTraverser.goLeft,[modify, Lean.Syntax.Traverser.left],[Unit]]
[Quotient.liftOn,[Quot.liftOn],[]]
[Lean.JsonRpc.Notification.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonRpc.Notification.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.JsonRpc.Notification.mk, And]]
[Lean.Meta.getSimpLemmas,[Lean.Meta.SimpExtension.getLemmas, Lean.Meta.simpExtension],[Lean.Core.CoreM, Lean.Meta.SimpLemmas]]
[Lean.Meta.RecursorInfo.depElim,[],[Bool]]
[Lean.Meta.generalize,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarTag, Lean.Meta.getMVarType, Lean.Meta.instantiateMVars, OfNat.ofNat, Lean.Meta.isTypeCorrect, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.throwTacticEx, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Syntax.missing, Lean.Meta.generalize.go],[Lean.Meta.MetaM, Prod, Array, Lean.FVarId, Lean.MVarId]]
[Lean.Lsp.DocumentSymbolParams.mk.inj,[],[Eq]]
[Lean.Json.str.inj,[],[Eq]]
[Lean.Server.Watchdog.parseParams,[Lean.Server.Watchdog.ServerM, Lean.FromJson.fromJson?, Pure.pure, liftM, IO.throwServerError, HAppend.hAppend, ToString.toString, Lean.Json.compress],[Lean.Server.Watchdog.ServerM]]
[Lean.mkInductiveValEx,[Lean.InductiveVal.mk, Lean.ConstantVal.mk],[Lean.InductiveVal]]
[Lean.LocalContext.findDeclRevM?,[Std.PersistentArray.findSomeRevM?, Lean.LocalContext.decls, Unit.unit, Option, Pure.pure, Option.none],[Option]]
[Lean.AttributeKind.global.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.AttributeKind.global, OfNat.ofNat]]
[«term%[_|_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false],[Lean.ParserDescr]]
[Tactic.Ring.zero_horner,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, HAdd.hAdd, MonoidWithZero.zero_mul, HPow.hPow, zero_add, eq_self],[Eq, Tactic.Ring.horner, OfNat.ofNat]]
[UInt8.neg_def,[rfl],[Eq, Neg.neg, UInt8.mk, UInt8.val]]
[forall_eq',[of_eq_true, Eq.trans, congrFun, congrArg, Iff, forall_congr, implies_congr, propext, eq_comm, Eq.refl, forall_eq, iff_self],[Iff]]
[Lean.Rat.instNegRat,[Neg.mk, Lean.Rat.neg],[Neg, Lean.Rat]]
[String.codepointPosToUtf8PosFrom,[String.Pos, PProd.fst, String.next],[String.Pos]]
[Lean.Elab.Term.MkInstResult.instType,[],[Lean.Expr]]
[Lean.IR.Borrow.OwnedSet.instBEqKey,[BEq.mk, Lean.IR.Borrow.OwnedSet.beq],[BEq, Lean.IR.Borrow.OwnedSet.Key]]
[Lean.Module.commands,[],[Array, Lean.Syntax]]
[Lean.AttributeExtensionState.noConfusionType,[],[]]
[Lean.Elab.Term.Quotation.HeadCheck.unconditional.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Quotation.HeadCheck.unconditional, OfNat.ofNat]]
[Lean.TraceElem.msg,[],[Lean.MessageData]]
[Lean.Parser.Level.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.levelParser],[Lean.Parser.Parser]]
[Or.neg_resolve_right,[Or.elim, id, absurd],[]]
[Lean.Parser.Term.leftArrow.parenthesizer,[Lean.Parser.unicodeSymbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Syntax.unary,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.syntaxParser],[Lean.Parser.Parser]]
[Lean.PrettyPrinter.Formatter.checkStackTop.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Term.let_fun.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.letDecl.parenthesizer, Lean.Parser.Term.optSemicolon.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[DoResultPRBC.continue.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultPRBC.continue, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.FunInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.FunInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[OptionT.mk,[],[OptionT]]
[Lean.Elab.WF.TerminationHint.one.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.WF.TerminationHint.one, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.termParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.DiscrTree.mkNoindexAnnotation,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Expr]]
[Lean.IR.EmitC.emitIsTaggedPtr,[Bind.bind, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn],[Lean.IR.EmitC.M, Unit]]
[Lean.Elab.Command.State.mk.inj,[And.intro],[And, Eq]]
[DoResultBC.continue.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultBC.continue, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Tactic.SavedState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.SavedState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Tactic.SavedState.mk, And]]
[Lean.Lsp.RpcRef.noConfusionType,[],[]]
[instAddCommGroup.proof_1,[Semiring.add_zero],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Lean.PPContext.mctx,[],[Lean.MetavarContext]]
[Lean.Meta.DiscrTree.hasNoindexAnnotation,[Option.isSome, Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous],[Bool]]
[Lean.Name.reprPrec,[Unit.unit, Std.Format, Std.Format.text, Repr.addAppParen, HAppend.hAppend, PProd.fst, OfNat.ofNat, repr, ite, Eq, Bool, Bool.false, Bool.true, Lean.Name.toString],[Std.Format]]
[Lean.PrettyPrinter.Delaborator.delabDIte.delabBranch,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, guard, Eq, Lean.Expr.isLambda, Bool.true, Unit.unit, Lean.PrettyPrinter.Delaborator.DelabM, Prod, Lean.Syntax, Lean.Name, Lean.PrettyPrinter.Delaborator.SubExpr.withBindingBody, Lean.PrettyPrinter.Delaborator.delab, Pure.pure, Prod.mk, Lean.PrettyPrinter.Delaborator.withBindingBodyUnusedName, Lean.Syntax.getId],[Lean.PrettyPrinter.Delaborator.DelabM, Prod, Lean.Syntax, Lean.Name]]
[Lean.Parser.mkParserAttributeImpl,[Lean.AttributeImpl.mk, Lean.AttributeImplCore.mk, Lean.AttributeApplicationTime.afterCompilation, Bind.bind, Lean.Attribute.Builtin.getPrio, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, liftM, Lean.Parser.mkParserOfConstant, List.forM, MonadExcept.tryCatch, Lean.Parser.addToken, Lean.Exception.internal, Lean.AttrM, PUnit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, MonadExcept.throw, Std.PersistentHashMap.forM, Lean.MonadEnv.modifyEnv, Lean.Parser.addSyntaxNodeKind, Unit, Lean.Parser.addParser, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.ScopedEnvExtension.add, Lean.Parser.parserExtension],[Lean.AttributeImpl]]
[instToFormatProd,[Std.ToFormat.mk, Std.Format, Std.Format.paren, HAppend.hAppend, Std.ToFormat.format, Std.Format.text, Std.Format.line],[Std.ToFormat, Prod]]
[instSubUInt32,[Sub.mk, UInt32.sub],[Sub, UInt32]]
[Lean.instInhabitedDefinitionSafety,[Inhabited.mk, Lean.DefinitionSafety.unsafe],[Inhabited, Lean.DefinitionSafety]]
[Lean.Parser.orelseInfo,[Lean.Parser.ParserInfo.mk, Function.comp, Lean.Parser.ParserInfo.collectTokens, Lean.Parser.ParserInfo.collectKinds, Lean.Parser.FirstTokens.merge, Lean.Parser.ParserInfo.firstTokens],[Lean.Parser.ParserInfo]]
[Lean.Meta.InductionSubgoal.subst,[],[Lean.Meta.FVarSubst]]
[Lean.Elab.Tactic.evalRotateLeft,[Bind.bind, Lean.Elab.Tactic.getGoals, Lean.Elab.Tactic.setGoals, List.rotateLeft],[Lean.Elab.Tactic.Tactic]]
[Lean.ScopedEnvExtension.addScopedEntry,[Lean.PersistentEnvExtension.addEntry, Lean.ScopedEnvExtension.ext, Lean.ScopedEnvExtension.Entry.scoped],[Lean.Environment]]
[Lean.Meta.Match.Pattern.var.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Pattern.var, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.Pattern.var]]
[Lean.Lsp.Hover.contents,[],[Lean.Lsp.MarkupContent]]
[IO.FS.Metadata.accessed,[],[IO.FS.SystemTime]]
[Lean.IR.addParamsRename,[OptionM.run, ite, Eq, bne, Array.size, Bool.true, Alternative.failure, Bind.bind, ForIn.forIn, Lean.IR.addParamRename, Array.getOp, Pure.pure, PUnit.unit, ForInStep.yield],[Option, Lean.IR.IndexRenaming]]
[Lean.Parser.Command.decreasingBy.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.terminationHint.parenthesizer, Lean.Parser.Tactic.tacticSeq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Tactic.finCases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.ParserDescr.cat, Lean.ParserDescr.unary],[Lean.ParserDescr]]
[Lean.IR.Checker.checkVar,[Bind.bind, MonadReader.read, ite, Eq, or, Lean.IR.LocalContext.isLocalVar, Lean.IR.Checker.CheckerContext.localCtx, Lean.IR.VarId.idx, Lean.IR.LocalContext.isParam, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.IR.Checker.M, Unit]]
[Prod.snd_injective,[Prod.ext', Subsingleton.elim, Prod.fst],[Function.injective, Prod.snd]]
[Mathlib.ExtendedBinder.«term∀___,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[instReprUInt32,[Repr.mk, repr, UInt32.toNat],[Repr, UInt32]]
[StateT.seqRight_eq,[StateT.ext, Eq.mpr, congr, congrArg, Eq, StateT.run_seqRight, Eq.trans, StateT.run_seq, Functor.map, id, Bind.bind, StateT.run_map, map_eq_pure_bind, Prod.mk, Prod.snd, StateT.run, funext, Prod.fst, LawfulMonad.bind_assoc, Pure.pure, LawfulMonad.pure_bind, congrFun, id_eq, bind_congr, of_eq_true, Prod.ext, bind_pure, eq_self, Eq.symm, Eq.refl],[Eq, SeqRight.seqRight, Seq.seq, Functor.map, Function.const, id]]
[Function.extend_def,[Eq.mpr, Eq.refl, Eq, Function.extend, dite, Exists, Classical.choose, Subsingleton.elim, Classical.propDecidable, rfl],[Eq, Function.extend, dite, Exists, Classical.choose]]
[String.toInt?,[OptionM.run, ite, Eq, String.get, OfNat.ofNat, Char.ofNat, Bind.bind, Substring.toNat?, Substring.drop, String.toSubstring, Pure.pure, Neg.neg, Int.ofNat, Functor.map, String.toNat?],[Option, Int]]
[Lean.Meta.SynthInstance.getMaxHeartbeats,[HMul.hMul, Lean.Option.get, Lean.Meta.synthInstance.maxHeartbeats, OfNat.ofNat],[Nat]]
[Lean.Elab.Term.elabForIn,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Term.isLocalIdent?, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, List.nil, Lean.Elab.Term.elabTerm, Lean.Elab.Term.tryPostponeIfNoneOrMVar, liftM, Lean.Meta.inferType, Lean.Meta.mkFreshLevelMVar, Lean.Meta.mkFreshExprMVar, Option.some, Lean.mkSort, Lean.mkLevelSucc, Lean.MetavarKind.natural, MonadExcept.tryCatch, Lean.Meta.mkAppM, Lean.Elab.Term.tryPostpone, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Elab.throwUnsupportedSyntax, Lean.Elab.Term.elabForIn.getMonad, Lean.Elab.Term.elabForIn.throwFailure],[Lean.Elab.Term.TermElab]]
[Bool.false_and,[rfl, Eq.symm, Eq.refl],[Eq, and, Bool.false]]
[Lean.OpaqueVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.OpaqueVal.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Simp.pre,[Bind.bind, MonadReader.read, liftM, Lean.Meta.Simp.Methods.pre],[Lean.Meta.Simp.M, Lean.Meta.Simp.Step]]
[Lean.Elab.Term.instMonadTermElabM,[Monad.mk],[Monad, Lean.Elab.Term.TermElabM]]
[Lean.IR.getEnv,[Bind.bind, MonadState.get, Pure.pure, Lean.IR.CompilerState.env],[Lean.IR.CompilerM, Lean.Environment]]
[Lean.Lsp.Location.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.Location.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.Location.mk, And]]
[Lean.Server.FileWorker.queueRequest,[Lean.Server.FileWorker.updatePendingRequests, Std.RBMap.insert],[Lean.Server.FileWorker.WorkerM, Unit]]
[Lean.Meta.DiscrTree.insert,[Bind.bind, Lean.Meta.DiscrTree.mkPath, Pure.pure, Lean.Meta.DiscrTree.insertCore],[Lean.Meta.MetaM, Lean.Meta.DiscrTree]]
[Lean.MonadStateCacheT.instMonadHashMapCacheAdapterMonadStateCacheT,[Lean.MonadHashMapCacheAdapter.mk, MonadState.get, modify],[Lean.MonadHashMapCacheAdapter, Lean.MonadStateCacheT]]
[USize.instSemigroupUSize.proof_1,[congrArg, USize.mk, Semigroup.mul_assoc, USize.val],[Eq, USize.mk]]
[Lean.Meta.IndPredBelow.Variables.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.IndPredBelow.Variables.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.abel!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.PrettyPrinter.mkCombinatorParenthesizerAttribute,[Lean.ParserCompiler.registerCombinatorAttribute, Lean.Name.mkStr, Lean.Name.anonymous],[IO, Lean.ParserCompiler.CombinatorAttribute]]
[Lean.Elab.Term.LetRecToLift.noConfusionType,[],[]]
[Lean.NameMap.instEmptyCollectionNameMap,[EmptyCollection.mk, Lean.mkNameMap],[EmptyCollection, Lean.NameMap]]
[Lean.Message.mk.inj,[And.intro],[And, Eq]]
[IO.Error.resourceBusy.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.resourceBusy, HAdd.hAdd, OfNat.ofNat]]
[UInt32.add_def,[rfl],[Eq, HAdd.hAdd, UInt32.mk, UInt32.val]]
[Lean.Elab.FieldInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.FieldInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.evalExpr,[Lean.withoutModifyingEnv, Bind.bind, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.inferType, Lean.Meta.whnfD, ite, Eq, Lean.Expr.isConstOf, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr],[Lean.Elab.Term.TermElabM]]
[Lean.Elab.Term.Do.ToTerm.Kind.noConfusion,[noConfusionEnum, Lean.Elab.Term.Do.ToTerm.Kind.toCtorIdx],[Lean.Elab.Term.Do.ToTerm.Kind.noConfusionType]]
[Std.Format.group.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.Format.group, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.Format.group, And]]
[Lean.Parser.Tactic.squeezeDSimp?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Parser.Tactic.refine,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[StateT.run_monadMap,[rfl],[Eq, StateT.run, MonadFunctorT.monadMap]]
[Lean.Meta.mkAdd,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getDecLevel, Lean.Meta.synthInstance, Lean.mkApp3, Lean.mkConst, List.cons, List.nil, Option.none, Pure.pure, Lean.mkApp6, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Elab.logWarning,[Lean.Elab.log, Lean.MessageSeverity.warning],[Unit]]
[Std.RBTree.all,[Std.RBMap.all],[Bool]]
[Lean.PrettyPrinter.Formatter.State.noConfusionType,[],[]]
[Lean.MetavarContext.lDepth,[],[Std.PersistentHashMap, Lean.MVarId, Nat]]
[withTheReader,[MonadWithReaderOf.withReader],[]]
[Lean.LocalInstance.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.deltaRHS?,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getMVarType', Pure.pure, Lean.Expr.eq?, Option.none, Lean.Meta.MetaM, Option, Lean.MVarId, liftM, Lean.Meta.delta?, BEq.beq, Lean.Meta.mkEq, coeM, Lean.Meta.replaceTargetDefEq, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing],[Lean.Meta.MetaM, Option, Lean.MVarId]]
[UInt16.size,[OfNat.ofNat],[Nat]]
[Lean.Elab.Term.ElabAppArgs.State.etaArgs,[],[Array, Lean.Expr]]
[Lean.Elab.Term.MVarErrorKind.noConfusionType,[],[]]
[Lean.Parser.Term.tupleTail.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.termParser.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Std.Range.mk.inj,[And.intro],[And, Eq]]
[List.mapA,[Unit.unit, List, Pure.pure, List.nil, Seq.seq, Functor.map, List.cons, PProd.fst],[List]]
[UInt8.sub_def,[rfl],[Eq, HSub.hSub, UInt8.mk, UInt8.val]]
[FloatArray.noConfusionType,[],[]]
[Fin.instShiftLeftFin,[ShiftLeft.mk, Fin.shiftLeft],[ShiftLeft, Fin]]
[termIfThenElse,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.instBEqAttributeApplicationTime,[BEq.mk, BEq.beq, Lean.AttributeApplicationTime.toCtorIdx],[BEq, Lean.AttributeApplicationTime]]
[Lean.Elab.Term.CollectPatternVars.State.mk.inj,[And.intro],[And, Eq]]
[Lean.ModuleIdx,[Nat],[]]
[Lean.Meta.CheckAssignment.instMonadCacheExprExprCheckAssignmentM,[Lean.MonadCache.mk, Bind.bind, MonadState.get, Pure.pure, Std.HashMap.find?, Lean.Meta.CheckAssignment.State.cache, Lean.ExprStructEq.mk, modify, Lean.Meta.CheckAssignment.State.mk, Std.HashMap.insert],[Lean.MonadCache, Lean.Expr, Lean.Meta.CheckAssignment.CheckAssignmentM]]
[Lean.Json.CompressWorkItem.json.inj,[],[Eq]]
[Lean.Lsp.TextEdit.noConfusionType,[],[]]
[String.repeat,[String.mk, List.repeat],[String]]
[Lean.Expr.arrayLit?,[Unit.unit, Option, Prod, Lean.Expr, List, Lean.Expr.app2?, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Expr.listLit?, Option.none],[Option, Prod, Lean.Expr, List]]
[Lean.Meta.getMVars,[Bind.bind, StateRefT'.run, Lean.Meta.collectMVars, Lean.CollectMVars.State.mk, Lean.Meta.MetaM, Array, Lean.MVarId, Pure.pure, Lean.CollectMVars.State.result],[Lean.Meta.MetaM, Array, Lean.MVarId]]
[Alternative.orElse,[],[]]
[stx!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.isExtern,[Option.isSome, Lean.getExternAttrData],[Bool]]
[and_not_self_iff,[Iff.intro, And.right, And.left, False.elim],[Iff, And, Not, False]]
[Lean.Tactic.solveByElim,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Parser.Term.match.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.generalizingParam.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.Term.matchDiscr.parenthesizer, Bool.false, Lean.Parser.Term.optType.parenthesizer, Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.WorkDoneProgressReport.noConfusionType,[],[]]
[Lean.Elab.Command.StructFieldView.binderInfo,[],[Lean.BinderInfo]]
[Lean.Parser.isParserCategory,[Std.PersistentHashMap.contains, Lean.Parser.ParserExtension.State.categories, Lean.ScopedEnvExtension.getState, Lean.Parser.parserExtension],[Bool]]
[Lean.Meta.mkAuxDefinition,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Meta.Match.MatchEqns.splitterName,[],[Lean.Name]]
[Lean.Compiler.InlineAttributeKind.macroInline.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Compiler.InlineAttributeKind.macroInline, OfNat.ofNat]]
[exists_prop_decidable.proof_2,[mt],[Not, Exists]]
[Lean.Elab.MacroExpansionInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.MacroExpansionInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.instBEqVarId,[BEq.mk, BEq.beq, Lean.IR.VarId.idx],[BEq, Lean.IR.VarId]]
[Lean.Name.toString.maybePseudoSyntax,[Lean.Name.anonymous, Lean.Name.num, Bool, Lean.Name.getRoot, or, String.isPrefixOf, Bool.false],[Bool]]
[Lean.IR.ExpandResetReuse.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.ExpandResetReuse.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.doSeqBracketed,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.withoutPosition, Lean.Parser.many1, Lean.Parser.Term.doSeqItem, Lean.Parser.ppLine],[Lean.Parser.Parser]]
[Lean.Meta.CaseArraySizesSubgoal.elems,[],[Array, Lean.FVarId]]
[Lean.Parser.Term.do,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.argPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.doSeq],[Lean.Parser.Parser]]
[Lean.IR.Expr.uproj.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.uproj, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Expr.uproj, And]]
[Lean.Parser.Term.whereDecls.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1Indent.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.Term.letRecDecl.parenthesizer, Lean.Parser.optional.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Subtype.prop,[Subtype.property],[Subtype.val]]
[Nat.gcd_mul_lcm,[],[Eq, HMul.hMul, Nat.gcd, Nat.lcm]]
[Lean.Export.alloc,[Bind.bind, MonadState.get, modify, Lean.Export.OfState.modify, Lean.Export.Alloc.mk, Std.HashMap.insert, Lean.Export.Alloc.map, HAdd.hAdd, OfNat.ofNat, Pure.pure],[Lean.ExportM, Nat]]
[Lean.Parser.symbol,[Lean.Parser.tokenWithAntiquot, Lean.Parser.symbolNoAntiquot],[Lean.Parser.Parser]]
[Lean.Meta.project?,[Bind.bind, Lean.Meta.whnf, Lean.matchConstCtor, Lean.Expr.getAppFn, Pure.pure, Option.none, ite, LT.lt, Option.some, Lean.Expr.getArg!, Lean.Expr.getAppNumArgs],[Lean.Meta.MetaM, Option, Lean.Expr]]
[Lean.PrettyPrinter.Formatter.eoi.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[Ord.compare,[],[Ordering]]
[String.takeRight,[Substring.toString, Substring.takeRight, String.toSubstring],[String]]
[Char.isAlpha,[or, Char.isUpper, Char.isLower],[Bool]]
[Lean.Macro.trace,[modify, Lean.Macro.State.mk, Lean.Macro.State.macroScope, List.cons, Prod.mk, Lean.Macro.State.traceMsgs],[Lean.MacroM, Unit]]
[Lean.Lsp.instHashableRange,[Hashable.mk, UInt64, mixHash, OfNat.ofNat, Hashable.hash],[Hashable, Lean.Lsp.Range]]
[Lean.Elab.throwAbortTactic,[MonadExcept.throw, Lean.Exception.internal, Lean.Elab.abortTacticExceptionId, Lean.KVMap.mk],[]]
[Lean.traceM,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, Pure.pure, PUnit.unit],[Unit]]
[Lean.Parser.Term.termTry.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer, Lean.Parser.many.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.doCatch.parenthesizer, Lean.Parser.Term.doCatchMatch.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.doFinally.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.DidChangeTextDocumentParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.DidChangeTextDocumentParams.mk, HAdd.hAdd, OfNat.ofNat]]
[MonadFinally.noConfusionType,[],[]]
[Lean.PrettyPrinter.Formatter.manyNoAntiquot.formatter,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.PrettyPrinter.Formatter.visitArgs, Nat.forM, Array.size, Lean.Syntax.getArgs],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.FVarSubst.noConfusionType,[],[]]
[Lean.Expr.letE.inj,[And.intro],[And, Eq]]
[List.isEqv,[List.nil, List.cons, Bool, Bool.true, and, PProd.fst, Bool.false],[Bool]]
[Lean.Parser.Term.termUnless,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.withForbidden, Lean.Parser.termParser, Lean.Parser.Term.doSeq],[Lean.Parser.Parser]]
[Lean.Elab.Term.Do.mkSeq,[Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.seq, Lean.Elab.Term.Do.CodeBlock.code, Lean.Elab.Term.Do.CodeBlock.uvars],[Lean.Elab.Term.Do.CodeBlock]]
[UInt32.ofNat,[UInt32.mk, Fin.ofNat],[UInt32]]
[Tactic.Ring.HornerExpr.noConfusionType,[],[]]
[Lean.Elab.ContextInfo.runMetaM,[Bind.bind, Lean.Core.CoreM.toIO, Lean.Core.Context.mk, Lean.Elab.ContextInfo.options, Lean.Elab.ContextInfo.currNamespace, Lean.Elab.ContextInfo.openDecls, Lean.Core.State.mk, Lean.Elab.ContextInfo.env, IO, Pure.pure],[IO]]
[Lean.Level.PP.Result.ibelow,[True, And],[]]
[Lean.Elab.instInhabitedTacticInfo,[Inhabited.mk, Lean.Elab.TacticInfo.mk, arbitrary],[Inhabited, Lean.Elab.TacticInfo]]
[Lean.PPContext.lctx,[],[Lean.LocalContext]]
[Lean.Elab.Tactic.Conv.evalLhs,[Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Elab.Tactic.Conv.congr, ite, GE.ge, OfNat.ofNat, dite, LT.lt, List.length, ForIn.forIn, Unit.unit, Lean.Elab.Tactic.TacticM, ForInStep, Std.Range, Stream.next?, Pure.pure, ForInStep.done, Eq, bne, Bool.true, Lean.Meta.applyRefl, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, ForInStep.yield, PUnit.unit, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.get, List.nil, HSub.hSub, Int.ofNat],[Lean.Elab.Tactic.Tactic]]
[Lean.Elab.checkSyntaxNodeKind,[Bind.bind, Lean.MonadEnv.getEnv, ite, Eq, Lean.Parser.isValidSyntaxNodeKind, Bool.true, Pure.pure, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Name]]
[Lean.Elab.Command.withNamespace,[Bind.bind, Unit.unit, Lean.Name.num, Lean.Elab.Command.CommandElabM, Unit, Pure.pure, PProd.fst, Lean.MonadResolveName.getCurrNamespace, modify, Lean.Elab.Command.State.mk, Lean.Environment.registerNamespace, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, List.cons, Lean.Elab.Command.Scope.mk, Lean.Elab.Command.Scope.opts, Lean.Elab.Command.Scope.openDecls, Lean.Elab.Command.Scope.levelNames, Lean.Elab.Command.Scope.varDecls, Lean.Elab.Command.Scope.varUIds, or, Lean.Elab.Command.Scope.isNoncomputable, List.head!, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Lean.pushScope, ite, Eq, Bool.true, Lean.activateScoped, PUnit.unit, Lean.Name.mkStr, Lean.throwError, Lean.ToMessageData.toMessageData, Bool.false, List.drop, Lean.Name.getNumParts],[Lean.Elab.Command.CommandElabM]]
[Lean.Widget.InfoPopup.exprExplicit,[],[Option, Lean.Widget.CodeWithInfos]]
[Lean.Parser.Term.doSeqIndent.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.many1Indent.formatter, Lean.Parser.Term.doSeqItem.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.PrettyPrinter.Formatter.checkTailWs.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[Lean.Server.FileWorker.GoToKind.declaration.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Server.FileWorker.GoToKind.declaration, OfNat.ofNat]]
[Lean.Expr.ReplaceImpl.cache.proof_1,[lcProof],[LT.lt, USize.toNat, Array.size]]
[Lean.IR.instInhabitedVarId,[Inhabited.mk, Lean.IR.VarId.mk, arbitrary],[Inhabited, Lean.IR.VarId]]
[imp_iff_right,[Iff.intro, imp_intro],[Iff]]
[Lean.Elab.Term.isMonadApp,[Bind.bind, Lean.Elab.Term.isTypeApp?, Option.none, Lean.Elab.Term.TermElabM, Bool, liftM, Lean.Meta.isMonad?, Pure.pure, Option.isSome, Bool.false],[Lean.Elab.Term.TermElabM, Bool]]
[Lean.Parser.Tactic.rcases?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.casesTarget, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Meta.generalizeIndices,[Lean.Meta.withMVarContext, Bind.bind, Lean.MonadLCtx.getLCtx, Lean.Meta.getLocalInstances, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getLocalDecl, Lean.Meta.whnf, Lean.LocalDecl.type, Lean.Expr.withApp, Lean.matchConstInduct, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing, ite, GT.gt, Lean.InductiveVal.numIndices, OfNat.ofNat, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Lean.Meta.GeneralizeIndicesSubgoal]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.instMonadReaderOfSubExprAnalyzeM,[MonadReaderOf.mk, Functor.map, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.subExpr, MonadReader.read],[MonadReaderOf, Lean.PrettyPrinter.Delaborator.SubExpr, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM]]
[Lean.Parser.Attr.defaultInstance,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.optional, Lean.Parser.priorityParser],[Lean.Parser.Parser]]
[Lean.Elab.Frontend.State.parserState,[],[Lean.Parser.ModuleParserState]]
[List.cons_append,[rfl],[Eq, HAppend.hAppend, List.cons]]
[Function.update_eq_self,[Iff.mpr, Function.update_eq_iff, And.intro, rfl],[Eq, Function.update]]
[Int.zero_mul,[Int.mul_zero, Int.mul_comm, OfNat.ofNat],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Lsp.TextDocumentIdentifier.noConfusionType,[],[]]
[DoResultBC.noConfusionType,[],[]]
[Std.AssocList.all,[Unit.unit, Bool, Bool.true, and, PProd.fst],[Bool]]
[optParam,[],[]]
[Lean.Elab.Deriving.FromToJson.mkToJsonInstanceHandler,[ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.isStructure, Array.getOp, Lean.Elab.Command.liftTermElabM, Option.none, Lean.Elab.Deriving.mkContext, Lean.Elab.Deriving.mkHeader, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.Deriving.Context.typeInfos, Array.mapM, Lean.Elab.Deriving.FromToJson.mkJsonField, Lean.Elab.Term.TermElabM, Lean.Syntax, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.mkIdent, HAppend.hAppend, Lean.Elab.Deriving.Header.targetNames, Lean.Syntax.atom, Lean.Elab.Deriving.Context.auxFunNames, Array.append, Lean.Elab.Deriving.Header.binders, Lean.Syntax.SepArray.elemsAndSeps, Lean.Syntax.SepArray.ofElems, Lean.Elab.Deriving.mkInstanceCmds, Array.forM, Lean.Elab.Command.elabCommand, Lean.getConstInfoInduct, Lean.Elab.Deriving.mkDiscrs, dite, Option.some, Eq.symm, Array.toArrayLit_eq, Array.getLit, of_decide_eq_true, id, Eq.refl, Lean.Quote.quote, Lean.Name.getString!, Lean.ConstantVal.name, Lean.ConstructorVal.toConstantVal, Lean.mkSepArray, Array.map, Lean.mkAtom, Array.mapIdxM, Fin.val, Lean.Elab.Deriving.Context.usePartial, Lean.Elab.Deriving.mkLocalInstanceLetDecls, Lean.Elab.Deriving.Header.argNames, Lean.Elab.Deriving.mkLet, PUnit.unit, Bool.false, Lean.Elab.Deriving.FromToJson.mkToJsonInstanceHandler.mkAlts],[Lean.Elab.Command.CommandElabM, Bool]]
[Lean.Parser.Command.structure.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.structureTk.formatter, Lean.Parser.Command.classTk.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.many.formatter, Lean.ppSpace.formatter, Lean.Parser.Term.bracketedBinder.formatter, Bool.false, Lean.Parser.optional.formatter, Lean.Parser.Command.extends.formatter, Lean.Parser.Term.optType.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.structCtor.formatter, Lean.Parser.Command.structFields.formatter, Lean.Parser.Command.optDeriving.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.instToFormatProdNameDataValue,[Std.ToFormat.mk, Std.Format, HAppend.hAppend, Std.ToFormat.format, Std.Format.text],[Std.ToFormat, Prod, Lean.Name, Lean.DataValue]]
[Lean.replaceRef,[Option.none, Lean.Syntax, Lean.Syntax.getPos?, Bool.false],[Lean.Syntax]]
[Lean.Elab.Command.ElabHeaderResult.lctx,[],[Lean.LocalContext]]
[Lean.Xml.Content.Element.injEq,[Eq.propIntro, Eq.refl, Lean.Xml.Content.Element, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Xml.Content.Element]]
[Lean.Elab.Tactic.elabTermEnsuringType,[Bind.bind, Lean.Elab.Tactic.elabTerm, Unit.unit, Lean.Elab.Tactic.TacticM, Lean.Expr, Pure.pure, liftM, Lean.Meta.inferType, Lean.Meta.withAssignableSyntheticOpaque, Lean.Meta.isDefEq, ite, Eq, Bool.true, PUnit.unit, Lean.Elab.Term.throwTypeMismatchError, Option.none],[Lean.Elab.Tactic.TacticM, Lean.Expr]]
[Lean.KVMap.forIn,[List.forIn, Lean.KVMap.entries],[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isDefEqAssigning,[MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Config.mk, Lean.Meta.Config.foApprox, Lean.Meta.Config.ctxApprox, Lean.Meta.Config.quasiPatternApprox, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Bool.true, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct, Lean.Meta.Context.lctx, Lean.Meta.Context.localInstances, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth, Lean.Meta.isDefEq],[Lean.Meta.MetaM, Bool]]
[Lean.Elab.ExpandDeclIdResult.levelNames,[],[List, Lean.Name]]
[Lean.Elab.Term.getMainModule,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Environment.mainModule],[Lean.Elab.Term.TermElabM, Lean.Name]]
[UInt32.instSemiringUInt32.proof_4,[congrArg, UInt32.mk, AddMonoid.nsmul_succ', UInt32.val],[Eq, UInt32.mk, Semiring.nsmul, Nat.succ, UInt32.val]]
[Lean.Level.Data.hasParam,[BEq.beq, UInt64.land, UInt64.shiftRight, OfNat.ofNat],[Bool]]
[Lean.Occurrences.neg.injEq,[Eq.propIntro, Eq.refl, Lean.Occurrences.neg, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Occurrences.neg]]
[instHMod,[HMod.mk, Mod.mod],[HMod]]
[iff_false_left,[Iff.intro, mt, Iff.mpr, iff_of_false],[Iff, Not]]
[not_of_not_not_not,[absurd, not_not_intro],[Not]]
[Lean.Expr.letName!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Name, panicWithPosWithDecl, OfNat.ofNat],[Lean.Name]]
[Lean.Server.FileWorker.SemanticTokensState.noConfusionType,[],[]]
[Lean.Elab.ContextInfo.noConfusionType,[],[]]
[Lean.Elab.Attribute.noConfusionType,[],[]]
[Lean.Meta.Match.instReprMatchEqns,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.Meta.Match.MatchEqns.eqnNames, Std.Format.line, Lean.Meta.Match.MatchEqns.splitterName, Lean.Meta.Match.MatchEqns.splitterAltNumParams],[Repr, Lean.Meta.Match.MatchEqns]]
[decidable_of_iff',[decidable_of_decidable_of_iff, Iff.symm],[Decidable]]
[Lean.Occurrences.noConfusionType,[],[]]
[Lean.Syntax.setArg,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.node, Array.setD],[Lean.Syntax]]
[Lean.Elab.Tactic.Conv.isImplies,[ite, Eq, Lean.Expr.isArrow, Bool.true, andM, Lean.Meta.isProp, Lean.Expr.bindingDomain!, Lean.Expr.bindingBody!, Pure.pure, Bool.false],[Lean.Meta.MetaM, Bool]]
[Tactic.Ring.HornerExpr.xadd',[Bind.bind, Tactic.Ring.mkAppCS, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Tactic.Ring.HornerExpr.e, Prod.fst, List.nil, Pure.pure, Tactic.Ring.HornerExpr.xadd],[Tactic.Ring.RingM, Tactic.Ring.HornerExpr]]
[Lean.Meta.getCongrLemmas,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.ScopedEnvExtension.getState, Lean.Meta.congrExtension],[Lean.Meta.MetaM, Lean.Meta.CongrLemmas]]
[instInhabitedUSize,[Inhabited.mk, USize.ofNatCore, OfNat.ofNat, instInhabitedUSize.proof_1],[Inhabited, USize]]
[Semiring.zero_mul,[],[Eq, HMul.hMul, OfNat.ofNat]]
[UInt16.instRingUInt16.proof_4,[congrArg, UInt16.mk, SubNegMonoid.gsmul_neg', UInt16.val],[Eq, UInt16.mk, Ring.gsmul, Int.negSucc, UInt16.val]]
[Lean.isInitializerExecutionEnabled,[ST.Ref.get],[IO, Bool]]
[Lean.Lsp.CompletionItem.detail?,[],[Option, String]]
[List.drop_eq_nil_of_le,[Eq.mpr, Eq.refl, Eq, List.drop, List.nil, Eq.symm, List.length'_eq_length, List.drop_eq_nil_of_le'],[Eq, List.drop, List.nil]]
[Lean.Parser.many.formatter,[Lean.PrettyPrinter.Formatter.manyNoAntiquot.formatter, Lean.Parser.withAntiquotSpliceAndSuffix.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Ring.sub_eq_add_neg,[],[Eq, HSub.hSub, HAdd.hAdd, Neg.neg]]
[Lean.Widget.Lean.Widget.InteractiveTermGoal.instRpcEncodingInteractiveTermGoalRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Lean.Widget.InteractiveTermGoal.hyps, Lean.Widget.InteractiveTermGoal.type, Lean.Widget.InteractiveTermGoal.range, Pure.pure, Lean.Server.RpcEncoding.rpcDecode, Lean.Widget.InteractiveTermGoal.mk],[Lean.Server.RpcEncoding, Lean.Widget.InteractiveTermGoal]]
[Lean.Parser.Command.declaration,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Command.declModifiers, Bool.false, HOrElse.hOrElse, Lean.Parser.Command.abbrev, Lean.Parser.Command.def, Lean.Parser.Command.theorem, Lean.Parser.Command.constant, Lean.Parser.Command.instance, Lean.Parser.Command.axiom, Lean.Parser.Command.example, Lean.Parser.Command.inductive, Lean.Parser.Command.classInductive, Lean.Parser.Command.structure],[Lean.Parser.Parser]]
[StdGen.mk.inj,[And.intro],[And, Eq]]
[Lean.ExternEntry.adhoc.injEq,[Eq.propIntro, Eq.refl, Lean.ExternEntry.adhoc, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ExternEntry.adhoc]]
[Lean.Lsp.SemanticTokenType.toNat,[Unit.unit, Nat, OfNat.ofNat],[Nat]]
[Nat.foldAux,[PProd.fst, HSub.hSub, Nat.succ],[]]
[Lean.LocalContext.modifyLocalDecl,[Lean.LocalContext, Unit.unit, Lean.LocalContext.find?, Lean.LocalContext.mk, Std.PersistentHashMap.insert, Lean.LocalDecl.fvarId, Std.PersistentArray.set, Lean.LocalDecl.index, Option.some],[Lean.LocalContext]]
[add_left_neg,[AddGroup.add_left_neg],[Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat]]
[Lean.Lsp.LocationLink.originSelectionRange?,[],[Option, Lean.Lsp.Range]]
[EStateM.Result.ok.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, EStateM.Result.ok, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.Do.DoIfView.ref,[],[Lean.Syntax]]
[Lean.Elab.Term.StructInst.ExplicitSourceInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.StructInst.ExplicitSourceInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.waitIfContainsMVar,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Std.PersistentHashSet.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.PersistentHashSet.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Tactic.Conv.evalParen,[Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Elab.Tactic.Tactic]]
[Lean.Server.parseRequestParams,[Except.mapError, Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.parseError, HAppend.hAppend, ToString.toString, Lean.Json.compress, Lean.FromJson.fromJson?],[Except, Lean.Server.RequestError]]
[Nat.zero_lt_of_lt,[LT.lt, OfNat.ofNat],[LT.lt, OfNat.ofNat]]
[Ne.def,[rfl],[Eq, Ne, Not]]
[Lean.Meta.subst,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getLocalDecl, Lean.Meta.matchEq?, Lean.LocalDecl.type, Unit.unit, Lean.Meta.MetaM, Lean.MVarId, Lean.Meta.whnf, ite, Eq, Lean.Expr.isFVar, Bool.true, bne, Lean.Meta.mkEq, Lean.Meta.substCore, Lean.Meta.FVarSubst.mk, Pure.pure, Prod.snd, Bool.false, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Syntax.missing, Lean.LocalDecl.isLet, Lean.mkFVar, PUnit.unit],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.Expr.FindImpl.findUnsafe?,[Id.run, StateT.run', Lean.Expr.FindImpl.findM?, Lean.Expr.FindImpl.cacheSize, Lean.Expr.FindImpl.initCache],[Option, Lean.Expr]]
[Lean.Elab.instantiateMVarsAtPreDecls,[Array.mapM, Bind.bind, liftM, Lean.Meta.instantiateMVars, Lean.Elab.PreDefinition.type, Lean.Elab.PreDefinition.value, Pure.pure, Lean.Elab.PreDefinition.mk, Lean.Elab.PreDefinition.ref, Lean.Elab.PreDefinition.kind, Lean.Elab.PreDefinition.levelParams, Lean.Elab.PreDefinition.modifiers, Lean.Elab.PreDefinition.declName],[Lean.Elab.Term.TermElabM, Array, Lean.Elab.PreDefinition]]
[Lean.Server.Watchdog.PendingRequestMap,[Std.RBMap, Lean.JsonRpc.RequestID, Lean.JsonRpc.Message, Ord.compare],[]]
[Lean.PrettyPrinter.Parenthesizer.numLit.parenthesizer,[Lean.Parser.Term.num.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.instToStringVisibility,[ToString.mk, Unit.unit, String],[ToString, Lean.Elab.Visibility]]
[Thunk.noConfusionType,[],[]]
[Lean.Lsp.ProgressParams.value,[],[]]
[Std.RBNode.balance₃,[Std.RBNode.leaf, Std.RBNode.node, Std.Rbcolor.red, Std.Rbcolor.black, Std.RBNode],[Std.RBNode]]
[Lean.Xml.Parser.predefinedEntityToChar,[dite, Eq, Unit.unit, Eq.symm, Option, Lean.Xml.Parser.LeanChar, Option.some, Char.ofNat, Option.none],[Option, Lean.Xml.Parser.LeanChar]]
[ByteSlice.toArray,[ByteArray, ByteArray.extract],[ByteArray]]
[Lean.Expr.fvarId!,[Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.FVarId, panicWithPosWithDecl, OfNat.ofNat],[Lean.FVarId]]
[List.length_pos_iff_exists_mem,[Iff.intro, List.exists_mem_of_length_pos, LT.lt, OfNat.ofNat, List.length, List.length_pos_of_mem],[Iff, LT.lt, OfNat.ofNat, List.length, Exists, Mem.mem]]
[Lean.Elab.Deriving.DecEq.mkAuxFunction,[Bind.bind, Pure.pure, Array.getOp, Lean.Elab.Deriving.Context.auxFunNames, OfNat.ofNat, Lean.Elab.Deriving.Context.typeInfos, Lean.Elab.Deriving.DecEq.mkDecEqHeader, Lean.Elab.Deriving.DecEq.mkMatch, Lean.Elab.Deriving.Header.argNames, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom, Lean.mkIdent, Lean.Elab.Deriving.Header.targetNames, Array.append],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[of_as_true,[False.elim],[]]
[Lean.Lsp.SemanticTokensRangeParams.textDocument,[],[Lean.Lsp.TextDocumentIdentifier]]
[Nat.dvd_gcd,[Nat.gcd.induction, Eq.mpr, Eq.refl, Dvd.dvd, Nat.gcd, OfNat.ofNat, Nat.gcd_zero_left, Nat.gcd_rec, Iff.mpr, Nat.dvd_mod_iff],[Dvd.dvd, Nat.gcd]]
[Lean.IR.CompilerM,[ReaderT, Lean.Options, EStateM, String, Lean.IR.CompilerState],[]]
[Lean.Server.Watchdog.WorkerEvent.terminated.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Server.Watchdog.WorkerEvent.terminated, OfNat.ofNat]]
[Array.size_mkArray,[List.length_replicate],[Eq, Array.size, Array.mkArray]]
[Function.cantor_surjective,[False],[Not, Function.surjective]]
[or_of_or_of_imp_right,[Or.imp_right],[Or]]
[Std.PersistentHashMap.find?,[Option, Std.PersistentHashMap.findAux, UInt64.toUSize, Hashable.hash],[Option]]
[Lean.ModuleData.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ModuleData.mk, HAdd.hAdd, OfNat.ofNat]]
[ExceptT.bind_throw,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, LawfulMonad.pure_bind, Except.error, Except, Pure.pure, eq_self],[Eq, Bind.bind, MonadExcept.throw]]
[Nat.lt_of_sub_eq_succ,[Iff.mp, not_le, False.elim, Eq.mp, Eq.trans, congrFun, congrArg, Eq, Nat.sub_eq_zero_of_le, Nat.succ, eq_false'],[LT.lt]]
[Lean.PrefixTreeNode.Node.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.letIdDeclNoBinders,[Lean.Parser.node, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.Term.ident, Lean.Parser.pushNone, Lean.Parser.Term.optType, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.QuotKind.lift.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.QuotKind.lift, OfNat.ofNat]]
[Lean.Elab.Command.Scope.noConfusionType,[],[]]
[Lean.Elab.TacticInfo.goalsBefore,[],[List, Lean.MVarId]]
[Iff.noConfusionType,[],[]]
[Mathlib.Tactic.Lint.heuristicallyExtractSimpLemmasCore,[Id.run, Bind.bind, ForIn.forIn, ite, Eq, Std.PersistentHashSet.contains, Lean.Meta.SimpLemmas.toUnfold, Lean.Meta.Simp.Context.simpLemmas, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, Lean.SMap.contains, Lean.Meta.CongrLemmas.lemmas, Lean.Meta.Simp.Context.congrLemmas, Option.none, Id, ForInStep, Std.HashSet, Lean.Name, Std.HashMap.find?, Std.HashSet.toArray],[Array, Lean.Name]]
[Lean.PrettyPrinter.Delaborator.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PrettyPrinter.Delaborator.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.TransparencyMode.reducible.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.TransparencyMode.reducible, OfNat.ofNat]]
[Lean.SimplePersistentEnvExtensionDescr.mk.inj,[And.intro],[And, Eq]]
[Set.mem,[],[]]
[Nat.dvd_gcd_iff,[Iff.intro, And.intro, Nat.dvd_trans, And.left, Nat.gcd_dvd, And.right, Nat.dvd_gcd],[Iff, Dvd.dvd, Nat.gcd, And]]
[Mem.mem,[],[]]
[IO.AsyncList.asyncTail.injEq,[Eq.propIntro, Eq.refl, IO.AsyncList.asyncTail, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.AsyncList.asyncTail]]
[ByteArray.foldlMUnsafe.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bind.bind, ByteArray.uget, lcProof, ByteArray.foldlMUnsafe.fold, HAdd.hAdd, OfNat.ofNat],[]]
[Nat.gcd_dvd_gcd_mul_right_right,[Nat.gcd_dvd_gcd_of_dvd_right, Nat.dvd_mul_right],[Dvd.dvd, Nat.gcd, HMul.hMul]]
[Lean.Elab.Command.instMonadLogCommandElabM,[Lean.Elab.MonadLog.mk, Lean.MonadRef.getRef, Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Command.Context.fileName, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.MessageLog.add, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState],[Lean.Elab.MonadLog, Lean.Elab.Command.CommandElabM]]
[Lean.Parser.Command.declValSimple,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.optional, Lean.Parser.Term.whereDecls],[Lean.Parser.Parser]]
[mul_one,[Monoid.mul_one],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.State.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.arrayRef.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.Cache.defEqAll,[],[Lean.Meta.DefEqCache]]
[Lean.Elab.Structural.mkBRecOn,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Elab.Structural.M, Lean.Expr]]
[Subarray.foldr,[Id.run, Subarray.foldrM],[]]
[Lean.Meta.registerGetEqnsFn,[Bind.bind, Lean.initializing, ite, Eq, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, IO.userError],[IO, Unit]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withAppFn,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.PrettyPrinter.Delaborator.SubExpr.descend, Lean.Expr.appFn!, OfNat.ofNat],[]]
[Lean.Parser.Tactic.matchAlts.formatter,[Lean.Parser.Term.matchAlts.formatter, Lean.Parser.Tactic.matchRhs.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.ElabInfo.noConfusionType,[],[]]
[Lean.Level.max.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Level.max, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Level.max, And]]
[Lean.Parser.Tactic.tacticRefine_lift_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Command.ElabStructResult.projInfos,[],[List, Lean.Elab.Command.ProjectionInfo]]
[Lean.Meta.Match.InjectionAnyResult.subgoal.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.InjectionAnyResult.subgoal, HAdd.hAdd, OfNat.ofNat]]
[Lean.instEval,[Lean.Eval.mk, IO.println, ToString.toString, Unit.unit],[Lean.Eval]]
[Tactic.Ring.Cache.α,[],[Lean.Expr]]
[neq_of_not_iff,[mt, Eq.to_iff],[Ne]]
[Substring.drop,[Substring.mk, Substring, HAdd.hAdd, Substring.nextn, OfNat.ofNat],[Substring]]
[Fin.val,[],[Nat]]
[Lean.Environment.isProjectionFn,[Lean.MapDeclarationExtension.contains, Lean.projectionFnInfoExt],[Bool]]
[Lean.PrettyPrinter.Delaborator.delabConst,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, MonadReader.read, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPPrivateNames, Lean.PrettyPrinter.Delaborator.unresolveNameGlobal, Lean.getPPUniverses, ite, Eq, or, List.isEmpty, not, Bool.true, Lean.MonadLCtx.getLCtx, Lean.LocalContext.usesUserName, and, BEq.beq, Lean.PrettyPrinter.Delaborator.Context.inPattern, Pure.pure, PUnit.unit, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkIdent, Lean.Syntax.atom, Array.append, List.nil, Lean.mkSepArray, Array.map, Lean.mkAtom, panicWithPosWithDecl, OfNat.ofNat],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.PersistentEnvExtensionState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PersistentEnvExtensionState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.elabWaitIfTypeContainsMVar,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, liftM, Lean.MonadMCtx.getMCtx, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.MetavarContext.findUserName?, Lean.Syntax.getId, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.instantiateMVars, Lean.mkMVar, Lean.Meta.inferType, Lean.Expr.hasExprMVar, Lean.Elab.Term.tryPostpone, Pure.pure, PUnit.unit, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElab]]
[Lean.MessageSeverity.error.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.MessageSeverity.error, OfNat.ofNat]]
[ExceptT.bind,[ExceptT.mk, Bind.bind, ExceptT.bindCont],[ExceptT]]
[System.SearchPath.parse,[List.map, System.FilePath.mk, String.split, BEq.beq, System.SearchPath.separator],[System.SearchPath]]
[Lean.NameGenerator.next,[Lean.NameGenerator.mk, Lean.NameGenerator.namePrefix, HAdd.hAdd, Lean.NameGenerator.idx, OfNat.ofNat],[Lean.NameGenerator]]
[emptyWf.proof_1,[WellFounded.intro, Acc.intro, Acc, emptyRelation, Eq.refl],[WellFounded, emptyRelation]]
[Lean.IR.UnreachableBranches.InterpContext.decls,[],[Array, Lean.IR.Decl]]
[Id.run,[],[]]
[Lean.EnvExtensionInterfaceUnsafe.Ext.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.ClientCapabilities.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.ClientCapabilities.toCtorIdx],[]]
[Lean.Server.WithRpcRef.mk.inj,[],[Eq]]
[Std.HashMap.numBuckets,[Array.size, Subtype.val, Std.HashMapImp.buckets],[Nat]]
[Lean.Json.pretty,[Std.Format.pretty, Lean.Json.render],[String]]
[Lean.Parser.Level.paren,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.levelParser],[Lean.Parser.Parser]]
[Id.bind_eq,[rfl],[Eq, Bind.bind]]
[ne_true_of_eq_false,[Not, Eq, Bool.true],[Not, Eq, Bool.true]]
[Lean.Expr.projExpr!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[Nat.sub_lt,[LT.lt, HSub.hSub, absurd, Nat.lt_irrefl, OfNat.ofNat, Eq.symm, Nat.succ_sub_succ_eq_sub],[LT.lt, HSub.hSub]]
[Lean.Compiler.SpecEntry.cache.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Compiler.SpecEntry.cache, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Command.CollectAxioms.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.CollectAxioms.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Command.CollectAxioms.State.mk, And]]
[Function.update_comp_eq_of_injective,[Function.update_comp_eq_of_injective'],[Eq, Function.comp, Function.update]]
[Lean.IR.ExplicitRC.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.ExplicitRC.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.getInitFnNameFor?,[HOrElse.hOrElse, Lean.getBuiltinInitFnNameFor?, Lean.getRegularInitFnNameFor?],[Option, Lean.Name]]
[Lean.Parser.Tactic.«tactic_<;>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Lsp.instInhabitedDiagnosticRelatedInformation,[Inhabited.mk, Lean.Lsp.DiagnosticRelatedInformation.mk, arbitrary],[Inhabited, Lean.Lsp.DiagnosticRelatedInformation]]
[Lean.Syntax.decodeNameLit,[ite, Eq, BEq.beq, String.get, OfNat.ofNat, Char.ofNat, Bool.true, Unit.unit, List.cons, Option, Lean.Name, Substring.drop, String.toSubstring, List.nil, Option.none, Option.some, List.foldr, Lean.isIdBeginEscape, String.front, Lean.Name.mkStr, String.dropRight, String.drop, Lean.Name.anonymous],[Option, Lean.Name]]
[Lean.Elab.PreDefinition.declName,[],[Lean.Name]]
[Lean.Elab.Term.elabSort,[Bind.bind, ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, Lean.levelZero, Lean.Elab.Term.elabLevel, Lean.Syntax.getOp, OfNat.ofNat, Lean.mkSort],[Lean.Elab.Term.TermElab]]
[Lean.Elab.Tactic.evalRefine,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Tactic.refineCore, Bool.false, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[Lean.Rat.instSubRat,[Sub.mk, Lean.Rat.sub],[Sub, Lean.Rat]]
[Function.const,[],[]]
[Lean.Lsp.instToJsonSymbolKind,[Lean.ToJson.mk, Unit.unit, Lean.Json, OfNat.ofNat],[Lean.ToJson, Lean.Lsp.SymbolKind]]
[USize.ofNat,[USize.mk, Fin.ofNat', usize_size_gt_zero],[USize]]
[heq_of_eq,[Eq.subst, HEq.refl],[HEq]]
[Lean.Elab.Command.addLinter,[Bind.bind, ST.Ref.get, Lean.Elab.Command.lintersRef, ST.Ref.set, Array.push],[IO, Unit]]
[Lean.Meta.Instances.erase,[ite, Eq, Std.PersistentHashSet.contains, Lean.Meta.Instances.instanceNames, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Meta.Instances]]
[Std.PArray,[Std.PersistentArray],[]]
[Lean.Parser.Command.terminationBy.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.terminationHint.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.applyDerivingHandlers,[Bind.bind, ST.Ref.get, Lean.Elab.derivingHandlersRef, Unit.unit, Lean.Elab.Command.CommandElabM, Unit, Lean.NameMap.find?, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Elab.defaultHandler],[Lean.Elab.Command.CommandElabM, Unit]]
[Lean.getConstInfoRec,[Bind.bind, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.RecursorVal, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkConst, List.nil],[Lean.RecursorVal]]
[UInt8.zero_def,[rfl],[Eq, OfNat.ofNat, UInt8.mk]]
[Lean.Parsec.eof,[ite, Eq, String.Iterator.hasNext, Bool.true, Lean.Parsec.ParseResult.error, Lean.Parsec.expectedEndOfInput, Lean.Parsec.ParseResult.success, Unit.unit],[Lean.Parsec, Unit]]
[Except.error.inj,[],[Eq]]
[Array.findIdx?.loop,[dite, LT.lt, Array.size, Option, Nat, False.elim, Array.findIdx?.loop.proof_1, ite, Eq, Array.get, Fin.mk, Bool.true, Option.some, Option.none],[Option, Nat]]
[Lean.PrettyPrinter.Formatter.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Formatter.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PrettyPrinter.Formatter.Context.mk, And]]
[Lean.Elab.Term.elabFun,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.liftMacroM, Lean.Elab.Term.expandFunBinders, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Elab.Term.elabFunBinders, Lean.Elab.Term.elabTermEnsuringType, Option.none, liftM, Lean.Meta.mkLambdaFVars, Bool.false, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElab]]
[Lean.Meta.Simp.tryRewriteCtorEq,[Bind.bind, liftM, Lean.Meta.Simp.rewriteCtorEq?, Unit.unit, Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step, Pure.pure, Lean.Meta.Simp.Step.done],[Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step]]
[Lean.RecursorVal.mk.inj,[And.intro],[And, Eq]]
[apply_dite,[Decidable.em, of_eq_true, Eq.trans, congr, congrArg, Eq, dite_congr, eq_true, Eq.refl, Eq.mpr_prop, Eq.mpr_not, dite_true, eq_self, True.intro, Eq.symm, eq_false, dite_false, not_false],[Eq, dite]]
[Lean.LBool.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Widget.InfoWithCtx.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Widget.InfoWithCtx.mk, HAdd.hAdd, OfNat.ofNat]]
[IO.FS.SystemTime.sec,[],[Int]]
[instOrElse,[OrElse.mk, Alternative.orElse],[OrElse]]
[Lean.Meta.SortLocalDecls.Context.localDecls,[],[Lean.NameMap, Lean.LocalDecl]]
[Lean.Parser.Term.haveEqnsDecl,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.Term.haveIdLhs, Lean.Parser.Term.matchAlts, Lean.Parser.termParser, OfNat.ofNat, Bool.false],[Lean.Parser.Parser]]
[ByteArray.forIn.loop.proof_1,[Nat.lt_of_le_of_lt, Nat.sub_le, HSub.hSub, ByteArray.size, OfNat.ofNat, Nat.sub_lt, Nat.zero_lt_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self, of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, HSub.hSub, ByteArray.size, OfNat.ofNat]]
[Lean.Elab.Structural.EqnInfo.levelParams,[],[List, Lean.Name]]
[Lean.Parser.pushNone,[Lean.Parser.Parser.mk, Lean.Parser.ParserState.pushSyntax, Lean.mkNullNode, List.toArray, List.nil],[Lean.Parser.Parser]]
[Lean.Server.FileWorker.Reference.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.FileWorker.Reference.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.FileWorker.Reference.mk, And]]
[Lean.Xml.Parser.document,[SeqLeft.seqLeft, SeqRight.seqRight, Lean.Xml.Parser.prolog, Lean.Xml.Parser.element, Lean.Parsec.many, Lean.Xml.Parser.Misc, Lean.Parsec.eof],[Lean.Parsec, Lean.Xml.Element]]
[Lean.MonadCacheT.instMonadRefMonadCacheT,[inferInstanceAs, Lean.MonadRef, StateRefT', Std.HashMap],[Lean.MonadRef, Lean.MonadCacheT]]
[Lean.IR.instInhabitedAlt,[Inhabited.mk, Lean.IR.Alt.default, arbitrary],[Inhabited, Lean.IR.Alt]]
[Array.appendCore.loop,[dite, LT.lt, Array.size, Unit.unit, Array, PProd.fst, HAdd.hAdd, OfNat.ofNat, Array.push, Array.get, Fin.mk],[Array]]
[Lean.Meta.Match.MatchEqnsExtState.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.MatchEqnsExtState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.MatchEqnsExtState.mk]]
[Lean.Parser.Command.openHiding.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.Closure.mkValueTypeClosure,[Bind.bind, StateRefT'.run, ReaderT.run, Lean.Meta.Closure.mkValueTypeClosureAux, Lean.Meta.Closure.Context.mk, Lean.Meta.Closure.State.mk, Lean.Meta.MetaM, Lean.Meta.Closure.MkValueTypeClosureResult, Pure.pure, Lean.Meta.Closure.MkValueTypeClosureResult.mk, Lean.Meta.Closure.State.levelParams, Lean.Meta.Closure.State.levelArgs, HAppend.hAppend, Array.reverse, Lean.Meta.Closure.State.exprFVarArgs, Lean.Meta.Closure.State.exprMVarArgs],[Lean.Meta.MetaM, Lean.Meta.Closure.MkValueTypeClosureResult]]
[IO.FS.Stream.putStr,[],[IO, Unit]]
[Lean.IR.instToFormatLitVal,[Std.ToFormat.mk, Std.Format, Std.ToFormat.format, repr],[Std.ToFormat, Lean.IR.LitVal]]
[Lean.AttributeKind.local.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.AttributeKind.local, OfNat.ofNat]]
[Lean.Parser.attrParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.instReprElimAltInfo,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.Meta.ElimAltInfo.name, Std.Format.line, Lean.Meta.ElimAltInfo.numFields],[Repr, Lean.Meta.ElimAltInfo]]
[Lean.Lsp.Ipc.ipcStdioConfig,[IO.Process.StdioConfig.mk, IO.Process.Stdio.piped, IO.Process.Stdio.inherit],[IO.Process.StdioConfig]]
[Lean.MessageData.withContext.inj,[And.intro],[And, Eq]]
[Lean.Parser.Command.macroRhs.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.MetavarDecl.depth,[],[Nat]]
[Nat.instCommSemiringNat,[CommSemiring.mk, Nat.mul_comm],[CommSemiring, Nat]]
[ByteArray.foldlM.loop.proof_1,[Nat.lt_of_lt_of_le],[LT.lt, ByteArray.size]]
[Lean.Lsp.WorkDoneProgressReport.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.WorkDoneProgressReport.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.WorkDoneProgressReport.mk, And]]
[Lean.PrettyPrinter.Delaborator.Context.subExpr,[],[Lean.PrettyPrinter.Delaborator.SubExpr]]
[Nat.find_spec,[And.left, Subtype.property, Nat.find_x],[Nat.find]]
[Lean.Meta.simpGoal,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, ForIn.forIn, MProd.mk, Option.none, Lean.Meta.getLocalDecl, Lean.Meta.instantiateMVars, Lean.LocalDecl.type, Unit.unit, Lean.Meta.MetaM, ForInStep, MProd, Option, Prod, Array, Lean.FVarId, Lean.MVarId, Lean.Meta.Hypothesis, Std.RBMap.find?, Lean.LocalDecl.fvarId, Pure.pure, Lean.Meta.SimpLemmas.eraseCore, Lean.Meta.Simp.Context.simpLemmas, Lean.Meta.Simp.Context.mk, Lean.Meta.Simp.Context.config, Lean.Meta.Simp.Context.congrLemmas, Lean.Meta.Simp.Context.parent?, Lean.Meta.Simp.Context.dischargeDepth, MProd.fst, PUnit.unit],[Lean.Meta.MetaM, Option, Prod, Array, Lean.FVarId, Lean.MVarId]]
[Or.intro_left,[Or.inl],[Or]]
[List.disjoint_symm,[],[List.disjoint]]
[Lean.Lsp.instFileSourceDidChangeTextDocumentParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.DidChangeTextDocumentParams.textDocument],[Lean.Lsp.FileSource, Lean.Lsp.DidChangeTextDocumentParams]]
[tacticBy_cases_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.DeclarationRanges.selectionRange,[],[Lean.DeclarationRange]]
[Lean.Elab.Term.State.mvarErrorInfos,[],[Lean.MVarIdMap, Lean.Elab.Term.MVarErrorInfo]]
[StateT,[Prod],[]]
[instSubsingletonSquash.proof_1,[Subsingleton.intro, Squash.ind, Quot.sound, True.intro],[Subsingleton, Squash]]
[Lean.Parser.Module.updateTokens,[Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.prec, Lean.Parser.TokenTable, Lean.Parser.addParserTokens, Lean.Parser.ParserContext.tokens, Lean.Parser.Parser.info, Lean.Parser.Module.header, panicWithPosWithDecl, OfNat.ofNat, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Parser.ParserContext.savedPos?, Lean.Parser.ParserContext.forbiddenTk?],[Lean.Parser.ParserContext]]
[Lean.Elab.Command.command_Irreducible_def___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Meta.intros,[Bind.bind, Lean.Meta.getMVarType, Lean.Meta.instantiateMVars, ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Pure.pure, Prod.mk, List.toArray, List.nil, Lean.Meta.introN, Bool.false],[Lean.Meta.MetaM, Prod, Array, Lean.FVarId, Lean.MVarId]]
[Lean.Syntax.decodeCharLit,[OptionM.run, ite, Eq, BEq.beq, Char.ofNat, Bool.true, Bind.bind, Lean.Syntax.decodeQuotedChar, OfNat.ofNat, OptionM, Char, Pure.pure],[Option, Char]]
[Lean.Parser.Tactic.tacticRefine_lift'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Term.sorry,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Parser.Command.terminationHint,[HOrElse.hOrElse, Lean.Parser.Command.terminationHintMany, Lean.Parser.Command.terminationHint1],[Lean.Parser.Parser]]
[Int.subNatNat,[Unit.unit, Int, HSub.hSub, Int.ofNat, Int.negSucc],[Int]]
[UInt8.instAddCommSemigroupUInt8.proof_1,[congrArg, UInt8.mk, AddCommSemigroup.add_comm, UInt8.val],[Eq, UInt8.mk]]
[id_eq,[rfl],[Eq, id]]
[Option.bind,[Option, Option.none],[Option]]
[Nat.gcd_mul_gcd_of_coprime_of_mul_eq_mul,[Nat.dvd_antisymm, Nat.coprime.dvd_of_dvd_mul_right, Nat.coprime.mul, Nat.coprime.gcd_left, Eq.mpr, Eq.refl, Dvd.dvd, HMul.hMul, Nat.gcd, Eq.symm, Nat.mul_dvd_mul, And.left, Nat.gcd_dvd, Nat.gcd_comm],[Eq, HMul.hMul, Nat.gcd]]
[Lean.Elab.Term.StructInst.instToStringFieldStruct,[ToString.mk, Function.comp, ToString.toString, Std.ToFormat.format],[ToString, Lean.Elab.Term.StructInst.Field, Lean.Elab.Term.StructInst.Struct]]
[Tactic.Ring.State.atoms,[],[Array, Lean.Expr]]
[Lean.IR.ExplicitRC.updateVarInfoWithParams,[Lean.IR.ExplicitRC.Context.mk, Lean.IR.ExplicitRC.Context.env, Lean.IR.ExplicitRC.Context.decls, Lean.IR.ExplicitRC.Context.jpLiveVarMap, Lean.IR.ExplicitRC.Context.localCtx],[Lean.IR.ExplicitRC.Context]]
[Lean.Elab.IO.processCommands,[Bind.bind, StateRefT'.run, ReaderT.run, Lean.Elab.Frontend.processCommands, Lean.Elab.Frontend.Context.mk, Lean.Elab.Frontend.State.mk, Lean.Parser.ModuleParserState.pos, IO, Lean.Elab.Frontend.State, Pure.pure],[IO, Lean.Elab.Frontend.State]]
[Lean.Environment.evalConstCheck,[Unit.unit, ExceptT, String, Id, Lean.Environment.find?, MonadExcept.throw, HAppend.hAppend, ToString.toString, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.ConstantInfo.type, ite, Eq, bne, Bool.true, Lean.Environment.evalConst],[ExceptT, String, Id]]
[Lean.Meta.CaseArraySizesSubgoal.mvarId,[],[Lean.MVarId]]
[Lean.Syntax.updateLeading,[StateT.run', Lean.Syntax.replaceM, Lean.Syntax.missing, Lean.Syntax.node, Lean.SourceInfo.original, Lean.Syntax.atom, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Lean.Syntax.ident, StateM, String.Pos, Option, Lean.Syntax, Bind.bind, MonadState.get, MonadStateOf.set, Pure.pure, Option.some, Option.none, OfNat.ofNat],[Lean.Syntax]]
[Lean.Parser.Tactic.eraseAuxDiscrs.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Deriving.DecEq.mkDecEq,[Bind.bind, Lean.getConstInfoInduct, ite, Eq, Lean.InductiveVal.isNested, Bool.true, Pure.pure, Bool.false, Lean.Elab.Command.liftTermElabM, Option.none, Lean.Elab.Deriving.DecEq.mkDecEqCmds, Array.forM, Lean.Elab.Command.elabCommand, OfNat.ofNat, Array.size],[Lean.Elab.Command.CommandElabM, Bool]]
[Lean.Parser.Trie.Node.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.refl, Std.RBNode.leaf, Eq.trans, congr, congrFun, Eq.symm, Std.RBNode.node.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Parser.Trie.Node, HAdd.hAdd, OfNat.ofNat]]
[Lean.Expr.FindImpl.cacheSize,[OfNat.ofNat],[USize]]
[Lean.Syntax.isNameLit?,[Option.none, Option, Lean.Name, Lean.Syntax.isLit?, Lean.nameLitKind, Lean.Syntax.decodeNameLit],[Option, Lean.Name]]
[Lean.Parser.TokenMap.instInhabitedTokenMap,[Inhabited.mk, Std.RBMap.empty],[Inhabited, Lean.Parser.TokenMap]]
[or_true,[propext, Iff.intro, trivial, Or.inr],[Eq, Or, True]]
[Lean.Elab.InfoTree.hole.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.InfoTree.hole, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.InfoTree.hole]]
[Lean.Parser.Term.let,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, Lean.Parser.symbol, Lean.Parser.Term.letDecl, Lean.Parser.Term.optSemicolon, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.Parser.Term.forInMacro,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[Lean.Expr.lit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Expr.lit, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.mkSProjExpr,[Lean.IR.Expr.sproj],[Lean.IR.Expr]]
[Lean.Meta.SimpAll.Entry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SimpAll.Entry.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SimpAll.Entry.mk, And]]
[Lean.identKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[IO.AccessRight.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.AccessRight.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.AccessRight.mk, And]]
[Lean.Name.mkNum.proof_1,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt64.size]]
[Lean.FileMap.lines,[],[Array, Nat]]
[Prod.RProdSubLex.proof_1,[Prod.Lex.left, Eq.symm, eq_of_heq, Eq.refl, HEq.refl],[Prod.Lex]]
[ExceptT.lift,[ExceptT.mk, Functor.map, Except.ok],[ExceptT]]
[Lean.Parser.Tactic.inhabit,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.IR.AltCore.modifyBody,[Lean.IR.Alt, Lean.IR.Alt.ctor, Lean.IR.Alt.default],[Lean.IR.Alt]]
[Lean.Elab.MacroStackElem.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.MacroStackElem.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.MacroStackElem.mk, And]]
[instAddUInt8,[Add.mk, UInt8.add],[Add, UInt8]]
[Lean.Meta.getExpectedNumArgsAux,[Lean.Meta.withDefault, Lean.Meta.forallTelescopeReducing, Pure.pure, Prod.mk, Array.size, Lean.Expr.isMVar, Lean.Expr.getAppFn],[Lean.Meta.MetaM, Prod, Nat, Bool]]
[Std.HashMapImp.forBucketsM,[Array.forM, Std.AssocList.forM, Subtype.val, OfNat.ofNat, Array.size],[PUnit]]
[Lean.Meta.IndPredBelow.BrecOnVariables.params,[],[Array, Lean.FVarId]]
[Lean.Elab.Term.NamedArg.name,[],[Lean.Name]]
[UInt32.decEq.proof_1,[rfl],[Eq, UInt32.mk]]
[Lean.Parser.Term.subst.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.termParser.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.AddMessageContext.addMessageContext,[],[Lean.MessageData]]
[hidden,[],[]]
[Lean.ParserCompiler.CombinatorAttribute.noConfusionType,[],[]]
[Nat.mod_eq,[congrFun, WellFounded.fix_eq, WellFoundedRelation.wf, measure, id, dite, And, LT.lt, OfNat.ofNat, LE.le, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le, dif_eq_if, HMod.hMod],[Eq, HMod.hMod, ite, And, LT.lt, OfNat.ofNat, LE.le, HSub.hSub]]
[Lean.Meta.InfoCacheKey.noConfusionType,[],[]]
[Lean.Elab.Term.Quotation.resolveSectionVariable,[Lean.MacroScopesView.name, List.nil, Lean.Elab.Term.Quotation.resolveSectionVariable.loop],[List, Prod, Lean.Name, String]]
[Nat.coprime_self,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, Eq, Nat.gcd_self, OfNat.ofNat, iff_self],[Iff, Nat.coprime, Eq, OfNat.ofNat]]
[Lean.Meta.Simp.Result.getProof,[Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.Meta.Simp.Result.proof?, Pure.pure, Lean.Meta.mkEqRefl, Lean.Meta.Simp.Result.expr],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Elab.InfoTree.context.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.assert.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Lean.Parser.Term.optSemicolon.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.IR.LocalContextEntry.joinPoint.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.LocalContextEntry.joinPoint, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.LocalContextEntry.joinPoint, And]]
[Std.HashSet.erase,[Std.HashSet, Subtype.mk, Std.HashSetImp.erase, Std.HashSetImp.WellFormed.eraseWff],[Std.HashSet]]
[Lean.Elab.CompletionInfo.tactic.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.simpStar,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Elab.Command.elabSetOption,[Bind.bind, Lean.Elab.elabSetOption, Lean.Syntax.getOp, OfNat.ofNat, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Option.get, Lean.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Lean.Elab.Command.modifyScope, Lean.Elab.Command.Scope.mk, Lean.Elab.Command.Scope.header, Lean.Elab.Command.Scope.currNamespace, Lean.Elab.Command.Scope.openDecls, Lean.Elab.Command.Scope.levelNames, Lean.Elab.Command.Scope.varDecls, Lean.Elab.Command.Scope.varUIds, Lean.Elab.Command.Scope.isNoncomputable],[Lean.Elab.Command.CommandElab]]
[Lean.JsonRpc.ErrorCode.rpcNeedsReconnect.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.JsonRpc.ErrorCode.rpcNeedsReconnect, OfNat.ofNat]]
[Group.mul_left_inv,[],[Eq, HMul.hMul, Inv.inv, OfNat.ofNat]]
[Std.PersistentHashMap.Stats.numCollisions,[],[Nat]]
[Lean.AttributeExtensionState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.AttributeExtensionState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Xml.Parser.PI,[Bind.bind, SeqLeft.seqLeft, Lean.Parsec.skipString, Lean.Xml.Parser.PITarget, optional, SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Parsec.manyChars, Lean.Parsec.notFollowedBy, Lean.Xml.Parser.Char],[Lean.Parsec, Unit]]
[Lean.Meta.CongrLemmas.lemmas,[],[Lean.SMap, Lean.Name, List, Lean.Meta.CongrLemma]]
[Lean.Parser.Tactic.clearValue,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Mul.mul,[],[]]
[Lean.Parser.Tactic.applyFun,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.PrettyPrinter.Delaborator.ParamKind.bInfo,[],[Lean.BinderInfo]]
[Lean.SyntaxNode.getNumArgs,[Lean.SyntaxNode.withArgs, Array.size],[Nat]]
[Id.instOfNatId,[inferInstanceAs, OfNat],[OfNat, Id]]
[Lean.Parser.mkParserOfConstant,[Lean.Parser.mkParserOfConstantAux, Lean.Parser.compileParserDescr],[Lean.ImportM, Prod, Bool, Lean.Parser.Parser]]
[Lean.Lsp.StaticRegistrationOptions.id?,[],[Option, String]]
[Lean.MVarId.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MVarId.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Simp.Context.dischargeDepth,[],[Nat]]
[Nat.div_eq_of_lt,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, OfNat.ofNat, Nat.div_eq, ite, And, LT.lt, LE.le, HAdd.hAdd, HSub.hSub, if_neg, Nat.not_le_of_gt, And.right, rfl],[Eq, HDiv.hDiv, OfNat.ofNat]]
[Lean.Option.Decl.defValue,[],[]]
[ReprAtom.noConfusionType,[],[]]
[Lean.KeyedDeclsAttribute.ExtensionState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KeyedDeclsAttribute.ExtensionState.mk, HAdd.hAdd, OfNat.ofNat]]
[inv_eq_of_mul_eq_one,[left_inv_eq_right_inv, inv_mul_self],[Eq, Inv.inv]]
[Subtype.map_involutive,[Subtype.ext, Subtype.val],[Function.involutive, Subtype.map]]
[Lean.Parser.Term.doLetArrow,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.withPosition, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, HOrElse.hOrElse, Lean.Parser.Term.doIdDecl, Lean.Parser.Term.doPatDecl],[Lean.Parser.Parser]]
[Lean.ConstantInfo.value?,[Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Option, Lean.Expr, Option.some, Option.none],[Option, Lean.Expr]]
[Nat.lt_by_cases,[Nat.lt_ge_by_cases, Nat.le_antisymm],[]]
[Lean.IR.checkDecl,[Bind.bind, Lean.IR.getEnv, Except.ok, Lean.IR.CompilerM, Unit, StateT.run', Lean.IR.Checker.checkDecl, Lean.IR.Checker.CheckerContext.mk, Lean.IR.Checker.CheckerState.mk, MonadExcept.throw, HAppend.hAppend, ToString.toString, Lean.IR.Decl.name, Pure.pure, Unit.unit],[Lean.IR.CompilerM, Unit]]
[Nat.gcd_dvd,[Nat.gcd.induction, And.intro, Exists.intro, OfNat.ofNat, of_eq_true, Eq.trans, congrArg, Eq, congrFun, HMul.hMul, Nat.gcd_zero_left, Nat.mul_zero, eq_true_of_decide, Eq.refl, Bool.true, Nat.mul_one, eq_self, Eq.mpr, Dvd.dvd, Nat.gcd, Nat.gcd_rec, Iff.mp, Nat.dvd_mod_iff, Eq.mp, HMod.hMod, Eq.symm],[And, Dvd.dvd, Nat.gcd]]
[Lean.Elab.Term.Do.ToCodeBlock.ensureInsideFor,[Bind.bind, MonadReader.read, ite, Eq, Lean.Elab.Term.Do.ToCodeBlock.Context.insideFor, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.Do.ToCodeBlock.M, Unit]]
[Int.sign_neg_one,[rfl],[Eq, Int.sign, Neg.neg, OfNat.ofNat]]
[Nat.coprime_one_right_iff,[of_eq_true, Eq.trans, congr, congrArg, Iff, congrFun, Eq, Nat.gcd_one_right, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true],[Iff, Nat.coprime, OfNat.ofNat, Eq, Bool.true]]
[Lean.Elab.Term.MutualClosure.ClosureState.newLetDecls,[],[Array, Lean.LocalDecl]]
[Lean.Elab.Term.StructInst.instInhabitedFieldLHS,[Inhabited.mk, Lean.Elab.Term.StructInst.FieldLHS.fieldName, arbitrary],[Inhabited, Lean.Elab.Term.StructInst.FieldLHS]]
[Decidable.peirce,[dite, Not.elim],[]]
[Lean.Compiler.foldStrictAnd,[Option.none, Option.some, Bool.false, Bool.true, Option, Lean.Expr],[Option, Lean.Expr]]
[Lean.FVarIdHashSet,[Std.HashSet, Lean.FVarId],[]]
[Lean.FVarIdMap,[Std.RBMap, Lean.FVarId, Lean.Name.quickCmp, Lean.FVarId.name],[]]
[Lean.Level.depth,[UInt32.toNat, Lean.Level.Data.depth, Lean.Level.data],[Nat]]
[Lean.PrettyPrinter.Delaborator.annotateCurPos,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getPos, Pure.pure, Lean.PrettyPrinter.Delaborator.annotatePos],[Lean.PrettyPrinter.Delaborator.Delab]]
[Nat.sub_pos_of_lt,[Nat.lt_of_add_lt_add_right, Eq.mpr, Eq.refl, LT.lt, HAdd.hAdd, OfNat.ofNat, HSub.hSub, Nat.zero_add, Nat.sub_add_cancel, Nat.le_of_lt],[LT.lt, OfNat.ofNat, HSub.hSub]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.containsBadMax,[Lean.Level.zero, Lean.Level.param, Lean.Level.mvar, Bool, PProd.fst, or, and, Lean.Level.hasParam, PProd.snd, Bool.false],[Bool]]
[bfix6,[PProd.fst],[]]
[Lean.Elab.Command.elabNamespace,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Unit.unit, Lean.Name.num, Lean.Elab.Command.CommandElabM, Unit, Pure.pure, Bind.bind, PProd.fst, Lean.MonadResolveName.getCurrNamespace, modify, Lean.Elab.Command.State.mk, Lean.Environment.registerNamespace, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, List.cons, Lean.Elab.Command.Scope.mk, Lean.Elab.Command.Scope.opts, Lean.Elab.Command.Scope.openDecls, Lean.Elab.Command.Scope.levelNames, Lean.Elab.Command.Scope.varDecls, Lean.Elab.Command.Scope.varUIds, or, Lean.Elab.Command.Scope.isNoncomputable, List.head!, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Lean.pushScope, Lean.activateScoped, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData, Bool.false, Lean.Syntax.getId, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[instHashableFin,[Hashable.mk, Nat.toUInt64, Fin.val],[Hashable, Fin]]
[Lean.IR.instToFormatVarId,[Std.ToFormat.mk, Std.Format.text, ToString.toString],[Std.ToFormat, Lean.IR.VarId]]
[Std.PersistentHashMap.Stats.toString,[HAppend.hAppend, ToString.toString, Std.PersistentHashMap.Stats.numNodes, Std.PersistentHashMap.Stats.numNull, Std.PersistentHashMap.Stats.numCollisions, Std.PersistentHashMap.Stats.maxDepth],[String]]
[Mathlib.Tactic.Lint.printWarnings,[Bind.bind, Mathlib.Tactic.Lint.sortResults, Array.mapM, Lean.Core.CoreM, Lean.MessageData, Mathlib.Tactic.Lint.printWarning, Pure.pure, Lean.MessageData.joinSep, Array.toList, Lean.MessageData.ofFormat, Std.Format.line],[Lean.Core.CoreM, Lean.MessageData]]
[Lean.Meta.ppGoal.pushPending,[ite, Eq, List.isEmpty, Bool.true, Pure.pure, Unit.unit, Lean.Meta.MetaM, Std.Format, Bind.bind, Lean.Meta.ppExpr, HAppend.hAppend, Std.Format.group, Std.Format.joinSep, List.reverse, Std.ToFormat.format, Std.Format.text, Std.Format.nest, Std.Format.line, Std.Format.FlattenBehavior.allOrNone],[Lean.Meta.MetaM, Std.Format]]
[Lean.Lsp.instFileSourceDefinitionParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.DefinitionParams.toTextDocumentPositionParams],[Lean.Lsp.FileSource, Lean.Lsp.DefinitionParams]]
[Lean.Parser.addSyntaxNodeKind,[Lean.ScopedEnvExtension.addEntry, Lean.Parser.parserExtension, Lean.Parser.ParserExtension.Entry.kind],[Lean.Environment]]
[Lean.InductiveType.ctors,[],[List, Lean.Constructor]]
[Lean.SyntaxNode.modifyArgs,[Lean.Syntax, Lean.Syntax.node, Lean.unreachIsNodeMissing, Lean.unreachIsNodeAtom, Lean.unreachIsNodeIdent],[Lean.Syntax]]
[Lean.PrettyPrinter.Delaborator.isFOLike,[Pure.pure, or, Lean.Expr.isFVar, Lean.Expr.isConst],[Lean.Meta.MetaM, Bool]]
[Lean.KernelException.noConfusionType,[],[]]
[Lean.Compiler.mkNatLe,[Lean.mkAppN, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.levelZero, List.nil, List.toArray],[Lean.Expr]]
[Lean.Parser.FirstTokens.toOptional,[Lean.Parser.FirstTokens.epsilon, Lean.Parser.FirstTokens.unknown, Lean.Parser.FirstTokens.optTokens, Lean.Parser.FirstTokens],[Lean.Parser.FirstTokens]]
[Lean.Literal.noConfusionType,[],[]]
[Lean.addClass,[ite, Eq, Lean.isClass, Bool.true, Except.error, HAppend.hAppend, ToString.toString, Unit.unit, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Except, String, Lean.Environment, Lean.Environment.find?, Bind.bind, OfNat.ofNat, List.toArray, List.nil, Lean.ConstantInfo.type, Except.ok, Lean.PersistentEnvExtension.addEntry, Lean.classExtension, Lean.ClassEntry.mk],[Except, String, Lean.Environment]]
[Lean.LeanPaths.noConfusionType,[],[]]
[List.exists_cons_of_ne_nil,[absurd, Eq.refl, List.nil, Exists.intro, rfl],[Exists, Eq, List.cons]]
[Lean.Elab.Command.StructFieldView.name,[],[Lean.Name]]
[Lean.RecursorVal.numMotives,[],[Nat]]
[optionCoe,[CoeTail.mk, Option.some],[CoeTail, Option]]
[Lean.Macro.throwUnsupported,[MonadExcept.throw, Lean.Macro.Exception.unsupportedSyntax],[Lean.MacroM]]
[Lean.Parser.Command.end,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.ident],[Lean.Parser.Parser]]
[Lean.Elab.Command.catchExceptions,[EIO.catchExceptions, Lean.Elab.Command.withLogging, Pure.pure, Unit.unit],[Lean.Elab.Command.CommandElabCoreM, Empty, Unit]]
[Lean.IR.IRType.instBEqIRType,[BEq.mk, Lean.IR.IRType.beq],[BEq, Lean.IR.IRType]]
[StateCpsT,[],[]]
[CommSemigroup.toSemigroup,[],[Semigroup]]
[Lean.ScopedEnvExtension.ScopedEntries.mk.injEq,[Eq.propIntro, Eq.refl, Lean.ScopedEnvExtension.ScopedEntries.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ScopedEnvExtension.ScopedEntries.mk]]
[Lean.getMainModuleDoc,[Lean.SimplePersistentEnvExtension.getState],[Std.PersistentArray, String]]
[Lean.Elab.expandOptDeclSig,[ite, Eq, Lean.Syntax.isNone, Bool.true, Prod.mk, Option.none, Option.some, Lean.Syntax.getOp, OfNat.ofNat],[Prod, Lean.Syntax, Option]]
[instHXor,[HXor.mk, Xor.xor],[HXor]]
[instMonadReaderOf,[MonadReaderOf.mk, liftM, MonadReader.read],[MonadReaderOf]]
[Lean.Meta.SynthInstance.hasInferTCGoalsRLAttribute,[Lean.TagAttribute.hasTag, Lean.Meta.SynthInstance.inferTCGoalsRLAttr],[Bool]]
[Std.ShareCommon.Object,[NonScalar],[]]
[Lean.Meta.Match.MatcherInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.MatcherInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Closure.MkValueTypeClosureResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Closure.MkValueTypeClosureResult.mk, HAdd.hAdd, OfNat.ofNat]]
[instReprULift,[Repr.mk, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg, ULift.down],[Repr, ULift]]
[Lean.IR.EmitC.toCName,[Bind.bind, Lean.IR.EmitC.getEnv, Unit.unit, Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Lean.IR.EmitC.M, String, Lean.getExportNameFor, Pure.pure, Lean.IR.EmitC.throwInvalidExportName, ite, Eq, BEq.beq, Lean.Name.mkStr, Bool.true, Lean.IR.EmitC.leanMainFn, Lean.Name.mangle],[Lean.IR.EmitC.M, String]]
[Lean.Elab.Command.ElabStructResult.localInsts,[],[Lean.LocalInstances]]
[Lean.SCC.Data.index?,[],[Option, Nat]]
[Lean.Parser.Term.ensureExpectedType,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.strLit, Lean.Parser.termParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[Lean.mkInductiveDeclEs,[Lean.Declaration.inductDecl],[Lean.Declaration]]
[Lean.recOnSuffix,[],[String]]
[Lean.IR.Expr.reset.inj,[And.intro],[And, Eq]]
[ForInStep.yield.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, ForInStep.yield, HAdd.hAdd, OfNat.ofNat]]
[List.exists_of_length_succ,[Exists, Eq, List.cons, absurd, Eq.symm, Nat.succ_ne_zero, Exists.intro, rfl],[Exists, Eq, List.cons]]
[Lean.Parser.isEOI,[Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous],[Bool]]
[IO.Error.mkProtocolError,[IO.Error.protocolError],[IO.Error]]
[Function.inv_fun_on,[dite, Exists, And, Mem.mem, Eq, Classical.choose, Classical.choice],[]]
[UInt8.add_def,[rfl],[Eq, HAdd.hAdd, UInt8.mk, UInt8.val]]
[Classical.indefiniteDescription.proof_1,[Nonempty, Subtype, Nonempty.intro, Subtype.mk],[Nonempty, Subtype]]
[Lean.PrettyPrinter.Delaborator.delabNameMkStr,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPNotation, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.PrettyPrinter.Delaborator.reifyName, Pure.pure, Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.mkNameLit, HAppend.hAppend, ToString.toString, Lean.SourceInfo.none, List.nil],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.Meta.getLocalDeclFromUserName,[Bind.bind, Lean.MonadLCtx.getLCtx, Unit.unit, Lean.Meta.MetaM, Lean.LocalDecl, Lean.LocalContext.findFromUserName?, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM, Lean.LocalDecl]]
[Lean.StructureFieldInfo.noConfusionType,[],[]]
[Prod.snd_swap,[rfl],[Eq, Prod.snd, Prod.swap, Prod.fst]]
[Lean.Environment.extensions,[],[Array, Lean.EnvExtensionState]]
[Nat.mul_dvd_mul,[Dvd.dvd, HMul.hMul, Exists.intro, Eq.mpr, Eq.refl, Eq, Nat.mul_assoc, Eq.symm, Nat.mul_comm, rfl],[Dvd.dvd, HMul.hMul]]
[ByteArray.push,[ByteArray, ByteArray.mk, Array.push],[ByteArray]]
[Lean.Meta.Match.Unify.expandIfVar,[Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.Match.Unify.M, Lean.Expr, Bind.bind, MonadState.get, Pure.pure, Lean.Meta.FVarSubst.apply, Lean.Meta.Match.Unify.State.fvarSubst],[Lean.Meta.Match.Unify.M, Lean.Expr]]
[instIsAddRightCancel.proof_1,[Eq.mpr, Eq.refl, Eq, Eq.symm, add_neg_cancel_right, HAdd.hAdd, Neg.neg, rfl],[Eq]]
[FloatArray.forIn,[FloatArray.size, Nat.le_refl, FloatArray.forIn.loop],[]]
[Lean.getPPAnalyzeCheckInstances,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.checkInstances, Lean.Option.defValue],[Bool]]
[instInhabitedOrdering,[Inhabited.mk, Ordering.lt],[Inhabited, Ordering]]
[Lean.Elab.Term.registerMVarErrorHoleInfo,[Lean.Elab.Term.registerMVarErrorInfo, Lean.Elab.Term.MVarErrorInfo.mk, Lean.Elab.Term.MVarErrorKind.hole],[Lean.Elab.Term.TermElabM, Unit]]
[instDecidableIff.proof_3,[Iff.mpr],[False]]
[Lean.Meta.InfoCacheKey.expr,[],[Lean.Expr]]
[Lean.Parser.Command.whereStructInst,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1Indent, Lean.Parser.group, Lean.Parser.Command.whereStructField, Lean.Parser.optional],[Lean.Parser.Parser]]
[PSigma.skipLeft.proof_1,[PSigma.revLex, WellFoundedRelation.wf, emptyWf],[WellFounded, PSigma.RevLex, emptyRelation, WellFoundedRelation.rel]]
[Lean.Meta.CongrLemma.hypothesesPos,[],[Array, Nat]]
[Lean.Elab.Command.CtorView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Command.CtorView.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.export,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident, Lean.Parser.many1],[Lean.Parser.Parser]]
[Lean.Elab.Term.tryPostponeIfMVar,[ite, Eq, Lean.Expr.isMVar, Lean.Expr.getAppFn, Bool.true, Bind.bind, liftM, Lean.Meta.instantiateMVars, Lean.Elab.Term.tryPostpone, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElabM, Unit]]
[Std.HashSetBucket.update,[Subtype.mk, Array.uset, Subtype.val, Std.HashSetBucket.update.proof_1],[Std.HashSetBucket]]
[Lean.IR.mkPAppExpr,[Lean.IR.Expr.pap],[Lean.IR.Expr]]
[Std.PersistentArray.Stats.noConfusionType,[],[]]
[Classical.epsilon_spec,[Classical.epsilon_spec_aux, nonempty_of_exists],[Classical.epsilon]]
[Lean.Meta.GeneralizeTelescope.Entry.modified,[],[Bool]]
[Fin.overflowingMul,[Prod.mk, Decidable.decide, LE.le, HMul.hMul, Fin.val],[Prod, Bool, Fin]]
[Lean.Parser.Term.anonymousCtor.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy.parenthesizer, Lean.Parser.termParser.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Tactic.sliceLHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[Lean.Lsp.HoverParams.toTextDocumentPositionParams,[],[Lean.Lsp.TextDocumentPositionParams]]
[Lean.IR.EmitC.Context.jpMap,[],[Lean.IR.JPParamsMap]]
[Std.HashMapImp.find?,[Option, Std.AssocList.find?, Array.uget, Subtype.val],[Option]]
[Lean.ConstructorVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ConstructorVal.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.SynthInstance.GeneratorNode.instances,[],[Array, Lean.Expr]]
[Lean.MonadLCtx.getLCtx,[],[Lean.LocalContext]]
[Option.get!,[Unit.unit, panicWithPosWithDecl, OfNat.ofNat],[]]
[Lean.Elab.Command.elabPrint,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Lean.withRef, Bind.bind, Lean.Elab.resolveGlobalConstWithInfos, Option.none, List.forM, Lean.MonadEnv.getEnv, Unit.unit, Lean.Elab.Command.CommandElabM, Unit, Lean.Environment.find?, Lean.MessageData, Pure.pure, Lean.DefinitionSafety.unsafe, Lean.DefinitionSafety.safe, Lean.Elab.logInfo, Bool.false, ForIn.forIn, Lean.getConstInfo, PUnit.unit, ForInStep.yield, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkConst, List.nil, Lean.Elab.logInfoAt, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Option.get!, Lean.Syntax.isStrLit?],[Lean.Elab.Command.CommandElab]]
[Int.instDecidableEqInt,[Int.decEq],[DecidableEq, Int]]
[Lean.NameMap.find?,[Std.RBMap.find?],[Option]]
[Lean.Parser.Term.macroDollarArg.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[iff_true_right,[Iff.trans, Iff.comm, iff_true_left],[Iff]]
[Lean.KernelException.funExpected.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KernelException.funExpected, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Deriving.Hashable.mkAuxFunction,[Bind.bind, Pure.pure, Array.getOp, Lean.Elab.Deriving.Context.auxFunNames, Lean.Elab.Deriving.Context.typeInfos, Lean.Elab.Deriving.Hashable.mkHashableHeader, Lean.Elab.Deriving.Hashable.mkMatch, ite, Eq, Lean.Elab.Deriving.Context.usePartial, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Lean.Syntax.atom, Lean.mkIdent, Array.append, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Mathlib.Tactic.Lint.Linter.noErrorsFound,[],[Lean.MessageData]]
[instRingFin,[Ring.mk, Fin, Semiring.nsmul, Neg.neg, Nat.succ, instRingFin.proof_2, instRingFin.proof_3, instRingFin.proof_4, instRingFin.proof_5],[Ring, Fin]]
[Lean.Parser.Term.doTry,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.doSeq, Lean.Parser.many, HOrElse.hOrElse, Lean.Parser.Term.doCatch, Lean.Parser.Term.doCatchMatch, Lean.Parser.optional, Lean.Parser.Term.doFinally],[Lean.Parser.Parser]]
[Lean.Elab.Term.precheckFun,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.liftMacroM, Lean.Elab.Term.expandFunBinders, Lean.Elab.Term.Quotation.PrecheckM, Unit, ForIn.forIn, liftM, BEq.beq, Array.mapM, or, Lean.identKind, Pure.pure, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Term.mkFreshIdent, Lean.Elab.Term.BinderView.mk, Lean.Elab.Term.expandOptType, Lean.BinderInfo.default, Lean.Syntax.isNone, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Elab.Term.declareTacticSyntax, Lean.mkIdentFrom, Lean.Elab.throwUnsupportedSyntax, Lean.Syntax.getNumArgs, Lean.mkHole, Lean.BinderInfo.implicit, Lean.BinderInfo.strictImplicit, Lean.MonadQuotation.withFreshMacroScope, Lean.MonadQuotation.addMacroScope, Lean.BinderInfo.instImplicit, Lean.Elab.Term.Quotation.withNewLocals, Lean.Elab.Term.Quotation.precheck, Lean.Elab.Term.BinderView.type, PUnit.unit, ForInStep.yield],[Lean.Elab.Term.Quotation.Precheck]]
[List.inter,[List.filter, Decidable.decide, Mem.mem],[List]]
[Lean.Elab.ExpandDeclIdResult.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.DefView.noConfusionType,[],[]]
[String.Iterator.remainingToString,[String, String.extract, String.bsize],[String]]
[Array.foldl,[Id.run, Array.foldlM],[]]
[Lean.Lsp.SymbolKind.file.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.file, OfNat.ofNat]]
[Lean.Meta.CaseValueSubgoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.CaseValueSubgoal.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.manyIndent.formatter,[Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.many.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkColGe.formatter],[Lean.PrettyPrinter.Formatter]]
[instLTUInt32,[LT.mk, LT.lt, UInt32.val],[LT, UInt32]]
[Lean.Meta.IndPredBelow.mkCtorType.addHeaderVars,[Bind.bind, Array.mapIdxM, Lean.Meta.IndPredBelow.Context.headers, Pure.pure, Prod.mk, Array.getOp, Lean.Meta.IndPredBelow.Context.belowNames, Fin.val, Lean.Meta.withLocalDeclsD, Lean.Meta.IndPredBelow.mkCtorType.addMotives, Lean.Meta.IndPredBelow.Variables.mk, Lean.Meta.IndPredBelow.Variables.target, Lean.Meta.IndPredBelow.Variables.params, Lean.Meta.IndPredBelow.Variables.args, Lean.Meta.IndPredBelow.Variables.motives, Lean.Meta.IndPredBelow.Variables.innerType],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Syntax.decodeStrLit,[Lean.Syntax.decodeStrLitAux, OfNat.ofNat],[Option, String]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.noConfusionType,[],[]]
[Lean.Syntax.missing.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Syntax.missing, OfNat.ofNat]]
[Lean.Parser.Command.macroArg,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.atomic, Lean.Parser.ident, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, Lean.Parser.syntaxParser, Lean.Parser.argPrec],[Lean.Parser.Parser]]
[Lean.Expr.updateProj!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr, Lean.Expr.updateProj, Lean.Expr.proj, Lean.Expr.updateProj!.proof_1, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[Lean.Parser.Term.doMatchAlts.formatter,[Lean.Parser.Term.matchAlts.formatter, Lean.Parser.Term.doSeq.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.PreDefinition.noConfusionType,[],[]]
[Lean.Core.instMonadResolveNameCoreM,[Lean.MonadResolveName.mk, Bind.bind, MonadReader.read, Pure.pure, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls],[Lean.MonadResolveName, Lean.Core.CoreM]]
[Lean.Parser.checkColGtFn,[Unit.unit, Lean.Parser.ParserState, Lean.Parser.ParserContext.savedPos?, ite, GT.gt, Lean.Position.column, Lean.Parser.ParserState.mkError],[Lean.Parser.ParserFn]]
[ByteArray.noConfusionType,[],[]]
[Lean.Parser.Command.optDefDeriving.formatter,[Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.notSymbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.ident.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[List.hasDecidableLt.proof_4,[Eq.symm, eq_of_heq, Eq.refl, List.cons, HEq.refl, False, absurd],[False]]
[Int.decLe,[Decidable, Int.NonNeg, Decidable.isTrue, Int.NonNeg.mk, Decidable.isFalse, Eq.refl, Int.negSucc, HEq.refl, False, HSub.hSub],[Decidable, LE.le]]
[Lean.Lsp.Ipc.runWith,[Bind.bind, IO.Process.spawn, IO.Process.SpawnArgs.mk, Lean.Lsp.Ipc.ipcStdioConfig, System.FilePath.toString, ReaderT.run],[IO]]
[Lean.Parser.Tactic.Conv.ring!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[mul_add,[Semiring.mul_add],[Eq, HMul.hMul, HAdd.hAdd]]
[Lean.Message.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Message.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.TacticInfo.mctxBefore,[],[Lean.MetavarContext]]
[Lean.MessageData.compose.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MessageData.compose, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MessageData.compose, And]]
[Lean.Elab.RecKind.noConfusionType,[noConfusionTypeEnum, Lean.Elab.RecKind.toCtorIdx],[]]
[Lean.instInhabitedPrefixTree,[Inhabited.mk, Lean.PrefixTree.empty],[Inhabited, Lean.PrefixTree]]
[Lean.Parser.getParserPriority,[dite, Eq, Unit.unit, Eq.symm, Except, String, Nat, Lean.Syntax.getNumArgs, Pure.pure, OfNat.ofNat, Lean.Syntax.isNatLit?, Lean.Syntax.getArg, MonadExcept.throw],[Except, String, Nat]]
[IO.FS.FileType.symlink.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.FileType.symlink, OfNat.ofNat]]
[Lean.Elab.Tactic.elabSimpConfigCore,[ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, Lean.Meta.Simp.Config.mk, Lean.withoutModifyingState, Lean.Meta.withLCtx, Lean.LocalContext.mk, EmptyCollection.emptyCollection, Lean.Elab.Term.withSynthesize, Bind.bind, Lean.Elab.Term.elabTermEnsuringType, Lean.Syntax.getOp, OfNat.ofNat, Option.some, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Option.none, liftM, Lean.Meta.instantiateMVars, Bool.false],[Lean.Elab.Term.TermElabM, Lean.Meta.Simp.Config]]
[Lean.Lsp.DocumentSymbolAux.selectionRange,[],[Lean.Lsp.Range]]
[Nat.coprime.dvd_of_dvd_mul_left,[Nat.coprime.dvd_of_dvd_mul_right, Eq.mp, Eq.refl, Dvd.dvd, HMul.hMul, Nat.mul_comm],[Dvd.dvd]]
[Lean.IR.Checker.checkFullApp,[Bind.bind, Lean.IR.Checker.getDecl, ite, Eq, BEq.beq, Array.size, Lean.IR.Decl.params, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.IR.Checker.M, Unit]]
[Lean.Meta.RewriteResult.eqProof,[],[Lean.Expr]]
[Lean.Parser.mkAntiquotSplice.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.maxPrec, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.setExpected.parenthesizer, List.nil, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.manyNoAntiquot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.nullKind],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Tactic.classical,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Lsp.ReferenceParams.mk.inj,[And.intro],[And, Eq]]
[map_eq_pure_bind,[Eq.mpr, Eq.refl, Eq, Functor.map, Bind.bind, Pure.pure, Eq.symm, LawfulMonad.bind_pure_comp, rfl],[Eq, Functor.map, Bind.bind, Pure.pure]]
[Lean.IR.EmitC.emitTag,[ite, Eq, Lean.IR.IRType.isObj, Bool.true, Bind.bind, Lean.IR.EmitC.emit],[Lean.IR.EmitC.M, Unit]]
[Lean.Syntax.mkAntiquotSpliceNode,[Lean.mkNode, HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkAtom, Lean.mkNullNode, List.nil],[Lean.Syntax]]
[Lean.MetavarContext.MkBinding.Exception.revertFailure.inj,[And.intro],[And, Eq]]
[not_or_of_imp,[Decidable.not_or_of_imp],[Or, Not]]
[List.mem_cons,[Iff.rfl],[Iff, Mem.mem, List.cons, Or, Eq]]
[Lean.Meta.lambdaLetTelescope,[Lean.Meta.map2MetaM, Bind.bind, Lean.MonadLCtx.getLCtx, List.toArray, List.nil, OfNat.ofNat, Bool.true],[]]
[Function.injective.ne,[mt],[Ne]]
[Lean.Parser.Command.infixl,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Elab.Term.MVarErrorInfo.logError.addArgName,[Unit.unit, Lean.MessageData, Lean.Elab.Term.MVarErrorInfo.argName?, ite, Eq, Lean.Name.hasMacroScopes, Bool.true, HAppend.hAppend, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.ToMessageData.toMessageData],[Lean.MessageData]]
[Lean.IR.UniqueIds.checkParams,[Array.allM, Lean.IR.UniqueIds.checkId, Lean.IR.VarId.idx, Lean.IR.Param.x, OfNat.ofNat, Array.size],[Lean.IR.UniqueIds.M, Bool]]
[Lean.ReducibilityHints.isRegular,[Lean.ReducibilityHints.opaque, Lean.ReducibilityHints.abbrev, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Lsp.SemanticTokens.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.SemanticTokens.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.SemanticTokens.mk]]
[Lean.IR.JoinPointId.mk.injEq,[Eq.propIntro, Eq.refl, Lean.IR.JoinPointId.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.JoinPointId.mk]]
[Lean.getPPInstanceTypes,[Lean.KVMap.get, Lean.Option.name, Lean.pp.instanceTypes, Lean.Option.defValue],[Bool]]
[Lean.Syntax.setKind,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.node],[Lean.Syntax]]
[Array.set!,[Array.setD],[Array]]
[Lean.LocalContext.mkEmpty,[Lean.LocalContext.mk],[Lean.LocalContext]]
[Lean.Parser.Command.namedName,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.ident],[Lean.Parser.Parser]]
[Lean.Elab.Term.instAddErrorMessageContextTermElabM,[Lean.AddErrorMessageContext.mk, Bind.bind, MonadReader.read, Lean.AddMessageContext.addMessageContext, Lean.Elab.addMacroStack, Lean.Elab.Term.Context.macroStack, Pure.pure, Prod.mk],[Lean.AddErrorMessageContext, Lean.Elab.Term.TermElabM]]
[UInt16.instSemiringUInt16.proof_10,[rfl],[Eq, Nat.succ]]
[Lean.Xml.Parser.CDSect,[SeqLeft.seqLeft, SeqRight.seqRight, Lean.Xml.Parser.CDStart, Lean.Xml.Parser.CData, Lean.Xml.Parser.CDEnd],[Lean.Parsec, String]]
[DoResultSBC.break.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultSBC.break, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.Conv.ringNF!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.ringMode],[Lean.ParserDescr]]
[Lean.mkAttributeImplOfBuilder,[Bind.bind, ST.Ref.get, Lean.attributeImplBuilderTableRef, Unit.unit, IO, Lean.AttributeImpl, Std.HashMap.find?, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, IO.ofExcept],[IO, Lean.AttributeImpl]]
[Lean.Unhygienic,[ReaderT, Lean.Unhygienic.Context, StateM, Lean.MacroScope],[]]
[Lean.LOption.noConfusionType,[],[]]
[Lean.Elab.Term.StructInst.Source.explicit.inj,[],[Eq]]
[Lean.Parser.Term.waitIfContainsMVar.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[CommMonoid.noConfusionType,[],[]]
[Lean.Lsp.Hover.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.Hover.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Compiler.hasNoInlineAttribute,[Lean.Compiler.InlineAttributeKind.noinline],[Bool]]
[Std.PersistentArray.mkNewTail,[ite, LE.le, Std.PersistentArray.size, USize.toNat, Std.PersistentArray.mul2Shift, OfNat.ofNat, HAdd.hAdd, Std.PersistentArray.shift, Std.PersistentArray.initShift, Std.PersistentArray.mk, Std.PersistentArray.insertNewLeaf, Std.PersistentArray.root, USize.ofNat, HSub.hSub, Std.PersistentArray.tail, Std.PersistentArray.mkEmptyArray, Std.PersistentArrayNode.node, Array.push, Std.PersistentArray.mkNewPath, List.toArray, List.nil],[Std.PersistentArray]]
[Lean.Meta.Simp.Methods.pre,[],[Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step]]
[Std.HashSet.size,[Nat],[Nat]]
[Tactic.Ring.HornerExpr.xadd.inj,[And.intro],[And, Eq]]
[String.leftpad_length,[Eq, String.length, String.leftpad, max, of_eq_true, Eq.trans, congrFun, congrArg, List.leftpad_length, List.length, eq_self],[Eq, String.length, String.leftpad, max]]
[Lean.Lsp.instInhabitedCancelParams,[Inhabited.mk, Lean.Lsp.CancelParams.mk, arbitrary],[Inhabited, Lean.Lsp.CancelParams]]
[UInt64.toUInt8,[Nat.toUInt8, UInt64.toNat],[UInt8]]
[Lean.Elab.Term.elabLetRec,[Bind.bind, Array.mapM, Lean.Elab.expandOptDocComment?, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, List.toArray, List.nil, Lean.Elab.elabDeclAttrs, Lean.Syntax.getSepArgs, Lean.Elab.Term.LetRecView.mk, Lean.Elab.Term.LetRecView.decls, ForIn.forIn, Unit.unit, Lean.Elab.Term.TermElabM, ForInStep, Subarray, Lean.Expr, Stream.next?, ForInStep.done, Lean.Elab.Term.addTermInfo, Lean.Elab.Term.LetRecDeclView.ref, Option.none, Lean.Name.anonymous, ForInStep.yield, Lean.Meta.forallBoundedTelescope, Lean.Elab.Term.LetRecDeclView.type, Option.some, Array.size, Lean.Elab.Term.LetRecDeclView.binderIds, PUnit.unit, Array.getOp, Lean.Elab.Term.withDeclName, Lean.Elab.Term.LetRecDeclView.declName, Lean.Elab.Term.elabTermEnsuringType, Lean.Elab.Term.LetRecDeclView.valStx, liftM, Lean.Meta.mkLambdaFVars, Bool.false, Lean.Elab.Term.LetRecView.body, MonadState.get, List.any, BEq.beq, Lean.Elab.Term.LetRecToLift.declName, Lean.withRef, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MonadLCtx.getLCtx, Lean.Meta.getLocalInstances, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Array.toList, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState, Lean.mkAppN],[Lean.Elab.Term.TermElab]]
[eq_false_of_decide,[propext, Iff.intro, absurd, of_decide_eq_false, False.elim],[Eq, False]]
[instToStringSubtype,[ToString.mk, ToString.toString, Subtype.val],[ToString, Subtype]]
[Lean.Parser.ParserState.mkErrorAt,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Array.push, Lean.Syntax.missing, Option.some, Lean.Parser.Error.mk, List.cons, List.nil, Array.shrink],[Lean.Parser.ParserState]]
[Acc.ndrec,[],[]]
[Lean.Meta.IndPredBelow.mkBelowMatcher,[Bind.bind, Lean.Meta.Match.getMkMatcherInputInContext, Lean.Meta.forallBoundedTelescope, Lean.Meta.Match.MkMatcherInput.matchType, Option.some, Lean.Meta.Match.MkMatcherInput.numDiscrs, Lean.Meta.inferType, Array.getOp, Lean.Expr.withApp, Lean.getConstInfoInduct, Pure.pure, Prod.mk, Lean.Meta.MetaM, Prod, Lean.Name, Lean.Expr, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.withLocalDeclD, Lean.Meta.mkForallFVars, Array.push, Bool.false, Bool.true, Lean.Expr.replaceFVars, Lean.Meta.MatcherApp.discrs, Unit, List.mapM, Lean.Meta.Match.MkMatcherInput.lhss, Array.mapIdxM, Array.zip, List.toArray, List.zip, Lean.Meta.MatcherApp.alts, Lean.Meta.withExistingLocalDecls, HAppend.hAppend, Lean.Meta.Match.AltLHS.fvarDecls, Lean.Meta.lambdaTelescope, Lean.isTracingEnabledFor, ite, Eq, Lean.addTrace, Lean.ToMessageData.toMessageData, Array.map, Lean.LocalDecl.toExpr, Array.toSubarray, OfNat.ofNat, Array.size, PUnit.unit, Lean.Meta.Match.MkMatcherInput.matcherName, List.foldl, List.nil, ForIn.forIn, Lean.Meta.Match.Pattern.toMessageData, Lean.Meta.Match.AltLHS.patterns, ForInStep.yield, Lean.Meta.Match.mkMatcher, Lean.Meta.Match.MkMatcherInput.mk, HAdd.hAdd, Lean.Meta.Match.MatcherResult.addMatcher, Lean.Meta.check, Lean.Meta.Match.MatcherResult.matcher, Lean.Meta.IndPredBelow.mkBelowMatcher.addBelowPattern, Lean.Meta.IndPredBelow.mkBelowMatcher.convertToBelow, Lean.Meta.IndPredBelow.mkBelowMatcher.transformFields, Lean.Meta.IndPredBelow.mkBelowMatcher.toInaccessible, Lean.Meta.IndPredBelow.mkBelowMatcher.newMotive],[Lean.Meta.MetaM, Prod, Lean.Expr, Unit]]
[Lean.HeadIndex.lit.injEq,[Eq.propIntro, Eq.refl, Lean.HeadIndex.lit, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.HeadIndex.lit]]
[Lean.Parser.Term.local,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[UInt8.instRingUInt8.proof_2,[congrArg, UInt8.mk, Ring.gsmul_zero', UInt8.val],[Eq, UInt8.mk, Ring.gsmul, OfNat.ofNat, UInt8.val]]
[Lean.TraceElem.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Info.updateContext?,[Option.none, Option.some, Lean.Elab.Info.ofTermInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.Info.ofCompletionInfo, Option, Lean.Elab.ContextInfo, Lean.Elab.ContextInfo.mk, Lean.Elab.ContextInfo.env, Lean.Elab.ContextInfo.fileMap, Lean.Elab.TacticInfo.mctxAfter, Lean.Elab.ContextInfo.options, Lean.Elab.ContextInfo.currNamespace, Lean.Elab.ContextInfo.openDecls],[Option, Lean.Elab.ContextInfo]]
[List.groupByAux,[List.nil, List.cons, List, Unit.unit, PProd.fst, List.reverse],[List]]
[USize.instSemiringUSize.proof_2,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, USize.zero_def, USize.add_def, USize.mk, OfNat.ofNat, zero_add, USize.val, USize.mk_val_eq, eq_self, propext, forall_const, USize],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.FileWorker.WorkerState.doc,[],[Lean.Server.FileWorker.EditableDocument]]
[instOfNat_1,[OfNat.mk, One.one],[OfNat]]
[Lean.KeyedDeclsAttribute.getEntries,[ite, Eq, Std.PersistentHashSet.isEmpty, Lean.KeyedDeclsAttribute.ExtensionState.erased, Bool.true, List.filter, not, Std.PersistentHashSet.contains, Lean.KeyedDeclsAttribute.OLeanEntry.declName, Lean.KeyedDeclsAttribute.AttributeEntry.toOLeanEntry],[List, Lean.KeyedDeclsAttribute.AttributeEntry]]
[UInt16.modn,[UInt16.mk, HMod.hMod, UInt16.val],[UInt16]]
[MonadExceptOf.tryCatch,[],[]]
[Lean.Lsp.SemanticTokensLegend.tokenModifiers,[],[Array, String]]
[Lean.unreachIsNodeMissing,[False.elim, Lean.unreachIsNodeMissing.proof_1],[]]
[instShiftRightUInt16,[ShiftRight.mk, UInt16.shiftRight],[ShiftRight, UInt16]]
[Lean.Expr.mvar.inj,[And.intro],[And, Eq]]
[Lean.Macro.State.noConfusionType,[],[]]
[Lean.Parser.Term.doIfLetPure.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.IR.ExplicitBoxing.BoxingState.auxDeclCache,[],[Std.AssocList, Lean.IR.FnBody, Lean.IR.Expr]]
[Lean.«tacticIntro.»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[FloatArray.forIn.loop,[Pure.pure],[]]
[Lean.Parser.Term.doIfLet.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.doIfLetPure.parenthesizer, Lean.Parser.Term.doIfLetBind.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.elabNamedPattern,[Bind.bind, List.nil, Bool.false, List.toArray, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.Elab.Term.TermElabM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Pure.pure, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError],[Lean.Elab.Term.TermElab]]
[InvImage.wf.proof_1,[WellFounded.intro, InvImage.accessible, WellFounded.apply],[WellFounded, InvImage]]
[Ordering.noConfusion,[noConfusionEnum, Ordering.toCtorIdx],[Ordering.noConfusionType]]
[List.perm_middle,[List.Perm, HAppend.hAppend, List.cons, List.Perm.refl, List.nil, List.Perm.trans, List.Perm.cons, List.Perm.swap],[List.Perm, HAppend.hAppend, List.cons]]
[Nat.sub_le_sub_right,[Unit.unit, LE.le, HSub.hSub, Nat.pred_le_pred, PProd.fst],[LE.le, HSub.hSub]]
[Lean.Meta.Closure.State.exprMVarArgs,[],[Array, Lean.Expr]]
[Lean.ResolveName.resolveGlobalName.loop,[Lean.Name.anonymous, Lean.Name.num, List, Prod, Lean.Name, String, Unit.unit, List.cons, Lean.Name.str, ite, Eq, and, Lean.Environment.contains, or, not, Lean.Name.isAtomic, Lean.isProtected, Bool.true, PProd.fst, List.nil, List.map, Prod.mk, List.eraseDups, Option.none, Option.some],[List, Prod, Lean.Name, String]]
[Lean.Compiler.SpecInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Compiler.SpecInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Compiler.SpecInfo.mk, And]]
[UInt32.instSemiringUInt32.proof_9,[rfl],[Eq, OfNat.ofNat]]
[UInt16.decEq.proof_1,[rfl],[Eq, UInt16.mk]]
[Lean.Elab.Tactic.Conv.evalConvConvSeq,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.Conv.getLhs, Lean.Elab.Tactic.Conv.convert, Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.Conv.updateLhs],[Lean.Elab.Tactic.Tactic]]
[instCoeDep,[CoeDep.mk, coeFun],[CoeDep]]
[Lean.Eval.noConfusionType,[],[]]
[And.elim,[And.left, And.right],[]]
[Lean.mkBelowName,[Lean.Name.mkStr, Lean.belowSuffix],[Lean.Name]]
[USize.add,[USize.mk, HAdd.hAdd, USize.val],[USize]]
[IO.Error.protocolError.inj,[And.intro],[And, Eq]]
[Lean.Compiler.SpecInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.FnBody.jdecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.FnBody.jdecl, HAdd.hAdd, OfNat.ofNat]]
[instRingFin.proof_2,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.mul_def, Fin.mk, HMod.hMod, Nat.mod_lt, Fin.size_positive, congrFun, HMul.hMul, Nat.zero_mod, Nat.zero_mul, Fin.zero_def, eq_true_of_decide, Eq.refl, Bool.true],[Eq, Fin, Semiring.nsmul, Neg.neg, Nat.succ, OfNat.ofNat]]
[Equiv.toFun,[],[]]
[le_of_not_le,[Or.resolve_left, le_total],[LE.le]]
[Lean.IR.instToFormatArg,[Std.ToFormat.mk, Unit.unit, Std.Format, Std.ToFormat.format, Std.Format.text],[Std.ToFormat, Lean.IR.Arg]]
[Lean.IR.CompilerState.noConfusionType,[],[]]
[Lean.Meta.mkGeneralizationForbiddenSet,[Bind.bind, ForIn.forIn, MProd.mk, Lean.Meta.MetaM, Lean.FVarIdSet, Array.toList, Lean.CollectFVars.State.fvarSet, Lean.Meta.mkGeneralizationForbiddenSet.visit, Lean.Meta.mkGeneralizationForbiddenSet.loop],[Lean.Meta.MetaM, Lean.FVarIdSet]]
[Lean.IR.FnBody.nil,[Lean.IR.FnBody.unreachable],[Lean.IR.FnBody]]
[Lean.DefinitionVal.toConstantVal,[],[Lean.ConstantVal]]
[Lean.Server.instRpcEncodingProdProd,[Lean.Server.RpcEncoding.mk, Prod, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Pure.pure, Prod.mk, ExceptT, String, Lean.Server.RpcEncoding.rpcDecode],[Lean.Server.RpcEncoding, Prod]]
[Lean.IR.EmitC.emitFileHeader,[Bind.bind, Lean.IR.EmitC.getEnv, Lean.IR.EmitC.getModName, Lean.IR.EmitC.emitLn, HAppend.hAppend, ToString.toString, Lean.IR.EmitC.emit, Array.forM, Lean.Environment.imports, OfNat.ofNat, Array.size, Lean.IR.EmitC.emitLns, List.cons, List.nil],[Lean.IR.EmitC.M, Unit]]
[Lean.Elab.DefKind.opaque.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.DefKind.opaque, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.addTermInfo,[Bind.bind, modify, Lean.PrettyPrinter.Delaborator.State.mk, Std.RBMap.insert, Lean.PrettyPrinter.Delaborator.State.infos, Lean.PrettyPrinter.Delaborator.State.holeIter, Lean.PrettyPrinter.Delaborator.addTermInfo.mkTermInfo],[Lean.PrettyPrinter.Delaborator.DelabM, Unit]]
[UInt32.sub,[UInt32.mk, HSub.hSub, UInt32.val],[UInt32]]
[Lean.IR.instInhabitedFnBody,[Inhabited.mk, Lean.IR.FnBody.unreachable],[Inhabited, Lean.IR.FnBody]]
[HPow.hPow,[],[]]
[Lean.Meta.setMVarKind,[Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.setMVarKind],[Lean.Meta.MetaM, Unit]]
[Lean.addMessageContextPartial,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, Pure.pure, Lean.MessageData.withContext, Lean.MessageDataContext.mk, Lean.MetavarContext.mk, Lean.LocalContext.mk],[Lean.MessageData]]
[OptionT.instMonadFunctorOptionT,[MonadFunctor.mk, Option],[MonadFunctor, OptionT]]
[Subtype.map,[Subtype.mk, Subtype.val, Subtype.map.proof_1],[Subtype]]
[Function.const_def,[rfl],[Eq, Function.const]]
[ReaderT.run_pure,[rfl],[Eq, ReaderT.run, Pure.pure]]
[Int.ofNat_add_ofNat,[rfl],[Eq, HAdd.hAdd, Int.ofNat]]
[Lean.Meta.UnificationHintEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.UnificationHintEntry.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.UnificationHintEntry.mk, And]]
[Lean.Elab.Term.Context.fileName,[],[String]]
[StateRefT'.instMonadLiftStateRefT',[MonadLift.mk, StateRefT'.lift],[MonadLift, StateRefT']]
[Lean.Lsp.TextDocumentSyncKind.noConfusion,[noConfusionEnum, Lean.Lsp.TextDocumentSyncKind.toCtorIdx],[Lean.Lsp.TextDocumentSyncKind.noConfusionType]]
[Nat.dvd_trans,[Dvd.dvd, Exists.intro, HMul.hMul],[Dvd.dvd]]
[Lean.Option.get?,[Lean.KVMap.get?, Lean.Option.name],[Option]]
[Lean.PersistentEnvExtensionState.importedEntries,[],[Array]]
[Lean.IR.ExplicitBoxing.BoxingState.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.ExplicitRC.visitDecl,[Lean.IR.Decl.extern, Lean.IR.Decl, Lean.IR.Decl.updateBody!],[Lean.IR.Decl]]
[Lean.Meta.Simp.rewrite.inErasedSet,[Unit.unit, Bool, Lean.Meta.SimpLemma.name?, Bool.false, Std.PersistentHashSet.contains],[Bool]]
[Int.add_assoc_aux2,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HAdd.hAdd, Int.negSucc_ofNat_add_negSucc_ofNat, Int.ofNat, Int.negSucc_ofNat_add_ofNat, Nat.succ, Int.negSucc, Eq.refl, Int.subNatNat, Int.add_comm, Int.subNatNat_add_negSucc_ofNat, of_eq_true, Nat.add_succ, Nat.succ_add, Nat.add_comm, eq_self],[Eq, HAdd.hAdd, Int.negSucc, Int.ofNat]]
[Std.AssocList.find?,[Unit.unit, Option, Option.none, BEq.beq, Option.some, PProd.fst],[Option]]
[Lean.Elab.Info.isTerm,[Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.Info.ofCompletionInfo, Bool, Bool.true, Bool.false],[Bool]]
[ExceptT.instMonadLiftExceptT,[MonadLift.mk, ExceptT.lift],[MonadLift, ExceptT]]
[Lean.DataValue.ofName.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.DataValue.ofName, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.pipeCompletion,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.minPrec, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.TrailingParser]]
[coeOfHead,[CoeHTCT.mk, coeHead],[CoeHTCT]]
[dif_pos,[Eq, dite, rfl, absurd],[Eq, dite]]
[Decidable.and_iff_not_or_not,[Eq.mpr, Eq.refl, Iff, And, Not, Or, Eq.symm, propext, Decidable.not_and_distrib, Decidable.not_not, Iff.rfl],[Iff, And, Not, Or]]
[instAddCommSemigroupFin.proof_1,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.add_def, congrFun, HMod.hMod, Nat.add_comm, eq_self, HAdd.hAdd],[Eq, HAdd.hAdd]]
[Lean.Meta.Split.simpMatchTarget,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getMVarType, Lean.Meta.instantiateMVars, Lean.Meta.Split.simpMatch, Lean.Meta.applySimpResultToTarget],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.Elab.Term.Do.ToTerm.mkIte,[ite, Eq, Lean.Syntax.isNone, Bool.true, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.MacroM, Lean.Syntax]]
[Lean.Parser.ParserState.mkEOIError,[Lean.Parser.ParserState.mkUnexpectedError],[Lean.Parser.ParserState]]
[Lean.Elab.Term.StructInst.ExplicitSourceInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.StructInst.ExplicitSourceInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.StructInst.ExplicitSourceInfo.mk, And]]
[Lean.Parser.Command.syntaxAbbrev.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.docComment.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter, Lean.Parser.many1.formatter, Lean.Parser.syntaxParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Server.Completion.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.Completion.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.Completion.State.mk, And]]
[Lean.Elab.getDeclarationRange,[Bind.bind, Lean.MonadFileMap.getFileMap, Pure.pure, Lean.DeclarationRange.mk, Lean.Lsp.Position.character, Lean.FileMap.leanPosToLspPos],[Lean.DeclarationRange]]
[Lean.Parser.Command.notationItem,[HAndThen.hAndThen, Lean.Parser.ppSpace, Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, HOrElse.hOrElse, Lean.Parser.strLit, Lean.Parser.Command.identPrec],[Lean.Parser.Parser]]
[Lean.Lsp.DidChangeTextDocumentParams.mk.inj,[And.intro],[And, Eq]]
[Std.RBTree.any,[Std.RBMap.any],[Bool]]
[Fin.shiftRight,[Fin, Fin.mk, HMod.hMod, HShiftRight.hShiftRight, Fin.shiftRight.proof_1],[Fin]]
[Lean.Parser.Command.infixr.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[IO.Error.resourceBusy.inj,[And.intro],[And, Eq]]
[Lean.InductiveVal.numParams,[],[Nat]]
[Lean.Export.Entry.name.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Export.Entry.name, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.Snapshots.Snapshot.isAtEnd,[or, Lean.Parser.isEOI, Lean.Server.Snapshots.Snapshot.stx, Lean.Parser.isExitCommand],[Bool]]
[Int.one_mul,[Eq, HMul.hMul, OfNat.ofNat],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Syntax.TopDown.stx,[],[Lean.Syntax]]
[Std.ShareCommon.mkObjectMap,[Std.mkHashMap, OfNat.ofNat],[Std.ShareCommon.ObjectMap]]
[Lean.Lsp.instBEqDiagnosticWith,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Lsp.DiagnosticWith]]
[Lean.Meta.Config.constApprox,[],[Bool]]
[Lean.instEmptyCollectionMVarIdMap,[inferInstanceAs, EmptyCollection, Std.RBMap, Lean.MVarId, Lean.Name.quickCmp, Lean.MVarId.name],[EmptyCollection, Lean.MVarIdMap]]
[Lean.Elab.Command.StructFieldInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.StructFieldInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Command.StructFieldInfo.mk, And]]
[Lean.Meta.caseValues.loop,[Lean.Meta.MetaM, Array, Lean.Meta.CaseValuesSubgoal, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing, Bind.bind, Lean.Meta.withMVarContext, Lean.Meta.getMVarTag, Lean.Meta.checkNotAssigned, Lean.Meta.getMVarType, Lean.Meta.mkEq, Lean.mkFVar, Lean.Meta.foldPatValue, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.mkAppOptM, List.toArray, List.cons, Option.none, Option.some, List.nil, Lean.Meta.assignExprMVar, Lean.Meta.intro1P, Lean.Expr.mvarId!, Prod, Lean.Meta.CaseValueSubgoal, Lean.Meta.substCore, Bool.false, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, List.map, Lean.FVarId.name, Lean.Meta.FVarSubst.domain, Pure.pure, PUnit.unit, Prod.mk, Lean.Name.appendIndexAfter, Lean.Meta.FVarSubst.mk, Lean.Meta.appendTagSuffix, Lean.Meta.CaseValueSubgoal.mvarId, Array.foldlM, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.MVarId, Lean.Meta.FVarSubst.get, Lean.Meta.CaseValueSubgoal.subst, Lean.Meta.tryClear, OfNat.ofNat, Array.size, Unit.unit, HAdd.hAdd, Array.push, Lean.Meta.CaseValuesSubgoal.mk, Lean.Meta.CaseValueSubgoal.newH, PProd.fst],[Lean.Meta.MetaM, Array, Lean.Meta.CaseValuesSubgoal]]
[Lean.Parser.Tactic.ghostFunTac,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[System.FilePath.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, System.FilePath.mk, HAdd.hAdd, OfNat.ofNat]]
[usize_size_eq,[],[Or, Eq, USize.size, OfNat.ofNat]]
[Lean.Compiler.atMostOnce.instAndThenVisitor,[AndThen.mk, Lean.Compiler.atMostOnce.seq, Unit.unit],[AndThen, Lean.Compiler.atMostOnce.Visitor]]
[Lean.Elab.Term.isLocalIdent?,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Elab.Term.TermElabM, Option, Lean.Expr, Bind.bind, Lean.Elab.Term.resolveLocalName, Option.none, Option.some, Prod.mk, List.cons, Pure.pure],[Lean.Elab.Term.TermElabM, Option, Lean.Expr]]
[Lean.Parser.Term.doCatch.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.Parser.optional.formatter, Lean.Parser.termParser.formatter, Lean.Parser.darrow.formatter, Lean.Parser.Term.doSeq.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.leadPrec,[OfNat.ofNat],[Nat]]
[UInt8.shiftRight,[UInt8.mk, HShiftRight.hShiftRight, UInt8.val, UInt8.modn, OfNat.ofNat],[UInt8]]
[UInt16.le,[LE.le, UInt16.val],[]]
[Lean.version.patch,[Unit.unit],[Nat]]
[Lean.PersistentLevelMap,[Std.PHashMap, Lean.Level],[]]
[Lean.ConstantInfo.thmInfo.inj,[],[Eq]]
[Lean.Elab.Tactic.ElimApp.setMotiveArg,[Bind.bind, Lean.Meta.inferType, Lean.mkMVar, Lean.Meta.mkLambdaFVars, Array.map, Lean.mkFVar, Bool.false, Bool.true, Lean.Meta.isDefEqGuarded, ite, Eq, Pure.pure, PUnit.unit, Lean.Meta.mkHasTypeButIsExpectedMsg, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr],[Lean.Meta.MetaM, Unit]]
[Std.PersistentHashSet.instEmptyCollectionPersistentHashSet,[EmptyCollection.mk, Std.PersistentHashSet.empty],[EmptyCollection, Std.PersistentHashSet]]
[Std.PersistentArray.modify,[ite, GE.ge, Std.PersistentArray.tailOff, Std.PersistentArray.mk, Std.PersistentArray.root, Array.modify, Std.PersistentArray.tail, HSub.hSub, Std.PersistentArray.size, Std.PersistentArray.shift, Std.PersistentArray.modifyAux, USize.ofNat],[Std.PersistentArray]]
[Lean.Parser.ppGroup,[id],[Lean.Parser.Parser]]
[Lean.Compiler.SpecInfo.argKinds,[],[Lean.Compiler.SpecArgKind]]
[Lean.Meta.Match.getEquationsFor,[Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.Meta.MetaM, Lean.Meta.Match.MatchEqns, Std.PersistentHashMap.find?, Lean.Meta.Match.MatchEqnsExtState.map, Lean.EnvExtension.getState, Lean.Meta.Match.matchEqnsExt, Pure.pure, Lean.Meta.withConfig, Lean.Meta.Config.mk, Lean.Meta.Config.foApprox, Lean.Meta.Config.ctxApprox, Lean.Meta.Config.quasiPatternApprox, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Bool.false, Lean.getConstInfo, Lean.Meta.getMatcherInfo?, Option.none, Lean.Meta.forallTelescopeReducing, Lean.ConstantInfo.type, ForIn.forIn, MProd.mk, Lean.Meta.inferType, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Array.getOp, Lean.Meta.dependsOn, Lean.Expr.fvarId!, and, Lean.Expr.isConstOf, Lean.Name.mkStr, Lean.Name.anonymous, not, Prod.mk, List.toArray, List.nil, List.cons, Lean.mkConst, PUnit.unit, Prod, Lean.Expr, Nat, Lean.Meta.instantiateForall, ForInStep.yield, Array.filterMapM, Lean.Meta.forallTelescope, Array.mapM, Subarray.toArray, Array.toSubarray, HSub.hSub, StateRefT'.run', OptionT.run, SeqRight.seqRight, MonadState.get, Option, Array.foldrM, Lean.Meta.mkArrow, Array.filterM, Lean.Meta.mkForallFVars, Option.some, Array.forM, OptionT, StateRefT', IO.RealWorld, Array, PUnit, Lean.Expr.eq?, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.isTracingEnabledFor, Lean.addTrace, ForInStep, MProd, Lean.Name],[Lean.Meta.MetaM, Lean.Meta.Match.MatchEqns]]
[Lean.getAllParentStructures,[Prod.snd, StateT.run, List.toArray, List.nil, Lean.getAllParentStructures.visit],[Array, Lean.Name]]
[instReprAtomInt,[ReprAtom.mk],[ReprAtom, Int]]
[Lean.Widget.InteractiveHypothesis.mk.inj,[And.intro],[And, Eq]]
[«stx_+»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[FloatSpec.float,[],[]]
[Lean.Elab.Term.instToStringLVal,[ToString.mk, String, ToString.toString, HAppend.hAppend],[ToString, Lean.Elab.Term.LVal]]
[neg_add_cancel_left,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, Eq.symm, add_assoc, add_left_neg, OfNat.ofNat, zero_add, rfl],[Eq, HAdd.hAdd, Neg.neg]]
[Lean.Server.Watchdog.FileWorker.doc,[],[Lean.Server.Watchdog.OpenDocument]]
[PSum.inl.injEq,[Eq.propIntro, Eq.refl, PSum.inl, Eq.symm, eq_of_heq, HEq.refl],[Eq, PSum.inl]]
[Repr.reprPrec,[],[Std.Format]]
[Lean.Elab.Term.MatchAltView.patterns,[],[Array, Lean.Syntax]]
[Lean.Syntax.unescapeAntiquot,[ite, Eq, Lean.Syntax.isAntiquot, Bool.true, Lean.Syntax.setArg, OfNat.ofNat, Lean.mkNullNode, Array.pop, Lean.Syntax.getArgs, Lean.Syntax.getOp],[Lean.Syntax]]
[List.contains,[List.elem],[Bool]]
[Lean.MVarIdSet,[Std.RBTree, Lean.MVarId, Lean.Name.quickCmp, Lean.MVarId.name],[]]
[LawfulApplicative.seqRight_eq,[],[Eq, SeqRight.seqRight, Seq.seq, Functor.map, Function.const, id]]
[Lean.Elab.Deriving.mkInductiveApp,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Not.decidable_imp_symm,[Decidable.not_imp_symm],[]]
[Lean.Meta.Split.applyMatchSplitter,[Bind.bind, ite, Eq, Array.all, Lean.Expr.isFVar, OfNat.ofNat, Array.size, Bool.true, Pure.pure, Prod.mk, Array.map, Lean.Expr.fvarId!, Array.mapM, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.GeneralizeArg.mk, Option.some, Lean.Meta.generalize, Lean.Meta.MetaM, Prod, Array, Lean.FVarId, Lean.MVarId, Array.ofSubarray, Array.toSubarray, List, Lean.Meta.revert, Lean.Meta.introNP, Lean.Meta.getMatcherInfo?, Option.none, Lean.Meta.Match.getEquationsFor, Lean.Meta.withMVarContext, Lean.Meta.getMVarType, Lean.Meta.mkLambdaFVars, Bool.false, Lean.Meta.Match.MatcherInfo.uElimPos?, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM, List, Lean.MVarId]]
[Lean.Meta.Match.MatcherInfo.getFirstDiscrPos,[HAdd.hAdd, Lean.Meta.Match.MatcherInfo.numParams, OfNat.ofNat],[Nat]]
[Lean.IR.ExpandResetReuse.Context.noConfusionType,[],[]]
[Lean.Lsp.instFromJsonTextDocumentSyncKind,[Lean.FromJson.mk, Except.error, dite, Eq, Unit.unit, Eq.symm, Except.ok, Except, String, Lean.Lsp.TextDocumentSyncKind, Lean.Json.getNat?, Pure.pure, Lean.Lsp.TextDocumentSyncKind.none, Lean.Lsp.TextDocumentSyncKind.full, Lean.Lsp.TextDocumentSyncKind.incremental, MonadExcept.throw],[Lean.FromJson, Lean.Lsp.TextDocumentSyncKind]]
[Lean.Elab.Term.ToDepElimPattern.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.ToDepElimPattern.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.ToDepElimPattern.State.mk, And]]
[String.Iterator.pos,[String.Pos],[String.Pos]]
[Lean.Macro.Methods.getCurrNamespace,[],[Lean.MacroM, Lean.Name]]
[Lean.Meta.SavedState.meta,[],[Lean.Meta.State]]
[Lean.IR.LocalContext.addLocal,[Std.RBMap.insert, Lean.IR.VarId.idx, Lean.IR.LocalContextEntry.localVar],[Lean.IR.LocalContext]]
[DivInvMonoid.div_eq_mul_inv,[],[Eq, HDiv.hDiv, HMul.hMul, Inv.inv]]
[Std.RBTree.max,[Unit.unit, Option, Std.RBMap.max, Option.some, Option.none],[Option]]
[Lean.Meta.Closure.pickNextToProcess?,[Bind.bind, Lean.MonadLCtx.getLCtx, MonadState.get, ite, Eq, Array.isEmpty, Lean.Meta.Closure.State.toProcess, Bool.true, Pure.pure, Option.none, MonadState.modifyGet, Prod, Option, Lean.Meta.Closure.ToProcessElement, Lean.Meta.Closure.State, Prod.mk, Option.some, Lean.Meta.Closure.State.mk, Lean.Meta.Closure.State.visitedLevel, Lean.Meta.Closure.State.visitedExpr, Lean.Meta.Closure.State.levelParams, Lean.Meta.Closure.State.nextLevelIdx, Lean.Meta.Closure.State.levelArgs, Lean.Meta.Closure.State.newLocalDecls, Lean.Meta.Closure.State.newLocalDeclsForMVars, Lean.Meta.Closure.State.newLetDecls, Lean.Meta.Closure.State.nextExprIdx, Lean.Meta.Closure.State.exprMVarArgs, Lean.Meta.Closure.State.exprFVarArgs],[Lean.Meta.Closure.ClosureM, Option, Lean.Meta.Closure.ToProcessElement]]
[Lean.Lsp.DiagnosticRelatedInformation.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.LVal.getOp.inj,[And.intro],[And, Eq]]
[Semiring.zero_add,[],[Eq, HAdd.hAdd, OfNat.ofNat]]
[toBoolUsing_eq_true,[decide_eq_true],[Eq, toBoolUsing, Bool.true]]
[Lean.Elab.MonadMacroAdapter.noConfusionType,[],[]]
[Lean.Meta.localDeclDependsOnPred,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.findLocalDeclDependsOn],[Lean.Meta.MetaM, Bool]]
[Lean.Meta.addCongrLemma,[Bind.bind, Lean.Meta.mkCongrLemma, Lean.ScopedEnvExtension.add, Lean.Meta.congrExtension],[Lean.Meta.MetaM, Unit]]
[Lean.Json.Structured.arr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Json.Structured.arr, HAdd.hAdd, OfNat.ofNat]]
[UInt8.instCommRingUInt8,[CommRing.mk, UInt8.instCommRingUInt8.proof_1],[CommRing, UInt8]]
[Lean.Meta.AbstractMVarsResult.expr,[],[Lean.Expr]]
[Lean.EnvExtensionInterfaceUnsafe.Ext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.EnvExtensionInterfaceUnsafe.Ext.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.mkAttributeImplOfEntry,[IO, Lean.AttributeImpl, IO.ofExcept, Lean.mkAttributeImplOfConstant, Lean.mkAttributeImplOfBuilder],[IO, Lean.AttributeImpl]]
[String.toName,[List.foldl, Lean.Name.mkStr, String.trim, Lean.Name.anonymous],[Lean.Name]]
[Task.pure.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Task.pure, HAdd.hAdd, OfNat.ofNat]]
[Lean.Syntax.getTailInfo,[Option.getD, Lean.Syntax.getTailInfo?, Lean.SourceInfo.none],[Lean.SourceInfo]]
[Nat.mod_mod,[Or.elim, Nat.eq_zero_or_pos, of_eq_true, Eq.trans, congr, congrArg, Eq, HMod.hMod, Nat.mod_zero, eq_self, Nat.mod_eq_of_lt, Nat.mod_lt],[Eq, HMod.hMod]]
[IO.Error.mkHardwareFault,[IO.Error.hardwareFault],[IO.Error]]
[Lean.Elab.Deriving.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.Server.RequestM.bindTask,[liftM, EIO.bindTask, Task.Priority.default],[Lean.Server.RequestM, Lean.Server.RequestTask]]
[tryFinally,[Functor.map, Prod.fst],[]]
[Lean.Parser.Command.infix,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Compiler.findUnFoldFn,[List.lookup, Lean.Compiler.unFoldFns],[Option, Lean.Compiler.UnFoldFn]]
[Lean.Elab.Deriving.DecEq.mkDecEqHeader,[Lean.Elab.Deriving.mkHeader, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat],[Lean.Elab.Term.TermElabM, Lean.Elab.Deriving.Header]]
[Lean.Parser.Command.structCtor,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.atomic, HAndThen.hAndThen, Lean.Parser.Command.declModifiers, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.Command.inferMod, Lean.Parser.symbol],[Lean.Parser.Parser]]
[UInt8.instSemiringUInt8.proof_9,[rfl],[Eq, OfNat.ofNat]]
[Lean.Parser.Term.letIdLhs,[HAndThen.hAndThen, Lean.Parser.Term.ident, Lean.Parser.notFollowedBy, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, Lean.Parser.many, Lean.Parser.ppSpace, HOrElse.hOrElse, Lean.Parser.Term.simpleBinderWithoutType, Lean.Parser.Term.bracketedBinder, Bool.false, Lean.Parser.Term.optType],[Lean.Parser.Parser]]
[Lean.Elab.Term.State.noConfusionType,[],[]]
[List.append_subset_of_subset_of_subset,[Or.elim, Iff.mp, List.mem_append],[Subset.subset, HAppend.hAppend]]
[Lean.Elab.Tactic.MkSimpContextResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Tactic.MkSimpContextResult.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.tfaeHave,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Parser.Command.infixl.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.SCC.Data.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.SCC.Data.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.SCC.Data.mk, And]]
[Lean.KeyedDeclsAttribute.Key,[Lean.Name],[]]
[Lean.mkLevelParam,[Lean.Level.param, Lean.Level.mkData, mixHash, OfNat.ofNat, Hashable.hash, Bool.false, Bool.true],[Lean.Level]]
[Lean.Lsp.instFromJsonTextDocumentItem,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, String, Nat, Pure.pure, Lean.Lsp.TextDocumentItem.mk],[Lean.FromJson, Lean.Lsp.TextDocumentItem]]
[List.zip,[List.zipWith, Prod.mk],[List, Prod]]
[Lean.Server.FileWorker.handleRpcConnect,[Bind.bind, liftM, Lean.Server.FileWorker.RpcSession.new, Lean.Server.FileWorker.WorkerM, Lean.Lsp.RpcConnected, IO.mkRef, modify, Lean.Server.FileWorker.WorkerState.mk, Lean.Server.FileWorker.WorkerState.doc, Lean.Server.FileWorker.WorkerState.pendingRequests, Std.RBMap.insert, Lean.Server.FileWorker.WorkerState.rpcSessions, Pure.pure, Lean.Lsp.RpcConnected.mk],[Lean.Server.FileWorker.WorkerM, Lean.Lsp.RpcConnected]]
[Nat.mul_pred_right,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Nat.pred, HSub.hSub, Nat.mul_comm, Nat.mul_pred_left, rfl],[Eq, HMul.hMul, Nat.pred, HSub.hSub]]
[Lean.ConstantInfo.quotInfo.inj,[],[Eq]]
[and_iff_left_iff_imp,[Iff.intro, And.right, Iff.mpr, and_iff_left_of_imp],[Iff, And]]
[Lean.ExprStructEq.instHashableExprStructEq,[Hashable.mk, Lean.ExprStructEq.hash],[Hashable, Lean.ExprStructEq]]
[Lean.ScopedEnvExtension.Entry.global.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ScopedEnvExtension.Entry.global, HAdd.hAdd, OfNat.ofNat]]
[Lean.Expr.eq?,[Lean.Expr.app3?, Lean.Name.mkStr, Lean.Name.anonymous],[Option, Prod, Lean.Expr]]
[Lean.Elab.withInfoTreeContext,[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, ite, Eq, Lean.Elab.InfoState.enabled, Bool.true, Lean.Elab.getResetInfoTrees, Functor.map, Prod.fst, MonadFinally.tryFinally', Lean.Elab.InfoState.trees, Lean.Elab.MonadInfoTree.modifyInfoState, Lean.Elab.InfoState.mk, Lean.Elab.InfoState.assignment, Std.PersistentArray.push],[]]
[IO.Error.interrupted.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.interrupted, HAdd.hAdd, OfNat.ofNat]]
[toBoolUsing,[Decidable.decide],[Bool]]
[Lean.KeyedDeclsAttribute.tableRef,[],[IO.Ref, Lean.KeyedDeclsAttribute.Table]]
[Lean.Elab.Term.StructInst.Struct.ref,[Lean.Syntax],[Lean.Syntax]]
[UInt32.instSemiringUInt32.proof_3,[congrArg, UInt32.mk, Semiring.nsmul_zero', UInt32.val],[Eq, UInt32.mk, Semiring.nsmul, OfNat.ofNat, UInt32.val]]
[Lean.ModuleData.mk.inj,[And.intro],[And, Eq]]
[Lean.Server.DocumentMeta.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.DocumentMeta.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.DocumentMeta.mk, And]]
[Lean.Elab.Term.LetRecToLift.type,[],[Lean.Expr]]
[Lean.Meta.AbstractMVarsResult.numMVars,[],[Nat]]
[Lean.Elab.Tactic.Conv.evalCongr,[Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Elab.Tactic.Conv.congr, Lean.Elab.Tactic.replaceMainGoal],[Lean.Elab.Tactic.Tactic]]
[ByteSliceT.off,[],[Nat]]
[Lean.MetavarContext.UnivMVarParamResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MetavarContext.UnivMVarParamResult.mk, HAdd.hAdd, OfNat.ofNat]]
[Function.injective.of_comp_iff,[Iff.intro, Function.injective.of_comp, Function.injective.comp],[Iff, Function.injective, Function.comp]]
[coeOfHeadOfTC,[CoeHTCT.mk, coeTC, coeHead],[CoeHTCT]]
[Lean.Widget.CodeToken.noConfusionType,[],[]]
[Lean.PrettyPrinter.ParenthesizerM,[ReaderT, Lean.PrettyPrinter.Parenthesizer.Context, StateRefT', IO.RealWorld, Lean.PrettyPrinter.Parenthesizer.State, Lean.Core.CoreM],[]]
[Lean.IR.LocalContext.getType,[Option.none, Option.some, Lean.IR.LocalContextEntry.joinPoint, Option, Lean.IR.IRType, Std.RBMap.find?, Lean.IR.VarId.idx],[Option, Lean.IR.IRType]]
[ByteArray.uset,[ByteArray, ByteArray.mk, Array.uset],[ByteArray]]
[Lean.LocalContext.empty,[Lean.LocalContext.mk],[Lean.LocalContext]]
[instHAnd,[HAnd.mk, AndOp.and],[HAnd]]
[USize.instAddSemigroupUSize.proof_1,[congrArg, USize.mk, AddSemigroup.add_assoc, USize.val],[Eq, USize.mk]]
[Nat.forM.loop,[Unit.unit, Unit, Pure.pure, Bind.bind, HSub.hSub, OfNat.ofNat, PProd.fst],[Unit]]
[Lean.Elab.Term.synthesizeAppInstMVars,[Bind.bind, ForIn.forIn, PUnit.unit, Lean.Elab.Term.synthesizeInstMVarCore, Option.none, ite, Eq, Bool.true, Pure.pure, ForInStep.yield, Lean.Elab.Term.registerSyntheticMVarWithCurrRef, Lean.Elab.Term.SyntheticMVarKind.typeClass, Lean.MonadRef.getRef, Lean.Elab.Term.registerMVarErrorImplicitArgInfo],[Lean.Elab.Term.TermElabM, Unit]]
[Function.swap,[],[]]
[Array.getSepElems,[Array.getEvenElems],[Array]]
[BaseIO.mapTasks,[List.nil, BaseIO.mapTasks.go],[BaseIO, Task]]
[Lean.Core.transform,[Lean.MonadCacheT.run, Lean.Core.transform.visit],[Lean.Expr]]
[Lean.Elab.Term.ElabAppArgs.State.instMVars,[],[Array, Lean.MVarId]]
[Lean.Elab.Term.elabNoImplicitLambda,[Lean.Elab.Term.elabTerm, Lean.Syntax.getOp, OfNat.ofNat, Functor.map, Lean.Elab.Term.mkNoImplicitLambdaAnnotation, Bool.true],[Lean.Elab.Term.TermElab]]
[instReprSourceInfo,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, HAppend.hAppend, Std.Format.text, Std.Format.line, reprArg, Std.Format.FlattenBehavior.allOrNone],[Repr, Lean.SourceInfo]]
[Lean.Name.cmp,[Unit.unit, Lean.Name.str, Lean.Name.num, Ordering, Ordering.eq, Ordering.lt, Ordering.gt, PProd.fst, Ord.compare],[Ordering]]
[Nat.eq_zero_of_mul_eq_zero,[Or, Eq, OfNat.ofNat, Or.inl, rfl, Or.inr, Nat.eq_zero_of_add_eq_zero_left, Eq.mp, Eq.refl, HMul.hMul, HAdd.hAdd, Nat.succ_mul],[Or, Eq, OfNat.ofNat]]
[Lean.Elab.Command.StructFieldInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Command.StructFieldInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[commandSudoSet_option___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Deriving.Context.noConfusionType,[],[]]
[Lean.getPPInstantiateMVars,[Lean.KVMap.get, Lean.Option.name, Lean.pp.instantiateMVars, Lean.Option.defValue],[Bool]]
[Lean.Parser.tacticParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parsec.skipChar,[SeqRight.seqRight, Lean.Parsec.pchar, Pure.pure, Unit.unit],[Lean.Parsec, Unit]]
[UInt16.instAddCommSemigroupUInt16,[AddCommSemigroup.mk, UInt16.instAddCommSemigroupUInt16.proof_1],[AddCommSemigroup, UInt16]]
[Std.PersistentHashMap.maxDepth,[OfNat.ofNat],[USize]]
[Lean.Parser.Tactic.tryFor,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.PrettyPrinter.Formatter.pushLine,[Bind.bind, Lean.PrettyPrinter.Formatter.push, Std.Format.line, modify, Lean.PrettyPrinter.Formatter.State.mk, Lean.PrettyPrinter.Formatter.State.stxTrav, Lean.PrettyPrinter.Formatter.State.stack],[Lean.PrettyPrinter.FormatterM, Unit]]
[Quotient.recOnSubsingleton₂,[Quot.recOnSubsingleton],[]]
[Lean.MetavarKind.noConfusion,[noConfusionEnum, Lean.MetavarKind.toCtorIdx],[Lean.MetavarKind.noConfusionType]]
[Lean.IR.CompilerState.log,[],[Lean.IR.Log]]
[by_contra,[Decidable.by_contradiction],[]]
[Lean.Elab.instMonadInfoTree,[Lean.Elab.MonadInfoTree.mk, liftM, Lean.Elab.MonadInfoTree.getInfoState, Lean.Elab.MonadInfoTree.modifyInfoState],[Lean.Elab.MonadInfoTree]]
[Lean.Expr.letE.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Expr.letE, HAdd.hAdd, OfNat.ofNat]]
[iff_not_self,[Iff.mpr],[Not, Iff]]
[Lean.Level.getOffsetAux,[Lean.Level.zero, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Nat, PProd.fst, HAdd.hAdd, OfNat.ofNat],[Nat]]
[Lean.Lsp.RpcRef.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.RpcRef.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.Sorry.State.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.ExplicitBoxing.BoxingContext.mk.inj,[And.intro],[And, Eq]]
[Lean.Xml.Element.Element.inj,[And.intro],[And, Eq]]
[Std.HashSetImp.foldM,[Std.HashSetImp.foldBucketsM, Std.HashSetImp.buckets],[]]
[Lean.IR.EmitC.quoteString,[HAppend.hAppend],[String]]
[Lean.Lsp.WorkspaceFolder.noConfusionType,[],[]]
[Std.Range.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.Range.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.Range.mk, And]]
[Fin.ofNat.proof_1,[Nat.mod_lt, Nat.zero_lt_succ],[LT.lt, HMod.hMod, Nat.succ]]
[Lean.isLetFun,[Unit.unit, Bool, Lean.letFunAnnotation?, Bool.false, and, Lean.Expr.isApp, Lean.Expr.isLambda, Lean.Expr.appFn!],[Bool]]
[Lean.Elab.Term.MutualClosure.insertReplacementForLetRecs,[List.foldl, Std.RBMap.insert, Lean.Elab.Term.LetRecToLift.fvarId, Lean.Elab.Term.MutualClosure.LetRecClosure.toLift, Lean.Elab.Term.MutualClosure.LetRecClosure.closed],[Lean.Elab.Term.MutualClosure.Replacement]]
[Lean.MonadCacheT,[StateRefT', Std.HashMap],[]]
[Lean.Elab.throwAbortCommand,[MonadExcept.throw, Lean.Exception.internal, Lean.Elab.abortCommandExceptionId, Lean.KVMap.mk],[]]
[List.length_pos_of_mem,[LT.lt, OfNat.ofNat, List.length, List.nil, Eq.refl, Eq.mpr, List.cons, List.length_cons, Nat.zero_lt_succ],[LT.lt, OfNat.ofNat, List.length]]
[Lean.Parser.Term.bracketedBinderF,[Lean.Parser.Term.bracketedBinder, Bool.false],[Lean.Parser.Parser]]
[Lean.Parser.Tactic.Conv.ringNF,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.ringMode],[Lean.ParserDescr]]
[Lean.Meta.Simp.Config.memoize,[],[Bool]]
[Lean.LocalContext.sanitizeNames,[Bind.bind, MonadState.get, ite, Eq, not, Lean.getSanitizeNames, Lean.NameSanitizerState.options, Bool.true, Pure.pure, StateT.run', Nat.foldRevM, Unit.unit, StateT, Lean.NameSet, StateM, Lean.NameSanitizerState, Lean.LocalContext, Std.PersistentArray.getOp, Lean.LocalContext.decls, or, Lean.Name.hasMacroScopes, Lean.LocalDecl.userName, Lean.NameSet.contains, modify, Lean.NameSet.insert, liftM, Lean.sanitizeName, Lean.LocalContext.setUserName, Lean.LocalDecl.fvarId, Std.PersistentArray.size, EmptyCollection.emptyCollection],[StateM, Lean.NameSanitizerState, Lean.LocalContext]]
[instReprFin,[Repr.mk, repr, Fin.val],[Repr, Fin]]
[Lean.instMetaEval,[Lean.MetaEval.mk, Bind.bind, Lean.Eval.eval, Pure.pure],[Lean.MetaEval]]
[instCommSemiring,[CommSemiring.mk, CommRing.mul_comm],[CommSemiring]]
[Semiring.toSemigroup,[],[Semigroup]]
[Lean.Json.setObjVal!,[Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Lean.Json.arr, Lean.Json, Lean.Json.obj, Std.RBNode.insert, Ord.compare, panicWithPosWithDecl, OfNat.ofNat],[Lean.Json]]
[forall_prop_of_true,[forall_const],[Iff]]
[Lean.Elab.Term.Do.mkDoSeq,[Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkNullNode, Array.map, List.nil],[Lean.Syntax]]
[Lean.JsonNumber.fromInt,[Lean.JsonNumber.mk, OfNat.ofNat],[Lean.JsonNumber]]
[Function.bijective.surjective,[And.right],[Function.surjective]]
[Lean.IR.ExplicitBoxing.getVarType,[Bind.bind, Lean.IR.ExplicitBoxing.getLocalContext, Unit.unit, Lean.IR.ExplicitBoxing.M, Lean.IR.IRType, Lean.IR.LocalContext.getType, Pure.pure, Lean.IR.IRType.object],[Lean.IR.ExplicitBoxing.M, Lean.IR.IRType]]
[Lean.Compiler.FFI.getCFlags,[HAppend.hAppend, List.toArray, List.cons, System.FilePath.toString, HDiv.hDiv, System.FilePath.mk, List.nil, String.splitOn, String.trim, Unit.unit],[Array, String]]
[Lean.Level.collectMVars,[Lean.Level.zero, Lean.Level.param, Lean.MVarIdSet, PProd.fst, PProd.snd, Std.RBTree.insert],[Lean.MVarIdSet]]
[Lean.Meta.mkPure,[Lean.Meta.mkAppOptM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Option.some, Option.none, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Name.isStr,[Lean.Name.anonymous, Lean.Name.num, Bool, Bool.true, Bool.false],[Bool]]
[Std.PersistentHashMap.Node.collision.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.PersistentHashMap.Node.collision, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.PersistentHashMap.Node.collision, And]]
[Lean.IR.FnBody.mdata.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.mdata, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.FnBody.mdata, And]]
[Lean.Elab.Tactic.setGoals,[modify, Lean.Elab.Tactic.State.mk],[Lean.Elab.Tactic.TacticM, Unit]]
[FloatArray.size,[Nat, Array.size],[Nat]]
[Lean.Syntax.below,[PUnit, PProd],[]]
[InvImage,[],[]]
[Lean.IR.UnreachableBranches.updateJPParamsAssignment,[Bind.bind, MonadReader.read, Nat.foldM, Lean.IR.UnreachableBranches.findVarValue, Lean.IR.Param.x, Lean.IR.UnreachableBranches.findArgValue, ite, Eq, BEq.beq, Bool.true, Pure.pure, modify, Lean.IR.UnreachableBranches.InterpState.mk, Array.modify, Lean.IR.UnreachableBranches.InterpState.assignments, Std.HashMap.insert, Lean.IR.UnreachableBranches.InterpState.funVals, Bool.false, Array.size],[Lean.IR.UnreachableBranches.M, Bool]]
[Lean.Server.FileWorker.handleReferences.applyIdMap,[Lean.Server.FileWorker.RefIdent.const, Lean.Server.FileWorker.RefIdent, Lean.Server.FileWorker.RefIdent.fvar, Std.HashMap.findD],[Lean.Server.FileWorker.RefIdent]]
[Lean.Server.WithRpcRef.val,[],[]]
[Prod.ext,[rfl, Eq.symm, Eq.refl],[Eq, Prod.mk, Prod.fst, Prod.snd]]
[Lean.Widget.instReprTaggedText,[Repr.mk],[Repr, Lean.Widget.TaggedText]]
[Lean.MonadHashMapCacheAdapter.findCached?,[Bind.bind, Lean.MonadHashMapCacheAdapter.getCache, Pure.pure, Std.HashMap.find?],[Option]]
[Lean.SMap.map₁,[],[Std.HashMap]]
[Lean.Parser.invalidLongestMatchParser,[Lean.Parser.ParserState.mkError],[Lean.Parser.ParserState]]
[Lean.Elab.Tactic.AuxMatchTermState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Tactic.AuxMatchTermState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.MessageData.instCoeListMessageDataMessageData,[Coe.mk, Lean.MessageData.ofList],[Coe, List, Lean.MessageData]]
[Lean.Elab.Term.withoutPending,[Bind.bind, MonadState.get, tryFinally, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState],[Lean.Elab.Term.TermElabM]]
[zero_lt_of_lt,[LT.lt, OfNat.ofNat, Nat.lt_trans, Nat.zero_lt_succ],[LT.lt, OfNat.ofNat]]
[MonadWithReaderOf.noConfusionType,[],[]]
[Lean.PrettyPrinter.Delaborator.instMonadQuotationDelabM,[Lean.MonadQuotation.mk, Pure.pure, arbitrary],[Lean.MonadQuotation, Lean.PrettyPrinter.Delaborator.DelabM]]
[Lean.IR.EmitC.Context.mainFn,[],[Lean.IR.FunId]]
[Lean.Meta.reduceBoolNativeUnsafe,[Lean.evalConstCheck, Bool, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Meta.MetaM, Bool]]
[Lean.IR.EmitC.toStringArgs,[List.map, Lean.IR.EmitC.argToCString, Array.toList],[List, String]]
[instToStringDecidable,[ToString.mk, String],[ToString, Decidable]]
[StateCpsT.instLawfulMonadStateCpsT.proof_1,[LawfulMonad.mk, rfl],[LawfulMonad, StateCpsT]]
[Lean.Parser.Term.doReturn.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkLineEq.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.casesRec,[Lean.Meta.saturate, Lean.Meta.withMVarContext, Bind.bind, Lean.MonadLCtx.getLCtx, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, ite, Eq, Bool.true, Lean.observing?, Lean.Meta.cases, Lean.LocalDecl.fvarId, List.toArray, List.nil, Pure.pure, List.map, Lean.Meta.InductionSubgoal.mvarId, Lean.Meta.CasesSubgoal.toInductionSubgoal, Array.toList, Option.isSome, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, Lean.Meta.MetaM, Option, List, Lean.MVarId, MProd.fst],[Lean.Meta.MetaM, List, Lean.MVarId]]
[Lean.Parser.nonReservedSymbolNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.nonReservedSymbolInfo, Lean.Parser.nonReservedSymbolFn],[Lean.Parser.Parser]]
[Lean.Meta.RecursorInfo.isMinor,[ite, LE.le, Lean.Meta.RecursorInfo.motivePos, Bool.false, Eq, and, Decidable.decide, Lean.Meta.RecursorInfo.firstIndexPos, Lean.Meta.RecursorInfo.majorPos, Bool.true],[Bool]]
[Lean.Parser.Tactic.guardProofTerm,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[MonadExceptOf.throw,[],[]]
[Lean.JsonRpc.ErrorCode.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Meta.tryClearMany,[Array.foldrM, Lean.Meta.tryClear, Array.size, OfNat.ofNat],[Lean.Meta.MetaM, Lean.MVarId]]
[congrArg,[rfl],[Eq]]
[Lean.mkConstructorValEx,[Lean.ConstructorVal.mk, Lean.ConstantVal.mk],[Lean.ConstructorVal]]
[Std.HashMap.insert.proof_2,[],[Std.HashMapImp.WellFormed, Prod.fst, Prod.mk]]
[Lean.Server.FileWorker.EditableDocument.mk.inj,[And.intro],[And, Eq]]
[Std.withShareCommon,[Std.MonadShareCommon.withShareCommon],[]]
[Lean.Parser.Tactic.abel1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.JsonRpc.ErrorCode.unknownErrorCode.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.JsonRpc.ErrorCode.unknownErrorCode, OfNat.ofNat]]
[Nat.repeat,[Nat.repeat.loop],[]]
[exists_prop_decidable,[dite, decidable_of_decidable_of_iff, exists_prop_decidable.proof_1, Decidable.isFalse, exists_prop_decidable.proof_2],[Decidable, Exists]]
[UInt64.lt,[LT.lt, UInt64.val],[]]
[Lean.HeadIndex.fvar.injEq,[Eq.propIntro, Eq.refl, Lean.HeadIndex.fvar, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.HeadIndex.fvar]]
[Lean.runMetaEval,[IO.FS.withIsolatedStreams, liftM, EIO.toBaseIO, Lean.MetaEval.eval, Bool.false],[IO, Prod, String, Except, IO.Error, Lean.Environment]]
[List.cons.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, List.cons, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.SynthInstance.instInhabitedSynthM,[Inhabited.mk, arbitrary],[Inhabited, Lean.Meta.SynthInstance.SynthM]]
[Array.getLit,[Array.get, Fin.mk, Array.getLit.proof_1],[]]
[Lean.Expr.etaExpandedStrict?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Expr, PProd.fst, PProd.snd, HAdd.hAdd, OfNat.ofNat, Lean.Expr.lam, ite, Eq, BEq.beq, Bool.true, Option.none, Lean.Expr.hasLooseBVars, Option.some],[Option, Lean.Expr]]
[Lean.AttributeImpl.mk.inj,[And.intro],[And, Eq]]
[instDecidableIff,[dite, Decidable.isTrue, instDecidableIff.proof_1, Decidable.isFalse, instDecidableIff.proof_2, instDecidableIff.proof_3, instDecidableIff.proof_4],[Decidable, Iff]]
[Lean.Export.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Export.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Export.State.mk, And]]
[Lean.Lsp.DocumentSymbolAux.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.DocumentSymbolAux.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.DocumentSymbolAux.mk, And]]
[Lean.Elab.Command.mkMessageAux,[Lean.Elab.mkMessageCore, Lean.Elab.Command.Context.fileName, Lean.Elab.Command.Context.fileMap, Option.getD, Lean.Syntax.getPos?, Bool.false, Lean.Elab.Command.Context.cmdPos],[Lean.Message]]
[Lean.Lsp.LeanFileProgressParams.noConfusionType,[],[]]
[Lean.Module.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Trie.matchPrefix,[Prod.mk, Option.none, Lean.Parser.Trie.matchPrefix.loop],[Prod, String.Pos, Option]]
[Lean.Widget.MsgEmbed.instFromJsonRpcEncodingPacket,[Lean.FromJson.mk, Except.orElseLazy, Except.bind, Lean.Json.parseTagged, OfNat.ofNat, Option.none, Bind.bind, Lean.FromJson.fromJson?, Array.getOp, Pure.pure, Except.error],[Lean.FromJson]]
[Lean.ReducibilityHints.getHeightEx,[Lean.ReducibilityHints.opaque, Lean.ReducibilityHints.abbrev, UInt32, OfNat.ofNat],[UInt32]]
[Lean.JsonNumber.mantissa,[],[Int]]
[lt_by_cases.proof_1,[le_antisymm, le_of_not_gt],[Eq]]
[Lean.Meta.SynthInstance.mkTableKeyFor,[Lean.Meta.withMCtx, Bind.bind, liftM, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Pure.pure, Lean.Meta.SynthInstance.mkTableKey],[Lean.Meta.SynthInstance.SynthM, Lean.Expr]]
[Lean.Parser.Term.binop,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.ppSpace, Lean.Parser.termParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[Lean.KVMap.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KVMap.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.mkAxiomValEx,[Lean.AxiomVal.mk, Lean.ConstantVal.mk],[Lean.AxiomVal]]
[Nat.eq_zero_of_gcd_eq_zero_left,[Eq, OfNat.ofNat, Nat.eq_zero_or_pos, absurd, Eq.symm, ne_of_lt, Nat.gcd_pos_of_pos_left],[Eq, OfNat.ofNat]]
[Function.comp_const,[rfl],[Eq, Function.comp, Function.const]]
[Lean.isOutParam,[Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat],[Bool]]
[Lean.Elab.Term.LValResolution.localRec.inj,[And.intro],[And, Eq]]
[Lean.Xml.parse,[Except, String, Lean.Xml.Element, Lean.Xml.Parser.document, String.mkIterator, Except.ok, Except.error, HAppend.hAppend, ToString.toString, Nat.repr, String.Iterator.i, String.Iterator.extract, String.Iterator.prevn, OfNat.ofNat],[Except, String, Lean.Xml.Element]]
[Lean.IR.Checker.CheckerContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Checker.CheckerContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Checker.CheckerContext.mk, And]]
[instOrdUInt16,[Ord.mk, compareOfLessAndEq],[Ord, UInt16]]
[String.dropRight,[Substring.toString, Substring.dropRight, String.toSubstring],[String]]
[Lean.Syntax.Traverser.idxs,[],[Array, Nat]]
[Lean.IR.UnreachableBranches.resetVarAssignment,[Bind.bind, MonadReader.read, modify, Lean.IR.UnreachableBranches.InterpState.mk, Array.modify, Lean.IR.UnreachableBranches.InterpState.assignments, Lean.IR.UnreachableBranches.InterpContext.currFnIdx, Std.HashMap.insert, Lean.IR.UnreachableBranches.Value.bot, Lean.IR.UnreachableBranches.InterpState.funVals],[Lean.IR.UnreachableBranches.M, Unit]]
[Mathlib.ExtendedBinder.«term∃ᵉ_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Mathlib.ExtendedBinder.extBinders, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[le_max_left,[dite, LT.lt, of_eq_true, Eq.trans, congrArg, LE.le, if_pos, eq_true, le_refl, Eq.mpr, if_neg, le_of_not_lt],[LE.le, max]]
[Lean.Elab.Command.Scope.opts,[],[Lean.Options]]
[Lean.Lsp.TextEdit.mk.inj,[And.intro],[And, Eq]]
[Lean.JsonRpc.Message.responseError.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.JsonRpc.Message.responseError, HAdd.hAdd, OfNat.ofNat]]
[Nat.ble_succ_eq_true,[Eq.refl, Bool.true, HEq.refl, Eq, Nat.ble, Nat.succ, rfl, PProd.fst],[Eq, Nat.ble, Nat.succ, Bool.true]]
[Lean.Macro.Context.ref,[],[Lean.Syntax]]
[Int.sign_zero,[rfl],[Eq, Int.sign, OfNat.ofNat]]
[CommSemiring.mul_comm,[],[Eq, HMul.hMul]]
[Lean.KeyedDeclsAttribute.mk.inj,[And.intro],[And, Eq]]
[Lean.Macro.Methods.expandMacro?,[],[Lean.MacroM, Option, Lean.Syntax]]
[Lean.Parser.ParserCategory.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserCategory.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.ParserCategory.mk, And]]
[Mathlib.Tactic.Lint.«command#lintMathlibAll+-*Only__»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[IO.FS.Metadata.type,[],[IO.FS.FileType]]
[Lean.Compiler.mkUIntTypeName,[Lean.Name.mkSimple, HAppend.hAppend, ToString.toString],[Lean.Name]]
[Lean.Elab.TerminationHints.noConfusionType,[],[]]
[Lean.Meta.Match.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.State.mk, And]]
[Lean.mkLevelMax',[ite, Eq, BEq.beq, Bool.true, Lean.Level.isZero, Lean.Level.getLevelOffset, GE.ge, Lean.Level.getOffset, Lean.mkLevelMax],[Lean.Level]]
[Lean.LocalDecl.fvarId,[Lean.FVarId],[Lean.FVarId]]
[Lean.Parser.Term.stateRefT.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.macroArg.formatter, Lean.Parser.Term.macroLastArg.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.JsonNumber.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonNumber.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.JsonNumber.mk, And]]
[Lean.PrettyPrinter.Formatter.parserOfStack.formatter,[Bind.bind, MonadState.get, Lean.PrettyPrinter.Formatter.formatterForKind, Lean.Syntax.getKind],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Tactic.mkInitialTacticInfo,[Bind.bind, Lean.MonadMCtx.getMCtx, Lean.Elab.Tactic.getUnsolvedGoals, Pure.pure, Lean.Elab.Tactic.mkTacticInfo],[Lean.Elab.Tactic.TacticM, Lean.Elab.Info]]
[USize.shiftLeft,[USize.mk, HShiftLeft.hShiftLeft, USize.val, USize.modn, System.Platform.numBits],[USize]]
[Lean.Export.instOfStateLevel,[Lean.Export.OfState.mk, Lean.Export.State.levels, Lean.Export.State.mk, Lean.Export.State.names, Lean.Export.State.exprs, Lean.Export.State.defs, Lean.Export.State.stk],[Lean.Export.OfState, Lean.Level]]
[ReaderT.failure,[Alternative.failure],[ReaderT]]
[Lean.HeadIndex.mvar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.HeadIndex.mvar, HAdd.hAdd, OfNat.ofNat]]
[iff_not_comm,[Decidable.iff_not_comm],[Iff, Not]]
[Lean.Elab.Term.synthesizeCoeInstMVarCore,[Bind.bind, Lean.MonadOptions.getOptions, Lean.Elab.Term.synthesizeInstMVarCore, Option.some, Lean.Option.get, Lean.Elab.Term.maxCoeSize],[Lean.Elab.Term.TermElabM, Bool]]
[not_and,[and_imp],[Iff, Not, And]]
[Lean.Exception.hasSyntheticSorry,[Lean.Exception.internal, Bool, Lean.MessageData.hasSyntheticSorry, Bool.false],[Bool]]
[ST.Ref.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, ST.Ref.mk, HAdd.hAdd, OfNat.ofNat]]
[false_iff,[propext, Iff.intro, Iff.mpr, False.elim],[Eq, Iff, False, Not]]
[Lean.Meta.Closure.MkValueTypeClosureResult.exprArgs,[],[Array, Lean.Expr]]
[Lean.PrettyPrinter.Delaborator.Pos,[Nat],[]]
[UInt16.lor,[UInt16.mk, Fin.lor, UInt16.val],[UInt16]]
[Lean.MetavarDecl.kind,[],[Lean.MetavarKind]]
[Lean.Elab.withMacroExpansionInfo,[Lean.Elab.withInfoContext],[]]
[Lean.IR.EmitC.emitApp,[ite, GT.gt, Array.size, Lean.closureMaxArgs, Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitArgs, Lean.IR.EmitC.emitLn, Lean.IR.EmitC.emitLhs],[Lean.IR.EmitC.M, Unit]]
[Lean.Server.Watchdog.GroupedEdits.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.Watchdog.GroupedEdits.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.Watchdog.GroupedEdits.mk, And]]
[Lean.Parser.Term.binop.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.ppSpace.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[List.set,[List, List.cons, PProd.fst, List.nil],[List]]
[Lean.SyntaxNode.withArgs,[Lean.unreachIsNodeMissing, Lean.unreachIsNodeAtom, Lean.unreachIsNodeIdent],[]]
[Lean.Parser.Term.sorry.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.modifyTraces,[Lean.MonadTrace.modifyTraceState, Lean.TraceState.mk, Lean.TraceState.enabled, Lean.TraceState.traces],[Unit]]
[Lean.Elab.Term.BinderView.type,[],[Lean.Syntax]]
[Lean.PrettyPrinter.Parenthesizer.State.trailPrec,[],[Option, Nat]]
[Lean.MessageLog.hasErrors,[Std.PersistentArray.any, Lean.MessageLog.msgs, Lean.MessageSeverity.information, Lean.MessageSeverity.warning, Unit.unit, Bool, Lean.Message.severity, Bool.true, Bool.false],[Bool]]
[Lean.Elab.Term.LetIdDeclView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.LetIdDeclView.mk, HAdd.hAdd, OfNat.ofNat]]
[List.length_nil,[rfl],[Eq, List.length, List.nil, OfNat.ofNat]]
[Lean.Parser.Term.attributes.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.Term.attrInstance.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Server.RequestError.instCoeErrorRequestError,[Coe.mk, Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.internalError, ToString.toString],[Coe, IO.Error, Lean.Server.RequestError]]
[UInt16.add,[UInt16.mk, HAdd.hAdd, UInt16.val],[UInt16]]
[LinearOrder.le_total,[],[Or, LE.le]]
[Lean.Lsp.instToJsonHoverParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.HoverParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position],[Lean.ToJson, Lean.Lsp.HoverParams]]
[Nat.le.intro,[Nat.le_add_right],[LE.le]]
[Lean.Parser.interpolatedStrFn,[ite, Eq, String.atEnd, Bool.true, Lean.Parser.ParserState.mkEOIError, List.nil, bne, Char.ofNat, Lean.Parser.ParserState.mkError, Lean.Parser.interpolatedStrFn.parse],[Lean.Parser.ParserFn]]
[Lean.Parser.Term.nomatch.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Function.injective.decidable_eq,[decidable_of_iff, Eq, Function.injective.eq_iff],[DecidableEq]]
[Lean.MessageData.ofFormat.injEq,[Eq.propIntro, Eq.refl, Lean.MessageData.ofFormat, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MessageData.ofFormat]]
[Lean.PrettyPrinter.Formatter.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Formatter.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PrettyPrinter.Formatter.State.mk, And]]
[Mathlib.Tactic.Ext.tacticSplitAnds,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.maxRecDepthErrorMessage,[],[String]]
[Lean.Elab.Term.Do.ToCodeBlock.withNewMutableVars,[MonadWithReader.withReader, ite, Eq, Bool.true, Lean.Elab.Term.Do.ToCodeBlock.Context.mk, Lean.Elab.Term.Do.ToCodeBlock.Context.ref, Lean.Elab.Term.Do.ToCodeBlock.Context.m, Lean.Elab.Term.Do.insertVars, Lean.Elab.Term.Do.ToCodeBlock.Context.mutableVars, Lean.Elab.Term.Do.ToCodeBlock.Context.insideFor],[Lean.Elab.Term.Do.ToCodeBlock.M]]
[Lean.Parser.Syntax.sepBy1.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.syntaxParser.parenthesizer, Lean.Parser.strLit.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.ToHide.State.hiddenInaccessible,[],[Lean.FVarIdSet]]
[Function.update_idem,[funext, Decidable.em, Eq, of_eq_true, Eq.trans, congr, congrArg, dite_congr, congrFun, eq_self, Eq.refl, Eq.symm, Eq.mpr_prop, dite_true, True.intro, eq_false, dite_false],[Eq, Function.update]]
[Lean.Elab.Term.StructInst.Field.isSimple,[Lean.Elab.Term.StructInst.Field.mk, List.nil, List.cons, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Elab.Term.expandLetEqnsDecl,[Bind.bind, Lean.Elab.Term.expandMatchAltsIntoMatch, Bool.false, Pure.pure, Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.getOp, OfNat.ofNat, Lean.mkAtomFrom, List.nil],[Lean.MacroM, Lean.Syntax]]
[Lean.Export.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Export.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.dynamicQuot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.PrettyPrinter.Parenthesizer.parserOfStack.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Command.inferMacroRulesAltKind,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, not, Lean.Syntax.isQuot, Bind.bind, Lean.Elab.throwUnsupportedSyntax, Pure.pure, PUnit.unit],[Lean.Elab.Command.CommandElabM, Lean.SyntaxNodeKind]]
[Nat.mul_div_cancel',[Eq.mp, Eq.refl, Eq, HAdd.hAdd, OfNat.ofNat, HMul.hMul, HDiv.hDiv, Nat.zero_add, HMod.hMod, Nat.mod_eq_zero_of_dvd],[Eq, HMul.hMul, HDiv.hDiv]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.hyps,[],[Array, Lean.Expr]]
[Lean.unreachIsNodeMissing.proof_1,[Eq.refl, Lean.Syntax.missing, HEq.refl, False],[False]]
[Mathlib.ExtendedBinder.«termSatisfiesBinderPred%__»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Tactic.ringNF,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.ringMode, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Meta.Match.Example.arrayLit.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.refl, SizeOf.sizeOf, List.nil, Eq.trans, HAdd.hAdd, Eq.symm, List.cons.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Meta.Match.Example.arrayLit, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.mkTokenAndFixPos,[Unit.unit, Lean.Parser.ParserState, Lean.Parser.ParserState.mkErrorAt, Option.none, ite, Eq, BEq.beq, Lean.Parser.ParserContext.forbiddenTk?, Option.some, Bool.true, Lean.Parser.ParserState.pushSyntax],[Lean.Parser.ParserFn]]
[IO.appDir,[Bind.bind, IO.appPath, Pure.pure, System.FilePath.parent, Option.none, IO, System.FilePath, IO.FS.realPath, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString],[IO, System.FilePath]]
[List.subset.trans,[],[Subset.subset]]
[Lean.Lsp.RpcConnectParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.RpcConnectParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.CtorFieldInfo.object.injEq,[Eq.propIntro, Eq.refl, Lean.IR.CtorFieldInfo.object, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.CtorFieldInfo.object]]
[Lean.Parser.Term.binrel_no_prop,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.ppSpace, Lean.Parser.termParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[Lean.Parser.Module.prelude.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Command.macroTailDefault.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter, Lean.Parser.darrow.formatter, Lean.Parser.Command.macroRhs.formatter, Lean.PrettyPrinter.Formatter.categoryParserOfStack.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Lean.IR.FnBody.dec.inj,[And.intro],[And, Eq]]
[UInt16.instSemiringUInt16.proof_5,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, congrFun, HMul.hMul, UInt16.zero_def, UInt16.mul_def, UInt16.mk, OfNat.ofNat, MonoidWithZero.zero_mul, UInt16.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt16],[Eq, HMul.hMul, OfNat.ofNat]]
[Nat.add_sub_cancel,[],[Eq, HSub.hSub, HAdd.hAdd]]
[Lean.InductiveType.noConfusionType,[],[]]
[Lean.Server.Watchdog.GroupedEdits.params,[],[Lean.Lsp.DidChangeTextDocumentParams]]
[forall_prop_decidable,[dite, decidableOfDecidableOfIff, forall_prop_decidable.proof_1, Decidable.isTrue, forall_prop_decidable.proof_2],[Decidable]]
[Int.ofNat_succ,[rfl],[Eq, Int.ofNat, Nat.succ, HAdd.hAdd, OfNat.ofNat]]
[Lean.interpolatedStrKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Lean.Expr.betaRev,[ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Lean.Expr, LT.lt, HAdd.hAdd, PProd.fst, PProd.snd, Lean.Expr.mkAppRevRange, Lean.Expr.instantiateRange],[Lean.Expr]]
[EmptyCollection.emptyCollection,[],[]]
[Lean.FVarId.mk.inj,[],[Eq]]
[Nat.coprime.gcd_eq_one,[id],[Eq, Nat.gcd, OfNat.ofNat]]
[Subtype.simps.coe,[Subtype.val],[]]
[Lean.IR.AltCore.ctor.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.AltCore.ctor, HAdd.hAdd, OfNat.ofNat]]
[Std.PersistentHashMap.root,[],[Std.PersistentHashMap.Node]]
[IO.Process.Output.stdout,[],[String]]
[Int.instCommRingInt.proof_6,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Int.ofNat, Nat.succ, HAdd.hAdd, Int.ofNat_succ, OfNat.ofNat, Int.distrib_right, Int.add_comm, Int.one_mul, rfl],[Eq, HMul.hMul, Int.ofNat, Nat.succ, HAdd.hAdd]]
[Lean.Level.max.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Level.max, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Match.InjectionAnyResult.subgoal.inj,[],[Eq]]
[Lean.JsonRpc.instFromJsonErrorCode,[Lean.FromJson.mk, Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.JsonNumber.mk, Int.ofNat, dite, Eq, Unit.unit, Eq.symm, Int.negSucc, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Except, String, Lean.JsonRpc.ErrorCode, Pure.pure, Lean.JsonRpc.ErrorCode.parseError, Lean.JsonRpc.ErrorCode.invalidRequest, Lean.JsonRpc.ErrorCode.methodNotFound, Lean.JsonRpc.ErrorCode.invalidParams, Lean.JsonRpc.ErrorCode.internalError, Lean.JsonRpc.ErrorCode.serverNotInitialized, Lean.JsonRpc.ErrorCode.unknownErrorCode, Lean.JsonRpc.ErrorCode.contentModified, Lean.JsonRpc.ErrorCode.requestCancelled, Lean.JsonRpc.ErrorCode.rpcNeedsReconnect, MonadExcept.throw],[Lean.FromJson, Lean.JsonRpc.ErrorCode]]
[Lean.scientificLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Tactic.DeclCache,[Prod, Tactic.Cache, Lean.Meta.MetaM],[]]
[Lean.Elab.MacroExpansionInfo.format,[Bind.bind, Lean.Elab.ContextInfo.ppSyntax, Lean.Elab.MacroExpansionInfo.lctx, Lean.Elab.MacroExpansionInfo.stx, Lean.Elab.MacroExpansionInfo.output, Pure.pure, HAppend.hAppend, Std.ToFormat.format],[IO, Std.Format]]
[Lean.Parser.Command.syntaxCat.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter, Lean.Parser.Command.catBehavior.formatter],[Lean.PrettyPrinter.Formatter]]
[instReprSubarray,[Repr.mk, HAppend.hAppend, repr, Subarray.toArray, Std.Format.text],[Repr, Subarray]]
[Lean.FVarIdSet,[Std.RBTree, Lean.FVarId, Lean.Name.quickCmp, Lean.FVarId.name],[]]
[Lean.Lsp.DiagnosticWith.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.DiagnosticWith.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.MetavarContext.noConfusionType,[],[]]
[Lean.Xml.Parser.DeclSep,[HOrElse.hOrElse, Lean.Xml.Parser.PEReference, SeqRight.seqRight, Lean.Xml.Parser.S, Pure.pure, Unit.unit],[Lean.Parsec, Unit]]
[Lean.Lsp.RpcKeepAliveParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.RpcKeepAliveParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.UniqueIds.checkDecl,[Lean.IR.UniqueIds.M, Bool, andM, Lean.IR.UniqueIds.checkParams, Lean.IR.UniqueIds.checkFnBody],[Lean.IR.UniqueIds.M, Bool]]
[Lean.Meta.GeneralizeIndicesSubgoal.noConfusionType,[],[]]
[iff_and_self,[Eq.mpr, Eq.refl, Iff, And, propext, and_comm, iff_self_and, Iff.rfl],[Iff, And]]
[Lean.Parser.many1NoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.many1Fn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[instHashableList,[Hashable.mk, List.foldl, mixHash, Hashable.hash, OfNat.ofNat],[Hashable, List]]
[Lean.Parser.Term.hole.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.ModuleParserState.recovering,[],[Bool]]
[Lean.MessageLog.isEmpty,[Std.PersistentArray.isEmpty, Lean.MessageLog.msgs],[Bool]]
[Prod.exists,[Iff.intro, Exists, Prod.mk, Exists.intro],[Iff, Exists, Prod.mk]]
[Lean.KVMap.instValueString,[Lean.KVMap.Value.mk, Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Option, String, Option.some, Option.none],[Lean.KVMap.Value, String]]
[Lean.Meta.Simp.mkCongrFun,[Unit.unit, Lean.Meta.MetaM, Lean.Meta.Simp.Result, Lean.Meta.Simp.Result.proof?, Pure.pure, Lean.Meta.Simp.Result.mk, Lean.mkApp, Lean.Meta.Simp.Result.expr, Option.none, Bind.bind, Lean.Meta.mkCongrFun, Option.some],[Lean.Meta.MetaM, Lean.Meta.Simp.Result]]
[if_ctx_congr_prop,[Iff, ite, absurd, Iff.mp, not_iff_not_of_iff, Iff.mpr],[Iff, ite]]
[decidableOfDecidableOfEq,[],[Decidable]]
[Lean.Parser.trailingLoopStep,[Lean.Parser.longestMatchFn, Option.some, HAppend.hAppend, Lean.Parser.PrattParsingTables.trailingParsers],[Lean.Parser.ParserFn]]
[Lean.Parser.Tactic.ring1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[FloatArray.forIn.loop.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self],[LE.le, FloatArray.size]]
[Lean.IR.FnBody.sset.inj,[And.intro],[And, Eq]]
[Lean.Meta.NormNum.isNat,[Eq, OfNat.ofNat],[]]
[Lean.Parser.Command.classInductive.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.group.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.Command.optDeclSig.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.many.formatter, Lean.Parser.Command.ctor.formatter, Lean.Parser.Command.optDeriving.formatter],[Lean.PrettyPrinter.Formatter]]
[Nat.lcm_self,[Eq, Nat.lcm, Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, OfNat.ofNat, Nat.lcm_zero_left, rfl],[Eq, Nat.lcm]]
[Lean.Parser.Tactic.revertTargetDeps,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Elab.Tactic.evalFailIfSuccess,[Bind.bind, MonadExcept.tryCatch, Lean.Elab.Tactic.evalTactic, Pure.pure, Bool.true, Bool.false, ite, Eq, Lean.throwError, Lean.ToMessageData.toMessageData, PUnit.unit],[Lean.Elab.Tactic.Tactic]]
[List.subset_cons_of_subset,[Or.inr],[Subset.subset, List.cons]]
[Lean.Elab.Term.StructInst.DefaultFields.Context.allStructNames,[],[Array, Lean.Name]]
[instSizeOfNat,[SizeOf.mk],[SizeOf, Nat]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.noConfusionType,[],[]]
[Lean.Meta.DiscrTree.instInhabitedDiscrTree,[Inhabited.mk, Lean.Meta.DiscrTree.mk],[Inhabited, Lean.Meta.DiscrTree]]
[Array.eraseIdx'.proof_1,[rfl],[Eq, Array.size]]
[Lean.DefinitionVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.DefinitionVal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.DefinitionVal.mk, And]]
[Lean.Server.instInhabitedDocumentMeta,[Inhabited.mk, Lean.Server.DocumentMeta.mk, arbitrary],[Inhabited, Lean.Server.DocumentMeta]]
[Lean.Meta.DiscrTree.instDecidableLt,[inferInstanceAs, Decidable, Eq, Lean.Meta.DiscrTree.Key.lt, Bool.true],[Decidable, LT.lt]]
[Lean.Lsp.TextDocumentItem.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.TextDocumentItem.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.ParserCompiler.CombinatorAttribute.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ParserCompiler.CombinatorAttribute.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ParserCompiler.CombinatorAttribute.mk, And]]
[Lean.Expr.ctorName,[String],[String]]
[Lean.Elab.Term.LValResolution.const.inj,[And.intro],[And, Eq]]
[Function.involutive.eq_iff,[Function.injective.eq_iff', Function.involutive.injective],[Iff, Eq]]
[Lean.Parser.Term.doLetArrow.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.doIdDecl.parenthesizer, Lean.Parser.Term.doPatDecl.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.UnificationHint.constraints,[],[List, Lean.Meta.UnificationConstraint]]
[Lean.Parser.Tactic.unfoldWf,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[instCoeStringError,[Coe.mk, IO.userError],[Coe, String, IO.Error]]
[Lean.Parser.Tactic.rwRule,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[Lean.Meta.Match.MatcherInfo.numParams,[],[Nat]]
[Lean.Elab.Command.getScopes,[Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Command.State.scopes],[Lean.Elab.Command.CommandElabM, List, Lean.Elab.Command.Scope]]
[Lean.ExternEntry.foreign.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ExternEntry.foreign, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ExternEntry.foreign, And]]
[Lean.MessageDataContext.mctx,[],[Lean.MetavarContext]]
[Lean.bignumToJson,[Lean.Json.str, ToString.toString],[Lean.Json]]
[Lean.Elab.MacroExpansionInfo.stx,[],[Lean.Syntax]]
[Lean.QuotKind.toCtorIdx,[OfNat.ofNat],[Nat]]
[Nat.gcd_zero_right,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, Nat.gcd, Nat.zero_eq, OfNat.ofNat, Nat.gcd_zero_left, eq_true_of_decide, Eq.refl, Bool.true, Eq.symm, Nat.gcd_succ, Nat.zero_mod, Nat.succ, eq_self],[Eq, Nat.gcd, OfNat.ofNat]]
[instToStringUSize,[ToString.mk, ToString.toString, USize.toNat],[ToString, USize]]
[Lean.Expr.FoldConstsImpl.State.noConfusionType,[],[]]
[Lean.Elab.Term.StructInst.Field.toSyntax,[List.nil, Lean.Syntax, Lean.Elab.Term.StructInst.Field.lhs, Lean.Syntax.setArg, OfNat.ofNat, Lean.mkNullNode, List.toArray, List.cons, Lean.Elab.Term.StructInst.FieldLHS.toSyntax, Bool.true, Array.map, Bool.false, panicWithPosWithDecl],[Lean.Syntax]]
[Std.PersistentArray.tailOff,[],[Nat]]
[Std.PersistentHashMap.Stats.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.PersistentHashMap.Stats.mk, HAdd.hAdd, OfNat.ofNat]]
[Mod.noConfusionType,[],[]]
[Lean.Core.State.ngen,[],[Lean.NameGenerator]]
[Std.RBNode.node.inj,[And.intro],[And, Eq, HEq]]
[Lean.Meta.mkEqSymm,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.eq?, Lean.Meta.getLevel, Lean.mkApp4, Lean.mkConst, List.cons, List.nil, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Elab.Info.docString?,[Bind.bind, Lean.MonadEnv.getEnv, Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.Info.ofCompletionInfo, Lean.Meta.MetaM, Option, String, Option.none, Lean.Expr.constName?, Lean.Elab.TermInfo.expr, liftM, Lean.findDocString?, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Option, String]]
[Lean.instInhabitedSourceInfo,[Inhabited.mk, Lean.SourceInfo.none],[Inhabited, Lean.SourceInfo]]
[List.span,[List.spanAux, List.nil],[Prod, List]]
[autoParam,[],[]]
[Lean.IR.Expr.box.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.box, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Expr.box, And]]
[Std.HashMap.isEmpty,[Decidable.decide, Eq, Std.HashMap.size, OfNat.ofNat],[Bool]]
[Lean.Elab.Level.mkFreshLevelMVar,[Bind.bind, Lean.mkFreshMVarId, modify, Lean.Elab.Level.State.mk, Lean.Elab.Level.State.ngen, Lean.MetavarContext.addLevelMVarDecl, Lean.Elab.Level.State.mctx, Lean.Elab.Level.State.levelNames, Pure.pure, Lean.mkLevelMVar],[Lean.Elab.Level.LevelElabM, Lean.Level]]
[AddMonoid.zero_add,[],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Equiv.apply_symm_apply,[Equiv.rightInv],[Eq, Equiv.toFun, Equiv.symm]]
[Lean.IR.Decl.name,[Lean.IR.FunId],[Lean.IR.FunId]]
[Lean.Parser.Term.have.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.haveDecl.parenthesizer, Lean.Parser.Term.optSemicolon.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Tactic.evalAnyGoals,[Bind.bind, Lean.Elab.Tactic.getGoals, ForIn.forIn, MProd.mk, liftM, Lean.Meta.isExprMVarAssigned, ite, Eq, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Elab.Tactic.setGoals, List.cons, List.nil, MonadExcept.tryCatch, Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.getUnsolvedGoals, Lean.Elab.Tactic.TacticM, ForInStep, MProd, Bool, Array, Lean.MVarId, MProd.fst, Unit, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Elab.Tactic.Tactic]]
[instLEUInt64,[LE.mk, UInt64.le],[LE, UInt64]]
[UInt64.instAddCommSemigroupUInt64,[AddCommSemigroup.mk, UInt64.instAddCommSemigroupUInt64.proof_1],[AddCommSemigroup, UInt64]]
[instLTOption,[LT.mk, Option.lt, LT.lt],[LT, Option]]
[Int.instLEInt,[LE.mk, Int.le],[LE, Int]]
[List.equiv_iff_subset_and_subset,[Iff.intro, And.intro, Iff.mp, Iff.mpr, Iff, Mem.mem],[Iff, List.equiv, And, Subset.subset]]
[instLTUSize,[LT.mk, USize.lt],[LT, USize]]
[Lean.Elab.ContextInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.ContextInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.str,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.strLit],[Lean.Parser.Parser]]
[AddSemigroup.add_assoc,[],[Eq, HAdd.hAdd]]
[UInt16.decLe,[Decidable, LE.le, inferInstanceAs],[Decidable, LE.le]]
[Lean.MetavarContext.findLocalDeclDependsOn,[Bool, Lean.MetavarContext.findExprDependsOn, StateT.run', orM, Lean.MetavarContext.DependsOn.main, EmptyCollection.emptyCollection],[Bool]]
[UInt32.instSemiringUInt32.proof_12,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HMul.hMul, UInt32.add_def, UInt32.mul_def, UInt32.mk, HAdd.hAdd, UInt32.val, UInt32.eq_of_val_eq, Semiring.add_mul],[Eq, HMul.hMul, HAdd.hAdd]]
[Lean.Parser.Tactic.tacticLet'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Elab.Term.expandDbgTrace,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.interpolatedStrKind, Bool.true, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom],[Lean.Macro]]
[Lean.Server.registerRpcCallHandler,[Bind.bind, liftM, IO.initializing, ite, Eq, not, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Pure.pure, PUnit.unit],[IO, Unit]]
[Function.injective.of_comp,[],[Function.injective]]
[Lean.Elab.Deriving.Header.binders,[],[Array, Lean.Syntax]]
[Lean.Server.FileWorker.unfoldCmdSnaps,[ite, Eq, and, Lean.MessageLog.hasErrors, Lean.Server.Snapshots.Snapshot.msgLog, Bool.true, Pure.pure, IO.AsyncList.nil, Bind.bind, MonadReader.read, liftM, IO.AsyncList.unfoldAsync, Lean.Server.FileWorker.CancelToken.check, Lean.Server.Snapshots.Snapshot.isAtEnd, Lean.Server.publishDiagnostics, Std.PersistentArray.toArray, Lean.Server.Snapshots.Snapshot.diagnostics, Lean.Server.publishProgressDone, MonadExcept.throw, Lean.Server.FileWorker.ElabTaskError.eof, PUnit.unit],[ReaderT, Lean.Server.FileWorker.WorkerContext, IO, IO.AsyncList, Lean.Server.FileWorker.ElabTaskError, Lean.Server.Snapshots.Snapshot]]
[UInt16.mul,[UInt16.mk, HMul.hMul, UInt16.val],[UInt16]]
[Lean.Meta.Closure.pushFVarArg,[modify, Lean.Meta.Closure.State.mk, Lean.Meta.Closure.State.visitedLevel, Lean.Meta.Closure.State.visitedExpr, Lean.Meta.Closure.State.levelParams, Lean.Meta.Closure.State.nextLevelIdx, Lean.Meta.Closure.State.levelArgs, Lean.Meta.Closure.State.newLocalDecls, Lean.Meta.Closure.State.newLocalDeclsForMVars, Lean.Meta.Closure.State.newLetDecls, Lean.Meta.Closure.State.nextExprIdx, Lean.Meta.Closure.State.exprMVarArgs, Array.push, Lean.Meta.Closure.State.exprFVarArgs, Lean.Meta.Closure.State.toProcess],[Lean.Meta.Closure.ClosureM, Unit]]
[Lean.Elab.Info.ofTacticInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Info.ofTacticInfo, HAdd.hAdd, OfNat.ofNat]]
[false_implies_iff,[Iff.intro, trivial, False.elim],[Iff, True]]
[Function.involutive.injective,[Function.left_inverse.injective, Function.involutive.left_inverse],[Function.injective]]
[Lean.ImportState.moduleData,[],[Array, Lean.ModuleData]]
[Lean.Parser.Tactic.exactModCast,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[instInhabitedDepArrow,[Inhabited.mk, arbitrary],[Inhabited]]
[IO.Process.Child.stdin,[],[IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdin]]
[Char.isValidCharNat,[Or, LT.lt, OfNat.ofNat, And],[]]
[«term_%_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Std.PersistentArray.stats,[Std.PersistentArray.collectStats, Std.PersistentArray.root, Std.PersistentArray.Stats.mk, OfNat.ofNat, Array.size, Std.PersistentArray.tail],[Std.PersistentArray.Stats]]
[Lean.LBool.and,[Lean.LBool.false, Lean.LBool.undef, Lean.LBool],[Lean.LBool]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.forceRegularApp,[],[Bool]]
[Lean.KeyedDeclsAttribute.ExtensionState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KeyedDeclsAttribute.ExtensionState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KeyedDeclsAttribute.ExtensionState.mk, And]]
[Lean.LocalInstance.noConfusionType,[],[]]
[Lean.PrettyPrinter.Delaborator.getUnusedName.bodyUsesSuggestion,[Option.isSome, Lean.Expr.find?, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Unit.unit, Lean.LocalContext.find?, Bool.false, BEq.beq, Lean.LocalDecl.userName],[Bool]]
[Int.sign,[Unit.unit, Int, OfNat.ofNat, Neg.neg],[Int]]
[Lean.Meta.DecLevelContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.DecLevelContext.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.decimalNumberFn.parseOptDot,[ite, Eq, BEq.beq, Char.ofNat, Bool.true, Char.isDigit, Lean.Parser.takeWhileFn, Lean.Parser.ParserState.setPos],[Lean.Parser.ParserState]]
[mul_left_inv,[Group.mul_left_inv],[Eq, HMul.hMul, Inv.inv, OfNat.ofNat]]
[Lean.Elab.Term.ToDepElimPattern.State.newLocals,[],[Lean.FVarIdSet]]
[UInt64.val,[],[Fin, UInt64.size]]
[String.Iterator.nextn,[String.Iterator, PProd.fst, String.Iterator.next],[String.Iterator]]
[Lean.Elab.Tactic.State.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Tactic.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Tactic.State.mk]]
[Lean.IR.UnreachableBranches.Value.choice.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.refl, SizeOf.sizeOf, List.nil, Eq.trans, HAdd.hAdd, Eq.symm, List.cons.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.IR.UnreachableBranches.Value.choice, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Tactic.instInhabitedState,[Inhabited.mk, Lean.Elab.Tactic.State.mk, arbitrary],[Inhabited, Lean.Elab.Tactic.State]]
[Lean.ParserCompiler.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ParserCompiler.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ParserCompiler.Context.mk, And]]
[Lean.Server.FileWorker.ElabTaskError.ioError.injEq,[Eq.propIntro, Eq.refl, Lean.Server.FileWorker.ElabTaskError.ioError, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.FileWorker.ElabTaskError.ioError]]
[List.singleton_append,[rfl],[Eq, HAppend.hAppend, List.cons, List.nil]]
[Lean.Parser.takeWhileFn,[Lean.Parser.takeUntilFn, not],[Lean.Parser.ParserFn]]
[UInt16.toUInt32,[Nat.toUInt32, UInt16.toNat],[UInt32]]
[Lean.Meta.Simp.Result.noConfusionType,[],[]]
[Lean.Parser.LeadingIdentBehavior.symbol.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Parser.LeadingIdentBehavior.symbol, OfNat.ofNat]]
[instNonempty,[instNonempty.proof_1],[Nonempty]]
[Lean.Meta.CaseValuesSubgoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.CaseValuesSubgoal.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.all,[not, Nat.any],[Bool]]
[Lean.IR.CtorFieldInfo.usize.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.CtorFieldInfo.usize, HAdd.hAdd, OfNat.ofNat]]
[StateCpsT.runK_pure,[rfl],[Eq, StateCpsT.runK, Pure.pure]]
[Lean.IR.FnBody.dec.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.dec, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.FnBody.dec, And]]
[Lean.Elab.Term.TermElabM,[ReaderT, Lean.Elab.Term.Context, StateRefT', IO.RealWorld, Lean.Elab.Term.State, Lean.Meta.MetaM],[]]
[HEq.rfl,[HEq.rfl.proof_1],[HEq]]
[Int.subNatNat_of_lt,[Eq.mpr, Eq.refl, Eq, Int.subNatNat, Int.negSucc, Nat.pred, HSub.hSub, Int.subNatNat_of_sub_eq_succ, Nat.succ, Nat.succ_pred_eq_of_pos, Nat.sub_pos_of_lt, rfl],[Eq, Int.subNatNat, Int.negSucc, Nat.pred, HSub.hSub]]
[Function.surjective_to_subsingleton,[Exists, Eq, Exists.intro, Subsingleton.elim],[Function.surjective]]
[Substring.atEnd,[Bool, BEq.beq, HAdd.hAdd],[Bool]]
[Lean.Elab.Term.LetIdDeclView.type,[],[Lean.Syntax]]
[Lean.Parser.registerBuiltinParserAttribute,[Bind.bind, ST.Ref.get, Lean.Parser.builtinParserCategoriesRef, IO.ofExcept, ite, Eq, Std.PersistentHashMap.contains, Bool.true, MonadExcept.throw, HAppend.hAppend, ToString.toString, Pure.pure, Std.PersistentHashMap.insert, Lean.Parser.ParserCategory.mk, Lean.Parser.PrattParsingTables.mk, ST.Ref.set, Lean.registerBuiltinAttribute, Lean.AttributeImpl.mk, Lean.AttributeImplCore.mk, Lean.AttributeApplicationTime.afterCompilation, liftM, Lean.Attribute.Builtin.getPrio, BEq.beq, Lean.AttributeKind.global, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData],[IO, Unit]]
[Lean.Elab.Term.FunBinders.State.fvars,[],[Array, Lean.Expr]]
[Lean.Meta.DiscrTree.Key.star.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.DiscrTree.Key.star, OfNat.ofNat]]
[Function.comp_left,[],[]]
[Lean.Elab.Frontend.Context.noConfusionType,[],[]]
[Lean.Lsp.TextDocumentSyncOptions.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.TextDocumentSyncOptions.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.TextDocumentSyncOptions.mk, And]]
[Nat.coprime.mul_dvd_of_dvd_of_dvd,[Dvd.dvd, HMul.hMul, Nat.mul_dvd_mul_left, Nat.coprime.dvd_of_dvd_mul_left, Nat.coprime.symm, Eq.symm],[Dvd.dvd, HMul.hMul]]
[Lean.Meta.InstanceEntry.mk.inj,[And.intro],[And, Eq]]
[dbgTrace,[Unit.unit],[]]
[Lean.Meta.Match.Pattern.inaccessible.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Pattern.inaccessible, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.Pattern.inaccessible]]
[Lean.MetavarDecl.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MetavarDecl.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.StructInst.Source.implicit.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.StructInst.Source.implicit, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.StructInst.Source.implicit]]
[instHAndThen,[HAndThen.mk, AndThen.andThen],[HAndThen]]
[Lean.Parser.PrattParsingTables.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.PrattParsingTables.mk, HAdd.hAdd, OfNat.ofNat]]
[List.forM,[Unit.unit, PUnit, Pure.pure, PUnit.unit, Bind.bind, PProd.fst],[PUnit]]
[Lean.PrettyPrinter.Parenthesizer.ParenthesizerAliasValue,[Lean.Parser.AliasValue, Lean.PrettyPrinter.Parenthesizer],[]]
[Lean.Compiler.CSimp.Entry.mk.inj,[And.intro],[And, Eq]]
[Nat.add_le_add_iff_le_right,[Iff.intro, Nat.le_of_add_le_add_right, Nat.add_le_add_right],[Iff, LE.le, HAdd.hAdd]]
[StateRefT'.run,[Bind.bind, ST.mkRef, ST.Ref.get, Pure.pure, Prod.mk],[Prod]]
[Lean.Parser.Term.letPatDecl.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.pushNone.formatter, Lean.Parser.Term.optType.formatter, Lean.Parser.symbol.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.isType,[Bind.bind, Lean.Meta.isTypeQuick, Unit.unit, Lean.Meta.MetaM, Bool, Pure.pure, Bool.true, Bool.false, Lean.Meta.inferType, Lean.Meta.whnfD, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj],[Lean.Meta.MetaM, Bool]]
[Lean.Lsp.Ipc.waitForExit,[Bind.bind, MonadReader.read, liftM, IO.Process.Child.wait],[Lean.Lsp.Ipc.IpcM, UInt32]]
[Nat.add_lt_add_left,[Nat.lt_of_succ_le, Nat.add_le_add_left, Nat.succ_le_of_lt, Nat.add_succ],[LT.lt, HAdd.hAdd]]
[Lean.Parser.Command.macroRhs,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HOrElse.hOrElse, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.withPosition, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Std.HashSetImp.foldBuckets,[Id.run, Std.HashSetImp.foldBucketsM],[]]
[Nat.dvd_mul_right,[Exists.intro, rfl],[Dvd.dvd, HMul.hMul]]
[Lean.instInhabitedAttributeImplCore,[Inhabited.mk, Lean.AttributeImplCore.mk, arbitrary],[Inhabited, Lean.AttributeImplCore]]
[Lean.Macro.throwError,[Bind.bind, Lean.MonadRef.getRef, MonadExcept.throw, Lean.Macro.Exception.error],[Lean.MacroM]]
[instAddCommGroup.proof_4,[Semiring.nsmul_succ'],[Eq, Semiring.nsmul, Nat.succ, HAdd.hAdd]]
[Lean.Compiler.binFoldFns,[HAppend.hAppend, Lean.Compiler.boolFoldFns, Lean.Compiler.uintBinFoldFns, Lean.Compiler.natFoldFns],[List, Prod, Lean.Name, Lean.Compiler.BinFoldFn]]
[Lean.Meta.NormNum.instLawfulOfNat,[Lean.Meta.NormNum.instLawfulOfNat.proof_1],[Lean.Meta.NormNum.LawfulOfNat]]
[Lean.idEndEscape,[Char.ofNat],[Char]]
[Lean.Meta.SynthInstance.getNextToResume,[Bind.bind, MonadState.get, modify, Lean.Meta.SynthInstance.State.mk, Lean.Meta.SynthInstance.State.result?, Lean.Meta.SynthInstance.State.generatorStack, Array.pop, Lean.Meta.SynthInstance.State.resumeStack, Lean.Meta.SynthInstance.State.tableEntries, Pure.pure],[Lean.Meta.SynthInstance.SynthM, Prod, Lean.Meta.SynthInstance.ConsumerNode, Lean.Meta.SynthInstance.Answer]]
[LawfulApplicative.seq_assoc,[],[Eq, Seq.seq, Functor.map, Function.comp]]
[Lean.Expr.app2?,[ite, Eq, Lean.Expr.isAppOfArity, OfNat.ofNat, Bool.true, Option.some, Prod.mk, Lean.Expr.appArg!, Lean.Expr.appFn!, Option.none],[Option, Prod, Lean.Expr]]
[Lean.MetavarContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MetavarContext.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.isIOUnitBuiltinInitFn,[Lean.isIOUnitInitFnCore, Lean.builtinInitAttr],[Bool]]
[HXor.hXor,[],[]]
[GE.ge,[LE.le],[]]
[Lean.Elab.Command.State.traceState,[],[Lean.TraceState]]
[Lean.Lsp.WaitForDiagnosticsParams.mk.inj,[And.intro],[And, Eq]]
[Lean.EnvExtensionState,[PointedType.type, Lean.EnvExtensionStateSpec],[]]
[Semiring.npow,[],[]]
[Lean.Elab.Term.Do.getDoReassignVars,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, List.toArray, List.cons, Lean.Elab.Term.Do.getLetIdDeclVar, List.nil, Lean.Elab.Term.Do.getLetPatDeclVars, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.TermElabM, Array, Lean.Name]]
[Lean.SMap.foldStage2,[Std.PersistentHashMap.foldl, Lean.SMap.map₂],[]]
[Lean.withoutModifyingEnv,[Bind.bind, Lean.MonadEnv.getEnv, tryFinally, Lean.setEnv],[]]
[Lean.Meta.IndPredBelow.mkBrecOnDecl.mkIH,[Bind.bind, Lean.Meta.instantiateForall, Prod.snd, liftM, Pure.pure, Prod.mk],[Lean.Meta.MetaM, Prod, Lean.Name, Lean.Expr]]
[instTransEq.proof_1,[Eq.symm],[]]
[Substring.isEmpty,[BEq.beq, Substring.bsize, OfNat.ofNat],[Bool]]
[Lean.LocalContext.isSubPrefixOf,[Lean.LocalContext.isSubPrefixOfAux, Lean.LocalContext.decls, OfNat.ofNat],[Bool]]
[Lean.formatKVMap,[Std.Format.sbracket, Std.Format.joinSep, Lean.KVMap.entries, Std.Format.text],[Std.Format]]
[Lean.Elab.DefKind.toCtorIdx,[OfNat.ofNat],[Nat]]
[instHModUSizeNatUSize,[HMod.mk, USize.modn],[HMod, USize, Nat]]
[Nat.div_lt_iff_lt_mul,[Eq.mpr, Eq.refl, Iff, LT.lt, HDiv.hDiv, HMul.hMul, Eq.symm, propext, not_le, Not, LE.le, not_congr, Nat.le_div_iff_mul_le],[Iff, LT.lt, HDiv.hDiv, HMul.hMul]]
[Function.surj_inv_eq,[Classical.choose_spec],[Eq, Function.surj_inv]]
[Lean.Elab.Deriving.Header.targetType,[],[Lean.Syntax]]
[Lean.Core.Context.noConfusionType,[],[]]
[Lean.Elab.Command.Ctor2InferMod,[Std.HashMap, Lean.Name, Bool],[]]
[Lean.Parser.Tactic.dUnfold,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Meta.rewrite,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.MetaM, Lean.Meta.RewriteResult, Unit.unit, Lean.Expr.iff?, Lean.Meta.mkEq],[Lean.Meta.MetaM, Lean.Meta.RewriteResult]]
[Lean.Lsp.instFileSourceReferenceParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.ReferenceParams.toTextDocumentPositionParams],[Lean.Lsp.FileSource, Lean.Lsp.ReferenceParams]]
[Lean.isIdEndEscape,[Decidable.decide, Eq, Lean.idEndEscape],[Bool]]
[Lean.Environment.moduleIdxForModule?,[Option.map, Fin.val, Array.indexOf?, Lean.Environment.allImportedModuleNames],[Option, Lean.ModuleIdx]]
[Lean.instInhabitedExternAttrData,[Inhabited.mk, Lean.ExternAttrData.mk, arbitrary],[Inhabited, Lean.ExternAttrData]]
[Lean.PersistentEnvExtensionDescr.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.measurability!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Declaration.axiomDecl.inj,[],[Eq]]
[Lean.JsonRpc.Message.noConfusionType,[],[]]
[Lean.Elab.DefKind.isDefOrAbbrevOrOpaque,[Unit.unit, Lean.Elab.DefKind.theorem, Lean.Elab.DefKind.example, Bool, Bool.true, Bool.false],[Bool]]
[inferInstance,[],[]]
[Lean.Elab.Tactic.Conv.evalConvSeq,[Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Elab.Tactic.Tactic]]
[Lean.Expr.mdata.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.mdata, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Expr.mdata, And]]
[Lean.Elab.Term.Do.Code.jmp.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Code.jmp, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.Code.jmp, And]]
[Lean.Parser.Command.init_quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Server.FileWorker.WorkerContext.hIn,[],[IO.FS.Stream]]
[Lean.Expr.setPPUniverses,[Lean.Expr.setOption, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Expr]]
[Lean.KVMap.mk.injEq,[Eq.propIntro, Eq.refl, Lean.KVMap.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KVMap.mk]]
[Lean.Parser.addTrailingParser,[Unit.unit, Except, String, Lean.Parser.ParserCategories, Lean.Parser.getCategory, Lean.Parser.throwUnknownParserCategory, Pure.pure, Std.PersistentHashMap.insert, Lean.Parser.ParserCategory.mk, Lean.Parser.FirstTokens.epsilon, Lean.Parser.FirstTokens.unknown, Lean.Parser.PrattParsingTables, Lean.Parser.ParserInfo.firstTokens, Lean.Parser.Parser.info, Lean.Parser.PrattParsingTables.mk, Lean.Parser.PrattParsingTables.leadingTable, Lean.Parser.PrattParsingTables.leadingParsers, Lean.Parser.PrattParsingTables.trailingTable, List.cons, Prod.mk, Lean.Parser.PrattParsingTables.trailingParsers, Lean.Parser.ParserCategory.tables, Lean.Parser.ParserCategory.behavior],[Except, String, Lean.Parser.ParserCategories]]
[Lean.Meta.TransparencyMode.instHashableTransparencyMode,[Hashable.mk, Lean.Meta.TransparencyMode.hash],[Hashable, Lean.Meta.TransparencyMode]]
[Lean.Parser.dbgTraceState,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.dbgTraceStateFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.Expr.hasAnyFVar.visit,[ite, Eq, not, Lean.Expr.hasFVar, Bool.true, Bool.false, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lit, Bool, or, PProd.fst, PProd.snd],[Bool]]
[ToBool.toBool,[],[Bool]]
[CoeT.coe,[],[]]
[Trans.noConfusionType,[],[]]
[Lean.Expr.isConstOf,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, BEq.beq, Bool.false],[Bool]]
[Lean.Compiler.SpecializeAttributeKind.nospecialize.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Compiler.SpecializeAttributeKind.nospecialize, OfNat.ofNat]]
[Substring.startPos,[],[String.Pos]]
[Lean.Exception.error.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Exception.error, HAdd.hAdd, OfNat.ofNat]]
[IO.Process.Stdio.inherit.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.Process.Stdio.inherit, OfNat.ofNat]]
[Lean.Lsp.instToJsonPlainTermGoalParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.PlainTermGoalParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position],[Lean.ToJson, Lean.Lsp.PlainTermGoalParams]]
[Lean.Elab.Term.Do.ToCodeBlock.Catch.mk.inj,[And.intro],[And, Eq]]
[Lean.PrettyPrinter.Delaborator.State.holeIter,[],[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator]]
[Lean.IR.EmitC.emitReset,[Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn, Nat.forM, Lean.IR.EmitC.emitLhs],[Lean.IR.EmitC.M, Unit]]
[List.card_map_eq_of_inj_on,[of_eq_true, Eq.trans, implies_congr, Eq.refl, List.inj_on, List.nil, congr, congrArg, Eq, List.card, List.map_nil, List.card_nil, eq_true_of_decide, Bool.true, implies_true, Decidable.em, Mem.mem, List.map, List.exists_of_mem_map, Eq.symm],[Eq, List.card, List.map]]
[right_cancelative,[Eq],[]]
[Lean.Widget.InteractiveGoal.userName?,[],[Option, String]]
[Char.utf8Size,[ite, LE.le, UInt32.ofNatCore, OfNat.ofNat, Char.utf8Size.proof_1, Char.utf8Size.proof_2, Char.utf8Size.proof_3, Char.utf8Size.proof_4, Char.utf8Size.proof_5, Char.utf8Size.proof_6, Char.utf8Size.proof_7],[UInt32]]
[Lean.EnvironmentHeader.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.depArrow.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.bracketedBinder.formatter, Lean.Parser.unicodeSymbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Tactic.ElabSimpArgsResult.mk.inj,[And.intro],[And, Eq]]
[Nat.find,[Subtype.val, Nat.find_x],[Nat]]
[IO.Error.permissionDenied.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.permissionDenied, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.private.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.DocumentHighlight.range,[],[Lean.Lsp.Range]]
[Lean.Meta.Closure.ToProcessElement.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Closure.ToProcessElement.mk, HAdd.hAdd, OfNat.ofNat]]
[InvImage.accessible.proof_1,[Acc.intro, rfl],[Acc, InvImage]]
[Lean.Parser.Term.doLetRec.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.group.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.Term.letRecDecls.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.SCC.Data.mk.inj,[And.intro],[And, Eq]]
[Fin.land,[Fin, Fin.mk, HMod.hMod, Nat.land, Fin.land.proof_1],[Fin]]
[Lean.Parser.Command.print.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.ident.formatter, Lean.Parser.strLit.formatter],[Lean.PrettyPrinter.Formatter]]
[«term_≈_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[UInt8.instSemiringUInt8.proof_7,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt8.one_def, UInt8.mul_def, UInt8.mk, OfNat.ofNat, one_mul, UInt8.val, UInt8.mk_val_eq, eq_self, propext, forall_const, UInt8],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Parser.nonReservedSymbol,[Lean.Parser.tokenWithAntiquot, Lean.Parser.nonReservedSymbolNoAntiquot],[Lean.Parser.Parser]]
[Tactic.Ring.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Tactic.Ring.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Std.RBMap.foldM,[Std.RBNode.foldM],[]]
[Lean.Meta.SynthInstance.ConsumerNode.mk.inj,[And.intro],[And, Eq]]
[Lean.KVMap.insertCore,[List, Prod, Lean.Name, Lean.DataValue, List.cons, Prod.mk, List.nil, ite, Eq, BEq.beq, Bool.true, PProd.fst],[List, Prod, Lean.Name, Lean.DataValue]]
[Lean.JsonRpc.instFromJsonRequestID,[Lean.FromJson.mk, Lean.Json.null, Lean.Json.bool, Lean.Json.arr, Lean.Json.obj, Except, String, Lean.JsonRpc.RequestID, Pure.pure, Lean.JsonRpc.RequestID.str, Lean.JsonRpc.RequestID.num, MonadExcept.throw],[Lean.FromJson, Lean.JsonRpc.RequestID]]
[instShiftRightUInt8,[ShiftRight.mk, UInt8.shiftRight],[ShiftRight, UInt8]]
[Lean.Parser.Syntax.cat.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.Parser.optPrecedence.formatter],[Lean.PrettyPrinter.Formatter]]
[ExceptT.seqRight_eq,[],[Eq, SeqRight.seqRight, Seq.seq, Functor.map, Function.const, id]]
[Lean.Parser.Term.generalizingParam.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.trueVal.parenthesizer, Lean.Parser.Term.falseVal.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Tactic.use,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.ScopedEnvExtension.Entry.scoped.inj,[And.intro],[And, Eq]]
[Command.simpsProj,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Command.simpsRule, Bool.false],[Lean.ParserDescr]]
[Lean.Elab.Term.MatchAltView.ref,[],[Lean.Syntax]]
[List.card_eq_of_equiv,[Nat.le_antisymm, List.card_subset_le, And.left, And.right],[Eq, List.card]]
[Lean.Meta.forallTelescope,[Lean.Meta.map2MetaM, Bool.false, Option.none],[]]
[Lean.Meta.SynthInstance.Waiter.root.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.SynthInstance.Waiter.root, OfNat.ofNat]]
[Lean.Parser.Command.eval.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.instFromJsonDiagnosticRelatedInformation,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.Location, String, Pure.pure, Lean.Lsp.DiagnosticRelatedInformation.mk],[Lean.FromJson, Lean.Lsp.DiagnosticRelatedInformation]]
[Lean.Elab.InfoTree.deepestNodes,[Option.none, Lean.Elab.InfoTree.deepestNodes.go],[List]]
[Lean.LocalContext.findDeclM?,[Std.PersistentArray.findSomeM?, Lean.LocalContext.decls, Unit.unit, Option, Pure.pure, Option.none],[Option]]
[Lean.CollectLevelParams.State.mk.inj,[And.intro],[And, Eq]]
[Lean.Server.Watchdog.ServerContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.Watchdog.ServerContext.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.instance.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.optNamedPrio.formatter, Lean.Parser.optional.formatter, Lean.ppSpace.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.Command.declSig.formatter, Lean.Parser.Command.declVal.formatter, Lean.Parser.Command.terminationSuffix.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.IR.ExplicitRC.VarMap,[Std.RBMap, Lean.IR.VarId, Lean.IR.ExplicitRC.VarInfo, Ord.compare, Lean.IR.VarId.idx],[]]
[Lean.IR.Borrow.collectDecls,[Bind.bind, MonadReader.read, Lean.IR.Borrow.whileModifing, Array.forM, Lean.IR.Borrow.collectDecl, Lean.IR.Borrow.BorrowInfCtx.decls, OfNat.ofNat, Array.size, MonadState.get, Pure.pure, Lean.IR.Borrow.BorrowInfState.paramMap],[Lean.IR.Borrow.M, Lean.IR.Borrow.ParamMap]]
[not_imp,[Decidable.not_imp],[Iff, Not, And]]
[Lean.setImplementedBy,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.Compiler.setImplementedBy, Lean.setEnv, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format],[Unit]]
[Std.PersistentArray.findSomeRev?,[Id.run, Std.PersistentArray.findSomeRevM?],[Option]]
[List.map_cons,[rfl],[Eq, List.map, List.cons]]
[Lean.IR.FnBody.body,[Lean.IR.FnBody.case, Lean.IR.FnBody.ret, Lean.IR.FnBody.jmp, Lean.IR.FnBody.unreachable, Lean.IR.FnBody],[Lean.IR.FnBody]]
[Lean.mkBelow,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.MonadEnv.modifyEnv, Lean.throwKernelException, Lean.mkBelowImp],[Unit]]
[Lean.Lsp.RpcKeepAliveParams.uri,[],[Lean.Lsp.DocumentUri]]
[SubNegMonoid.gsmul,[],[]]
[Lean.IR.UnreachableBranches.InterpContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.UnreachableBranches.InterpContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.UnreachableBranches.InterpContext.mk, And]]
[Lean.Elab.Term.elabPipeProj,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Term.withoutPostponingUniverseConstraints, Bind.bind, Lean.Elab.Term.expandArgs, Bool.false, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, BEq.beq, Array.size, OfNat.ofNat, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElab]]
[true_iff_false,[iff_false_intro, Iff.mp, trivial],[Iff, True, False]]
[Lean.Meta.Simp.Config.contextual,[],[Bool]]
[Lean.Parser.AliasValue.unary.inj,[],[Eq]]
[Lean.Meta.GeneralizeTelescope.Entry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.GeneralizeTelescope.Entry.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.GeneralizeTelescope.Entry.mk, And]]
[OfScientific.noConfusionType,[],[]]
[Lean.Parser.rawFn,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Parser.ParserState.pushSyntax],[Lean.Parser.ParserFn]]
[Lean.Message.endPos,[],[Option, Lean.Position]]
[Float.mk.injEq,[Eq.propIntro, Eq.refl, Float.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Float.mk]]
[Lean.Parser.Command.exit,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.checkKnowsType,[Bind.bind, MonadReader.read, ite, Eq, not, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.knowsType, Bool.true, MonadExcept.throw, Lean.Exception.internal, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeFailureId, Lean.KVMap.mk, Pure.pure, PUnit.unit],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM, Unit]]
[Lean.Widget.instToJsonGetInteractiveDiagnosticsParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Widget.GetInteractiveDiagnosticsParams.lineRange?, List.nil],[Lean.ToJson, Lean.Widget.GetInteractiveDiagnosticsParams]]
[Lean.PrettyPrinter.Formatter.checkColGe.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.Simp.instReprConfig,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.Meta.Simp.Config.maxSteps, Std.Format.line, Lean.Meta.Simp.Config.maxDischargeDepth, Lean.Meta.Simp.Config.contextual, Lean.Meta.Simp.Config.memoize, Lean.Meta.Simp.Config.singlePass, Lean.Meta.Simp.Config.zeta, Lean.Meta.Simp.Config.beta, Lean.Meta.Simp.Config.eta, Lean.Meta.Simp.Config.etaStruct, Lean.Meta.Simp.Config.iota, Lean.Meta.Simp.Config.proj, Lean.Meta.Simp.Config.decide],[Repr, Lean.Meta.Simp.Config]]
[Lean.PrettyPrinter.Parenthesizer.withAntiquotSuffixSplice.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, Lean.Syntax.isAntiquotSuffixSplice, Bool.true, Lean.PrettyPrinter.Parenthesizer.visitArgs, SeqRight.seqRight],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Syntax.SepArray.ofElems,[Lean.Syntax.SepArray.mk, Lean.mkSepArray, Lean.mkAtom],[Lean.Syntax.SepArray]]
[Lean.IR.ExplicitRC.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.RpcCallParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.RpcCallParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Level.mvarId!,[Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.MVarId, panicWithPosWithDecl, OfNat.ofNat],[Lean.MVarId]]
[Lean.Lsp.TextDocumentItem.noConfusionType,[],[]]
[Lean.Parser.Command.declValEqns.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.Term.matchAltsWhereDecls.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.addMessageContextFull,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadMCtx.getMCtx, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Pure.pure, Lean.MessageData.withContext, Lean.MessageDataContext.mk],[Lean.MessageData]]
[Lean.Parser.Tactic.tacticErw__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Parser.Tactic.cc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[instXorUInt64,[Xor.mk, UInt64.xor],[Xor, UInt64]]
[Lean.Parser.Command.identPrec,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.optPrecedence],[Lean.Parser.Parser]]
[Lean.Meta.DecLevelContext.canAssignMVars,[],[Bool]]
[Lean.Elab.Term.instInhabitedMatchAltView,[Inhabited.mk, Lean.Elab.Term.MatchAltView.mk, arbitrary],[Inhabited, Lean.Elab.Term.MatchAltView]]
[Lean.PrettyPrinter.Parenthesizer.sepByNoAntiquot.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.PrettyPrinter.Parenthesizer.visitArgs, List.forM, List.reverse, List.range, Array.size, Lean.Syntax.getArgs, ite, Eq, BEq.beq, HMod.hMod, OfNat.ofNat, Bool.true],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.elabStrLit,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Syntax.isStrLit?, Pure.pure, Lean.mkStrLit, Lean.Elab.throwIllFormedSyntax],[Lean.Elab.Term.TermElab]]
[Prod.map_snd,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Prod.snd, prod_map, eq_self],[Eq, Prod.snd, Prod.map]]
[List.lengthTR,[List.lengthTRAux, OfNat.ofNat],[Nat]]
[Int.negOfNat_add,[Unit.unit, Eq, HAdd.hAdd, Int.negOfNat, of_eq_true, Eq.trans, congr, congrArg, Nat.zero_eq, Nat.add_zero, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true, Eq.mpr, congrFun, Nat.succ, Nat.zero_add, rfl, Nat.succ_add],[Eq, HAdd.hAdd, Int.negOfNat]]
[Lean.Elab.Term.CollectPatternVars.Context.paramDecls,[],[Array, Prod, Lean.Name, Lean.BinderInfo]]
[Lean.Lsp.SymbolKind.method.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.method, OfNat.ofNat]]
[Union.noConfusionType,[],[]]
[Lean.Elab.Command.elabInitQuot,[Bind.bind, Lean.MonadEnv.getEnv, Lean.Elab.Command.CommandElabM, Unit, Lean.Environment.addDecl, Lean.Declaration.quotDecl, Lean.setEnv, Lean.MonadOptions.getOptions, Lean.throwError, Lean.KernelException.toMessageData],[Lean.Elab.Command.CommandElab]]
[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Eq.substr,[Eq.symm],[]]
[Lean.Core.instMonadWithOptionsCoreM,[Lean.MonadWithOptions.mk, MonadWithReader.withReader, Lean.Core.Context.mk, Lean.Core.Context.options, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats],[Lean.MonadWithOptions, Lean.Core.CoreM]]
[Lean.Elab.isAutoBoundImplicitLocalException?,[Lean.Exception.error, Option, Lean.Name, ite, Eq, BEq.beq, Lean.Elab.autoBoundImplicitExceptionId, Bool.true, Option.some, Lean.KVMap.getName, Lean.Name.mkStr, Lean.Name.anonymous, Option.none],[Option, Lean.Name]]
[false_of_ne,[Ne.irrefl],[False]]
[instReprSigma,[Repr.mk, Std.Format, Std.Format.bracket, HAppend.hAppend, repr, Std.Format.text],[Repr, Sigma]]
[IO.FS.instBEqFileType,[BEq.mk, BEq.beq, IO.FS.FileType.toCtorIdx],[BEq, IO.FS.FileType]]
[Lean.Lsp.Range.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.Range.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.Range.mk, And]]
[exacts,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Core.mkFreshUserName,[Bind.bind, MonadState.modifyGet, Prod.mk, Lean.Core.State.nextMacroScope, Lean.Core.State.mk, Lean.Core.State.env, HAdd.hAdd, OfNat.ofNat, Lean.Core.State.ngen, Lean.Core.State.traceState, Lean.MonadEnv.getEnv, Pure.pure, Lean.addMacroScope, Lean.Environment.mainModule],[Lean.Core.CoreM, Lean.Name]]
[Lean.Macro.Exception.noConfusionType,[],[]]
[Lean.Meta.State.postponed,[],[Std.PersistentArray, Lean.Meta.PostponedEntry]]
[Lean.Meta.throwLetTypeMismatchMessage,[Bind.bind, Lean.MonadLCtx.getLCtx, Option.none, Option.some, Lean.LocalDecl.cdecl, Lean.Meta.MetaM, Lean.LocalContext.find?, Lean.Meta.inferType, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, panicWithPosWithDecl, OfNat.ofNat],[Lean.Meta.MetaM]]
[Lean.Compiler.checkIsDefinition,[Unit.unit, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Except, String, Unit, Lean.Environment.find?, Except.ok, Except.error, HAppend.hAppend, ToString.toString],[Except, String, Unit]]
[Nat.fold,[Nat.foldAux],[]]
[Lean.Expr.hasLevelParamEx,[Lean.Expr.hasLevelParam],[Bool]]
[Lean.Meta.AuxLemmas.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.AuxLemmas.mk, HAdd.hAdd, OfNat.ofNat]]
[Bool.false.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Bool.false, OfNat.ofNat]]
[Lean.Elab.expandDeclSig,[Prod.mk, Lean.Syntax.getOp, OfNat.ofNat],[Prod, Lean.Syntax]]
[List.length_replicate.aux,[of_eq_true, Eq.trans, congrArg, Eq, List.length, congrFun, HAdd.hAdd, Nat.zero_eq, Nat.zero_add, eq_self, congr, List.cons, List.length_cons, Nat.add_succ, Nat.succ_add, Nat.succ],[Eq, List.length, List.replicate.loop, HAdd.hAdd]]
[Lean.Meta.ByCasesSubgoal.mk.inj,[And.intro],[And, Eq]]
[Exists.nonempty,[Nonempty, Nonempty.intro],[Nonempty]]
[Array.zipWith,[Array.zipWithAux, OfNat.ofNat, List.toArray, List.nil],[Array]]
[Lean.Lsp.TextDocumentItem.text,[],[String]]
[Lean.Meta.simpTarget,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.simpTargetCore],[Lean.Meta.MetaM, Option, Lean.MVarId]]
[Lean.Meta.NormNum.instLawfulOfNat.proof_1,[Lean.Meta.NormNum.LawfulOfNat.mk, rfl],[Lean.Meta.NormNum.LawfulOfNat]]
[Nat.coprime.coprime_mul_left_right,[Nat.coprime.coprime_dvd_right, Nat.dvd_mul_left],[Nat.coprime]]
[IO.Error.noFileOrDirectory.inj,[And.intro],[And, Eq]]
[Lean.MonadCache.noConfusionType,[],[]]
[Lean.SourceInfo.getPos?,[Lean.SourceInfo.synthetic, Bool.true, Lean.SourceInfo.none, Option, String.Pos, Option.some, Option.none],[Option, String.Pos]]
[Lean.Meta.CongrArgKind.heq.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.CongrArgKind.heq, OfNat.ofNat]]
[Lean.Meta.DefaultInstanceEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.DefaultInstanceEntry.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Name.hash.proof_1,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt64.size]]
[Subarray.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Subarray.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Subarray.mk, And]]
[Lean.Lsp.DiagnosticTag.noConfusion,[noConfusionEnum, Lean.Lsp.DiagnosticTag.toCtorIdx],[Lean.Lsp.DiagnosticTag.noConfusionType]]
[List.head?,[Unit.unit, Option, Option.none, Option.some],[Option]]
[Lean.Meta.Split.splitMatch,[Bind.bind, Lean.Meta.matchMatcherApp?, Option.none, Lean.Meta.MetaM, List, Lean.MVarId, Lean.Meta.Match.getEquationsFor, Lean.Meta.MatcherApp.matcherName, Lean.Meta.Split.applyMatchSplitter, Lean.Meta.MatcherApp.matcherLevels, Lean.Meta.MatcherApp.params, Lean.Meta.MatcherApp.discrs, List.foldlM, Prod, Nat, Lean.Meta.withMVarContext, Lean.Meta.getMVarType, Lean.Meta.instantiateMVars, Lean.Meta.getCongrLemmas, Pure.pure, Lean.Meta.Simp.Context.mk, Lean.Meta.Simp.Config.mk, Bool.false, Lean.Meta.SimpLemmas.mk, Lean.Meta.Simp.main, Lean.Meta.Simp.Methods.mk, ite, Eq, Lean.Expr.isAppOf, Bool.true, liftM, Lean.Meta.reduceRecMatcher?, Unit.unit, Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step, Lean.Meta.Simp.Step.done, Lean.Meta.Simp.Result.mk, Lean.Meta.withReducible, Lean.Meta.Simp.tryLemma?, Lean.Meta.SimpLemma.mk, Lean.mkConst, List.nil, Option.some, Lean.Meta.SplitIf.discharge?, Lean.Meta.Simp.Step.visit, Lean.Meta.Simp.Result.proof?, Lean.Meta.replaceTargetEq, Lean.Meta.Simp.Result.expr, Lean.Meta.replaceTargetDefEq, Array.getOp, Lean.Meta.Match.MatchEqns.eqnNames, Prod.mk, HAdd.hAdd, OfNat.ofNat, List.cons, List.reverse, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM, List, Lean.MVarId]]
[ST.Prim.Ref.modifyGet,[Bind.bind, ST.Prim.Ref.get, ST, ST.Prim.Ref.set, Pure.pure],[ST]]
[Lean.LocalDecl.type,[Lean.Expr],[Lean.Expr]]
[Lean.Expr.ReplaceLevelImpl.State.mk.inj,[And.intro],[And, Eq]]
[Lean.PrettyPrinter.Delaborator.isSimpleHOFun,[Bind.bind, Lean.PrettyPrinter.Delaborator.returnsPi, Lean.PrettyPrinter.Delaborator.isNonConstFun, Pure.pure, and, not],[Lean.Meta.MetaM, Bool]]
[Lean.Lsp.RpcRef.p,[],[USize]]
[Lean.Elab.Term.Do.Code.match.inj,[And.intro],[And, Eq]]
[Lean.Lsp.ProgressParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.ProgressParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.ProgressParams.mk, And]]
[Lean.Parser.Term.typeSpec.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[ByteArray.size,[Nat, Array.size],[Nat]]
[Lean.Elab.Command.openPrivate,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Parser.ParserExtension.Entry.kind.inj,[],[Eq]]
[UInt64.ofNat,[UInt64.mk, Fin.ofNat],[UInt64]]
[Lean.OpenDecl.simple.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.OpenDecl.simple, HAdd.hAdd, OfNat.ofNat]]
[instDecidableXor.proof_3,[Or.inr, And.intro],[Or, And, Not]]
[Lean.MetavarContext.mkMetavarContext,[Lean.MetavarContext.mk],[Lean.MetavarContext]]
[Function.inv_fun_on_eq',[],[Eq, Function.inv_fun_on]]
[Lean.Meta.UnificationHints.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.UnificationHints.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.UnificationHints.mk]]
[Lean.PrettyPrinter.Delaborator.unfoldMDatas,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Lean.Expr, PProd.fst],[Lean.Expr]]
[Lean.Parser.eoiFn,[ite, Eq, String.atEnd, Lean.Parser.InputContext.input, Lean.Parser.ParserContext.toInputContext, Bool.true, Lean.Parser.ParserState.mkError],[Lean.Parser.ParserFn]]
[Lean.Parser.Command.protected.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.instInhabitedFileMap,[Inhabited.mk, Lean.FileMap.mk, arbitrary],[Inhabited, Lean.FileMap]]
[Lean.Elab.Term.LetRecToLift.val,[],[Lean.Expr]]
[bfix5,[PProd.fst],[]]
[Std.ShareCommonT.monadShareCommon,[Std.MonadShareCommon.mk, Std.ShareCommonT.withShareCommon],[Std.MonadShareCommon, Std.ShareCommonT]]
[Lean.mkConstEx,[Lean.mkConst],[Lean.Expr]]
[Lean.KVMap.noConfusionType,[],[]]
[Lean.getPPMotivesAll,[Lean.KVMap.get, Lean.Option.name, Lean.pp.motives.all, Lean.Option.defValue],[Bool]]
[Lean.Elab.Tactic.getUnsolvedGoals,[Bind.bind, Lean.Elab.Tactic.pruneSolvedGoals, Lean.Elab.Tactic.getGoals],[Lean.Elab.Tactic.TacticM, List, Lean.MVarId]]
[Lean.Elab.instInhabitedAttribute,[Inhabited.mk, Lean.Elab.Attribute.mk, arbitrary],[Inhabited, Lean.Elab.Attribute]]
[fixCore5,[bfix5, USize.size],[]]
[Lean.Parser.Command.catBehaviorSymbol.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.nonReservedSymbol.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[USize.instCommRingUSize.proof_1,[USize.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, USize.val, USize.mul_def, CommSemiring.mul_comm],[Eq, HMul.hMul]]
[Function.surjective.exists₃,[Iff.trans, Function.surjective.exists, exists_congr, Function.surjective.exists₂],[Iff, Exists]]
[HDiv.hDiv,[],[]]
[CoeFun.coe,[],[]]
[Except.error.injEq,[Eq.propIntro, Eq.refl, Except.error, Eq.symm, eq_of_heq, HEq.refl],[Eq, Except.error]]
[List.mem_bind,[Eq.mpr, congrFun, congrArg, Iff, Eq.trans, propext, List.mem_join, Exists, funext, And, List.mem_map, Mem.mem, Iff.intro, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Exists.intro, And.intro, Eq, rfl],[Iff, Mem.mem, List.bind, Exists, And]]
[Std.HashMapImp.noConfusionType,[],[]]
[Lean.PrettyPrinter.formatTactic,[Lean.PrettyPrinter.format, Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Core.CoreM, Std.Format]]
[Nat.gcd_eq_right_iff_dvd,[Eq.mpr, Eq.refl, Iff, Dvd.dvd, Eq, Nat.gcd, Nat.gcd_comm, Nat.gcd_eq_left_iff_dvd],[Iff, Dvd.dvd, Eq, Nat.gcd]]
[le_of_not_gt,[le_of_not_lt],[LE.le]]
[ReaderT.tryFinally,[MonadFinally.mk, MonadFinally.tryFinally'],[MonadFinally, ReaderT]]
[Lean.registerAttributeImplBuilder,[Bind.bind, ST.Ref.get, Lean.attributeImplBuilderTableRef, ite, Eq, Std.HashMap.contains, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Pure.pure, PUnit.unit],[IO, Unit]]
[Lean.SCC.Data.noConfusionType,[],[]]
[Lean.Compiler.InlineAttributeKind.noConfusionType,[noConfusionTypeEnum, Lean.Compiler.InlineAttributeKind.toCtorIdx],[]]
[Lean.Elab.InfoTree.node.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, congrFun, congr, Eq.symm, Std.PersistentArrayNode.node.sizeOf_spec, Eq.refl, List.nil, List.cons.sizeOf_spec, Array.mk.sizeOf_spec, Std.PersistentArrayNode.leaf.sizeOf_spec, Std.PersistentArray.mk.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Elab.InfoTree.node, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.instToFormatIRType,[Std.ToFormat.mk],[Std.ToFormat, Lean.IR.IRType]]
[Lean.PrettyPrinter.Delaborator.SubExpr.maxChildren,[OfNat.ofNat],[Lean.PrettyPrinter.Delaborator.Pos]]
[Lean.IR.Expr.unbox.inj,[],[Eq]]
[Lean.IR.UnreachableBranches.InterpState.noConfusionType,[],[]]
[Lean.Meta.Simp.Config.decide,[],[Bool]]
[Lean.Lsp.instFromJsonDocumentSymbolParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Pure.pure, Lean.Lsp.DocumentSymbolParams.mk],[Lean.FromJson, Lean.Lsp.DocumentSymbolParams]]
[instHDiv,[HDiv.mk, Div.div],[HDiv]]
[Lean.Meta.addDefaultInstance,[Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.Meta.MetaM, Unit, Lean.Environment.find?, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.forallTelescopeReducing, Lean.ConstantInfo.type, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr.getAppFn, ite, Eq, Lean.isClass, Bool.true, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Unit]]
[Lean.Parser.Attr.ancestor,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Elab.Term.tryPostponeIfNoneOrMVar,[Unit.unit, Lean.Elab.Term.TermElabM, Unit, Lean.Elab.Term.tryPostponeIfMVar, Lean.Elab.Term.tryPostpone],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Lsp.InitializeParams.trace,[],[Lean.Lsp.Trace]]
[coeOfHTCT,[CoeT.mk, CoeHTCT.coe],[CoeT]]
[UInt32.instAddSemigroupUInt32,[AddSemigroup.mk, UInt32.instAddSemigroupUInt32.proof_1],[AddSemigroup, UInt32]]
[Lean.PrettyPrinter.Delaborator.shouldShowMotive,[Bind.bind, andM, Pure.pure, Lean.getPPMotivesPi, Lean.PrettyPrinter.Delaborator.returnsPi, Lean.getPPMotivesNonConst, Lean.PrettyPrinter.Delaborator.isNonConstFun, orM, Lean.getPPMotivesAll],[Lean.Meta.MetaM, Bool]]
[IO.FS.Stream.writeLspNotification,[IO.FS.Stream.writeLspMessage, Lean.JsonRpc.Message.notification, Lean.JsonRpc.Notification.method, Except.toOption, Lean.Json.toStructured?, Lean.JsonRpc.Notification.param],[IO, Unit]]
[Function.inv_fun_neg,[Function.inv_fun_on_neg, mt, Exists, Eq, Exists.intro],[Eq, Function.inv_fun, Classical.choice]]
[Lean.Lsp.InitializeResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.InitializeResult.mk, HAdd.hAdd, OfNat.ofNat]]
[List.mem_append_eq,[propext, List.mem_append],[Eq, Mem.mem, HAppend.hAppend, Or]]
[Lean.Meta.Simp.State.numSteps,[],[Nat]]
[Lean.Elab.Deriving.BEq.mkMatch.mkAlts,[Bind.bind, ForIn.forIn, Lean.getConstInfoCtor, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, liftM, Lean.Core.betaReduce, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, PUnit.unit, ForInStep.yield, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, MProd.mk, Lean.Elab.Term.TermElabM, Lean.Syntax, ite, Eq, Lean.Expr.containsFVar, Lean.Expr.fvarId!, Bool.true, Lean.Core.mkFreshUserName, Lean.Meta.inferType, Lean.Expr.isAppOf, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Lean.mkIdent, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.Elab.Deriving.BEq.mkMatch.mkElseAlt],[Lean.Elab.Term.TermElabM, Array, Lean.Syntax]]
[Lean.Elab.Tactic.Conv.evalChange,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Tactic.Conv.getLhs, Lean.MonadMCtx.getMCtx, liftM, Lean.Meta.inferType, Lean.Elab.Tactic.elabTermEnsuringType, Option.some, Bool.false, Lean.Meta.getMVars, Lean.Elab.Tactic.filterOldMVars, Lean.Elab.Tactic.logUnassignedAndAbort, Lean.Meta.isDefEqGuarded, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[List.card_cons_of_mem,[Eq.mpr, Eq.refl, Eq, ite, Mem.mem, List.card, HAdd.hAdd, OfNat.ofNat, if_pos, rfl],[Eq, List.card, List.cons]]
[Lean.Parser.Tactic.seq1,[Lean.Parser.node, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.sepBy1, Lean.Parser.tacticParser, OfNat.ofNat, Lean.Parser.symbol, Bool.true],[Lean.Parser.Parser]]
[Lean.Meta.UnificationHints.mk.inj,[],[Eq]]
[Lean.Parser.Tactic.withReducible,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Meta.ReduceMatcherResult.reduced.inj,[],[Eq]]
[Lean.Parser.Term.termPquoteₓ_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Int.neg_eq_neg_one_mul,[Unit.unit, Eq, Neg.neg, HMul.hMul, OfNat.ofNat, rfl],[Eq, Neg.neg, HMul.hMul, OfNat.ofNat]]
[Lean.Meta.DefaultInstanceEntry.noConfusionType,[],[]]
[Lean.IR.CollectUsedDecls.collect,[modify, Lean.NameSet.insert],[Lean.IR.CollectUsedDecls.M, Unit]]
[Lean.Parser.Tactic.Conv.convIntro___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.throwUnknownConstant,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkConst, List.nil],[]]
[Nat.decEq,[Decidable, Eq, Nat.beq, Nat.decEq.proof_1, Decidable.isTrue, Nat.eq_of_beq_eq_true, Decidable.isFalse, Nat.ne_of_beq_eq_false],[Decidable, Eq]]
[Lean.SCC.State.sccs,[],[List]]
[IO.FS.SystemTime.mk.inj,[And.intro],[And, Eq]]
[Lean.MonadResolveName.noConfusionType,[],[]]
[Lean.Meta.collectUsedFVarsAtFVars,[Array.forM, Bind.bind, liftM, Lean.Meta.inferType, Lean.Meta.collectUsedFVars, OfNat.ofNat, Array.size],[StateRefT', IO.RealWorld, Lean.CollectFVars.State, Lean.Meta.MetaM, Unit]]
[Lean.Parser.ParserContext.prec,[],[Nat]]
[Lean.ConstantInfo.defnInfo.inj,[],[Eq]]
[Lean.Meta.SynthInstance.SubgoalsResult.noConfusionType,[],[]]
[Lean.setReducibilityStatusImp,[Except.error, Lean.Environment, Lean.EnumAttributes.setValue, Lean.reducibilityAttrs],[Lean.Environment]]
[Numeric.OfNat,[OfNat.mk, Numeric.ofNat],[OfNat]]
[Lean.DefinitionVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.DefinitionVal.mk, HAdd.hAdd, OfNat.ofNat]]
[Thunk.get,[Unit.unit],[]]
[Subarray.h₁,[],[LE.le, Subarray.start, Subarray.stop]]
[Lean.Elab.Command.instMonadQuotationCommandElabM,[Lean.MonadQuotation.mk, Lean.Elab.Command.getCurrMacroScope, Lean.Elab.Command.getMainModule, Lean.Elab.Command.withFreshMacroScope],[Lean.MonadQuotation, Lean.Elab.Command.CommandElabM]]
[Lean.Parser.Syntax.numPrec.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.numLit.formatter],[Lean.PrettyPrinter.Formatter]]
[Classical.propDecidable.proof_1,[Nonempty, Decidable, Classical.em, Nonempty.intro, Decidable.isTrue, Decidable.isFalse],[Nonempty, Decidable]]
[Lean.Parser.Tactic.revertDeps,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Parser.Command.unsafe,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Parser.Term.doIfProp.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.optIdent.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.InitializationOptions.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.InitializationOptions.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.InitializationOptions.mk]]
[List.minimum?,[Unit.unit, Option, Option.none, Option.some, List.foldl, min],[Option]]
[Nat.gcd_eq_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, Nat.gcd_comm, Nat.gcd_eq_left, rfl],[Eq, Nat.gcd]]
[Lean.SCC.scc,[List, List.reverse, Lean.SCC.State.sccs],[List]]
[Lean.Lsp.SemanticTokensParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.SemanticTokensParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.SemanticTokensParams.mk]]
[IO.Error.resourceBusy.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.resourceBusy, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.resourceBusy, And]]
[instSemigroupFin.proof_1,[Fin.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, Fin.val, Eq.trans, congrFun, HMul.hMul, Fin.mul_def, Fin.mk, HMod.hMod, Nat.mod_lt, Fin.size_positive, Eq.refl, Eq.symm, Eq.mp, Nat.mul_mod, Nat.mod_eq_of_lt, Fin.isLt, Nat.mul_assoc, rfl],[Eq, HMul.hMul]]
[instDecidablePredComp,[inferInstanceAs, DecidablePred],[DecidablePred, Function.comp]]
[Lean.Elab.Tactic.State.noConfusionType,[],[]]
[coeOfTCOfTail,[CoeHTCT.mk, coeTail, coeTC],[CoeHTCT]]
[TC.wf,[TC.wf.proof_1],[WellFounded, TC]]
[Function.surjective.forall₃,[Iff.trans, Function.surjective.forall, forall_congr', Function.surjective.forall₂],[Iff]]
[Tactic.Ring.horner,[HAdd.hAdd, HMul.hMul, HPow.hPow],[]]
[Lean.Meta.DiscrTree.Trie.ibelow,[And, True],[]]
[PNonScalar.noConfusionType,[],[]]
[Lean.Parser.Attr.class.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.instFileSourceDeclarationParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.DeclarationParams.toTextDocumentPositionParams],[Lean.Lsp.FileSource, Lean.Lsp.DeclarationParams]]
[Lean.ModuleData.entries,[],[Array, Prod, Lean.Name, Lean.EnvExtensionEntry]]
[Lean.Server.Snapshots.Snapshot.mpState,[],[Lean.Parser.ModuleParserState]]
[Lean.Lsp.LeanFileProgressProcessingInfo.range,[],[Lean.Lsp.Range]]
[Lean.Meta.Config.transparency,[],[Lean.Meta.TransparencyMode]]
[Lean.Elab.DefView.deriving?,[],[Option, Array, Lean.Syntax]]
[Lean.instQuoteArray,[Lean.Quote.mk, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Quote.quote, Array.toList, List.nil],[Lean.Quote, Array]]
[Lean.Parser.Term.scientific.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.scientificLit.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.CasesSubgoal.toInductionSubgoal,[],[Lean.Meta.InductionSubgoal]]
[Lean.instCoeNameDataValue,[Coe.mk, Lean.DataValue.ofName],[Coe, Lean.Name, Lean.DataValue]]
[Lean.Meta.reduceProj?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Meta.MetaM, Option, Lean.Expr, Lean.Meta.project?, Pure.pure, Option.none],[Lean.Meta.MetaM, Option, Lean.Expr]]
[IO.FS.Stream.getLine,[],[IO, String]]
[Lean.Parser.Tactic.quotSeq.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.Tactic.seq1.formatter],[Lean.PrettyPrinter.Formatter]]
[MProd.fst,[],[]]
[UInt8.instCommRingUInt8.proof_1,[UInt8.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, UInt8.val, UInt8.mul_def, CommSemiring.mul_comm],[Eq, HMul.hMul]]
[Prod.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Prod.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.InitializeResult.serverInfo?,[],[Option, Lean.Lsp.ServerInfo]]
[Lean.Elab.instToStringModifiers,[ToString.mk, Function.comp, ToString.toString, Std.ToFormat.format],[ToString, Lean.Elab.Modifiers]]
[Lean.Lsp.DidCloseTextDocumentParams.mk.inj,[],[Eq]]
[Lean.Elab.headerToImports,[HAppend.hAppend, List.map, Lean.Import.mk, Array.toList, Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat],[List, Lean.Import]]
[timeCmd,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Lsp.Location.range,[],[Lean.Lsp.Range]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.withKnowing,[MonadWithReader.withReader, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.inBottomUp, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.parentIsApp, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.subExpr],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM]]
[Lean.Parser.Term.doIfProp,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.Term.optIdent, Lean.Parser.termParser, OfNat.ofNat, Bool.false],[Lean.Parser.Parser]]
[Lean.Elab.Term.TermElabM.toIO,[Bind.bind, Lean.Meta.MetaM.toIO, Lean.Elab.Term.TermElabM.run, IO, Prod, Lean.Core.State, Lean.Meta.State, Lean.Elab.Term.State, Pure.pure, Prod.mk],[IO, Prod, Lean.Core.State, Lean.Meta.State, Lean.Elab.Term.State]]
[Lean.Xml.Parser.hexDigitToNat,[ite, And, LE.le, Char.ofNat, HSub.hSub, Char.toNat, HAdd.hAdd, OfNat.ofNat],[Nat]]
[IO.Error.illegalOperation.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.illegalOperation, HAdd.hAdd, OfNat.ofNat]]
[Lean.Xml.Parser.Attribute,[Bind.bind, Lean.Xml.Parser.Name, Lean.Xml.Parser.Eq, Lean.Xml.Parser.AttValue, Pure.pure, Prod.mk],[Lean.Parsec, Prod, String]]
[Lean.Parser.Command.extends,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.sepBy1, Lean.Parser.termParser, Bool.false],[Lean.Parser.Parser]]
[Lean.Core.withCurrHeartbeats,[controlAt, Lean.Core.CoreM, Bind.bind, liftM, IO.getNumHeartbeats, MonadWithReader.withReader, Lean.Core.Context.mk, Lean.Core.Context.options, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.maxHeartbeats],[]]
[Lean.initSearchPath,[Bind.bind, Lean.getBuiltinSearchPath, Lean.addSearchPathFromEnv, ST.Ref.set, Lean.searchPathRef],[IO, Unit]]
[AddCommSemigroup.add_comm,[],[Eq, HAdd.hAdd]]
[Lean.Elab.Tactic.evalFirst,[ite, Eq, Array.isEmpty, Bool.true, Bind.bind, Lean.Elab.throwUnsupportedSyntax, Pure.pure, PUnit.unit, Lean.Elab.Tactic.evalFirst.loop],[Lean.Elab.Tactic.Tactic]]
[Lean.Elab.PreDefinition.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.PreDefinition.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.FileMap.leanPosToLspPos,[Lean.Lsp.Position, Lean.Lsp.Position.mk, HSub.hSub, OfNat.ofNat, String.codepointPosToUtf16PosFrom, Lean.FileMap.source, Array.get!, Lean.FileMap.positions],[Lean.Lsp.Position]]
[Lean.Parser.Command.partial.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.le_of_ble_eq_true,[Eq.refl, Bool.true, HEq.refl, LE.le, Nat.zero_le, Nat.succ_le_succ, PProd.fst],[LE.le]]
[Lean.Expr.getArgD,[Lean.Expr.getRevArgD, HSub.hSub, OfNat.ofNat],[Lean.Expr]]
[Int.decEq.proof_4,[absurd],[False]]
[StateT.ext,[funext],[Eq]]
[UInt8.mul,[UInt8.mk, HMul.hMul, UInt8.val],[UInt8]]
[IO.Error.instToStringError,[ToString.mk, IO.Error.toString],[ToString, IO.Error]]
[Lean.KeyedDeclsAttribute.OLeanEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KeyedDeclsAttribute.OLeanEntry.mk, HAdd.hAdd, OfNat.ofNat]]
[MonadStateOf.noConfusionType,[],[]]
[Lean.mkFreshFVarId,[Bind.bind, Lean.mkFreshId, Pure.pure, Lean.FVarId.mk],[Lean.FVarId]]
[LawfulMonad.toLawfulApplicative,[],[LawfulApplicative]]
[Lean.MessageData.withContext.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MessageData.withContext, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MessageData.withContext, And]]
[Lean.KeyedDeclsAttribute.Def.descr,[],[String]]
[Lean.IR.logMessageIf,[Bind.bind, MonadReader.read, ite, Eq, Option.none, Option.some, Lean.DataValue.ofString, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Bool, Lean.KVMap.find, Lean.KVMap.getBool, Lean.IR.tracePrefixOptionName, Bool.false, Bool.true, Lean.IR.log, Lean.IR.LogEntry.message, Std.ToFormat.format, Pure.pure, PUnit.unit, HAppend.hAppend],[Lean.IR.CompilerM, Unit]]
[RandomGen.next,[],[Prod, Nat]]
[Lean.IR.checkDecls,[Array.forM, Lean.IR.checkDecl, OfNat.ofNat, Array.size],[Lean.IR.CompilerM, Unit]]
[Lean.KernelException.exprTypeMismatch.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KernelException.exprTypeMismatch, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.Watchdog.findFileWorker!,[Bind.bind, Lean.Server.Watchdog.findFileWorker?, Option.none, Lean.Server.Watchdog.ServerM, Lean.Server.Watchdog.FileWorker, Pure.pure, liftM, IO.throwServerError, HAppend.hAppend, ToString.toString],[Lean.Server.Watchdog.ServerM, Lean.Server.Watchdog.FileWorker]]
[Lean.Parser.Tactic.Conv.nestedTactic,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Elab.withInfoContext',[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, ite, Eq, Lean.Elab.InfoState.enabled, Bool.true, Lean.Elab.getResetInfoTrees, Functor.map, Prod.fst, MonadFinally.tryFinally', Unit.unit, Unit, Lean.Elab.MonadInfoTree.modifyInfoState, Lean.Elab.InfoState.mk, Lean.Elab.InfoState.assignment, Lean.Elab.InfoState.trees, Std.PersistentArray, Lean.Elab.InfoTree, Std.PersistentArray.push, Lean.Elab.InfoTree.node, Lean.Elab.InfoTree.hole],[]]
[Lean.Name.lt,[BEq.beq, Lean.Name.cmp, Ordering.lt],[Bool]]
[Lean.Elab.isValidAutoBoundImplicitName,[Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Bool, and, Decidable.decide, GT.gt, String.length, OfNat.ofNat, or, Lean.isGreek, String.getOp, Char.isLower, Substring.all, Substring.drop, String.toSubstring, Char.isDigit, Lean.isSubScriptAlnum, BEq.beq, Char.ofNat, Bool.false],[Bool]]
[Lean.Elab.Command.StructCtorView.inferMod,[],[Bool]]
[Lean.Elab.Tactic.ElimApp.State.f,[],[Lean.Expr]]
[List.map_singleton,[rfl],[Eq, List.map, List.cons, List.nil]]
[instTransEq_1.proof_1,[],[]]
[String.offsetOfPos,[String.offsetOfPosAux, OfNat.ofNat],[Nat]]
[Lean.Widget.InteractiveHypothesis.isType,[],[Bool]]
[Lean.Parser.Tactic.Conv.slice,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Environment.const2ModIdx,[],[Std.HashMap, Lean.Name, Lean.ModuleIdx]]
[Lean.IR.ExplicitBoxing.BoxingState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.ExplicitBoxing.BoxingState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.IRType.ibelow,[True, And],[]]
[Lean.Json.arr.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.trans, Eq.refl, SizeOf.sizeOf, List.nil, HAdd.hAdd, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Json.arr, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.TransparencyMode.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Lsp.StaticRegistrationOptions.noConfusionType,[],[]]
[Lean.EnvExtension.instInhabitedEnvExtension,[Lean.EnvExtensionInterface.inhabitedExt, Lean.EnvExtensionInterfaceImp],[Inhabited, Lean.EnvExtension]]
[Lean.Meta.RewriteResult.mvarIds,[],[List, Lean.MVarId]]
[Lean.ParserCompiler.compileEmbeddedParsers,[Lean.Meta.MetaM, Unit, Pure.pure, Unit.unit, PProd.fst, SeqRight.seqRight, PProd.snd, Functor.discard, Lean.ParserCompiler.compileParserExpr, Bool.false, Lean.mkConst, List.nil],[Lean.Meta.MetaM, Unit]]
[Lean.Meta.IndPredBelow.proveBrecOn,[Bind.bind, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Name.anonymous, Lean.Expr.mvarId!, Lean.Meta.MetaM, Lean.Expr, List.nil, List.cons, Lean.MonadOptions.getOptions, List.forM, Lean.Meta.instantiateMVars, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Meta.IndPredBelow.proveBrecOn.intros, Lean.Meta.IndPredBelow.proveBrecOn.applyIH, Lean.Meta.IndPredBelow.proveBrecOn.induction, Lean.Meta.IndPredBelow.proveBrecOn.applyCtors, Lean.Meta.IndPredBelow.proveBrecOn.introNPRec, Lean.Meta.IndPredBelow.proveBrecOn.closeGoal],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.instReprSMap,[Repr.mk, Repr.addAppParen, HAppend.hAppend, reprArg, Lean.SMap.toList, Std.Format.text],[Repr, Lean.SMap]]
[Lean.Parser.Tactic.obtain,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.rcasesPatMed, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy1],[Lean.ParserDescr]]
[Std.Format.defIndent,[OfNat.ofNat],[Nat]]
[Lean.Meta.getTheoremInfo,[Bind.bind, Lean.Meta.shouldReduceAll, ite, Eq, Bool.true, Pure.pure, Option.some, Option.none],[Lean.Meta.MetaM, Option, Lean.ConstantInfo]]
[Lean.Elab.Command.liftCoreM,[Bind.bind, MonadState.get, MonadReader.read, liftM, IO.getNumHeartbeats, Lean.Elab.Command.CommandElabM, modify, Lean.Elab.Command.State.mk, Lean.Core.State.env, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Core.State.ngen, Lean.Elab.Command.State.infoState, Lean.Core.State.traceState, Pure.pure, MonadExcept.throw],[Lean.Elab.Command.CommandElabM]]
[Lean.Elab.MacroExpansionInfo.output,[],[Lean.Syntax]]
[Lean.Meta.SizeOfSpecNested.Context.params,[],[Array, Lean.Expr]]
[Lean.KVMap.instValueName,[Lean.KVMap.Value.mk, Lean.DataValue.ofName, Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Option, Lean.Name, Option.some, Option.none],[Lean.KVMap.Value, Lean.Name]]
[UInt64.instInhabitedFinSize,[Inhabited.mk, Fin.ofNat', OfNat.ofNat, UInt64.size_positive],[Inhabited, Fin, UInt64.size]]
[Nat.pow_succ,[rfl],[Eq, HPow.hPow, Nat.succ, HMul.hMul]]
[Lean.Lsp.WorkDoneProgressReport.cancellable,[],[Bool]]
[Lean.PrettyPrinter.Parenthesizer.checkLineEq.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Tactic.dsimp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.IR.mkVarJPMaps,[Lean.IR.CollectMaps.collectDecl, Prod.mk, EmptyCollection.emptyCollection],[Prod, Lean.IR.VarTypeMap, Lean.IR.JPParamsMap]]
[Lean.Elab.Command.CollectAxioms.M,[ReaderT, Lean.Environment, StateM, Lean.Elab.Command.CollectAxioms.State],[]]
[not_and_of_not_left,[mt, And.left],[Not, And]]
[Lean.Parser.Error.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.simpIfLocalDecl,[Bind.bind, Lean.Meta.SplitIf.getSimpContext, Lean.Meta.simpLocalDecl, Option.some, Lean.Meta.SplitIf.discharge?, Bool.false, Option.none, Lean.Meta.MetaM, Lean.MVarId, Pure.pure, panicWithPosWithDecl, OfNat.ofNat],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.Meta.Match.Alt.patterns,[],[List, Lean.Meta.Match.Pattern]]
[EIO,[EStateM, IO.RealWorld],[]]
[Lean.Lsp.instFromJsonPlainGoal,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, String, Array, Pure.pure, Lean.Lsp.PlainGoal.mk],[Lean.FromJson, Lean.Lsp.PlainGoal]]
[Lean.Name.getRoot,[Unit.unit, Lean.Name.str, Lean.Name.anonymous, Lean.Name.num, Lean.Name, PProd.fst],[Lean.Name]]
[Lean.IR.Borrow.preserveTailCall,[Bind.bind, MonadReader.read, Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.fap, Lean.IR.FnBody.vdecl, Lean.IR.FnBody.jdecl, Lean.IR.FnBody.set, Lean.IR.FnBody.setTag, Lean.IR.FnBody.uset, Lean.IR.FnBody.sset, Lean.IR.FnBody.inc, Lean.IR.FnBody.dec, Lean.IR.FnBody.del, Lean.IR.FnBody.mdata, Lean.IR.FnBody.case, Lean.IR.FnBody.ret, Lean.IR.Arg.irrelevant, Lean.IR.FnBody.jmp, Lean.IR.FnBody.unreachable, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Lean.IR.Borrow.M, Unit, ite, Eq, and, Array.any, Lean.IR.Borrow.BorrowInfCtx.decls, BEq.beq, Lean.IR.Decl.name, OfNat.ofNat, Array.size, Bool.true, Lean.IR.Borrow.getParamInfo, Lean.IR.Borrow.ParamMap.Key.decl, Lean.IR.Borrow.ownParamsUsingArgs, Pure.pure, PUnit.unit, Unit.unit],[Lean.IR.Borrow.M, Unit]]
[Lean.Elab.Term.Quotation.HeadCheck.shape.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Quotation.HeadCheck.shape, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.Watchdog.WorkerEvent.processGroupedEdits.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Server.Watchdog.WorkerEvent.processGroupedEdits, OfNat.ofNat]]
[Lean.Lsp.VersionedTextDocumentIdentifier.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.Arg.stx.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.Arg.stx, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Arg.stx]]
[Lean.Meta.Match.Alt.fvarDecls,[],[List, Lean.LocalDecl]]
[Lean.Parser.Tactic.applyField,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Nat.mul_eq,[rfl],[Eq, Nat.mul, HMul.hMul]]
[StateT.run_get,[rfl],[Eq, StateT.run, MonadState.get, Pure.pure, Prod.mk]]
[FloatArray.foldlM.loop.proof_1,[Nat.lt_of_lt_of_le],[LT.lt, FloatArray.size]]
[Lean.Meta.caseValues,[OfNat.ofNat, Array.toList, List.toArray, List.nil, Lean.Meta.caseValues.loop],[Lean.Meta.MetaM, Array, Lean.Meta.CaseValuesSubgoal]]
[List.isInfix,[Exists, Eq, HAppend.hAppend],[]]
[Lean.Meta.Rewrite.Config.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Rewrite.Config.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Rewrite.Config.mk, And]]
[Lean.Expr.and?,[Lean.Expr.app2?, Lean.Name.mkStr, Lean.Name.anonymous],[Option, Prod, Lean.Expr]]
[Iff.elim_left,[Iff.elim_left.proof_1],[]]
[ReaderT.instLawfulMonadReaderT,[ReaderT.instLawfulMonadReaderT.proof_1],[LawfulMonad, ReaderT]]
[Lean.Meta.liftMkBindingM,[Bind.bind, Lean.MonadLCtx.getLCtx, Lean.MonadMCtx.getMCtx, Lean.MonadNameGenerator.getNGen, Lean.Meta.MetaM, Lean.MetavarContext.MkBinding.State.mk, Lean.MonadNameGenerator.setNGen, Lean.MetavarContext.MkBinding.State.ngen, Lean.Meta.setMCtx, Lean.MetavarContext.MkBinding.State.mctx, Pure.pure, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM]]
[Lean.Export.OfState.modify,[],[Lean.Export.State]]
[Lean.Meta.approxDefEq,[Lean.Meta.mapMetaM, Lean.Meta.withConfig, Lean.Meta.Config.mk, Bool.true, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct],[]]
[Lean.Xml.Parser.DefaultDecl,[HOrElse.hOrElse, Lean.Parsec.skipString, SeqRight.seqRight, optional, SeqLeft.seqLeft, Lean.Xml.Parser.S, Lean.Xml.Parser.AttValue, Pure.pure, Unit.unit],[Lean.Parsec, Unit]]
[Lean.Elab.elabSetOption,[Bind.bind, Lean.MonadRef.getRef, Lean.Elab.addCompletionInfo, Lean.Elab.CompletionInfo.option, Lean.Syntax.setArgs, Array.ofSubarray, Array.toSubarray, Lean.Syntax.getArgs, OfNat.ofNat, Unit.unit, Lean.Options, Lean.Syntax.isStrLit?, Lean.DataValue.ofString, Lean.Syntax.isNatLit?, Lean.DataValue.ofNat, Lean.Syntax.missing, Lean.Syntax.node, dite, Eq, Eq.symm, Lean.Syntax.atom, Lean.Syntax.ident, Lean.DataValue.ofBool, Bool.true, Bool.false, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.elabSetOption.setOption],[Lean.Options]]
[Lean.IR.EmitC.emitExternDeclAux,[Bind.bind, Lean.IR.EmitC.getEnv, Lean.IR.EmitC.emitFnDeclAux],[Lean.IR.EmitC.M, Unit]]
[«term_$__»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Elab.Term.MVarErrorKind.implicitArg.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.MVarErrorKind.implicitArg, HAdd.hAdd, OfNat.ofNat]]
[Fin.shiftLeft.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, HShiftLeft.hShiftLeft]]
[Lean.Meta.instantiateLevelMVars,[Lean.MetavarContext.instantiateLevelMVars],[Lean.Meta.MetaM, Lean.Level]]
[Nat.zero_le,[Unit.unit, LE.le, OfNat.ofNat, Nat.le.refl, Nat.le.step, PProd.fst],[LE.le, OfNat.ofNat]]
[IO.Error.userError.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.userError, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Match.Pattern.var.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.Pattern.var, HAdd.hAdd, OfNat.ofNat]]
[instComplementUInt32,[Complement.mk, UInt32.complement],[Complement, UInt32]]
[Lean.IR.Param.noConfusionType,[],[]]
[Std.PersistentArrayNode.below,[PProd, PUnit],[]]
[Lean.AttributeImplCore.noConfusionType,[],[]]
[Lean.Elab.Tactic.getMainTarget,[Bind.bind, Lean.Elab.Tactic.getMainDecl, liftM, Lean.Meta.instantiateMVars, Lean.MetavarDecl.type],[Lean.Elab.Tactic.TacticM, Lean.Expr]]
[Lean.Xml.Parser.intSubset,[SeqRight.seqRight, Lean.Parsec.many, HOrElse.hOrElse, Lean.Xml.Parser.markupDecl, Lean.Xml.Parser.DeclSep, Pure.pure, Unit.unit],[Lean.Parsec, Unit]]
[Lean.Meta.Simp.Step.done.inj,[],[Eq]]
[Lean.FileMap.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.FileMap.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.cdot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Task.Priority.default,[OfNat.ofNat],[Task.Priority]]
[Nat.log2,[WellFounded.fix, Nat.log2.proof_1, dite, GE.ge, OfNat.ofNat, HAdd.hAdd, HDiv.hDiv, Eq.refl, Nat.zero, HEq.refl, absurd, of_decide_eq_false, Decidable.decide, Nat.succ, LT.lt, of_decide_eq_true, Bool.true, Eq.mpr, Nat.div_eq, ite, And, LE.le, HSub.hSub, if_pos, And.intro, Nat.succ_lt_succ, Nat.zero_lt_succ, Nat.lt_trans, PProd.fst, PProd.snd, Nat.lt_succ_self],[Nat]]
[Lean.PersistentEnvExtensionState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PersistentEnvExtensionState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PersistentEnvExtensionState.mk, And]]
[Lean.Elab.Term.Do.JPDecl.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.JPDecl.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.JPDecl.mk, And]]
[hasOfNatOfCoe,[OfNat.mk, coe, OfNat.ofNat],[OfNat]]
[Lean.Expr.hasSyntheticSorry,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lit, Bool, or, Lean.Expr.isSyntheticSorry, PProd.fst, PProd.snd, Bool.false],[Bool]]
[Lean.Widget.InteractiveTermGoal.toInteractiveGoal,[Lean.Widget.InteractiveGoal.mk, Lean.Widget.InteractiveTermGoal.hyps, Lean.Widget.InteractiveTermGoal.type, Option.none],[Lean.Widget.InteractiveGoal]]
[UInt32.instSemiringUInt32.proof_7,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt32.one_def, UInt32.mul_def, UInt32.mk, OfNat.ofNat, one_mul, UInt32.val, UInt32.mk_val_eq, eq_self, propext, forall_const, UInt32],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Elab.Level.Context.options,[],[Lean.Options]]
[Subtype.ext_iff_val,[Subtype.ext_iff],[Iff, Eq, Subtype.val]]
[Lean.Elab.Tactic.evalApply,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Tactic.evalApplyLikeTactic, Lean.Meta.apply, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[Lean.Lsp.MarkupContent.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.MarkupContent.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Level.instantiateParams,[Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Level, ite, Eq, Lean.Level.hasParam, Bool.true, Lean.Level.updateSucc!, PProd.fst, Lean.Level.updateMax!, PProd.snd, Lean.Level.updateIMax!, Unit.unit],[Lean.Level]]
[Lean.mkFVarEx,[Lean.mkFVar],[Lean.Expr]]
[instHAppend,[HAppend.mk, Append.append],[HAppend]]
[Lean.Elab.Term.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.InfoState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.InfoState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.InfoState.mk, And]]
[Lean.Elab.Term.CollectPatternVars.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.instToJsonInitializationOptions,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Lsp.InitializationOptions.editDelay?, List.nil],[Lean.ToJson, Lean.Lsp.InitializationOptions]]
[Lean.Elab.Term.ElabAppArgs.State.ellipsis,[],[Bool]]
[Lean.Lsp.Command.command,[],[String]]
[Lean.Elab.GoalsAtResult.useAfter,[],[Bool]]
[Lean.Elab.elabDeriving,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Unit.unit, Lean.Elab.Command.CommandElabM, Unit, OptionM.run, Array.sequenceMap, Array.getSepElems, Lean.Syntax.getArgs, Lean.Syntax.isNone, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Bind.bind, Array.mapM, Lean.Elab.resolveGlobalConstNoOverloadWithInfo, ForIn.forIn, ForInStep, Subarray, Option, Lean.Syntax, Stream.next?, Pure.pure, ForInStep.done, MonadExcept.tryCatch, Lean.withRef, and, BEq.beq, Array.size, Option.isNone, Lean.Elab.Command.liftTermElabM, Lean.Elab.Term.processDefDeriving, Array.getOp, PUnit.unit, Lean.Elab.logException, ForInStep.yield, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Lean.Parser.Tactic.itauto,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[List.card_cons_of_not_mem,[Eq.mpr, Eq.refl, Eq, ite, Mem.mem, List.card, HAdd.hAdd, OfNat.ofNat, if_neg, rfl],[Eq, List.card, List.cons, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Structural.RecArgInfo.indPred,[],[Bool]]
[Lean.ToMessageData.toMessageData,[],[Lean.MessageData]]
[List.cons_ne_self,[mt, congr_arg, List.length', Nat.succ_ne_self],[Ne, List.cons]]
[Lean.Elab.Term.Do.attachJPs,[Array.foldr, Lean.Elab.Term.Do.attachJP, Array.size, OfNat.ofNat],[Lean.Elab.Term.Do.Code]]
[Decidable.iff_iff_and_or_not_and_not,[Iff.intro, Eq.mpr, Eq.refl, Or, And, Not, propext, Decidable.em, Or.inl, And.intro, Eq.symm, Or.inr, Iff, And.right, And.left, False.elim],[Iff, Or, And, Not]]
[String.toAsciiByteArray.loop.proof_1,[Nat.Up.WF, String.utf8ByteSize],[WellFounded, Nat.Up, String.utf8ByteSize]]
[MonadLift.noConfusionType,[],[]]
[Prod.swap_swap_eq,[funext, Prod.swap_swap],[Eq, Function.comp, Prod.swap, id]]
[Lean.Elab.Structural.EqnsExtState.mk.inj,[],[Eq]]
[Decidable.of_not_imp,[Decidable.by_contradiction, not_not_of_not_imp],[]]
[UInt32.mod_def,[rfl],[Eq, HMod.hMod, UInt32.mk, UInt32.val]]
[Lean.Parser.checkNoWsBeforeFn,[ite, Eq, Lean.Parser.checkTailNoWs, Bool.true, Lean.Parser.ParserState.mkError],[Lean.Parser.ParserFn]]
[String.toUpper,[String.map, Char.toUpper],[String]]
[Lean.Parser.Term.subst,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.sepBy1, Lean.Parser.termParser, Bool.false],[Lean.Parser.TrailingParser]]
[Lean.Elab.Tactic.Conv.evalConvSeqBracketed,[Bind.bind, Lean.Elab.Tactic.mkInitialTacticInfo, Lean.Syntax.getOp, OfNat.ofNat, Lean.withRef, Lean.Elab.Tactic.closeUsingOrAdmit, Lean.Elab.withInfoContext, Pure.pure, Unit.unit, Lean.Elab.Tactic.evalManyTacticOptSemi, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Elab.Tactic.evalTactic],[Lean.Elab.Tactic.Tactic]]
[Lean.Lsp.DocumentSymbolAux.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.DocumentSymbolAux.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.LetRecDeclView.type,[],[Lean.Expr]]
[Lean.SMap.forM,[Bind.bind, Std.HashMap.forM, Lean.SMap.map₁, Std.PersistentHashMap.forM, Lean.SMap.map₂],[PUnit]]
[Std.RBNode.leaf.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Std.RBNode.leaf, OfNat.ofNat]]
[Lean.Syntax.getPos?,[Lean.SourceInfo.getPos?, Lean.Syntax.getHeadInfo],[Option, String.Pos]]
[Equiv.instCoeFunEquivArrow,[CoeFun.mk, Equiv.toFun],[CoeFun, Equiv]]
[Lean.Meta.Hypothesis.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Hypothesis.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Hypothesis.mk, And]]
[Lean.Compiler.voidType,[Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.Expr]]
[Lean.Exception.internal.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Exception.internal, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.rename,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Parser.Tactic.Conv.convRw__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq],[Lean.ParserDescr]]
[decidableOfDecidableOfIff.proof_1,[absurd, Iff.mpr],[False]]
[Lean.Parser.Tactic.locationWildcard,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Lsp.instFileSourceTextDocumentEdit,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.TextDocumentEdit.textDocument],[Lean.Lsp.FileSource, Lean.Lsp.TextDocumentEdit]]
[Or.resolve_right,[Or.elim, id, absurd],[]]
[Lean.Parser.Command.derivingClasses,[Lean.Parser.sepBy1, Lean.Parser.group, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.symbol, Lean.Parser.Term.structInst, Bool.false],[Lean.Parser.Parser]]
[IO.FS.writeFile,[Bind.bind, IO.FS.Handle.mk, IO.FS.Mode.write, Bool.false, IO.FS.Handle.putStr],[IO, Unit]]
[CoeFun.noConfusionType,[],[]]
[Lean.Meta.SizeOfSpecNested.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.Checker.checkVarType,[Bind.bind, Lean.IR.Checker.getType, Lean.IR.Checker.checkType],[Lean.IR.Checker.M, Unit]]
[Lean.Level.updateMax!,[Lean.Level.zero, Lean.Level.succ, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Level, Lean.Level.updateMax, Lean.Level.max, Lean.Level.updateMax!.proof_1, panicWithPosWithDecl, OfNat.ofNat],[Lean.Level]]
[Lean.ModuleData.noConfusionType,[],[]]
[Lean.Parser.Term.funStrictImplicitBinder.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.lookahead.formatter, Lean.Parser.Term.strictImplicitLeftBracket.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.strictImplicitRightBracket.formatter, Lean.Parser.Term.strictImplicitBinder.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.getOptionDeclsArray,[Bind.bind, Lean.getOptionDecls, Pure.pure, Std.RBMap.fold, Array.push, Prod.mk, List.toArray, List.nil],[IO, Array, Prod, Lean.Name, Lean.OptionDecl]]
[Lean.Elab.Term.resolveLocalName.loop,[Unit.unit, Option, Prod, Lean.Expr, List, String, Lean.LocalContext.findFromUserName?, Lean.MacroScopesView.review, Lean.MacroScopesView.mk, Lean.MacroScopesView.imported, Lean.MacroScopesView.mainModule, Lean.MacroScopesView.scopes, ite, Eq, and, Lean.LocalDecl.isAuxDecl, not, List.isEmpty, Bool.true, Option.none, Option.some, Prod.mk, Lean.LocalDecl.toExpr, Lean.Name.anonymous, Lean.Name.num, PProd.fst, List.cons],[Option, Prod, Lean.Expr, List, String]]
[Except.mapError,[Except, Except.error, Except.ok],[Except]]
[List.forIn_nil,[rfl],[Eq, ForIn.forIn, List.nil, Pure.pure]]
[Lean.ClassState.mk.inj,[],[Eq]]
[Lean.PrettyPrinter.Delaborator.ParamKind.noConfusionType,[],[]]
[Lean.IR.ExplicitBoxing.castArgsIfNeeded,[Bind.bind, Lean.IR.ExplicitBoxing.castArgsIfNeededAux, Lean.IR.Param.ty, Array.getOp, Lean.IR.ExplicitBoxing.M, Lean.IR.FnBody, Pure.pure, Lean.IR.reshape],[Lean.IR.ExplicitBoxing.M, Lean.IR.FnBody]]
[Lean.Elab.Term.Do.hasBreakContinueReturn,[Lean.Elab.Term.Do.hasExitPointPred, Lean.Elab.Term.Do.Code.decl, Lean.Elab.Term.Do.Code.reassign, Lean.Elab.Term.Do.Code.joinpoint, Lean.Elab.Term.Do.Code.seq, Lean.Elab.Term.Do.Code.action, Lean.Elab.Term.Do.Code.ite, Lean.Elab.Term.Do.Code.match, Lean.Elab.Term.Do.Code.jmp, Bool, Bool.true, Bool.false],[Bool]]
[ltOfOrd,[LT.mk, Eq, BEq.beq, Ord.compare, Ordering.lt, Bool.true],[LT]]
[Xor.noConfusionType,[],[]]
[Lean.Parser.ParserExtension.addEntryImpl,[Lean.Parser.ParserExtension.State, Except.error, ite, Eq, BEq.beq, Bool.true, MonadExcept.throw, Unit.unit, Except, String, Lean.Parser.TokenTable, Lean.Parser.Trie.find?, Pure.pure, Lean.Parser.Trie.insert, Lean.Parser.ParserExtension.State.tokens, Lean.Parser.ParserExtension.State.mk, Lean.Parser.ParserExtension.State.kinds, Lean.Parser.ParserExtension.State.categories, panicWithPosWithDecl, OfNat.ofNat, Lean.Parser.SyntaxNodeKindSet.insert, Std.PersistentHashMap.contains, Std.PersistentHashMap.insert, Lean.Parser.ParserCategory.mk, Lean.Parser.PrattParsingTables.mk, Lean.Parser.addParser],[Lean.Parser.ParserExtension.State]]
[Lean.Widget.CodeWithInfos,[Lean.Widget.TaggedText, Lean.Widget.CodeToken],[]]
[Lean.Elab.Term.StructInst.Struct.source,[Lean.Elab.Term.StructInst.Source],[Lean.Elab.Term.StructInst.Source]]
[Lean.Elab.Term.StructInst.FieldLHS.toSyntax,[Lean.Syntax, ite, Eq, Bool.true, Lean.mkIdentFrom, Lean.mkGroupNode, List.toArray, List.cons, Lean.mkAtomFrom, List.nil],[Lean.Syntax]]
[Lean.Elab.Term.setElabConfig,[Lean.Meta.Config.mk, Bool.true, Bool.false, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct],[Lean.Meta.Config]]
[Array.findSome!,[Unit.unit, Array.findSome?, panicWithPosWithDecl, OfNat.ofNat],[]]
[Prod.forall',[Prod.forall],[Iff, Prod.fst, Prod.snd]]
[Lean.Elab.Command.elabCommandTopLevel,[Lean.withRef, Bind.bind, MonadState.modifyGet, Prod.mk, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.MessageLog.mk, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Lean.Elab.getResetInfoTrees, Lean.Elab.Command.withLogging, Lean.Elab.Command.runLinters, Lean.Elab.Command.elabCommand, MonadState.get, Pure.pure, Lean.MonadOptions.getOptions, ite, Eq, and, not, Lean.Option.get, Lean.Elab.Command.showPartialSyntaxErrors, Lean.MessageLog.hasErrors, Lean.Syntax.hasMissing, Bool.true, PUnit.unit],[Lean.Elab.Command.CommandElabM, Unit]]
[Lean.Parser.Term.typeSpec,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.KernelException.letTypeMismatch.inj,[And.intro],[And, Eq]]
[List.ne_nil_of_length_pos,[Nat.lt_irrefl, OfNat.ofNat, Eq.subst, Iff.mpr, List.length_eq_zero],[Ne, List.nil]]
[StateT.instLawfulMonadStateT,[StateT.instLawfulMonadStateT.proof_1],[LawfulMonad, StateT]]
[Lean.Syntax.setTailInfo,[Unit.unit, Lean.Syntax, Lean.Syntax.setTailInfoAux],[Lean.Syntax]]
[Lean.Meta.CaseValueSubgoal.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Tactic.ElimApp.M,[ReaderT, Lean.Elab.Tactic.ElimApp.Context, StateRefT', IO.RealWorld, Lean.Elab.Tactic.ElimApp.State, Lean.Elab.Term.TermElabM],[]]
[Lean.Meta.mkLevelStuckErrorMessage,[Unit.unit, Lean.Meta.MetaM, Lean.MessageData, Lean.Meta.PostponedEntry.ctx?, Pure.pure, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.Meta.PostponedEntry.lhs, Lean.Meta.PostponedEntry.rhs, Lean.Meta.withLCtx, Lean.Meta.DefEqContext.lctx, Lean.Meta.DefEqContext.localInstances, Bind.bind, Lean.Meta.instantiateMVars, Lean.Meta.DefEqContext.lhs, Lean.Meta.DefEqContext.rhs, MonadExcept.tryCatch, Lean.Meta.inferType, Lean.AddMessageContext.addMessageContext, Lean.MessageData.ofExpr],[Lean.Meta.MetaM, Lean.MessageData]]
[Lean.Meta.Hypothesis.value,[],[Lean.Expr]]
[Std.PersistentHashMap.Stats.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Tactic.ElabSimpArgsResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.ElabSimpArgsResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Tactic.ElabSimpArgsResult.mk, And]]
[Lean.Lsp.ReferenceParams.noConfusionType,[],[]]
[Lean.Meta.DefaultInstances.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.DefaultInstances.mk, HAdd.hAdd, OfNat.ofNat]]
[ExceptT.mk,[],[ExceptT]]
[Lean.Lsp.RpcCallParams.mk.inj,[And.intro],[And, Eq]]
[GroupWithZero.inv_zero,[],[Eq, Inv.inv, OfNat.ofNat]]
[Lean.PrettyPrinter.parenthesizeTerm,[Lean.PrettyPrinter.parenthesize, Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat],[Lean.Core.CoreM, Lean.Syntax]]
[instIsAddRightCancel,[IsAddRightCancel.mk, instIsAddRightCancel.proof_1],[IsAddRightCancel]]
[Lean.Meta.cleanup.collectPropsStep,[Bind.bind, MonadState.get, Lean.MonadLCtx.getLCtx, ForIn.forIn, PUnit.unit, liftM, Lean.Meta.isProp, Lean.LocalDecl.type, ite, Eq, Bool.true, Lean.Meta.dependsOnPred, Std.RBTree.contains, Lean.Meta.cleanup.addUsedFVar, Lean.LocalDecl.fvarId, Pure.pure, ForInStep.yield],[StateRefT', IO.RealWorld, Prod, Bool, Lean.FVarIdSet, Lean.Meta.MetaM, Unit]]
[Lean.Elab.Info.isCompletion,[Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofTermInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Widget.Lean.Widget.InteractiveGoals.instRpcEncodingInteractiveGoalsRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Lean.Widget.InteractiveGoals.goals, Pure.pure, Lean.Server.RpcEncoding.rpcDecode, Lean.Widget.InteractiveGoals.mk],[Lean.Server.RpcEncoding, Lean.Widget.InteractiveGoals]]
[termℕ,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Expr.replaceFVars,[Lean.Expr.instantiateRev, Lean.Expr.abstract],[Lean.Expr]]
[Lean.Lsp.DefinitionParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.DefinitionParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Attr.externEntry.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.strLit.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.matcherTy,[],[Lean.Expr]]
[Lean.ConstantInfo.levelParams,[Lean.ConstantVal.levelParams, Lean.ConstantInfo.toConstantVal],[List, Lean.Name]]
[Lean.instReprLiteral,[Repr.mk, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, HAppend.hAppend, Std.Format.text, Std.Format.line, reprArg, Std.Format.FlattenBehavior.allOrNone],[Repr, Lean.Literal]]
[Lean.Elab.Term.expandAssert,[Unit.unit, Lean.MacroM, Lean.Syntax, Lean.Syntax.reprint, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Quote.quote],[Lean.Macro]]
[map_congr,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Functor.map, funext, eq_self],[Eq, Functor.map]]
[Lean.Meta.isMatcherCore,[Option.isSome, Lean.Meta.getMatcherInfoCore?],[Bool]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.info,[],[Lean.Meta.Match.MatcherInfo]]
[Int.decLt,[Decidable, Int.NonNeg, Decidable.isTrue, Int.NonNeg.mk, Decidable.isFalse, Eq.refl, Int.negSucc, HEq.refl, False, HSub.hSub, HAdd.hAdd, OfNat.ofNat],[Decidable, LT.lt]]
[mt,[],[Not]]
[Lean.instInhabitedExprStructEq,[Inhabited.mk, Lean.ExprStructEq.mk, arbitrary],[Inhabited, Lean.ExprStructEq]]
[Lean.Meta.MVarRenaming.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.MVarRenaming.mk, HAdd.hAdd, OfNat.ofNat]]
[String.foldr,[String.foldrAux, String.bsize, OfNat.ofNat],[]]
[Lean.Meta.mkOfEqTrue,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Meta.Match.Unify.Context.noConfusionType,[],[]]
[Lean.Meta.IndPredBelow.mkBelowMatcher.addBelowPattern,[Lean.Meta.withExistingLocalDecls, Lean.Meta.Match.AltLHS.fvarDecls, Bind.bind, Lean.Meta.IndPredBelow.mkBelowMatcher.convertToBelow, Array.getOp, Lean.Meta.MetaM, Lean.Meta.Match.AltLHS, Array.toList, Lean.Meta.IndPredBelow.mkBelowMatcher.toInaccessible, Pure.pure, Lean.Meta.Match.AltLHS.mk, Lean.Meta.Match.AltLHS.ref, HAppend.hAppend],[Lean.Meta.MetaM, Lean.Meta.Match.AltLHS]]
[Lean.Lsp.InitializeParams.clientInfo?,[],[Option, Lean.Lsp.ClientInfo]]
[Lean.Parser.Tactic.rotate,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.resolveGlobalName,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, Pure.pure, Lean.ResolveName.resolveGlobalName],[List, Prod, Lean.Name, String]]
[Lean.instCoeNatDataValue,[Coe.mk, Lean.DataValue.ofNat],[Coe, Nat, Lean.DataValue]]
[Lean.MetavarContext.instInhabitedMetavarContext,[Inhabited.mk, Lean.MetavarContext.mk],[Inhabited, Lean.MetavarContext]]
[Lean.Lsp.instToJsonMarkupContent,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.MarkupContent.kind, List.nil, Lean.Lsp.MarkupContent.value],[Lean.ToJson, Lean.Lsp.MarkupContent]]
[Lean.PrettyPrinter.Parenthesizer.visitToken,[Bind.bind, modify, Lean.PrettyPrinter.Parenthesizer.State.mk, Lean.PrettyPrinter.Parenthesizer.State.stxTrav, Option.none, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.State.minPrec, Lean.PrettyPrinter.Parenthesizer.State.trailPrec, Lean.PrettyPrinter.Parenthesizer.State.trailCat, Bool.true, Lean.Syntax.MonadTraverser.goLeft],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Command.adaptExpander,[Bind.bind, Lean.Elab.Command.withMacroExpansion, Lean.Elab.Command.elabCommand],[Lean.Elab.Command.CommandElab]]
[Lean.Elab.Term.expandUnreachable,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.Macro]]
[Lean.ScopedEnvExtension.StateStack.newEntries,[],[List, Lean.ScopedEnvExtension.Entry]]
[Lean.MVarId.noConfusionType,[],[]]
[Lean.IR.CtorLayout.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.CtorLayout.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.CtorLayout.mk, And]]
[Mathlib.Tactic.Lint.Linter.mk.inj,[And.intro],[And, Eq]]
[Lean.Xml.Parser.TokenizedType,[HOrElse.hOrElse, Lean.Parsec.skipString],[Lean.Parsec, Unit]]
[List.erase_nil,[rfl],[Eq, List.erase, List.nil]]
[List.exists_mem_cons_of,[Exists.intro, And.intro, List.mem_cons_self],[Exists, And, Mem.mem, List.cons]]
[String.set,[String, String.mk, List, Char, List.nil, ite, Eq, List.cons, PProd.fst, HAdd.hAdd, String.csize, OfNat.ofNat],[String]]
[Lean.Server.FileWorker.SemanticTokensContext.noConfusionType,[],[]]
[instDecidableRelLeLeOfOrd,[inferInstanceAs, DecidableRel, Eq, Ordering.isLE, Ord.compare, Bool.true],[DecidableRel, LE.le]]
[List.disjoint_comm,[Iff.intro, List.disjoint_symm],[Iff, List.disjoint]]
[Lean.Expr.updateLet!.proof_1,[rfl],[Eq, Lean.Expr.isLet, Lean.Expr.letE]]
[Lean.Elab.Term.StructInst.Field.lhs,[],[List, Lean.Elab.Term.StructInst.FieldLHS]]
[Lean.Elab.Tactic.isHoleRHS,[or, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous],[Bool]]
[Lean.Json.bool.injEq,[Eq.propIntro, Eq.refl, Lean.Json.bool, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Json.bool]]
[Lean.Name.simpMacroScopes,[Unit.unit, Lean.Name, Lean.Name.hasMacroScopes, Lean.Name.anonymous, Lean.Name.str, Lean.Name.mkNum, PProd.fst, BEq.beq],[Lean.Name]]
[Nat.mod_lt,[Nat.mod.inductionOn],[LT.lt, HMod.hMod]]
[List.erase_eq_erasep,[rfl, Classical.em, Eq, of_eq_true, Eq.trans, congr, congrArg, List.erase, List.cons, List.erase_cons_head, List.erasep_cons_of_pos, congrFun, eq_self, Eq.symm, List.erase_cons_tail, ne_eq, Not, eq_false, Ne.symm, eq_true_of_decide, Eq.refl, Bool.true, List.erasep_cons_of_neg, List.erasep],[Eq, List.erase, List.erasep]]
[Lean.Parser.Tactic.Conv.guardLHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Nat.add_le_add_left,[LE.le, HAdd.hAdd, Nat.le.dest],[LE.le, HAdd.hAdd]]
[IO.withStdin,[Bind.bind, liftM, IO.setStdin, tryFinally, Functor.discard],[]]
[Lean.Parser.skip,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo],[Lean.Parser.Parser]]
[Lean.Parser.Term.letDecl.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.notFollowedBy.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.letIdDecl.parenthesizer, Lean.Parser.Term.letPatDecl.parenthesizer, Lean.Parser.Term.letEqnsDecl.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Std.PersistentArray.any,[Id.run, Std.PersistentArray.anyM],[Bool]]
[Lean.Lsp.instToJsonWorkDoneProgressReport,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.WorkDoneProgressReport.kind, List.nil, Lean.Json.opt, Lean.Lsp.WorkDoneProgressReport.message?, Lean.Lsp.WorkDoneProgressReport.cancellable, Lean.Lsp.WorkDoneProgressReport.percentage?],[Lean.ToJson, Lean.Lsp.WorkDoneProgressReport]]
[List.partition,[List.partitionAux, Prod.mk, List.nil],[Prod, List]]
[Lean.instToMessageDataString,[Lean.ToMessageData.mk, Lean.stringToMessageData],[Lean.ToMessageData, String]]
[Std.PersistentArray.allM,[Bind.bind, Std.PersistentArray.anyM, Pure.pure, not],[Bool]]
[Lean.OpaqueVal.value,[],[Lean.Expr]]
[instOrOpUSize,[OrOp.mk, USize.lor],[OrOp, USize]]
[Lean.Parser.instCoeStringParser,[Coe.mk, Lean.Parser.symbol],[Coe, String, Lean.Parser.Parser]]
[Lean.Server.RequestContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.RequestContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.RequestContext.mk, And]]
[Lean.Meta.throwUnknownMVar,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MVarId.name],[Lean.Meta.MetaM]]
[Lean.ParserCompiler.registerCombinatorAttribute,[Bind.bind, Lean.registerSimplePersistentEnvExtension, Lean.SimplePersistentEnvExtensionDescr.mk, Lean.NameMap.insert, Prod.fst, Prod.snd, Lean.mkStateFromImportedEntries, EmptyCollection.emptyCollection, Lean.registerBuiltinAttribute, Pure.pure, Lean.ParserCompiler.CombinatorAttribute.mk],[IO, Lean.ParserCompiler.CombinatorAttribute]]
[Lean.IR.ExplicitBoxing.BoxingState.noConfusionType,[],[]]
[HAnd.noConfusionType,[],[]]
[Lean.Expr.getRevArg!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, PProd.fst, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[Char.utf16Size,[ite, LE.le, Char.val, OfNat.ofNat],[UInt32]]
[not_true,[iff_false_intro, not_not_intro, trivial],[Iff, Not, True, False]]
[Lean.Elab.Modifiers.isUnsafe,[],[Bool]]
[Subtype.noConfusionType,[],[]]
[Lean.Elab.Command.hasNoErrorMessages,[Bind.bind, MonadState.get, Pure.pure, not, Lean.MessageLog.hasErrors, Lean.Elab.Command.State.messages],[Lean.Elab.Command.CommandElabM, Bool]]
[Lean.KVMap.getInt,[Option.none, Option.some, Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofName, Lean.DataValue.ofNat, Int, Lean.KVMap.find],[Int]]
[Lean.StructureInfo.fieldInfo,[],[Array, Lean.StructureFieldInfo]]
[instReprProd,[Repr.mk, Std.Format, Std.Format.bracket, Std.Format.joinSep, List.reverse, ReprTuple.reprTuple, List.cons, repr, List.nil, HAppend.hAppend, Std.Format.text, Std.Format.line],[Repr, Prod]]
[Lean.Elab.Term.NamedArg.noConfusionType,[],[]]
[Lean.Meta.AbstractNestedProofs.Context.baseName,[],[Lean.Name]]
[Lean.Elab.Term.PatternElabException.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.PatternElabException.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.logMessage,[Bind.bind, MonadReader.read, ite, Eq, Option.none, Option.some, Lean.DataValue.ofString, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Bool, Lean.KVMap.find, Lean.KVMap.getBool, Lean.IR.tracePrefixOptionName, Bool.false, Bool.true, Lean.IR.log, Lean.IR.LogEntry.message, Std.ToFormat.format, Pure.pure, PUnit.unit],[Lean.IR.CompilerM, Unit]]
[Lean.Meta.matchConstructorApp?,[Bind.bind, Lean.MonadEnv.getEnv, Lean.Meta.matchHelper?, Pure.pure, Lean.Expr.isConstructorApp?],[Lean.Meta.MetaM, Option, Lean.ConstructorVal]]
[Lean.Elab.Term.LVal.getRef,[Lean.Syntax],[Lean.Syntax]]
[Lean.Parser.antiquotNestedExpr,[Lean.Parser.node, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.symbolNoAntiquot, Lean.Parser.decQuotDepth, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.Meta.DiscrTree.Key.proj.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.DiscrTree.Key.proj, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.DiscrTree.Key.proj, And]]
[Sigma.snd,[],[Sigma.fst]]
[Lean.Parser.Tactic.squeezeSimpa!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Array.toArrayLit.proof_1,[Nat.le_refl, Array.size],[LE.le, Array.size]]
[iff_false,[propext, Iff.intro, Iff.mp, False.elim],[Eq, Iff, False, Not]]
[Lean.Elab.Term.Do.mkSingletonDoSeq,[Lean.Elab.Term.Do.mkDoSeq, List.toArray, List.cons, List.nil],[Lean.Syntax]]
[Lean.LocalContext.setUserName,[Lean.LocalContext.mk, Std.PersistentHashMap.insert, Lean.LocalContext.fvarIdToDecl, Lean.LocalDecl.fvarId, Std.PersistentArray.set, Lean.LocalContext.decls, Lean.LocalDecl.index, Option.some],[Lean.LocalContext]]
[Lean.Parser.nonReservedSymbolInfo,[Lean.Parser.ParserInfo.mk, ite, Eq, Bool.true, Lean.Parser.FirstTokens.tokens, List.cons, List.nil],[Lean.Parser.ParserInfo]]
[UInt16.instSemigroupUInt16.proof_1,[congrArg, UInt16.mk, Semigroup.mul_assoc, UInt16.val],[Eq, UInt16.mk]]
[Lean.Parser.Tactic.propagateTags,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[String.anyAux,[String.anyAux.loop],[Bool]]
[«command_ClassAbbrev__:_:=__,»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.IR.Borrow.BorrowInfState.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.optSemicolon.parenthesizer,[Lean.Parser.ppDedent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ppLine.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.Simp.Step.visit.inj,[],[Eq]]
[Lean.Elab.Tactic.Conv.convert,[Bind.bind, liftM, Lean.Elab.Tactic.Conv.mkConvGoalFor, Lean.Elab.Tactic.TacticM, Prod, Lean.Expr, Lean.Elab.Tactic.getGoals, tryFinally, Lean.Elab.Tactic.setGoals, List.cons, Lean.Expr.mvarId!, List.nil, ForIn.forIn, PUnit.unit, MonadExcept.tryCatch, Lean.Meta.applyRefl, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Pure.pure, Unit.unit, ForInStep.yield, Lean.Elab.Tactic.pruneSolvedGoals, ite, Eq, List.isEmpty, Bool.true, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.goalsToMessageData, Lean.Meta.instantiateMVars, Prod.mk],[Lean.Elab.Tactic.TacticM, Prod, Lean.Expr]]
[exists_eq_left,[Iff.intro, Exists.intro, And.intro, rfl],[Iff, Exists, And, Eq]]
[ByteArray.instInhabitedByteArray,[Inhabited.mk, ByteArray.empty],[Inhabited, ByteArray]]
[Lean.Meta.resettingSynthInstanceCacheWhen,[ite, Eq, Bool.true, Lean.Meta.resettingSynthInstanceCache],[]]
[Lean.Elab.Command.mkDefViewOfAbbrev,[Lean.Elab.DefView, Lean.Elab.DefView.mk, Lean.Elab.DefKind.abbrev, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Elab.DefView]]
[Lean.Elab.Info.ofCompletionInfo.inj,[],[Eq]]
[Lean.Lsp.DiagnosticCode.noConfusionType,[],[]]
[Lean.Elab.Term.Do.getPatternsVarsEx,[HOrElse.hOrElse, Functor.map, Lean.Elab.Term.getPatternVarNames, Lean.Elab.Term.getPatternsVars, Array.map, Lean.Syntax.getId, Lean.Elab.Term.Quotation.getPatternsVars],[Lean.Elab.Term.TermElabM, Array, Lean.Name]]
[Lean.Expr.ReplaceImpl.cacheSize,[OfNat.ofNat],[USize]]
[Lean.MetavarKind.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Meta.InfoCacheKey.mk.inj,[And.intro],[And, Eq]]
[List.exists_mem_cons_iff,[Iff.intro, List.or_exists_of_exists_mem_cons, Or.elim, List.exists_mem_cons_of, List.exists_mem_cons_of_exists],[Iff, Exists, And, Mem.mem, List.cons, Or]]
[Lean.Parser.getUnaryAlias,[Bind.bind, Lean.Parser.getAlias, Unit.unit, Lean.Parser.AliasValue.const, Lean.Parser.AliasValue.binary, IO, Pure.pure, MonadExcept.throw, coe, HAppend.hAppend, ToString.toString],[IO]]
[Lean.markBorrowed,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Expr]]
[Lean.Meta.SynthInstance.SubgoalsResult.instTypeBody,[],[Lean.Expr]]
[Prod.noConfusionType,[],[]]
[Lean.Json.CompressWorkItem.objectField.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Json.CompressWorkItem.objectField, HAdd.hAdd, OfNat.ofNat]]
[pow_one,[Eq.mpr, Eq.refl, Eq, HPow.hPow, OfNat.ofNat, Nat.one_eq_succ_zero, Nat.succ, pow_succ, HMul.hMul, pow_zero, one_mul, rfl],[Eq, HPow.hPow, OfNat.ofNat]]
[Lean.Server.FileWorker.RefIdent.const.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.FileWorker.RefIdent.const, HAdd.hAdd, OfNat.ofNat]]
[Lean.SimplePersistentEnvExtension.getState,[Prod.snd, Lean.PersistentEnvExtension.getState],[]]
[Prod.fst_eq_iff,[Iff, Eq, Prod.fst, Prod.mk, Prod.snd, of_eq_true, Eq.trans, congrArg, Prod.mk.injEq, And, eq_self, and_true, iff_self],[Iff, Eq, Prod.fst, Prod.mk, Prod.snd]]
[Lean.Meta.splitIfTarget?,[Lean.commitWhenSome?, Bind.bind, Lean.Meta.getMVarType, Lean.Meta.SplitIf.splitIfAt?, Option.none, Lean.Meta.MetaM, Option, Prod, Lean.Meta.ByCasesSubgoal, Lean.Meta.simpIfTarget, Lean.Meta.ByCasesSubgoal.mvarId, Bool.false, ite, Eq, and, BEq.beq, Bool.true, Pure.pure, Option.some, Prod.mk, Lean.Meta.ByCasesSubgoal.mk, Lean.Meta.ByCasesSubgoal.fvarId],[Lean.Meta.MetaM, Option, Prod, Lean.Meta.ByCasesSubgoal]]
[Lean.Parser.Term.explicitBinder,[Lean.Parser.ppGroup, Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.Term.binderIdent, Lean.Parser.Term.binderType, Lean.Parser.optional, HOrElse.hOrElse, Lean.Parser.Term.binderTactic, Lean.Parser.Term.binderDefault],[Lean.Parser.Parser]]
[Lean.Meta.getLevelMVarDepth,[Bind.bind, Lean.MonadMCtx.getMCtx, Option.none, Lean.Meta.MetaM, Nat, Lean.MetavarContext.findLevelDepth?, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MVarId.name],[Lean.Meta.MetaM, Nat]]
[Lean.Level.isExplicit,[Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Bool, Bool.true, and, not, Lean.Level.hasMVar, Lean.Level.hasParam, PProd.fst, Bool.false],[Bool]]
[Lean.Parser.Tactic.Conv.normCast,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Elab.Term.elabCommandQuot,[Lean.Elab.Term.adaptExpander, Lean.Elab.Term.Quotation.stxQuot.expand],[Lean.Elab.Term.TermElab]]
[Lean.Json.CompressWorkItem.json.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Json.CompressWorkItem.json, HAdd.hAdd, OfNat.ofNat]]
[Mathlib.Tactic.Lint.getChecks,[ite, Eq, Bool.true, Bind.bind, Pure.pure, List.nil, Lean.MonadEnv.getEnv, Lean.TagAttribute.getDecls, Mathlib.Tactic.Lint.mathlibLinterAttr, Mathlib.Tactic.Lint.getLinters, Array.toList],[Lean.Core.CoreM, List, Mathlib.Tactic.Lint.NamedLinter]]
[mul_right_inv,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Inv.inv, OfNat.ofNat, Eq.symm, mul_left_inv, inv_inv, rfl],[Eq, HMul.hMul, Inv.inv, OfNat.ofNat]]
[Lean.Elab.Command.StructView.fields,[],[Array, Lean.Elab.Command.StructFieldView]]
[Lean.Parser.Tactic.continuity?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Meta.Simp.Config.eta,[],[Bool]]
[Lean.EnvironmentHeader.trustLevel,[],[UInt32]]
[Lean.Parser.Command.universe.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Compiler.BinFoldFn,[Option, Lean.Expr],[]]
[List.append_eq_appendTR,[funext, rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, List.cons, List.reverseAux_reverseAux, List.nil, eq_self, List.reverseAux],[Eq, List.append, List.appendTR]]
[Lean.Elab.InfoTree.termGoalAt?,[Lean.Elab.InfoTree.smallestInfo?, Id.run, ite, Eq, Lean.Elab.Info.contains, Bool.true, Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.Info.ofCompletionInfo, Id, Bool, Pure.pure, or, not, Lean.Syntax.isIdent, Lean.Elab.ElabInfo.stx, Lean.Elab.TermInfo.toElabInfo, Std.HashSet.contains, Option.get!, Lean.Elab.Info.pos?, Bind.bind, PUnit.unit, Lean.Elab.InfoTree.termGoalAt?.getHeadFnPos?],[Option, Prod, Lean.Elab.ContextInfo, Lean.Elab.Info]]
[max,[ite, LT.lt],[]]
[System.SearchPath.toString,[String.intercalate, Char.toString, System.SearchPath.separator, List.map, System.FilePath.toString],[String]]
[Lean.Name.replacePrefix,[Lean.Name.str, Lean.Name.num, Lean.Name, Lean.Name.anonymous, ite, Eq, BEq.beq, Bool.true, Lean.Name.mkStr, PProd.fst, Lean.Name.mkNum],[Lean.Name]]
[Dvd.noConfusionType,[],[]]
[Int.subNatNat_sub,[Eq.mpr, Eq.refl, Eq, Int.subNatNat, HSub.hSub, HAdd.hAdd, Eq.symm, Int.subNatNat_add_add, Nat.sub_add_cancel, rfl],[Eq, Int.subNatNat, HSub.hSub, HAdd.hAdd]]
[Lean.Lsp.instFromJsonLeanFileProgressProcessingInfo,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.Range, Pure.pure, Lean.Lsp.LeanFileProgressProcessingInfo.mk],[Lean.FromJson, Lean.Lsp.LeanFileProgressProcessingInfo]]
[Lean.Elab.Term.Do.ToTerm.reassignToTerm,[Lean.withRef, Lean.MonadQuotation.withFreshMacroScope, ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.getKind, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Lean.Quote.quote, List.nil, Lean.Macro.throwErrorAt],[Lean.MacroM, Lean.Syntax]]
[List.card_nil,[rfl],[Eq, List.card, List.nil, OfNat.ofNat]]
[Lean.Meta.RecursorInfo.mk.inj,[And.intro],[And, Eq]]
[Mathlib.Tactic.Lint.NamedLinter.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Mathlib.Tactic.Lint.NamedLinter.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Mathlib.Tactic.Lint.NamedLinter.mk, And]]
[IO.AccessRight.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.AccessRight.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.levelParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.Match.counterExamplesToMessageData,[Lean.MessageData.joinSep, List.map, Lean.Meta.Match.counterExampleToMessageData, Lean.MessageData.ofFormat, Std.Format.line],[Lean.MessageData]]
[Lean.Meta.isMatcherAppCore?,[ite, Eq, Lean.Expr.isConst, Bool.true, Option.none, Option, Lean.Meta.Match.MatcherInfo, Lean.Meta.getMatcherInfoCore?, Lean.Expr.constName!, GE.ge, Lean.Expr.getAppNumArgs, Lean.Meta.Match.MatcherInfo.arity, Option.some],[Option, Lean.Meta.Match.MatcherInfo]]
[Lean.Elab.WF.TerminationStrategy.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.WF.TerminationStrategy.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.pred_lt,[LT.lt, Nat.pred, absurd, rfl, Nat.lt_succ_of_le, Nat.le_refl, Nat.succ],[LT.lt, Nat.pred]]
[Lean.Elab.Term.MVarErrorInfo.logError,[Unit.unit, Lean.Elab.Term.TermElabM, Unit, Lean.Elab.Term.MVarErrorInfo.kind, Bind.bind, liftM, Lean.Meta.instantiateMVars, Lean.Elab.logErrorAt, Lean.Elab.Term.MVarErrorInfo.ref, Lean.MessageData.tagged, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.Term.MVarErrorInfo.logError.addArgName, Lean.Elab.Term.MVarErrorInfo.logError.appendExtra],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.instInhabitedContext,[Inhabited.mk, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk, arbitrary],[Inhabited, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context]]
[Lean.PrettyPrinter.Delaborator.delabMVar,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, liftM, Lean.Meta.getMVarDecl, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Lean.mkIdent, List.nil, panicWithPosWithDecl, OfNat.ofNat],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.Server.FileWorker.handleSemanticTokensFull,[Lean.Server.FileWorker.handleSemanticTokens, OfNat.ofNat, HShiftLeft.hShiftLeft],[Lean.Server.RequestM, Lean.Server.RequestTask, Lean.Lsp.SemanticTokens]]
[Lean.Parser.Command.macroTail.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.macroTailTactic.formatter, Lean.Parser.Command.macroTailCommand.formatter, Lean.Parser.Command.macroTailDefault.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Structural.State.addMatchers,[],[Array, Lean.Meta.MetaM, Unit]]
[Lean.getPPUniverses,[Lean.KVMap.get, Lean.Option.name, Lean.pp.universes, Lean.getPPAll],[Bool]]
[PSigma.revLexAccessible.proof_1,[Acc.intro, PSigma.mk, Eq.symm, eq_of_heq, Eq.refl, HEq.refl],[Acc, PSigma.RevLex, PSigma.mk]]
[Lean.Elab.instInhabitedDefKind,[Inhabited.mk, Lean.Elab.DefKind.def],[Inhabited, Lean.Elab.DefKind]]
[Lean.instInhabitedLocalInstance,[Inhabited.mk, Lean.LocalInstance.mk, arbitrary],[Inhabited, Lean.LocalInstance]]
[Lean.instInhabitedOptions,[Inhabited.mk, Lean.KVMap.mk],[Inhabited, Lean.Options]]
[Lean.Meta.instReprElimInfo,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.Meta.ElimInfo.name, Std.Format.line, Lean.Meta.ElimInfo.motivePos, Lean.Meta.ElimInfo.targetsPos, Lean.Meta.ElimInfo.altsInfo],[Repr, Lean.Meta.ElimInfo]]
[Lean.Parser.Tactic.Conv.convConvSeq,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[Lean.ConstantInfo.name,[Lean.ConstantVal.name, Lean.ConstantInfo.toConstantVal],[Lean.Name]]
[Lean.Elab.ContextInfo.options,[],[Lean.Options]]
[Lean.Syntax.getAntiquotSpliceContents,[Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat],[Array, Lean.Syntax]]
[Lean.Lsp.TextDocumentSyncKind.incremental.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.TextDocumentSyncKind.incremental, OfNat.ofNat]]
[Lean.EnumAttributes.getValue,[Unit.unit, Option, Lean.Environment.getModuleIdxFor?, Array.binSearch, Lean.PersistentEnvExtension.getModuleEntries, Lean.EnumAttributes.ext, Prod.mk, arbitrary, Lean.Name.quickLt, Prod.fst, OfNat.ofNat, HSub.hSub, Array.size, Option.some, Option.none, Lean.NameMap.find?, Lean.PersistentEnvExtension.getState],[Option]]
[Lean.Syntax.MonadTraverser.getCur,[Functor.map, Lean.Syntax.Traverser.cur, MonadState.get],[Lean.Syntax]]
[Lean.PrettyPrinter.Parenthesizer.liftCoreM,[liftM],[Lean.PrettyPrinter.ParenthesizerM]]
[Lean.Meta.ReduceMatcherResult.stuck.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.ReduceMatcherResult.stuck, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.ReduceMatcherResult.stuck]]
[or_not,[em],[Or, Not]]
[instInhabitedExcept,[Inhabited.mk, Except.error, arbitrary],[Inhabited, Except]]
[Nat.instCommSemiringNat.proof_1,[of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.succ_mul, Nat.add_comm, HMul.hMul, eq_self, HAdd.hAdd],[Eq, HMul.hMul, Nat.succ, HAdd.hAdd]]
[Lean.withImportModules,[Bind.bind, Lean.importModules, tryFinally, Lean.Environment.freeRegions],[IO]]
[Function.surjective.has_right_inverse,[Exists.intro, Function.surj_inv, Function.right_inverse_surj_inv],[Function.has_right_inverse]]
[Lean.Lsp.PlainGoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.PlainGoal.mk, HAdd.hAdd, OfNat.ofNat]]
[not_forall,[Decidable.not_forall],[Iff, Not, Exists]]
[Std.Format.tag.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.Format.tag, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.Format.tag, And]]
[String.Iterator.extract,[String, ite, Eq, or, Decidable.decide, Ne, GT.gt, Bool.true, String.extract],[String]]
[Lean.IR.NormalizeIds.normJP,[Functor.map, Lean.IR.JoinPointId.mk, Lean.IR.NormalizeIds.normIndex, Lean.IR.JoinPointId.idx],[Lean.IR.NormalizeIds.M, Lean.IR.JoinPointId]]
[Std.mkHashSet,[Subtype.mk, Std.mkHashSetImp, Std.HashSetImp.WellFormed.mkWff],[Std.HashSet]]
[Nat.gcd,[WellFounded.fix, Nat.gcd.proof_1, Unit.unit, Nat, HMod.hMod, Nat.succ, Nat.mod_lt, Nat.zero_lt_succ],[Nat]]
[Lean.Compiler.atMostOnce.AtMostOnceData.result,[],[Bool]]
[Std.RBNode.balLeft,[Std.RBNode.leaf, Std.RBNode.node, Std.Rbcolor.red, Std.Rbcolor.black, Std.RBNode, Std.RBNode.balance₃, Std.RBNode.setRed],[Std.RBNode]]
[Lean.Meta.mkSimpLemmas,[Lean.Meta.withReducible, Bind.bind, Lean.Meta.inferType, Lean.Meta.isProp, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Array.map, Lean.Expr, List.toArray, Array.mapM, Lean.Meta.instantiateMVars, Lean.Meta.withNewMCtxDepth, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.MetaM, Lean.Meta.SimpLemma, Lean.Meta.whnfR, Unit.unit, Lean.Expr.eq?, Lean.Meta.DiscrTree.mkPath, Prod.mk],[Lean.Meta.MetaM, Array, Lean.Meta.SimpLemma]]
[Lean.Meta.CaseArraySizesSubgoal.subst,[],[Lean.Meta.FVarSubst]]
[Lean.Parser.setLhsPrec,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.setLhsPrecFn],[Lean.Parser.Parser]]
[Lean.Parser.instInhabitedParser,[Inhabited.mk, Lean.Parser.Parser.mk, arbitrary],[Inhabited, Lean.Parser.Parser]]
[Lean.Meta.matchFalse,[Lean.Meta.testHelper, Pure.pure, Lean.Expr.isConstOf, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Meta.MetaM, Bool]]
[Lean.strLt,[Decidable.decide, LT.lt],[Bool]]
[Lean.ConstantVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ConstantVal.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.noImplicitLambda.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.OptionDecl.defValue,[],[Lean.DataValue]]
[ExceptCpsT.instLawfulMonadExceptCpsT.proof_1,[LawfulMonad.mk, rfl],[LawfulMonad, ExceptCpsT]]
[Lean.LocalContext.mkLambda,[Lean.LocalContext.mkBinding, Bool.true],[Lean.Expr]]
[Lean.Elab.expandOptNamedPrio,[ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, OfNat.ofNat, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Lean.evalPrio, Lean.Macro.throwUnsupported],[Lean.MacroM, Nat]]
[instAddUInt16,[Add.mk, UInt16.add],[Add, UInt16]]
[String.codepointPosToUtf16Pos,[String.codepointPosToUtf16PosFrom, OfNat.ofNat],[Nat]]
[Prod.map_snd',[funext, Prod.map_snd],[Eq, Function.comp, Prod.snd, Prod.map]]
[Lean.Elab.Tactic.ElimApp.evalAlts,[Bind.bind, ForIn.forIn, PUnit.unit, ite, Eq, bne, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Array.any, Bool, BEq.beq, OfNat.ofNat, Array.size, Pure.pure, ForInStep.yield, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.withInfoContext, Lean.Elab.Tactic.ElimApp.evalAlts.go, Lean.Elab.Tactic.ElimApp.evalAlts.applyPreTac],[Lean.Elab.Tactic.TacticM, Unit]]
[STWorld.noConfusionType,[],[]]
[Lean.Parser.Tactic.rintroPat.binder,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Term.StructInst.FieldLHS.modifyOp.inj,[And.intro],[And, Eq]]
[Lean.Server.Watchdog.ServerContext.initParams,[],[Lean.Lsp.InitializeParams]]
[Ord.noConfusionType,[],[]]
[List.exists_of_mem_join,[Iff.mp, List.mem_join],[Exists, And, Mem.mem]]
[Std.mkPersistentArray,[Nat.fold, Std.PersistentArray.push, Std.PersistentArray.empty],[Std.PArray]]
[Lean.IR.mkUSet,[Lean.IR.FnBody.uset],[Lean.IR.FnBody]]
[Lean.IR.ExpandResetReuse.eraseProjIncFor,[Lean.IR.ExpandResetReuse.eraseProjIncForAux, Array.mkArray, Option.none, List.toArray, List.nil],[Prod, Array, Lean.IR.FnBody, Lean.IR.ExpandResetReuse.Mask]]
[Lean.PrettyPrinter.Delaborator.getExprKind,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Pure.pure, Lean.Name, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr.getAppFn, List.nil, List.cons, Prod.mk, Lean.KVMap.entries],[Lean.PrettyPrinter.Delaborator.DelabM, Lean.Name]]
[UInt64.instAddSemigroupUInt64.proof_1,[congrArg, UInt64.mk, AddSemigroup.add_assoc, UInt64.val],[Eq, UInt64.mk]]
[IO.FS.Metadata.byteSize,[],[UInt64]]
[Lean.Elab.Term.ToParserDescrContext.first,[],[Bool]]
[Lean.Meta.instReprTransparencyMode,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone],[Repr, Lean.Meta.TransparencyMode]]
[Lean.Meta.Closure.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Closure.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[String.append,[String, String.mk, HAppend.hAppend],[String]]
[Lean.Export.State.defs,[],[Std.HashSet, Lean.Name]]
[Lean.Parser.Attr.toAdditive?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Meta.Match.Extension.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.Extension.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.sub_zero,[rfl],[Eq, HSub.hSub, OfNat.ofNat]]
[Lean.Parser.ident,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.identKind, Bool.true, Lean.Parser.identNoAntiquot],[Lean.Parser.Parser]]
[Array.eraseIdxSzAuxInstance,[Inhabited.mk, Subtype.mk, Array.pop, Array.size_pop],[Inhabited, Subtype, Eq, Array.size, HSub.hSub, OfNat.ofNat]]
[Char.instInhabitedChar,[Inhabited.mk, Char.ofNat],[Inhabited, Char]]
[Lean.Server.Completion.State.noConfusionType,[],[]]
[IO.rand,[Bind.bind, ST.Ref.get, IO.stdGenRef, IO, Nat, ST.Ref.set, Pure.pure],[IO, Nat]]
[Lean.Widget.MsgEmbed.expr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Widget.MsgEmbed.expr, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.Context.defaultOptions,[],[Lean.Options]]
[Lean.NameSet.instEmptyCollectionNameSet,[EmptyCollection.mk, Lean.NameSet.empty],[EmptyCollection, Lean.NameSet]]
[ToBool.noConfusionType,[],[]]
[List.erasep_append_left,[List.nil, Eq, List.erasep, HAppend.hAppend, Classical.em, of_eq_true, Eq.trans, congr, congrArg, List.cons_append, List.erasep_cons_of_pos, eq_true, congrFun, eq_self, Eq.symm, Eq.mpr, List.erasep_cons_of_neg, Not, eq_false, eq_true_of_decide, Eq.refl, Bool.true, List.cons.injEq, And, true_and, PProd.fst, List.mem_of_ne_of_mem, mt, eq_of_heq, HEq.refl, rfl],[Eq, List.erasep, HAppend.hAppend]]
[Lean.Elab.Term.StructInst.FieldLHS.modifyOp.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.StructInst.FieldLHS.modifyOp, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.StructInst.FieldLHS.modifyOp, And]]
[Decidable.or_iff_not_imp_left,[Iff.intro, Or.resolve_left, dite, Or.inl, Function.comp, Or.inr],[Iff, Or]]
[Lean.Message.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Message.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Message.mk, And]]
[Lean.Server.Completion.find?.choose,[ite, Eq, not, Lean.Elab.Info.isCompletion, Bool.true, Option.isSome, Lean.Elab.Info.occursInside?, Option, Prod, Lean.Server.Completion.HoverInfo, Lean.Elab.ContextInfo, Lean.Elab.Info, or, bne, Unit.unit, Lean.Server.Completion.HoverInfo.inside, Option.some, Prod.mk, HSub.hSub, Lean.Elab.Info.isSmaller, Option.none, Lean.Server.Completion.HoverInfo.after, Lean.Elab.Info.occursBefore?, Decidable.decide, LT.lt, and, BEq.beq],[Option, Prod, Lean.Server.Completion.HoverInfo, Lean.Elab.ContextInfo, Lean.Elab.Info]]
[EStateM.instInhabitedEStateM,[Inhabited.mk, EStateM.Result.error, arbitrary],[Inhabited, EStateM]]
[Hashable.hash,[],[UInt64]]
[Lean.Parser.instInhabitedInputContext,[Inhabited.mk, Lean.Parser.InputContext.mk, arbitrary],[Inhabited, Lean.Parser.InputContext]]
[Lean.Parser.Attr.defaultInstance.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.optional.parenthesizer, Lean.Parser.priorityParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.MonadStateCacheT,[StateT, Std.HashMap],[]]
[Lean.Meta.Match.MatcherInfo.uElimPos?,[],[Option, Nat]]
[Lean.Elab.Deriving.explicitBinderF,[Lean.Parser.Term.explicitBinder, Bool.false],[Lean.Parser.Parser]]
[Lean.Parser.getConstAlias,[Bind.bind, Lean.Parser.getAlias, Unit.unit, IO, Pure.pure, MonadExcept.throw, coe, HAppend.hAppend, ToString.toString],[IO]]
[Lean.mkNot,[Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.Expr]]
[Lean.Parser.Tactic.generalizes,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.generalizesArg],[Lean.ParserDescr]]
[List.insert_equiv_cons,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, List.mem_insert_iff, List.mem_cons_iff, iff_self, Or, Eq, Mem.mem],[List.equiv, List.insert, List.cons]]
[Std.HashSetImp.buckets,[],[Std.HashSetBucket]]
[Lean.Elab.InfoTree.getCompletionInfos,[Lean.Elab.InfoTree.foldInfo, Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofTermInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Array, Prod, Lean.Elab.ContextInfo, Lean.Elab.CompletionInfo, Array.push, Prod.mk, List.toArray, List.nil],[Array, Prod, Lean.Elab.ContextInfo, Lean.Elab.CompletionInfo]]
[Lean.KeyedDeclsAttribute.instInhabitedOLeanEntry,[Inhabited.mk, Lean.KeyedDeclsAttribute.OLeanEntry.mk, arbitrary],[Inhabited, Lean.KeyedDeclsAttribute.OLeanEntry]]
[Lean.Parser.Priority.numPrio.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.numLit.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[IO.FS.readBinFile,[Bind.bind, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.true, IO.FS.Handle.readBinToEnd],[IO, ByteArray]]
[Lean.Lsp.instFromJsonDocumentSelector,[Lean.FromJson.mk, Lean.FromJson.fromJson?],[Lean.FromJson, Lean.Lsp.DocumentSelector]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.postponed,[],[Array, Prod, Lean.Expr]]
[Lean.PrettyPrinter.Parenthesizer.checkTailWs.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.SynthInstance.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SynthInstance.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SynthInstance.Context.mk, And]]
[Lean.Meta.CasesSubgoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.CasesSubgoal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.CasesSubgoal.mk, And]]
[Lean.Elab.Tactic.evalTraceState,[Bind.bind, Lean.Elab.Tactic.getUnsolvedGoals, Lean.Elab.logInfo, Lean.Elab.goalsToMessageData],[Lean.Elab.Tactic.Tactic]]
[instInhabitedStdGen,[Inhabited.mk, StdGen.mk, OfNat.ofNat],[Inhabited, StdGen]]
[Lean.Elab.FieldInfo.val,[],[Lean.Expr]]
[Lean.Meta.DiscrTree.instReprKey,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, HAppend.hAppend, Std.Format.text, Std.Format.line, reprArg, Std.Format.FlattenBehavior.allOrNone],[Repr, Lean.Meta.DiscrTree.Key]]
[Lean.IR.instToStringJoinPointId,[ToString.mk, HAppend.hAppend, ToString.toString, Lean.IR.JoinPointId.idx],[ToString, Lean.IR.JoinPointId]]
[Nat.instDecidableCoprime,[dite, Eq, Nat.gcd, OfNat.ofNat, Decidable.isTrue, Decidable.isFalse],[Decidable, Nat.coprime]]
[Lean.Meta.SimpLemmas.isDeclToUnfold,[Std.PersistentHashSet.contains, Lean.Meta.SimpLemmas.toUnfold],[Bool]]
[UInt64.instSemiringUInt64.proof_4,[congrArg, UInt64.mk, AddMonoid.nsmul_succ', UInt64.val],[Eq, UInt64.mk, Semiring.nsmul, Nat.succ, UInt64.val]]
[Lean.EnvExtensionInterface.mk.inj,[And.intro],[And, Eq, HEq]]
[Lean.Core.Context.initHeartbeats,[],[Nat]]
[Lean.getNatOption,[Bind.bind, Lean.MonadOptions.getOptions, Pure.pure, Lean.KVMap.getNat],[Nat]]
[Lean.Meta.DiscrTree.Key.const.inj,[And.intro],[And, Eq]]
[IO.FileRight.mk.inj,[And.intro],[And, Eq]]
[Lean.Xml.Parser.PubidChar,[HOrElse.hOrElse, Lean.Parsec.asciiLetter, Lean.Parsec.digit, Lean.Xml.Parser.endl, Lean.Parsec.attempt, Bind.bind, Lean.Parsec.anyChar, ite, Eq, String.contains, Bool.true, Pure.pure, Lean.Parsec.fail],[Lean.Parsec, Lean.Xml.Parser.LeanChar]]
[Lean.Parser.many1,[Lean.Parser.many1NoAntiquot, Lean.Parser.withAntiquotSpliceAndSuffix, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Meta.SimpAll.State.noConfusionType,[],[]]
[Lean.Elab.Tactic.elabAsFVar,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.elabTerm, Option.none, Bool.false, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Elab.Tactic.TacticM, Lean.FVarId, Pure.pure, liftM, Lean.Meta.inferType, Unit.unit, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true],[Lean.Elab.Tactic.TacticM, Lean.FVarId]]
[not_congr,[Iff.intro, mt, Iff.mpr, Iff.mp],[Iff, Not]]
[Lean.Syntax.atom.inj,[And.intro],[And, Eq]]
[Lean.PrettyPrinter.parenthesize,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Std.ToFormat.format, Pure.pure, PUnit.unit],[Lean.Core.CoreM, Lean.Syntax]]
[Lean.Lsp.instFromJsonClientCapabilities,[Lean.FromJson.mk, Pure.pure, Lean.Lsp.ClientCapabilities.mk],[Lean.FromJson, Lean.Lsp.ClientCapabilities]]
[Lean.isCasesOnRecursor,[Lean.Name.anonymous, Lean.Name.num, Bool, and, BEq.beq, Lean.casesOnSuffix, Lean.isAuxRecursor, Bool.false],[Bool]]
[FloatArray.set,[FloatArray, FloatArray.mk, Array.set],[FloatArray]]
[Lean.Server.Watchdog.ServerM,[ReaderT, Lean.Server.Watchdog.ServerContext, IO],[]]
[Lean.ConstantVal.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.delta',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Elab.Level.State.mctx,[],[Lean.MetavarContext]]
[Lean.Server.replaceLspRange,[String.toFileMap, HAppend.hAppend],[Lean.FileMap]]
[Lean.Elab.Term.StructInst.DefaultFields.Context.noConfusionType,[],[]]
[Lean.Lsp.SymbolKind.constructor.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.constructor, OfNat.ofNat]]
[Std.PersistentHashMap.isUnaryNode.proof_1,[Eq.mpr, Eq.refl, LT.lt, OfNat.ofNat, Array.size, Eq.symm, of_decide_eq_true, Bool.true],[LT.lt, OfNat.ofNat, Array.size]]
[Lean.Elab.Term.StructInst.DefaultFields.tryToSynthesizeDefault,[OfNat.ofNat, Lean.Elab.Term.StructInst.DefaultFields.tryToSynthesizeDefault.loop],[Lean.Elab.Term.TermElabM, Bool]]
[Lean.Elab.Command.elabMutualDef,[Bind.bind, Array.mapM, Lean.Elab.elabModifiers, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, and, Decidable.decide, GT.gt, Array.size, Lean.Elab.Modifiers.isNonrec, Bool.true, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Elab.Command.runTermElabM, Option.none, Lean.Elab.Term.elabMutualDef],[Lean.Elab.Command.CommandElabM, Unit]]
[Lean.hasNeverExtractAttribute,[Lean.hasNeverExtractAttribute.visit],[Bool]]
[Lean.Elab.Info.type?,[Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofCompletionInfo, Lean.Meta.MetaM, Option, Lean.Expr, coeM, Lean.Meta.inferType, Lean.Elab.TermInfo.expr, Lean.Elab.FieldInfo.val, Pure.pure, Option.none],[Lean.Meta.MetaM, Option, Lean.Expr]]
[Lean.BinderInfo.strictImplicit.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.BinderInfo.strictImplicit, OfNat.ofNat]]
[Lean.Json.instCoeStringJson,[Coe.mk, Lean.Json.str],[Coe, String, Lean.Json]]
[Lean.Parser.Term.panic,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.Expr.instantiateLevelParamsArray,[Lean.Expr.instantiateLevelParamsCore, OfNat.ofNat],[Lean.Expr]]
[instDecidableLe,[UInt32.decLe],[Decidable, LE.le]]
[Lean.TheoremVal.noConfusionType,[],[]]
[Decidable.eq_or_lt_of_le,[Or.symm, Decidable.lt_or_eq_of_le],[Or, Eq, LT.lt]]
[Std.RBNode.lowerBound,[Option, Sigma, Unit.unit, PProd.fst, PProd.snd, Option.some, Sigma.mk],[Option, Sigma]]
[Lean.MetavarContext.LevelMVarToParam.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.StructInst.Field.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Command.macroTail,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HOrElse.hOrElse, Lean.Parser.Command.macroTailTactic, Lean.Parser.Command.macroTailCommand, Lean.Parser.Command.macroTailDefault],[Lean.Parser.Parser]]
[EStateM.run,[],[EStateM.Result]]
[unsafeBaseIO,[EStateM.Result.error, EStateM.run, Unit.unit],[]]
[Lean.Lsp.CompletionParams.mk.inj,[],[Eq]]
[Int.natAbs_zero,[rfl],[Eq, Int.natAbs, OfNat.ofNat]]
[Lean.Meta.map2MetaM,[controlAt, Lean.Meta.MetaM, MonadControlT.stM],[]]
[Lean.IR.LocalContext.isJP,[Option.none, Option.some, Lean.IR.LocalContextEntry.param, Lean.IR.LocalContextEntry.localVar, Bool, Std.RBMap.find?, Bool.true, Bool.false],[Bool]]
[Lean.Elab.Structural.recArgHasLooseBVarsAt,[Option.isSome],[Bool]]
[System.FilePath.fileName,[ite, Eq, or, String.isEmpty, BEq.beq, Bool.true, Option.none, Option.some],[Option, String]]
[Fin.instAddFin,[Add.mk, Fin.add],[Add, Fin]]
[tacticIterate___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Meta.AltVarNames.mk.inj,[And.intro],[And, Eq]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.knowsType,[],[Bool]]
[Lean.Meta.FunInfo.noConfusionType,[],[]]
[Lean.Elab.Term.blockImplicitLambda,[or, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bool.false, and, BEq.beq, Lean.Syntax.getKind, Lean.Syntax.getOp, OfNat.ofNat, Array.any, Array.size, cond, Lean.Syntax.matchesNull],[Bool]]
[UInt8.instSemiringUInt8,[Semiring.mk, UInt8.instSemiringUInt8.proof_1, UInt8.instSemiringUInt8.proof_2, UInt8.mk, Semiring.nsmul, UInt8.val, UInt8.instSemiringUInt8.proof_3, UInt8.instSemiringUInt8.proof_4, UInt8.instSemiringUInt8.proof_5, UInt8.instSemiringUInt8.proof_6, UInt8.instSemiringUInt8.proof_7, UInt8.instSemiringUInt8.proof_8, UInt8.instSemiringUInt8.proof_9, UInt8.instSemiringUInt8.proof_10, UInt8.instSemiringUInt8.proof_11, UInt8.instSemiringUInt8.proof_12, UInt8.instSemiringUInt8.proof_13],[Semiring, UInt8]]
[UInt64.size,[OfNat.ofNat],[Nat]]
[Lean.ParserCompiler.replaceParserTy,[Lean.Expr.replace, ite, Eq, Lean.Expr.isConstOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Option.some, Lean.mkConst, Lean.ParserCompiler.Context.tyName, List.nil, Option.none],[Lean.Expr]]
[PSum.inr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, PSum.inr, HAdd.hAdd, OfNat.ofNat]]
[Lean.NameHashSet,[Std.HashSet, Lean.Name],[]]
[Lean.MetavarContext.localDeclDependsOn,[Lean.MetavarContext.findLocalDeclDependsOn, BEq.beq],[Bool]]
[Lean.Parser.Term.namedArgument.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.ParserAttributeHook.noConfusionType,[],[]]
[Lean.Expr.updateConst,[Lean.mkConst, Lean.Expr.constName!],[Lean.Expr]]
[Lean.Parser.getNext,[String.get, String.next],[Char]]
[Lean.Elab.WF.packDomain,[Bind.bind, ForIn.forIn, MProd.mk, Lean.Meta.lambdaTelescope, Lean.Elab.PreDefinition.value, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.PreDefinition.declName, Pure.pure, PUnit.unit, Lean.Meta.MetaM, ForInStep, MProd, Array, Nat, Lean.Elab.PreDefinition, Bool, ForInStep.yield, not],[Lean.Meta.MetaM, Array, Lean.Elab.PreDefinition]]
[Lean.IR.Log,[Array, Lean.IR.LogEntry],[]]
[Lean.Expr.Data.hasFVar,[BEq.beq, UInt64.land, UInt64.shiftRight, OfNat.ofNat],[Bool]]
[Lean.Parser.manyIndent,[Lean.Parser.withPosition, Lean.Parser.many, HAndThen.hAndThen, Lean.Parser.checkColGe],[Lean.Parser.Parser]]
[Lean.Meta.Match.MatchEqnsExtState.map,[],[Std.PHashMap, Lean.Name, Lean.Meta.Match.MatchEqns]]
[Lean.Parser.errorAtSavedPosFn,[Unit.unit, Lean.Parser.ParserState, Lean.Parser.ParserContext.savedPos?, Lean.Parser.ParserState.mk, Array.push, Lean.Syntax.missing, Option.some, Lean.Parser.Error.mk],[Lean.Parser.ParserFn]]
[Lean.Elab.Term.synthesizeSyntheticMVarsUsingDefault,[Bind.bind, Lean.Elab.Term.synthesizeSyntheticMVars, Bool.true, Bool.false],[Lean.Elab.Term.TermElabM, Unit]]
[withPtrEqDecEq.proof_2,[ofBoolUsing_eq_true],[Eq]]
[Lean.Parser.Term.ensureExpectedType.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.strLit.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.AssertAfterResult.fvarId,[],[Lean.FVarId]]
[Array.uset,[Array.set, Fin.mk, USize.toNat],[Array]]
[Lean.Server.Watchdog.FileWorker.noConfusionType,[],[]]
[Lean.Elab.Command.mkDefViewOfConstant,[Lean.Elab.Command.CommandElabM, Lean.Elab.DefView, Unit.unit, Lean.Syntax.getOptional?, Lean.Syntax.getOp, OfNat.ofNat, Bind.bind, Pure.pure, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Prod.mk, List.nil, Lean.mkNode, List.toArray, Lean.mkAtomFrom],[Lean.Elab.Command.CommandElabM, Lean.Elab.DefView]]
[Lean.instInhabitedConstructor,[Inhabited.mk, Lean.Constructor.mk, arbitrary],[Inhabited, Lean.Constructor]]
[Lean.Meta.instMetaEvalMetaM,[Lean.MetaEval.mk, Lean.MetaEval.eval, Lean.Meta.MetaM.run', Lean.Meta.Context.mk, Lean.Meta.State.mk, Bool.true],[Lean.MetaEval, Lean.Meta.MetaM]]
[List.length_insert_of_not_mem,[Eq.mpr, Eq.refl, Eq, List.length, List.insert, HAdd.hAdd, OfNat.ofNat, List.insert_of_not_mem, List.cons, Eq.symm, List.length'_eq_length, List.length', rfl],[Eq, List.length, List.insert, HAdd.hAdd, OfNat.ofNat]]
[Lean.ScopedEnvExtension.ext,[],[Lean.PersistentEnvExtension, Lean.ScopedEnvExtension.Entry, Lean.ScopedEnvExtension.StateStack]]
[Fin.modn_lt,[LT.lt, Fin.val, HMod.hMod, Nat.lt_of_le_of_lt, Nat.mod_le, Nat.mod_lt],[LT.lt, Fin.val, HMod.hMod]]
[Lean.Meta.Match.Pattern.replaceFVarId,[Lean.Meta.Match.Pattern.applyFVarSubst, Lean.Meta.FVarSubst.insert],[Lean.Meta.Match.Pattern]]
[Lean.getAttrParamOptPrio,[ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, OfNat.ofNat, Unit.unit, Lean.AttrM, Nat, Lean.Syntax.isNatLit?, Lean.Syntax.getOp, Lean.throwErrorAt, Lean.ToMessageData.toMessageData],[Lean.AttrM, Nat]]
[Lean.OpenDecl.explicit.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.OpenDecl.explicit, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.OpenDecl.explicit, And]]
[Lean.Meta.Match.Problem.examples,[],[List, Lean.Meta.Match.Example]]
[Lean.Parser.ParserExtension.Entry.token.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.ParserExtension.Entry.token, HAdd.hAdd, OfNat.ofNat]]
[List.disjoint_iff_ne,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, List.disjoint_left, forall_congr, implies_congr, Eq.refl, Mem.mem, ne_eq, imp_not_comm, forall_eq', iff_self, Not],[Iff, List.disjoint, Ne]]
[Lean.Syntax.isCharLit?,[Option.none, Option, Char, Lean.Syntax.isLit?, Lean.charLitKind, Lean.Syntax.decodeCharLit],[Option, Char]]
[Lean.Meta.AbstractMVarsResult.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.getMVarSyntaxMVarId,[Lean.MVarId.mk, Lean.Syntax.getKind, Lean.Syntax.getOp, OfNat.ofNat],[Lean.MVarId]]
[Lean.Parser.Command.theorem.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.Command.declSig.parenthesizer, Lean.Parser.Command.declVal.parenthesizer, Lean.Parser.Command.terminationSuffix.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Level.num.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.numLit.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[instMonadExceptOfExceptT,[MonadExceptOf.mk, ExceptT.mk, throwThe, tryCatchThe],[MonadExceptOf, ExceptT]]
[Lean.Parser.Command.docComment.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.ppDedent.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.commentBody.formatter, Lean.ppLine.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Command.catBehavior,[Lean.Parser.optional, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.nonReservedSymbol, Bool.false, HOrElse.hOrElse, Lean.Parser.Command.catBehaviorBoth, Lean.Parser.Command.catBehaviorSymbol],[Lean.Parser.Parser]]
[Nat.instCommSemiringNat.proof_3,[rfl],[Eq, Numeric.ofNat, HAdd.hAdd, OfNat.ofNat]]
[List.concat_eq_append',[Eq, List.concat, List.append', List.cons, List.nil, Eq.symm, List.append_nil, of_eq_true, Eq.trans, congrFun, congrArg, PProd.fst, eq_self],[Eq, List.concat, List.append', List.cons, List.nil]]
[Lean.IR.Expr.isTaggedPtr.injEq,[Eq.propIntro, Eq.refl, Lean.IR.Expr.isTaggedPtr, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Expr.isTaggedPtr]]
[Lean.Server.Watchdog.handleDidClose,[Lean.Server.Watchdog.terminateFileWorker, Lean.Lsp.TextDocumentIdentifier.uri, Lean.Lsp.DidCloseTextDocumentParams.textDocument],[Lean.Server.Watchdog.ServerM, Unit]]
[add_mul,[Semiring.add_mul],[Eq, HMul.hMul, HAdd.hAdd]]
[Tactic.Ring.horner_pow,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HPow.hPow, add_zero, HMul.hMul, mul_pow, HAdd.hAdd, Eq.symm, pow_mul, OfNat.ofNat, eq_self],[Eq, HPow.hPow, Tactic.Ring.horner, OfNat.ofNat]]
[Lean.Elab.Term.LVal.fieldIdx.inj,[And.intro],[And, Eq]]
[Lean.Server.Watchdog.ServerEvent.clientError.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.Watchdog.ServerEvent.clientError, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.InputContext.noConfusionType,[],[]]
[Lean.Meta.DiscrTree.Trie.node.inj,[And.intro],[And, Eq]]
[Lean.Syntax.setHeadInfo,[Unit.unit, Lean.Syntax, Lean.Syntax.setHeadInfoAux],[Lean.Syntax]]
[Lean.Lsp.ServerCapabilities.documentHighlightProvider,[],[Bool]]
[Lean.Elab.Command.expandNotation,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Lean.Macro.throwUnsupported],[Lean.Macro]]
[Lean.Compiler.foldNatDecLe,[Lean.Compiler.foldNatBinPred, Lean.Compiler.mkNatLe, Decidable.decide, LE.le],[Option, Lean.Expr]]
[HMod.hMod,[],[]]
[Lean.InductiveType.type,[],[Lean.Expr]]
[MonadControl.stM,[],[]]
[Lean.Parser.Attr.defaultInstance.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.optional.formatter, Lean.Parser.priorityParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Array.modify,[Id.run, Array.modifyM],[Array]]
[Lean.Elab.Command.StructFieldView.inferMod,[],[Bool]]
[List.card_subset_le,[LE.le, List.card, Eq.mpr, congrFun, congrArg, List.card_nil, Nat.zero_le, Decidable.em, Mem.mem, Eq.symm, Eq.refl],[LE.le, List.card]]
[Lean.Meta.SimpAll.State.ctx,[],[Lean.Meta.Simp.Context]]
[Subtype.restrict_apply,[rfl],[Eq, Subtype.restrict, Subtype.val]]
[Lean.Parser.Tactic.matchRhs.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.hole.parenthesizer, Lean.Parser.Term.syntheticHole.parenthesizer, Lean.Parser.Tactic.tacticSeq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Tactic.LibrarySearch.lines,[Lean.MessageData.joinSep, Lean.MessageData.ofFormat, Std.Format.line],[Lean.MessageData]]
[Lean.Parser.notFollowedByCommandToken,[Lean.Parser.notFollowedByCategoryToken, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Parser.Parser]]
[Lean.Elab.Term.Do.mkTerminalAction,[Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.action],[Lean.Elab.Term.Do.CodeBlock]]
[instLTFin,[LT.mk, LT.lt, Fin.val],[LT, Fin]]
[«term_/\_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.commitWhen,[Bind.bind, Lean.MonadBacktrack.saveState, MonadExcept.tryCatch, Unit.unit, Bool, Pure.pure, Bool.true, Lean.MonadBacktrack.restoreState, Bool.false, MonadExcept.throw],[Bool]]
[decide_true_eq_true,[Eq, Decidable.decide, True, Bool.true, rfl, False.elim, True.intro],[Eq, Decidable.decide, True, Bool.true]]
[Lean.IR.EmitC.emitInc,[Bind.bind, Lean.IR.EmitC.emit, ite, Eq, Bool.true, BEq.beq, OfNat.ofNat, bne, Pure.pure, PUnit.unit],[Lean.IR.EmitC.M, Unit]]
[Nat.foldRev.loop,[PProd.fst],[]]
[instLEFloat,[LE.mk, Float.le],[LE, Float]]
[Lean.AttributeExtensionOLeanEntry.decl.injEq,[Eq.propIntro, Eq.refl, Lean.AttributeExtensionOLeanEntry.decl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.AttributeExtensionOLeanEntry.decl]]
[Lean.IR.ExplicitRC.Context.varMap,[],[Lean.IR.ExplicitRC.VarMap]]
[Lean.SimpleScopedEnvExtension.Descr.noConfusionType,[],[]]
[instMulUInt32,[Mul.mk, UInt32.mul],[Mul, UInt32]]
[List.card_map_le,[of_eq_true, Eq.trans, congr, congrArg, LE.le, List.card, List.map_nil, List.card_nil, eq_true_of_decide, Eq.refl, Bool.true, Decidable.em, Mem.mem, List.map, Eq.mpr, congrFun, List.map_cons, List.card_cons_of_mem, eq_true, List.cons, Nat.le_trans, List.card_le_card_cons, Eq.symm],[LE.le, List.card, List.map]]
[Lean.Meta.FVarSubst.domain,[Std.AssocList.foldl, List.cons, List.nil, Lean.Meta.FVarSubst.map],[List, Lean.FVarId]]
[Lean.Expr.updateLambda!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateLambda, Lean.Expr.lam, Lean.Expr.updateLambda!.proof_1, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[Lean.Meta.throwAppTypeMismatch,[Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Prod, Lean.Expr, Lean.BinderInfo, Pure.pure, Prod.mk, Lean.Expr.Data.binderInfo, Lean.Meta.throwFunctionExpected, ite, Eq, Lean.BinderInfo.isExplicit, Bool.true, PUnit.unit],[Lean.Meta.MetaM]]
[Lean.Meta.InjectionResultCore.solved.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.InjectionResultCore.solved, OfNat.ofNat]]
[Lean.Lsp.SemanticTokensOptions.mk.inj,[And.intro],[And, Eq]]
[Lean.RecursorVal.getFirstIndexIdx,[HAdd.hAdd, Lean.RecursorVal.numParams, Lean.RecursorVal.numMotives, Lean.RecursorVal.numMinors],[Nat]]
[Lean.PrefixTree.foldMatchingM,[Lean.PrefixTreeNode.foldMatchingM, Subtype.val],[]]
[Lean.Meta.IndPredBelow.mkCtorType.copyVarName,[Bind.bind, Lean.Meta.getLocalDecl, liftM, Lean.Core.mkFreshUserName, Lean.LocalDecl.userName],[Lean.Meta.MetaM, Lean.Name]]
[Lean.Meta.Match.Pattern.arrayLit.inj,[And.intro],[And, Eq]]
[Quot.hrecOn,[Quot.recOn, Quot.hrecOn.proof_1],[]]
[Lean.Parser.Term.simpleBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.Parser.Term.optType.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.instInhabitedFieldInfo,[Inhabited.mk, Lean.Elab.FieldInfo.mk, arbitrary],[Inhabited, Lean.Elab.FieldInfo]]
[Lean.Parser.ParserInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.ParserInfo.mk, And]]
[Lean.instFVarIdHashSetEmptyCollection,[Std.HashSet.instEmptyCollectionHashSet],[EmptyCollection, Lean.FVarIdHashSet]]
[Lean.Elab.Term.MutualClosure.ClosureState.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.Checker.CheckerContext.localCtx,[],[Lean.IR.LocalContext]]
[Lean.Level.zero.inj,[],[Eq]]
[Lean.Lsp.instInhabitedDiagnosticWith,[Inhabited.mk, Lean.Lsp.DiagnosticWith.mk, arbitrary],[Inhabited, Lean.Lsp.DiagnosticWith]]
[Classical.indefiniteDescription,[Classical.choice, Classical.indefiniteDescription.proof_1],[Subtype]]
[Lean.LocalContext.findFromUserName?,[Std.PersistentArray.findSomeRev?, Lean.LocalContext.decls, Unit.unit, Option, Lean.LocalDecl, Option.none, ite, Eq, BEq.beq, Lean.LocalDecl.userName, Bool.true, Option.some],[Option, Lean.LocalDecl]]
[Lean.IR.LitVal.str.inj,[],[Eq]]
[Lean.Meta.SimpLemmas.eraseCore,[Pure.pure, Lean.Meta.SimpLemmas.mk, Lean.Meta.SimpLemmas.pre, Lean.Meta.SimpLemmas.post, Std.PersistentHashSet.erase, Lean.Meta.SimpLemmas.lemmaNames, Lean.Meta.SimpLemmas.toUnfold, Std.PersistentHashSet.insert, Lean.Meta.SimpLemmas.erased],[Lean.Meta.SimpLemmas]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.bottomUps,[],[Array, Bool]]
[Lean.Server.Watchdog.FileWorker.erasePendingRequest,[ST.Ref.modify, Lean.Server.Watchdog.FileWorker.pendingRequestsRef, Std.RBMap.erase],[IO, Unit]]
[CommSemiring.toSemiring,[],[Semiring]]
[List.toSSet,[List.foldl, Lean.SSet.insert, Lean.SMap.mk],[Lean.SSet]]
[Lean.Meta.MatcherApp.matcherName,[],[Lean.Name]]
[Lean.Elab.Term.StructInst.CtorHeaderResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.StructInst.CtorHeaderResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.StructInst.CtorHeaderResult.mk, And]]
[Lean.NameSSet.insert,[Lean.SSet.insert],[Lean.NameSSet]]
[Lean.Parser.Command.nonrec,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Widget.TaggedText.tag.inj,[And.intro],[And, Eq]]
[Lean.Expr.bvar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Expr.bvar, HAdd.hAdd, OfNat.ofNat]]
[Lean.mkApp5,[Lean.mkApp, Lean.mkApp4],[Lean.Expr]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.args,[],[Array, Lean.Expr]]
[List.mapIdxM,[OfNat.ofNat, List.mapIdxM.loop],[List]]
[Lean.getPPAnalysisNeedsType,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false],[Bool]]
[Lean.ProjectionFunctionInfo.numParams,[],[Nat]]
[Function.injective.ne_iff,[Iff.intro, mt, congr_arg, Function.injective.ne],[Iff, Ne]]
[Lean.Parser.Tactic.fconstructor,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Array.forRevM,[Array.foldrM, PUnit.unit],[PUnit]]
[Lean.Elab.Deriving.mkInstanceCmds,[Bind.bind, ForIn.forIn, ite, Eq, Array.contains, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Bool.true, Lean.Elab.Deriving.mkInductArgNames, Lean.Elab.Deriving.mkImplicitBinders, Lean.Elab.Deriving.mkInstImplicitBinders, Lean.Elab.Deriving.mkInductiveApp, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkIdent, List.nil, Lean.Syntax.atom, PUnit.unit, ForInStep.yield],[Lean.Elab.Term.TermElabM, Array, Lean.Syntax]]
[false_or,[propext, Iff.intro, False.elim, Or.inr],[Eq, Or, False]]
[Array.shrink,[HSub.hSub, Array.size, Array.shrink.loop],[Array]]
[Lean.Lsp.ServerCapabilities.semanticTokensProvider?,[],[Option, Lean.Lsp.SemanticTokensOptions]]
[Lean.Elab.DefViewElabHeader.levelNames,[],[List, Lean.Name]]
[Or.intro_right,[Or.inr],[Or]]
[UInt16.zero_def,[rfl],[Eq, OfNat.ofNat, UInt16.mk]]
[Lean.Server.FileWorker.CancelToken.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Server.FileWorker.CancelToken.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.FileWorker.CancelToken.mk]]
[Lean.ToExpr.toExpr,[],[Lean.Expr]]
[Lean.InductiveVal.isReflexiveEx,[Lean.InductiveVal.isReflexive],[Bool]]
[Mathlib.Tactic.Lint.LintVerbosity.noConfusionType,[noConfusionTypeEnum, Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx],[]]
[Nat.le_div_iff_mul_le,[Nat.mod.inductionOn, Eq.mpr, Eq.refl, Iff, LE.le, HDiv.hDiv, HMul.hMul, Nat.div_eq, congrFun, congrArg, Eq.trans, ite_congr, congr, And, eq_true, eq_true_of_decide, Bool.true, HAdd.hAdd, HSub.hSub, OfNat.ofNat, ite_true, of_eq_true, Nat.zero_eq, Nat.zero_le, Nat.zero_mul, Eq.symm, Nat.succ, Nat.add_one, propext, Nat.add_le_add_iff_le_right, Nat.succ_mul, Nat.add_sub_cancel, Nat.sub_le_sub_right_iff, And.right, Iff.rfl, eq_false, ite_false, Nat.not_succ_le_zero, Nat.add_comm, false_iff, not_le, Nat.lt_of_lt_of_le, Iff.mp, And.intro, Nat.le_add_right],[Iff, LE.le, HDiv.hDiv, HMul.hMul]]
[Nat.coprime.coprime_dvd_right,[Nat.coprime.symm, Nat.coprime.coprime_dvd_left],[Nat.coprime]]
[tacticAssumption',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Name.instDecidableRelLtNameHasLtQuick,[inferInstanceAs, DecidableRel, Eq, Lean.Name.quickLt, Bool.true],[DecidableRel, LT.lt]]
[Union.union,[],[]]
[Lean.Meta.DiscrTree.instToFormatDiscrTree,[Std.ToFormat.mk, Lean.Meta.DiscrTree.format],[Std.ToFormat, Lean.Meta.DiscrTree]]
[Std.HashMapImp.contains.proof_1,[Subtype.property],[GT.gt, Array.size, Subtype.val, OfNat.ofNat]]
[Lean.Lsp.instToJsonCompletionItem,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.CompletionItem.label, List.nil, Lean.Json.opt, Lean.Lsp.CompletionItem.detail?, Lean.Lsp.CompletionItem.documentation?],[Lean.ToJson, Lean.Lsp.CompletionItem]]
[Lean.Parser.mkParserOfConstantUnsafe,[Bind.bind, MonadReader.read, Unit.unit, Lean.ImportM, Prod, Bool, Lean.Parser.Parser, Lean.Environment.find?, MonadExcept.throw, coe, HAppend.hAppend, ToString.toString, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Name.anonymous, Lean.Name.str, dite, Eq, Eq.symm, Lean.Name.num, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.ConstantInfo.type, liftM, IO.ofExcept, Lean.Environment.evalConst, Pure.pure, Prod.mk, Bool.false, Bool.true, Lean.ParserDescr, Lean.TrailingParserDescr],[Lean.ImportM, Prod, Bool, Lean.Parser.Parser]]
[Lean.PrettyPrinter.delab,[Bind.bind, Lean.PrettyPrinter.delabCore, Lean.Meta.MetaM, Lean.Syntax, Pure.pure],[Lean.Meta.MetaM, Lean.Syntax]]
[Lean.Elab.Tactic.evalOpen,[tryFinally, Bind.bind, Lean.pushScope, Lean.Elab.OpenDecl.elabOpenDecl, Lean.Syntax.getOp, OfNat.ofNat, withTheReader, Lean.Core.Context, Lean.Core.Context.mk, Lean.Core.Context.options, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats, Lean.Elab.Tactic.evalTactic, Lean.popScope],[Lean.Elab.Tactic.Tactic]]
[Lean.Parser.Term.doubleQuotedName,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.checkNoWsBefore, Lean.Parser.rawCh, Char.ofNat, Bool.false, Lean.Parser.Term.ident],[Lean.Parser.Parser]]
[Lean.Parser.Tactic.hGeneralize,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.binderIdent, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Array.toArrayLit_eq,[sorryAx, Eq, Array.toArrayLit, Bool.false],[Eq, Array.toArrayLit]]
[Lean.EnvExtensionInterface.inhabitedExt,[],[Inhabited, Lean.EnvExtensionInterface.ext]]
[Lean.TheoremVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.TheoremVal.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.MData.empty,[Lean.KVMap.mk],[Lean.IR.MData]]
[Lean.Expr.fvar.inj,[And.intro],[And, Eq]]
[Lean.EnvExtensionInterfaceUnsafe.registerExt,[Bind.bind, Lean.initializing, ite, Eq, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, IO.userError],[IO, Lean.EnvExtensionInterfaceUnsafe.Ext]]
[Lean.Syntax.toNat,[Unit.unit, Nat, Lean.Syntax.isNatLit?, OfNat.ofNat],[Nat]]
[instInhabitedFloat,[Inhabited.mk, Float.mk, FloatSpec.val, floatSpec],[Inhabited, Float]]
[Lean.Parser.Command.mixfix.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.Command.mixfixKind.parenthesizer, Lean.Parser.precedence.parenthesizer, Lean.Parser.Command.optNamedName.parenthesizer, Lean.Parser.Command.optNamedPrio.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.strLit.parenthesizer, Lean.Parser.darrow.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[ExceptCpsT.instLawfulMonadExceptCpsT,[ExceptCpsT.instLawfulMonadExceptCpsT.proof_1],[LawfulMonad, ExceptCpsT]]
[Lean.Elab.Term.StructInst.Struct.noConfusionType,[],[]]
[Lean.Meta.deltaExpand,[Lean.Core.transform, Bind.bind, Lean.Meta.delta?, Unit.unit, Lean.Core.CoreM, Lean.TransformStep, Pure.pure, Lean.TransformStep.visit, Lean.TransformStep.done],[Lean.Core.CoreM, Lean.Expr]]
[ByteArray.mk.injEq,[Eq.propIntro, Eq.refl, ByteArray.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, ByteArray.mk]]
[Lean.ImportM,[ReaderT, Lean.ImportM.Context, IO],[]]
[IsMulRightCancel.mul_right_cancel,[],[Eq]]
[Int.decEq.proof_3,[rfl],[Eq, Int.negSucc]]
[Lean.Parser.Term.notFollowedByRedefinedTermToken,[Lean.Parser.notFollowedBy, HOrElse.hOrElse, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Module.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Module.mk, HAdd.hAdd, OfNat.ofNat]]
[not_of_not_imp,[mt, imp_intro],[Not]]
[Lean.Expr.bvar.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.bvar, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Expr.bvar, And]]
[Lean.Meta.isDelayedAssigned,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.isDelayedAssigned],[Lean.Meta.MetaM, Bool]]
[Lean.InternalExceptionId.mk.injEq,[Eq.propIntro, Eq.refl, Lean.InternalExceptionId.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.InternalExceptionId.mk]]
[Lean.IR.explicitRC,[Bind.bind, Lean.IR.getEnv, Pure.pure, Array.map, Lean.IR.ExplicitRC.visitDecl],[Lean.IR.CompilerM, Array, Lean.IR.Decl]]
[instOne,[One.mk, OfNat.ofNat],[One]]
[Lean.markNoConfusion,[Lean.TagDeclarationExtension.tag, Lean.noConfusionExt],[Lean.Environment]]
[ReaderT.instAlternativeReaderT,[Alternative.mk, ReaderT.failure, ReaderT.orElse],[Alternative, ReaderT]]
[Div.noConfusionType,[],[]]
[Lean.Lsp.LeanFileProgressProcessingInfo.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.LeanFileProgressProcessingInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.LeanFileProgressProcessingInfo.mk]]
[Lean.Lsp.instToJsonDiagnosticWith,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.DiagnosticWith.range, List.nil, Lean.Lsp.DiagnosticWith.fullRange, Lean.Json.opt, Lean.Lsp.DiagnosticWith.severity?, Lean.Lsp.DiagnosticWith.code?, Lean.Lsp.DiagnosticWith.source?, Lean.Lsp.DiagnosticWith.message, Lean.Lsp.DiagnosticWith.tags?, Lean.Lsp.DiagnosticWith.relatedInformation?],[Lean.ToJson, Lean.Lsp.DiagnosticWith]]
[forall₃_congr,[forall_congr', forall₂_congr],[Iff]]
[Std.instEmptyCollectionRBMap,[EmptyCollection.mk, Std.RBMap.empty],[EmptyCollection, Std.RBMap]]
[Lean.Parser.Tactic.decide.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.TextDocumentPositionParams.textDocument,[],[Lean.Lsp.TextDocumentIdentifier]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isHigherOrder,[Lean.Meta.forallTelescopeReducing, Pure.pure, and, Decidable.decide, GT.gt, Array.size, OfNat.ofNat, Lean.Expr.isSort],[Lean.Meta.MetaM, Bool]]
[Option.isEqSome,[Bool, BEq.beq, Bool.false],[Bool]]
[Lean.instForInMVarIdSetMVarId,[inferInstanceAs, ForIn, Std.RBTree, Lean.MVarId, Lean.Name.quickCmp, Lean.MVarId.name],[ForIn, Lean.MVarIdSet, Lean.MVarId]]
[Lean.Elab.Term.MutualClosure.LetRecClosure.noConfusionType,[],[]]
[Lean.Lsp.SymbolKind.noConfusion,[noConfusionEnum, Lean.Lsp.SymbolKind.toCtorIdx],[Lean.Lsp.SymbolKind.noConfusionType]]
[«stx_,*,?»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[Lean.Meta.GeneralizeIndicesSubgoal.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.cases,[Lean.Meta.Cases.cases],[Lean.Meta.MetaM, Array, Lean.Meta.CasesSubgoal]]
[Lean.Lsp.InitializeParams.processId?,[],[Option, Int]]
[Lean.Lsp.SaveOptions.mk.inj,[],[Eq]]
[Lean.Parser.Syntax.subPrio,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Elab.Term.synthesizeInst,[Bind.bind, liftM, Lean.Meta.instantiateMVars, Lean.Meta.trySynthInstance, Option.none, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Std.RBNode.balRight,[Std.RBNode.leaf, Std.RBNode.node, Std.Rbcolor.black, Std.RBNode, Std.Rbcolor.red, Std.RBNode.balance₃, Std.RBNode.setRed],[Std.RBNode]]
[Lean.Elab.checkSyntaxNodeKindAtNamespaces,[Unit.unit, Lean.Name.str, Lean.Name.num, Lean.Name, HOrElse.hOrElse, Lean.Elab.checkSyntaxNodeKind, HAppend.hAppend, PProd.fst, Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Name]]
[Lean.Syntax.mkNameLit,[Lean.Syntax.mkLit, Lean.nameLitKind],[Lean.Syntax]]
[Lean.Meta.instReduceEvalString,[Lean.Meta.ReduceEval.mk, Bind.bind, Lean.Meta.whnf, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.natVal, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, String, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr],[Lean.Meta.ReduceEval, String]]
[Or.left_comm,[Iff.trans, Iff.symm, Or.assoc, or_congr, Or.comm, Iff.refl],[Iff, Or]]
[Quotient.lift₂.proof_1,[Setoid.refl],[Eq]]
[Lean.Elab.Term.elabParen,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.Elab.Term.withSynthesize, Lean.Elab.Term.elabType, Lean.Elab.Term.elabTerm, Option.some, Lean.Elab.Term.ensureHasType, Option.none, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElab]]
[Lean.Xml.Parser.NDataDecl,[SeqLeft.seqLeft, SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Parsec.skipString, Lean.Xml.Parser.Name],[Lean.Parsec, Unit]]
[Lean.Elab.Term.Quotation.Precheck.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Quotation.Precheck.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.FieldInfo.format,[Lean.Elab.ContextInfo.runMetaM, Lean.Elab.FieldInfo.lctx, Bind.bind, Lean.Meta.inferType, Lean.Elab.FieldInfo.val, Lean.Meta.ppExpr, Pure.pure, HAppend.hAppend, Std.ToFormat.format, Lean.Elab.FieldInfo.fieldName, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Std.Format, Lean.Elab.FieldInfo.stx],[IO, Std.Format]]
[Lean.Parser.Tactic.intros,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Module.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Module.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Module.mk, And]]
[Lean.Parser.ParserState.mkError,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Array.push, Lean.Syntax.missing, Option.some, Lean.Parser.Error.mk, List.cons, List.nil],[Lean.Parser.ParserState]]
[Lean.LocalContext.foldr,[Id.run, Lean.LocalContext.foldrM],[]]
[Lean.Elab.DefViewElabHeader.declName,[],[Lean.Name]]
[Lean.Parser.mkAntiquotSplice,[Lean.Parser.leadingNode, Lean.Parser.maxPrec, Lean.Parser.atomic, HAndThen.hAndThen, Lean.Parser.setExpected, List.nil, Lean.Parser.symbol, Lean.Parser.manyNoAntiquot, Lean.Parser.checkNoWsBefore, Lean.Parser.node, Lean.nullKind],[Lean.Parser.Parser]]
[Lean.Elab.Tactic.evalIntro,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Lean.Syntax.getId, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, List.nil, Lean.Elab.Tactic.evalTactic, GE.ge, Lean.Syntax.getNumArgs, Array.append, Lean.Elab.throwUnsupportedSyntax, Lean.Elab.Tactic.evalIntro.introStep],[Lean.Elab.Tactic.Tactic]]
[Lean.Compiler.foldNatDecLt,[Lean.Compiler.foldNatBinPred, Lean.Compiler.mkNatLt, Decidable.decide, LT.lt],[Option, Lean.Expr]]
[IO.FS.Stream.readLspMessage,[MonadExcept.tryCatch, Bind.bind, Unit.unit, IO, Nat, List.lookup, String.toNat?, Pure.pure, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, IO.FS.Stream.readMessage],[IO, Lean.JsonRpc.Message]]
[Std.rbmapOf,[Std.RBMap.fromList],[Std.RBMap]]
[Lean.Parser.Term.matchAlt.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ppIndent.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Bool.false, Lean.Parser.darrow.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGe.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[List.instSetoidList,[Setoid.mk, List.Perm, List.Perm.Equivalence],[Setoid, List]]
[Lean.Parser.Term.sort.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.checkWsBefore.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.PrettyPrinter.Formatter.checkColGt.formatter, Lean.Parser.levelParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.Simp.Config.zeta,[],[Bool]]
[Lean.Parser.Term.let_tmp,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, Lean.Parser.symbol, Lean.Parser.Term.letDecl, Lean.Parser.Term.optSemicolon, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.Expr.FindImpl.findM?.visit,[Bind.bind, liftM, Lean.Expr.FindImpl.visited, ite, Eq, Bool.true, Alternative.failure, Pure.pure, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lit, OptionT, Lean.Expr.FindImpl.FindM, Lean.Expr, HOrElse.hOrElse, Lean.Expr.FindImpl.findM?.visit],[OptionT, Lean.Expr.FindImpl.FindM, Lean.Expr]]
[Lean.IR.IRType.irrelevant.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.IR.IRType.irrelevant, OfNat.ofNat]]
[Lean.CollectFVars.instInhabitedState,[Inhabited.mk, Lean.CollectFVars.State.mk, arbitrary],[Inhabited, Lean.CollectFVars.State]]
[left_distributive,[Eq],[]]
[Alternative.toApplicative,[],[Applicative]]
[Lean.Meta.Match.proveCondEqThm,[Bind.bind, Lean.Meta.instantiateMVars, Lean.Meta.withLCtx, Lean.LocalContext.mk, EmptyCollection.emptyCollection, Lean.Meta.forallTelescope, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Name.anonymous, Lean.Meta.deltaTarget, Lean.Expr.mvarId!, BEq.beq, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MessageData.ofGoal, Pure.pure, PUnit.unit, Lean.Meta.Match.proveCondEqThm.go],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Parser.Term.matchDiscr.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.PrettyPrinter.Formatter.evalInsideQuot.formatter, Lean.Parser.Term.matchDiscr.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.instToJsonWorkspaceFolder,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.WorkspaceFolder.uri, List.nil, Lean.Lsp.WorkspaceFolder.name],[Lean.ToJson, Lean.Lsp.WorkspaceFolder]]
[Lean.Elab.Command.MkInstanceName.isFirst,[Bind.bind, MonadState.get, Pure.pure, BEq.beq],[Lean.Elab.Command.MkInstanceName.M, Bool]]
[Lean.Lsp.SymbolKind.interface.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.interface, OfNat.ofNat]]
[and_not_self,[False],[Not, And]]
[Lean.IR.instToStringExpr,[ToString.mk, Std.Format.pretty, Std.ToFormat.format, Std.Format.defWidth],[ToString, Lean.IR.Expr]]
[Lean.Server.Snapshots.Snapshot.stx,[],[Lean.Syntax]]
[Lean.Elab.Term.Do.ToCodeBlock.Context.insideFor,[],[Bool]]
[Lean.Meta.Match.MatcherInfo.noConfusionType,[],[]]
[Lean.Server.Snapshots.Snapshot.diagnostics,[Std.PersistentArray.map, Lean.Widget.InteractiveDiagnostic.toDiagnostic, Lean.Server.Snapshots.Snapshot.interactiveDiags],[Std.PersistentArray, Lean.Lsp.Diagnostic]]
[exists_unique_of_exists_of_unique,[Exists.elim, ExistsUnique.intro],[ExistsUnique]]
[Lean.Json.Parser.any,[Bind.bind, Lean.Parsec.ws, Lean.Json.Parser.anyCore, Unit.unit, Lean.Parsec.eof, Pure.pure],[Lean.Parsec, Lean.Json]]
[Float.val,[],[FloatSpec.float, floatSpec]]
[Lean.Elab.Term.StructInst.FieldLHS.fieldName.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.StructInst.FieldLHS.fieldName, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.Formatter.instCoeArrowFormatterArrowFormatterFormatterFormatterAliasValue,[Coe.mk, Lean.Parser.AliasValue.binary],[Coe, Lean.PrettyPrinter.Formatter, Lean.PrettyPrinter.Formatter.FormatterAliasValue]]
[Lean.KVMap.getName,[Option.none, Option.some, Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Lean.Name, Lean.KVMap.find],[Lean.Name]]
[Lean.Meta.DiscrTree.Key.other.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.DiscrTree.Key.other, OfNat.ofNat]]
[Fin.subUnderflows?,[Decidable.decide, LT.lt, Fin.val],[Bool]]
[measure,[invImage, Nat.lt_wfRel],[WellFoundedRelation]]
[Lean.Meta.registerGetUnfoldEqnFn,[Bind.bind, Lean.initializing, ite, Eq, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, IO.userError],[IO, Unit]]
[Lean.Elab.Tactic.State.mk.inj,[],[Eq]]
[Lean.PersistentEnvExtension.modifyState,[Lean.EnvExtension.modifyState, Lean.PersistentEnvExtension.toEnvExtension, Lean.PersistentEnvExtensionState.mk, Lean.PersistentEnvExtensionState.importedEntries, Lean.PersistentEnvExtensionState.state],[Lean.Environment]]
[Lean.Meta.smartUnfoldingMatchAlt?,[Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous],[Option, Lean.Expr]]
[Lean.Elab.Structural.EqnInfo.recArgPos,[],[Nat]]
[Lean.Meta.mkFreshExprSyntheticOpaqueMVar,[Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.syntheticOpaque],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Meta.SimpLemmas.erased,[],[Std.PHashSet, Lean.Name]]
[UInt8.noConfusionType,[],[]]
[Lean.Elab.Term.Do.hasReturn,[Lean.Elab.Term.Do.hasExitPointPred, Lean.Elab.Term.Do.Code.decl, Lean.Elab.Term.Do.Code.reassign, Lean.Elab.Term.Do.Code.joinpoint, Lean.Elab.Term.Do.Code.seq, Lean.Elab.Term.Do.Code.action, Lean.Elab.Term.Do.Code.break, Lean.Elab.Term.Do.Code.continue, Lean.Elab.Term.Do.Code.ite, Lean.Elab.Term.Do.Code.match, Lean.Elab.Term.Do.Code.jmp, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Parser.Term.scoped.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.throwUnsupportedSyntax,[MonadExcept.throw, Lean.Exception.internal, Lean.Elab.unsupportedSyntaxExceptionId, Lean.KVMap.mk],[]]
[left_commutative,[Eq],[]]
[Lean.IR.LocalContextEntry.localVar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.LocalContextEntry.localVar, HAdd.hAdd, OfNat.ofNat]]
[Lean.instInhabitedExpr,[Inhabited.mk, Lean.Expr.bvar, arbitrary],[Inhabited, Lean.Expr]]
[Equiv.rightInv,[],[Function.right_inverse, Equiv.invFun, Equiv.toFun]]
[Lean.Parser.Term.bracketedBinder,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.none, Bool.false, HOrElse.hOrElse, Lean.Parser.Term.explicitBinder, Lean.Parser.Term.strictImplicitBinder, Lean.Parser.Term.implicitBinder, Lean.Parser.Term.instBinder],[Lean.Parser.Parser]]
[Lean.Parser.Tactic.compVal,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Std.PersistentArray.Stats.tailSize,[],[Nat]]
[Lean.Elab.Term.Do.Code.match.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, Eq.refl, List.nil, congr, Lean.Elab.Term.Do.Alt.mk, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.Code.match, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.quotedCharCoreFn,[ite, Eq, String.atEnd, Bool.true, Lean.Parser.ParserState.mkEOIError, List.nil, Lean.Parser.ParserState.next, BEq.beq, Char.ofNat, Lean.Parser.andthenFn, Lean.Parser.hexDigitFn, Lean.Parser.ParserState.mkUnexpectedError],[Lean.Parser.ParserFn]]
[Lean.MessageDataContext.opts,[],[Lean.Options]]
[Lean.Expr.updateLet,[Lean.mkLet, Lean.Expr.letName!, Bool.false],[Lean.Expr]]
[Lean.Declaration.thmDecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Declaration.thmDecl, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.strLit.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.strLitKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.strLitNoAntiquot.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Mathlib.Tactic.Ext.mkIff,[Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.Expr]]
[UInt16.instAddSemigroupUInt16,[AddSemigroup.mk, UInt16.instAddSemigroupUInt16.proof_1],[AddSemigroup, UInt16]]
[Lean.Parser.Command.identScope,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[SubNegMonoid.gsmul_neg',[],[Eq, SubNegMonoid.gsmul, Int.negSucc, Neg.neg, coe, Nat.succ]]
[Lean.Meta.mkForallCongr,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[List.count,[List.countp, Eq],[Nat]]
[Lean.Elab.Term.reportMatcherResultErrors,[ite, Eq, List.isEmpty, Lean.Meta.Match.MatcherResult.counterExamples, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.withHeadRefOnly, Lean.Elab.logError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.Match.counterExamplesToMessageData],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Elab.Tactic.Conv.evalWhnf,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.Conv.getLhs, liftM, Lean.Meta.whnf, Lean.Elab.Tactic.Conv.changeLhs],[Lean.Elab.Tactic.Tactic]]
[Lean.Parser.Command.init_quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.CollectPatternVars.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.CollectPatternVars.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.DocumentMeta.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.DocumentMeta.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.mk, And]]
[Lean.Elab.Term.Quotation.HeadCheck.other.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Quotation.HeadCheck.other, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.IndPredBelow.BrecOnVariables.indices,[],[Array, Lean.FVarId]]
[Array.getOp,[Array.get!],[]]
[Lean.Elab.Term.MkInstResult.noConfusionType,[],[]]
[UInt64.instRingUInt64.proof_5,[UInt64.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, UInt64.val, congrFun, HAdd.hAdd, UInt64.neg_def, UInt64.add_def, UInt64.mk, Neg.neg, add_left_neg, UInt64.zero_def, eq_true_of_decide, Eq.refl, Bool.true],[Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat]]
[Lean.Server.Watchdog.handleDidOpen,[Lean.Server.Watchdog.startFileWorker, Lean.Server.DocumentMeta.mk, Lean.Lsp.TextDocumentItem.uri, Lean.Lsp.TextDocumentItem.version, String.toFileMap, Lean.Lsp.TextDocumentItem.text],[Lean.Server.Watchdog.ServerM, Unit]]
[guardExprStrict,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Parser.rawIdent.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.identKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.rawIdentNoAntiquot.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.mkBInductionOn,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.MonadEnv.modifyEnv, Lean.throwKernelException, Lean.mkBInductionOnImp],[Unit]]
[Nat.coprime_div_gcd_div_gcd,[Eq.mpr, Eq.refl, Nat.coprime, HDiv.hDiv, Nat.gcd, propext, Nat.coprime_iff_gcd_eq_one, Eq, OfNat.ofNat, Nat.gcd_div, Nat.gcd_dvd_left, Nat.gcd_dvd_right, Nat.div_self, rfl],[Nat.coprime, HDiv.hDiv, Nat.gcd]]
[Lean.PrettyPrinter.Formatter.FormatterAliasValue,[Lean.Parser.AliasValue, Lean.PrettyPrinter.Formatter],[]]
[Lean.Elab.Term.Quotation.getPatternsVars,[Array.foldlM, Bind.bind, Lean.Elab.Term.Quotation.getPatternVars, Pure.pure, HAppend.hAppend, List.toArray, List.nil, OfNat.ofNat, Array.size],[Lean.Elab.Term.TermElabM, Array, Lean.Syntax]]
[Lean.InductiveVal.noConfusionType,[],[]]
[Lean.IR.formatAlt,[Std.Format, HAppend.hAppend, Std.ToFormat.format, Lean.IR.CtorInfo.name, Std.Format.text, Std.Format.nest, Int.ofNat, Std.Format.line],[Std.Format]]
[Lean.Parser.Command.parameter,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Nat.gcd_mul_left,[Nat.gcd.induction, of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, Nat.gcd, Nat.mul_zero, HMul.hMul, Nat.gcd_zero_left, eq_self, Eq.mp, Eq.refl, HMod.hMod, Eq.symm, Nat.gcd_rec, Nat.mul_mod_mul_left],[Eq, Nat.gcd, HMul.hMul]]
[Lean.Lsp.instFromJsonTypeDefinitionParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.TypeDefinitionParams.mk, Lean.Lsp.TextDocumentPositionParams.mk],[Lean.FromJson, Lean.Lsp.TypeDefinitionParams]]
[And.congr_left_iff,[Eq.mpr, congrArg, Iff, And, Eq.trans, Eq.symm, propext, And.congr_right_iff, congr, and_comm, Iff.rfl],[Iff, And]]
[Lean.Parser.ppSpace,[Lean.Parser.skip],[Lean.Parser.Parser]]
[Lean.Elab.CompletionInfo.namespaceId.inj,[],[Eq]]
[Lean.Elab.Term.LetRecDeclView.noConfusionType,[],[]]
[Lean.Elab.Tactic.ElimApp.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Tactic.ElimApp.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.LogEntry.fmt,[Std.Format, HAppend.hAppend, Std.Format.bracket, Std.ToFormat.format, Array.foldl, Std.Format.line, Std.Format.nil, OfNat.ofNat, Array.size],[Std.Format]]
[List.mem_filterAux,[Iff, Mem.mem, List.filterAux, Or, And, Eq, Bool.true, of_eq_true, Eq.trans, congr, congrArg, propext, List.mem_reverse, congrFun, List.mem_nil_iff, false_and, false_or, iff_self, Eq.mpr, Unit.unit, List, List.cons, List.mem_cons_iff, PProd.fst, Iff.intro, Or.inl, And.intro, Or.inr, And.left, And.right, Eq.symm, Eq.refl, Eq.mp, Bool.false],[Iff, Mem.mem, List.filterAux, Or, And, Eq, Bool.true]]
[Lean.Parser.Term.matchDiscr.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Term.ident.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Decidable.not_or_of_imp,[dite, Or.inr, Or.inl],[Or, Not]]
[Lean.Parser.Command.localized,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Function.Equiv.refl,[rfl],[Function.Equiv]]
[Lean.Elab.Modifiers.visibility,[],[Lean.Elab.Visibility]]
[Lean.Widget.GetInteractiveDiagnosticsParams.mk.inj,[],[Eq]]
[Lean.Elab.Tactic.tryTactic?,[MonadExcept.tryCatch, Bind.bind, Pure.pure, Option.some, Option.none],[Lean.Elab.Tactic.TacticM, Option]]
[Lean.Elab.Deriving.mkLet,[Array.foldrM, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.size, OfNat.ofNat],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Subtype.map_comp,[rfl],[Eq, Subtype.map, Function.comp]]
[Lean.Parser.ParserCategories,[Std.PersistentHashMap, Lean.Name, Lean.Parser.ParserCategory],[]]
[Std.HashMapImp.reinsertAux,[Std.HashMapBucket, Std.HashMapBucket.update, Std.AssocList.cons, Array.uget, Subtype.val],[Std.HashMapBucket]]
[Lean.Parser.Command.eval.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.indentD,[Lean.MessageData.nestD, HAppend.hAppend, Lean.MessageData.ofFormat, Std.Format.line],[Lean.MessageData]]
[Lean.Parser.Term.explicit,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[min_le_right,[dite, LE.le, Eq.mpr, congrFun, congrArg, if_pos, of_eq_true, Eq.trans, if_neg, eq_true, le_refl],[LE.le, min]]
[«term_-_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Function.hfunext,[],[HEq]]
[Lean.Elab.Term.FunBinders.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.FunBinders.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.FunBinders.State.mk, And]]
[Lean.Meta.Match.MkMatcherInput.lhss,[],[List, Lean.Meta.Match.AltLHS]]
[Lean.Server.RequestM.mapTask,[Bind.bind, liftM, EIO.mapTask, Task.Priority.default, Pure.pure, Task.map, liftExcept],[Lean.Server.RequestM, Lean.Server.RequestTask]]
[Lean.addTrace,[Bind.bind, Lean.MonadRef.getRef, Lean.AddMessageContext.addMessageContext, Lean.modifyTraces, Std.PersistentArray.push, Lean.TraceElem.mk, Lean.MessageData.tagged, HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ToMessageData.toMessageData, Lean.addTrace.addTraceOptions],[Unit]]
[Lean.Parser.Tactic.splitIfs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location, Lean.ParserDescr.symbol, Lean.binderIdent],[Lean.ParserDescr]]
[Lean.ClassEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ClassEntry.mk, HAdd.hAdd, OfNat.ofNat]]
[instAndOpUSize,[AndOp.mk, USize.land],[AndOp, USize]]
[Function.surjective.prod_map,[Exists, Eq, Prod.map, Exists.intro, Prod.mk, Prod.ext'],[Function.surjective, Prod.map]]
[Lean.Meta.forallTelescopeCompatible,[controlAt, Lean.Meta.MetaM, Lean.Meta.forallTelescopeCompatibleAux, List.toArray, List.nil],[]]
[Lean.Compiler.foldUnOp,[OptionM.run, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, OptionM, Lean.Expr, Bind.bind, Lean.Compiler.findUnFoldFn, Alternative.failure],[Option, Lean.Expr]]
[Lean.PrettyPrinter.Formatter.setExpected.formatter,[],[Lean.PrettyPrinter.Formatter]]
[System.mkFilePath,[System.FilePath.mk, String.intercalate, Char.toString, System.FilePath.pathSeparator],[System.FilePath]]
[Array.anyMUnsafe,[ite, LT.lt, LE.le, Array.size, USize.ofNat, Pure.pure, Bool.false, Array.anyMUnsafe.any],[Bool]]
[Lean.IR.IRType.struct.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.mono,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.Parser.Tactic.mono.side, Lean.ParserDescr.sepBy1, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.simpArg],[Lean.ParserDescr]]
[Lean.Elab.Term.mkTermElabAttributeUnsafe,[Lean.Elab.mkElabAttribute, Lean.Elab.Term.TermElab, Lean.Name.mkStr, Lean.Name.anonymous],[IO, Lean.KeyedDeclsAttribute, Lean.Elab.Term.TermElab]]
[Lean.Elab.Command.elabExportPrivate,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Lean.Parser.Term.termTry.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.doSeq.formatter, Lean.Parser.many.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.doCatch.formatter, Lean.Parser.Term.doCatchMatch.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.doFinally.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.expandOptPrecedence,[ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, Option.none, Bind.bind, Lean.evalPrec, Lean.Syntax.getOp, OfNat.ofNat, Option.some],[Lean.MacroM, Option, Nat]]
[Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.alts,[],[Array, Lean.Elab.Term.MatchAltView]]
[max_assoc,[eq_max, le_trans, le_max_left, max, max_le, le_max_right],[Eq, max]]
[Subtype.mk_eq_mk,[Subtype.ext_iff],[Iff, Eq, Subtype.mk]]
[Lean.Server.FileWorker.WorkerContext.hLog,[],[IO.FS.Stream]]
[Lean.instMonadLiftImportMAttrM,[MonadLift.mk, Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, liftM, Lean.ImportM.Context.mk],[MonadLift, Lean.ImportM, Lean.AttrM]]
[Lean.KeyedDeclsAttribute.Def.onAdded,[],[Lean.AttrM, Unit]]
[Lean.Lsp.DocumentSymbolAux.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.MonadMacroAdapter.getCurrMacroScope,[],[Lean.MacroScope]]
[Lean.Elab.Info.ofFieldInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Info.ofFieldInfo, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.ParserState.keepLatest,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Lean.Parser.ParserState.keepTop, Option.none],[Lean.Parser.ParserState]]
[EStateM.dummySave,[PUnit.unit],[PUnit]]
[instInhabitedSort,[Inhabited.mk, PUnit],[Inhabited]]
[Decidable.by_cases,[Decidable.byCases],[]]
[Lean.Meta.elimOptParam,[Lean.Core.transform, ite, Eq, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Bool.true, Pure.pure, Lean.TransformStep.visit, Lean.Expr.getArg!, Lean.Expr.getAppNumArgs, Lean.TransformStep.done],[Lean.Core.CoreM, Lean.Expr]]
[instOfNatUInt32,[OfNat.mk, UInt32.ofNat],[OfNat, UInt32]]
[IO.Error.noSuchThing.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.noSuchThing, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.noSuchThing, And]]
[Nat.toSuperscriptString,[List.asString, Nat.toSuperDigits],[String]]
[Lean.ParametricAttribute.mk.inj,[And.intro],[And, Eq]]
[Equiv.trans.proof_2,[Function.right_inverse.comp, Equiv.rightInv],[Function.right_inverse, Function.comp, Equiv.invFun, Equiv.toFun]]
[Lean.Parser.ParserExtension.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserExtension.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.ParserExtension.State.mk, And]]
[Lean.Elab.Command.addUnivLevel,[Lean.withRef, Bind.bind, Lean.Elab.Command.getLevelNames, ite, Eq, List.elem, Bool.true, Lean.Elab.throwAlreadyDeclaredUniverseLevel, Lean.Elab.Command.modifyScope, Lean.Elab.Command.Scope.mk, Lean.Elab.Command.Scope.header, Lean.Elab.Command.Scope.opts, Lean.Elab.Command.Scope.currNamespace, Lean.Elab.Command.Scope.openDecls, List.cons, Lean.Elab.Command.Scope.levelNames, Lean.Elab.Command.Scope.varDecls, Lean.Elab.Command.Scope.varUIds, Lean.Elab.Command.Scope.isNoncomputable],[Lean.Elab.Command.CommandElabM, Unit]]
[Lean.Declaration.defnDecl.injEq,[Eq.propIntro, Eq.refl, Lean.Declaration.defnDecl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Declaration.defnDecl]]
[Lean.instInhabitedInductiveVal,[Inhabited.mk, Lean.InductiveVal.mk, arbitrary],[Inhabited, Lean.InductiveVal]]
[Lean.Parser.Error.expected,[],[List, String]]
[Function.combine,[],[]]
[Lean.Name.str.inj,[And.intro],[And, Eq]]
[Lean.Parser.checkLinebreakBeforeFn,[ite, Eq, Lean.Parser.checkTailLinebreak, Bool.true, Lean.Parser.ParserState.mkError],[Lean.Parser.ParserFn]]
[Lean.getOptionDefaulValue,[Bind.bind, Lean.getOptionDecl, Pure.pure, Lean.OptionDecl.defValue],[IO, Lean.DataValue]]
[Lean.mkApp2,[Lean.mkAppB],[Lean.Expr]]
[Lean.PPContext.opts,[],[Lean.Options]]
[Lean.Lsp.DiagnosticWith.noConfusionType,[],[]]
[Lean.Server.DocumentMeta.noConfusionType,[],[]]
[Nat.div_eq,[congrFun, WellFounded.fix_eq, WellFoundedRelation.wf, measure, id, dite, And, LT.lt, OfNat.ofNat, LE.le, HAdd.hAdd, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le, Nat.zero, dif_eq_if, HDiv.hDiv],[Eq, HDiv.hDiv, ite, And, LT.lt, OfNat.ofNat, LE.le, HAdd.hAdd, HSub.hSub]]
[StateRefT'.instAlternativeStateRefT',[inferInstanceAs, Alternative, ReaderT, ST.Ref],[Alternative, StateRefT']]
[Lean.Elab.DefView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.DefView.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.Watchdog.GroupedEdits.noConfusionType,[],[]]
[Lean.Elab.Term.getMVarErrorInfo?,[Bind.bind, MonadState.get, Pure.pure, Std.RBMap.find?, Lean.Elab.Term.State.mvarErrorInfos],[Lean.Elab.Term.TermElabM, Option, Lean.Elab.Term.MVarErrorInfo]]
[Lean.Elab.Term.Quotation.Precheck.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.Quotation.Precheck.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Quotation.Precheck.Context.mk]]
[Lean.Elab.instInhabitedDefView,[Inhabited.mk, Lean.Elab.DefView.mk, arbitrary],[Inhabited, Lean.Elab.DefView]]
[Lean.Parser.Command.postfix,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Lsp.RpcConnected.sessionId,[],[UInt64]]
[Lean.Elab.Term.withoutModifyingElabMetaStateWithInfo,[Bind.bind, MonadState.get, getThe, Lean.Meta.State, tryFinally, Lean.Elab.withSaveInfoContext, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState, MonadStateOf.set],[Lean.Elab.Term.TermElabM]]
[Lean.Attribute.Builtin.getId?,[Bind.bind, Lean.Attribute.Builtin.getIdent?, Pure.pure, Functor.map, Lean.Syntax.getId],[Lean.AttrM, Option, Lean.Name]]
[Lean.Lsp.instFileSourceWaitForDiagnosticsParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.WaitForDiagnosticsParams.uri],[Lean.Lsp.FileSource, Lean.Lsp.WaitForDiagnosticsParams]]
[Lean.instFVarIdHashSetInhabited,[Std.HashSet.instInhabitedHashSet],[Inhabited, Lean.FVarIdHashSet]]
[Lean.Module.header,[],[Lean.Syntax]]
[Subarray.start,[],[Nat]]
[Lean.Parser.Attr.intro!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Name.num.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Name.num, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Name.num, And]]
[Lean.Meta.IndPredBelow.mkCtorType.rebuild,[Lean.Expr.withApp, Lean.Meta.IndPredBelow.Variables.innerType, Bind.bind, Lean.Meta.mkForallFVars, Lean.Meta.IndPredBelow.Variables.target, Bool.false, Bool.true, Pure.pure, Lean.Meta.IndPredBelow.mkCtorType.replaceTempVars],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Elab.Term.LValResolution.const.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LValResolution.const, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.LValResolution.const, And]]
[Lean.Meta.SizeOfSpecNested.main,[Bind.bind, liftM, Lean.Meta.isDefEq, ite, Eq, Bool.true, Lean.Meta.mkEqRefl, Lean.Meta.whnfI, Lean.Meta.unfoldDefinition, Lean.Meta.SizeOfSpecNested.main.loop, Lean.Meta.SizeOfSpecNested.main.step],[Lean.Meta.SizeOfSpecNested.M, Lean.Expr]]
[Lean.Elab.Command.elabReduce,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.withoutModifyingEnv, Lean.Elab.Command.runTermElabM, Option.some, Bind.bind, Lean.Elab.Term.elabTerm, Option.none, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Bool.false, liftM, Lean.Meta.instantiateMVars, Lean.Elab.Term.levelMVarToParam, OfNat.ofNat, Lean.Elab.Term.TermElabM, Unit, withTheReader, Lean.Core.Context, Lean.Core.Context.mk, Lean.KVMap.setBool, Lean.Core.Context.options, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats, Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.all, Lean.Meta.reduce, Lean.Elab.logInfoAt, Lean.MessageData.ofExpr, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[ne_false_of_eq_true,[Not, Eq, Bool.false],[Not, Eq, Bool.false]]
[Lean.ProjectionFunctionInfo.mk.inj,[And.intro],[And, Eq]]
[instLTUInt8,[LT.mk, UInt8.lt],[LT, UInt8]]
[Lean.Elab.Tactic.ElimApp.evalAlts.go,[Bind.bind, ForIn.forIn, MProd.mk, Lean.Elab.Tactic.TacticM, ForInStep, MProd, Array, Lean.MVarId, Lean.Syntax, Bool, liftM, Option.none, PUnit.unit, ite, Eq, BEq.beq, Lean.Meta.ElimAltInfo.name, Bool.true, Pure.pure, ForInStep.done, Option.some, Lean.Meta.ElimAltInfo.numFields, ForInStep.yield, Unit.unit, Lean.Elab.Term.TermElabM, Nat, MProd.fst, Array.findIdx?, Lean.Syntax.hasArgs, Lean.Syntax.getOp, OfNat.ofNat, Lean.Name.eraseMacroScopes, Lean.Syntax.getId, Lean.Name.mkStr, Lean.Name.anonymous, Array.getOp, Unit],[Lean.Elab.Tactic.TacticM, Unit]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Mathlib.Tactic.Lint.SimpLemmaInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Std.RBMap.find?,[Option, Std.RBNode.find],[Option]]
[Mathlib.ExtendedBinder.«binderTerm≤_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.ParserContext.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.TextDocumentSyncOptions.willSave,[],[Bool]]
[ExceptT.pure,[ExceptT.mk, Pure.pure, Except.ok],[ExceptT]]
[Lean.Parser.Term.doubleQuotedName.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.PrettyPrinter.Formatter.rawCh.formatter, Char.ofNat, Lean.Parser.Term.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Expr.mkDataForLet,[ite, GT.gt, HSub.hSub, Nat.pow, OfNat.ofNat, panicWithPosWithDecl, Lean.BinderInfo.default],[Lean.Expr.Data]]
[Lean.Parser.Command.openOnly.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.ident.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.UnificationHint.pattern,[],[Lean.Meta.UnificationConstraint]]
[Lean.Meta.UnificationHints.noConfusionType,[],[]]
[Lean.Elab.Deriving.implicitBinderF,[Lean.Parser.Term.implicitBinder, Bool.false],[Lean.Parser.Parser]]
[Lean.Parser.Tactic.safe,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.sepBy1],[Lean.ParserDescr]]
[Lean.Parser.Term.doIfLetBind.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.instInhabitedAttributeExtensionState,[Inhabited.mk, Lean.AttributeExtensionState.mk, arbitrary],[Inhabited, Lean.AttributeExtensionState]]
[Lean.Elab.GoalsAtResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.GoalsAtResult.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.Completion.find?,[IO, Option, Lean.Lsp.CompletionList, Option.none, Option.some, Prod.mk, Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofTermInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.InfoTree.foldInfo, Lean.Elab.CompletionInfo.namespaceId, Lean.Elab.CompletionInfo.endSection, Lean.Elab.ContextInfo.runMetaM, Bind.bind, StateRefT'.run, OptionT.run, Lean.Server.Completion.State.mk, Lean.Meta.MetaM, Pure.pure, Lean.Lsp.CompletionList.mk, Bool.true, HAppend.hAppend, Array.qsort, Decidable.decide, LT.lt, Lean.Lsp.CompletionItem.label, OfNat.ofNat, HSub.hSub, Array.size, Lean.Server.Completion.State.itemsMain, Lean.Server.Completion.State.itemsOther, Lean.Elab.TermInfo.lctx, MonadExcept.tryCatch, liftM, Lean.Meta.inferType, Lean.Elab.TermInfo.expr, Lean.Meta.instantiateMVars, EmptyCollection.emptyCollection, Prod.snd, Lean.Server.Completion.HoverInfo.after, Lean.Server.Completion.M, Unit, PUnit.unit, Lean.LocalContext.mk, Lean.getOptionDecls, Lean.MonadOptions.getOptions, ForIn.forIn, ForInStep, Array, Lean.Lsp.CompletionItem, Lean.MonadEnv.getEnv, Lean.Server.Completion.find?.choose],[IO, Option, Lean.Lsp.CompletionList]]
[Int.ofNat.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Int.ofNat, HAdd.hAdd, OfNat.ofNat]]
[IO.FS.instInhabitedSystemTime,[Inhabited.mk, IO.FS.SystemTime.mk, arbitrary],[Inhabited, IO.FS.SystemTime]]
[Lean.Parser.Tactic.caseArg,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.sepBy1, Lean.binderIdent, Lean.ParserDescr.symbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Name.toString,[Lean.Name.toStringWithSep, and, not, Lean.Name.isInaccessibleUserName, Lean.Name.hasMacroScopes, Lean.Name.toString.maybePseudoSyntax],[String]]
[Function.injective.has_left_inverse,[Exists.intro, Function.inv_fun, Function.left_inverse_inv_fun],[Function.has_left_inverse]]
[Lean.Expr.getAppFn,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, PProd.fst],[Lean.Expr]]
[instHashableBool,[Hashable.mk, Unit.unit, UInt64, OfNat.ofNat],[Hashable, Bool]]
[Lean.Elab.Frontend.Context.mk.inj,[],[Eq]]
[List.append_assoc,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HAppend.hAppend, List.cons_append, List.cons, eq_self],[Eq, HAppend.hAppend]]
[Lean.MessageData.ofSyntax.inj,[],[Eq]]
[Lean.Import.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Import.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Import.mk, And]]
[Lean.Meta.Simp.discharge?,[Bind.bind, MonadReader.read, liftM, Lean.Meta.Simp.Methods.discharge?],[Lean.Meta.Simp.M, Option, Lean.Expr]]
[Lean.JsonRpc.ErrorCode.noConfusion,[noConfusionEnum, Lean.JsonRpc.ErrorCode.toCtorIdx],[Lean.JsonRpc.ErrorCode.noConfusionType]]
[Lean.Elab.Deriving.BEq.mkAuxFunction,[Bind.bind, Pure.pure, Array.getOp, Lean.Elab.Deriving.Context.auxFunNames, Lean.Elab.Deriving.Context.typeInfos, Lean.Elab.Deriving.BEq.mkBEqHeader, Lean.Elab.Deriving.BEq.mkMatch, ite, Eq, Lean.Elab.Deriving.Context.usePartial, Bool.true, Lean.Elab.Deriving.mkLocalInstanceLetDecls, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.Deriving.Header.argNames, Lean.Elab.Deriving.mkLet, PUnit.unit],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Lean.Parser.TrailingParser,[Lean.Parser.Parser],[]]
[Std.PersistentHashMap.erase,[Std.PersistentHashMap, Std.PersistentHashMap.mk, ite, Eq, Bool.true, HSub.hSub, OfNat.ofNat],[Std.PersistentHashMap]]
[Lean.Elab.WF.TerminationHintValue.mk.inj,[And.intro],[And, Eq]]
[Squash.ind,[Quot.ind],[]]
[Lean.Meta.instInhabitedDefaultInstances,[Inhabited.mk, Lean.Meta.DefaultInstances.mk, arbitrary],[Inhabited, Lean.Meta.DefaultInstances]]
[Int.neg_ofNat_of_succ,[rfl],[Eq, Neg.neg, Int.ofNat, Nat.succ, Int.negSucc]]
[funext,[],[Eq]]
[Lean.Meta.instReduceEvalOption,[Lean.Meta.ReduceEval.mk, Bind.bind, Lean.Meta.whnf, Pure.pure, Lean.Expr.getAppFn, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Option, ite, Eq, and, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Bool.true, Option.none, Functor.map, Option.some, Lean.Meta.reduceEval, Lean.Expr.appArg!, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr],[Lean.Meta.ReduceEval, Option]]
[Lean.Elab.MacroStackElem.after,[],[Lean.Syntax]]
[Lean.Elab.Command.elabInductiveViews,[Bind.bind, Lean.Elab.Command.runTermElabM, Option.some, Lean.Elab.Command.InductiveView.declName, Lean.withRef, Lean.Elab.Term.getLevelNames, ite, GT.gt, Array.size, OfNat.ofNat, ForIn.forIn, PUnit.unit, Eq, BEq.beq, Lean.Elab.Command.InductiveView.levelNames, Bool.true, Pure.pure, ForInStep.yield, Lean.throwErrorAt, Lean.Elab.Command.InductiveView.ref, Lean.ToMessageData.toMessageData, Lean.Elab.Term.withLevelNames, List.toArray, List.nil, Lean.Elab.Modifiers.isUnsafe, Lean.Elab.Command.InductiveView.modifiers, Lean.Elab.Command.ElabHeaderResult.view, Lean.Elab.Command.ElabHeaderResult.params, Option.none, Array.mapM, Lean.Meta.withLCtx, Lean.Elab.Command.ElabHeaderResult.lctx, Lean.Elab.Command.ElabHeaderResult.localInsts, liftM, Lean.Meta.mkForallFVars, Lean.Elab.Command.ElabHeaderResult.type, Bool.false, Prod.mk, Lean.Elab.Command.InductiveView.shortDeclName, Lean.Meta.inferType, Lean.Meta.forallTelescopeReducing, Decidable.decide, List.mapM, Lean.Elab.Term.withAutoBoundImplicit, Lean.Elab.Term.elabBinders, Lean.Syntax.getArgs, Lean.Elab.Command.CtorView.binders, Lean.Elab.Command.CtorView.ref, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Lean.Elab.Term.addAutoBoundImplicits, Lean.Constructor.mk, Lean.Elab.Command.CtorView.declName, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Constructor, Lean.Elab.Command.CtorView.type?, Lean.throwError, Lean.Elab.Term.elabType, Lean.Elab.Term.synthesizeSyntheticMVars, Lean.Meta.instantiateMVars, Lean.Meta.transform, Lean.TransformStep.done, Lean.Expr.getAppFn, HAppend.hAppend, Lean.indentExpr, Array.toList, Lean.Elab.Command.InductiveView.ctors, Lean.Level, Lean.InductiveType.type, Lean.Meta.whnfD, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Elab.Command.shouldInferResultUniverse, StateRefT'.run, List.forM, Lean.Meta.collectUsedFVars, Lean.InductiveType.ctors, Lean.Constructor.type, Lean.CollectFVars.State.mk, Prod, Lean.LocalContext, Lean.LocalInstances, Array, Lean.Expr, Lean.Meta.removeUnused, Lean.Constructor.name, Lean.InductiveType.mk, Lean.InductiveType.name, StateRefT'.run', Lean.Elab.Term.levelMVarToParam', Lean.Level.isParam, Lean.Elab.Command.checkResultingUniverse, Lean.Meta.mkSizeOfInstances, Lean.Meta.IndPredBelow.mkBelow, Lean.Meta.mkInjectiveTheorems, Lean.NameSet.contains, Lean.Elab.DerivingClassView.applyHandlers],[Lean.Elab.Command.CommandElabM, Unit]]
[Lean.Parser.Command.moduleDoc.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.ppDedent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.commentBody.parenthesizer, Lean.Parser.ppLine.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[List.hasDecEq.proof_6,[absurd],[False]]
[Lean.Expr.binderInfoEx,[Lean.Expr.binderInfo],[Lean.BinderInfo]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.subExpr,[],[Lean.PrettyPrinter.Delaborator.SubExpr]]
[Lean.Parser.Command.structImplicitBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Command.declModifiers.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.inferMod.parenthesizer, Lean.Parser.Command.declSig.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[«term_<||>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[USize.neg_def,[rfl],[Eq, Neg.neg, USize.mk, USize.val]]
[em,[Classical.em],[Or, Not]]
[IO.mapTasks,[EIO.mapTasks],[BaseIO, Task, Except, IO.Error]]
[Lean.Elab.Term.withoutPostponingUniverseConstraints,[Bind.bind, liftM, Lean.Meta.getResetPostponed, MonadExcept.tryCatch, Lean.Meta.processPostponed, Bool.false, Bool.true, ite, Eq, Pure.pure, PUnit.unit, Lean.Meta.getPostponed, ForIn.forIn, MProd.mk, Lean.Level.normLt, Lean.Elab.Term.TermElabM, ForInStep, MProd, Std.HashSet, Prod, Lean.Level, Array, Lean.Meta.PostponedEntry, Unit, Lean.Meta.mkLevelStuckErrorMessage, Array.getOp, Lean.Elab.logErrorAt, Lean.Meta.PostponedEntry.ref, ForInStep.yield, OfNat.ofNat, Lean.throwErrorAt, Lean.Meta.setPostponed, MonadExcept.throw, DoResultPR.pure],[Lean.Elab.Term.TermElabM]]
[eq_iff_iff,[Iff.symm, iff_iff_eq],[Iff, Eq]]
[Lean.Expr.app3?,[ite, Eq, Lean.Expr.isAppOfArity, OfNat.ofNat, Bool.true, Option.some, Prod.mk, Lean.Expr.appArg!, Lean.Expr.appFn!, Option.none],[Option, Prod, Lean.Expr]]
[Lean.ExprStructEq.mk.injEq,[Eq.propIntro, Eq.refl, Lean.ExprStructEq.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ExprStructEq.mk]]
[Lean.Elab.Term.Do.ToTerm.mkUVarTuple,[Bind.bind, MonadReader.read, Array.mapM, Lean.mkIdentFromRef, Lean.Elab.Term.Do.ToTerm.Context.uvars, liftM, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Array.getOp, Array.foldrM, Array.back, Array.extract, HSub.hSub],[Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax]]
[Lean.Parser.Command.postfix.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.NameTrie.forMatchingM,[Lean.PrefixTree.forMatchingM, List.nil, List, Lean.NamePart, PProd.fst, List.cons, Lean.NamePart.str, Lean.NamePart.num],[Unit]]
[Lean.mkAnd,[Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.Expr]]
[Nat.not_le_of_lt,[Nat.not_le_of_gt],[Not, LE.le]]
[Lean.Server.RequestContext.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.CongrTheorem.proof,[],[Lean.Expr]]
[Lean.Parser.Command.macroTail.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.macroTailTactic.parenthesizer, Lean.Parser.Command.macroTailCommand.parenthesizer, Lean.Parser.Command.macroTailDefault.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Float.lt,[FloatSpec.lt, floatSpec],[]]
[Lean.Elab.Term.MutualClosure.insertReplacementForMainFns,[Nat.fold, Std.RBMap.insert, Lean.Expr.fvarId!, Array.getOp, Lean.mkAppN, Lean.mkConst, Lean.Elab.DefViewElabHeader.declName, List.nil, Array.size],[Lean.Elab.Term.MutualClosure.Replacement]]
[Lean.Meta.casesAnd,[Bind.bind, Lean.Meta.casesRec, Lean.Meta.instantiateMVars, Lean.LocalDecl.type, Pure.pure, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.Meta.exactlyOne, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format],[Lean.Meta.MetaM, Lean.MVarId]]
[Int.le,[Int.NonNeg, HSub.hSub],[]]
[Lean.JsonRpc.instFromJsonNotification,[Lean.FromJson.mk, Bind.bind, Lean.FromJson.fromJson?, Lean.JsonRpc.Message.request, Lean.JsonRpc.Message.response, Lean.JsonRpc.Message.responseError, Except, String, Lean.JsonRpc.Notification, Pure.pure, Lean.ToJson.toJson, Lean.JsonRpc.Notification.mk, MonadExcept.throw],[Lean.FromJson, Lean.JsonRpc.Notification]]
[Std.AssocList.cons.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.AssocList.cons, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.AssocList.cons, And]]
[Lean.Meta.SynthInstance.instInhabitedGeneratorNode,[Inhabited.mk, Lean.Meta.SynthInstance.GeneratorNode.mk, arbitrary],[Inhabited, Lean.Meta.SynthInstance.GeneratorNode]]
[Lean.Elab.Command.checkValidInductiveModifier,[ite, Eq, Lean.Elab.Modifiers.isNoncomputable, Bool.true, Bind.bind, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Unit]]
[Eq.mpr_prop,[Eq.symm],[]]
[termSudoSet_option___In_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Nat.not_lt_zero,[Nat.not_succ_le_zero],[Not, LT.lt, OfNat.ofNat]]
[Ordering.noConfusionType,[noConfusionTypeEnum, Ordering.toCtorIdx],[]]
[Nat.ne_of_beq_eq_false,[False],[Not, Eq]]
[Lean.Elab.goalsToMessageData,[Lean.MessageData.joinSep, List.map, Lean.MessageData.ofGoal, Lean.ToMessageData.toMessageData],[Lean.MessageData]]
[IO.AsyncList.cons.inj,[And.intro],[And, Eq]]
[Lean.AttributeImplBuilderTable,[Std.HashMap, Lean.Name, Lean.AttributeImplBuilder],[]]
[Std.HashMapImp.fold,[Std.HashMapImp.foldBuckets, Std.HashMapImp.buckets],[]]
[Char.instLEChar,[LE.mk, Char.le],[LE, Char]]
[Lean.Meta.IndPredBelow.mkContext.motiveType,[Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.InductiveVal.toConstantVal, Bind.bind, Lean.Meta.mkArrow, Lean.mkAppN, Lean.Meta.IndPredBelow.mkContext.mkIndValConst, Lean.mkSort, Lean.levelZero, Lean.Meta.mkForallFVars, Bool.false, Bool.true],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.MonadCacheT.instMonadFinallyMonadCacheT,[inferInstanceAs, MonadFinally, StateRefT', Std.HashMap],[MonadFinally, Lean.MonadCacheT]]
[Substring.next,[String.Pos, ite, Eq, HSub.hSub, String.next],[String.Pos]]
[Lean.IR.CtorInfo.beq,[Bool, and, BEq.beq],[Bool]]
[Lean.Parser.ParserState.mkErrorsAt,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Array.push, Lean.Syntax.missing, Option.some, Lean.Parser.Error.mk, Array.shrink],[Lean.Parser.ParserState]]
[Lean.Lsp.instFromJsonPlainTermGoal,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, String, Lean.Lsp.Range, Pure.pure, Lean.Lsp.PlainTermGoal.mk],[Lean.FromJson, Lean.Lsp.PlainTermGoal]]
[Lean.Elab.Structural.EqnInfo.declName,[],[Lean.Name]]
[Lean.Lsp.DiagnosticCode.int.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.DiagnosticCode.int, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.Do.getLetEqnsDeclVar,[Lean.Syntax.getId, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Name]]
[Lean.Meta.Config.zetaNonDep,[],[Bool]]
[Lean.Parser.Tactic.applyWith',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Meta.kabstract,[Bind.bind, Lean.Meta.instantiateMVars, ite, Eq, and, Lean.Expr.isFVar, BEq.beq, Lean.Occurrences.all, Bool.true, Pure.pure, Lean.Expr.abstract, List.toArray, List.cons, List.nil, StateRefT'.run', OfNat.ofNat, Lean.Meta.kabstract.visit],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.IR.Expr.noConfusionType,[],[]]
[Lean.Rat.sub,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, HSub.hSub, HMul.hMul, Lean.Rat.num, Int.ofNat, Lean.Rat.den, HDiv.hDiv],[Lean.Rat]]
[Lean.HeadIndex.lit.inj,[],[Eq]]
[«term∃_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Command.InductiveView.declName,[],[Lean.Name]]
[Lean.Elab.instInhabitedTerminationHints,[Inhabited.mk, Lean.Elab.TerminationHints.mk, arbitrary],[Inhabited, Lean.Elab.TerminationHints]]
[Lean.Meta.Match.MkMatcherInput.matchType,[],[Lean.Expr]]
[Lean.Meta.Contradiction.Config.genDiseq,[],[Bool]]
[Lean.Compiler.SpecState.mk.inj,[And.intro],[And, Eq]]
[Lean.EnvExtension.modifyState,[Lean.EnvExtensionInterface.modifyState, Lean.EnvExtensionInterfaceImp],[Lean.Environment]]
[Lean.Elab.Term.elabMVarWithIdKind,[Pure.pure, Lean.mkInaccessible, Lean.mkMVar, Lean.Elab.Term.getMVarSyntaxMVarId],[Lean.Elab.Term.TermElab]]
[Function.involutive.surjective,[Exists.intro],[Function.surjective]]
[orM,[Bind.bind, Unit.unit, ToBool.toBool, Pure.pure],[]]
[List.mem_erasep_of_neg,[Iff.intro, List.mem_of_mem_erasep, Or.elim, List.exists_or_eq_self_of_erasep, Eq.mpr, Eq.refl, Mem.mem, List.erasep],[Iff, Mem.mem, List.erasep]]
[IO.Error.hardwareFault.inj,[And.intro],[And, Eq]]
[Lean.mkCasesOnName,[Lean.Name.mkStr, Lean.casesOnSuffix],[Lean.Name]]
[Lean.Lsp.instToJsonRpcReleaseParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.RpcReleaseParams.uri, List.nil, Lean.Lsp.RpcReleaseParams.sessionId, Lean.Lsp.RpcReleaseParams.refs],[Lean.ToJson, Lean.Lsp.RpcReleaseParams]]
[Lean.Expr.isCharLit,[and, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.Expr.isNatLit, Lean.Expr.appArg!],[Bool]]
[Substring.extract,[Substring, ite, GE.ge, Substring.mk, OfNat.ofNat, Nat.min, HAdd.hAdd],[Substring]]
[Lean.Meta.reduceNative?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Option, Lean.Expr, ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Meta.reduceBoolNative, Pure.pure, Option.some, Lean.ToExpr.toExpr, Lean.Meta.reduceNatNative, Option.none],[Lean.Meta.MetaM, Option, Lean.Expr]]
[Lean.Meta.mkImpCongr,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Name.appendIndexAfter,[Lean.Name.modifyBase, Lean.Name.anonymous, Lean.Name.num, Lean.Name, Lean.Name.mkStr, HAppend.hAppend, ToString.toString],[Lean.Name]]
[Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.mk.inj,[And.intro],[And, Eq]]
[Mathlib.ExtendedBinder.extBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Mathlib.ExtendedBinder.extBinder, Mathlib.ExtendedBinder.extBinderCollection],[Lean.ParserDescr]]
[Lean.Elab.Term.logUnassignedUsingErrorInfos,[Bind.bind, MonadState.get, ForIn.forIn, MProd.mk, Lean.Elab.Term.TermElabM, ForInStep, MProd, Bool, Array, Lean.Elab.Term.MVarErrorInfo, Lean.MVarIdSet, ite, Eq, Std.RBTree.contains, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, liftM, Lean.Meta.getMVars, Lean.mkMVar, Array.any, Array.contains, OfNat.ofNat, Array.size, Lean.Meta.withMVarContext, Lean.Elab.Term.MVarErrorInfo.mvarId, Lean.Elab.Term.MVarErrorInfo.logError],[Lean.Elab.Term.TermElabM, Bool]]
[Lean.JsonRpc.Message.request.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.JsonRpc.Message.request, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.anonymousCtor.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy.formatter, Lean.Parser.termParser.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Tactic.zify,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Meta.withLocalDeclD,[Lean.Meta.withLocalDecl, Lean.BinderInfo.default],[]]
[Std.ShareCommon.PersistentState.shareCommon,[Prod.mk],[Prod, Std.ShareCommon.PersistentState]]
[Lean.IR.FnBody.set.inj,[And.intro],[And, Eq]]
[le_total,[LinearOrder.le_total],[Or, LE.le]]
[Lean.ConstantVal.type,[],[Lean.Expr]]
[Lean.Xml.Parser.contentspec,[HOrElse.hOrElse, Lean.Parsec.skipString, Lean.Xml.Parser.Mixed, Lean.Xml.Parser.children],[Lean.Parsec, Unit]]
[instReprStdGen,[Repr.mk, Std.Format, Std.Format.bracket, HAppend.hAppend, repr, Std.Format.text],[Repr, StdGen]]
[Lean.IR.VarId.alphaEqv,[Unit.unit, Bool, Std.RBMap.find?, Lean.IR.VarId.idx, BEq.beq],[Bool]]
[String.modify,[String.set, String.get],[String]]
[IO.Error.unsupportedOperation.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.unsupportedOperation, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.unsupportedOperation, And]]
[Lean.Parser.Term.letrec,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, Lean.Parser.group, Lean.Parser.symbol, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.Term.letRecDecls, Lean.Parser.Term.optSemicolon, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.Parser.Command.visibility.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.private.parenthesizer, Lean.Parser.Command.protected.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[instDivUInt8,[Div.mk, UInt8.div],[Div, UInt8]]
[Std.RBNode.insert,[ite, Eq, Std.RBNode.isRed, Bool.true, Std.RBNode.setBlack, Std.RBNode.ins],[Std.RBNode]]
[Subtype.coe_eq_iff,[Iff.intro, Exists.intro, Subtype.property, Eq.symm, Subtype.coe_eta, Eq, Subtype.val, rfl],[Iff, Eq, Subtype.val, Exists, Subtype.mk]]
[Array.appendList,[List.foldl, Array.push],[Array]]
[instSemiringFin.proof_11,[rfl],[Eq, OfNat.ofNat]]
[Lean.Elab.Command.StructView.scopeLevelNames,[],[List, Lean.Name]]
[Lean.JsonRpc.instInhabitedResponse,[Inhabited.mk, Lean.JsonRpc.Response.mk, arbitrary],[Inhabited, Lean.JsonRpc.Response]]
[Lean.Elab.Tactic.Conv.congr,[Lean.Meta.withMVarContext, Bind.bind, Lean.Elab.Tactic.Conv.getLhsRhsCore, Lean.Meta.MetaM, List, Lean.MVarId, Lean.Meta.instantiateMVars, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, List, Lean.MVarId]]
[StateT.instLawfulMonadStateT.proof_1,[LawfulMonad.mk, StateT.ext, Eq.mpr, congr, congrArg, Eq, Eq.trans, StateT.run_bind, Pure.pure, Bind.bind, StateT.run, funext, StateT.run_pure, Prod.fst, Prod.snd, StateT.run_map, LawfulMonad.bind_pure_comp, Prod.mk, rfl, of_eq_true, congrFun, LawfulMonad.pure_bind, eq_self, LawfulMonad.bind_assoc],[LawfulMonad, StateT]]
[Lean.PrettyPrinter.Formatter.checkPrec.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[Std.RBMap.all,[Bool, Std.RBNode.all],[Bool]]
[Int.zero_ne_one,[sorryAx, False, Bool.true],[Ne, OfNat.ofNat]]
[Lean.Elab.Term.traceAtCmdPos,[Lean.withRef, Lean.Syntax.missing, Lean.Elab.trace],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Elab.Term.instToStringPatternVar,[ToString.mk, String, ToString.toString, HAppend.hAppend, Lean.MVarId.name],[ToString, Lean.Elab.Term.PatternVar]]
[Lean.Elab.Command.instMonadRefCommandElabM,[Lean.MonadRef.mk, Lean.Elab.Command.getRef, MonadWithReader.withReader, Lean.Elab.Command.Context.mk, Lean.Elab.Command.Context.fileName, Lean.Elab.Command.Context.fileMap, Lean.Elab.Command.Context.currRecDepth, Lean.Elab.Command.Context.cmdPos, Lean.Elab.Command.Context.macroStack, Lean.Elab.Command.Context.currMacroScope],[Lean.MonadRef, Lean.Elab.Command.CommandElabM]]
[Lean.Parser.Module.import.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.CollectMaps.collectVar,[Prod, Lean.IR.VarTypeMap, Lean.IR.JPParamsMap, Prod.mk, Std.HashMap.insert],[Lean.IR.CollectMaps.Collector]]
[Lean.Elab.Term.Do.attachJP,[Lean.Elab.Term.Do.Code.joinpoint, Lean.Elab.Term.Do.JPDecl.name, Lean.Elab.Term.Do.JPDecl.params, Lean.Elab.Term.Do.JPDecl.body],[Lean.Elab.Term.Do.Code]]
[Lean.Parser.Command.include,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[IO.AccessRight.write,[],[Bool]]
[Lean.Level.instToStringLevel,[ToString.mk, Std.Format.pretty, Lean.Level.format, Std.Format.defWidth],[ToString, Lean.Level]]
[Function.inv_fun_on_neg,[],[Eq, Function.inv_fun_on, Classical.choice]]
[Lean.JsonRpc.Notification.param,[],[]]
[«term_⊆_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.MessageData.ofFormat.inj,[],[Eq]]
[Lean.Parser.Command.simp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.parser, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.PrettyPrinter.Parenthesizer.withOpenDecl.parenthesizer,[],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.KeyedDeclsAttribute.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KeyedDeclsAttribute.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KeyedDeclsAttribute.mk, And]]
[Lean.Parser.Tactic.refine',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.PPContext.currNamespace,[],[Lean.Name]]
[Lean.Elab.TerminationHints.decreasingBy?,[],[Option, Lean.Syntax]]
[imp_congr,[imp_congr_ctx],[Iff]]
[Std.RBTree.fold,[Std.RBMap.fold],[]]
[Lean.Elab.Tactic.evalTacticSeq1Indented,[Lean.Elab.Tactic.evalManyTacticOptSemi, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Elab.Tactic.Tactic]]
[Lean.Elab.Tactic.evalTacticSeqBracketed,[Bind.bind, Lean.Elab.Tactic.mkInitialTacticInfo, Lean.Syntax.getOp, OfNat.ofNat, Lean.withRef, Lean.Elab.Tactic.closeUsingOrAdmit, Lean.Elab.withInfoContext, Pure.pure, Unit.unit, Lean.Elab.Tactic.evalManyTacticOptSemi],[Lean.Elab.Tactic.Tactic]]
[Lean.Meta.Simp.ConfigCtx.mk.inj,[],[Eq]]
[IO.Error.mkTimeExpired,[IO.Error.timeExpired],[IO.Error]]
[Nat.div_eq_sub_div,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HAdd.hAdd, HSub.hSub, OfNat.ofNat, Nat.div_eq, ite, And, LT.lt, LE.le, if_pos, And.intro, rfl],[Eq, HDiv.hDiv, HAdd.hAdd, HSub.hSub, OfNat.ofNat]]
[Lean.Elab.Tactic.MkSimpContextResult.fvarIdToLemmaId,[],[Lean.Meta.FVarIdToLemmaId]]
[Lean.Lsp.ClientInfo.noConfusionType,[],[]]
[Lean.IR.UnreachableBranches.Value.ibelow,[True, And],[]]
[Lean.Parser.Term.suffices.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.sufficesDecl.formatter, Lean.Parser.Term.optSemicolon.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Tactic.linarith!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy],[Lean.ParserDescr]]
[coeTrans,[CoeTC.mk, coeB, coeTC],[CoeTC]]
[Lean.LocalContext.findFVar?,[Lean.LocalContext.find?, Lean.Expr.fvarId!],[Option, Lean.LocalDecl]]
[instMonadST,[inferInstanceAs, Monad, EST, Empty],[Monad, ST]]
[ExceptT.bindCont,[Except, Pure.pure, Except.error],[Except]]
[Lean.Parser.Trie.below,[PProd, PUnit],[]]
[Lean.Elab.OpenDecl.resolveId,[Bind.bind, Lean.MonadEnv.getEnv, ite, Eq, Lean.Environment.contains, Bool.true, Pure.pure, Lean.withRef, Lean.resolveGlobalConstNoOverloadCore],[Lean.Elab.OpenDecl.M, Lean.Name]]
[instInhabitedTask,[Inhabited.mk, Task.pure, arbitrary],[Inhabited, Task]]
[Nat.not_lt,[Iff.intro, Nat.le_of_not_lt, Nat.not_lt_of_le],[Iff, Not, LT.lt, LE.le]]
[Lean.Meta.InductionSubgoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.InductionSubgoal.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.JsonNumber.lt,[Bool, dite, Eq, Prod.mk, Int.ofNat, Unit.unit, Eq.symm, Int.negSucc, Bool.true, Bool.false, ite, LT.lt, GT.gt, Decidable.decide],[Bool]]
[Lean.Parser.Term.haveIdLhs.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.many.formatter, Lean.ppSpace.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.simpleBinderWithoutType.formatter, Lean.Parser.Term.bracketedBinder.formatter, Bool.false, Lean.Parser.Term.optType.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Tactic.Conv.evalPattern,[Lean.Elab.Tactic.withMainContext, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, liftM, Lean.Elab.Term.withoutPending, Lean.Elab.Term.elabTerm, Option.none, Lean.Meta.abstractMVars, Lean.Elab.Tactic.Conv.getLhs, IO.mkRef, Lean.Meta.getCongrLemmas, Pure.pure, Lean.Meta.Simp.Context.mk, Lean.Meta.Simp.Config.mk, Bool.false, Lean.Meta.SimpLemmas.mk, Lean.Meta.Simp.main, Lean.Meta.Simp.Methods.mk, ST.Ref.get, Option.isSome, Lean.Meta.Simp.Step.visit, Lean.Meta.Simp.Result.mk, Lean.Elab.Tactic.Conv.matchPattern?, Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step, Lean.Elab.Tactic.Conv.mkConvGoalFor, ST.Ref.set, Option.some, ForIn.forIn, Lean.Meta.mkCongrFun, PUnit.unit, ForInStep.yield, Lean.Meta.Simp.Step.done, Lean.mkAppN, Lean.Meta.MetaM, Option, Prod, Lean.MVarId, Lean.Meta.Simp.Result, Prod.mk, Lean.Expr.mvarId!, Unit.unit, Lean.Elab.Tactic.TacticM, Unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Meta.Simp.Result.getProof, Lean.Elab.Tactic.Conv.updateLhs, Lean.Meta.Simp.Result.expr, Lean.Elab.Tactic.getMainGoal, Lean.Meta.applyRefl, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.nil, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[Lean.Lsp.ServerInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.UnreachableBranches.instReprValue,[Repr.mk],[Repr, Lean.IR.UnreachableBranches.Value]]
[Stream.forIn,[Stream.forIn.visit],[]]
[Lean.Parser.Parser.noConfusionType,[],[]]
[Lean.Name.quickCmpAux,[Unit.unit, Lean.Name.str, Lean.Name.num, Ordering, Ordering.eq, Ordering.lt, Ordering.gt, Ord.compare, PProd.fst],[Ordering]]
[Lean.NamingContext.openDecls,[],[List, Lean.OpenDecl]]
[Lean.Parser.Command.declVal.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.declValSimple.formatter, Lean.Parser.Command.declValEqns.formatter, Lean.Parser.Command.whereStructInst.formatter],[Lean.PrettyPrinter.Formatter]]
[List.reverseAux,[List, PProd.fst, List.cons],[List]]
[Lean.Server.Watchdog.handleRequest,[ite, Eq, BEq.beq, Bool.true, Bind.bind, Lean.Server.Watchdog.parseParams, Lean.Lsp.RpcConnectParams, Pure.pure, Lean.Lsp.FileSource.fileSource, liftM, Lean.Server.routeLspRequest, Lean.Server.Watchdog.ServerM, Unit, MonadReader.read, IO.FS.Stream.writeLspResponseError, Lean.Server.Watchdog.ServerContext.hOut, Lean.Server.RequestError.toLspResponseError, PUnit.unit],[Lean.Server.Watchdog.ServerM, Unit]]
[Lean.Parser.Term.doTry.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.doSeq.formatter, Lean.Parser.many.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.doCatch.formatter, Lean.Parser.Term.doCatchMatch.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.doFinally.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.PrettyPrinter.Delaborator.returnsPi,[Lean.Meta.lambdaTelescope, Pure.pure, Lean.Expr.isForall],[Lean.Meta.MetaM, Bool]]
[String.Iterator.prev,[String.Iterator, String.Iterator.mk, String.prev],[String.Iterator]]
[Lean.PrettyPrinter.Parenthesizer.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.PrettyPrinter.Parenthesizer.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PrettyPrinter.Parenthesizer.Context.mk]]
[Lean.Elab.Term.Do.Code.noConfusionType,[],[]]
[Function.uncurry_def,[rfl],[Eq, Function.uncurry, Prod.fst, Prod.snd]]
[Lean.Xml.instToStringContent,[ToString.mk],[ToString, Lean.Xml.Content]]
[Lean.Lsp.DiagnosticWith.relatedInformation?,[],[Option, Array, Lean.Lsp.DiagnosticRelatedInformation]]
[Lean.mkConst,[Lean.Expr.const, Lean.Expr.mkData, mixHash, OfNat.ofNat, Hashable.hash, Bool.false, List.any, Lean.Level.hasMVar, Lean.Level.hasParam],[Lean.Expr]]
[Lean.Name.instAppendName,[Append.mk, Lean.Name.append],[Append, Lean.Name]]
[Lean.Elab.WF.TerminationHint.find?,[Unit.unit, Option, Lean.Elab.WF.TerminationHintValue, Option.none, Option.some, Array.findSome?, Lean.NameMap.find?],[Option, Lean.Elab.WF.TerminationHintValue]]
[Lean.Elab.Term.Do.mkUnless,[Bind.bind, Lean.Elab.Term.Do.mkPureUnitAction, Lean.MonadRef.getRef, Pure.pure, Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.ite, Option.none, Lean.mkNullNode, List.toArray, List.nil, Lean.Elab.Term.Do.CodeBlock.code, Lean.Elab.Term.Do.CodeBlock.uvars],[Lean.MacroM, Lean.Elab.Term.Do.CodeBlock]]
[Lean.Expr.updateProj!.proof_1,[rfl],[Eq, Lean.Expr.isProj, Lean.Expr.proj]]
[not_lt_of_gt,[lt_asymm],[Not, LT.lt]]
[Lean.Lsp.instFromJsonTextDocumentPositionParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.TextDocumentPositionParams.mk],[Lean.FromJson, Lean.Lsp.TextDocumentPositionParams]]
[instDecidableEqUInt8,[UInt8.decEq],[DecidableEq, UInt8]]
[Lean.KeyedDeclsAttribute.Def.valueTypeName,[],[Lean.Name]]
[Lean.Widget.MsgEmbed.instInhabitedRpcEncodingPacket,[Inhabited.mk, arbitrary],[Inhabited]]
[Subtype.map.proof_1,[Subtype.val, Subtype.prop],[Subtype.val]]
[Lean.Parser.finishCommentBlock.eoi,[Lean.Parser.ParserState.mkUnexpectedError, List.nil],[Lean.Parser.ParserState]]
[Lean.Lsp.CompletionItem.noConfusionType,[],[]]
[plift.up.injEq,[Eq.propIntro, Eq.refl, plift.up, Eq.symm, eq_of_heq, HEq.refl],[Eq, plift.up]]
[Lean.Elab.ExpandDeclIdResult.shortName,[],[Lean.Name]]
[Task.spawn,[Task.pure, Unit.unit],[Task]]
[Lean.Meta.getFunInfo,[Bind.bind, MonadState.get, Lean.Meta.getTransparency, Unit.unit, Lean.Meta.MetaM, Lean.Meta.FunInfo, Std.PersistentHashMap.find?, Lean.Meta.Cache.funInfo, Lean.Meta.State.cache, Lean.Meta.InfoCacheKey.mk, Pure.pure, modify, Lean.Meta.State.mk, Lean.Meta.State.mctx, Lean.Meta.Cache.mk, Lean.Meta.Cache.inferType, Std.PersistentHashMap.insert, Lean.Meta.Cache.synthInstance, Lean.Meta.Cache.whnfDefault, Lean.Meta.Cache.whnfAll, Lean.Meta.Cache.defEqDefault, Lean.Meta.Cache.defEqAll, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed, Lean.Meta.inferType, Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.default, Lean.Meta.forallBoundedTelescope, ForIn.forIn, Lean.Meta.getFVarLocalDecl, PUnit.unit, ForInStep.yield, Lean.Meta.FunInfo.mk, Option.none],[Lean.Meta.MetaM, Lean.Meta.FunInfo]]
[Lean.Server.RequestError.fileChanged,[Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.contentModified],[Lean.Server.RequestError]]
[Std.AssocList.empty,[Std.AssocList.nil],[Std.AssocList]]
[Nat.add_div_right,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HAdd.hAdd, Nat.succ, Nat.div_eq_sub_div, Nat.le_add_left, HSub.hSub, OfNat.ofNat, Nat.add_sub_cancel, rfl],[Eq, HDiv.hDiv, HAdd.hAdd, Nat.succ]]
[Lean.instToJsonUInt64,[Lean.ToJson.mk, Lean.bignumToJson, UInt64.toNat],[Lean.ToJson, UInt64]]
[Int.natAbs_one,[rfl],[Eq, Int.natAbs, OfNat.ofNat]]
[Lean.Parser.Term.doubleQuotedName.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.PrettyPrinter.Parenthesizer.rawCh.parenthesizer, Char.ofNat, Lean.Parser.Term.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.DidOpenTextDocumentParams.mk.inj,[],[Eq]]
[Lean.Elab.Info.ofMacroExpansionInfo.inj,[],[Eq]]
[Lean.Meta.SynthInstance.Waiter.isRoot,[Unit.unit, Bool, Bool.false, Bool.true],[Bool]]
[Lean.Parser.Tactic.nthRwRHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Nat.succ_lt_succ,[Nat.succ_le_succ],[LT.lt, Nat.succ]]
[Lean.Parser.orelse,[Lean.Parser.Parser.mk, Lean.Parser.orelseInfo, Lean.Parser.Parser.info, Lean.Parser.orelseFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.Parser.Command.declModifiers.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.docComment.parenthesizer, Lean.Parser.Term.attributes.parenthesizer, Lean.PrettyPrinter.Parenthesizer.ite, Eq, Lean.PrettyPrinter.Parenthesizer.skip.parenthesizer, Lean.Parser.ppDedent.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.Parser.Command.visibility.parenthesizer, Lean.Parser.Command.noncomputable.parenthesizer, Lean.Parser.Command.unsafe.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.partial.parenthesizer, Lean.Parser.Command.nonrec.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[lt_asymm,[lt_irrefl, lt_trans],[Not, LT.lt]]
[Lean.Meta.ElimInfo.name,[],[Lean.Name]]
[Int.neg_add,[],[Eq, Neg.neg, HAdd.hAdd]]
[Lean.Lsp.ServerCapabilities.typeDefinitionProvider,[],[Bool]]
[UInt16.instNegUInt16,[Neg.mk, UInt16.mk, Neg.neg, UInt16.val],[Neg, UInt16]]
[Lean.Lsp.ServerInfo.name,[],[String]]
[Lean.getPPAnalyzeTrustOfScientific,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.trustOfScientific, Lean.Option.defValue],[Bool]]
[Lean.MessageLog.mk.inj,[],[Eq]]
[Semiring.npow_succ',[],[Eq, Semiring.npow, Nat.succ, HMul.hMul]]
[Lean.Macro.Methods.hasDecl,[],[Lean.MacroM, Bool]]
[Lean.Meta.MetaM,[ReaderT, Lean.Meta.Context, StateRefT', IO.RealWorld, Lean.Meta.State, Lean.Core.CoreM],[]]
[Lean.OptionDecl.group,[],[String]]
[Lean.JsonRpc.ErrorCode.internalError.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.JsonRpc.ErrorCode.internalError, OfNat.ofNat]]
[Lean.PrettyPrinter.ppExpr,[Bind.bind, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.Meta.withLCtx, List.toArray, List.nil, Lean.PrettyPrinter.delab, EmptyCollection.emptyCollection, liftM, Lean.PrettyPrinter.ppTerm],[Lean.Meta.MetaM, Std.Format]]
[Lean.Rat.normalize,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, HDiv.hDiv, Lean.Rat.num, Int.ofNat, Lean.Rat.den],[Lean.Rat]]
[Lean.AttributeImpl.noConfusionType,[],[]]
[Std.shareCommon,[Std.ShareCommonM.run, Std.withShareCommon],[]]
[Function.on_fun,[],[]]
[Lean.Server.FileWorker.GoToKind.type.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Server.FileWorker.GoToKind.type, OfNat.ofNat]]
[Lean.SMap.find!,[Unit.unit, Lean.SMap.find?, panicWithPosWithDecl, OfNat.ofNat],[]]
[Lean.Parser.Term.proj.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.fieldIdx.formatter, Lean.Parser.Term.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.ParserContext.forbiddenTk?,[],[Option, Lean.Parser.Token]]
[Lean.PrettyPrinter.Parenthesizer.Context.noConfusionType,[],[]]
[Lean.Elab.Term.CollectPatternVars.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.CollectPatternVars.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.CollectPatternVars.State.mk, And]]
[instOrElseEIO,[OrElse.mk, MonadExcept.orElse],[OrElse, EIO]]
[Std.PersistentArrayNode.noConfusionType,[],[]]
[Lean.EnvExtensionInterfaceUnsafe.Ext.mkInitial,[],[IO]]
[Lean.Level.toNat,[Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Option, Nat, Lean.Level.getLevelOffset, Option.some, Lean.Level.getOffset, Option.none],[Option, Nat]]
[Lean.Parser.Term.optIdent.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Server.FileWorker.WorkerM,[ReaderT, Lean.Server.FileWorker.WorkerContext, StateRefT', IO.RealWorld, Lean.Server.FileWorker.WorkerState, IO],[]]
[Lean.ConstantVal.levelParams,[],[List, Lean.Name]]
[Lean.instToStringRat,[ToString.mk, ite, Eq, BEq.beq, Lean.Rat.den, OfNat.ofNat, Bool.true, ToString.toString, Lean.Rat.num, HAppend.hAppend],[ToString, Lean.Rat]]
[Set.«term⋃₀_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Command.def.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.Command.optDeclSig.formatter, Lean.Parser.Command.declVal.formatter, Lean.Parser.Command.optDefDeriving.formatter, Lean.Parser.Command.terminationSuffix.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.AxiomVal.isUnsafeEx,[Lean.AxiomVal.isUnsafe],[Bool]]
[dite,[],[]]
[Lean.Parser.Term.pipeProj,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.minPrec, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.checkNoWsBefore, HOrElse.hOrElse, Lean.Parser.fieldIdx, Lean.Parser.Term.ident, Lean.Parser.many, Lean.Parser.Term.argument],[Lean.Parser.TrailingParser]]
[Lean.Meta.tryUnificationHints,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Meta.tryUnificationHints.isDefEqPattern, Lean.Meta.tryUnificationHints.tryCandidate],[Lean.Meta.MetaM, Bool]]
[Lean.Parser.Command.print,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, HOrElse.hOrElse, Lean.Parser.ident, Lean.Parser.strLit],[Lean.Parser.Parser]]
[IO.FS.Stream.noConfusionType,[],[]]
[Lean.Elab.Term.MutualClosure.Replacement,[Lean.FVarIdMap, Lean.Expr],[]]
[Lean.Elab.Command.MkInstanceName.append,[modify, HAppend.hAppend],[Lean.Elab.Command.MkInstanceName.M, Unit]]
[Std.PersistentArrayNode.leaf.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.PersistentArrayNode.leaf, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.isReadOnlyLevelMVar,[Bind.bind, Lean.Meta.getConfig, ite, Eq, Lean.Meta.Config.ignoreLevelMVarDepth, Bool.true, Pure.pure, Bool.false, Lean.Meta.getLevelMVarDepth, Lean.MonadMCtx.getMCtx, bne, Lean.MetavarContext.depth],[Lean.Meta.MetaM, Bool]]
[Lean.Elab.Deriving.DecEq.mkDecEqEnum,[Bind.bind, Lean.Elab.Command.liftTermElabM, Option.none, liftM, Lean.Elab.Deriving.DecEq.mkEnumOfNat, Lean.Elab.Deriving.DecEq.mkEnumOfNatThm, Lean.getConstInfoInduct, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Lean.mkIdent, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, PUnit.unit],[Lean.Elab.Command.CommandElabM, Unit]]
[Lean.Compiler.foldNatBinPred,[OptionM.run, Bind.bind, Lean.Compiler.getNumLit, Pure.pure, Lean.Compiler.toDecidableExpr],[Option, Lean.Expr]]
[Lean.Elab.Tactic.Conv.evalExt,[ite, Eq, Array.isEmpty, Bool.true, Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Meta.withMVarContext, Lean.Elab.Tactic.Conv.getLhsRhsCore, Lean.Meta.MetaM, Lean.MVarId, Lean.Meta.instantiateMVars, Lean.Expr.isForall, Lean.Meta.mkConstWithFreshMVarLevels, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.apply, List.nil, List.cons, Lean.Meta.introN, OfNat.ofNat, Bool.false, Lean.Elab.Tactic.Conv.markAsConvGoal, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Meta.inferType, Lean.Meta.whnfD, Pure.pure, PUnit.unit, HAppend.hAppend, Lean.indentD, Lean.Elab.Tactic.replaceMainGoal, Option.none, ForIn.forIn, Lean.withRef, Option.some, Lean.Syntax.getId, ForInStep.yield],[Lean.Elab.Tactic.Tactic]]
[String.take,[Substring.toString, Substring.take, String.toSubstring],[String]]
[instShiftLeftUInt32,[ShiftLeft.mk, UInt32.shiftLeft],[ShiftLeft, UInt32]]
[Lean.Parser.Tactic.Conv.enterArg,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.IR.Borrow.InitParamMap.visitDecls,[Array.forM, Lean.IR.Decl.extern, StateM, Lean.IR.Borrow.ParamMap, PUnit, Bind.bind, modify, Std.HashMap.insert, Lean.IR.Borrow.ParamMap.Key.decl, Lean.IR.Borrow.InitParamMap.initBorrowIfNotExported, Lean.IR.Borrow.InitParamMap.visitFnBody, Pure.pure, Unit.unit, OfNat.ofNat, Array.size],[StateM, Lean.IR.Borrow.ParamMap, Unit]]
[List.not_exists_mem_nil,[False, Eq.refl],[Not, Exists, And, Mem.mem, List.nil]]
[Lean.Parser.ParserModuleContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.ParserModuleContext.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parsec.ParseResult.error.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parsec.ParseResult.error, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parsec.ParseResult.error, And]]
[Std.ShareCommon.ObjectPersistentMap.insert,[Std.PersistentHashMap.insert],[Std.ShareCommon.ObjectPersistentMap]]
[USize.instRingUSize.proof_2,[congrArg, USize.mk, Ring.gsmul_zero', USize.val],[Eq, USize.mk, Ring.gsmul, OfNat.ofNat, USize.val]]
[Lean.Parser.Term.bracketedBinder.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.PrettyPrinter.Formatter.evalInsideQuot.formatter, Lean.Parser.Term.bracketedBinder.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.GeneralizeArg.xName?,[],[Option, Lean.Name]]
[by_contradiction,[Decidable.by_contradiction],[]]
[Lean.Meta.modifyCache,[modify, Lean.Meta.State, Lean.Meta.State.mk],[Lean.Meta.MetaM, Unit]]
[Mathlib.Tactic.Lint.getLinters,[List.mapM, Mathlib.Tactic.Lint.getLinter],[Lean.Core.CoreM, List, Mathlib.Tactic.Lint.NamedLinter]]
[Lean.LocalContext.pop,[Lean.LocalContext, ite, Eq, BEq.beq, Std.PersistentArray.size, OfNat.ofNat, Bool.true, Unit.unit, Std.PersistentArray.get!, HSub.hSub, Lean.LocalContext.mk, Std.PersistentHashMap.erase, Lean.LocalDecl.fvarId, Std.PersistentArray.pop],[Lean.LocalContext]]
[exists_imp_exists,[Exists.elim, Exists.intro],[Exists]]
[List.cons_bind,[of_eq_true, eq_self, HAppend.hAppend, List.join, List.map],[Eq, List.bind, List.cons, HAppend.hAppend]]
[Lean.SimpleScopedEnvExtension.Descr.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.SimpleScopedEnvExtension.Descr.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.withoutPosition,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.Parser.fn, Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.prec, Lean.Parser.ParserContext.tokens, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Option.none, Lean.Parser.ParserContext.forbiddenTk?],[Lean.Parser.Parser]]
[Nat.find_x,[WellFounded.fix', WellFounded.intro, Acc, And, Eq, HAdd.hAdd, OfNat.ofNat, Not, dite, Subtype.mk, Nat.find_x.proof_1, Nat.find_x.proof_3],[Subtype, And, Not]]
[peirce,[Decidable.peirce],[]]
[IO.FS.Stream.ofBuffer,[IO.FS.Stream.mk, Bind.bind, ST.Ref.get, Pure.pure, Decidable.decide, GE.ge, IO.FS.Stream.Buffer.pos, ByteArray.size, IO.FS.Stream.Buffer.data, Unit.unit, ST.Ref.modifyGet, Prod.mk, IO.FS.Stream.Buffer.mk, HAdd.hAdd, ST.Ref.modify, ByteArray.copySlice, OfNat.ofNat, Bool.false, String.fromUTF8Unchecked, ByteArray.extract],[IO.FS.Stream]]
[Lean.Lsp.instToJsonDocumentSymbolAux,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.DocumentSymbolAux.name, List.nil, Lean.Json.opt, Lean.Lsp.DocumentSymbolAux.detail?, Lean.Lsp.DocumentSymbolAux.kind, Lean.Lsp.DocumentSymbolAux.range, Lean.Lsp.DocumentSymbolAux.selectionRange, Lean.Lsp.DocumentSymbolAux.children?],[Lean.ToJson, Lean.Lsp.DocumentSymbolAux]]
[Lean.Elab.Term.elabBadCDot,[Lean.throwError, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.TermElab]]
[Lean.Meta.CasesSubgoal.noConfusionType,[],[]]
[Lean.Name.mapPrefix,[Id.run, Option.none, Id, Lean.Name, Pure.pure, Bind.bind, PUnit.unit],[Lean.Name]]
[Lean.ConstantInfo.isUnsafe,[Bool, BEq.beq, Lean.DefinitionVal.safety, Lean.DefinitionSafety.unsafe, Lean.AxiomVal.isUnsafe, Bool.false, Lean.OpaqueVal.isUnsafe, Lean.InductiveVal.isUnsafe, Lean.ConstructorVal.isUnsafe, Lean.RecursorVal.isUnsafe],[Bool]]
[Lean.PrettyPrinter.Formatter.scientificLit.formatter,[Lean.Parser.Term.scientific.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.Quotation.MatchResult.noConfusionType,[],[]]
[instToStringSum,[ToString.mk, String, HAppend.hAppend, addParenHeuristic, ToString.toString],[ToString, Sum]]
[Lean.Meta.Config.proofIrrelevance,[],[Bool]]
[Lean.Lsp.HoverParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.HoverParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.HoverParams.mk]]
[instMonoidWithZero,[MonoidWithZero.mk, Semiring.zero_mul, Semiring.mul_zero],[MonoidWithZero]]
[Lean.PrettyPrinter.Delaborator.whenNotPPOption,[Bind.bind, Lean.PrettyPrinter.Delaborator.getPPOption, ite, Eq, Bool.true, Alternative.failure],[Lean.PrettyPrinter.Delaborator.Delab]]
[UInt16.div,[UInt16.mk, HDiv.hDiv, UInt16.val],[UInt16]]
[Lean.Parser.Term.fromTerm.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Command.macroTailCommand.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.identEq.parenthesizer, Lean.Name.mkSimple, Lean.Parser.darrow.parenthesizer, Lean.Parser.Command.macroRhs.parenthesizer, Lean.PrettyPrinter.Parenthesizer.many1Unbox.parenthesizer, Lean.Parser.commandParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.instFileSourceLocation,[Lean.Lsp.FileSource.mk, Lean.Lsp.Location.uri],[Lean.Lsp.FileSource, Lean.Lsp.Location]]
[Lean.TraceElem.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.TraceElem.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.SimpLemmas.pre,[],[Lean.Meta.DiscrTree, Lean.Meta.SimpLemma]]
[Lean.Compiler.foldUIntSub,[Lean.Compiler.foldBinUInt, HAdd.hAdd, HSub.hSub, Lean.Compiler.NumScalarTypeInfo.size],[Option, Lean.Expr]]
[Lean.Parser.Term.strictImplicitRightBracket,[HOrElse.hOrElse, Lean.Parser.atomic, Lean.Parser.group, HAndThen.hAndThen, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Not.elim,[absurd],[]]
[Lean.Elab.Command.InductiveView.noConfusionType,[],[]]
[instInhabited,[Inhabited.mk, Pure.pure, arbitrary],[Inhabited]]
[Lean.NameMap,[Std.RBMap, Lean.Name, Lean.Name.quickCmp],[]]
[Lean.Elab.Command.mkNameFromParserSyntax.appendCatName,[Lean.Name.anonymous, Lean.Name.num, String, HAppend.hAppend],[String]]
[Lean.Parser.Tactic.case,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary],[Lean.ParserDescr]]
[DecidablePred,[Decidable],[]]
[List.cons_subset,[Eq.mpr, congr, congrArg, Iff, Eq.trans, propext, List.subset_def, forall_congr, implies_congr, List.mem_cons_iff, Eq.refl, Mem.mem, or_imp_distrib, forall_and_distrib, congrFun, And, forall_eq, Iff.rfl],[Iff, Subset.subset, List.cons, And, Mem.mem]]
[List.repeat_succ,[rfl],[Eq, List.repeat, HAdd.hAdd, OfNat.ofNat, List.cons]]
[Mathlib.Tactic.Lint.Linter.test,[],[Lean.Meta.MetaM, Option, Lean.MessageData]]
[instMonadLiftT,[MonadLiftT.mk, MonadLift.monadLift, MonadLiftT.monadLift],[MonadLiftT]]
[Lean.NamePart.cmp,[Lean.NamePart.str, Lean.NamePart.num, Ordering, Ord.compare, Ordering.lt, Ordering.gt],[Ordering]]
[ofBoolUsing_eq_true,[of_decide_eq_true],[]]
[seq_eq_bind,[Eq.mpr, Eq.refl, Eq, Seq.seq, Bind.bind, Functor.map, LawfulMonad.bind_map, rfl],[Eq, Seq.seq, Bind.bind, Functor.map]]
[Lean.Elab.Structural.EqnInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Structural.EqnInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Structural.EqnInfo.mk, And]]
[Lean.Widget.instFromJsonGetInteractiveDiagnosticsParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, Lean.Lsp.LineRange, Pure.pure, Lean.Widget.GetInteractiveDiagnosticsParams.mk],[Lean.FromJson, Lean.Widget.GetInteractiveDiagnosticsParams]]
[ST.Ref.modify,[liftM, ST.Prim.Ref.modify],[Unit]]
[Lean.IR.NormalizeIds.instMonadLiftMN,[MonadLift.mk, Pure.pure],[MonadLift, Lean.IR.NormalizeIds.M, Lean.IR.NormalizeIds.N]]
[Lean.Parser.Tactic.«tacticNext___=>_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[ptrAddrUnsafe,[OfNat.ofNat],[USize]]
[Lean.Lsp.instFromJsonStaticRegistrationOptions,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, String, Pure.pure, Lean.Lsp.StaticRegistrationOptions.mk],[Lean.FromJson, Lean.Lsp.StaticRegistrationOptions]]
[List.dropLast,[Unit.unit, List.cons, List, List.nil, PProd.fst],[List]]
[Lean.PrettyPrinter.Formatter.interpolatedStr.formatter,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.PrettyPrinter.Formatter.visitArgs, Array.forM, Unit.unit, Lean.PrettyPrinter.FormatterM, PUnit, Lean.Syntax.isLit?, Lean.interpolatedStrLitKind, SeqRight.seqRight, Lean.PrettyPrinter.Formatter.push, Std.Format.text, Lean.Syntax.MonadTraverser.goLeft, Array.reverse, Lean.Syntax.getArgs, OfNat.ofNat, Array.size],[Lean.PrettyPrinter.Formatter]]
[exists_eq_left',[of_eq_true, Eq.trans, congrFun, congrArg, Iff, Exists, funext, And, propext, eq_comm, exists_eq_left, iff_self],[Iff, Exists, And, Eq]]
[Lean.PrettyPrinter.Formatter.rawIdentNoAntiquot.formatter,[Bind.bind, Lean.PrettyPrinter.Formatter.checkKind, Lean.identKind, Lean.Syntax.MonadTraverser.getCur, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.PrettyPrinter.FormatterM, Unit, Lean.PrettyPrinter.Formatter.pushToken, Lean.Name.toString, Bool.true, Lean.Syntax.MonadTraverser.goLeft, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.PrettyPrinter.Formatter]]
[Std.AssocList.contains,[Unit.unit, Bool, Bool.false, or, BEq.beq, PProd.fst],[Bool]]
[Nat.pos_iff_ne_zero,[Iff.intro, absurd, of_decide_eq_false, Eq.refl, Decidable.decide, LT.lt, OfNat.ofNat, Nat.zero, Eq.symm, Nat.succ_ne_zero, Nat.pos_of_ne_zero],[Iff, LT.lt, OfNat.ofNat, Ne]]
[instDecidableAnd,[Decidable, And, Decidable.isTrue, And.intro, Decidable.isFalse, instDecidableAnd.proof_1, instDecidableAnd.proof_2],[Decidable, And]]
[Lean.Meta.Closure.pushLocalDecl,[Bind.bind, Lean.Meta.Closure.collectExpr, modify, Lean.Meta.Closure.State.mk, Lean.Meta.Closure.State.visitedLevel, Lean.Meta.Closure.State.visitedExpr, Lean.Meta.Closure.State.levelParams, Lean.Meta.Closure.State.nextLevelIdx, Lean.Meta.Closure.State.levelArgs, Array.push, Lean.Meta.Closure.State.newLocalDecls, Lean.LocalDecl.cdecl, arbitrary, Lean.Meta.Closure.State.newLocalDeclsForMVars, Lean.Meta.Closure.State.newLetDecls, Lean.Meta.Closure.State.nextExprIdx, Lean.Meta.Closure.State.exprMVarArgs, Lean.Meta.Closure.State.exprFVarArgs, Lean.Meta.Closure.State.toProcess],[Lean.Meta.Closure.ClosureM, Unit]]
[termS!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Json.Parser.hexChar,[Bind.bind, Lean.Parsec.anyChar, ite, And, LE.le, Char.ofNat, Pure.pure, HSub.hSub, UInt32.toNat, Char.val, Lean.Parsec.fail],[Lean.Parsec, Nat]]
[exists_imp_exists',[Exists.elim, Exists.intro],[Exists]]
[Lean.Expr.updateApp!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateApp, Lean.Expr.app, Lean.Expr.updateApp!.proof_1, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[Lean.Parser.Term.nomatch,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Monoid.noConfusionType,[],[]]
[Lean.Lsp.instToJsonDocumentHighlight,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.DocumentHighlight.range, List.nil, Lean.Json.opt, Lean.Lsp.DocumentHighlight.kind?],[Lean.ToJson, Lean.Lsp.DocumentHighlight]]
[Lean.Parser.Module.prelude,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[instReprChar,[Repr.mk, Std.Format.text, Char.quote],[Repr, Char]]
[Lean.Server.WithRpcRef.encodeUnsafe,[Lean.Server.MonadRpcSession.rpcStoreRef],[Lean.Lsp.RpcRef]]
[Lean.Parser.Term.doDbgTrace.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.interpolatedStr.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Monoid.mul_one,[],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.LocalContext.fvarIdToDecl,[],[Std.PersistentHashMap, Lean.FVarId, Lean.LocalDecl]]
[UInt32.sub_def,[rfl],[Eq, HSub.hSub, UInt32.mk, UInt32.val]]
[Lean.Meta.Simp.getConfig,[Bind.bind, readThe, Lean.Meta.Simp.Context, Pure.pure, Lean.Meta.Simp.Context.config],[Lean.Meta.Simp.M, Lean.Meta.Simp.Config]]
[Lean.Rat.inv,[ite, LT.lt, Lean.Rat.num, OfNat.ofNat, Neg.neg, Int.ofNat, Lean.Rat.den, Int.natAbs, Eq, BEq.beq, Bool.true],[Lean.Rat]]
[String.bsize,[String.utf8ByteSize],[Nat]]
[Lean.IR.EmitC.emitMainFnIfNeeded,[Bind.bind, Lean.IR.EmitC.hasMainFn, ite, Eq, Bool.true, Lean.IR.EmitC.emitMainFn, Pure.pure, PUnit.unit],[Lean.IR.EmitC.M, Unit]]
[Preorder.toLT,[],[LT]]
[Acc.brecOn,[Acc.below.intro],[]]
[Mathlib.Tactic.Lint.shouldBeLinted,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.ParametricAttribute.getParam, Mathlib.Tactic.Lint.nolintAttr, not, Array.contains, Option.getD, EmptyCollection.emptyCollection],[Bool]]
[DecidableRel,[Decidable],[]]
[Lean.Parser.ppIndent,[id],[Lean.Parser.Parser]]
[Nat.pred_zero,[rfl],[Eq, Nat.pred, OfNat.ofNat]]
[Lean.Meta.MatcherApp.discrs,[],[Array, Lean.Expr]]
[Lean.Meta.Match.Unify.isAltVar,[Bind.bind, MonadReader.read, Pure.pure, List.any, BEq.beq, Lean.LocalDecl.fvarId, Lean.Meta.Match.Unify.Context.altFVarDecls],[Lean.Meta.Match.Unify.M, Bool]]
[Nat.gcd_add_mul_self,[of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.gcd_rec, HAdd.hAdd, HMul.hMul, congrFun, Nat.gcd, Nat.add_mul_mod_self_right, eq_self, HMod.hMod],[Eq, Nat.gcd, HAdd.hAdd, HMul.hMul]]
[Lean.Parser.priorityParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Parenthesizer]]
[instOfNatUInt8,[OfNat.mk, UInt8.ofNat],[OfNat, UInt8]]
[Lean.IR.IndexSet,[Std.RBTree, Lean.IR.Index, Ord.compare],[]]
[Lean.Meta.Config.offsetCnstrs,[],[Bool]]
[Lean.Server.FileWorker.handleReferences.findReferences,[Id.run, Bind.bind, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield],[Array, Lean.Server.FileWorker.Reference]]
[instAppendSubarray,[Append.mk, Array.toSubarray, OfNat.ofNat, Array.size],[Append, Subarray]]
[Lean.instInhabitedOpaqueVal,[Inhabited.mk, Lean.OpaqueVal.mk, arbitrary],[Inhabited, Lean.OpaqueVal]]
[Std.HashMap.empty,[Std.mkHashMap, OfNat.ofNat],[Std.HashMap]]
[Lean.ImportState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ImportState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ImportState.mk, And]]
[Lean.PrettyPrinter.Delaborator.SubExpr.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PrettyPrinter.Delaborator.SubExpr.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Trie.Node.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.Trie.Node, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.Trie.Node, And]]
[Lean.Xml.Parser.NotationDecl,[SeqRight.seqRight, Lean.Parsec.skipString, Lean.Xml.Parser.S, Lean.Xml.Parser.Name, HOrElse.hOrElse, Lean.Xml.Parser.ExternalID, Lean.Xml.Parser.PublicID, optional, Lean.Parsec.skipChar, Char.ofNat],[Lean.Parsec, Unit]]
[Lean.Meta.instInhabitedSimpLemma,[Inhabited.mk, Lean.Meta.SimpLemma.mk, arbitrary],[Inhabited, Lean.Meta.SimpLemma]]
[List.Perm.Equivalence,[Equivalence.mk, List.Perm.refl, List.Perm.symm, List.Perm.trans],[Equivalence, List.Perm]]
[Lean.Meta.SynthInstance.TableEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SynthInstance.TableEntry.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SynthInstance.TableEntry.mk, And]]
[Lean.JsonRpc.instInhabitedRequest,[Inhabited.mk, Lean.JsonRpc.Request.mk, arbitrary],[Inhabited, Lean.JsonRpc.Request]]
[Nat.coprime_mul_iff_right,[Eq.mpr, Eq.refl, Iff, Nat.coprime, HMul.hMul, And, propext, Nat.coprime_comm, Nat.coprime_mul_iff_left, Iff.rfl],[Iff, Nat.coprime, HMul.hMul, And]]
[Std.HashMap.erase,[Std.HashMap, Subtype.mk, Std.HashMapImp.erase, Std.HashMapImp.WellFormed.eraseWff],[Std.HashMap]]
[List.mapTR,[List.mapTRAux, List.nil],[List]]
[USize.instRingUSize.proof_4,[congrArg, USize.mk, SubNegMonoid.gsmul_neg', USize.val],[Eq, USize.mk, Ring.gsmul, Int.negSucc, USize.val]]
[Not.imp_symm,[Not.decidable_imp_symm],[]]
[Lean.Meta.ElimInfo.noConfusionType,[],[]]
[Lean.Elab.Term.StructInst.DefaultFields.Context.structs,[],[Array, Lean.Elab.Term.StructInst.Struct]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.maybeAddBlockImplicit,[Bind.bind, MonadReader.read, ite, Eq, not, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.parentIsApp, Bool.true, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, liftM, Lean.Meta.inferType, and, Lean.Expr.isForall, BEq.beq, Lean.Expr.bindingInfo!, Lean.BinderInfo.implicit, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.annotateBool, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, PUnit.unit],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM, Unit]]
[EStateM.Backtrackable.restore,[],[]]
[List.erase_append_right,[Eq.mpr, Eq.refl, Eq, List.erase, HAppend.hAppend, List.erase_eq_erasep, List.erasep, List.erasep_append_right, Eq.mp, Not, Mem.mem, rfl],[Eq, List.erase, HAppend.hAppend]]
[Lean.Parser.atomicFn,[Lean.Parser.ParserState.mk, Option.none, Lean.Parser.ParserState, Option.some],[Lean.Parser.ParserFn]]
[List.filterAuxM,[List, Pure.pure, Bind.bind, PProd.fst, cond, List.cons],[List]]
[Array.sequenceMap,[Array.size, OfNat.ofNat, Array.empty, Array.sequenceMap.loop],[Array]]
[instToStringUnit,[ToString.mk],[ToString, Unit]]
[UInt64.add,[UInt64.mk, HAdd.hAdd, UInt64.val],[UInt64]]
[Lean.Lsp.TextDocumentIdentifier.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.TextDocumentIdentifier.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Parser.fn,[],[Lean.Parser.ParserFn]]
[Lean.Elab.Term.LValResolution.getOp.inj,[And.intro],[And, Eq]]
[Lean.Meta.assert,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarTag, Lean.Meta.getMVarType, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.assignExprMVar, Lean.mkApp, Pure.pure, Lean.Expr.mvarId!],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.Server.RequestError.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.RequestError.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.RequestError.mk, And]]
[Std.PersistentHashMap.findEntry?,[Option, Prod, Std.PersistentHashMap.findEntryAux, UInt64.toUSize, Hashable.hash],[Option, Prod]]
[Prod.swap,[Prod.mk, Prod.snd, Prod.fst],[Prod]]
[Lean.Json.ibelow,[True, And],[]]
[Lean.Parser.Term.inaccessible.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[eqRec_heq,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, HEq],[HEq]]
[true_iff,[propext, Iff.intro, Iff.mp, trivial],[Eq, Iff, True]]
[Lean.instInhabitedRat,[Inhabited.mk, arbitrary],[Inhabited, Lean.Rat]]
[Lean.Parser.ParserInfo.collectTokens,[],[List, Lean.Parser.Token]]
[Lean.Meta.Match.MatcherResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.MatcherResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.MatcherResult.mk, And]]
[Lean.Elab.Term.ensureHasTypeAux,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Pure.pure, Bind.bind, liftM, Lean.Meta.isDefEq, ite, Eq, Bool.true, Lean.Meta.instantiateMVars, Lean.Elab.Term.isTypeApp?, Option.none, Lean.Meta.isMonad?, MonadExcept.tryCatch, Lean.Meta.mkAppOptM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Option.some, List.nil, Lean.Meta.expandCoe, Lean.MonadOptions.getOptions, Lean.Option.get, Lean.Elab.Term.autoLift, Lean.Meta.mkAppM, Lean.Elab.Term.synthesizeInst, Lean.Meta.getDecLevel, Lean.Meta.inferType, DoResultPR.return, PUnit.unit, DoResultPR, PUnit, Lean.Meta.getLevel, Lean.mkAppN, Lean.mkConst, DoResultPR.pure],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Lean.Meta.SimpLemma.name?,[],[Option, Lean.Name]]
[Lean.Elab.Term.Do.JPDecl.name,[],[Lean.Name]]
[Lean.Meta.isFinPatLit,[and, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.Expr.isNatLit, Lean.Expr.appArg!],[Bool]]
[Lean.Parser.TokenCacheEntry.token,[],[Lean.Syntax]]
[Lean.Meta.CheckAssignment.State.cache,[],[Lean.ExprStructMap, Lean.Expr]]
[Lean.Server.Watchdog.ServerEvent.workerEvent.inj,[And.intro],[And, Eq]]
[ShiftLeft.shiftLeft,[],[]]
[Lean.Widget.InteractiveDiagnostic.toDiagnostic.prettyTt,[Lean.Widget.TaggedText.stripTags],[String]]
[List.get!,[Nat.zero, List.nil, Nat.succ, PProd.fst, panicWithPosWithDecl, OfNat.ofNat],[]]
[Fin.noConfusionType,[],[]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withBindingDomain,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.PrettyPrinter.Delaborator.SubExpr.descend, Lean.Expr.bindingDomain!, OfNat.ofNat],[]]
[Lean.instInhabitedMetavarDecl,[Inhabited.mk, Lean.MetavarDecl.mk, arbitrary],[Inhabited, Lean.MetavarDecl]]
[Lean.Parser.Tactic.tacticSeqBracketed.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.Parser.tacticParser.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.ppDedent.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Std.RBMap.erase,[Std.RBMap, Subtype.mk, Std.RBNode.erase, Std.RBMap.erase.proof_1],[Std.RBMap]]
[Decidable.imp_or_distrib',[Decidable.em, of_eq_true, Eq.trans, congr, congrArg, Iff, implies_congr, Eq.refl, congrFun, Or, eq_true, true_or, implies_true, eq_true_of_decide, Bool.true, Eq.symm, Eq.mpr, eq_false, False, false_or, Iff.symm, or_iff_right_of_imp, False.elim],[Iff, Or]]
[Lean.Expr.ne?,[Lean.Expr.app3?, Lean.Name.mkStr, Lean.Name.anonymous],[Option, Prod, Lean.Expr]]
[Lean.Elab.Term.LetRecDeclView.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.letDecl.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.notFollowedBy.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.letIdDecl.formatter, Lean.Parser.Term.letPatDecl.formatter, Lean.Parser.Term.letEqnsDecl.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.RpcConnected.mk.inj,[],[Eq]]
[Lean.Compiler.CSimp.Entry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Compiler.CSimp.Entry.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Compiler.CSimp.Entry.mk, And]]
[Lean.KVMap.getBool,[Option.none, Option.some, Lean.DataValue.ofString, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Bool, Lean.KVMap.find],[Bool]]
[Lean.Expr.isConstructorApp?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.strVal, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.ConstructorVal, ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo, Lean.Environment.find?, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Expr.getAppFn, Unit.unit, HAdd.hAdd, Lean.ConstructorVal.numParams, Lean.ConstructorVal.numFields, Lean.Expr.getAppNumArgs],[Option, Lean.ConstructorVal]]
[Lean.Lsp.Ipc.stdin,[Bind.bind, MonadReader.read, Pure.pure, IO.FS.Stream.ofHandle, IO.Process.Child.stdin],[Lean.Lsp.Ipc.IpcM, IO.FS.Stream]]
[Array.split,[Array.foldl, Prod, Array, ite, Eq, Bool.true, Prod.mk, Array.push, List.toArray, List.nil, OfNat.ofNat, Array.size],[Prod, Array]]
[Lean.unbracketedExplicitBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.binderIdent, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[Tactic.instInhabitedCache,[inferInstanceAs, Inhabited, IO.Ref, Sum, Lean.Meta.MetaM, Task, Except, Lean.Exception],[Inhabited, Tactic.Cache]]
[Lean.Elab.Term.Do.Code.match.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Code.match, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.Code.match, And]]
[Lean.Parser.Level.num.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.numLit.formatter],[Lean.PrettyPrinter.Formatter]]
[IO.Error.timeExpired.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.timeExpired, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.timeExpired, And]]
[Lean.Server.Watchdog.forwardNotification,[Lean.Server.Watchdog.tryWriteMessage, Lean.Lsp.FileSource.fileSource, Lean.JsonRpc.Message.notification, Lean.JsonRpc.Notification.method, Lean.JsonRpc.Notification.mk, Except.toOption, Lean.Json.toStructured?, Lean.JsonRpc.Notification.param, Bool.true, Bool.false],[Lean.Server.Watchdog.ServerM, Unit]]
[Lean.Compiler.hasInlineIfReduceAttribute,[Lean.Compiler.InlineAttributeKind.inlineIfReduce],[Bool]]
[Lean.Elab.Term.Do.JPDecl.params,[],[Array, Prod, Lean.Name, Bool]]
[Lean.Elab.Command.elabMacroRulesAux,[Bind.bind, Array.mapM, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, not, Lean.Syntax.isQuot, Lean.Elab.throwUnsupportedSyntax, Pure.pure, PUnit.unit, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Array.append, List.nil, Unit.unit, Array, Lean.Syntax, Array.empty, Lean.Syntax.atom, Lean.mkIdent, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.mkIdentFrom, Prod.mk, Array.push],[Lean.Elab.Command.CommandElabM, Lean.Syntax]]
[Lean.Parser.Tactic.unfold,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Elab.Info.ofFieldInfo.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Info.ofFieldInfo, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Info.ofFieldInfo]]
[Lean.LocalContext.any,[Id.run, Lean.LocalContext.anyM],[Bool]]
[Lean.Meta.smartUnfoldingSuffix,[],[String]]
[Lean.Parser.Term.attr.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.attrParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.registerInternalExceptionId,[Bind.bind, ST.Ref.get, Lean.internalExceptionsRef, ite, Eq, Array.contains, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Pure.pure, PUnit.unit],[IO, Lean.InternalExceptionId]]
[Lean.Parser.addParserTokens,[List.foldlM, ite, Eq, BEq.beq, Bool.true, MonadExcept.throw, Unit.unit, Except, String, Lean.Parser.TokenTable, Lean.Parser.Trie.find?, Pure.pure, Lean.Parser.Trie.insert],[Except, String, Lean.Parser.TokenTable]]
[Lean.Server.RequestError.toLspResponseError,[Lean.JsonRpc.ResponseError.mk, Lean.Server.RequestError.code, Lean.Server.RequestError.message],[Lean.JsonRpc.ResponseError, Unit]]
[List.bind_map,[Unit.unit, Eq, List.map, List.bind, rfl, of_eq_true, Eq.trans, congr, congrArg, List.cons_bind, List.map_append, HAppend.hAppend, PProd.fst, eq_self],[Eq, List.map, List.bind]]
[Nat.lcm_ne_zero,[],[Ne, Nat.lcm, OfNat.ofNat]]
[Lean.Compiler.SpecArgKind.fixedHO.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Compiler.SpecArgKind.fixedHO, OfNat.ofNat]]
[Lean.Option.name,[],[Lean.Name]]
[le_of_not_lt,[LE.le, lt_trichotomy, le_of_lt, le_refl, absurd],[LE.le]]
[fixCore3,[bfix3, USize.size],[]]
[Lean.Elab.Term.Do.mkContinue,[Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.continue],[Lean.Elab.Term.Do.CodeBlock]]
[Lean.Lsp.ServerInfo.noConfusionType,[],[]]
[max_eq_left,[Eq.symm, eq_max, le_refl],[Eq, max]]
[ofNat_add,[Eq, Numeric.ofNat, HAdd.hAdd, Eq.symm, add_zero, OfNat.ofNat, Trans.trans, Semiring.ofNat_succ, Nat.add, of_eq_true, Eq.trans, congr, congrArg, congrFun, Nat.add_eq, Nat.add_zero, PProd.fst, add_assoc, eq_self],[Eq, Numeric.ofNat, HAdd.hAdd]]
[Lean.Widget.traverse,[Bind.bind, Lean.Meta.instantiateMVars, Lean.MonadLCtx.getLCtx, List.drop, OfNat.ofNat, List.nil, Lean.Widget.traverse.tritsLE, Lean.Widget.traverse.go],[Lean.Meta.MetaM, Prod, Lean.LocalContext, Lean.Expr]]
[Lean.Parser.Command.noncomputableSection.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.ToHide.State.hiddenInaccessibleProp,[],[Lean.FVarIdSet]]
[Lean.Elab.Term.elabAppArgs,[Bind.bind, liftM, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Substring.dropRight,[Substring.mk, Substring, HAdd.hAdd, Substring.prevn, Substring.bsize],[Substring]]
[Lean.mkProjectionInfoEx,[Lean.ProjectionFunctionInfo.mk],[Lean.ProjectionFunctionInfo]]
[ne_of_gt,[absurd, lt_irrefl],[Ne]]
[lt_of_le_of_lt,[LT.lt, lt_of_le_not_le, le_trans],[LT.lt]]
[Lean.mkNoConfusionEnum.mkToCtorIdx,[Bind.bind, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.Meta.MetaM, Unit, Lean.Meta.mkArrow, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Meta.withLocalDeclD, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.mkLambdaFVars, List.toArray, List.cons, List.nil, Bool.false, Bool.true, Lean.mkAppN, Lean.mkApp2, Lean.mkConst, Lean.mkCasesOnName, Lean.levelOne, Lean.addAndCompile, Lean.Declaration.defnDecl, Lean.DefinitionVal.mk, Lean.ConstantVal.mk, Lean.ReducibilityHints.abbrev, Lean.DefinitionSafety.safe, panicWithPosWithDecl, OfNat.ofNat],[Lean.Meta.MetaM, Unit]]
[Lean.Parser.Tactic.introNoMatch,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Meta.SynthInstance.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SynthInstance.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.PPFns.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.SimpAll.Entry.proof,[],[Lean.Expr]]
[Lean.Widget.Lean.Widget.MsgToInteractive.instFromJsonRpcEncodingPacket,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.RpcRef, Nat, Pure.pure],[Lean.FromJson]]
[Lean.IR.UnreachableBranches.getFunctionSummary?,[Lean.SMap.find?, Lean.SimplePersistentEnvExtension.getState, Lean.IR.UnreachableBranches.functionSummariesExt],[Option, Lean.IR.UnreachableBranches.Value]]
[UInt16.instAddSemigroupUInt16.proof_1,[congrArg, UInt16.mk, AddSemigroup.add_assoc, UInt16.val],[Eq, UInt16.mk]]
[Lean.Elab.applyVisibility,[Lean.Elab.Visibility.regular, Unit.unit, Lean.Name, Bind.bind, Lean.MonadEnv.getEnv, Lean.Elab.checkNotAlreadyDeclared, Pure.pure, Lean.setEnv],[Lean.Name]]
[Nat.sub.right_comm,[Eq.mpr, Eq.refl, Eq, HSub.hSub, Nat.sub_sub, HAdd.hAdd, Nat.add_comm, rfl],[Eq, HSub.hSub]]
[Std.Format.isNil,[Unit.unit, Std.Format.line, Std.Format.text, Std.Format.nest, Std.Format.append, Std.Format.group, Std.Format.tag, Bool, Bool.true, Bool.false],[Bool]]
[Lean.PrettyPrinter.Formatter.instCoeArrowFormatterFormatterFormatterAliasValue,[Coe.mk, Lean.Parser.AliasValue.unary],[Coe, Lean.PrettyPrinter.Formatter, Lean.PrettyPrinter.Formatter.FormatterAliasValue]]
[Lean.Lsp.SymbolKind.function.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.function, OfNat.ofNat]]
[Lean.Export.exportName,[Bind.bind, MonadState.get, Unit.unit, Lean.ExportM, Nat, Std.HashMap.find?, Lean.Export.Alloc.map, Lean.Export.State.names, Pure.pure, OfNat.ofNat, Lean.Export.alloc, PProd.fst, liftM, IO.println, HAppend.hAppend, ToString.toString],[Lean.ExportM, Nat]]
[Lean.Parser.Command.variable.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.ppSpace.formatter, Lean.Parser.Term.bracketedBinder.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.SCC.Data.onStack,[],[Bool]]
[Lean.Elab.Term.elabType,[Bind.bind, liftM, Lean.Meta.mkFreshLevelMVar, Lean.Elab.Term.elabTerm, Option.some, Lean.mkSort, Bool.true, Lean.withRef, Lean.Elab.Term.ensureType],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Nat.lt_iff_le_not_le,[Iff.intro, And.intro, Nat.le_of_lt, Nat.not_le_of_gt, Nat.gt_of_not_le, And.right],[Iff, LT.lt, And, LE.le, Not]]
[Lean.JsonRpc.ResponseError.message,[],[String]]
[Lean.Parser.checkOutsideQuot,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.checkOutsideQuotFn],[Lean.Parser.Parser]]
[instReprUInt8,[Repr.mk, repr, UInt8.toNat],[Repr, UInt8]]
[Lean.Parser.Command.genInjectiveTheorems.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Except.ok.inj,[],[Eq]]
[Lean.Elab.Term.getLevelNames,[Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Term.State.levelNames],[Lean.Elab.Term.TermElabM, List, Lean.Name]]
[eq_false',[propext, Iff.intro, absurd, False.elim],[Eq, False]]
[Lean.MetavarContext.depth,[],[Nat]]
[Lean.JsonRpc.ResponseError.code,[],[Lean.JsonRpc.ErrorCode]]
[instAddCommGroup.proof_5,[AddCommSemigroup.add_comm],[Eq, HAdd.hAdd]]
[Lean.Parser.Syntax.numPrec.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.numLit.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[IO.AccessRight.noConfusionType,[],[]]
[Std.Format.text.inj,[],[Eq]]
[Lean.Widget.Lean.Widget.InfoPopup.instToJsonRpcEncodingPacket,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil],[Lean.ToJson]]
[eq_true,[propext, Iff.intro, trivial],[Eq, True]]
[Lean.Meta.ToHide.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.ToHide.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.RpcCallParams.toTextDocumentPositionParams,[],[Lean.Lsp.TextDocumentPositionParams]]
[Lean.Meta.GeneralizeIndicesSubgoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.GeneralizeIndicesSubgoal.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Macro.instMonadRefMacroM,[Lean.MonadRef.mk, Bind.bind, MonadReader.read, Pure.pure, Lean.Macro.Context.ref, MonadWithReader.withReader, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth],[Lean.MonadRef, Lean.MacroM]]
[Lean.JsonRpc.Request.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.JsonRpc.Request.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.MetavarContext.mvarCounter,[],[Nat]]
[Lean.Declaration.inductDecl.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Declaration.inductDecl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Declaration.inductDecl, And]]
[Lean.MessageData.ofExpr.injEq,[Eq.propIntro, Eq.refl, Lean.MessageData.ofExpr, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MessageData.ofExpr]]
[Substring.contains,[Substring.any, BEq.beq],[Bool]]
[System.instReprFilePath,[Repr.mk, Repr.addAppParen, HAppend.hAppend, Std.Format.text, repr, System.FilePath.toString],[Repr, System.FilePath]]
[Lean.Elab.Term.instToStringArg,[ToString.mk, String, ToString.toString],[ToString, Lean.Elab.Term.Arg]]
[Lean.IR.Borrow.getParamInfo,[Bind.bind, MonadState.get, Unit.unit, Lean.IR.Borrow.M, Array, Lean.IR.Param, Std.HashMap.find?, Lean.IR.Borrow.BorrowInfState.paramMap, Pure.pure, Lean.IR.Borrow.ParamMap.Key.jp, MonadReader.read, Lean.IR.findEnvDecl, Lean.IR.Borrow.BorrowInfCtx.env, Lean.IR.Decl.params, panicWithPosWithDecl, OfNat.ofNat],[Lean.IR.Borrow.M, Array, Lean.IR.Param]]
[Lean.Lsp.instToJsonDidOpenTextDocumentParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.DidOpenTextDocumentParams.textDocument, List.nil],[Lean.ToJson, Lean.Lsp.DidOpenTextDocumentParams]]
[Mathlib.Tactic.Lint.instDecidableEqLintVerbosity.proof_1,[],[Eq]]
[Lean.Parser.ppIndent.parenthesizer,[],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.KVMap.mk.inj,[],[Eq]]
[Lean.Elab.Term.SyntheticMVarDecl.stx,[],[Lean.Syntax]]
[ByteSlice.arr,[],[ByteArray]]
[Nat.pos_of_dvd_of_pos,[Nat.pos_of_ne_zero, Nat.lt_irrefl, OfNat.ofNat, Eq.mp, Eq.refl, LT.lt, Nat.eq_zero_of_zero_dvd, Dvd.dvd],[LT.lt, OfNat.ofNat]]
[Lean.Level.isIMax,[Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.param, Lean.Level.mvar, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Lsp.instFromJsonInitializationOptions,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, Nat, Pure.pure, Lean.Lsp.InitializationOptions.mk],[Lean.FromJson, Lean.Lsp.InitializationOptions]]
[Lean.IR.EmitC.emitIsShared,[Bind.bind, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn],[Lean.IR.EmitC.M, Unit]]
[instToStreamStringSubstring,[ToStream.mk, String.toSubstring],[ToStream, String, Substring]]
[Lean.PrettyPrinter.Formatter.instCoeFormatterFormatterAliasValue,[Coe.mk, Lean.Parser.AliasValue.const],[Coe, Lean.PrettyPrinter.Formatter, Lean.PrettyPrinter.Formatter.FormatterAliasValue]]
[proof_irrel,[proofIrrel],[Eq]]
[Lean.Parser.Token,[String],[]]
[Nat.div.inductionOn,[WellFounded.fix, WellFoundedRelation.wf, measure, id, dite, And, LT.lt, OfNat.ofNat, LE.le, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le],[]]
[Lean.Meta.Match.Extension.Entry.noConfusionType,[],[]]
[Lean.Elab.Tactic.mkTacticInfo,[Bind.bind, MonadReader.read, Lean.MonadMCtx.getMCtx, Lean.Elab.Tactic.getUnsolvedGoals, Pure.pure, Lean.Elab.Info.ofTacticInfo, Lean.Elab.TacticInfo.mk, Lean.Elab.ElabInfo.mk, Lean.Elab.Tactic.Context.elaborator],[Lean.Elab.Tactic.TacticM, Lean.Elab.Info]]
[List.elem,[Unit.unit, Bool, Bool.false, BEq.beq, Bool.true, PProd.fst],[Bool]]
[Mathlib.Tactic.Lint.NamedLinter.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Mathlib.Tactic.Lint.NamedLinter.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.EnvironmentHeader.mainModule,[],[Lean.Name]]
[WellFounded.fixFEq,[WellFounded.fixFEq.proof_1],[Eq, WellFounded.fixF, Acc.inv]]
[Lean.Parser.Term.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.PrettyPrinter.Parenthesizer.many1Unbox.parenthesizer, Lean.Parser.commandParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.EmitC.emitUProj,[Bind.bind, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn],[Lean.IR.EmitC.M, Unit]]
[Lean.Json.CompressWorkItem.objectField.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Json.CompressWorkItem.objectField, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Json.CompressWorkItem.objectField, And]]
[Lean.RecursorRule.ctor,[],[Lean.Name]]
[Lean.MVarIdMap,[Std.RBMap, Lean.MVarId, Lean.Name.quickCmp, Lean.MVarId.name],[]]
[Lean.Core.withIncRecDepth,[controlAt, Lean.Core.CoreM, Lean.withIncRecDepth],[]]
[Lean.PrettyPrinter.Delaborator.instMonadStateOfHoleIteratorDelabM,[MonadStateOf.mk, Functor.map, Lean.PrettyPrinter.Delaborator.State.holeIter, MonadState.get, modify, Lean.PrettyPrinter.Delaborator.State, Lean.PrettyPrinter.Delaborator.State.mk, MonadState.modifyGet, Prod, Prod.mk],[MonadStateOf, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator, Lean.PrettyPrinter.Delaborator.DelabM]]
[Array.anyM.loop,[dite, LT.lt, Unit.unit, Bool, Pure.pure, Bool.false, Bind.bind, Array.get, Fin.mk, Array.anyM.loop.proof_1, ite, Eq, Bool.true, PProd.fst, HAdd.hAdd, OfNat.ofNat],[Bool]]
[Lean.RecursorVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.RecursorVal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.RecursorVal.mk, And]]
[Lean.Elab.CompletionInfo.endSection.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.Do.Code.ibelow,[And, True],[]]
[Lean.TraceState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.TraceState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.TraceState.mk, And]]
[IO.FS.instLTSystemTime,[ltOfOrd],[LT, IO.FS.SystemTime]]
[IO.instInhabitedError,[Inhabited.mk, IO.Error.alreadyExists, arbitrary],[Inhabited, IO.Error]]
[Nat.instShiftLeftNat,[ShiftLeft.mk, Nat.shiftLeft],[ShiftLeft, Nat]]
[Lean.Elab.Command.ElabStructResult.decl,[],[Lean.Declaration]]
[Lean.PrettyPrinter.Parenthesizer.checkOutsideQuot.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.PatternElabException.patternIdx,[],[Nat]]
[Lean.Elab.Tactic.Conv.evalNestedTacticCore,[Bind.bind, Lean.Elab.Tactic.evalTactic, Lean.Elab.Tactic.Conv.remarkAsConvGoal],[Lean.Elab.Tactic.Tactic]]
[Function.right_inverse.comp,[Function.left_inverse.comp],[Function.right_inverse, Function.comp]]
[Lean.Parser.Command.terminationHint.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.terminationHintMany.formatter, Lean.Parser.Command.terminationHint1.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.mkRecOnName,[Lean.Name.mkStr, Lean.recOnSuffix],[Lean.Name]]
[Lean.Elab.WF.instInhabitedTerminationHintValue,[Inhabited.mk, Lean.Elab.WF.TerminationHintValue.mk, arbitrary],[Inhabited, Lean.Elab.WF.TerminationHintValue]]
[Lean.Elab.Command.StructFieldKind.newField.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Command.StructFieldKind.newField, OfNat.ofNat]]
[Lean.Meta.MVarRenaming.insert,[Lean.Meta.MVarRenaming.mk, Std.RBMap.insert, Lean.Meta.MVarRenaming.map],[Lean.Meta.MVarRenaming]]
[Lean.Parser.Tactic.unfoldCoes,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Lsp.VersionedTextDocumentIdentifier.noConfusionType,[],[]]
[Std.HashSetImp.mkIdx,[Subtype.mk, HMod.hMod, USize.modn_lt],[Subtype, LT.lt, USize.toNat]]
[Lean.MetavarContext.lAssignment,[],[Std.PersistentHashMap, Lean.MVarId, Lean.Level]]
[List.any,[List.foldr, or, Bool.false],[Bool]]
[Lean.Xml.Element.noConfusionType,[],[]]
[Lean.Parser.andthenFn,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true],[Lean.Parser.ParserFn]]
[Std.MonadShareCommon.noConfusionType,[],[]]
[Std.Format.defWidth,[OfNat.ofNat],[Nat]]
[Lean.Parser.Tactic.inferAutoParam,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[List.ball_cons,[Iff.intro, And.intro, List.mem_cons_self, List.mem_cons_of_mem, Or.elim, Eq.mpr, Eq.refl],[Iff, And]]
[List.subset_of_cons_subset,[List.mem_cons_of_mem],[Subset.subset]]
[Lean.IR.EmitC.emitDel,[Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn],[Lean.IR.EmitC.M, Unit]]
[Lean.Expr.updateProj,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr, Lean.mkProj],[Lean.Expr]]
[UInt32.instAddSemigroupUInt32.proof_1,[congrArg, UInt32.mk, AddSemigroup.add_assoc, UInt32.val],[Eq, UInt32.mk]]
[Lean.registerSimplePersistentEnvExtension,[Lean.registerPersistentEnvExtension, Lean.PersistentEnvExtensionDescr.mk, Lean.SimplePersistentEnvExtensionDescr.name, Pure.pure, Prod.mk, List.nil, Lean.SimplePersistentEnvExtensionDescr.addImportedFn, List.toArray, Prod, List, List.cons, Lean.SimplePersistentEnvExtensionDescr.addEntryFn, Lean.SimplePersistentEnvExtensionDescr.toArrayFn, List.reverse, Prod.fst, HAppend.hAppend, Std.ToFormat.format, List.length],[IO, Lean.SimplePersistentEnvExtension]]
[Mathlib.Tactic.Lint.LintVerbosity.medium.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Mathlib.Tactic.Lint.LintVerbosity.medium, OfNat.ofNat]]
[Lean.Parser.FirstTokens.optTokens.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.FirstTokens.optTokens, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.FirstTokens.optTokens]]
[Lean.Parser.ParserExtension.State.noConfusionType,[],[]]
[Lean.Parser.Command.openScoped.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[ite_congr,[Decidable.em, Eq.mpr, Eq.refl, Eq, ite, if_pos, Eq.symm, if_neg],[Eq, ite]]
[Lean.Elab.Command.elabSynth,[Lean.withoutModifyingEnv, Lean.Elab.Command.runTermElabM, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.Elab.Term.elabTerm, Option.none, Bool.true, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Bool.false, liftM, Lean.Meta.instantiateMVars, Lean.Meta.synthInstance, Lean.Elab.logInfo, Lean.MessageData.ofExpr, Pure.pure, Unit.unit],[Lean.Elab.Command.CommandElab]]
[prod_map,[rfl, Eq.symm, Eq.refl],[Eq, Prod.map, Prod.mk, Prod.fst, Prod.snd]]
[Lean.Unhygienic.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Unhygienic.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.UnreachableBranches.Value.ctor.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.LetIdDeclView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LetIdDeclView.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.LetIdDeclView.mk, And]]
[Nat.le_of_succ_le,[Nat.le_trans, Nat.le_succ],[LE.le]]
[Lean.Expr.FoldConstsImpl.foldUnsafe,[StateT.run', Lean.Expr.FoldConstsImpl.fold, Lean.Expr.FoldConstsImpl.cacheSize, Lean.Expr.FoldConstsImpl.initCache],[]]
[Lean.Parser.ParserContext.toParserModuleContext,[],[Lean.Parser.ParserModuleContext]]
[List.decidablePairwise.proof_2,[],[False]]
[Lean.Elab.withSaveInfoContext,[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, ite, Eq, Lean.Elab.InfoState.enabled, Bool.true, Lean.Elab.getResetInfoTrees, Functor.map, Prod.fst, MonadFinally.tryFinally', Std.PersistentArray.mapM, Lean.MonadEnv.getEnv, Lean.MonadFileMap.getFileMap, Lean.MonadMCtx.getMCtx, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, Lean.MonadOptions.getOptions, Pure.pure, Lean.Elab.InfoTree.context, Lean.Elab.ContextInfo.mk, Lean.Elab.InfoState.trees, Lean.Elab.MonadInfoTree.modifyInfoState, Lean.Elab.InfoState.mk, Lean.Elab.InfoState.assignment, HAppend.hAppend],[]]
[Array.foldlM,[dite, LE.le, Array.size, Array.foldlM.proof_1],[]]
[Lean.MetavarContext.eAssignment,[],[Std.PersistentHashMap, Lean.MVarId, Lean.Expr]]
[«term_×'_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.bracketedExplicitBinders, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Meta.Match.Pattern.val.inj,[],[Eq]]
[Lean.IR.Borrow.BorrowInfState.modified,[],[Bool]]
[Lean.withRef,[Bind.bind, Lean.MonadRef.getRef, Lean.MonadRef.withRef],[]]
[Lean.Parser.Tactic.Conv.guardTarget,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.IR.push,[Array.push],[Array, Lean.IR.FnBody]]
[Lean.Lsp.VersionedTextDocumentIdentifier.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.VersionedTextDocumentIdentifier.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.VersionedTextDocumentIdentifier.mk, And]]
[Lean.PrettyPrinter.Delaborator.isNonConstFun,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Bool, PProd.fst, PProd.snd, Pure.pure, Lean.Expr.hasLooseBVars],[Lean.Meta.MetaM, Bool]]
[Lean.Meta.Simp.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Simp.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Simp.State.mk, And]]
[Nat.add_sub_cancel',[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HSub.hSub, Nat.add_comm, Nat.sub_add_cancel, rfl],[Eq, HAdd.hAdd, HSub.hSub]]
[Lean.Elab.Term.ElabAppArgs.M,[StateRefT', IO.RealWorld, Lean.Elab.Term.ElabAppArgs.State, Lean.Elab.Term.TermElabM],[]]
[Lean.Meta.withPPInaccessibleNamesImp,[withTheReader, Lean.Core.Context, Lean.Core.Context.mk, Lean.Option.setIfNotSet, Lean.Core.Context.options, Lean.Meta.pp.inaccessibleNames, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats],[Lean.Meta.MetaM]]
[Lean.Elab.Command.mkDefViewOfDef,[Lean.Elab.DefView, Lean.Elab.DefView.mk, Lean.Elab.DefKind.def, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Elab.DefView]]
[Lean.Parser.nonReservedSymbol.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.tokenWithAntiquot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.nonReservedSymbolNoAntiquot.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.DeclInfo.sorryDep?,[],[Option, Lean.Name]]
[Lean.Meta.Simp.Step.noConfusionType,[],[]]
[EIO.asTask,[BaseIO.asTask, EIO.toBaseIO],[BaseIO, Task, Except]]
[Nat.le_of_lt,[Nat.le_of_succ_le],[LE.le]]
[Lean.Parser.Tactic.tacticShow_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.getExternNameFor,[OptionM.run, Bind.bind, Lean.getExternAttrData, Lean.getExternEntryFor, Lean.ExternEntry.adhoc, Lean.ExternEntry.inline, OptionM, String, Pure.pure, Alternative.failure],[Option, String]]
[Lean.Lsp.WorkspaceFolder.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.WorkspaceFolder.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.MonadNameGenerator.setNGen,[],[Unit]]
[Lean.KVMap.Value.toDataValue,[],[Lean.DataValue]]
[Lean.JsonRpc.RequestID.num.injEq,[Eq.propIntro, Eq.refl, Lean.JsonRpc.RequestID.num, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.JsonRpc.RequestID.num]]
[UInt8.instSemigroupUInt8,[Semigroup.mk, UInt8.instSemigroupUInt8.proof_1],[Semigroup, UInt8]]
[Fin.sub_def,[Eq, HSub.hSub, Fin.mk, HMod.hMod, HAdd.hAdd, Fin.val, Nat.mod_lt, Fin.size_positive, rfl],[Eq, HSub.hSub, Fin.mk, HMod.hMod, HAdd.hAdd, Fin.val, Nat.mod_lt, Fin.size_positive]]
[Lean.IR.Borrow.ApplyParamMap.visitDecls,[Array.map, Lean.IR.Decl.extern, Lean.IR.Decl, Unit.unit, Std.HashMap.find?, Lean.IR.Borrow.ParamMap.Key.decl, Lean.IR.Decl.fdecl, panicWithPosWithDecl, OfNat.ofNat],[Array, Lean.IR.Decl]]
[Nat.div_mul_cancel,[Eq.mpr, Eq.refl, Eq, HMul.hMul, HDiv.hDiv, Nat.mul_comm, Nat.mul_div_cancel', rfl],[Eq, HMul.hMul, HDiv.hDiv]]
[lt_or_eq_of_le,[Decidable.lt_or_eq_of_le],[Or, LT.lt, Eq]]
[Lean.instFromJsonUSize,[Lean.FromJson.mk, Bind.bind, Lean.bignumFromJson?, ite, GE.ge, USize.size, MonadExcept.throw, Pure.pure, PUnit.unit],[Lean.FromJson, USize]]
[Lean.KernelException.unknownConstant.inj,[And.intro],[And, Eq]]
[Lean.IR.CtorLayout.numUSize,[],[Nat]]
[Nat.gcd_le_left,[Nat.le_of_dvd, Nat.gcd_dvd_left],[LE.le, Nat.gcd]]
[Lean.Parser.Command.reduce.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Level.Data,[UInt64],[]]
[Lean.Parser.binNumberFn,[Lean.Parser.mkNodeToken, Lean.numLitKind],[Lean.Parser.ParserFn]]
[implies_of_if_pos,[],[]]
[Lean.Syntax.modifyArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.node],[Lean.Syntax]]
[decide_eq_true_iff,[Iff.intro, of_decide_eq_true, decide_eq_true],[Iff, Eq, Decidable.decide, Bool.true]]
[EStateM.Result.error.injEq,[Eq.propIntro, And.intro, Eq.refl, EStateM.Result.error, Eq.symm, eq_of_heq, HEq.refl],[Eq, EStateM.Result.error, And]]
[prioLow,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[String.get,[Char, arbitrary, ite, Eq, PProd.fst, HAdd.hAdd, String.csize, OfNat.ofNat],[Char]]
[Lean.Elab.Tactic.deltaTarget,[Bind.bind, Lean.Elab.Tactic.getMainGoal, Lean.Elab.Tactic.getMainTarget, liftM, Lean.Meta.deltaExpand, BEq.beq, ite, Eq, Bool.true, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Syntax.missing, Pure.pure, PUnit.unit],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.NamingContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.NamingContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.NamingContext.mk, And]]
[Int.subNatNat_of_sub_eq_zero,[],[Eq, Int.subNatNat, Int.ofNat, HSub.hSub]]
[List.forIn,[List.forIn.loop],[]]
[iff_of_false,[Iff.intro, Not.elim],[Iff]]
[Lean.Meta.instInhabitedUnificationHintEntry,[Inhabited.mk, Lean.Meta.UnificationHintEntry.mk, arbitrary],[Inhabited, Lean.Meta.UnificationHintEntry]]
[Lean.Parser.Tactic.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.tacticParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.expandTermReturn,[Lean.withRef, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.Macro]]
[Nat.min_succ_succ,[],[Eq, min, Nat.succ]]
[List.anyM,[Unit.unit, Bool, Pure.pure, Bool.false, Bind.bind, Bool.true, PProd.fst],[Bool]]
[Lean.NameMap.contains,[Std.RBMap.contains],[Bool]]
[Lean.Lsp.instFromJsonTextDocumentSyncOptions,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Bool, Lean.Lsp.TextDocumentSyncKind, Option, Lean.Lsp.SaveOptions, Pure.pure, Lean.Lsp.TextDocumentSyncOptions.mk],[Lean.FromJson, Lean.Lsp.TextDocumentSyncOptions]]
[Lean.Meta.CongrLemma.mk.inj,[And.intro],[And, Eq]]
[IO.AsyncList.instInhabitedAsyncList,[Inhabited.mk, IO.AsyncList.nil],[Inhabited, IO.AsyncList]]
[UInt8.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, UInt8.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.doLet.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.letDecl.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Server.RpcEncoding.DerivingParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.RpcEncoding.DerivingParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Compiler.SpecArgKind.fixedInst.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Compiler.SpecArgKind.fixedInst, OfNat.ofNat]]
[EStateM.seqRight,[EStateM.Result, Unit.unit, EStateM.Result.error],[EStateM]]
[Coe.noConfusionType,[],[]]
[Lean.Parser.Tactic.mono.side,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.IR.NormalizeIds.normDecl,[Lean.IR.Decl.extern, Lean.IR.NormalizeIds.N, Lean.IR.Decl, Lean.IR.NormalizeIds.withParams, Bind.bind, Lean.IR.NormalizeIds.normFnBody, Pure.pure, Lean.IR.Decl.updateBody!],[Lean.IR.NormalizeIds.N, Lean.IR.Decl]]
[Lean.Widget.InfoPopup.doc,[],[Option, String]]
[Lean.LOption.undef.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.LOption.undef, OfNat.ofNat]]
[String.Iterator.next,[String.Iterator, String.Iterator.mk, String.next],[String.Iterator]]
[Lean.Core.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Core.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.AltVarNames.explicit,[],[Bool]]
[Lean.Lsp.PlainGoalParams.mk.inj,[],[Eq]]
[InvImage.wf,[InvImage.wf.proof_1],[WellFounded, InvImage]]
[Lean.Parser.Command.optNamedName.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.Parser.Command.namedName.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Std.ShareCommon.Object.ptrHash,[USize.toUInt64, ptrAddrUnsafe],[UInt64]]
[Lean.InternalExceptionId.getName,[Bind.bind, ST.Ref.get, Lean.internalExceptionsRef, dite, LT.lt, Array.size, Pure.pure, Array.get, Fin.mk, MonadExcept.throw, IO.userError],[IO, Lean.Name]]
[List.getLastD.proof_1,[],[List.noConfusionType, False, List.cons, List.nil]]
[Lean.instBEqData_1,[BEq.mk, BEq.beq],[BEq, Lean.Expr.Data]]
[IO.FS.instBEqSystemTime,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, IO.FS.SystemTime]]
[Lean.NameGenerator.idx,[],[Nat]]
[EStateM.fromStateM,[EStateM.Result, StateT.run, EStateM.Result.ok],[EStateM]]
[Char.utf8Size.proof_2,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[Lean.Lsp.ProgressParams.token,[],[String]]
[Lean.Json.null.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Json.null, OfNat.ofNat]]
[Lean.ScopedEnvExtension.addImportedFn,[Bind.bind, liftM, Lean.ScopedEnvExtension.Descr.mkInitial, ForIn.forIn, MProd.mk, Lean.ImportM, ForInStep, MProd, Lean.ScopedEnvExtension.ScopedEntries, Lean.ScopedEnvExtension.Descr.ofOLeanEntry, Pure.pure, PUnit.unit, ForInStep.yield, Lean.ScopedEnvExtension.StateStack, Lean.ScopedEnvExtension.StateStack.mk, List.cons, Lean.ScopedEnvExtension.State.mk, List.nil],[Lean.ImportM, Lean.ScopedEnvExtension.StateStack]]
[Lean.Elab.Command.StructView.isClass,[],[Bool]]
[Lean.PrettyPrinter.Parenthesizer.term.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.nullKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.throwBacktrack, Lean.PrettyPrinter.Parenthesizer.maybeParenthesize, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Unhygienic.run, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.PrettyPrinter.Parenthesizer.parenthesizeCategoryCore],[Lean.PrettyPrinter.CategoryParenthesizer]]
[Lean.Macro.Context.mainModule,[],[Lean.Name]]
[Lean.Expr.Data.binderInfo,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Lean.BinderInfo.default, Lean.BinderInfo.implicit, Lean.BinderInfo.strictImplicit, Lean.BinderInfo.instImplicit, Lean.BinderInfo.auxDecl],[Lean.BinderInfo]]
[Lean.Parser.ParserExtension.State.tokens,[],[Lean.Parser.TokenTable]]
[Prod.swap_prod_mk,[rfl],[Eq, Prod.swap, Prod.mk]]
[Lean.MonadEnv.noConfusionType,[],[]]
[Lean.Elab.Term.StructInst.Field.noConfusionType,[],[]]
[Lean.IR.CtorLayout.mk.inj,[And.intro],[And, Eq]]
[Lean.IR.EmitC.emitReuse,[Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.emitAllocCtor, ite, Eq, Bool.true, Lean.IR.CtorInfo.cidx, Pure.pure, PUnit.unit],[Lean.IR.EmitC.M, Unit]]
[Lean.Parser.checkInsideQuot,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.checkInsideQuotFn],[Lean.Parser.Parser]]
[Lean.Parser.Command.mixfixKind.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.prefix.formatter, Lean.Parser.Command.infix.formatter, Lean.Parser.Command.infixl.formatter, Lean.Parser.Command.infixr.formatter, Lean.Parser.Command.postfix.formatter],[Lean.PrettyPrinter.Formatter]]
[List.length_dropLast,[Unit.unit, Eq, List.length, List.dropLast, HSub.hSub, OfNat.ofNat, rfl],[Eq, List.length, List.dropLast, HSub.hSub, OfNat.ofNat]]
[Lean.IR.FnBody.mdata.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.FnBody.mdata, HAdd.hAdd, OfNat.ofNat]]
[congr_arg2,[rfl],[Eq]]
[or_iff_left_iff_imp,[Iff.intro, Iff.mp, Or.inr, or_iff_left_of_imp],[Iff, Or]]
[Lean.Elab.Term.ExtractMonadResult.noConfusionType,[],[]]
[Lean.NamingContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.NamingContext.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Macro.hasDecl,[Bind.bind, Lean.Macro.getMethods, Lean.Macro.Methods.hasDecl],[Lean.MacroM, Bool]]
[Complement.complement,[],[]]
[Lean.AttributeImplCore.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.AttributeImplCore.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.AttributeImplCore.mk, And]]
[Lean.Syntax.ident.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Syntax.ident, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Syntax.ident, And]]
[Lean.Meta.SimpAll.Entry.noConfusionType,[],[]]
[Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer,[],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.WF.instInhabitedTerminationHint,[Inhabited.mk, Lean.Elab.WF.TerminationHint.none],[Inhabited, Lean.Elab.WF.TerminationHint]]
[Lean.SyntaxNode.getArgs,[Lean.SyntaxNode.withArgs],[Array, Lean.Syntax]]
[Lean.IR.instInhabitedArg,[Inhabited.mk, Lean.IR.Arg.var, arbitrary],[Inhabited, Lean.IR.Arg]]
[Lean.Parser.Tactic.«tactic·._»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Std.HashMapImp.erase.proof_1,[Subtype.property],[GT.gt, Array.size, Subtype.val, OfNat.ofNat]]
[Lean.Elab.Term.Do.Code.action.inj,[],[Eq]]
[Lean.Elab.ContextInfo.env,[],[Lean.Environment]]
[Lean.Elab.Tactic.instMonadTacticM,[Monad.mk],[Monad, Lean.Elab.Tactic.TacticM]]
[Lean.Widget.InfoWithCtx.ctx,[],[Lean.Elab.ContextInfo]]
[Lean.Parser.Tactic.Conv.arg,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.ScopedEnvExtension.Descr.ofOLeanEntry,[],[Lean.ImportM]]
[Lean.Expr.arrow?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Prod, Lean.Expr, ite, Eq, Lean.Expr.hasLooseBVars, Bool.true, Option.none, Option.some, Prod.mk],[Option, Prod, Lean.Expr]]
[Lean.Elab.MacroStackElem.before,[],[Lean.Syntax]]
[USize.instSemiringUSize.proof_4,[congrArg, USize.mk, AddMonoid.nsmul_succ', USize.val],[Eq, USize.mk, Semiring.nsmul, Nat.succ, USize.val]]
[Lean.Elab.Term.Do.DoIfView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.DoIfView.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.DoIfView.mk, And]]
[Lean.Elab.Term.Do.Code.return.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Code.return, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.Code.return, And]]
[Lean.InductiveVal.numIndices,[],[Nat]]
[Nat.exists_coprime',[Exists, And, LT.lt, OfNat.ofNat, Nat.coprime, Eq, HMul.hMul, Exists.intro, Nat.gcd, And.intro],[Exists, And, LT.lt, OfNat.ofNat, Nat.coprime, Eq, HMul.hMul]]
[Lean.Parser.Command.derivingClasses.parenthesizer,[Lean.Parser.sepBy1.parenthesizer, Lean.Parser.group.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.structInst.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[ByteArray.set,[ByteArray, ByteArray.mk, Array.set],[ByteArray]]
[Lean.Parser.Command.optDefDeriving,[Lean.Parser.optional, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.notSymbol, Lean.Parser.sepBy1, Lean.Parser.ident, Bool.false],[Lean.Parser.Parser]]
[Lean.Elab.Term.precheckMatch,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Unit.unit, Lean.Elab.Term.Quotation.PrecheckM, Unit, OptionM.run, Array.sequenceMap, Array.getSepElems, Lean.Syntax.getArgs, Option.some, Option.none, OptionM, Prod, Array, Lean.Syntax, Prod.mk, Bind.bind, Array.forM, Lean.Elab.Term.Quotation.precheck, Array.size, ForIn.forIn, MProd.mk, PUnit.unit, ForInStep, MProd, Option, PUnit, MonadExcept.tryCatch, liftM, Lean.Elab.Term.getPatternsVars, Pure.pure, DoResultPR.pure, DoResultPR, Lean.Elab.Term.PatternVar, DoResultPR.return, ForInStep.done, MProd.fst, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.Quotation.Precheck]]
[and_symm_right,[Iff.intro, And, Eq, And.intro, Eq.symm],[Iff, And, Eq]]
[Lean.mkDecIsFalse,[Lean.mkAppB, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.Expr]]
[Lean.Elab.Term.Do.Alt.rhs,[],[]]
[xor_true,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, funext, congr, Or, true_and, Not, And, eq_false_of_decide, Eq.refl, Bool.false, and_false, or_false, eq_self],[Eq, xor, True, Not]]
[IO.FS.SystemTime.noConfusionType,[],[]]
[Lean.Xml.instToStringAttributes,[ToString.mk, Std.RBMap.fold, HAppend.hAppend, ToString.toString],[ToString, Lean.Xml.Attributes]]
[String.utf16Length,[String.foldr, HAdd.hAdd, UInt32.toNat, Char.utf16Size, OfNat.ofNat],[Nat]]
[Lean.Parser.Term.letEqnsDecl,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.Term.letIdLhs, HOrElse.hOrElse, Lean.Parser.symbol, Lean.Parser.Term.matchAlts, Lean.Parser.termParser, OfNat.ofNat, Bool.false],[Lean.Parser.Parser]]
[le_antisymm,[PartialOrder.le_antisymm],[Eq]]
[Lean.Meta.Closure.State.levelArgs,[],[Array, Lean.Level]]
[Mathlib.Tactic.Conv.convLHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[imp_congr_right,[Iff.intro, Iff.mp, Iff.mpr],[Iff]]
[List.unzip,[Unit.unit, Prod, List, Prod.mk, List.nil, PProd.fst, List.cons],[Prod, List]]
[Lean.Lsp.DidCloseTextDocumentParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DidCloseTextDocumentParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.DidCloseTextDocumentParams.mk]]
[PartialOrder.toPreorder,[],[Preorder]]
[Lean.Parser.Tactic.obviously,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Meta.getFunInfoNArgs,[Bind.bind, MonadState.get, Lean.Meta.getTransparency, Unit.unit, Lean.Meta.MetaM, Lean.Meta.FunInfo, Std.PersistentHashMap.find?, Lean.Meta.Cache.funInfo, Lean.Meta.State.cache, Lean.Meta.InfoCacheKey.mk, Pure.pure, modify, Lean.Meta.State.mk, Lean.Meta.State.mctx, Lean.Meta.Cache.mk, Lean.Meta.Cache.inferType, Std.PersistentHashMap.insert, Lean.Meta.Cache.synthInstance, Lean.Meta.Cache.whnfDefault, Lean.Meta.Cache.whnfAll, Lean.Meta.Cache.defEqDefault, Lean.Meta.Cache.defEqAll, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed, Lean.Meta.inferType, Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.default, Lean.Meta.forallBoundedTelescope, ForIn.forIn, Lean.Meta.getFVarLocalDecl, PUnit.unit, ForInStep.yield, Lean.Meta.FunInfo.mk, Option.some],[Lean.Meta.MetaM, Lean.Meta.FunInfo]]
[Lean.Elab.Structural.EqnsExtState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Structural.EqnsExtState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Match.Example.arrayLit.inj,[],[Eq]]
[Lean.MessageData.ofExpr.inj,[],[Eq]]
[Lean.Syntax.decodeScientificLitVal?.decodeExp,[ite, Eq, BEq.beq, Char.ofNat, Bool.true, Lean.Syntax.decodeScientificLitVal?.decodeAfterExp, String.next, OfNat.ofNat, Bool.false],[Option, Prod, Nat, Bool]]
[List.Perm.subset,[List.nil_subset, List.nil, List.cons_subset_cons, Eq.mpr, Eq.refl, Mem.mem, List.cons, propext, List.mem_cons, Or.inr, Or.inl, List.subset.trans],[Subset.subset]]
[Lean.Parser.Term.sufficesDecl,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.optIdent, Lean.Parser.termParser, HOrElse.hOrElse, Lean.Parser.Term.fromTerm, Lean.Parser.Term.byTactic],[Lean.Parser.Parser]]
[Substring.foldr,[String.foldrAux],[]]
[Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parsec.unexpectedEndOfInput,[],[String]]
[Lean.Lsp.SemanticTokenType.names,[List.toArray, List.cons, List.nil],[Array, String]]
[Nat.zero_ne_one,[],[Ne, OfNat.ofNat]]
[Lean.EnvExtensionInterface.modifyState,[],[Lean.Environment]]
[Lean.instInhabitedInductiveType,[Inhabited.mk, Lean.InductiveType.mk, arbitrary],[Inhabited, Lean.InductiveType]]
[Lean.Parser.trailingNodeAux,[Lean.Parser.Parser.mk, Lean.Parser.nodeInfo, Lean.Parser.Parser.info, Lean.Parser.trailingNodeFn, Lean.Parser.Parser.fn],[Lean.Parser.TrailingParser]]
[Lean.ClassEntry.mk.inj,[And.intro],[And, Eq]]
[Lean.Expr.getAppNumArgsAux,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Nat, PProd.fst, HAdd.hAdd, OfNat.ofNat],[Nat]]
[Lean.Lsp.SemanticTokensRangeParams.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.replaceLocalDecl,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getLocalDecl, Lean.Meta.mkEqMP, Lean.mkFVar, StateRefT'.run, Lean.Meta.MetaM, Lean.Meta.AssertAfterResult, Lean.Meta.assertAfter, Lean.LocalDecl.fvarId, Lean.LocalDecl.userName, HOrElse.hOrElse, Lean.Meta.clear, Lean.Meta.AssertAfterResult.mvarId, Pure.pure, Lean.Meta.AssertAfterResult.mk, Lean.Meta.AssertAfterResult.fvarId, Lean.Meta.AssertAfterResult.subst, Lean.Meta.replaceLocalDecl.findMaxFVar],[Lean.Meta.MetaM, Lean.Meta.AssertAfterResult]]
[Lean.Expr.const.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.const, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Expr.const, And]]
[Lean.Parser.strLitNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.strLitFn],[Lean.Parser.Parser]]
[Lean.Lsp.StaticRegistrationOptions.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.StaticRegistrationOptions.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.StaticRegistrationOptions.mk]]
[or_congr_right,[or_congr, Iff.rfl],[Iff, Or]]
[Lean.FVarId.noConfusionType,[],[]]
[instInhabitedUSize.proof_1,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, OfNat.ofNat, HEq.refl, LT.lt, USize.size, usize_size_eq, of_decide_eq_true, Bool.true],[LT.lt, OfNat.ofNat, USize.size]]
[IO.Ref,[ST.Ref, IO.RealWorld],[]]
[Lean.instBEqLOption,[BEq.mk, Unit.unit, Lean.LOption.none, Lean.LOption.some, Lean.LOption.undef, Bool, Bool.true, and, BEq.beq, Bool.false],[BEq, Lean.LOption]]
[System.FilePath.join,[ite, Eq, System.FilePath.isAbsolute, Bool.true, System.FilePath.mk, HAppend.hAppend, System.FilePath.toString, Char.toString, System.FilePath.pathSeparator],[System.FilePath]]
[Lean.NameTrie.empty,[Lean.PrefixTree.empty],[Lean.NameTrie]]
[Lean.instFromJsonInt,[Lean.FromJson.mk, Lean.Json.getInt?],[Lean.FromJson, Int]]
[Lean.instToExprProd,[Lean.ToExpr.mk, Lean.Expr, Lean.mkApp4, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.levelZero, List.nil, Lean.ToExpr.toExpr, Lean.mkApp2],[Lean.ToExpr, Prod]]
[Lean.IR.CtorInfo.name,[],[Lean.Name]]
[Lean.Meta.Rewrite.Config.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Rewrite.Config.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.optKind,[Lean.Parser.optional, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.ident],[Lean.Parser.Parser]]
[Lean.Meta.SynthInstance.SubgoalsResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SynthInstance.SubgoalsResult.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.instInhabitedSubExpr,[Inhabited.mk, Lean.PrettyPrinter.Delaborator.SubExpr.mk, arbitrary],[Inhabited, Lean.PrettyPrinter.Delaborator.SubExpr]]
[Lean.Meta.AuxLemmas.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.AuxLemmas.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.AuxLemmas.mk, And]]
[false_iff_true,[iff_false_intro, Iff.mpr, trivial],[Iff, False, True]]
[Bind.bind,[],[]]
[Lean.Elab.Structural.EqnsExtState.map,[],[Std.PHashMap, Lean.Name, Array]]
[Lean.Server.FileWorker.initAndRunWorker,[Bind.bind, Lean.Server.maybeTee, Bool.false, Bool.true, IO.FS.Stream.readLspRequestAs, Lean.Lsp.InitializeParams, IO, UInt32, IO.FS.Stream.readLspNotificationAs, Lean.Lsp.DidOpenTextDocumentParams, Pure.pure, IO.FS.Stream.withPrefix, HAppend.hAppend, ToString.toString, Lean.Lsp.TextDocumentItem.uri, Lean.Lsp.DidOpenTextDocumentParams.textDocument, liftM, IO.setStderr, MonadExcept.tryCatch, Lean.Server.FileWorker.initializeWorker, StateRefT'.run, ReaderT.run, Lean.Server.FileWorker.mainLoop, OfNat.ofNat, IO.eprintln, Lean.Server.publishDiagnostics, List.toArray, List.cons, Lean.Lsp.DiagnosticWith.mk, Lean.Lsp.Range.mk, Lean.Lsp.Position.mk, Option.some, Lean.Lsp.DiagnosticSeverity.error, IO.Error.toString, List.nil],[IO, UInt32]]
[Std.instEmptyCollectionRBTree,[EmptyCollection.mk, Std.mkRBTree],[EmptyCollection, Std.RBTree]]
[Lean.Server.publishProgress,[IO.FS.Stream.writeLspNotification, Lean.JsonRpc.Notification.mk, Lean.Lsp.LeanFileProgressParams.mk, Lean.Lsp.VersionedTextDocumentIdentifier.mk, Lean.Server.DocumentMeta.uri, Option.some, Lean.Server.DocumentMeta.version],[IO, Unit]]
[Lean.Compiler.NumScalarTypeInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.JsonRpc.instInhabitedResponseError,[Inhabited.mk, Lean.JsonRpc.ResponseError.mk, arbitrary],[Inhabited, Lean.JsonRpc.ResponseError]]
[Lean.Compiler.NumScalarTypeInfo.toNatFn,[],[Lean.Name]]
[Lean.Parser.Tactic.Conv.convRight,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Lsp.DiagnosticCode.string.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DiagnosticCode.string, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.DiagnosticCode.string]]
[Lean.LocalInstances.erase,[Option.none, Lean.LocalInstances, Array.findIdx?, BEq.beq, Lean.Expr.fvarId!, Lean.LocalInstance.fvar, Array.eraseIdx],[Lean.LocalInstances]]
[Lean.Name.instBEqName,[BEq.mk, Lean.Name.beq],[BEq, Lean.Name]]
[Lean.Server.Snapshots.Snapshot.msgLog,[Lean.Elab.Command.State.messages, Lean.Server.Snapshots.Snapshot.cmdState],[Lean.MessageLog]]
[Lean.Parser.Command.example,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.declSig, Lean.Parser.Command.declVal],[Lean.Parser.Parser]]
[Eq.mpr_not,[Eq.symm],[Not]]
[List.eq_nil_of_subset_nil,[Eq, List.nil, rfl, False.elim, List.mem_cons_self],[Eq, List.nil]]
[Lean.JsonRpc.Request.method,[],[String]]
[Lean.Syntax.setInfo,[Unit.unit, Lean.Syntax, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax.node, Lean.Syntax.missing],[Lean.Syntax]]
[Lean.Parser.Term.arrow.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.unicodeSymbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Nat.gcd_gcd_self_right_left,[Nat.dvd_antisymm, Nat.gcd_dvd_right, Nat.gcd, Nat.dvd_gcd, Nat.gcd_dvd_left, Nat.dvd_refl],[Eq, Nat.gcd]]
[Lean.Parser.Tactic.Conv.convRepeat_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[List.reverseAux_reverseAux,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, List.cons, List.reverseAux, List.nil, eq_self],[Eq, List.reverseAux, List.nil]]
[Std.RBTree.erase,[Std.RBMap.erase],[Std.RBTree]]
[Lean.Widget.MsgEmbed.instRpcEncodingMsgEmbedRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Pure.pure, ExceptT, String, Lean.Widget.MsgEmbed, Lean.Server.RpcEncoding.rpcDecode, Lean.Widget.MsgEmbed.expr, Lean.Widget.MsgEmbed.goal, Lean.Widget.MsgEmbed.lazyTrace],[Lean.Server.RpcEncoding, Lean.Widget.MsgEmbed]]
[Lean.Parser.charLitFn,[ite, Eq, and, not, Lean.Parser.ParserState.hasError, Lean.Syntax.isOfKind, Array.back, Lean.Parser.ParserState.stxStack, Lean.charLitKind, Bool.true, Lean.Parser.ParserState.mkErrorAt, Option.some],[Lean.Parser.ParserFn]]
[Lean.Elab.Command.elabMacroRules,[Lean.Elab.Command.adaptExpander, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Option.some, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Lean.IR.Borrow.BorrowInfState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Borrow.BorrowInfState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Borrow.BorrowInfState.mk, And]]
[mul_right_cancel,[IsMulRightCancel.mul_right_cancel],[Eq]]
[Tactic.Ring.subst_into_pow,[Eq.mpr, Eq.refl, Eq, HPow.hPow, rfl],[Eq, HPow.hPow]]
[Lean.PrettyPrinter.format,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Std.ToFormat.format, Pure.pure, PUnit.unit],[Lean.Core.CoreM, Std.Format]]
[List.union_equiv_append,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, List.mem_union_iff, List.mem_append, iff_self, Or, Mem.mem],[List.equiv, List.union, HAppend.hAppend]]
[Lean.DeclarationRanges.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Tactic.showTerm,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Parser.Command.docComment,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.ppDedent, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.commentBody, Lean.Parser.ppLine],[Lean.Parser.Parser]]
[Mathlib.Tactic.Ext.«termExtIffType%__»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[and_self_right,[Iff.intro, And.intro, And.left, And.right],[Iff, And]]
[Subarray.all,[Id.run, Subarray.allM],[Bool]]
[Lean.Server.Watchdog.FileWorker.stdin,[IO.FS.Stream.ofHandle, IO.Process.Child.stdin, Lean.Server.Watchdog.FileWorker.proc],[IO.FS.Stream]]
[Lean.PrettyPrinter.Formatter.parseToken,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, MonadReader.read, Pure.pure, Lean.Parser.andthenFn, Lean.Parser.whitespace, Lean.Parser.tokenFn, List.nil, Lean.Parser.ParserContext.mk, Lean.Parser.InputContext.mk, Lean.FileMap.ofString, Lean.Parser.ParserModuleContext.mk, OfNat.ofNat, Lean.PrettyPrinter.Formatter.Context.table, Lean.Parser.mkParserState],[Lean.PrettyPrinter.FormatterM, Lean.Parser.ParserState]]
[Lean.Compiler.SpecInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Compiler.SpecInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[System.FilePath.isRelative,[not, System.FilePath.isAbsolute],[Bool]]
[Lean.mkAtom,[Lean.Syntax.atom, Lean.SourceInfo.none],[Lean.Syntax]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.isConditional,[],[Bool]]
[Quotient.ind,[Quot.ind],[]]
[Lean.Lsp.instToJsonDocumentHighlightParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.DocumentHighlightParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position],[Lean.ToJson, Lean.Lsp.DocumentHighlightParams]]
[«stx_<|>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.instToMessageDataMessageData,[Lean.ToMessageData.mk, id],[Lean.ToMessageData, Lean.MessageData]]
[Command.simpsRule.erase,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[unsafeEIO,[unsafeBaseIO, EIO.toBaseIO],[Except]]
[Lean.Parser.Tactic.extractGoal!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Expr.FindImpl.findM?,[Lean.Expr.FindImpl.findM?.visit],[OptionT, Lean.Expr.FindImpl.FindM, Lean.Expr]]
[Lean.Parser.Syntax.nonReserved,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.strLit],[Lean.Parser.Parser]]
[Std.PShareCommonM,[Std.PShareCommonT, Id],[]]
[IO.FS.instInhabitedStream,[Inhabited.mk, IO.FS.Stream.mk, arbitrary],[Inhabited, IO.FS.Stream]]
[Prod.anyI,[Nat.anyAux, Prod.snd, HSub.hSub, Prod.fst],[Bool]]
[Lean.Widget.TaggedText.noConfusionType,[],[]]
[String.all,[not, String.any],[Bool]]
[Lean.instAddErrorMessageContext,[Lean.AddErrorMessageContext.mk, Bind.bind, Lean.AddMessageContext.addMessageContext, Pure.pure, Prod.mk],[Lean.AddErrorMessageContext]]
[Lean.ParametricAttributeImpl.afterImport,[],[Lean.ImportM, Unit]]
[Lean.Meta.ToHide.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.ToHide.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.ToHide.Context.mk]]
[Lean.Parser.Term.optExprPrecedence.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.Match.State.mk.inj,[And.intro],[And, Eq]]
[Lean.instInhabitedOptionDecl,[Inhabited.mk, Lean.OptionDecl.mk, arbitrary],[Inhabited, Lean.OptionDecl]]
[Lean.Meta.ApplyNewGoals.noConfusionType,[noConfusionTypeEnum, Lean.Meta.ApplyNewGoals.toCtorIdx],[]]
[Int.negSucc_ofNat_inj_iff,[Iff.intro, Int.negSucc.inj, of_eq_true, Eq.trans, congrFun, congrArg, Eq, Int.negSucc, eq_self],[Iff, Eq, Int.negSucc]]
[Task.Priority.max,[OfNat.ofNat],[Task.Priority]]
[Lean.Parser.Tactic.rintro?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[decidable_of_bool.proof_1,[Iff.mp, rfl],[]]
[Lean.Meta.AbstractMVars.State.noConfusionType,[],[]]
[or_left_comm,[Eq.mpr, Eq.refl, Iff, Or, Eq.symm, propext, or_assoc, or_comm, Iff.rfl],[Iff, Or]]
[Lean.Parser.tacticParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Parser.Parser]]
[lt_or_le,[dite, LE.le, Or.inr, Or.inl, lt_of_not_ge],[Or, LT.lt, LE.le]]
[Lean.Parser.addParser,[Except, String, Lean.Parser.ParserCategories, Lean.Parser.addLeadingParser, Lean.Parser.addTrailingParser],[Except, String, Lean.Parser.ParserCategories]]
[Lean.Parser.Error.toString,[String.intercalate, HAppend.hAppend],[String]]
[Lean.Elab.Command.StructCtorView.declName,[],[Lean.Name]]
[HXor.noConfusionType,[],[]]
[Lean.Elab.Term.Context.autoBoundImplicit,[],[Bool]]
[Lean.Parser.Term.funImplicitBinder,[HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.lookahead, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.Term.binderIdent, HOrElse.hOrElse, Lean.Parser.Term.implicitBinder, Bool.false],[Lean.Parser.Parser]]
[instStreamList,[Stream.mk, Unit.unit, Option, Prod, List, Option.none, Option.some, Prod.mk],[Stream, List]]
[Nat.succ_sub_sub_succ,[Eq.mpr, Eq.refl, Eq, HSub.hSub, Nat.succ, Nat.sub_sub, HAdd.hAdd, Nat.add_succ, Nat.succ_sub_succ, rfl],[Eq, HSub.hSub, Nat.succ]]
[Lean.Elab.Deriving.mkLocalInstanceLetDecls,[Bind.bind, ForIn.forIn, Lean.Elab.Deriving.mkInductArgNames, Lean.Elab.Deriving.mkImplicitBinders, Array.ofSubarray, Lean.Elab.Deriving.mkInductiveApp, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkIdent, List.nil, Lean.Syntax.atom, liftM, Lean.Core.mkFreshUserName, Array.append, PUnit.unit, ForInStep.yield],[Lean.Elab.Term.TermElabM, Array, Lean.Syntax]]
[UInt16.shiftRight,[UInt16.mk, HShiftRight.hShiftRight, UInt16.val, UInt16.modn, OfNat.ofNat],[UInt16]]
[not_le,[Iff.symm, lt_iff_not_ge],[Iff, Not, LE.le, LT.lt]]
[Lean.Parser.Tactic.squeezeScope,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Parser.PrattParsingTables.noConfusionType,[],[]]
[Mathlib.ExtendedBinder.extBinder,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[Lean.IR.declToString,[Std.Format.pretty, Std.ToFormat.format, Std.Format.defWidth],[String]]
[Nat.left_distrib,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Nat.zero, HAdd.hAdd, Nat.zero_mul, OfNat.ofNat, rfl, congr, congrArg, Eq.trans, Nat.succ_mul, congrFun, Nat.add_assoc, Nat.add_left_comm],[Eq, HMul.hMul, HAdd.hAdd]]
[Lean.PrettyPrinter.Parenthesizer.many1Unbox.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.nullKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.manyNoAntiquot.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Tactic.Conv.convSeq,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.Parser.Tactic.Conv.convSeq1Indented, Lean.Parser.Tactic.Conv.convSeqBracketed],[Lean.ParserDescr]]
[not_not_em,[Or.inr, Or.inl],[Not, Or]]
[UInt32.instSemiringUInt32.proof_11,[Eq.mpr, congr, congrArg, Eq, Eq.trans, HMul.hMul, UInt32.add_def, UInt32.mul_def, UInt32.mk, HAdd.hAdd, UInt32.val, UInt32.eq_of_val_eq, Semiring.mul_add],[Eq, HMul.hMul, HAdd.hAdd]]
[Lean.Widget.InteractiveHypothesis.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Widget.InteractiveHypothesis.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Widget.InteractiveHypothesis.mk, And]]
[Mathlib.Tactic.Lint.sortResults,[Bind.bind, ForIn.forIn, Lean.Core.CoreM, ForInStep, Std.HashMap, Lean.Name, Nat, Lean.findDeclarationRanges?, Option.none, Pure.pure, PUnit.unit, ForInStep.yield, Array.qsort, Std.HashMap.toArray, Bool, Decidable.decide, LT.lt, Std.HashMap.findD, OfNat.ofNat, HSub.hSub, Array.size],[Lean.Core.CoreM, Array, Prod, Lean.Name]]
[Lean.Elab.Command.StructFieldView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.StructFieldView.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Command.StructFieldView.mk, And]]
[AddGroup.noConfusionType,[],[]]
[Lean.instMonadBacktrackExceptT,[Lean.MonadBacktrack.mk, ExceptT.lift, Lean.MonadBacktrack.saveState, Lean.MonadBacktrack.restoreState],[Lean.MonadBacktrack, ExceptT]]
[Lean.PrettyPrinter.Formatter.withForbidden.formatter,[],[Lean.PrettyPrinter.Formatter]]
[Lean.KVMap.setBool,[Lean.KVMap.insert, Lean.DataValue.ofBool],[Lean.KVMap]]
[Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1],[Trans, LE.le, LT.lt]]
[Std.PersistentArray.mk.inj,[And.intro],[And, Eq]]
[Lean.Server.DocumentMeta.text,[],[Lean.FileMap]]
[Lean.Expr.headBeta,[ite, Eq, Lean.Expr.isHeadBetaTargetFn, Bool.true, Lean.Expr.betaRev, Lean.Expr.getAppRevArgs],[Lean.Expr]]
[Lean.Elab.liftMacroM,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, Lean.MonadRef.getRef, Lean.Elab.MonadMacroAdapter.getCurrMacroScope, Lean.MonadRecDepth.getRecDepth, Lean.MonadRecDepth.getMaxRecDepth, Lean.Elab.MonadMacroAdapter.getNextMacroScope, Lean.Macro.Context.mk, Lean.Environment.mainModule, Lean.Macro.State.mk, Lean.Elab.throwUnsupportedSyntax, Lean.throwErrorAt, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Elab.MonadMacroAdapter.setNextMacroScope, Lean.Macro.State.macroScope, List.forM, List.reverse, Lean.Macro.State.traceMsgs, PUnit, Lean.trace, Pure.pure],[]]
[Lean.instToJsonString,[Lean.ToJson.mk, Lean.Json.str],[Lean.ToJson, String]]
[Lean.Widget.InteractiveHypothesis.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Widget.InteractiveHypothesis.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.fromTerm,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.ScopedEnvExtension.Descr.name,[],[Lean.Name]]
[Lean.Elab.Tactic.withRWRulesSeq,[Bind.bind, Lean.Elab.Tactic.withTacticInfoContext, Lean.mkNullNode, List.toArray, List.cons, List.nil, Pure.pure, Unit.unit, ForIn.forIn, PUnit.unit, Lean.withRef, ForInStep.yield],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.Lsp.SemanticTokensLegend.mk.inj,[And.intro],[And, Eq]]
[Lean.Environment.registerNamespace,[ite, Eq, Lean.NameSSet.contains, Lean.SimplePersistentEnvExtension.getState, Lean.namespacesExt, Bool.true, Lean.PersistentEnvExtension.addEntry],[Lean.Environment]]
[EStateM.Backtrackable.save,[],[]]
[Lean.Expr.FoldConstsImpl.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.FoldConstsImpl.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Expr.FoldConstsImpl.State.mk, And]]
[Lean.Parser.numLitNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.numLitFn],[Lean.Parser.Parser]]
[Lean.IR.Borrow.updateParamMap,[Bind.bind, Lean.IR.Borrow.getCurrFn, MonadState.get, Unit.unit, Lean.IR.Borrow.M, Unit, Std.HashMap.find?, Lean.IR.Borrow.BorrowInfState.paramMap, Array.mapM, ite, Eq, not, Lean.IR.Param.borrow, Bool.true, Pure.pure, Lean.IR.Borrow.isOwned, Lean.IR.Param.x, Lean.IR.Borrow.markModified, Lean.IR.Param.mk, Bool.false, Lean.IR.Param.ty, modify, Lean.IR.Borrow.BorrowInfState.mk, Lean.IR.Borrow.BorrowInfState.owned, Lean.IR.Borrow.BorrowInfState.modified, Std.HashMap.insert],[Lean.IR.Borrow.M, Unit]]
[Lean.Json.arr.injEq,[Eq.propIntro, Eq.refl, Lean.Json.arr, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Json.arr]]
[Lean.Meta.ToHide.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.ToHide.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.FileWorker.RpcSession.keptAlive,[Bind.bind, liftM, IO.monoMsNow, Pure.pure, Lean.Server.FileWorker.RpcSession.mk, Lean.Server.FileWorker.RpcSession.aliveRefs, Lean.Server.FileWorker.RpcSession.nextRef, HAdd.hAdd, Lean.Server.FileWorker.RpcSession.keepAliveTimeMs],[IO, Lean.Server.FileWorker.RpcSession]]
[instModUInt32,[Mod.mk, UInt32.mod],[Mod, UInt32]]
[Lean.IR.ExplicitBoxing.BoxingContext.decls,[],[Array, Lean.IR.Decl]]
[Lean.Meta.instToFormatUnificationHints,[Std.ToFormat.mk, Std.ToFormat.format, Lean.Meta.UnificationHints.discrTree],[Std.ToFormat, Lean.Meta.UnificationHints]]
[iff_true,[propext, Iff.intro, Iff.mpr, trivial],[Eq, Iff, True]]
[Lean.Widget.InteractiveGoals.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Widget.InteractiveGoals.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Widget.InteractiveGoals.mk]]
[Lean.Meta.getMVarTag,[Bind.bind, Lean.Meta.getMVarDecl, Pure.pure, Lean.MetavarDecl.userName],[Lean.Meta.MetaM, Lean.Name]]
[Lean.Parser.Term.doFinally.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.getMajorPos?,[Lean.ParametricAttribute.getParam, Lean.Meta.recursorAttribute],[Option, Nat]]
[Lean.Parsec.notFollowedBy,[Lean.Parsec.ParseResult, Unit, Lean.Parsec.ParseResult.error, Lean.Parsec.ParseResult.success, Unit.unit],[Lean.Parsec, Unit]]
[Lean.IR.instToFormatFnBody,[Std.ToFormat.mk, Lean.IR.formatFnBody, OfNat.ofNat],[Std.ToFormat, Lean.IR.FnBody]]
[Lean.Meta.instInhabitedInfoCacheKey,[Inhabited.mk, Lean.Meta.InfoCacheKey.mk, arbitrary],[Inhabited, Lean.Meta.InfoCacheKey]]
[Lean.Expr.FoldConstsImpl.visited.proof_1,[lcProof],[LT.lt, USize.toNat, HMod.hMod, ptrAddrUnsafe, Array.size, Lean.Expr.FoldConstsImpl.State.visitedTerms]]
[Lean.IR.Decl.resultType,[Lean.IR.IRType],[Lean.IR.IRType]]
[IO.Error.resourceVanished.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.resourceVanished, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.resourceVanished, And]]
[Lean.Parser.instInhabitedPrattParsingTables,[Inhabited.mk, Lean.Parser.PrattParsingTables.mk],[Inhabited, Lean.Parser.PrattParsingTables]]
[Lean.JsonRpc.instToJsonMessage,[Lean.ToJson.mk, Lean.Json.mkObj, List.cons, Prod.mk, Lean.Json.str, List, Prod, String, Lean.Json, HAppend.hAppend, Lean.ToJson.toJson, List.nil, Lean.Json.opt],[Lean.ToJson, Lean.JsonRpc.Message]]
[Lean.Elab.InfoTree.below,[PProd, PUnit],[]]
[EStateM.pure,[EStateM.Result.ok],[EStateM]]
[Lean.IR.UnreachableBranches.InterpContext.noConfusionType,[],[]]
[Function.comp,[],[]]
[IO.FileRight.user,[],[IO.AccessRight]]
[ShiftRight.shiftRight,[],[]]
[Lean.Elab.Command.instMonadResolveNameCommandElabM,[Lean.MonadResolveName.mk, Bind.bind, Lean.Elab.Command.getScope, Pure.pure, Lean.Elab.Command.Scope.currNamespace, Lean.Elab.Command.Scope.openDecls],[Lean.MonadResolveName, Lean.Elab.Command.CommandElabM]]
[Lean.IR.CtorInfo.ssize,[],[Nat]]
[Lean.Elab.Term.elabMutualDef.processDeriving,[Bind.bind, ForIn.forIn, Unit.unit, Lean.Elab.Term.TermElabM, ForInStep, Subarray, Lean.Elab.DefView, Stream.next?, Pure.pure, ForInStep.done, Option.none, Lean.Elab.DefView.deriving?, PUnit.unit, Lean.resolveGlobalConstNoOverload, Lean.withRef, Lean.Elab.Term.processDefDeriving, Lean.Elab.DefViewElabHeader.declName, ite, Eq, Bool.true, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, ForInStep.yield],[Lean.Elab.Term.TermElabM, Unit]]
[List.foldr,[Unit.unit, PProd.fst],[]]
[Tactic.TryThis.addExactSuggestion,[Bind.bind, liftM, Tactic.TryThis.delabToRefinableSyntax, ite, Eq, Lean.Expr.hasExprMVar, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.Elab.Tactic.TacticM, Unit]]
[instInhabitedUInt32.proof_1,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[Lean.Parser.Trie.ibelow,[And, True],[]]
[Lean.Parser.Tactic.clear!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[WellFoundedRelation.noConfusionType,[],[]]
[Lean.Meta.Simp.Config.noConfusionType,[],[]]
[Std.RBNode.below,[PUnit, PProd],[]]
[Lean.Meta.Match.MatchEqns.splitterAltNumParams,[],[Array, Nat]]
[GroupWithZero.zero_mul,[],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.ConstructorVal.induct,[],[Lean.Name]]
[Lean.Parser.nodeInfo,[Lean.Parser.ParserInfo.mk, Lean.Parser.ParserInfo.collectTokens, Lean.Parser.SyntaxNodeKindSet.insert, Lean.Parser.ParserInfo.collectKinds, Lean.Parser.ParserInfo.firstTokens],[Lean.Parser.ParserInfo]]
[Lean.Syntax.mkApp,[dite, Eq, Array.size, Unit.unit, Eq.symm, Array.toArrayLit_eq, Eq.refl, Lean.Syntax, Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkNullNode, List.nil],[Lean.Syntax]]
[Lean.PrettyPrinter.Delaborator.delabOfNat,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPCoercions, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.strVal, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Pure.pure, Lean.Quote.quote, Alternative.failure],[Lean.PrettyPrinter.Delaborator.Delab]]
[ne_iff_lt_or_gt,[Iff.intro, lt_or_gt_of_ne, Ne, ne_of_lt, ne_of_gt],[Iff, Ne, Or, LT.lt, GT.gt]]
[Lean.MapDeclarationExtension.insert,[Lean.PersistentEnvExtension.addEntry, Prod.mk],[Lean.Environment]]
[Lean.LocalDecl.isLet,[Bool, Bool.false, Bool.true],[Bool]]
[Array.instAppendArray,[Append.mk, Array.append],[Append, Array]]
[Tactic.LibrarySearch.librarySearch',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Meta.assumptionCore,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType, Lean.Meta.findLocalDeclWithType?, Unit.unit, Lean.Meta.MetaM, Bool, Pure.pure, Bool.false, Lean.Meta.assignExprMVar, Lean.mkFVar, Bool.true],[Lean.Meta.MetaM, Bool]]
[Lean.Meta.IndPredBelow.Variables.noConfusionType,[],[]]
[Decidable.not_and_distrib',[Iff.intro, dite, Or.inl, And.intro, Or.inr, not_and_of_not_or_not],[Iff, Not, And, Or]]
[Lean.SMap.insert,[Lean.SMap, Lean.SMap.mk, Bool.true, Std.HashMap.insert, Bool.false, Std.PersistentHashMap.insert],[Lean.SMap]]
[Lean.Lsp.DiagnosticTag.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.DiagnosticTag.toCtorIdx],[]]
[Lean.Meta.mapErrorImp,[MonadExcept.tryCatch, Lean.Exception.internal, Lean.Meta.MetaM, MonadExcept.throw, Lean.Exception.error],[Lean.Meta.MetaM]]
[Lean.Elab.Tactic.ElabSimpArgsResult.starArg,[],[Bool]]
[UInt64.modn,[UInt64.mk, HMod.hMod, UInt64.val],[UInt64]]
[Lean.MetavarContext.UnivMVarParamResult.newParamNames,[],[Array, Lean.Name]]
[UInt16.instSemiringUInt16.proof_11,[Eq.mpr, congr, congrArg, Eq, Eq.trans, HMul.hMul, UInt16.add_def, UInt16.mul_def, UInt16.mk, HAdd.hAdd, UInt16.val, UInt16.eq_of_val_eq, Semiring.mul_add],[Eq, HMul.hMul, HAdd.hAdd]]
[Lean.instInhabitedEnvExtensionEntry,[Inhabited.mk, PointedType.val, Lean.EnvExtensionEntrySpec],[Inhabited, Lean.EnvExtensionEntry]]
[Lean.Elab.Term.Do.mkReturn,[Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.return],[Lean.Elab.Term.Do.CodeBlock]]
[UInt32.toUInt64,[Nat.toUInt64, UInt32.toNat],[UInt64]]
[Std.RBTree.subset,[Std.RBTree.all, Option.toBool, Std.RBTree.find?],[Bool]]
[Lean.StructureDescr.structName,[],[Lean.Name]]
[Lean.ConstantInfo.recInfo.inj,[],[Eq]]
[Lean.Parser.Term.matchAltsWhereDecls.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.matchAlts.formatter, Lean.Parser.termParser.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.whereDecls.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.ParserState.keepTop,[Array.push, Array.shrink],[Array, Lean.Syntax]]
[Lean.Meta.appendParentTag,[Bind.bind, Lean.Meta.getMVarTag, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Meta.setMVarTag, Lean.Expr.mvarId!, Array.getOp, Lean.Name.isAnonymous, Pure.pure, PUnit.unit, Nat.forM, Lean.Meta.isExprMVarAssigned, Lean.BinderInfo.isInstImplicit, Lean.Meta.appendTag],[Lean.Meta.MetaM, Unit]]
[List.tailD,[List],[List]]
[Lean.JsonRpc.ResponseError.noConfusionType,[],[]]
[Lean.Meta.Simp.synthesizeArgs.synthesizeInstance,[Bind.bind, liftM, Lean.Meta.trySynthInstance, Option.none, Lean.LOption.none, Lean.LOption.undef, Lean.Meta.Simp.SimpM, Bool, Lean.Meta.withReducibleAndInstances, Lean.Meta.isDefEq, ite, Eq, Bool.true, Pure.pure, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, PUnit.unit],[Lean.Meta.Simp.SimpM, Bool]]
[Lean.Lsp.instToJsonWaitForDiagnosticsParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.WaitForDiagnosticsParams.uri, List.nil, Lean.Lsp.WaitForDiagnosticsParams.version],[Lean.ToJson, Lean.Lsp.WaitForDiagnosticsParams]]
[Lean.Elab.Command.elabSyntax,[Bind.bind, Pure.pure, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Option.some, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[boolToSort,[CoeSort.mk, Eq, Bool.true],[CoeSort, Bool]]
[Lean.PrettyPrinter.Delaborator.delabForall,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, MonadExcept.tryCatch, liftM, Lean.Meta.isProp, Pure.pure, Bool.false, List.toArray, List.nil],[Lean.PrettyPrinter.Delaborator.Delab]]
[iff_of_eq,[Iff.rfl],[Iff]]
[Lean.Elab.Tactic.evalRenameInaccessibles,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Tactic.getMainGoal, Lean.Elab.Tactic.renameInaccessibles, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.nil, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[Lean.hasMatchPatternAttribute,[Lean.TagAttribute.hasTag, Lean.matchPatternAttr],[Bool]]
[Lean.PrettyPrinter.Delaborator.getOptionsAtCurrPos,[Bind.bind, MonadReader.read, Lean.PrettyPrinter.Delaborator.SubExpr.getPos, Pure.pure, Std.RBMap.find?, Lean.PrettyPrinter.Delaborator.Context.optionsPerPos, Option.none, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Options, ForIn.forIn, ForInStep, PUnit.unit, ForInStep.yield],[Lean.PrettyPrinter.Delaborator.DelabM, Lean.Options]]
[Lean.Parser.Term.binderIdent,[HOrElse.hOrElse, Lean.Parser.Term.ident, Lean.Parser.Term.hole],[Lean.Parser.Parser]]
[Lean.Level.updateSucc,[Lean.mkLevelSucc],[Lean.Level]]
[Lean.IR.Alt.isDefault,[Bool, Bool.false, Bool.true],[Bool]]
[Lean.Lsp.DiagnosticRelatedInformation.noConfusionType,[],[]]
[Lean.IR.EmitC.emitSProj,[Bind.bind, Lean.IR.EmitC.emitLhs, Unit.unit, Lean.IR.IRType.usize, Lean.IR.IRType.irrelevant, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.struct, Lean.IR.IRType.union, Lean.IR.EmitC.M, Unit, Lean.IR.EmitC.emit, MonadExcept.throw],[Lean.IR.EmitC.M, Unit]]
[Std.HashMap.forM,[PUnit, Std.HashMapImp.forM],[PUnit]]
[List.erase_append_left,[Eq.mpr, congr, congrArg, Eq, List.erase_eq_erasep, HAppend.hAppend, congrFun, List.erasep_append_left, rfl],[Eq, List.erase, HAppend.hAppend]]
[Std.instToFormatFormat,[Std.ToFormat.mk],[Std.ToFormat, Std.Format]]
[Lean.Elab.Term.LetRecDeclView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.LetRecDeclView.mk, HAdd.hAdd, OfNat.ofNat]]
[Subsingleton.elim,[Subsingleton.elim.proof_1],[Eq]]
[Not.intro,[],[Not]]
[Lean.Meta.mkSizeOfFns,[Bind.bind, Lean.getConstInfoInduct, Lean.getConstInfoRec, Lean.mkRecName, ForIn.forIn, MProd.mk, Lean.Meta.mkSizeOfFn, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Meta.MetaM, Prod, Array, Lean.Name, Lean.NameMap, Prod.mk],[Lean.Meta.MetaM, Prod, Array, Lean.Name, Lean.NameMap]]
[Lean.Elab.Term.hasElabWithoutExpectedType,[Lean.TagAttribute.hasTag, Lean.Elab.Term.elabWithoutExpectedTypeAttr],[Bool]]
[Substring.dropWhile,[Substring, Substring.mk],[Substring]]
[Function.bijective.of_comp_iff',[and_congr, Function.injective.of_comp_iff, Function.bijective.injective, Function.surjective.of_comp_iff'],[Iff, Function.bijective, Function.comp]]
[implies_of_if_neg,[],[]]
[Std.RBMap.lowerBound,[Option, Sigma, Std.RBNode.lowerBound, Option.none],[Option, Sigma]]
[Lean.Parser.TokenMap.instEmptyCollectionTokenMap,[EmptyCollection.mk, Std.RBMap.empty],[EmptyCollection, Lean.Parser.TokenMap]]
[Semiring.mul_add,[],[Eq, HMul.hMul, HAdd.hAdd]]
[Lean.IR.CtorFieldInfo.instToFormatCtorFieldInfo,[Std.ToFormat.mk, Lean.IR.CtorFieldInfo.format],[Std.ToFormat, Lean.IR.CtorFieldInfo]]
[Lean.Meta.IndPredBelow.mkBelow,[Bind.bind, Lean.Meta.isInductivePredicate, ite, Eq, Bool.true, Lean.getConstInfoInduct, Lean.InductiveVal.isRec, Lean.Meta.IndPredBelow.mkContext, Lean.Meta.IndPredBelow.mkBelowDecl, Lean.addDecl, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.IndPredBelow.Context.belowNames, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Unit]]
[String.substrEq,[and, Decidable.decide, LE.le, HAdd.hAdd, String.bsize, String.substrEq.loop],[Bool]]
[DoResultPRBC.break.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultPRBC.break, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.instFromJsonDidChangeTextDocumentParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.VersionedTextDocumentIdentifier, Array, Lean.Lsp.TextDocumentContentChangeEvent, Pure.pure, Lean.Lsp.DidChangeTextDocumentParams.mk],[Lean.FromJson, Lean.Lsp.DidChangeTextDocumentParams]]
[Lean.AttributeExtensionOLeanEntry.builder.inj,[And.intro],[And, Eq]]
[UInt32.one_def,[rfl],[Eq, OfNat.ofNat, UInt32.mk]]
[Lean.Parser.Command.export.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter, Lean.Parser.many1.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.Match.AltLHS.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.rotateRight,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Parser.precedence.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.precedenceParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.forEachExpr',[Lean.MonadCacheT.run, Lean.Meta.ForEachExpr.visit],[Lean.Meta.MetaM, Unit]]
[Lean.MessageData.below,[PUnit, PProd],[]]
[Lean.Parser.scientificLit.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.scientificLitKind, Bool.true, Lean.PrettyPrinter.Formatter.scientificLitNoAntiquot.formatter],[Lean.PrettyPrinter.Formatter]]
[UInt16.instRingUInt16.proof_5,[UInt16.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, UInt16.val, congrFun, HAdd.hAdd, UInt16.neg_def, UInt16.add_def, UInt16.mk, Neg.neg, add_left_neg, UInt16.zero_def, eq_true_of_decide, Eq.refl, Bool.true],[Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat]]
[Lean.Elab.Structural.getEqnsFor?,[Bind.bind, Lean.MonadEnv.getEnv, Option.none, Lean.Meta.MetaM, Option, Array, Lean.Name, Std.PersistentHashMap.find?, Lean.Elab.Structural.EqnsExtState.map, Lean.EnvExtension.getState, Lean.Elab.Structural.eqnsExt, Pure.pure, Option.some, Lean.MapDeclarationExtension.find?, Lean.Elab.Structural.eqnInfoExt, Lean.Elab.Structural.mkEqns, Lean.MonadEnv.modifyEnv, Lean.EnvExtension.modifyState, Lean.Elab.Structural.EqnsExtState.mk, Std.PersistentHashMap.insert],[Lean.Meta.MetaM, Option, Array, Lean.Name]]
[Lean.mkBInductionOnName,[Lean.Name.mkStr, Lean.binductionOnSuffix],[Lean.Name]]
[String.length_append,[Eq, String.length, HAppend.hAppend, HAdd.hAdd, Eq.mpr, Eq.refl, String.mk, String.congr_append, List.length_append],[Eq, String.length, HAppend.hAppend, HAdd.hAdd]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Mathlib.Tactic.Lint.SimpLemmaInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Mathlib.Tactic.Lint.SimpLemmaInfo.mk, And]]
[Lean.Elab.Term.PatternVarDecl.localVar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.PatternVarDecl.localVar, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.forInMacro.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[DivInvMonoid.noConfusionType,[],[]]
[Lean.Parser.peekTokenAux,[Option.none, Prod, Lean.Parser.ParserState, Except, Lean.Syntax, Lean.Parser.ParserState.errorMsg, Prod.mk, Lean.Parser.ParserState.restore, Except.error, Except.ok],[Prod, Lean.Parser.ParserState, Except, Lean.Syntax]]
[Std.mkPArray,[Std.mkPersistentArray],[Std.PArray]]
[Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat.lt_of_lt_of_le],[LT.lt]]
[Lean.Elab.TermInfo.format,[Lean.Elab.TermInfo.runMetaM, Bind.bind, MonadExcept.tryCatch, Lean.Meta.ppExpr, Lean.Elab.TermInfo.expr, Lean.Meta.inferType, Pure.pure, HAppend.hAppend, Std.ToFormat.format, ite, Eq, Lean.Name.isAnonymous, Lean.Elab.ElabInfo.elaborator, Bool.true, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Std.Format, Lean.Elab.ElabInfo.stx, Lean.Elab.TermInfo.toElabInfo],[IO, Std.Format]]
[UInt8.instRingUInt8,[Ring.mk, UInt8.instRingUInt8.proof_1, UInt8.mk, Ring.gsmul, UInt8.val, UInt8.instRingUInt8.proof_2, UInt8.instRingUInt8.proof_3, UInt8.instRingUInt8.proof_4, UInt8.instRingUInt8.proof_5],[Ring, UInt8]]
[Lean.Level.updateIMax!,[Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.param, Lean.Level.mvar, Lean.Level, Lean.Level.updateIMax, Lean.Level.imax, Lean.Level.updateIMax!.proof_1, panicWithPosWithDecl, OfNat.ofNat],[Lean.Level]]
[Lean.isStructureLike,[Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, dite, Eq, Lean.ConstantInfo.inductInfo, Lean.InductiveVal.mk, Lean.ConstantVal.mk, List.nil, List.cons, Bool.true, Eq.symm, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Bool, Lean.Environment.find?, Bool.false],[Bool]]
[Lean.Parser.trailingNodeFn,[Lean.Parser.ParserState.mkTrailingNode],[Lean.Parser.ParserFn]]
[UInt64.instSemiringUInt64.proof_1,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt64.zero_def, UInt64.add_def, UInt64.mk, OfNat.ofNat, add_zero, UInt64.val, UInt64.mk_val_eq, eq_self, propext, forall_const, UInt64],[Eq, HAdd.hAdd, OfNat.ofNat]]
[UInt16.instInhabitedFinSize,[Inhabited.mk, Fin.ofNat', OfNat.ofNat, UInt16.size_positive],[Inhabited, Fin, UInt16.size]]
[Lean.Lsp.ClientInfo.mk.inj,[And.intro],[And, Eq]]
[Nat.mul_mod,[],[Eq, HMod.hMod, HMul.hMul]]
[Lean.MonadBacktrack.saveState,[],[]]
[Lean.Parser.Priority.numPrio.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.numLit.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Server.Snapshots.compileNextCmd,[IO, Lean.Server.Snapshots.Snapshot, ite, Eq, or, Lean.Parser.isEOI, Lean.Parser.isExitCommand, Bool.true, Bind.bind, Pure.pure, liftM, IO.mkRef, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, IO.FS.withIsolatedStreams, Lean.Elab.Command.catchExceptions, SeqRight.seqRight, Lean.Elab.getResetInfoTrees, Lean.Elab.Command.elabCommandTopLevel, ST.Ref.get, not, String.isEmpty, PUnit.unit, Lean.Server.Snapshots.compileNextCmd.withNewInteractiveDiags],[IO, Lean.Server.Snapshots.Snapshot]]
[PSigma.SkipLeft,[PSigma.RevLex, emptyRelation],[]]
[Lean.StructureDescr.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.StructureDescr.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Compiler.SpecState.noConfusionType,[],[]]
[Lean.Meta.SynthInstance.GeneratorNode.mctx,[],[Lean.MetavarContext]]
[Decidable.em,[Decidable.byCases, Or.inl, Or.inr],[Or, Not]]
[Array.insertionSort.swapLoop.proof_1,[Nat.lt_trans, Nat.lt_succ_self, Eq.symm],[LT.lt, Array.size]]
[Lean.PrettyPrinter.Parenthesizer.nonReservedSymbolNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.SavedState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.SavedState.mk, HAdd.hAdd, OfNat.ofNat]]
[and_congr_left',[and_congr, Iff.rfl],[Iff, And]]
[if_true,[if_pos, trivial],[Eq, ite, True]]
[Lean.Parser.Tactic.traceState,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.IR.Borrow.OwnedSet.beq,[Bool, and, BEq.beq],[Bool]]
[Lean.Option.Decl.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Option.Decl.mk, HAdd.hAdd, OfNat.ofNat]]
[Subarray.toArray,[Array.ofSubarray],[Array]]
[Lean.mkBVar,[Lean.Expr.bvar, Lean.Expr.mkData, mixHash, OfNat.ofNat, Hashable.hash, HAdd.hAdd, Bool.false],[Lean.Expr]]
[Lean.Widget.TaggedText.below,[PUnit, PProd],[]]
[Std.Range.stop,[],[Nat]]
[Lean.IR.instToFormatJoinPointId,[Std.ToFormat.mk, Std.Format.text, ToString.toString],[Std.ToFormat, Lean.IR.JoinPointId]]
[Lean.Parser.Command.structSimpleBinder.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Command.declModifiers.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.inferMod.formatter, Lean.Parser.Command.optDeclSig.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.binderTactic.formatter, Lean.Parser.Term.binderDefault.formatter],[Lean.PrettyPrinter.Formatter]]
[le_antisymm_iff,[Iff.intro, And.intro, le_of_eq, Eq.symm, Eq, le_antisymm],[Iff, Eq, And, LE.le]]
[Lean.IR.ExpandResetReuse.setFields,[Nat.fold, Lean.IR.FnBody.set, Array.get!, Array.size],[Lean.IR.FnBody]]
[Lean.Elab.Term.Do.Alt.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.Alt.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.getDecl',[Bind.bind, Lean.IR.findDecl', Option.none, Lean.IR.CompilerM, Lean.IR.Decl, Pure.pure, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.IR.CompilerM, Lean.IR.Decl]]
[Array.toListLitAux,[List, PProd.fst, Array.toListLitAux.proof_1, List.cons, Array.getLit, Array.toListLitAux.proof_2],[List]]
[Lean.Lsp.Trace.verbose.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.Trace.verbose, OfNat.ofNat]]
[Lean.Lsp.LeanFileProgressProcessingInfo.mk.inj,[],[Eq]]
[add_left_comm,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Eq.symm, add_assoc, add_comm, rfl],[Eq, HAdd.hAdd]]
[Nat.lt_of_le_of_ne,[LT.lt, Nat.lt_or_ge, absurd, Nat.le_antisymm],[LT.lt]]
[Std.PersistentHashMap.foldlM,[Std.PersistentHashMap.foldlMAux, Std.PersistentHashMap.root],[]]
[Lean.Xml.Content.Character.injEq,[Eq.propIntro, Eq.refl, Lean.Xml.Content.Character, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Xml.Content.Character]]
[Nat.le_of_not_lt,[Or.resolve_left, Nat.lt_or_ge],[LE.le]]
[IO.Error.mkInvalidArgumentFile,[Function.comp, IO.Error.invalidArgument, Option.some],[IO.Error]]
[Monoid.one_mul,[],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Export.instCoeNameEntry,[Coe.mk, Lean.Export.Entry.name],[Coe, Lean.Name, Lean.Export.Entry]]
[Lean.LOption.none.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.LOption.none, OfNat.ofNat]]
[List.pwFilter,[Unit.unit, List, List.nil, ite, List.cons],[List]]
[Nat.coprime.gcd_left,[Nat.coprime.coprime_dvd_left, Nat.gcd_dvd_right],[Nat.coprime, Nat.gcd]]
[Lean.Elab.Term.SyntheticMVarDecl.noConfusionType,[],[]]
[Lean.Parser.Command.notation3Item,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.parser, Lean.Parser.Command.bindersItem, Lean.ParserDescr.unary, Lean.Parser.Command.identScope],[Lean.ParserDescr]]
[le_of_lt_or_eq,[LE.le, le_of_lt, le_refl],[LE.le]]
[one_mul,[Monoid.one_mul],[Eq, HMul.hMul, OfNat.ofNat]]
[Std.PersistentHashMap.Entry.null.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Std.PersistentHashMap.Entry.null, OfNat.ofNat]]
[String.isNat,[String.all, Char.isDigit],[Bool]]
[Lean.Elab.Command.StructFieldInfo.fvar,[],[Lean.Expr]]
[Lean.Server.Watchdog.handleCrash,[Bind.bind, Lean.Server.Watchdog.findFileWorker!, Lean.Server.Watchdog.updateFileWorkers, Lean.Server.Watchdog.FileWorker.mk, Lean.Server.Watchdog.FileWorker.doc, Lean.Server.Watchdog.FileWorker.proc, Lean.Server.Watchdog.FileWorker.commTask, Lean.Server.Watchdog.WorkerState.crashed, Lean.Server.Watchdog.FileWorker.pendingRequestsRef, Lean.Server.Watchdog.FileWorker.groupedEditsRef],[Lean.Server.Watchdog.ServerM, Unit]]
[Std.PersistentHashMap.Node.entries.inj,[],[Eq]]
[PSigma.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, PSigma.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.getMVarDecl,[Bind.bind, Lean.MonadMCtx.getMCtx, Unit.unit, Lean.Meta.MetaM, Lean.MetavarDecl, Lean.MetavarContext.findDecl?, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MVarId.name],[Lean.Meta.MetaM, Lean.MetavarDecl]]
[Lean.Syntax.isIdOrAtom?,[Lean.Syntax.missing, Lean.Syntax.node, Option, String, Option.some, Substring.toString, Option.none],[Option, String]]
[Lean.KVMap.contains,[Option.isSome, Lean.KVMap.find],[Bool]]
[Lean.Parser.Term.binderDefault.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.existsIntro,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType', Lean.matchConstStruct, Lean.Expr.getAppFn, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing, ite, LT.lt, Lean.ConstructorVal.numFields, OfNat.ofNat, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.instReprReducibilityStatus,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone],[Repr, Lean.ReducibilityStatus]]
[Lean.Parser.numLit,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.numLitKind, Bool.true, Lean.Parser.numLitNoAntiquot],[Lean.Parser.Parser]]
[Lean.IR.Checker.CheckerContext.decls,[],[Array, Lean.IR.Decl]]
[PSigma.lex.proof_1,[WellFounded.intro, Acc, PSigma.Lex, PSigma.lexAccessible, WellFounded.apply],[WellFounded, PSigma.Lex]]
[Lean.isLHSGoal?,[Unit.unit, Option, Lean.Expr, Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous, Option.none, ite, Eq, Lean.Expr.isAppOfArity, OfNat.ofNat, Bool.true, Option.some, Lean.Expr.appArg!, Lean.Expr.appFn!],[Option, Lean.Expr]]
[List.card_remove_of_mem,[Eq, List.card, HAdd.hAdd, List.remove, OfNat.ofNat, False.elim, List.not_mem_nil, Decidable.em, Eq.mpr, congrArg, List.cons, congrFun, if_pos, List, Mem.mem, Eq.symm, Eq.refl],[Eq, List.card, HAdd.hAdd, List.remove, OfNat.ofNat]]
[Bool.true.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Bool.true, OfNat.ofNat]]
[Lean.IR.EmitC.emitArgs,[Nat.forM, Array.size, ite, GT.gt, OfNat.ofNat, Bind.bind, Lean.IR.EmitC.emit, Pure.pure, PUnit.unit],[Lean.IR.EmitC.M, Unit]]
[Lean.Elab.WF.TerminationHintValue.noConfusionType,[],[]]
[Lean.addSearchPathFromEnv,[Bind.bind, liftM, IO.getEnv, Unit.unit, IO, Lean.SearchPath, Pure.pure, HAppend.hAppend, System.SearchPath.parse],[IO, Lean.SearchPath]]
[Lean.Parser.Term.structInst.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ppHardSpace.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.termParser.parenthesizer, Bool.false, Lean.Parser.manyIndent.parenthesizer, Lean.Parser.group.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.structInstFieldAbbrev.parenthesizer, Lean.Parser.Term.structInstField.parenthesizer, Lean.Parser.Term.optEllipsis.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Tactic.«tacticHave__:=_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Command.macroTailDefault.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.darrow.parenthesizer, Lean.Parser.Command.macroRhs.parenthesizer, Lean.PrettyPrinter.Parenthesizer.categoryParserOfStack.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.AssertAfterResult.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.squeezeDSimp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Lsp.Range.start,[],[Lean.Lsp.Position]]
[Mathlib.Tactic.Ext.tacticSubstEqs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.isStructure,[Option.isSome, Lean.getStructureInfo?],[Bool]]
[Lean.ClosedTermCache.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ClosedTermCache.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ClosedTermCache.mk, And]]
[List.asString,[String.mk],[String]]
[Lean.PrettyPrinter.Formatter.rawCh.formatter,[Lean.PrettyPrinter.Formatter.symbolNoAntiquot.formatter, Char.toString],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Term.termPpquoteₓ_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.checkWsBeforeFn,[ite, Eq, Lean.Parser.checkTailWs, Bool.true, Lean.Parser.ParserState.mkError],[Lean.Parser.ParserFn]]
[Lean.Parser.termRegister_parser_alias___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[eq_false_of_ne_true,[Eq, Bool.false, False.elim, rfl],[Eq, Bool.false]]
[Lean.Elab.DerivingClassView.args?,[],[Option, Lean.Syntax]]
[Lean.Elab.Term.FunBinders.State.lctx,[],[Lean.LocalContext]]
[Subset.subset,[],[]]
[Lean.KVMap.setName,[Lean.KVMap.insert, Lean.DataValue.ofName],[Lean.KVMap]]
[Lean.Meta.IndPredBelow.mkCtorType,[Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, Lean.Meta.IndPredBelow.Variables.mk, Array.ofSubarray, Array.toSubarray, OfNat.ofNat, Lean.Meta.IndPredBelow.Context.numParams, List.toArray, List.nil, Array.size, Lean.Meta.IndPredBelow.mkCtorType.addHeaderVars, Lean.Meta.IndPredBelow.mkCtorType.addMotives, Lean.Meta.IndPredBelow.mkCtorType.modifyBinders, Lean.Meta.IndPredBelow.mkCtorType.rebuild, Lean.Meta.IndPredBelow.mkCtorType.replaceTempVars, Lean.Meta.IndPredBelow.mkCtorType.checkCount, Lean.Meta.IndPredBelow.mkCtorType.mkBelowBinder, Lean.Meta.IndPredBelow.mkCtorType.mkMotiveBinder, Lean.Meta.IndPredBelow.mkCtorType.copyVarName],[Lean.Meta.MetaM, Lean.Expr]]
[IO.FS.FileType.dir.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.FileType.dir, OfNat.ofNat]]
[dbgTraceVal,[dbgTrace, ToString.toString],[]]
[String.Iterator.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.ElabAppArgs.State.expectedType?,[],[Option, Lean.Expr]]
[Std.Format.FlattenBehavior.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Compiler.isToNat,[List.any, Lean.Compiler.numScalarTypes, BEq.beq, Lean.Compiler.NumScalarTypeInfo.toNatFn],[Bool]]
[instReprDecidable,[Repr.mk, Std.Format, Repr.addAppParen, Std.Format.text],[Repr, Decidable]]
[Std.PersistentArrayNode.node.injEq,[Eq.propIntro, Eq.refl, Std.PersistentArrayNode.node, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.PersistentArrayNode.node]]
[Preorder.le_refl,[],[LE.le]]
[Lean.Meta.Simp.SimpLetCase.toCtorIdx,[OfNat.ofNat],[Nat]]
[List.subset_append_left,[List.mem_append_left],[Subset.subset, HAppend.hAppend]]
[instDecidableEqFin,[Decidable, Eq, decEq, Fin.val, Decidable.isTrue, Fin.eq_of_val_eq, Decidable.isFalse, Fin.ne_of_val_ne],[DecidableEq, Fin]]
[Lean.IR.Checker.CheckerContext.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.fieldIdx,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.fieldIdxFn],[Lean.Parser.Parser]]
[add_right_comm,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, add_assoc, add_comm, rfl],[Eq, HAdd.hAdd]]
[Lean.Meta.introNP,[Lean.Meta.introNCore, List.nil, Bool.false, Bool.true],[Lean.Meta.MetaM, Prod, Array, Lean.FVarId, Lean.MVarId]]
[Lean.Parser.Tactic.tacticSeqBracketed,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many, Lean.Parser.group, Lean.Parser.ppLine, Lean.Parser.tacticParser, Lean.Parser.optional, Lean.Parser.ppDedent],[Lean.Parser.Parser]]
[List.head!,[Unit.unit, panicWithPosWithDecl, OfNat.ofNat],[]]
[Lean.Meta.DefEqCache,[Std.PersistentHashMap, Prod, Lean.Expr, Unit],[]]
[Lean.IR.Decl.updateBody!,[Lean.IR.Decl.extern, Lean.IR.Decl, Lean.IR.Decl.fdecl, panicWithPosWithDecl, OfNat.ofNat],[Lean.IR.Decl]]
[Lean.ImportM.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ImportM.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ImportM.Context.mk, And]]
[Lean.Parser.Term.typeAscription.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.Do.CodeBlocl.toMessageData,[Lean.Elab.Term.Do.CodeBlock.code, Lean.Elab.Term.Do.CodeBlocl.toMessageData.loop],[Lean.MessageData]]
[Lean.PrettyPrinter.Delaborator.delabSort,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Unit.unit, Lean.Level.dec, Lean.Level.quote, OfNat.ofNat, panicWithPosWithDecl],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.Elab.Term.Do.mkBreak,[Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.break],[Lean.Elab.Term.Do.CodeBlock]]
[Lean.Elab.Tactic.MkSimpContextResult.ctx,[],[Lean.Meta.Simp.Context]]
[UInt16.noConfusionType,[],[]]
[ULift.up_down,[Eq, ULift.up, ULift.down, rfl],[Eq, ULift.up, ULift.down]]
[Lean.Parser.antiquotExpr,[HOrElse.hOrElse, Lean.Parser.identNoAntiquot, Lean.Parser.antiquotNestedExpr],[Lean.Parser.Parser]]
[Lean.Meta.Closure.Context.mk.inj,[],[Eq]]
[Lean.Xml.Parser.Mixed,[HOrElse.hOrElse, Bind.bind, Lean.Parsec.skipChar, Char.ofNat, SeqRight.seqRight, optional, Lean.Xml.Parser.S, Lean.Parsec.skipString, Lean.Parsec.many, Lean.Xml.Parser.Name, SeqLeft.seqLeft],[Lean.Parsec, Unit]]
[Subtype.val,[],[]]
[USize.decLe,[Decidable, LE.le, inferInstanceAs],[Decidable, LE.le]]
[Lean.Elab.Term.getPatternVars,[Bind.bind, Lean.Elab.liftMacroM, Lean.expandMacros, StateRefT'.run, Lean.Elab.Term.CollectPatternVars.collect, Lean.Elab.Term.CollectPatternVars.State.mk, Lean.Elab.Term.TermElabM, Array, Lean.Elab.Term.PatternVar, Pure.pure, Lean.Elab.Term.CollectPatternVars.State.vars],[Lean.Elab.Term.TermElabM, Array, Lean.Elab.Term.PatternVar]]
[Lean.MetavarContext.hasAssignableMVar,[Bool, List.any, Lean.MetavarContext.hasAssignableLevelMVar, or, and, Lean.Expr.hasMVar, PProd.fst, PProd.snd, Bool.false, Lean.MetavarContext.isExprAssignable],[Bool]]
[Tactic.Ring.HornerExpr.xadd.injEq,[Eq.propIntro, And.intro, Eq.refl, Tactic.Ring.HornerExpr.xadd, Eq.symm, eq_of_heq, HEq.refl],[Eq, Tactic.Ring.HornerExpr.xadd, And]]
[Std.Format.defUnicode,[Bool.true],[Bool]]
[Lean.Lsp.DidOpenTextDocumentParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.DidOpenTextDocumentParams.mk, HAdd.hAdd, OfNat.ofNat]]
[lt_of_lt_of_le,[LT.lt, lt_of_le_not_le, le_trans],[LT.lt]]
[instSubFloat,[Sub.mk, Float.sub],[Sub, Float]]
[StateRefT'.modifyGet,[ST.Ref.modifyGet],[StateRefT']]
[Lean.Elab.addAndCompilePartialRec,[ite, Eq, Array.all, and, not, Lean.Elab.DefKind.isTheorem, Lean.Elab.PreDefinition.kind, Lean.Elab.Modifiers.isNoncomputable, Lean.Elab.PreDefinition.modifiers, OfNat.ofNat, Array.size, Bool.true, Lean.Elab.addAndCompileUnsafe, Array.map, Lean.Elab.PreDefinition.mk, Lean.Elab.PreDefinition.ref, Lean.Elab.PreDefinition.levelParams, Lean.Elab.Modifiers.mk, Lean.Compiler.mkUnsafeRecName, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.type, Lean.Expr.replace, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Expr, Array.any, BEq.beq, Option.some, Lean.mkConst, Option.none, Lean.Elab.PreDefinition.value, Lean.DefinitionSafety.partial, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElabM, Unit]]
[UInt16.size_positive,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt16.size]]
[Lean.Meta.SimpAll.Entry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SimpAll.Entry.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.intro,[Bind.bind, Lean.Meta.introN, OfNat.ofNat, List.cons, List.nil, Bool.false, Lean.Meta.MetaM, Prod, Lean.FVarId, Lean.MVarId, Pure.pure, Prod.mk, Array.get!],[Lean.Meta.MetaM, Prod, Lean.FVarId, Lean.MVarId]]
[Function.left_inverse.right_inverse,[],[Function.right_inverse]]
[Lean.Meta.mkCongrFun,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Meta.mkEqRefl, Lean.mkApp, Lean.Expr.appArg!, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Option.none, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.eq?, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.getLevel, Pure.pure, Lean.mkApp6, Lean.mkConst, List.cons, List.nil, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr],[Lean.Meta.MetaM, Lean.Expr]]
[instOrOpUInt8,[OrOp.mk, UInt8.lor],[OrOp, UInt8]]
[Lean.Parser.Term.waitIfTypeMVar.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.FVarSubst.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.FVarSubst.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.Conv.dsimp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.PrettyPrinter.Parenthesizer.registerAlias,[Lean.Parser.registerAliasCore, Lean.PrettyPrinter.Parenthesizer.parenthesizerAliasesRef],[IO, Unit]]
[Lean.isIOUnitInitFn,[or, Lean.isIOUnitBuiltinInitFn, Lean.isIOUnitRegularInitFn],[Bool]]
[Lean.ImportM.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ImportM.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Function.right_inverse.surjective,[Exists.intro],[Function.surjective]]
[Lean.Parser.ParserState.stackSize,[Array.size, Lean.Parser.ParserState.stxStack],[Nat]]
[Lean.Meta.tryUnificationHints.isDefEqPattern,[Lean.Meta.withReducible, Lean.Meta.isExprDefEqAux],[Lean.Meta.MetaM, Bool]]
[Lean.ScopedEnvExtension.Descr.addEntry,[],[]]
[Nat.Up,[And, LT.lt],[]]
[Lean.Expr.replaceFVar,[Lean.Expr.instantiate1, Lean.Expr.abstract, List.toArray, List.cons, List.nil],[Lean.Expr]]
[Lean.Elab.DefKind.noConfusion,[noConfusionEnum, Lean.Elab.DefKind.toCtorIdx],[Lean.Elab.DefKind.noConfusionType]]
[Char.eq_of_val_eq,[Eq.symm, eq_of_heq, Eq.refl, Char.val, Char.mk, HEq.refl, Eq, rfl],[Eq]]
[Nat.add_sub_assoc,[Eq, HSub.hSub, HAdd.hAdd, Eq.mpr, Eq.refl, Eq.symm, Nat.add_sub_cancel_left, Nat.add_comm, Nat.add_assoc, Nat.add_sub_cancel, rfl],[Eq, HSub.hSub, HAdd.hAdd]]
[Lean.IR.EmitC.emitSimpleExternalCall,[Bind.bind, Lean.IR.EmitC.emit, Functor.discard, Nat.foldM, ite, Eq, Lean.IR.IRType.isIrrelevant, Lean.IR.Param.ty, Array.getOp, Bool.true, Pure.pure, PUnit.unit, Array.size, Lean.IR.EmitC.emitLn, Unit.unit],[Lean.IR.EmitC.M, Unit]]
[Lean.Elab.Term.Context.sectionVars,[],[Lean.NameMap, Lean.Name]]
[Lean.Parser.mkIdResult,[ite, Eq, Unit.unit, Bool, Bool.false, Decidable.decide, GE.ge, String.bsize, HSub.hSub, Bool.true, Lean.Parser.mkTokenAndFixPos, Lean.Parser.ParserState.pushSyntax],[Lean.Parser.ParserFn]]
[true_or,[propext, Iff.intro, trivial, Or.inl],[Eq, Or, True]]
[ByteArray.data,[],[Array, UInt8]]
[List.mapIdx.loop,[List, List.nil, List.cons, PProd.fst, HAdd.hAdd, OfNat.ofNat],[List]]
[and_congr,[Iff.intro, And.imp, Iff.mp, Iff.mpr],[Iff, And]]
[Lean.PrettyPrinter.Delaborator.delabSigmaCore,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPNotation, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, guard, Eq, BEq.beq, Lean.Expr.getAppNumArgs, OfNat.ofNat, Bool.true, Lean.Expr.isLambda, Lean.Expr.appArg!, Lean.PrettyPrinter.Delaborator.SubExpr.withAppArg, Lean.PrettyPrinter.Delaborator.SubExpr.withBindingDomain, Lean.PrettyPrinter.Delaborator.delab, Lean.PrettyPrinter.Delaborator.withBindingBodyUnusedName, ite, Lean.Expr.hasLooseBVars, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.instToStringNamePart,[ToString.mk, String, ToString.toString],[ToString, Lean.NamePart]]
[Lean.Lsp.SymbolKind.number.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.number, OfNat.ofNat]]
[ReaderT.run_seqLeft,[Eq.mpr, Eq.refl, Eq, ReaderT.run, SeqLeft.seqLeft, seqLeft_eq_bind, rfl],[Eq, ReaderT.run, SeqLeft.seqLeft]]
[String.Pos,[Nat],[]]
[ByteArray.foldlM,[dite, LE.le, ByteArray.size, ByteArray.foldlM.proof_1],[]]
[Lean.Parser.Tactic.substs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Meta.inferTypeImp.infer,[List.cons, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.proj, Lean.Meta.MetaM, Lean.Expr, Bind.bind, Lean.getConstInfo, ite, Eq, BEq.beq, List.length, Lean.ConstantInfo.levelParams, Bool.true, Pure.pure, Lean.ConstantInfo.instantiateTypeLevelParams, Lean.Meta.throwIncorrectNumberOfLevels, List.nil, MonadState.get, Unit.unit, Std.PersistentHashMap.find?, Lean.Meta.Cache.inferType, Lean.Meta.State.cache, Lean.ExprStructEq.mk, or, Lean.Expr.hasMVar, PUnit.unit, Lean.Meta.modifyInferTypeCache, Std.PersistentHashMap.insert, Lean.Meta.inferType, Lean.Meta.whnf, Lean.matchConstStruct, Lean.Expr.getAppFn, bne, Array.size, ForIn.forIn, MProd.mk, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lit, Lean.Expr.mdata, ForInStep, MProd, Nat, ForInStep.yield, Lean.Expr.instantiateBetaRevRange, Lean.Meta.throwFunctionExpected, Lean.mkAppRange, OfNat.ofNat, HAdd.hAdd, Lean.mkConst, Lean.ConstantVal.name, Lean.ConstructorVal.toConstantVal, Lean.Expr.hasLooseBVars, PUnit, Lean.Expr.getAppArgs, Lean.MonadMCtx.getMCtx, Lean.MetavarContext.findDecl?, Lean.MetavarDecl.type, Lean.Meta.throwUnknownMVar, Lean.MonadLCtx.getLCtx, Lean.LocalContext.find?, Lean.LocalDecl.type, Lean.Meta.throwUnknownFVar, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkBVar, PProd.fst, Lean.Literal.type, Lean.mkSort, Lean.mkLevelSucc, Lean.Meta.forallTelescope, Lean.Meta.getLevel, Array.foldrM, Lean.mkLevelIMax', Lean.Level.normalize, Lean.Meta.lambdaLetTelescope, Lean.Meta.mkForallFVars, Bool.false],[Lean.Meta.MetaM, Lean.Expr]]
[Equiv.symm_comp_self,[funext, Equiv.symm_apply_apply],[Eq, Function.comp, Equiv.toFun, Equiv.symm, id]]
[Lean.Syntax.identComponents.nameComps,[Option.none, List, Lean.Name, List.cons, List.drop, Lean.Name.components],[List, Lean.Name]]
[Lean.IR.UnreachableBranches.InterpState.assignments,[],[Array, Lean.IR.UnreachableBranches.Assignment]]
[Lean.PrettyPrinter.Parenthesizer.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PrettyPrinter.Parenthesizer.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Std.RBTree.forM,[Std.RBTree.foldM, PUnit.unit],[PUnit]]
[Lean.Xml.Parser.AttDef,[SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Xml.Parser.Name, Lean.Xml.Parser.AttType, Lean.Xml.Parser.DefaultDecl],[Lean.Parsec, Unit]]
[Lean.Server.Watchdog.GroupedEdits.queuedMsgs,[],[Array, Lean.JsonRpc.Message]]
[Fin.instXorFin,[Xor.mk, Fin.xor],[Xor, Fin]]
[String.Iterator.s,[],[String]]
[Lean.Parser.Command.ctor.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declModifiers.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.inferMod.formatter, Lean.Parser.Command.optDeclSig.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Attribute.kind,[],[Lean.AttributeKind]]
[Lean.Occurrences.pos.inj,[],[Eq]]
[Lean.ClassEntry.noConfusionType,[],[]]
[IO.FS.instReprFileType,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone],[Repr, IO.FS.FileType]]
[Lean.instToJsonFilePath,[Lean.ToJson.mk, Lean.Json.str, System.FilePath.toString],[Lean.ToJson, System.FilePath]]
[Lean.IR.ExpandResetReuse.Context.mk.inj,[],[Eq]]
[Int.decEq.proof_5,[],[Int.noConfusionType, False, Int.ofNat, Int.negSucc]]
[Lean.IR.ExplicitBoxing.M,[ReaderT, Lean.IR.ExplicitBoxing.BoxingContext, StateT, Lean.IR.ExplicitBoxing.BoxingState, Id],[]]
[Lean.Server.RequestContext.hLog,[],[IO.FS.Stream]]
[List.mem_map,[Unit.unit, Iff, Mem.mem, List.map, Exists, And, Eq, of_eq_true, Eq.trans, congr, congrArg, List.map_nil, propext, List.mem_nil_iff, funext, congrFun, false_and, eq_false, exists_false, eq_true_of_decide, Eq.refl, Bool.true, Eq.mpr, List.cons, List.map_cons, List.mem_cons, Or, PProd.fst, Iff.intro, Exists.intro, And.intro, Or.inl, rfl, Or.inr, Eq.symm, eq_of_heq, HEq.refl],[Iff, Mem.mem, List.map, Exists, And, Eq]]
[Int.fdiv,[Int.ofNat, Int.negSucc, Nat.succ, Int, OfNat.ofNat, HDiv.hDiv],[Int]]
[Lean.Parser.Attr.mkIff,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.MetavarContext.LevelMVarToParam.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MetavarContext.LevelMVarToParam.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.FileWorker.CancelToken.ref,[],[IO.Ref, Bool]]
[Lean.Elab.DefViewElabHeader.ref,[],[Lean.Syntax]]
[Equiv.coe_fn_mk,[rfl],[Eq, Equiv.toFun, Equiv.mk]]
[Lean.Meta.CasesSubgoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.CasesSubgoal.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Match.Extension.State.mk.inj,[],[Eq]]
[Squash.mk,[Quot.mk, True],[Squash]]
[Lean.Elab.Command.mkDefViewOfTheorem,[Lean.Elab.DefView, Lean.Elab.DefView.mk, Lean.Elab.DefKind.theorem, Lean.Syntax.getOp, OfNat.ofNat, Option.some],[Lean.Elab.DefView]]
[Lean.Parser.Level.addLit.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.numLit.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Json.CompressWorkItem.arrayElem.injEq,[Eq.propIntro, Eq.refl, Lean.Json.CompressWorkItem.arrayElem, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Json.CompressWorkItem.arrayElem]]
[Lean.instToJsonJson,[Lean.ToJson.mk, id],[Lean.ToJson, Lean.Json]]
[Lean.Meta.Cache.synthInstance,[],[Lean.Meta.SynthInstanceCache]]
[Lean.JsonRpc.ErrorCode.requestCancelled.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.JsonRpc.ErrorCode.requestCancelled, OfNat.ofNat]]
[Lean.Meta.PostponedEntry.lhs,[],[Lean.Level]]
[Lean.Meta.SynthInstance.getTop,[Bind.bind, MonadState.get, Pure.pure, Array.back, Lean.Meta.SynthInstance.State.generatorStack],[Lean.Meta.SynthInstance.SynthM, Lean.Meta.SynthInstance.GeneratorNode]]
[ulift.up.inj,[],[Eq]]
[Std.HashMapImp.erase,[Std.HashMapImp, ite, Eq, Std.AssocList.contains, Bool.true, Std.HashMapImp.mk, HSub.hSub, OfNat.ofNat, Std.HashMapBucket.update, Std.AssocList.erase],[Std.HashMapImp]]
[Lean.Elab.Term.PatternVar.localVar.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.PatternVar.localVar, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.PatternVar.localVar]]
[Lean.Expr.isStringLit,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.natVal, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Elab.Term.SyntheticMVarKind.tactic.inj,[And.intro],[And, Eq]]
[Lean.Server.MonadRpcSession.rpcReleaseRef,[],[Bool]]
[Lean.IR.mkRet,[Lean.IR.FnBody.ret],[Lean.IR.FnBody]]
[Lean.Lsp.DocumentSymbolAux.name,[],[String]]
[Lean.Compiler.SpecState.switch,[Lean.Compiler.SpecState, Lean.Compiler.SpecState.mk, Lean.SMap.switch],[Lean.Compiler.SpecState]]
[Lean.PrettyPrinter.Formatter.withPosition.formatter,[],[Lean.PrettyPrinter.Formatter]]
[Lean.Name.append,[Lean.Name, Lean.Name.mkStr, PProd.fst, Lean.Name.mkNum],[Lean.Name]]
[Nat.lt_succ_of_le,[Nat.succ_le_succ],[LT.lt, Nat.succ]]
[Lean.Elab.Term.CollectPatternVars.Context.funId,[],[Lean.Syntax]]
[Lean.getPPAnalyzeTrustOfNat,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.trustOfNat, Lean.Option.defValue],[Bool]]
[Lean.Elab.ContextInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.ContextInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.ContextInfo.mk, And]]
[implies_congr_ctx,[propext, Iff.intro],[Eq]]
[Lean.Parsec.many1Chars,[Bind.bind, Lean.Parsec.manyCharsCore, Char.toString],[Lean.Parsec, String]]
[Lean.Parser.Term.noImplicitLambda,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[StateRefT'.instMonadStateOfStateRefT',[MonadStateOf.mk, StateRefT'.get, StateRefT'.set, StateRefT'.modifyGet],[MonadStateOf, StateRefT']]
[decidableLt_of_decidableLe,[Decidable, LT.lt, dite, LE.le, Decidable.isFalse, decidableLt_of_decidableLe.proof_1, Decidable.isTrue, lt_of_le_not_le, decidableLt_of_decidableLe.proof_2],[DecidableRel, LT.lt]]
[Lean.Parser.Term.doReassign.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.notFollowedByRedefinedTermToken.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.letIdDeclNoBinders.parenthesizer, Lean.Parser.Term.letPatDecl.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[List.partitionAux,[Prod, List, Prod.mk, List.reverse, Unit.unit, PProd.fst, List.cons],[Prod, List]]
[Lean.Elab.Term.Do.ToTerm.Kind.forInWithReturn.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.ToTerm.Kind.forInWithReturn, OfNat.ofNat]]
[Function.injective2.eq_iff,[Iff.intro, Eq, congr_arg2],[Iff, Eq, And]]
[Int.instAddInt,[Add.mk, Int.add],[Add, Int]]
[IsMulLeftCancel.mul_left_cancel,[],[Eq]]
[Lean.Meta.SynthInstance.ConsumerNode.noConfusionType,[],[]]
[Lean.Export.Entry.level.injEq,[Eq.propIntro, Eq.refl, Lean.Export.Entry.level, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Export.Entry.level]]
[Lean.Expr.instBEqExpr,[BEq.mk, Lean.Expr.eqv],[BEq, Lean.Expr]]
[Lean.IR.CtorFieldInfo.scalar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.CtorFieldInfo.scalar, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.Watchdog.WorkerEvent.crashed.inj,[],[Eq]]
[Lean.Lsp.Hover.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.Hover.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.Hover.mk, And]]
[Or.neg_resolve_left,[Or.elim, absurd, id],[]]
[not_iff_not,[Decidable.not_iff_not],[Iff, Not]]
[IO.Process.Output.stderr,[],[String]]
[Or.imp,[Or.elim, Function.comp, Or.inl, Or.inr],[Or]]
[Lean.Server.Watchdog.WorkerEvent.crashed.injEq,[Eq.propIntro, Eq.refl, Lean.Server.Watchdog.WorkerEvent.crashed, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.Watchdog.WorkerEvent.crashed]]
[Lean.PrettyPrinter.Delaborator.Context.inPattern,[],[Bool]]
[USize.land,[USize.mk, Fin.land, USize.val],[USize]]
[ST.Ref.modifyGet,[liftM, ST.Prim.Ref.modifyGet],[]]
[instDecidableEqChar,[Decidable, Eq, decEq, Char.val, Decidable.isTrue, Char.eq_of_val_eq, Decidable.isFalse, Char.ne_of_val_ne],[DecidableEq, Char]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.f,[],[Lean.Expr]]
[Lean.ScopedEnvExtension.Entry.scoped.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ScopedEnvExtension.Entry.scoped, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.isDefEqNat,[ite, Eq, or, Lean.Expr.hasFVar, Lean.Expr.hasMVar, Bool.true, Pure.pure, Lean.LBool.undef, Bind.bind, Lean.Meta.reduceNat?, Unit.unit, Lean.Meta.MetaM, Lean.LBool],[Lean.Meta.MetaM, Lean.LBool]]
[instXorUInt16,[Xor.mk, UInt16.xor],[Xor, UInt16]]
[Lean.Parser.Term.doFinally,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.doSeq],[Lean.Parser.Parser]]
[Array.swapAt,[Prod.mk],[Prod, Array]]
[Lean.Parser.Tactic.tacticSeq1Indented,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.many1Indent, Lean.Parser.group, HAndThen.hAndThen, Lean.Parser.ppLine, Lean.Parser.tacticParser, Lean.Parser.optional, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Std.PShareCommonT.withShareCommon,[MonadState.modifyGet, Std.ShareCommon.PersistentState.shareCommon],[Std.PShareCommonT]]
[Lean.Meta.SynthInstance.MkTableKey.M,[ReaderT, Lean.MetavarContext, StateM, Lean.Meta.SynthInstance.MkTableKey.State],[]]
[Lean.Level.instToFormatLevel,[Std.ToFormat.mk, Lean.Level.format],[Std.ToFormat, Lean.Level]]
[Lean.Level.Data.hash,[UInt32.toUInt64, UInt64.toUInt32],[UInt64]]
[Attr.simps,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.IR.mkUnreachable,[Lean.IR.FnBody.unreachable],[Lean.IR.FnBody]]
[Lean.mkAnnotation,[Lean.mkMData, Lean.KVMap.insert, Lean.KVMap.empty, Lean.DataValue.ofBool, Bool.true],[Lean.Expr]]
[Lean.Meta.Closure.State.newLetDecls,[],[Array, Lean.LocalDecl]]
[Lean.EnvironmentHeader.imports,[],[Array, Lean.Import]]
[gt_of_ge_of_gt,[lt_of_lt_of_le],[GT.gt]]
[Array.shrink.loop,[Array, PProd.fst, Array.pop],[Array]]
[mul_left_comm,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Eq.symm, mul_assoc, mul_comm, rfl],[Eq, HMul.hMul]]
[Lean.PersistentEnvExtension.addImportedFn,[],[Lean.ImportM]]
[Lean.Elab.Tactic.elabSimpConfigCtxCore,[ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, Lean.Meta.Simp.ConfigCtx.mk, Lean.Meta.Simp.Config.mk, Lean.withoutModifyingState, Lean.Meta.withLCtx, Lean.LocalContext.mk, EmptyCollection.emptyCollection, Lean.Elab.Term.withSynthesize, Bind.bind, Lean.Elab.Term.elabTermEnsuringType, Lean.Syntax.getOp, OfNat.ofNat, Option.some, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Option.none, liftM, Lean.Meta.instantiateMVars, Bool.false],[Lean.Elab.Term.TermElabM, Lean.Meta.Simp.ConfigCtx]]
[Lean.Elab.Term.LetRecDeclView.valStx,[],[Lean.Syntax]]
[instMonadControlExceptT,[MonadControl.mk, Except, liftM, ExceptT.run],[MonadControl, ExceptT]]
[Lean.MessageLog.msgs,[],[Std.PersistentArray, Lean.Message]]
[withPtrAddrUnsafe,[ptrAddrUnsafe],[]]
[Lean.Server.FileWorker.WorkerState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.FileWorker.WorkerState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.FileWorker.WorkerState.mk, And]]
[Std.HashMapImp.findEntry?.proof_1,[Subtype.property],[GT.gt, Array.size, Subtype.val, OfNat.ofNat]]
[MonadControlT.restoreM,[],[]]
[Mathlib.ExtendedBinder.«term∃___,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[MonadState.modifyGet,[],[]]
[Lean.Parser.ident.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.identKind, Bool.true, Lean.PrettyPrinter.Formatter.identNoAntiquot.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.mkLambdaEx,[Lean.mkLambda],[Lean.Expr]]
[not_and_of_not_or_not,[False, Or.elim, absurd],[Not, And]]
[Prod.map_map,[of_eq_true, Eq.trans, congr, congrArg, Eq, Prod.map, prod_map, Prod.mk, Prod.fst, Prod.snd, Function.comp, Function.comp_apply, eq_self],[Eq, Prod.map, Function.comp]]
[Lean.ResolveName.resolveGlobalName,[Lean.MacroScopesView.name, List.nil, Lean.ResolveName.resolveGlobalName.loop],[List, Prod, Lean.Name, String]]
[ExceptCpsT.run,[Except, Pure.pure, Except.ok, Except.error],[Except]]
[Lean.IR.instInhabitedIRType,[Inhabited.mk, Lean.IR.IRType.float],[Inhabited, Lean.IR.IRType]]
[Lean.Elab.Term.MutualClosure.LetRecClosure.mk.inj,[And.intro],[And, Eq]]
[withPtrEq,[Unit.unit],[Bool]]
[Lean.Parser.Tactic.choose!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Server.Watchdog.workerCfg,[IO.Process.StdioConfig.mk, IO.Process.Stdio.piped, IO.Process.Stdio.inherit],[IO.Process.StdioConfig]]
[Array.findSomeRevM?.find,[Option, Pure.pure, Option.none],[Option]]
[Lean.Server.FileWorker.EditableDocument.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.FileWorker.EditableDocument.mk, HAdd.hAdd, OfNat.ofNat]]
[Std.RBNode.node.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.RBNode.node, HAdd.hAdd, OfNat.ofNat]]
[Std.PersistentArray.forIn,[Bind.bind, Std.PersistentArray.forInAux, Std.PersistentArray.root, Pure.pure, ForIn.forIn, MProd.mk, Option.none, ForInStep, MProd, Option, ForInStep.done, Option.some, PUnit.unit, ForInStep.yield, Unit.unit, MProd.fst],[]]
[Mathlib.Tactic.Lint.decorateError,[MonadExcept.tryCatch, MonadExcept.throw],[Lean.Meta.MetaM]]
[UInt16.instSemiringUInt16.proof_8,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt16.one_def, UInt16.mul_def, UInt16.mk, OfNat.ofNat, mul_one, UInt16.val, UInt16.mk_val_eq, eq_self, propext, forall_const, UInt16],[Eq, HMul.hMul, OfNat.ofNat]]
[Int.decEq,[Decidable, Eq, Int.ofNat, decEq, Decidable.isTrue, Int.decEq.proof_1, Decidable.isFalse, Int.decEq.proof_2, Int.negSucc, Int.decEq.proof_3, Int.decEq.proof_4, Int.decEq.proof_5, Int.decEq.proof_6],[Decidable, Eq]]
[Lean.instInhabitedNameTrie,[Inhabited.mk, Lean.NameTrie.empty],[Inhabited, Lean.NameTrie]]
[Lean.Parser.Command.inferMod,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.atomic, HAndThen.hAndThen, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.IR.Borrow.BorrowInfState.noConfusionType,[],[]]
[Nat.add_mod_right,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, Nat.mod_eq_sub_mod, Nat.le_add_left, HSub.hSub, Nat.add_sub_cancel, rfl],[Eq, HMod.hMod, HAdd.hAdd]]
[Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter,[modify, Lean.PrettyPrinter.Formatter.State.mk, Lean.PrettyPrinter.Formatter.State.stxTrav, Lean.PrettyPrinter.Formatter.State.stack],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.toParserDescr.processNonReserved,[Unit.unit, Lean.Elab.Term.ToParserDescrM, Lean.Syntax, Lean.Syntax.isStrLit?, Lean.Syntax.getOp, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Quote.quote, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.ToParserDescrM, Lean.Syntax]]
[HShiftLeft.noConfusionType,[],[]]
[Lean.Elab.Term.elabNoMatch',[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Array.findIdxM?, Lean.Elab.Term.isAtomicDiscr?, Pure.pure, Option.isNone, Option.none, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, List.nil, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, Lean.Syntax.SepArray.elemsAndSeps, Lean.Syntax.SepArray.ofElems, Lean.Elab.Term.elabTerm, PUnit.unit, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElab]]
[Lean.IR.FreeIndices.instAndThenCollector,[AndThen.mk, Unit.unit],[AndThen, Lean.IR.FreeIndices.Collector]]
[Lean.EnvExtensionInterfaceUnsafe.mkInitialExtStates,[Bind.bind, ST.Ref.get, Array.mapM, Lean.EnvExtensionInterfaceUnsafe.Ext.mkInitial],[IO, Array, Lean.EnvExtensionState]]
[Lean.Parser.Tactic.Conv.first,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[Subtype.mk.injEq,[Eq.propIntro, Eq.refl, Subtype.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Subtype.mk]]
[Lean.ClosedTermCache.constNames,[],[Lean.NameSet]]
[Lean.Expr.lit.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.lit, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Expr.lit, And]]
[Lean.Elab.Term.Do.Code.ite.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Code.ite, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Do.Code.ite, And]]
[IO.Process.Stdio.noConfusion,[noConfusionEnum, IO.Process.Stdio.toCtorIdx],[IO.Process.Stdio.noConfusionType]]
[Lean.MetavarContext.LevelMVarToParam.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MetavarContext.LevelMVarToParam.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MetavarContext.LevelMVarToParam.State.mk, And]]
[Lean.Elab.Attribute.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Attribute.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Widget.TaggedText.appendText,[Lean.Widget.TaggedText.tag, Lean.Widget.TaggedText, Lean.Widget.TaggedText.text, HAppend.hAppend, Lean.Widget.TaggedText.append, Array.back, Array.set!, HSub.hSub, Array.size, OfNat.ofNat, Array.push, List.toArray, List.cons, List.nil],[Lean.Widget.TaggedText]]
[Lean.Elab.Term.finalizePatternDecls,[Bind.bind, ForIn.forIn, Lean.Elab.Term.TermElabM, ForInStep, Array, Lean.LocalDecl, liftM, Lean.Meta.getLocalDecl, Lean.Meta.instantiateLocalDeclMVars, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Meta.instantiateMVars, Lean.mkMVar, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MVarId.name, Lean.mkFVar, Lean.Meta.sortLocalDecls],[Lean.Elab.Term.TermElabM, Array, Lean.LocalDecl]]
[Lean.Elab.Term.resolveName.process,[ite, Eq, List.isEmpty, Bool.true, Bind.bind, MonadReader.read, and, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.isValidAutoBoundImplicitName, Lean.Elab.throwAutoBoundImplicitLocal, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkConst, List.nil, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElabM, List, Prod, Lean.Expr, String]]
[Lean.Lsp.CompletionItem.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.CompletionItem.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.CompletionItem.mk, And]]
[Lean.Lsp.TextDocumentPositionParams.mk.inj,[And.intro],[And, Eq]]
[ExceptT.adapt,[ExceptT.mk, Functor.map, Except.mapError],[ExceptT]]
[Lean.Meta.IndPredBelow.mkBelowMatcher.newMotive,[Lean.Meta.lambdaTelescope, Lean.Meta.MatcherApp.motive, Bind.bind, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Lean.Expr.replaceFVars, Lean.Meta.withLocalDeclD, Lean.Meta.mkLambdaFVars, HAppend.hAppend, Array.ofSubarray, Array.toSubarray, OfNat.ofNat, List.toArray, List.cons, List.nil, Array.size, Bool.false, Bool.true, Lean.isTracingEnabledFor, ite, Eq, Lean.addTrace, Lean.ToMessageData.toMessageData, PUnit.unit],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.IR.CtorInfo.cidx,[],[Nat]]
[Lean.Server.Completion.State.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.InductionSubgoal.noConfusionType,[],[]]
[Function.left_inverse.id,[funext],[Eq, Function.comp, id]]
[Lean.Elab.Term.synthesizeInstMVarCore,[Bind.bind, Lean.Elab.Term.getMVarDecl, liftM, Lean.Meta.instantiateMVars, Lean.Meta.trySynthInstance, Unit.unit, Lean.Elab.Term.TermElabM, Bool, Lean.Elab.Term.isExprMVarAssigned, ite, Eq, Bool.true, Lean.mkMVar, Lean.Meta.isDefEq, Pure.pure, PUnit.unit, orM, Lean.Elab.Term.containsPendingMVar, Bool.false, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr],[Lean.Elab.Term.TermElabM, Bool]]
[Lean.LocalInstances,[Array, Lean.LocalInstance],[]]
[Lean.Elab.Term.elabExplicitUnivs,[Array.foldrM, Bind.bind, Lean.Elab.Term.elabLevel, Pure.pure, List.cons, List.nil, Array.size, OfNat.ofNat],[Lean.Elab.Term.TermElabM, List, Lean.Level]]
[Lean.Export.Entry.expr.inj,[],[Eq]]
[Lean.Level.hasMVarEx,[Lean.Level.hasMVar],[Bool]]
[IO.Process.Output.noConfusionType,[],[]]
[fix6,[fixCore6, arbitrary],[]]
[Lean.IR.UnreachableBranches.Value.choice.inj,[],[Eq]]
[Bool.toLBool,[Unit.unit, Lean.LBool, Lean.LBool.true, Lean.LBool.false],[Lean.LBool]]
[Lean.Elab.Command.modifyScope,[modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, Unit.unit, List, Lean.Elab.Command.Scope, Lean.Elab.Command.State.scopes, List.cons, panicWithPosWithDecl, OfNat.ofNat, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState],[Lean.Elab.Command.CommandElabM, Unit]]
[Nat.succ.injEq,[Eq.propIntro, Eq.refl, Nat.succ, Eq.symm, eq_of_heq, HEq.refl],[Eq, Nat.succ]]
[Lean.Elab.Command.elabPrintAxioms,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.withRef, Bind.bind, Lean.Elab.resolveGlobalConstWithInfos, Option.none, List.forM, Lean.MonadEnv.getEnv, Lean.Elab.Command.CommandElabM, Unit, Array.isEmpty, Lean.Elab.Command.CollectAxioms.State.axioms, Lean.Elab.logInfo, HAppend.hAppend, Lean.ToMessageData.toMessageData, Array.toList, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[PLift.up_down,[Eq, PLift.up, PLift.down, rfl],[Eq, PLift.up, PLift.down]]
[implies,[],[]]
[EqIffBeqTrue,[Iff.intro, decide_eq_true, of_decide_eq_true],[Iff, Eq, BEq.beq, Bool.true]]
[Lean.Meta.Closure.MkValueTypeClosureResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Closure.MkValueTypeClosureResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Closure.MkValueTypeClosureResult.mk, And]]
[Lean.Elab.Structural.RecArgInfo.reflexive,[],[Bool]]
[DoResultBC.break.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultBC.break, HAdd.hAdd, OfNat.ofNat]]
[Lean.instInhabitedConstantVal,[Inhabited.mk, Lean.ConstantVal.mk, arbitrary],[Inhabited, Lean.ConstantVal]]
[randBool,[Prod, Bool, Prod.mk, Decidable.decide, Eq, OfNat.ofNat],[Prod, Bool]]
[Lean.instMonadRef,[Lean.MonadRef.mk, liftM, Lean.MonadRef.getRef, MonadFunctorT.monadMap, Lean.MonadRef.withRef],[Lean.MonadRef]]
[Lean.Parsec.skipString,[SeqRight.seqRight, Lean.Parsec.pstring, Pure.pure, Unit.unit],[Lean.Parsec, Unit]]
[Lean.Elab.Term.Do.Alt.ref,[],[Lean.Syntax]]
[Lean.getPPAnalyzeTrustId,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.trustId, Lean.Option.defValue],[Bool]]
[Lean.Lsp.PlainGoalParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.PlainGoalParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.TransformStep.noConfusionType,[],[]]
[Lean.Lsp.HoverParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.HoverParams.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Simp.Methods.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Simp.Methods.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Simp.Methods.mk, And]]
[Lean.Server.FileWorker.WorkerContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.FileWorker.WorkerContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.FileWorker.WorkerContext.mk, And]]
[Lean.Parser.Term.termQuoteₓ_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.wfRecursion,[Bind.bind, Lean.withoutModifyingEnv, ForIn.forIn, PUnit.unit, liftM, Lean.Elab.addAsAxiom, Pure.pure, ForInStep.yield, Lean.Elab.WF.packDomain, Lean.Elab.WF.packMutual, Lean.Elab.WF.elabWFRel, Lean.Elab.WF.mkFix, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.PreDefinition.declName],[Lean.Elab.Term.TermElabM, Unit]]
[Std.AssocList.ibelow,[True, And],[]]
[Lean.setTraceState,[Lean.MonadTrace.modifyTraceState],[Unit]]
[Lean.Elab.Term.Quotation.HeadCheck.other.inj,[],[Eq]]
[Function.comp_right,[],[]]
[Lean.Compiler.SpecState.addEntry,[Lean.Compiler.SpecState, Lean.Compiler.SpecState.mk, Lean.SMap.insert, Lean.Compiler.SpecState.specInfo, Lean.Compiler.SpecState.cache],[Lean.Compiler.SpecState]]
[Lean.PPContext.openDecls,[],[List, Lean.OpenDecl]]
[Array.toArrayLit_eq',[Array.toArrayLit_eq'.aux],[Eq, Array.toArrayLit]]
[Lean.Lsp.WorkDoneProgressEnd.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.WorkDoneProgressEnd.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.WorkDoneProgressEnd.mk, And]]
[Function.partial_inv_of_injective,[Iff, Eq, Function.partial_inv, Option.some, Iff.intro],[Function.is_partial_inv, Function.partial_inv]]
[Lean.Xml.Parser.STag,[SeqRight.seqRight, Lean.Parsec.skipChar, Char.ofNat, Pure.pure],[Lean.Parsec, Lean.Xml.Element]]
[Lean.expandExplicitBindersAux.loop,[Unit.unit, Lean.MacroM, Lean.Syntax, Pure.pure, Lean.Syntax.isIdent, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.MacroM, Lean.Syntax]]
[Lean.Elab.Term.elabSetOption,[Bind.bind, Lean.Elab.elabSetOption, Lean.Syntax.getOp, OfNat.ofNat, withTheReader, Lean.Core.Context, Lean.Core.Context.mk, Lean.Core.Context.currRecDepth, Lean.Option.get, Lean.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats, Lean.Elab.Term.elabTerm, Bool.true],[Lean.Elab.Term.TermElab]]
[Lean.LocalDecl.ldecl.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.doElem.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.doElemParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.ModuleData.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ModuleData.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ModuleData.mk, And]]
[ShiftRight.noConfusionType,[],[]]
[Lean.Meta.throwFunctionExpected,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr],[Lean.Meta.MetaM]]
[Lean.IR.IRType.union.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.IRType.union, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.IRType.union, And]]
[Lean.Level.mkData,[ite, GT.gt, HSub.hSub, Nat.pow, OfNat.ofNat, panicWithPosWithDecl],[Lean.Level.Data]]
[Lean.Lsp.ReferenceContext.noConfusionType,[],[]]
[Lean.Parser.Term.letRecDecls.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.Term.letRecDecl.parenthesizer, Lean.Parser.symbol.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.InductiveType.name,[],[Lean.Name]]
[Lean.Parser.Attr.ext,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[IO.Error.protocolError.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.protocolError, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.hexDigitFn,[ite, Eq, String.atEnd, Bool.true, Lean.Parser.ParserState.mkEOIError, List.nil, or, Char.isDigit, and, Decidable.decide, LE.le, Char.ofNat, Lean.Parser.ParserState.setPos, Lean.Parser.ParserState.mkUnexpectedError],[Lean.Parser.ParserFn]]
[Lean.IR.ResetReuse.M,[ReaderT, Lean.IR.LocalContext, StateT, Lean.IR.Index, Id],[]]
[instReprAtomNat,[ReprAtom.mk],[ReprAtom, Nat]]
[Lean.Elab.Term.LVal.noConfusionType,[],[]]
[Lean.Elab.Tactic.SavedState.noConfusionType,[],[]]
[Lean.PrettyPrinter.mkParenthesizerAttribute,[Lean.KeyedDeclsAttribute.init, Lean.KeyedDeclsAttribute.Def.mk, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.MonadEnv.getEnv, Lean.Attribute.Builtin.getId, ite, Eq, or, and, Option.isSome, Lean.Environment.find?, Lean.Parser.isValidSyntaxNodeKind, Bool.true, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[IO, Lean.KeyedDeclsAttribute, Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Info.ofCompletionInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Info.ofCompletionInfo, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Closure.MkValueTypeClosureResult.type,[],[Lean.Expr]]
[Lean.AttributeExtensionOLeanEntry.builder.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.AttributeExtensionOLeanEntry.builder, HAdd.hAdd, OfNat.ofNat]]
[Set.subset,[Mem.mem],[]]
[Lean.Elab.addAuxDeclarationRanges,[Bind.bind, Lean.Elab.getDeclarationRange, Lean.addDeclarationRanges, Lean.DeclarationRanges.mk],[Unit]]
[Lean.Elab.Tactic.rewriteTarget,[Lean.Elab.Term.withSynthesize, Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.elabTerm, Option.none, Bool.true, Lean.Elab.Tactic.getMainGoal, Lean.Elab.Tactic.getMainTarget, liftM, Lean.Meta.rewrite, Lean.Occurrences.all, Lean.Meta.replaceTargetEq, Lean.Meta.RewriteResult.eNew, Lean.Meta.RewriteResult.eqProof, Lean.Elab.Tactic.replaceMainGoal, List.cons, Lean.Meta.RewriteResult.mvarIds, Bool.false],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.Meta.mkExpectedTypeHint,[Bind.bind, Lean.Meta.getLevel, Pure.pure, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[instDecidableEqQuotient,[Quotient.recOnSubsingleton₂, Decidable, Eq, Quotient.mk, Decidable.isTrue, Quotient.sound, Decidable.isFalse, instDecidableEqQuotient.proof_2],[DecidableEq, Quotient]]
[Lean.PrettyPrinter.Parenthesizer.rawCh.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Term.SavedState.restore,[Bind.bind, Lean.MonadTrace.getTraceState, MonadState.get, liftM, Lean.Meta.SavedState.restore, Lean.Elab.Term.SavedState.meta, MonadStateOf.set, Lean.Elab.Term.SavedState.elab, Lean.setTraceState, ite, Eq, Bool.true, Pure.pure, PUnit.unit, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift],[Lean.Elab.Term.TermElabM, Unit]]
[instInhabitedUInt8,[Inhabited.mk, UInt8.ofNatCore, OfNat.ofNat, instInhabitedUInt8.proof_1],[Inhabited, UInt8]]
[Tactic.Ring.Cache.noConfusionType,[],[]]
[Lean.Meta.mapMetaM,[controlAt, Lean.Meta.MetaM, MonadControlT.stM],[]]
[Lean.Elab.Term.tryPostpone,[Bind.bind, MonadReader.read, ite, Eq, Lean.Elab.Term.Context.mayPostpone, Bool.true, Lean.Elab.throwPostpone, Pure.pure, PUnit.unit],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Parser.runParserCategory,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Except.error, Lean.Parser.ParserState.toErrorMsg, String.atEnd, Lean.Parser.ParserState.pos, Except.ok, Array.back, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.mkError],[Except, String, Lean.Syntax]]
[Lean.Parser.Term.type.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkWsBefore.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer, Lean.Parser.levelParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.dvd_of_mod_eq_zero,[Exists.intro, HDiv.hDiv],[Dvd.dvd]]
[Lean.Lsp.TextDocumentSyncKind.full.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.TextDocumentSyncKind.full, OfNat.ofNat]]
[Lean.Parser.Term.Command.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.commandParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.instToJsonTextDocumentEdit,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentEdit.textDocument, List.nil, Lean.Lsp.TextDocumentEdit.edits],[Lean.ToJson, Lean.Lsp.TextDocumentEdit]]
[List.join_cons,[rfl],[Eq, List.join, List.cons, HAppend.hAppend]]
[Lean.Parser.Term.waitIfTypeContainsMVar,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.termParser],[Lean.Parser.Parser]]
[instHashableProd,[Hashable.mk, UInt64, mixHash, Hashable.hash],[Hashable, Prod]]
[Lean.Syntax.prettyPrint,[Unit.unit, Std.Format, Lean.Syntax.reprint, Lean.Syntax.unsetTrailing, Std.ToFormat.format, String.toFormat],[Std.Format]]
[List.forall_mem_append,[Eq.mpr, congrFun, congrArg, Iff, Eq.trans, forall_congr, implies_congr, propext, List.mem_append, Eq.refl, or_imp_distrib, forall_and_distrib, And, Iff.rfl],[Iff, And]]
[Std.PersistentArrayNode.ibelow,[And, True],[]]
[WellFoundedRelation.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, WellFoundedRelation.mk, HAdd.hAdd, OfNat.ofNat]]
[List.toArray_data,[List.toArrayAux_data, Array.mkEmpty, List.redLength],[Eq, Array.data, List.toArray]]
[Lean.Parser.Term.prio.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.priorityParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.BinderInfo.implicit.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.BinderInfo.implicit, OfNat.ofNat]]
[Lean.Meta.appendTag,[Lean.Name.modifyBase, HAppend.hAppend, Lean.Name.eraseMacroScopes],[Lean.Name]]
[Lean.Elab.Structural.RecArgInfo.indLevels,[],[List, Lean.Level]]
[Lean.Parser.ModuleParserState.mk.inj,[And.intro],[And, Eq]]
[instHPow,[HPow.mk, Pow.pow],[HPow]]
[Lean.Lsp.Location.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.Location.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.ExprStructEq.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ExprStructEq.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.elseIf.formatter,[Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.group.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.checkLineEq.formatter],[Lean.PrettyPrinter.Formatter]]
[Tactic.Ring.Cache.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Tactic.Ring.Cache.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.withoutMacroStackAtErr,[withTheReader, Lean.Core.Context, Lean.Core.Context.mk, Lean.Option.set, Lean.Core.Context.options, Lean.Elab.pp.macroStack, Bool.false, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats],[Lean.Elab.Term.TermElabM]]
[Lean.HeadIndex.instHashableHeadIndex,[Hashable.mk, Lean.HeadIndex.HeadIndex.hash],[Hashable, Lean.HeadIndex]]
[Lean.Syntax.isScientificLit?,[Option.none, Option, Prod, Nat, Bool, Lean.Syntax.isLit?, Lean.scientificLitKind, Lean.Syntax.decodeScientificLitVal?],[Option, Prod, Nat, Bool]]
[Lean.Elab.Term.StructInst.FieldLHS.fieldName.inj,[And.intro],[And, Eq]]
[Lean.Expr.not?,[Lean.Expr.app1?, Lean.Name.mkStr, Lean.Name.anonymous],[Option, Lean.Expr]]
[Lean.Elab.instInhabitedVisibility,[Inhabited.mk, Lean.Elab.Visibility.regular],[Inhabited, Lean.Elab.Visibility]]
[Lean.Elab.Term.LValResolution.localRec.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.LValResolution.localRec, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Match.AltLHS.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.AltLHS.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.AltLHS.mk, And]]
[Lean.Lsp.instFileSourceSemanticTokensRangeParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.SemanticTokensRangeParams.textDocument],[Lean.Lsp.FileSource, Lean.Lsp.SemanticTokensRangeParams]]
[HasEquiv.noConfusionType,[],[]]
[Lean.Expr.updateLambdaE!.proof_1,[rfl],[Eq, Lean.Expr.isLambda, Lean.Expr.lam]]
[Lean.Parser.Tactic.ringMode,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Meta.CongrTheorem.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.have'',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Elab.Term.StructInst.Fields,[List, Lean.Elab.Term.StructInst.Field, Lean.Elab.Term.StructInst.Struct],[]]
[Lean.Elab.Term.Do.Code.seq.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.Code.seq, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.ParserContext.quotDepth,[],[Nat]]
[Lean.Meta.mkInjectiveTheorems,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, Lean.Meta.isInductivePredicate, ite, Eq, and, Lean.Environment.contains, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Option.get, Lean.Meta.genInjectivity, not, Bool.true, Lean.getConstInfoInduct, Lean.InductiveVal.isUnsafe, Pure.pure, PUnit.unit, ForIn.forIn, Lean.getConstInfoCtor, GT.gt, Lean.ConstructorVal.numFields, OfNat.ofNat, liftM, Lean.Meta.elimOptParam, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, Lean.Meta.forallBoundedTelescope, Option.some, Lean.ConstructorVal.numParams, Lean.Meta.forallTelescope, List.toArray, List.nil, Lean.Meta.withNewBinderInfos, Array.map, Prod.mk, Lean.Expr.fvarId!, Lean.BinderInfo.implicit, Bool.false, Option.none, Lean.Meta.MetaM, Unit, Lean.Meta.forallTelescopeReducing, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.injection, Unit.unit, panicWithPosWithDecl, Lean.Meta.splitAnd, List.forM, Lean.Meta.assumptionCore, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.ofGoal, Lean.Expr.mvarId!, Array.back, Lean.Meta.mkLambdaFVars, Lean.ConstantVal.name, Lean.Meta.instantiateMVars, Lean.addDecl, Lean.Declaration.thmDecl, Lean.TheoremVal.mk, Lean.ConstantVal.mk, Lean.Meta.mkInjectiveTheoremNameFor, Lean.ConstantVal.levelParams, Lean.Meta.apply, Lean.mkConst, List.cons, Lean.Expr, Lean.Meta.intro1, Lean.Meta.casesAnd, Lean.Meta.substEqs, Lean.Meta.applyRefl, Lean.Meta.addSimpLemma, Lean.Meta.simpExtension, Lean.AttributeKind.global, ForInStep.yield],[Lean.Meta.MetaM, Unit]]
[Lean.KernelException.letTypeMismatch.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.letTypeMismatch, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KernelException.letTypeMismatch, And]]
[Lean.Meta.ToHide.hasVisibleDep,[Bind.bind, MonadState.get, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.findLocalDeclDependsOn, not, Std.RBTree.contains, Lean.Meta.ToHide.State.hiddenInaccessible],[Lean.Meta.ToHide.M, Bool]]
[Lean.Parser.Module.module.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Module.header.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.commandParser.parenthesizer, Lean.Parser.ppLine.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Syntax.isIdent,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Bool, Bool.true, Bool.false],[Bool]]
[IO.FS.Stream.writeResponse,[IO.FS.Stream.writeMessage, Lean.JsonRpc.Message.response, Lean.JsonRpc.Response.id, Lean.ToJson.toJson, Lean.JsonRpc.Response.result],[IO, Unit]]
[Lean.Elab.Term.mkMatcher,[liftM, Lean.Meta.Match.mkMatcher],[Lean.Elab.Term.TermElabM, Lean.Meta.Match.MatcherResult]]
[Lean.Elab.Term.StructInst.Field.ref,[],[Lean.Syntax]]
[Lean.instBEqDefinitionSafety,[BEq.mk, BEq.beq, Lean.DefinitionSafety.toCtorIdx],[BEq, Lean.DefinitionSafety]]
[Std.ShareCommon.State.inhabited,[Inhabited.mk, Std.ShareCommon.State.empty],[Inhabited, Std.ShareCommon.State]]
[IO.FS.Metadata.mk.inj,[And.intro],[And, Eq]]
[Subrelation.wf.proof_1,[WellFounded.intro, Subrelation.accessible, WellFounded.apply],[WellFounded]]
[Std.HashSetImp.insert,[Std.HashSetImp, ite, Eq, List.contains, Bool.true, Std.HashSetImp.mk, Std.HashSetBucket.update, List.replace, LE.le, Array.size, Subtype.val, Std.HashSetImp.expand],[Std.HashSetImp]]
[Nat.add_mul_div_left,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HAdd.hAdd, HMul.hMul, Nat.zero, Nat.mul_zero, OfNat.ofNat, Nat.add_zero, rfl, Nat.succ, Nat.mul_succ, Eq.symm, Nat.add_assoc, Nat.add_div_right],[Eq, HDiv.hDiv, HAdd.hAdd, HMul.hMul]]
[Lean.Rat.mul,[HMul.hMul, HDiv.hDiv, Lean.Rat.num, Int.ofNat, Lean.Rat.den],[Lean.Rat]]
[LawfulFunctor.noConfusionType,[],[]]
[Lean.Parser.Tactic.extractGoal,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Array.zip,[Array.zipWith, Prod.mk],[Array, Prod]]
[Lean.Syntax.getTrailingSize,[Option.none, Option.some, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Nat, Lean.Syntax.getTailInfo?, Substring.bsize, OfNat.ofNat],[Nat]]
[Lean.Meta.NormNum.instLawfulOfNatNat.proof_1,[Lean.Meta.NormNum.LawfulOfNat.mk, rfl],[Lean.Meta.NormNum.LawfulOfNat, Nat]]
[instZero,[Zero.mk, OfNat.ofNat],[Zero]]
[Lean.DelayedMetavarAssignment.val,[],[Lean.Expr]]
[commutative,[Eq],[]]
[pow_zero,[Monoid.npow_zero'],[Eq, HPow.hPow, OfNat.ofNat]]
[Lean.Elab.Term.State.syntheticMVars,[],[List, Lean.Elab.Term.SyntheticMVarDecl]]
[Nat.lt_irrefl,[Nat.not_succ_le_self],[Not, LT.lt]]
[ByteArray.append,[ByteArray.copySlice, OfNat.ofNat, ByteArray.size, Bool.false],[ByteArray]]
[instReprAtomUInt16,[ReprAtom.mk],[ReprAtom, UInt16]]
[Semiring.npow_zero',[],[Eq, Semiring.npow, OfNat.ofNat]]
[Lean.Elab.Term.MVarErrorInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.MVarErrorInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.MVarErrorInfo.mk, And]]
[«term_⊕_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Elab.Command.StructView.allUserLevelNames,[],[List, Lean.Name]]
[Lean.Parser.Tactic.tacticTry_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Parser.longestMatchMkResult,[ite, Eq, and, not, Lean.Parser.ParserState.hasError, Decidable.decide, GT.gt, Lean.Parser.ParserState.stackSize, HAdd.hAdd, OfNat.ofNat, Bool.true, Lean.Parser.ParserState.mkNode, Lean.choiceKind],[Lean.Parser.ParserState]]
[Lean.Lsp.Ipc.writeRequest,[Bind.bind, Lean.Lsp.Ipc.stdin, liftM, IO.FS.Stream.writeLspRequest],[Lean.Lsp.Ipc.IpcM, Unit]]
[Int.add_assoc_aux1,[Eq, HAdd.hAdd, Int.ofNat, of_eq_true, Eq.trans, congr, congrArg, congrFun, Int.ofNat_add_ofNat, Nat.add_assoc, eq_self, Int.negSucc, Int.ofNat_add_negSucc_ofNat, Int.subNatNat_add, Nat.succ, Int.subNatNat],[Eq, HAdd.hAdd, Int.ofNat]]
[instToStringSubarray,[ToString.mk, ToString.toString, Subarray.toArray],[ToString, Subarray]]
[Nat.not_succ_le_self,[Unit.unit, Not, LE.le, Nat.succ, Nat.not_succ_le_zero, OfNat.ofNat, absurd, Nat.le_of_succ_le_succ, PProd.fst],[Not, LE.le, Nat.succ]]
[Nat.one_pos,[Nat.zero_lt_one],[LT.lt, OfNat.ofNat]]
[Nat.eq_of_mul_eq_mul_right,[Nat.eq_of_mul_eq_mul_left, Eq.mp, Eq.refl, Eq, HMul.hMul, Nat.mul_comm],[Eq]]
[Lean.PrefixTreeNode.Node.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.refl, Std.RBNode.leaf, Eq.trans, congr, congrFun, Eq.symm, Std.RBNode.node.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.PrefixTreeNode.Node, HAdd.hAdd, OfNat.ofNat]]
[Std.RBMap.find!,[Unit.unit, Std.RBMap.find?, panicWithPosWithDecl, OfNat.ofNat],[]]
[Lean.Elab.Term.MVarErrorInfo.noConfusionType,[],[]]
[Lean.Meta.Simp.throwCongrHypothesisFailed,[MonadExcept.throw, Lean.Exception.internal, Lean.Meta.Simp.congrHypothesisExceptionId, Lean.KVMap.mk],[Lean.Meta.MetaM]]
[Lean.IR.VarIdSet,[Std.RBTree, Lean.IR.VarId, Ord.compare, Lean.IR.VarId.idx],[]]
[Lean.Meta.NormNum.isNat_pow,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, OfNat.ofNat, Lean.Meta.NormNum.isNat, HPow.hPow, ofNat_pow],[Lean.Meta.NormNum.isNat, HPow.hPow]]
[Lean.Json.obj.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.refl, SizeOf.sizeOf, Std.RBNode.leaf, Eq.trans, congr, congrFun, HAdd.hAdd, Eq.symm, Std.RBNode.node.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Json.obj, HAdd.hAdd, OfNat.ofNat]]
[List.nil_bind,[of_eq_true, eq_self, List.nil],[Eq, List.bind, List.nil]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[ByteSlice.instForInByteSliceUInt8,[ForIn.mk, ByteSlice.forIn.loop, HAdd.hAdd],[ForIn, ByteSlice, UInt8]]
[EStateM.nonBacktrackable,[EStateM.Backtrackable.mk, EStateM.dummySave, EStateM.dummyRestore],[EStateM.Backtrackable, PUnit]]
[Lean.TagAttribute.hasTag,[Unit.unit, Bool, Lean.Environment.getModuleIdxFor?, Array.binSearchContains, Lean.PersistentEnvExtension.getModuleEntries, Lean.TagAttribute.ext, Lean.Name.quickLt, OfNat.ofNat, HSub.hSub, Array.size, Lean.NameSet.contains, Lean.PersistentEnvExtension.getState],[Bool]]
[Lean.mkBRecOnName,[Lean.Name.mkStr, Lean.brecOnSuffix],[Lean.Name]]
[Lean.Meta.IndPredBelow.instInhabitedVariables,[Inhabited.mk, Lean.Meta.IndPredBelow.Variables.mk, arbitrary],[Inhabited, Lean.Meta.IndPredBelow.Variables]]
[UInt32.decEq.proof_2,[absurd],[False]]
[Lean.Parser.Term.prec.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.precedenceParser],[Lean.Parser.Parser]]
[Lean.Expr.FindImpl.State.mk.inj,[],[Eq]]
[Lean.LocalContext.numIndices,[Std.PersistentArray.size, Lean.LocalContext.decls],[Nat]]
[Lean.Parser.Attr.instance,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.priorityParser],[Lean.Parser.Parser]]
[Lean.Parser.Attr.reassoc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Elab.Term.Do.ToTerm.actionTerminalToTerm,[Lean.withRef, Lean.MonadQuotation.withFreshMacroScope, Bind.bind, MonadReader.read, Lean.Elab.Term.Do.ToTerm.mkUVarTuple, Unit.unit, Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax, Lean.Elab.Term.Do.ToTerm.Context.kind, ite, Eq, Array.isEmpty, Lean.Elab.Term.Do.ToTerm.Context.uvars, Bool.true, Pure.pure, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom, panicWithPosWithDecl, OfNat.ofNat],[Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax]]
[Lean.Lsp.CompletionList.noConfusionType,[],[]]
[Lean.MessageData.joinSep,[List.cons, Lean.MessageData, Lean.MessageData.ofFormat, Std.Format.nil, HAppend.hAppend, PProd.fst],[Lean.MessageData]]
[Lean.Meta.Closure.mkForall,[Lean.Meta.Closure.mkBinding, Bool.false],[Lean.Expr]]
[Lean.Elab.instInhabitedElabInfo,[Inhabited.mk, Lean.Elab.ElabInfo.mk, arbitrary],[Inhabited, Lean.Elab.ElabInfo]]
[AddGroup.toSubNegMonoid,[],[SubNegMonoid]]
[Lean.Meta.Simp.instInhabitedResult,[Inhabited.mk, Lean.Meta.Simp.Result.mk, arbitrary],[Inhabited, Lean.Meta.Simp.Result]]
[PSigma.revLex,[PSigma.revLex.proof_1],[WellFounded, PSigma.RevLex]]
[Lean.addTrace.addTraceOptions,[Lean.MessageData.ofFormat, Lean.MessageData.ofSyntax, Lean.MessageData.ofExpr, Lean.MessageData.ofLevel, Lean.MessageData.ofName, Lean.MessageData.ofGoal, Lean.MessageData.withNamingContext, Lean.MessageData.nest, Lean.MessageData.group, Lean.MessageData.compose, Lean.MessageData.tagged, Lean.MessageData.node, Lean.MessageData, Lean.MessageData.withContext, Lean.MessageDataContext.mk, Lean.MessageDataContext.env, Lean.MessageDataContext.mctx, Lean.MessageDataContext.lctx, Lean.KVMap.setBool, Lean.MessageDataContext.opts, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false],[Lean.MessageData]]
[Lean.Elab.Tactic.getGoals,[Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Tactic.State.goals],[Lean.Elab.Tactic.TacticM, List, Lean.MVarId]]
[Lean.FindLevelMVar.Visitor,[Option, Lean.MVarId],[]]
[Std.PersistentArray.Stats.toString,[HAppend.hAppend, ToString.toString, Std.PersistentArray.Stats.numNodes, Std.PersistentArray.Stats.depth, Std.PersistentArray.Stats.tailSize],[String]]
[Int.neg_neg_ofNat_succ,[rfl],[Eq, Neg.neg, Int.negSucc, Int.ofNat, Nat.succ]]
[Lean.Lsp.RpcConnected.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.RpcConnected.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.RpcConnected.mk]]
[UInt16.mul_def,[rfl],[Eq, HMul.hMul, UInt16.mk, UInt16.val]]
[Std.RBMap.forM,[Std.RBMap.foldM, PUnit.unit],[PUnit]]
[Lean.IR.CtorLayout.fieldInfo,[],[List, Lean.IR.CtorFieldInfo]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.instMonadWithReaderOfSubExprAnalyzeM,[MonadWithReaderOf.mk, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.knowsType, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.knowsLevel, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.inBottomUp, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.parentIsApp, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.subExpr],[MonadWithReaderOf, Lean.PrettyPrinter.Delaborator.SubExpr, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM]]
[List.dropWhile,[Unit.unit, List, List.nil, PProd.fst, List.cons],[List]]
[Lean.FindMVar.Visitor,[Option, Lean.MVarId],[]]
[And.congr_right_iff,[Iff.intro, Eq.mp, congr, congrArg, Iff, Eq.trans, congrFun, And, eq_true, true_and, and_congr_right],[Iff, And]]
[Lean.QuotKind.ctor.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.QuotKind.ctor, OfNat.ofNat]]
[instRingFin.proof_4,[of_eq_true, Eq.trans, forall_congr, eq_self, Neg.neg, HMul.hMul, Fin.ofNat', Nat.succ, Fin.size_positive, propext, forall_const, Fin, Nat],[Eq, Neg.neg, HMul.hMul, Fin.ofNat', Nat.succ, Fin.size_positive]]
[Lean.Lsp.TypeDefinitionParams.noConfusionType,[],[]]
[Array.findSomeRevM?.find.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self],[LE.le, Array.size]]
[min_eq_right,[Eq.mpr, Eq.refl, Eq, min, min_comm, min_eq_left],[Eq, min]]
[Lean.MessageData.instCoeExprMessageData,[Coe.mk, Lean.MessageData.ofExpr],[Coe, Lean.Expr, Lean.MessageData]]
[Lean.Core.State.noConfusionType,[],[]]
[Lean.Elab.Tactic.ElimApp.Result.others,[],[Array, Lean.MVarId]]
[UInt8.instSemiringUInt8.proof_8,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt8.one_def, UInt8.mul_def, UInt8.mk, OfNat.ofNat, mul_one, UInt8.val, UInt8.mk_val_eq, eq_self, propext, forall_const, UInt8],[Eq, HMul.hMul, OfNat.ofNat]]
[add_left_cancel_iff,[Iff.intro, add_left_cancel, congrArg, HAdd.hAdd],[Iff, Eq, HAdd.hAdd]]
[Lean.instInhabitedTraceState,[Inhabited.mk, Lean.TraceState.mk, arbitrary],[Inhabited, Lean.TraceState]]
[Lean.ClassState.noConfusionType,[],[]]
[ByteArray.set!,[ByteArray, ByteArray.mk, Array.set!],[ByteArray]]
[Lean.Widget.CodeWithInfos.pretty,[Lean.Widget.TaggedText.stripTags],[String]]
[One.noConfusionType,[],[]]
[Std.PersistentArray.root,[],[Std.PersistentArrayNode]]
[Lean.Elab.Term.ensureType,[Bind.bind, liftM, Lean.Meta.isType, ite, Eq, Bool.true, Pure.pure, Lean.Meta.inferType, Lean.Meta.mkFreshLevelMVar, Lean.Meta.isDefEq, Lean.mkSort, Lean.Meta.mkFreshTypeMVar, Lean.MetavarKind.natural, Lean.Name.anonymous, Lean.Meta.getLevel, Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.synthetic, MonadExcept.tryCatch, Lean.Elab.Term.withoutMacroStackAtErr, Lean.Elab.Term.synthesizeCoeInstMVarCore, Lean.Meta.expandCoe, Lean.mkAppN, Lean.mkConst, Lean.Name.mkStr, List.cons, List.nil, List.toArray, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Exception.internal, Lean.Elab.Term.TermElabM, Lean.Expr],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Lean.Parser.Tactic.open.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.openDecl.formatter, Lean.PrettyPrinter.Formatter.withOpenDecl.formatter, Lean.Parser.Tactic.tacticSeq.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.MacroScopesView.mainModule,[],[Lean.Name]]
[Lean.Elab.GoalsAtResult.mk.inj,[And.intro],[And, Eq]]
[List.mapTRAux_eq,[of_eq_true, Eq.trans, congrArg, Eq, List.reverse, List.append_nil, eq_self, Eq.mpr, Eq.refl, List.mapTRAux, List.cons, HAppend.hAppend, List.map, List.reverse_cons, List.nil, List.append_assoc, rfl],[Eq, List.mapTRAux, HAppend.hAppend, List.reverse, List.map]]
[Lean.Lsp.ReferenceParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.ReferenceParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.ReferenceParams.mk, And]]
[instSubsingletonSquash,[instSubsingletonSquash.proof_1],[Subsingleton, Squash]]
[Lean.Elab.Term.StructInst.FieldVal.term.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.StructInst.FieldVal.term, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.Parenthesizer.withoutPosition.parenthesizer,[],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.Structural.RecArgInfo.noConfusionType,[],[]]
[Lean.Lsp.ServerCapabilities.hoverProvider,[],[Bool]]
[Lean.MonadCacheT.instMonadLiftMonadCacheT,[inferInstanceAs, MonadLift, StateRefT', Std.HashMap],[MonadLift, Lean.MonadCacheT]]
[Lean.Expr.ReplaceLevelImpl.cache.proof_1,[lcProof],[LT.lt, USize.toNat, Array.size, Lean.Expr.ReplaceLevelImpl.State.keys]]
[Lean.mkRawNatLit,[Lean.mkLit, Lean.Literal.natVal],[Lean.Expr]]
[Lean.IR.ExplicitBoxing.BoxingState.auxDecls,[],[Array, Lean.IR.Decl]]
[Lean.EnumAttributes.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.EnumAttributes.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.EnumAttributes.mk, And]]
[ByteArray.foldlM.loop,[dite, LT.lt, Unit.unit, Pure.pure, Bind.bind, ByteArray.get, Fin.mk, ByteArray.foldlM.loop.proof_1, PProd.fst, HAdd.hAdd, OfNat.ofNat],[]]
[Lean.Server.Watchdog.eraseFileWorker,[Bind.bind, MonadReader.read, ST.Ref.modify, Lean.Server.Watchdog.ServerContext.fileWorkersRef, Std.RBMap.erase],[Lean.Server.Watchdog.ServerM, Unit]]
[imp_iff_not_or,[Decidable.imp_iff_not_or],[Iff, Or, Not]]
[Lean.Parser.declareTrailingBuiltinParser,[Lean.Parser.declareBuiltinParser, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Core.CoreM, Unit]]
[Lean.Elab.Term.elabMatch,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.Elab.Term.resolveId?, Bool.false, Unit.unit, Lean.Elab.Term.TermElabM, Bool, Pure.pure, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.MonadEnv.getEnv, Option.none, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo, Lean.Environment.find?, not, Lean.hasMatchPatternAttribute, and, Lean.Syntax.isIdent, Lean.Name.isAtomic, Lean.Name.eraseMacroScopes, Lean.Syntax.getId, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Elab.Term.withMacroExpansion, Lean.Elab.Term.elabTerm, Lean.Elab.Term.elabMatch.elabMatchDefault],[Lean.Elab.Term.TermElab]]
[List.toArrayAux_data,[Eq, Array.data, List.toArrayAux, HAppend.hAppend, Eq.symm, List.append_nil, List.nil, Eq.trans, PProd.fst, Array.push, of_eq_true, congrFun, congrArg, Array.mk, List.concat_eq_append, List.append_assoc, List.cons, List.singleton_append, eq_self],[Eq, Array.data, List.toArrayAux, HAppend.hAppend]]
[Lean.Meta.ElimAltInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.ElimAltInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.ElimAltInfo.mk, And]]
[Lean.instInhabitedName,[Inhabited.mk, Lean.Name.anonymous],[Inhabited, Lean.Name]]
[Lean.HeadIndex.proj.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.HeadIndex.proj, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.HeadIndex.proj, And]]
[Lean.Parser.Command.noncomputable,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[instDecidableEqNat,[Nat.decEq],[DecidableEq, Nat]]
[List.cons_subset_of_subset_of_mem,[Iff.mpr, List.cons_subset, And.intro],[Subset.subset, List.cons]]
[RandomGen.range,[],[Prod, Nat]]
[Lean.getPPMatch,[Lean.KVMap.get, Lean.Option.name, Lean.pp.match, not, Lean.getPPAll],[Bool]]
[Std.HashSet.empty,[Std.mkHashSet, OfNat.ofNat],[Std.HashSet]]
[Lean.Elab.GoalsAtResult.ctxInfo,[],[Lean.Elab.ContextInfo]]
[Lean.MetavarContext.assignDelayed,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Lean.MetavarContext.decls, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Std.PersistentHashMap.insert, Lean.MetavarContext.dAssignment, Lean.DelayedMetavarAssignment.mk],[Lean.MetavarContext]]
[Lean.IR.ExplicitRC.VarInfo.persistent,[],[Bool]]
[Lean.LocalContext.all,[Id.run, Lean.LocalContext.allM],[Bool]]
[Std.RBMap.ofList,[Unit.unit, Std.RBMap, Std.mkRBMap, Std.RBMap.insert, PProd.fst],[Std.RBMap]]
[Lean.Lsp.CompletionItem.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.CompletionItem.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.hasOutParams,[Unit.unit, Bool, Lean.SMap.find?, Lean.ClassState.hasOutParam, Lean.SimplePersistentEnvExtension.getState, Lean.classExtension, Bool.false],[Bool]]
[Lean.Meta.Match.Problem.mvarId,[],[Lean.MVarId]]
[instPowNatNat,[Pow.mk, Nat.pow],[Pow, Nat]]
[ExceptT.run,[],[Except]]
[Lean.LocalDecl.setType,[Lean.LocalDecl, Lean.LocalDecl.cdecl, Lean.LocalDecl.ldecl],[Lean.LocalDecl]]
[Lean.MetavarContext.MkBinding.instToStringException,[ToString.mk, String, HAppend.hAppend, ToString.toString, Array.map, Lean.LocalDecl.userName, Lean.LocalContext.getFVar!],[ToString, Lean.MetavarContext.MkBinding.Exception]]
[Lean.PrettyPrinter.Delaborator.addFieldInfo,[Bind.bind, modify, Lean.PrettyPrinter.Delaborator.State.mk, Std.RBMap.insert, Lean.PrettyPrinter.Delaborator.State.infos, Lean.PrettyPrinter.Delaborator.State.holeIter, Lean.PrettyPrinter.Delaborator.addFieldInfo.mkFieldInfo],[Lean.PrettyPrinter.Delaborator.DelabM, Unit]]
[Function.right_inverse_of_injective_of_left_inverse,[],[Function.right_inverse]]
[Lean.PersistentEnvExtensionState.mk.inj,[And.intro],[And, Eq]]
[Lean.JsonRpc.Response.id,[],[Lean.JsonRpc.RequestID]]
[Acc.noConfusionType,[],[]]
[Int.add_left_neg,[Unit.unit, Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat, rfl, of_eq_true, Eq.trans, congrFun, congrArg, Int.neg_ofNat_of_succ, Int.ofNat, Nat.succ, Int.negSucc_ofNat_add_ofNat, Int.sub_nat_self, eq_true_of_decide, Eq.refl, Bool.true, Int.neg_neg_ofNat_succ, Int.negSucc, Int.ofNat_add_negSucc_ofNat],[Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat]]
[Lean.MonadStateCacheT.instMonadFinallyMonadStateCacheT,[inferInstanceAs, MonadFinally, StateT, Std.HashMap],[MonadFinally, Lean.MonadStateCacheT]]
[Lean.Parser.Command.syntaxAbbrev.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.docComment.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.syntaxParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Name.eraseMacroScopes,[Unit.unit, Lean.Name, Lean.Name.hasMacroScopes, BEq.beq, PProd.fst, Lean.Name.anonymous],[Lean.Name]]
[Lean.PrettyPrinter.Formatter.evalInsideQuot.formatter,[],[Lean.PrettyPrinter.Formatter]]
[ByteSlice.toString,[Id.run, Bind.bind, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield],[String]]
[Lean.Widget.Lean.Widget.CodeToken.instRpcEncodingCodeTokenRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Lean.Widget.CodeToken.info, Pure.pure, Lean.Server.RpcEncoding.rpcDecode, Lean.Widget.CodeToken.mk],[Lean.Server.RpcEncoding, Lean.Widget.CodeToken]]
[coeOfTail,[CoeHTCT.mk, coeTail],[CoeHTCT]]
[Lean.ScopedEnvExtension.State.noConfusionType,[],[]]
[Lean.IR.ExplicitBoxing.mkBoxedVersionAux,[Bind.bind, Array.mapM, MonadState.modifyGet, Prod.mk, Lean.IR.VarId.mk, HAdd.hAdd, OfNat.ofNat, Pure.pure, Lean.IR.Param.mk, Bool.false, Lean.IR.IRType.object, Nat.foldM, Lean.IR.ExplicitBoxing.N, Prod, Array, Lean.IR.FnBody, Lean.IR.Arg, ite, Eq, not, Lean.IR.IRType.isScalar, Lean.IR.Param.ty, Bool.true, Array.push, Lean.IR.Arg.var, Lean.IR.Param.x, Lean.IR.FnBody.vdecl, Lean.IR.Expr.unbox, arbitrary, List.toArray, List.nil, Array.size, Lean.IR.Decl, Lean.IR.Decl.resultType, Lean.IR.reshape, Lean.IR.FnBody.ret],[Lean.IR.ExplicitBoxing.N, Lean.IR.Decl]]
[Nat.gcd_mul_left_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.gcd_comm, Nat.gcd_mul_left_left, rfl],[Eq, Nat.gcd, HMul.hMul]]
[Lean.Parser.Term.have.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.haveDecl.formatter, Lean.Parser.Term.optSemicolon.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Lean.Expr.noConfusionType,[],[]]
[Functor.map_equiv.proof_2,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Functor.map_map, Equiv.toFun, Equiv.symm, Functor.map, Equiv.self_comp_symm, LawfulFunctor.id_map, eq_self],[Eq, Functor.map, Equiv.toFun, Equiv.symm]]
[Lean.instInhabitedStructureInfo,[Inhabited.mk, Lean.StructureInfo.mk, arbitrary],[Inhabited, Lean.StructureInfo]]
[Lean.PrettyPrinter.parenthesizeTactic,[Lean.PrettyPrinter.parenthesize, Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat],[Lean.Core.CoreM, Lean.Syntax]]
[Lean.MData,[Lean.KVMap],[]]
[Lean.PrettyPrinter.Formatter.registerAlias,[Lean.Parser.registerAliasCore, Lean.PrettyPrinter.Formatter.formatterAliasesRef],[IO, Unit]]
[Lean.IR.mkVDecl,[Lean.IR.FnBody.vdecl],[Lean.IR.FnBody]]
[Lean.Meta.IndPredBelow.mkBrecOnDecl.mkType,[Lean.Meta.forallTelescopeReducing, Array.getOp, Lean.Meta.IndPredBelow.Context.headers, Bind.bind, Array.mapIdxM, Lean.Meta.IndPredBelow.Context.motives, Lean.Meta.IndPredBelow.mkBrecOnDecl.mkIH, Array.ofSubarray, Lean.Meta.withLocalDeclsD, Lean.Meta.mkForallFVars, HAppend.hAppend, Lean.mkAppN, Bool.false, Bool.true],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Elab.Term.ElabAppArgs.State.f,[],[Lean.Expr]]
[Lean.Parser.Command.namedPrio.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.priorityParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.instInhabitedCongrLemma,[Inhabited.mk, Lean.Meta.CongrLemma.mk, arbitrary],[Inhabited, Lean.Meta.CongrLemma]]
[StateCpsT.runK_set,[rfl],[Eq, StateCpsT.runK, MonadStateOf.set, PUnit.unit]]
[Lean.ScopedEnvExtension.State.activeScopes,[],[Lean.NameSet]]
[Lean.Elab.getInfoHoleIdAssignment?,[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, Pure.pure, Std.PersistentHashMap.getOp, Lean.Elab.InfoState.assignment],[Option, Lean.Elab.InfoTree]]
[Lean.instInhabitedDeclarationRange,[Inhabited.mk, Lean.DeclarationRange.mk, arbitrary],[Inhabited, Lean.DeclarationRange]]
[Lean.Parser.Tactic.squeezeSimp?!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Environment.add,[Lean.Environment.addAux],[Lean.Environment]]
[Lean.IR.CtorLayout.numObjs,[],[Nat]]
[Nat.mod_add_div,[Nat.mod.inductionOn, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HMod.hMod, HMul.hMul, HDiv.hDiv, Nat.div_eq, ite, And, LT.lt, OfNat.ofNat, LE.le, HSub.hSub, Nat.mod_eq, congrFun, congrArg, congr, Eq.trans, ite_congr, eq_true, eq_true_of_decide, Bool.true, ite_true, Nat.mul_succ, Eq.symm, Nat.add_assoc, Nat.sub_add_cancel, And.right, rfl, of_eq_true, eq_false, ite_false, Nat.mul_zero, Nat.add_zero, eq_self],[Eq, HAdd.hAdd, HMod.hMod, HMul.hMul, HDiv.hDiv]]
[Lean.Elab.Tactic.Conv.changeLhs,[Bind.bind, Lean.Elab.Tactic.Conv.getRhs, Lean.Elab.Tactic.liftMetaTactic1, Lean.Meta.mkEq, coeM, Lean.Meta.replaceTargetDefEq, Lean.mkLHSGoal],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.instQuoteSubstring,[Lean.Quote.mk, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Quote.quote, Substring.toString, List.nil],[Lean.Quote, Substring]]
[Lean.Environment.getModuleIdx?,[Array.findIdx?, Lean.EnvironmentHeader.moduleNames, Lean.Environment.header, BEq.beq],[Option, Lean.ModuleIdx]]
[Lean.Elab.Tactic.getMainGoal.loop,[Unit.unit, Lean.Elab.Tactic.TacticM, Lean.MVarId, Lean.Elab.Tactic.throwNoGoalsToBeSolved, Bind.bind, liftM, Lean.Meta.isExprMVarAssigned, ite, Eq, Bool.true, PProd.fst, Lean.Elab.Tactic.setGoals, List.cons, Pure.pure],[Lean.Elab.Tactic.TacticM, Lean.MVarId]]
[String.instDecidableEqIterator,[Decidable, Eq, dite, Decidable.isTrue, rfl, Decidable.isFalse],[DecidableEq, String.Iterator]]
[Lean.JsonRpc.instBEqRequest,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.JsonRpc.Request]]
[Lean.JsonRpc.Notification.noConfusionType,[],[]]
[Lean.Server.FileWorker.handleReferences.combineFvars,[Prod, Array, Lean.Server.FileWorker.Reference, Std.HashMap, Lean.FVarId, Prod.mk],[Prod, Array, Lean.Server.FileWorker.Reference, Std.HashMap, Lean.FVarId]]
[Lean.registerEnumAttributes,[Bind.bind, Lean.registerPersistentEnvExtension, Lean.PersistentEnvExtensionDescr.mk, Pure.pure, EmptyCollection.emptyCollection, Lean.NameMap.insert, Prod.fst, Prod.snd, Array.qsort, Lean.Name.quickLt, OfNat.ofNat, HSub.hSub, Array.size, HAppend.hAppend, Std.Format.text, Std.Format.line, Std.ToFormat.format, Std.RBMap.size, List.forM, Lean.registerBuiltinAttribute, Lean.EnumAttributes.mk],[IO, Lean.EnumAttributes]]
[Std.Rbcolor.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.TagDeclarationExtension.tag,[Lean.PersistentEnvExtension.addEntry],[Lean.Environment]]
[Lean.PrettyPrinter.Formatter.identNoAntiquot.formatter,[Bind.bind, Lean.PrettyPrinter.Formatter.checkKind, Lean.identKind, Lean.Syntax.MonadTraverser.getCur, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.PrettyPrinter.FormatterM, Unit, Lean.PrettyPrinter.Formatter.pushToken, Lean.Name.toString, Bool.true, Lean.Syntax.MonadTraverser.goLeft, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.PrettyPrinter.Formatter]]
[instCoeTail_1,[CoeTail.mk, coeSort],[CoeTail]]
[Lean.Meta.NormNum.eval_eq_of_isNat,[Eq.symm, eq_of_heq, Eq.refl, OfNat.ofNat, HEq.refl, Eq, rfl],[Eq]]
[elabVariables,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.logWarningAt, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Option.getD, Lean.Syntax.getHeadInfo?, Array.append, List.nil, Lean.Elab.Command.elabVariable, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Std.PersistentHashSet.mk.injEq,[Eq.propIntro, Eq.refl, Std.PersistentHashSet.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.PersistentHashSet.mk]]
[Lean.version.major,[Unit.unit],[Nat]]
[Lean.Elab.Term.StructInst.DefaultFields.Context.mk.inj,[And.intro],[And, Eq]]
[CoeHead.coe,[],[]]
[Lean.Elab.Level.State.levelNames,[],[List, Lean.Name]]
[Function.injective_id,[id],[Function.injective, id]]
[Decidable.not_and,[Decidable.not_and_iff_or_not],[Iff, Not, And, Or]]
[Lean.Parser.Command.elabTail.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.darrow.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Nat.ne_of_lt,[Nat.not_le_of_lt, Nat.le_refl, Eq.symm],[Ne]]
[Lean.Elab.Term.Do.ToTerm.Kind.forIn.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Do.ToTerm.Kind.forIn, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.withBindingBodyUnusedName,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.PrettyPrinter.Delaborator.getUnusedName, Lean.Expr.bindingName!, Lean.Expr.bindingBody!, Lean.PrettyPrinter.Delaborator.annotateCurPos, Lean.mkIdent, Lean.PrettyPrinter.Delaborator.SubExpr.withBindingBody],[Lean.PrettyPrinter.Delaborator.DelabM]]
[Lean.Elab.RecKind.nonrec.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.RecKind.nonrec, OfNat.ofNat]]
[Lean.instInhabitedClassState,[Inhabited.mk, Lean.ClassState.mk, arbitrary],[Inhabited, Lean.ClassState]]
[Std.PersistentArray.instForInPersistentArray,[ForIn.mk, Std.PersistentArray.forIn],[ForIn, Std.PersistentArray]]
[String.instInhabitedString,[Inhabited.mk],[Inhabited, String]]
[IO.Error.mkInappropriateTypeFile,[Function.comp, IO.Error.inappropriateType, Option.some],[IO.Error]]
[List.replace,[List, List.nil, Unit.unit, BEq.beq, List.cons, PProd.fst],[List]]
[Lean.Elab.Term.isExprMVarAssigned,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.isExprAssigned],[Lean.Elab.Term.TermElabM, Bool]]
[Std.ShareCommonM,[Std.ShareCommonT, Id],[]]
[Lean.Parser.Syntax.paren.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.syntaxParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Tactic.simpa,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[StateT.run_bind,[of_eq_true, eq_self, Bind.bind],[Eq, StateT.run, Bind.bind, Prod.fst, Prod.snd]]
[Std.PersistentHashMap.instToStringStats,[ToString.mk, Std.PersistentHashMap.Stats.toString],[ToString, Std.PersistentHashMap.Stats]]
[Lean.ProjectionFunctionInfo.fromClassEx,[Lean.ProjectionFunctionInfo.fromClass],[Bool]]
[Lean.Elab.Term.SavedContext.errToSorry,[],[Bool]]
[Lean.Lsp.TextDocumentContentChangeEvent.rangeChange.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.TextDocumentContentChangeEvent.rangeChange, HAdd.hAdd, OfNat.ofNat]]
[Lean.PExprSet,[Lean.PersistentExprSet],[]]
[Lean.Elab.Term.elabForIn.getMonad,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.throwError, Lean.ToMessageData.toMessageData, Bind.bind, Lean.Elab.Term.isTypeApp?, Pure.pure, HAppend.hAppend, Lean.indentExpr],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[OptionT.lift,[OptionT.mk, Bind.bind, Pure.pure, Option.some],[OptionT]]
[Lean.Parser.commandParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.varNames,[],[Array, Lean.Name]]
[Lean.Elab.Tactic.saveTacticInfoForToken,[ite, Eq, Option.isNone, Lean.Syntax.getPos?, Bool.false, Bool.true, Pure.pure, PUnit.unit, Lean.Elab.Tactic.withTacticInfoContext, Unit.unit],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.LocalContext.decls,[],[Std.PersistentArray, Option, Lean.LocalDecl]]
[Lean.Parser.getSyntaxNodeKinds,[Std.PersistentHashMap.foldl, List.cons, List.nil],[List, Lean.SyntaxNodeKind]]
[Lean.Parser.Term.strictImplicitRightBracket.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.group.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Function.inv_fun,[Function.inv_fun_on, Set.univ],[]]
[Std.RBMap,[Subtype, Std.RBNode.WellFormed],[]]
[instHOr,[HOr.mk, OrOp.or],[HOr]]
[Lean.Elab.Tactic.getFVarIds,[Lean.Elab.Tactic.withMainContext, Array.mapM, Lean.Elab.Tactic.getFVarId],[Lean.Elab.Tactic.TacticM, Array, Lean.FVarId]]
[Lean.RecursorVal.getMajorIdx,[HAdd.hAdd, Lean.RecursorVal.numParams, Lean.RecursorVal.numMotives, Lean.RecursorVal.numMinors, Lean.RecursorVal.numIndices],[Nat]]
[readThe,[MonadReaderOf.read],[]]
[Lean.Elab.Term.instInhabitedArg,[Inhabited.mk, Lean.Elab.Term.Arg.stx, arbitrary],[Inhabited, Lean.Elab.Term.Arg]]
[Lean.getReducibilityStatusImp,[Unit.unit, Lean.ReducibilityStatus, Lean.EnumAttributes.getValue, Lean.reducibilityAttrs, Lean.ReducibilityStatus.semireducible],[Lean.ReducibilityStatus]]
[Lean.Meta.getFVarLocalDecl,[Lean.Meta.getLocalDecl, Lean.Expr.fvarId!],[Lean.Meta.MetaM, Lean.LocalDecl]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.noConfusionType,[],[]]
[Lean.PrettyPrinter.Delaborator.unresolveNameGlobal,[ite, Eq, Lean.Name.hasMacroScopes, Bool.true, Pure.pure, Bind.bind, PUnit.unit, Lean.PrettyPrinter.Delaborator.unresolveNameGlobal.unresolveNameCore],[Lean.PrettyPrinter.Delaborator.DelabM, Lean.Name]]
[Lean.PrefixTree.empty,[Subtype.mk, Lean.PrefixTreeNode.empty, Lean.PrefixTreeNode.WellFormed.emptyWff],[Lean.PrefixTree]]
[Lean.Lsp.TextDocumentPositionParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.TextDocumentPositionParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.TextDocumentPositionParams.mk, And]]
[Lean.Parser.Term.doReassign,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.notFollowedByRedefinedTermToken, HOrElse.hOrElse, Lean.Parser.Term.letIdDeclNoBinders, Lean.Parser.Term.letPatDecl],[Lean.Parser.Parser]]
[Lean.Meta.instInhabitedSimpLemmas,[Inhabited.mk, Lean.Meta.SimpLemmas.mk, arbitrary],[Inhabited, Lean.Meta.SimpLemmas]]
[String.isPrefix,[List.isPrefix],[]]
[Lean.Server.FileWorker.CancelToken.new,[Functor.map, Lean.Server.FileWorker.CancelToken.mk, liftM, IO.mkRef, Bool.false],[IO, Lean.Server.FileWorker.CancelToken]]
[exists_and_distrib_left,[Iff.intro, And, Exists, And.intro, Exists.intro],[Iff, Exists, And]]
[Lean.isIOUnitInitFnCore,[Option.none, Unit.unit, Option.some, Lean.Name.str, Lean.Name.num, Bool, Lean.ParametricAttribute.getParam, Bool.true, Bool.false],[Bool]]
[Lean.Xml.Parser.CData,[Lean.Parsec.manyChars, SeqRight.seqRight, Lean.Parsec.notFollowedBy, Lean.Parsec.skipString, Lean.Parsec.anyChar],[Lean.Parsec, String]]
[Lean.termThis,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Or.swap,[Or.inr, Or.inl],[Or]]
[Lean.Expr.consumeMData,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Lean.Expr, PProd.fst],[Lean.Expr]]
[Decidable.byContradiction,[Decidable.byCases, id, False.elim],[]]
[RandomGen.noConfusionType,[],[]]
[Lean.FileMap.lspPosToUtf8Pos,[String.codepointPosToUtf8PosFrom, Lean.FileMap.source],[String.Pos]]
[Lean.NameHashSet.instEmptyCollectionNameHashSet,[EmptyCollection.mk, Lean.NameHashSet.empty],[EmptyCollection, Lean.NameHashSet]]
[Nat.lt_or_eq_of_le,[Or.imp_right, Nat.le_antisymm, Nat.lt_or_ge],[Or, LT.lt, Eq]]
[Lean.Parser.Tactic.quotSeq,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.Tactic.seq1],[Lean.Parser.Parser]]
[Lean.Lsp.instFromJsonCompletionOptions,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, Array, String, Bool, Pure.pure, Lean.Lsp.CompletionOptions.mk],[Lean.FromJson, Lean.Lsp.CompletionOptions]]
[Lean.Expr.Data,[UInt64],[]]
[Lean.Meta.ParamInfo.backDeps,[],[Array, Nat]]
[StateRefT'.instMonadExceptOfStateRefT',[MonadExceptOf.mk, Function.comp, StateRefT'.lift, throwThe, tryCatchThe],[MonadExceptOf, StateRefT']]
[Quot.liftBeta,[rfl],[Eq, Quot.lift, Quot.mk]]
[Lean.Parser.Term.letPatDecl.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.pushNone.parenthesizer, Lean.Parser.Term.optType.parenthesizer, Lean.Parser.symbol.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Option.«commandRegister_option__:_:=_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.runParserAttributeHooks,[Bind.bind, ST.Ref.get, Lean.Parser.parserAttributeHooks, List.forM, Lean.Parser.ParserAttributeHook.postAdd],[Lean.AttrM, Unit]]
[Array.filterM,[Array.foldlM, Bind.bind, ite, Eq, Bool.true, Pure.pure, Array.push, List.toArray, List.nil],[Array]]
[Lean.isLetterLike,[or, and, Decidable.decide, LE.le, OfNat.ofNat, Char.val, Ne],[Bool]]
[Decidable.iff_not_comm,[Eq.mpr, Eq.refl, Iff, Not, propext, iff_def, And, and_congr, imp_not_comm, Decidable.not_imp_comm],[Iff, Not]]
[Lean.mkLitEx,[Lean.mkLit],[Lean.Expr]]
[instDecidableOr.proof_1,[False],[False]]
[And.left,[],[]]
[Lean.PrettyPrinter.Delaborator.delabLit,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Pure.pure, Lean.Quote.quote, panicWithPosWithDecl, OfNat.ofNat],[Lean.PrettyPrinter.Delaborator.Delab]]
[strictOr,[or],[Bool]]
[Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp,[Trans.mk, Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp.proof_1],[Trans, LE.le]]
[Lean.Lsp.WorkspaceFolder.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.WorkspaceFolder.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.WorkspaceFolder.mk, And]]
[Nat.add_le_of_le_sub_left,[Iff.mp, Nat.not_lt, Iff.mpr, Nat.sub_lt_left_of_lt_add],[LE.le, HAdd.hAdd]]
[Lean.MonadStateCacheT.instMonadExceptOfMonadStateCacheT,[inferInstanceAs, MonadExceptOf, StateT, Std.HashMap],[MonadExceptOf, Lean.MonadStateCacheT]]
[Lean.MonadRef.withRef,[],[]]
[Lean.Meta.isProof,[Bind.bind, Lean.Meta.isProofQuick, Unit.unit, Lean.Meta.MetaM, Bool, Pure.pure, Bool.true, Bool.false, Lean.Meta.inferType, Lean.Meta.isProp],[Lean.Meta.MetaM, Bool]]
[Lean.mkEM,[Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.Expr]]
[Lean.JsonRpc.ResponseError.id,[],[Lean.JsonRpc.RequestID]]
[Lean.Server.maybeTee,[Bind.bind, liftM, IO.getEnv, Unit.unit, IO, IO.FS.Stream, Pure.pure, IO.FS.createDirAll, System.FilePath.mk, IO.FS.Handle.mk, System.mkFilePath, List.cons, List.nil, IO.FS.Mode.write, Bool.true, ite, Eq, IO.FS.Stream.chainLeft, IO.FS.Stream.chainRight],[IO, IO.FS.Stream]]
[Lean.Meta.Simp.Step.done.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Simp.Step.done, HAdd.hAdd, OfNat.ofNat]]
[IO.Error.mkInappropriateType,[IO.Error.inappropriateType, Option.none],[IO.Error]]
[DoResultSBC.continue.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultSBC.continue, HAdd.hAdd, OfNat.ofNat]]
[UInt32.instRingUInt32.proof_2,[congrArg, UInt32.mk, Ring.gsmul_zero', UInt32.val],[Eq, UInt32.mk, Ring.gsmul, OfNat.ofNat, UInt32.val]]
[instDecidableArrow.proof_1,[],[]]
[liftExcept,[Pure.pure, MonadExcept.throw],[]]
[Lean.Elab.Command.InductiveView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.InductiveView.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Command.InductiveView.mk, And]]
[Prod.lex.proof_1,[WellFounded.intro, Acc, Prod.Lex, WellFoundedRelation.rel, Prod.lexAccessible, WellFounded.apply, WellFoundedRelation.wf],[WellFounded, Prod.Lex, WellFoundedRelation.rel]]
[Lean.Meta.SimpAll.Entry.type,[],[Lean.Expr]]
[Lean.Elab.InfoTree.ofJson.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.InfoTree.ofJson, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.InfoTree.ofJson]]
[Lean.Widget.TaggedText.instInhabitedTaggedState,[Inhabited.mk, arbitrary],[Inhabited]]
[Lean.JsonRpc.instCoeJsonNumberRequestID,[Coe.mk, Lean.JsonRpc.RequestID.num],[Coe, Lean.JsonNumber, Lean.JsonRpc.RequestID]]
[Nat.sub_self_add,[],[Eq, HSub.hSub, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.attrInstance.formatter,[Lean.ppGroup.formatter, Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.attrParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.mkRecursorInfo,[Bind.bind, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.Meta.MetaM, Lean.Meta.RecursorInfo, Lean.getConstInfoInduct, Lean.RecursorVal.getInduct, Pure.pure, Lean.Meta.RecursorInfo.mk, Bool.true, Lean.InductiveVal.isRec, Lean.RecursorVal.getMajorIdx, Unit.unit, Option.some, Lean.MonadEnv.getEnv, ite, Eq, Option.isSome, not, Lean.isAuxRecursor, Option.none, Lean.Name.anonymous, Lean.Name.num, Option, Nat, and, bne, Lean.recOnSuffix, Lean.casesOnSuffix, Lean.brecOnSuffix, Lean.getConstInfoRec, Lean.mkRecName, HAdd.hAdd, Lean.RecursorVal.numParams, Lean.RecursorVal.numIndices, BEq.beq, OfNat.ofNat, Lean.RecursorVal.numMotives, Lean.Meta.forallTelescopeReducing, Lean.ConstantInfo.type, Lean.Expr.withApp, Lean.Expr.isFVar, Array.all, Array.size, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Prod, Lean.Expr, Bool, dite, LT.lt, Prod.mk, Array.isEmpty, Lean.Meta.getMajorPos?],[Lean.Meta.MetaM, Lean.Meta.RecursorInfo]]
[Lean.IR.Decl.extern.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Decl.extern, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Decl.extern, And]]
[Lean.Lsp.RpcCallParams.noConfusionType,[],[]]
[subtypeCoe,[CoeHead.mk, Subtype.val],[CoeHead, Subtype]]
[instAddUInt64,[Add.mk, UInt64.add],[Add, UInt64]]
[Lean.IR.CtorFieldInfo.scalar.inj,[And.intro],[And, Eq]]
[Lean.IR.ExplicitRC.getJPLiveVars,[Unit.unit, Lean.IR.LiveVarSet, Std.RBMap.find?, Lean.IR.ExplicitRC.Context.jpLiveVarMap, EmptyCollection.emptyCollection],[Lean.IR.LiveVarSet]]
[Lean.IR.EmitC.emitFnDeclAux,[Bind.bind, Lean.IR.EmitC.getEnv, ite, Eq, Array.isEmpty, Bool.true, Lean.isClosedTermName, Lean.IR.Decl.name, Lean.IR.EmitC.emit, not, Pure.pure, PUnit.unit],[Lean.IR.EmitC.M, Unit]]
[Lean.IR.Expr.uproj.inj,[And.intro],[And, Eq]]
[Lean.Parser.anyOfFn,[List.cons, Lean.Parser.ParserState, Lean.Parser.ParserState.mkError, Lean.Parser.Parser.fn, Lean.Parser.orelseFn, PProd.fst],[Lean.Parser.ParserFn]]
[Lean.Parser.Command.catBehaviorSymbol,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.nonReservedSymbol, Bool.false],[Lean.Parser.Parser]]
[Std.PersistentHashMap.empty,[Std.PersistentHashMap.mk],[Std.PersistentHashMap]]
[List.length_append,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.length, List.nil_append, congrFun, HAdd.hAdd, List.length_nil, Nat.zero_add, eq_self, List.cons_append, List.length_cons, HAppend.hAppend, Nat.succ, Nat.succ_add],[Eq, List.length, HAppend.hAppend, HAdd.hAdd]]
[instSubsingleton,[instSubsingleton.proof_1],[Subsingleton]]
[Lean.Options.empty,[Lean.KVMap.mk],[Lean.Options]]
[Lean.Elab.instInhabitedRecKind,[Inhabited.mk, Lean.Elab.RecKind.partial],[Inhabited, Lean.Elab.RecKind]]
[Lean.Parser.Tactic.Conv.«conv·._»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[Lean.Expr.Data.nonDepLet,[BEq.beq, UInt64.land, UInt64.shiftRight, OfNat.ofNat],[Bool]]
[IO.FS.Mode.read.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.Mode.read, OfNat.ofNat]]
[Lean.Elab.Term.PatternVarDecl.localVar.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.PatternVarDecl.localVar, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.PatternVarDecl.localVar]]
[Lean.Syntax.ifNodeKind,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, ite, Eq, BEq.beq, Bool.true, Subtype.mk, Lean.Syntax.node, Lean.IsNode.mk, Unit.unit],[]]
[heq_self_iff_true,[iff_true_intro, HEq.rfl],[Iff, HEq, True]]
[Lean.Meta.DefaultInstanceEntry.instanceName,[],[Lean.Name]]
[Int.instSubInt,[Sub.mk, Int.sub],[Sub, Int]]
[Lean.MetavarContext.assignExpr,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Lean.MetavarContext.decls, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Std.PersistentHashMap.insert, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment],[Lean.MetavarContext]]
[Lean.Widget.InfoWithCtx.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Widget.InfoWithCtx.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Widget.InfoWithCtx.mk, And]]
[Lean.Parser.Command.moduleDoc.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.ppDedent.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.commentBody.formatter, Lean.ppLine.formatter],[Lean.PrettyPrinter.Formatter]]
[List.eq_or_mem_of_mem_cons,[],[Or, Eq, Mem.mem]]
[Lean.Elab.Term.StructInst.instToFormatStruct,[Std.ToFormat.mk, Lean.Elab.Term.StructInst.formatStruct],[Std.ToFormat, Lean.Elab.Term.StructInst.Struct]]
[Nat.instLinearOrderNat,[LinearOrder.mk, Nat.le_total, inferInstance],[LinearOrder, Nat]]
[Lean.Parser.Command.terminationSuffix.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.terminationBy.parenthesizer, Lean.Parser.Command.decreasingBy.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Tactic.introMatch.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.Tactic.matchAlts.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Tactic.ringNF!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.ringMode, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Meta.solveByElim,[Lean.Meta.MetaM, Unit, Lean.throwError, Lean.ToMessageData.toMessageData, Bind.bind, Lean.MonadLCtx.getLCtx, Lean.LocalContext.firstDeclM, guard, Not, Eq, Lean.LocalDecl.isAuxDecl, Bool.true, Lean.Meta.apply, Lean.LocalDecl.toExpr, ForIn.forIn, PUnit.unit, PProd.fst, Pure.pure, ForInStep.yield],[Lean.Meta.MetaM, Unit]]
[ByteArray.forInUnsafe.loop,[ite, LT.lt, Bind.bind, Pure.pure, ByteArray.forInUnsafe.loop, HAdd.hAdd, OfNat.ofNat],[]]
[Lean.Lsp.SemanticTokensRangeParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.SemanticTokensRangeParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.SemanticTokensRangeParams.mk, And]]
[IO.FS.Stream.writeLspResponseErrorWithData,[IO.FS.Stream.writeLspMessage, Lean.JsonRpc.Message.responseError, Lean.JsonRpc.ResponseError.id, Lean.JsonRpc.ResponseError.code, Lean.JsonRpc.ResponseError.message, Option.map, Lean.ToJson.toJson, Lean.JsonRpc.ResponseError.data?],[IO, Unit]]
[Lean.PrettyPrinter.Parenthesizer.throwBacktrack,[MonadExcept.throw, Lean.Exception.internal, Lean.PrettyPrinter.backtrackExceptionId, Lean.KVMap.mk],[Lean.PrettyPrinter.ParenthesizerM]]
[Std.PersistentHashMap.insert,[Std.PersistentHashMap, Std.PersistentHashMap.mk, Std.PersistentHashMap.insertAux, UInt64.toUSize, Hashable.hash, OfNat.ofNat, HAdd.hAdd],[Std.PersistentHashMap]]
[Lean.Meta.mkEqOfHEq,[Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Option.none, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.heq?, Lean.Meta.isDefEq, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Name.mkStr, Lean.Name.anonymous, Lean.indentExpr],[Lean.Meta.MetaM, Lean.Expr]]
[Function.left_id,[rfl],[Eq, Function.comp, id]]
[Array.setD,[dite, LT.lt, Array.size, Array.set, Fin.mk],[Array]]
[Lean.Meta.DiscrTree.getMatchWithExtra,[Lean.Meta.withReducible, Bind.bind, ite, Eq, Bool.true, Lean.Expr.bvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.mdata, Lean.Meta.MetaM, Prod, Lean.Meta.DiscrTree.Key, Array, Lean.Expr, Lean.Expr.getAppFn, Pure.pure, Prod.mk, Lean.Meta.DiscrTree.Key.lit, List.toArray, List.nil, Lean.Meta.DiscrTree.Key.const, Lean.Expr.getAppRevArgs, Lean.Meta.DiscrTree.Key.fvar, Lean.Meta.DiscrTree.Key.other, MonadReader.read, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Context.config, Lean.Meta.DiscrTree.Key.star, Lean.Meta.isReadOnlyOrSyntheticOpaqueExprMVar, Lean.Meta.DiscrTree.Key.proj, List.cons, Lean.Expr.hasLooseBVars, Lean.Meta.DiscrTree.Key.arrow, Nat, Unit.unit, Array.toSubarray, OfNat.ofNat, Array.size, Lean.Meta.DiscrTree.getMatchWithExtra.process],[Lean.Meta.MetaM, Array, Prod, Nat]]
[Lean.Json.getArrVal?,[Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Lean.Json.obj, Except, String, Lean.Json, Unit.unit, Array.get?, Pure.pure, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Except, String, Lean.Json]]
[Int.instCommRingInt.proof_5,[Int.sub_eq_add_neg],[Eq, HSub.hSub, HAdd.hAdd, Neg.neg]]
[Ne.intro,[],[Ne]]
[Lean.MetavarContext.MkBinding.mkBinding,[Bind.bind, Lean.MetavarContext.MkBinding.abstractRange, Array.size, Nat.foldRevM, Lean.MetavarContext.MkBinding.M, Prod, Lean.Expr, Nat, Lean.LocalContext.getFVar!, ite, Eq, or, not, Lean.Expr.hasLooseBVar, OfNat.ofNat, Bool.true, Pure.pure, Prod.mk, Lean.mkLambda, HAdd.hAdd, Lean.mkForall, Lean.Expr.lowerLooseBVars, Lean.mkLet],[Lean.MetavarContext.MkBinding.M, Prod, Lean.Expr, Nat]]
[instInhabitedUInt16.proof_1,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt16.size]]
[or_of_or_of_imp_left,[Or.imp_left],[Or]]
[Lean.Elab.Term.Quotation.HeadInfo.noConfusionType,[],[]]
[Lean.Elab.Command.elabUniverse,[Lean.Syntax.forArgsM, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Command.addUnivLevel],[Lean.Elab.Command.CommandElab]]
[Lean.Meta.SynthInstance.TableEntry.noConfusionType,[],[]]
[Lean.IR.EmitC.declareVar,[Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.toCType],[Lean.IR.EmitC.M, Unit]]
[Lean.Core.Context.mk.inj,[And.intro],[And, Eq]]
[Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat.lt_trans],[LT.lt]]
[charToHex,[HAppend.hAppend, hexDigitRepr],[String]]
[Dvd.dvd,[],[]]
[BaseIO.toEIO,[EStateM.Result.error, EStateM.Result, IO.RealWorld, EStateM.Result.ok],[EIO]]
[Lean.MonadRecDepth.noConfusionType,[],[]]
[Quotient.lift₂,[Quotient.lift, Quotient.lift₂.proof_1, Quotient.lift₂.proof_2],[]]
[Lean.Elab.Tactic.ElimApp.Result.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Tactic.ElimApp.Result.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.MVarErrorKind.implicitArg.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.MVarErrorKind.implicitArg, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.MVarErrorKind.implicitArg]]
[Lean.Elab.Term.Do.JPDecl.noConfusionType,[],[]]
[Lean.Elab.MonadMacroAdapter.getNextMacroScope,[],[Lean.MacroScope]]
[Lean.Server.FileWorker.updateDocument,[Bind.bind, MonadReader.read, MonadState.get, liftM, Lean.Server.Snapshots.reparseHeader, Lean.FileMap.source, Lean.Server.DocumentMeta.text, Lean.Server.FileWorker.EditableDocument.headerSnap, Lean.KVMap.mk, ite, Eq, bne, Lean.Server.Snapshots.Snapshot.stx, Bool.true, IO.throwServerError, Pure.pure, PUnit.unit],[Lean.Server.FileWorker.WorkerM, Unit]]
[Semiring.mul_one,[],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.numLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Lean.Meta.forallBoundedTelescope,[Lean.Meta.map2MetaM],[]]
[Lean.Compiler.atMostOnce.AtMostOnceData.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Compiler.atMostOnce.AtMostOnceData.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.SymbolKind.event.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.event, OfNat.ofNat]]
[Lean.Json.getNum?,[Lean.Json.null, Lean.Json.bool, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Except, String, Lean.JsonNumber, Pure.pure, MonadExcept.throw],[Except, String, Lean.JsonNumber]]
[Lean.Elab.Command.State.messages,[],[Lean.MessageLog]]
[Array.findSomeRevM?,[Array.size, Nat.le_refl, Array.findSomeRevM?.find],[Option]]
[Lean.Meta.FunInfo.paramInfo,[],[Array, Lean.Meta.ParamInfo]]
[List.findSomeM?,[Unit.unit, Option, Pure.pure, Option.none, Bind.bind, Option.some, PProd.fst],[Option]]
[Lean.Meta.synthInstance?,[Bind.bind, Lean.MonadOptions.getOptions, Lean.profileitM, Lean.Exception, Lean.Meta.getConfig, Lean.Meta.withConfig, Lean.Meta.Config.mk, Bool.true, Lean.Meta.Config.quasiPatternApprox, Bool.false, Lean.Meta.TransparencyMode.instances, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct, Lean.Meta.instantiateMVars, Lean.Meta.forallTelescopeReducing, Lean.Meta.whnf, Lean.Meta.mkForallFVars, MonadState.get, Unit.unit, Lean.Meta.MetaM, Option, Lean.Expr, Std.PersistentHashMap.find?, Lean.Meta.Cache.synthInstance, Lean.Meta.State.cache, Pure.pure, Lean.Meta.withNewMCtxDepth, Lean.Meta.forallTelescope, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr.getAppFn, Lean.MonadEnv.getEnv, ite, Eq, not, Lean.hasOutParams, Lean.Meta.inferType, OfNat.ofNat, Lean.mkAppN, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, PUnit.unit, Option.none, Lean.Meta.openAbstractMVarsResult],[Lean.Meta.MetaM, Option, Lean.Expr]]
[Lean.Parser.Command.docComment.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.ppDedent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.commentBody.parenthesizer, Lean.Parser.ppLine.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Export.OfState.noConfusionType,[],[]]
[Lean.MetavarContext.MkBinding.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MetavarContext.MkBinding.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MetavarContext.MkBinding.State.mk, And]]
[Lean.Parser.optional,[Lean.Parser.optionalNoAntiquot, Lean.Parser.withAntiquotSpliceAndSuffix, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.IR.mkStrExpr,[Lean.IR.Expr.lit, Lean.IR.LitVal.str],[Lean.IR.Expr]]
[Lean.Elab.logWarningAt,[Lean.Elab.logAt, Lean.MessageSeverity.warning],[Unit]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.noConfusionType,[],[]]
[Lean.SimpleScopedEnvExtension.Descr.addEntry,[],[]]
[Lean.Lsp.instBEqCancelParams,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Lsp.CancelParams]]
[Lean.Server.Snapshots.reparseHeader,[Bind.bind, Lean.Parser.parseHeader, IO, Lean.Server.Snapshots.Snapshot, Pure.pure, Lean.Server.Snapshots.Snapshot.mk, Lean.Server.Snapshots.Snapshot.beginPos, Lean.Server.Snapshots.Snapshot.cmdState, Lean.Server.Snapshots.Snapshot.interactiveDiags],[IO, Lean.Server.Snapshots.Snapshot]]
[Task.noConfusionType,[],[]]
[UInt8.toUInt16,[Nat.toUInt16, UInt8.toNat],[UInt16]]
[Lean.Parser.Term.letEqnsDecl.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.letIdLhs.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.instToJsonHover,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.Hover.contents, List.nil, Lean.Json.opt, Lean.Lsp.Hover.range?],[Lean.ToJson, Lean.Lsp.Hover]]
[Lean.Server.FileWorker.RpcSession.release,[Prod.mk, Lean.Server.FileWorker.RpcSession.mk, Std.PersistentHashMap.erase, Lean.Server.FileWorker.RpcSession.aliveRefs, Lean.Server.FileWorker.RpcSession.nextRef, Lean.Server.FileWorker.RpcSession.expireTime],[Prod, Bool, Lean.Server.FileWorker.RpcSession]]
[Lean.ScopedEnvExtension.Descr.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ScopedEnvExtension.Descr.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ScopedEnvExtension.Descr.mk, And]]
[Lean.Meta.Contradiction.Config.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Contradiction.Config.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Contradiction.Config.mk, And]]
[Lean.Rat.noConfusionType,[],[]]
[Lean.Parser.Module.import,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.ident],[Lean.Parser.Parser]]
[Lean.Elab.withInfoContext,[Lean.Elab.withInfoTreeContext, Bind.bind, Pure.pure, Lean.Elab.InfoTree.node],[]]
[Lean.Parser.Term.doReassignArrow.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.notFollowedByRedefinedTermToken.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.doIdDecl.parenthesizer, Lean.Parser.Term.doPatDecl.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.MonadWithOptions.withOptions,[],[]]
[Fin.mod_eq,[Fin.eq_of_val_eq, Eq.mpr, congrFun, congrArg, Eq, Eq.trans, Fin.val, Fin.modn_def, Nat.mod_mod, Nat.mod_eq_of_lt, Fin.isLt],[Eq, HMod.hMod]]
[Lean.Meta.appendTagSuffix,[Bind.bind, Lean.Meta.getMVarTag, Lean.Meta.setMVarTag, Lean.Meta.appendTag],[Lean.Meta.MetaM, Unit]]
[Lean.Compiler.instInhabitedSpecializeAttributeKind,[Inhabited.mk, Lean.Compiler.SpecializeAttributeKind.specialize],[Inhabited, Lean.Compiler.SpecializeAttributeKind]]
[Int.natAbs_neg,[Unit.unit, Eq, Int.natAbs, Neg.neg, rfl],[Eq, Int.natAbs, Neg.neg]]
[Subtype.heq_iff_coe_eq,[Iff.trans, heq_iff_eq, Subtype.ext_iff, funext, propext],[Iff, HEq, Eq, Subtype.val]]
[Lean.Syntax.splitNameLit,[List.reverse, List.nil],[List, Substring]]
[Lean.Parser.Tactic.assocRw,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Parser.Command.genInjectiveTheorems.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[UInt16.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd],[UInt16]]
[Lean.PrettyPrinter.Delaborator.SubExpr.nextExtraPos,[Bind.bind, getThe, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator, modifyThe, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.next, Pure.pure],[Lean.PrettyPrinter.Delaborator.Pos]]
[Lean.Elab.OpenDecl.resolveOpenDeclId,[Bind.bind, Lean.MonadResolveName.getOpenDecls, Lean.MonadResolveName.getCurrNamespace, StateRefT'.run', Lean.Elab.OpenDecl.resolveId, Lean.Elab.OpenDecl.State.mk],[Lean.Name]]
[Lean.Server.Watchdog.ServerContext.noConfusionType,[],[]]
[Lean.Expr.ReplaceLevelImpl.ReplaceM,[StateM, Lean.Expr.ReplaceLevelImpl.State],[]]
[Lean.Option.hasQuote,[Lean.Quote.mk, Unit.unit, Lean.Syntax, Lean.mkIdent, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.mkCApp, List.toArray, List.cons, Lean.Quote.quote, List.nil],[Lean.Quote, Option]]
[instLTUInt16,[LT.mk, UInt16.lt],[LT, UInt16]]
[Char.isValidChar_zero,[Or.inl, of_decide_eq_true, Eq.refl, Bool.true],[isValidChar, OfNat.ofNat]]
[Lean.Parser.ParserExtension.OLeanEntry.token.inj,[],[Eq]]
[Lean.PrettyPrinter.Formatter.numLit.formatter,[Lean.Parser.Term.num.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.IR.Decl.fdecl.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Decl.fdecl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Decl.fdecl, And]]
[«term_>=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instMonadBaseIO,[inferInstanceAs, Monad, EIO, Empty],[Monad, BaseIO]]
[Decidable.decide,[Bool.false, Bool.true],[Bool]]
[Int.sign_one,[rfl],[Eq, Int.sign, OfNat.ofNat]]
[Lean.Elab.Command.State.infoState,[],[Lean.Elab.InfoState]]
[Lean.Elab.Command.instInhabitedStructFieldInfo,[Inhabited.mk, Lean.Elab.Command.StructFieldInfo.mk, arbitrary],[Inhabited, Lean.Elab.Command.StructFieldInfo]]
[Lean.Elab.Term.MutualClosure.pushMain,[Nat.foldM, Bind.bind, liftM, Lean.Meta.mkLambdaFVars, Array.getOp, Bool.false, Bool.true, Lean.Meta.mkForallFVars, Lean.Elab.DefViewElabHeader.type, Pure.pure, Array.push, Lean.Elab.PreDefinition.mk, Lean.Elab.getDeclarationSelectionRef, Lean.Elab.DefViewElabHeader.ref, Lean.Elab.DefViewElabHeader.kind, List.nil, Lean.Elab.DefViewElabHeader.modifiers, Lean.Elab.DefViewElabHeader.declName, Array.size],[Lean.Elab.Term.TermElabM, Array, Lean.Elab.PreDefinition]]
[Lean.CollectFVars.State.visitedExpr,[],[Lean.ExprSet]]
[Lean.Parser.Tactic.revertAfter,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Ring.toSemiring,[],[Semiring]]
[Lean.Elab.Deriving.mkContext,[Bind.bind, Lean.getConstInfoInduct, ForIn.forIn, Pure.pure, Array.push, PUnit.unit, ForInStep.yield, Lean.Name.anonymous, Lean.Name.num, Lean.Elab.Term.TermElabM, ForInStep, Array, Lean.Name, Lean.Name.eraseMacroScopes, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkSimple, HAppend.hAppend, Lean.Name.mkStr, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.TermElabM, Lean.Elab.Deriving.Context]]
[String.foldlAux,[String.foldlAux.loop],[]]
[Lean.IR.ExplicitBoxing.BoxingContext.resultType,[],[Lean.IR.IRType]]
[Lean.Elab.Term.BinderView.bi,[],[Lean.BinderInfo]]
[Fin.instMulFin,[Mul.mk, Fin.mul],[Mul, Fin]]
[Lean.Lsp.DocumentHighlightKind.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.DocumentHighlightKind.toCtorIdx],[]]
[Nat.lt_or_ge,[Unit.unit, Or, LT.lt, GE.ge, Or.inr, Nat.zero_le, Nat.succ, PProd.fst, Or.inl, Nat.le_succ_of_le, Nat.eq_or_lt_of_le, Nat.le_refl],[Or, LT.lt, GE.ge]]
[Lean.Parser.ParserExtension.Entry.kind.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.ParserExtension.Entry.kind, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Tactic.evalCases,[Lean.Elab.Tactic.focus, Bind.bind, Lean.Elab.Tactic.elabCasesTargets, Lean.Syntax.getSepArgs, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, Lean.Syntax.isNone, Bool.true, BEq.beq, Array.size, Pure.pure, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.withRef, Lean.Elab.resolveGlobalConstNoOverloadWithInfo, Option.none, liftM, Lean.Meta.getElimInfo, Prod.mk, Bool.false, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.getMainGoal, Lean.MonadMCtx.getMCtx, Lean.Elab.Tactic.getUnsolvedGoals, Lean.MonadRef.getRef, Lean.Elab.Tactic.mkTacticInfo, Lean.Meta.getMVarTag, Lean.Meta.withMVarContext, Lean.Meta.addImplicitTargets, Lean.Elab.Tactic.ElimApp.mkElimApp, Array.mapM, Lean.Meta.instantiateMVars, Array.getOp, Lean.Meta.ElimInfo.targetsPos, Lean.Meta.inferType, Lean.Meta.ElimInfo.motivePos, Lean.Meta.generalizeTargetsEq, Lean.Meta.introN, List.nil, Lean.Elab.Tactic.ElimApp.setMotiveArg, Lean.Expr.mvarId!, Lean.Meta.assignExprMVar, Lean.Elab.Tactic.ElimApp.Result.elimApp, Lean.Elab.Tactic.ElimApp.evalAlts, Lean.Elab.Tactic.ElimApp.Result.alts],[Lean.Elab.Tactic.Tactic]]
[Lean.Elab.Command.MkInstanceName.M,[StateRefT', IO.RealWorld, String, Lean.Elab.Command.CommandElabM],[]]
[Lean.Syntax.getSubstring?,[Lean.SourceInfo.original, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Option, Substring, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo, Option.some, Substring.mk, Substring.str, ite, Eq, Bool.true, Substring.startPos, Substring.stopPos, Option.none],[Option, Substring]]
[Lean.IR.Borrow.ParamMap.instHashableKey,[Hashable.mk, Lean.IR.Borrow.ParamMap.getHash],[Hashable, Lean.IR.Borrow.ParamMap.Key]]
[Lean.AttributeApplicationTime.afterTypeChecking.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.AttributeApplicationTime.afterTypeChecking, OfNat.ofNat]]
[Lean.IR.compile,[Prod, Lean.IR.Log, Except, String, Lean.Environment, EStateM.run, Bind.bind, Lean.IR.logDecls, Lean.Name.mkStr, Lean.Name.anonymous, Lean.IR.checkDecls, Lean.IR.elimDeadBranches, MonadReader.read, ite, Eq, Lean.Option.get, Lean.IR.compiler.reuse, Bool.true, Pure.pure, PUnit.unit, Lean.IR.CompilerState.mk, Prod.mk, Lean.IR.CompilerState.log, Except.ok, Lean.IR.CompilerState.env, Except.error],[Prod, Lean.IR.Log, Except, String, Lean.Environment]]
[StateRefT'.run',[Bind.bind, StateRefT'.run, Pure.pure],[]]
[Lean.Expr.const.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Expr.const, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.checkInsideQuotFn,[ite, Eq, and, Decidable.decide, GT.gt, Lean.Parser.ParserContext.quotDepth, OfNat.ofNat, not, Lean.Parser.ParserContext.suppressInsideQuot, Bool.true, Lean.Parser.ParserState.mkUnexpectedError, List.nil],[Lean.Parser.ParserFn]]
[Lean.Elab.Frontend.getParserState,[Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Frontend.State.parserState],[Lean.Elab.Frontend.FrontendM, Lean.Parser.ModuleParserState]]
[Lean.Meta.Match.instInhabitedProblem,[Inhabited.mk, Lean.Meta.Match.Problem.mk, arbitrary],[Inhabited, Lean.Meta.Match.Problem]]
[Lean.withHeadRefOnly,[Bind.bind, Lean.MonadRef.getRef, Unit.unit, Lean.Syntax.getHead?, Lean.withRef],[]]
[Lean.PrettyPrinter.Formatter.setStack,[modify, Lean.PrettyPrinter.Formatter.State.mk, Lean.PrettyPrinter.Formatter.State.stxTrav, Lean.PrettyPrinter.Formatter.State.leadWord],[Lean.PrettyPrinter.FormatterM, Unit]]
[Lean.Parser.Command.universe.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.ClientInfo.version?,[],[Option, String]]
[instSemiringFin.proof_5,[Fin.eq_of_val_eq, Eq.mpr, congrFun, congrArg, Eq, Eq.trans, Fin.val, Fin.mul_def, OfNat.ofNat, HMod.hMod, HMul.hMul, Fin.one_def, False.elim, Fin.elim0, Eq.symm, Nat.succ, Nat.lt_or_eq_of_le, Nat.mod_le, of_eq_true, Nat.mul_one, Nat.mod_eq_of_lt, Fin.isLt, eq_self, Eq.refl],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Elab.Term.Quotation.getAntiquotationIds,[Bind.bind, ForIn.forIn, ite, Eq, and, or, Lean.Syntax.isAntiquot, Lean.Syntax.isTokenAntiquot, not, Lean.Syntax.isEscapedAntiquot, Bool.true, Lean.Syntax.isIdent, Pure.pure, PUnit.unit, ForInStep.yield, Lean.throwErrorAt, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.TermElabM, Array, Lean.Syntax]]
[Lean.Lsp.ReferenceParams.toTextDocumentPositionParams,[],[Lean.Lsp.TextDocumentPositionParams]]
[Lean.Syntax.mkStrLit,[Lean.Syntax.mkLit, Lean.strLitKind, String.quote],[Lean.Syntax]]
[Lean.IR.NormalizeIds.normIndex,[Unit.unit, Id, Lean.IR.Index, Std.RBMap.find?],[Lean.IR.NormalizeIds.M, Lean.IR.Index]]
[Monoid.HPow,[HPow.mk, Monoid.npow],[HPow, Nat]]
[Lean.Elab.Info.ofFieldInfo.inj,[],[Eq]]
[instDecidableEqSum.proof_1,[rfl],[Eq, Sum.inl]]
[Lean.Compiler.foldBinOp,[OptionM.run, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, OptionM, Lean.Expr, Bind.bind, Lean.Compiler.findBinFoldFn, Alternative.failure],[Option, Lean.Expr]]
[List.disjoint,[False],[]]
[Lean.Server.Watchdog.WorkerEvent.ioError.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.Watchdog.WorkerEvent.ioError, HAdd.hAdd, OfNat.ofNat]]
[Function.has_right_inverse,[Exists, Function.right_inverse],[]]
[EStateM.instMonadFinallyEStateM,[MonadFinally.mk, EStateM.Result, Prod, Option.some, EStateM.Result.ok, Prod.mk, EStateM.Result.error, Option.none],[MonadFinally, EStateM]]
[UInt16.ofNatCore,[UInt16.mk, Fin.mk],[UInt16]]
[Nat.lt_add_right,[lt_of_lt_of_le, Nat.le_add_right],[LT.lt, HAdd.hAdd]]
[Lean.KernelException.invalidProj.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.KernelException.invalidProj, HAdd.hAdd, OfNat.ofNat]]
[Lean.isClass,[Lean.SMap.contains, Lean.ClassState.hasOutParam, Lean.SimplePersistentEnvExtension.getState, Lean.classExtension],[Bool]]
[IO.eprint,[Bind.bind, liftM, IO.getStderr, IO.FS.Stream.putStr, ToString.toString],[IO, Unit]]
[Lean.Meta.mkSizeOfSpecLemmaInstance,[Lean.matchConstCtor, Lean.Expr.getAppFn, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Bind.bind, Lean.getConstInfo, Lean.Meta.forallTelescopeReducing, Lean.ConstantInfo.type, Pure.pure, Array.size, Lean.Meta.mkAppOptM],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.PrettyPrinter.Parenthesizer.checkWsBefore.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Syntax.modifyArg,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.node, Array.modify],[Lean.Syntax]]
[Lean.Meta.withReducible,[Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.reducible],[]]
[Lean.MetavarContext.getExprAssignmentDomain,[Std.PersistentHashMap.foldl, Lean.MetavarContext.eAssignment, Array.push, List.toArray, List.nil],[Array, Lean.MVarId]]
[Char.utf8Size.proof_1,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[Lean.Expr.forallE.inj,[And.intro],[And, Eq]]
[IO.FS.writeBinFile,[Bind.bind, IO.FS.Handle.mk, IO.FS.Mode.write, Bool.true, IO.FS.Handle.write],[IO, Unit]]
[Lean.Compiler.hasSpecializeAttribute,[Lean.Compiler.SpecializeAttributeKind.specialize],[Bool]]
[Lean.Elab.getRefPos,[Bind.bind, Lean.Elab.MonadLog.getRef, Pure.pure, Option.getD, Lean.Syntax.getPos?, Bool.false, OfNat.ofNat],[String.Pos]]
[Lean.IR.Expr.fap.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.fap, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Expr.fap, And]]
[Lean.Meta.InstanceEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.InstanceEntry.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.structExplicitBinder,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.Command.declModifiers, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.Command.inferMod, Lean.Parser.Command.optDeclSig, HOrElse.hOrElse, Lean.Parser.Term.binderTactic, Lean.Parser.Term.binderDefault],[Lean.Parser.Parser]]
[IO.FS.DirEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.FS.DirEntry.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.instToExprDeclarationRanges,[Lean.ToExpr.mk, Lean.mkAppN, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, List.toArray, List.cons, Lean.ToExpr.toExpr, Lean.DeclarationRanges.range, Lean.DeclarationRanges.selectionRange],[Lean.ToExpr, Lean.DeclarationRanges]]
[Lean.InductiveVal.all,[],[List, Lean.Name]]
[Lean.Elab.Term.tryPostponeIfHasMVars,[Bind.bind, Lean.Elab.Term.tryPostponeIfNoneOrMVar, Pure.pure, Option.none, Lean.Elab.Term.TermElabM, Lean.Expr, liftM, Lean.Meta.instantiateMVars, ite, Eq, Lean.Expr.hasExprMVar, Bool.true, Lean.Elab.Term.tryPostpone, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, PUnit.unit],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Lean.Elab.Term.StructInst.Field.val,[],[Lean.Elab.Term.StructInst.FieldVal]]
[Lean.checkCache,[Bind.bind, Lean.MonadCache.findCached?, Unit.unit, Pure.pure, Lean.MonadCache.cache],[]]
[Lean.Meta.CongrLemma.funName,[],[Lean.Name]]
[ST.Prim.Ref.modifyGetUnsafe,[Bind.bind, ST.Prim.Ref.take, ST, ST.Prim.Ref.set, Pure.pure],[ST]]
[Lean.Parser.mkNodeToken,[Lean.Parser.ParserState.pushSyntax, Lean.Syntax.mkLit],[Lean.Parser.ParserFn]]
[Bool.or_true,[rfl, Eq.symm, Eq.refl],[Eq, or, Bool.true]]
[Lean.Elab.Command.InductiveView.modifiers,[],[Lean.Elab.Modifiers]]
[Int.negSucc.injEq,[Eq.propIntro, Eq.refl, Int.negSucc, Eq.symm, eq_of_heq, HEq.refl],[Eq, Int.negSucc]]
[Lean.IR.CollectUsedDecls.collectInitDecl,[Bind.bind, MonadReader.read, Option.none, Lean.IR.CollectUsedDecls.M, Unit, Lean.getInitFnNameFor?, Lean.IR.CollectUsedDecls.collect, Pure.pure, Unit.unit],[Lean.IR.CollectUsedDecls.M, Unit]]
[IO.Error.mkEofError,[IO.Error.unexpectedEof],[IO.Error]]
[Lean.JsonRpc.Notification.method,[],[String]]
[lt_iff_not_ge,[Iff.intro, not_le_of_gt, lt_of_not_ge],[Iff, LT.lt, Not, GE.ge]]
[Lean.Meta.instInhabitedCaseArraySizesSubgoal,[Inhabited.mk, Lean.Meta.CaseArraySizesSubgoal.mk, arbitrary],[Inhabited, Lean.Meta.CaseArraySizesSubgoal]]
[Lean.Meta.Instances.noConfusionType,[],[]]
[Lean.Expr.ReplaceImpl.ReplaceM,[StateM, Lean.Expr.ReplaceImpl.State],[]]
[Lean.Meta.addGlobalInstance,[Lean.ScopedEnvExtension.add, Lean.Meta.globalInstanceExtension],[Lean.Meta.MetaM, Unit]]
[Lean.Macro.addMacroScope,[Bind.bind, MonadReader.read, Pure.pure, Lean.addMacroScope, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope],[Lean.MacroM, Lean.Name]]
[Lean.IR.CollectUsedDecls.M,[ReaderT, Lean.Environment, StateM, Lean.NameSet],[]]
[System.FilePath.fileStem,[Option.map, Unit.unit, dite, Eq, Eq.symm, String, String.revPosOf, Char.ofNat, String.extract, OfNat.ofNat, System.FilePath.fileName],[Option, String]]
[Function.left_inverse,[Eq],[]]
[Function.bijective_id,[And.intro, Function.injective_id, Function.surjective_id],[Function.bijective, id]]
[FloatArray.get?,[dite, LT.lt, FloatArray.size, Option.some, FloatArray.get, Fin.mk, Option.none],[Option, Float]]
[List.replicate.loop,[List, PProd.fst, List.cons],[List]]
[Lean.Compiler.foldToNat,[OptionM.run, Bind.bind, Lean.Compiler.getNumLit, Pure.pure, Lean.mkRawNatLit],[Option, Lean.Expr]]
[Lean.Parser.Tactic.tacticRepeat_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Std.Range.instForInRangeNat,[ForIn.mk, Std.Range.forIn],[ForIn, Std.Range, Nat]]
[Lean.Widget.MsgEmbed.lazyTrace.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Widget.MsgEmbed.lazyTrace, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Widget.MsgEmbed.lazyTrace, And]]
[Lean.Elab.Tactic.Conv.evalFirst,[Lean.Elab.Tactic.evalFirst],[Lean.Elab.Tactic.Tactic]]
[Lean.Parser.Term.macroArg.formatter,[Lean.Parser.termParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.Do.instInhabitedAlt,[Inhabited.mk, Lean.Elab.Term.Do.Alt.mk, arbitrary],[Inhabited, Lean.Elab.Term.Do.Alt]]
[or_self_left,[Iff.intro, Or.elim, Or.inl, id, Function.comp, Or.inr],[Iff, Or]]
[Lean.Name.isInaccessibleUserName,[Lean.Name.anonymous, Bool, or, String.contains, Char.ofNat, BEq.beq, PProd.fst, Bool.false],[Bool]]
[Lean.BinderInfo.brackets,[Lean.BinderInfo.default, Unit.unit, Lean.BinderInfo.auxDecl, Prod, String, Prod.mk],[Prod, String]]
[Lean.Server.Watchdog.GroupedEdits.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.Watchdog.GroupedEdits.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.MonadTrace.getTraceState,[],[Lean.TraceState]]
[Lean.Parser.Attr.simple.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.priorityParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Inv.inv,[],[]]
[toLOptionM,[Bind.bind, Pure.pure, Option.toLOption],[Lean.LOption]]
[EStateM.instToStringResult,[ToString.mk, String, HAppend.hAppend, ToString.toString],[ToString, EStateM.Result]]
[Lean.IR.JoinPointId.noConfusionType,[],[]]
[Std.HashSetImp.contains,[Bool, List.contains, Array.uget, Subtype.val],[Bool]]
[Lean.Elab.RecKind.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.LeanPaths.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.LeanPaths.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.LeanPaths.mk, And]]
[Lean.Name.appendAfter,[Lean.Name.modifyBase, Lean.Name.anonymous, Lean.Name.num, Lean.Name, Lean.Name.mkStr, HAppend.hAppend],[Lean.Name]]
[Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.discrs,[],[Array, Lean.Expr]]
[List.erase_subset,[Eq.mpr, Eq.refl, Subset.subset, List.erase, List.erase_eq_erasep, List.erasep_subset],[Subset.subset, List.erase]]
[Lean.IR.HasIndex.visitParams,[Array.any, BEq.beq, Lean.IR.VarId.idx, Lean.IR.Param.x, OfNat.ofNat, Array.size],[Bool]]
[Lean.Level.zero.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Level.zero, HAdd.hAdd, OfNat.ofNat]]
[Lean.Syntax.Traverser.right,[ite, GT.gt, Array.size, Lean.Syntax.Traverser.parents, OfNat.ofNat, Lean.Syntax.Traverser.down, Lean.Syntax.Traverser.up, HAdd.hAdd, Array.back, Lean.Syntax.Traverser.idxs],[Lean.Syntax.Traverser]]
[Lean.Meta.CasesSubgoal.ctorName,[],[Lean.Name]]
[Lean.Meta.Match.Extension.State.addEntry,[Lean.Meta.Match.Extension.State.mk, Lean.SMap.insert, Lean.Meta.Match.Extension.State.map, Lean.Meta.Match.Extension.Entry.name, Lean.Meta.Match.Extension.Entry.info],[Lean.Meta.Match.Extension.State]]
[Lean.MonadBacktrack.noConfusionType,[],[]]
[«term_≃_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.ParametricAttributeImpl.getParam,[],[Lean.AttrM]]
[Lean.Lsp.MarkupKind.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Meta.SimpLemma.priority,[],[Nat]]
[Lean.IR.EmitC.Context.noConfusionType,[],[]]
[Lean.Server.RpcEncoding.rpcEncode,[],[]]
[Lean.Elab.Term.StructInst.instInhabitedField,[Inhabited.mk, Lean.Elab.Term.StructInst.Field.mk, arbitrary],[Inhabited, Lean.Elab.Term.StructInst.Field]]
[AddSemigroup.noConfusionType,[],[]]
[Lean.JsonRpc.ResponseError.data?,[],[Option]]
[Lean.Lsp.SymbolKind.enumMember.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.enumMember, OfNat.ofNat]]
[Lean.PrettyPrinter.Parenthesizer.checkLinebreakBefore.parenthesizer,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Parenthesizer]]
[HMod.noConfusionType,[],[]]
[UInt32.instSemiringUInt32,[Semiring.mk, UInt32.instSemiringUInt32.proof_1, UInt32.instSemiringUInt32.proof_2, UInt32.mk, Semiring.nsmul, UInt32.val, UInt32.instSemiringUInt32.proof_3, UInt32.instSemiringUInt32.proof_4, UInt32.instSemiringUInt32.proof_5, UInt32.instSemiringUInt32.proof_6, UInt32.instSemiringUInt32.proof_7, UInt32.instSemiringUInt32.proof_8, UInt32.instSemiringUInt32.proof_9, UInt32.instSemiringUInt32.proof_10, UInt32.instSemiringUInt32.proof_11, UInt32.instSemiringUInt32.proof_12, UInt32.instSemiringUInt32.proof_13],[Semiring, UInt32]]
[String.noConfusionType,[],[]]
[Lean.IR.FunId,[Lean.Name],[]]
[Lean.Lsp.CompletionItem.documentation?,[],[Option, Lean.Lsp.MarkupContent]]
[Equivalence.symm,[],[]]
[Lean.Elab.Term.elabWaitIfTypeMVar,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, liftM, Lean.MonadMCtx.getMCtx, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.MetavarContext.findUserName?, Lean.Syntax.getId, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.instantiateMVars, Lean.mkMVar, Lean.Meta.inferType, Lean.Elab.Term.tryPostponeIfMVar, Lean.Elab.Term.elabTerm, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElab]]
[Lean.Meta.Cases.Context.inductiveVal,[],[Lean.InductiveVal]]
[Lean.Meta.getMVarType',[Bind.bind, Lean.Meta.getMVarDecl, Lean.Meta.instantiateMVars, Lean.MetavarDecl.type, Lean.Meta.whnf],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.PrettyPrinter.Parenthesizer.ite,[ite],[Lean.PrettyPrinter.Parenthesizer]]
[IO.FS.instReprDirEntry,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, IO.FS.DirEntry.root, Std.Format.line, IO.FS.DirEntry.fileName],[Repr, IO.FS.DirEntry]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withNaryArg,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.PrettyPrinter.Delaborator.SubExpr.getPos, withTheReader, Lean.PrettyPrinter.Delaborator.SubExpr, Lean.PrettyPrinter.Delaborator.SubExpr.mk, Array.getOp],[]]
[Lean.Parser.AliasValue.binary.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Parser.AliasValue.binary, OfNat.ofNat]]
[Lean.mkOpaqueValEx,[Lean.OpaqueVal.mk, Lean.ConstantVal.mk],[Lean.OpaqueVal]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.collectBottomUps,[Bind.bind, MonadReader.read, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit, ForIn.forIn, PUnit.unit, ite, Eq, BEq.beq, Array.getOp, Lean.BinderInfo.default, Bool.true, andM, liftM, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.hasMVarAtCurrDepth, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.canBottomUp, OfNat.ofNat, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.tryUnify, modify, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk, Array.set!, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.bottomUps, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.higherOrders, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.funBinders, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.provideds, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.namedArgs, Pure.pure, ForInStep.yield],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit]]
[Lean.resolveNamespace,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, Unit.unit, Lean.Name, Lean.ResolveName.resolveNamespace?, Pure.pure, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, HAppend.hAppend, ToString.toString],[Lean.Name]]
[Lean.Lsp.instToJsonInitializedParams,[Lean.ToJson.mk, Lean.Json.null],[Lean.ToJson, Lean.Lsp.InitializedParams]]
[Lean.Elab.Term.elabLetFunDecl,[Lean.Elab.Term.elabLetDeclCore, Bool.false],[Lean.Elab.Term.TermElab]]
[Lean.ConstantInfo.type,[Lean.ConstantVal.type, Lean.ConstantInfo.toConstantVal],[Lean.Expr]]
[Lean.MessageData.isNest,[Lean.MessageData.ofFormat, Lean.MessageData.ofSyntax, Lean.MessageData.ofExpr, Lean.MessageData.ofLevel, Lean.MessageData.ofName, Lean.MessageData.ofGoal, Lean.MessageData.withContext, Lean.MessageData.withNamingContext, Lean.MessageData.group, Lean.MessageData.compose, Lean.MessageData.tagged, Lean.MessageData.node, Bool, Bool.true, Bool.false],[Bool]]
[Lean.PrettyPrinter.Formatter.andthen.formatter,[SeqRight.seqRight],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.ExpandDeclIdResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.ExpandDeclIdResult.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.ExpandDeclIdResult.mk, And]]
[Lean.Elab.DefView.mk.inj,[And.intro],[And, Eq]]
[IO.AsyncList.finishedPrefix,[Function.comp, List.reverse, List.nil],[List]]
[PSum.inr.injEq,[Eq.propIntro, Eq.refl, PSum.inr, Eq.symm, eq_of_heq, HEq.refl],[Eq, PSum.inr]]
[Lean.Elab.DefView.declId,[],[Lean.Syntax]]
[Lean.Elab.Command.liftIO,[Bind.bind, MonadReader.read, liftM, IO.toEIO, Lean.Exception.error, Lean.Elab.Command.Context.ref, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, IO.Error.toString],[Lean.Elab.Command.CommandElabM]]
[Lean.KeyedDeclsAttribute.OLeanEntry.key,[],[Lean.KeyedDeclsAttribute.Key]]
[UInt8.instInhabitedFinSize,[Inhabited.mk, Fin.ofNat', OfNat.ofNat, UInt8.size_positive],[Inhabited, Fin, UInt8.size]]
[Lean.LocalContext.erase,[Lean.LocalContext, Unit.unit, Std.PersistentHashMap.find?, Lean.LocalContext.mk, Std.PersistentHashMap.erase, Std.PersistentArray.set, Lean.LocalDecl.index, Option.none],[Lean.LocalContext]]
[Lean.Meta.getInductiveUniverseAndParams,[Bind.bind, Lean.Meta.whnfD, Lean.matchConstInduct, Lean.Expr.getAppFn, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Pure.pure, Prod.mk],[Lean.Meta.MetaM, Prod, List, Lean.Level, Array, Lean.Expr]]
[Lean.EnvExtensionInterface.setState,[],[Lean.Environment]]
[Lean.Meta.Match.Pattern.below,[PUnit, PProd],[]]
[Lean.PrettyPrinter.Formatter.pushNone.formatter,[Lean.Syntax.MonadTraverser.goLeft],[Lean.PrettyPrinter.Formatter]]
[Lean.PPFns.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PPFns.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.PPFns.mk, And]]
[Lean.Elab.Command.instBEqStructFieldKind,[BEq.mk, BEq.beq, Lean.Elab.Command.StructFieldKind.toCtorIdx],[BEq, Lean.Elab.Command.StructFieldKind]]
[Nat.min_eq_right,[Eq.mpr, Eq.refl, Eq, Nat.min, Nat.min_comm, Nat.min_eq_left],[Eq, Nat.min]]
[Lean.Server.RpcEncoding.DerivingParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Server.RpcEncoding.DerivingParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.RpcEncoding.DerivingParams.mk]]
[Lean.Elab.Term.StructInst.FieldLHS.noConfusionType,[],[]]
[Lean.Parser.Command.terminationHint.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.terminationHintMany.parenthesizer, Lean.Parser.Command.terminationHint1.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Compiler.SpecState.cache,[],[Lean.SMap, Lean.Expr, Lean.Name]]
[Lean.Meta.sortLocalDecls,[StateRefT'.run', ReaderT.run, Lean.Meta.SortLocalDecls.Context.mk, Array.foldl, Lean.NameMap.insert, Lean.FVarId.name, Lean.LocalDecl.fvarId, EmptyCollection.emptyCollection, OfNat.ofNat, Array.size, Lean.Meta.SortLocalDecls.State.mk],[Lean.Meta.MetaM, Array, Lean.LocalDecl]]
[List.concat,[List, List.cons, List.nil, PProd.fst],[List]]
[Lean.Parser.Term.instBinder.parenthesizer,[Lean.Parser.ppGroup.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.optIdent.parenthesizer, Lean.Parser.termParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Command.eval,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.Elab.Term.withAutoBoundImplicit,[Bind.bind, Lean.MonadOptions.getOptions, ite, Eq, Bool.true, MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.Context.declName?, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.currMacroScope, Lean.Elab.Term.Context.mayPostpone, Lean.Elab.Term.Context.errToSorry, Std.PersistentArray.mk, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection, Lean.MonadBacktrack.saveState, Lean.Elab.Term.withAutoBoundImplicit.loop],[Lean.Elab.Term.TermElabM]]
[Lean.Meta.Simp.Methods.discharge?,[],[Lean.Meta.Simp.SimpM, Option, Lean.Expr]]
[Lean.Elab.Command.InductiveView.ctors,[],[Array, Lean.Elab.Command.CtorView]]
[Lean.Parser.Term.doCatchMatch.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.doMatchAlts.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.PrettyPrinter.Parenthesizer.State.noConfusionType,[],[]]
[Lean.instLTLiteral,[LT.mk, Eq, Lean.Literal.lt, Bool.true],[LT, Lean.Literal]]
[Lean.Elab.Command.expandMacroArg,[Bind.bind, Lean.expandMacros, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Pure.pure, Prod.mk, Option.some, Lean.Macro.throwUnsupported, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, List.nil, Option.none, Lean.Elab.Command.expandMacroArg.mkSplicePat],[Lean.MacroM, Prod, Lean.Syntax]]
[String.decLt,[List.hasDecidableLt, String.data],[Decidable, LT.lt]]
[Lean.Parser.Command.partial,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.Server.FileWorker.EditableDocument.cmdSnaps,[],[IO.AsyncList, Lean.Server.FileWorker.ElabTaskError, Lean.Server.Snapshots.Snapshot]]
[Array.toPArray,[Array.toPersistentArray],[Std.PersistentArray]]
[Lean.Rat.instOfNatRat,[OfNat.mk, Int.ofNat],[OfNat, Lean.Rat]]
[Lean.termM!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Level.hole,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Nat.le_total,[Or, LE.le, Nat.lt_or_ge, Or.inl, Nat.le_of_lt, Or.inr],[Or, LE.le]]
[Lean.IR.Decl.fdecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.Decl.fdecl, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.FnBody.del.inj,[And.intro],[And, Eq]]
[Lean.Parser.many1Indent,[Lean.Parser.withPosition, Lean.Parser.many1, HAndThen.hAndThen, Lean.Parser.checkColGe],[Lean.Parser.Parser]]
[EIO.toIO,[EStateM.adaptExcept],[IO]]
[Lean.Lsp.InitializeParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.InitializeParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.InitializeParams.mk, And]]
[Lean.Elab.WF.TerminationStrategy.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.WF.TerminationStrategy.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.WF.TerminationStrategy.mk, And]]
[Lean.Parser.ParserModuleContext.noConfusionType,[],[]]
[Lean.Elab.Tactic.ElimApp.State.alts,[],[Array, Prod, Lean.Name, Lean.MVarId]]
[Lean.Meta.deltaTarget,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType, liftM, Lean.Meta.deltaExpand, Lean.Meta.change, Bool.false],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.CollectFVars.Visitor,[Lean.CollectFVars.State],[]]
[Lean.Elab.Command.InductiveView.levelNames,[],[List, Lean.Name]]
[Classical.«tacticByCases__:_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.IR.Expr.isTaggedPtr.inj,[],[Eq]]
[Lean.Parser.instCoeArrowParserArrowParserParserParserAliasValue,[Coe.mk, Lean.Parser.AliasValue.binary],[Coe, Lean.Parser.Parser, Lean.Parser.ParserAliasValue]]
[Eq.symm,[rfl],[Eq]]
[Lean.Declaration.mutualDefnDecl.inj,[],[Eq]]
[IO.Error.mkNoSuchThing,[IO.Error.noSuchThing, Option.none],[IO.Error]]
[List.get,[absurd, Nat.not_lt_zero],[]]
[Lean.Parser.withOpen,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.withOpenFn, Lean.Parser.Parser.fn],[Lean.Parser.Parser]]
[Lean.Parser.nameLit.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.nameLitKind, Bool.true, Lean.PrettyPrinter.Formatter.nameLitNoAntiquot.formatter],[Lean.PrettyPrinter.Formatter]]
[Quot.recOnSubsingleton,[Quot.rec, Quot.recOnSubsingleton.proof_1],[]]
[Lean.Meta.instMonadBacktrackSavedStateMetaM,[Lean.MonadBacktrack.mk, Lean.Meta.saveState, Lean.Meta.SavedState.restore],[Lean.MonadBacktrack, Lean.Meta.SavedState, Lean.Meta.MetaM]]
[instInhabitedReaderT,[Inhabited.mk, arbitrary],[Inhabited, ReaderT]]
[List.toArray,[List.toArrayAux, Array.mkEmpty, List.redLength],[Array]]
[Std.HashSetImp.size,[],[Nat]]
[Lean.Parser.ParserContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.ParserContext.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.defReplacer,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[and_iff_left_of_imp,[Iff.intro, And.left, And.intro],[Iff, And]]
[Lean.Elab.Tactic.evalExact,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Tactic.closeMainGoalUsing, Bind.bind, Lean.MonadMCtx.getMCtx, Lean.Elab.Tactic.elabTermEnsuringType, Option.some, Bool.false, liftM, Lean.Meta.getMVars, Lean.Elab.Tactic.filterOldMVars, Lean.Elab.Tactic.logUnassignedAndAbort, Pure.pure, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[Lean.Elab.Term.isTypeApp?,[Bind.bind, Lean.Meta.withReducible, liftM, Lean.Meta.whnf, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Elab.Term.TermElabM, Option, Prod, Lean.Expr, Lean.Meta.instantiateMVars, Pure.pure, Option.some, Prod.mk, Option.none],[Lean.Elab.Term.TermElabM, Option, Prod, Lean.Expr]]
[Lean.Parsec.pstring,[ite, Eq, Lean.Parsec.ParseResult.success, String.Iterator.forward, String.length, Lean.Parsec.ParseResult.error, HAppend.hAppend, ToString.toString],[Lean.Parsec, String]]
[Int.instDivInt,[Div.mk, Int.div],[Div, Int]]
[Lean.Meta.PostponedEntry.ctx?,[],[Option, Lean.Meta.DefEqContext]]
[USize.toUInt32,[Nat.toUInt32, USize.toNat],[UInt32]]
[Lean.DataValue.ofNat.injEq,[Eq.propIntro, Eq.refl, Lean.DataValue.ofNat, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.DataValue.ofNat]]
[Lean.TrailingParserDescr,[Lean.ParserDescr],[]]
[Lean.ScopedEnvExtension.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ScopedEnvExtension.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Syntax.isToken,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Bool, BEq.beq, String.trim, Bool.false],[Bool]]
[Lean.MessageData.group.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MessageData.group, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.annotateBoolAt,[Bind.bind, MonadState.get, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM, Unit]]
[Lean.Elab.Info.ofTacticInfo.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Info.ofTacticInfo, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Info.ofTacticInfo]]
[Lean.addDecl,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.Environment.addDecl, Lean.setEnv, Lean.throwKernelException],[Unit]]
[Lean.DefinitionVal.value,[],[Lean.Expr]]
[Lean.Meta.withLocalDecls,[List.toArray, List.nil, Lean.Meta.withLocalDecls.loop],[]]
[Lean.Parser.Command.unsafe.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Nat.eq_one_of_dvd_one,[Nat.le_antisymm, Nat.le_of_dvd, of_decide_eq_true, rfl, Nat.pos_of_dvd_of_pos],[Eq, OfNat.ofNat]]
[Lean.Name.capitalize,[Lean.Name.anonymous, Lean.Name.num, Lean.Name, Lean.Name.mkStr, String.capitalize],[Lean.Name]]
[Lean.JsonRpc.instFromJsonMessage,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjVal?, Lean.Json.null, Lean.Json.bool, Lean.Json.num, dite, Eq, Unit.unit, Eq.symm, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Except, String, Lean.JsonRpc.Message, HOrElse.hOrElse, Lean.Json.getObjValAs?, Lean.JsonRpc.RequestID, Pure.pure, Lean.JsonRpc.Message.request, Except.toOption, Lean.JsonRpc.Message.notification, Lean.JsonRpc.Message.response, Lean.JsonRpc.ErrorCode, Lean.JsonRpc.Message.responseError, MonadExcept.throw],[Lean.FromJson, Lean.JsonRpc.Message]]
[Lean.ScopedEnvExtension.instInhabitedStateStack,[Inhabited.mk, Lean.ScopedEnvExtension.StateStack.mk, arbitrary],[Inhabited, Lean.ScopedEnvExtension.StateStack]]
[Lean.Parser.Tactic.Conv.ext,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[SubNegMonoid.sub_eq_add_neg,[],[Eq, HSub.hSub, HAdd.hAdd, Neg.neg]]
[Lean.Widget.msgToInteractive,[Bind.bind, Lean.NamingContext.mk, Lean.Name.anonymous, List.nil, Option.none, List.toArray, MonadState.modifyGet, Prod.mk, Array.size, Array.push, Pure.pure, Std.Format.tag, IO, Lean.Widget.TaggedText, Lean.Widget.MsgEmbed, Lean.Widget.TaggedText.rewriteM, Unit.unit, Array.get!, Lean.Widget.TaggedText.tag, Lean.Widget.MsgEmbed.expr, Lean.Widget.TaggedText.text, Lean.Widget.TaggedText.stripTags, panicWithPosWithDecl, OfNat.ofNat, Lean.Widget.MsgEmbed.lazyTrace, Lean.Server.WithRpcRef.mk],[IO, Lean.Widget.TaggedText, Lean.Widget.MsgEmbed]]
[Lean.SCC.State.stack,[],[List]]
[Nat.add_mul_div_right,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HAdd.hAdd, HMul.hMul, Nat.mul_comm, Nat.add_mul_div_left, rfl],[Eq, HDiv.hDiv, HAdd.hAdd, HMul.hMul]]
[Lean.Elab.Term.elabMutualDef,[ite, Eq, Array.any, Lean.Elab.DefKind.isExample, Lean.Elab.DefView.kind, OfNat.ofNat, Array.size, Bool.true, Lean.withoutModifyingEnv, Lean.Elab.Term.elabMutualDef.go, Lean.Elab.Term.elabMutualDef.processDeriving],[Lean.Elab.Term.TermElabM, Unit]]
[UInt8.instAddSemigroupUInt8,[AddSemigroup.mk, UInt8.instAddSemigroupUInt8.proof_1],[AddSemigroup, UInt8]]
[instSTWorldEST,[STWorld.mk],[STWorld, EST]]
[Std.RBNode.findCore,[Option, Sigma, Option.none, Unit.unit, PProd.fst, PProd.snd, Option.some, Sigma.mk],[Option, Sigma]]
[Std.ShareCommon.State,[PointedType.type, Std.ShareCommon.StatePointed],[]]
[Nat.mod.proof_1,[WellFoundedRelation.wf, measure, id],[WellFounded, WellFoundedRelation.rel, measure, id]]
[Lean.Lsp.WaitForDiagnostics.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.WaitForDiagnostics.mk, OfNat.ofNat]]
[Lean.Parser.Term.generalizingParam,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.nonReservedSymbol, Bool.false, HOrElse.hOrElse, Lean.Parser.Term.trueVal, Lean.Parser.Term.falseVal],[Lean.Parser.Parser]]
[Lean.Parser.Tactic.noncommRing,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Parser.Term.unreachable,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Std.Format.getIndent,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Std.Format.defIndent],[Nat]]
[Lean.KeyedDeclsAttribute.Def.builtinName,[],[Lean.Name]]
[Lean.instToExprList,[Lean.ToExpr.mk, Lean.List.toExprAux, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.levelZero, List.nil],[Lean.ToExpr, List]]
[Lean.Parser.Term.whereDecls,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1Indent, Lean.Parser.group, Lean.Parser.Term.letRecDecl, Lean.Parser.optional],[Lean.Parser.Parser]]
[Lean.Widget.InfoPopup.mk.inj,[And.intro],[And, Eq]]
[String.Range.contains,[and, Decidable.decide, LE.le, String.Range.start, LT.lt, String.Range.stop],[Bool]]
[Lean.Elab.Term.MatchAltView.noConfusionType,[],[]]
[Lean.FileMap.noConfusionType,[],[]]
[Lean.Meta.RecursorInfo.paramsPos,[],[List, Option, Nat]]
[Lean.Meta.contradictionCore,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.MonadLCtx.getLCtx, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, Unit.unit, Lean.Meta.MetaM, Bool, MProd.fst, Pure.pure],[Lean.Meta.MetaM, Bool]]
[Lean.DataValue.ofInt.inj,[],[Eq]]
[Lean.Elab.CompletionInfo.namespaceId.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.CompletionInfo.namespaceId, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.CompletionInfo.namespaceId]]
[Lean.Parser.Term.argument,[HAndThen.hAndThen, Lean.Parser.checkWsBefore, Lean.Parser.checkColGt, HOrElse.hOrElse, Lean.Parser.Term.namedArgument, Lean.Parser.Term.ellipsis, Lean.Parser.termParser, Lean.Parser.argPrec],[Lean.Parser.Parser]]
[Lean.instAddMessageContext,[Lean.AddMessageContext.mk, liftM, Lean.AddMessageContext.addMessageContext],[Lean.AddMessageContext]]
[Lean.Parser.Tactic.ringExpEq,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[IO.Error.unexpectedEof.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.Error.unexpectedEof, OfNat.ofNat]]
[Lean.MetavarContext.LevelMVarToParam.State.paramNames,[],[Array, Lean.Name]]
[Lean.Meta.NormNum.instLawfulOfNat_1.proof_1,[Lean.Meta.NormNum.LawfulOfNat.mk, rfl],[Lean.Meta.NormNum.LawfulOfNat]]
[Lean.Elab.Frontend.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Frontend.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.syntheticHole.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.Term.hole.formatter],[Lean.PrettyPrinter.Formatter]]
[Nat.foldRevM,[Nat.foldRevM.loop],[]]
[Lean.Elab.Term.mkExplicitBinder,[Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkAtom, Lean.mkNullNode, List.nil],[Lean.Syntax]]
[Lean.Parser.Tactic.guardHypNums,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Expr.hasMVar,[or, Lean.Expr.Data.hasExprMVar, Lean.Expr.Data.hasLevelMVar],[Bool]]
[Lean.Parser.Term.pipeCompletion.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.minPrec, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.Closure.State.noConfusionType,[],[]]
[Lean.Xml.Parser.CDEnd,[Lean.Parsec.skipString],[Lean.Parsec, Unit]]
[Lean.Meta.SynthInstance.Context.noConfusionType,[],[]]
[Lean.Parser.instOrElseParser,[OrElse.mk, Lean.Parser.orelse, Unit.unit],[OrElse, Lean.Parser.Parser]]
[Lean.Elab.mkMessageCore,[Lean.Message.mk],[Lean.Message]]
[SubNegMonoid.toNeg,[],[Neg]]
[Std.mkRBTree,[Std.mkRBMap, Unit],[Std.RBTree]]
[List.eraseIdx,[List, List.nil, List.cons, PProd.fst],[List]]
[Lean.Option.Decl.group,[],[String]]
[Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp.proof_1,[Nat.le_trans],[LE.le]]
[IO.println,[IO.print, String.push, ToString.toString, Char.ofNat],[IO, Unit]]
[Lean.Elab.Command.Context.fileName,[],[String]]
[Int.ofNat.injEq,[Eq.propIntro, Eq.refl, Int.ofNat, Eq.symm, eq_of_heq, HEq.refl],[Eq, Int.ofNat]]
[Lean.IR.instBEqFnBody,[BEq.mk, Lean.IR.FnBody.beq],[BEq, Lean.IR.FnBody]]
[Lean.Meta.MVarRenaming.map,[],[Lean.MVarIdMap, Lean.MVarId]]
[Lean.Parser.Term.prop.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.UnreachableBranches.Value.ctor.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.UnreachableBranches.Value.ctor, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.UnreachableBranches.Value.ctor, And]]
[Lean.JsonRpc.instCoeResponseMessage,[Coe.mk, Lean.JsonRpc.Message.response, Lean.JsonRpc.Response.id, Lean.ToJson.toJson, Lean.JsonRpc.Response.result],[Coe, Lean.JsonRpc.Response, Lean.JsonRpc.Message]]
[UInt32.toNat,[Fin.val, UInt32.val],[Nat]]
[Lean.ParserCompiler.registerParserCompiler,[Lean.Parser.registerParserAttributeHook, Lean.Parser.ParserAttributeHook.mk, Bind.bind, Lean.getConstInfo, ite, Eq, or, Lean.Expr.isConstOf, Lean.ConstantInfo.type, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, HOrElse.hOrElse, Lean.evalConstCheck, Lean.ParserDescr, Lean.TrailingParserDescr, Lean.Meta.MetaM.run', Lean.ParserCompiler.compileEmbeddedParsers, Lean.Meta.Context.mk, Lean.Meta.State.mk, Functor.discard, Lean.ParserCompiler.compileParserExpr, Lean.mkConst, List.nil],[IO, Unit]]
[Lean.Elab.Tactic.ElimApp.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.ElimApp.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Tactic.ElimApp.Context.mk, And]]
[Lean.PrettyPrinter.Formatter.withoutPosition.formatter,[],[Lean.PrettyPrinter.Formatter]]
[Lean.IR.CtorFieldInfo.usize.inj,[],[Eq]]
[Subtype.existsOfSubtype.proof_1,[Exists, Exists.intro],[Exists]]
[Lean.Elab.Tactic.Simp.DischargeWrapper.noConfusionType,[],[]]
[Lean.Xml.Parser.elementDecl,[Bind.bind, Lean.Parsec.skipString, SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Xml.Parser.Name, Lean.Xml.Parser.contentspec, optional, Lean.Parsec.skipChar, Char.ofNat],[Lean.Parsec, Unit]]
[Lean.Parser.Command.section.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Tactic.inferOptParam,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[«term_∘_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[not_or,[Iff.intro, And.intro, mt, Or.inl, Or.inr, False, Or.elim],[Iff, Not, Or, And]]
[Lean.PrefixTreeNode.WellFormed.brecOn,[Lean.PrefixTreeNode.WellFormed.below.emptyWff, Lean.PrefixTreeNode.WellFormed.below.insertWff],[]]
[Lean.Elab.Term.StructInst.Struct.structName,[Lean.Name],[Lean.Name]]
[Lean.Meta.Match.Example.below,[PUnit, PProd],[]]
[Lean.Parser.Tactic.withCases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[instHashableOption,[Hashable.mk, Unit.unit, UInt64, OfNat.ofNat, mixHash, Hashable.hash],[Hashable, Option]]
[Lean.Elab.Term.reportUnsolvedGoals,[Lean.Meta.withPPInaccessibleNames, Bind.bind, Lean.Elab.logError, Lean.MessageData.tagged, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.goalsToMessageData, List.forM, liftM, Lean.Elab.admitGoal, Bool.true],[Lean.Elab.Term.TermElabM, Unit]]
[Lean.Parser.Tactic.tacticSeq1Indented.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.many1Indent.formatter, Lean.Parser.group.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.ppLine.formatter, Lean.Parser.tacticParser.formatter, Lean.Parser.optional.formatter, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.enableInfoTree,[Lean.Elab.MonadInfoTree.modifyInfoState, Lean.Elab.InfoState.mk, Lean.Elab.InfoState.assignment, Lean.Elab.InfoState.trees],[Unit]]
[UInt32.size_positive,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[Lean.Lsp.DocumentHighlight.noConfusionType,[],[]]
[Lean.Parser.Term.let_fun.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.letDecl.formatter, Lean.Parser.Term.optSemicolon.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Lean.PrettyPrinter.Delaborator.addFieldInfo.mkFieldInfo,[Bind.bind, Lean.MonadLCtx.getLCtx, Pure.pure, Lean.Elab.Info.ofFieldInfo, Lean.Elab.FieldInfo.mk],[Lean.PrettyPrinter.Delaborator.DelabM, Lean.Elab.Info]]
[Std.PersistentHashMap.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.PersistentHashMap.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.PersistentHashMap.mk, And]]
[Lean.Meta.instInhabitedMetaM,[Inhabited.mk, arbitrary],[Inhabited, Lean.Meta.MetaM]]
[List.enum,[List.enumFrom, OfNat.ofNat],[List, Prod, Nat]]
[Nat.eq_zero_of_add_eq_zero_left,[Nat.eq_zero_of_add_eq_zero_right, Nat.add_comm],[Eq, OfNat.ofNat]]
[Lean.Level.getLevelOffset,[Lean.Level.zero, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Level, PProd.fst],[Lean.Level]]
[Option.lt,[Option.none, Option.some, True, False],[]]
[Lean.Elab.Deriving.FromToJson.mkJsonField,[Prod.mk, bne, Lean.Syntax.mkStrLit, Lean.SourceInfo.none],[Prod, Bool, Lean.Syntax]]
[Array.findRevM?,[Array.findSomeRevM?, Bind.bind, Pure.pure, ite, Eq, Bool.true, Option.some, Option.none],[Option]]
[Lean.Expr.appArg!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[Lean.Parser.leadingParser,[Lean.Parser.withAntiquotFn, Lean.Parser.leadingParserAux],[Lean.Parser.ParserFn]]
[Lean.Parser.Term.paren.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.ppDedent.formatter, Lean.PrettyPrinter.Formatter.withoutPosition.formatter, Lean.PrettyPrinter.Formatter.withoutForbidden.formatter, Lean.Parser.optional.formatter, Lean.Parser.termParser.formatter, Lean.Parser.Term.parenSpecial.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.SynthInstance.newSubgoal,[Lean.Meta.withMCtx, Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, Lean.MessageData.ofExpr, Pure.pure, PUnit.unit],[Lean.Meta.SynthInstance.SynthM, Unit]]
[Lean.Parser.Term.letIdDeclNoBinders.formatter,[Lean.PrettyPrinter.Formatter.node.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Term.ident.formatter, Lean.PrettyPrinter.Formatter.pushNone.formatter, Lean.Parser.Term.optType.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Nat.succ_le_of_lt,[],[LE.le, Nat.succ]]
[Lean.Parser.Command.declModifiers,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.docComment, Lean.Parser.Term.attributes, ite, Eq, Lean.Parser.skip, Lean.Parser.ppDedent, Lean.Parser.ppLine, Lean.Parser.Command.visibility, Lean.Parser.Command.noncomputable, Lean.Parser.Command.unsafe, HOrElse.hOrElse, Lean.Parser.Command.partial, Lean.Parser.Command.nonrec],[Lean.Parser.Parser]]
[Lean.Meta.isEtaUnassignedMVar,[Option.none, Option.some, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Bool, Lean.Expr.etaExpanded?, Bind.bind, Lean.Meta.isReadOnlyOrSyntheticOpaqueExprMVar, ite, Eq, Bool.true, Pure.pure, Bool.false, Lean.Meta.isExprMVarAssigned],[Lean.Meta.MetaM, Bool]]
[Lean.Elab.Term.PatternVarDecl.localVar.inj,[],[Eq]]
[Lean.IR.EmitC.M,[ReaderT, Lean.IR.EmitC.Context, EStateM, String],[]]
[Lean.Parser.Term.structInstLVal.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.fieldIdx.parenthesizer, Lean.Parser.Term.structInstArrayRef.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Std.ShareCommonT.withShareCommon,[MonadState.modifyGet, Std.ShareCommon.State.shareCommon],[Std.ShareCommonT]]
[List.not_mem_nil,[not_false],[Not, Mem.mem, List.nil]]
[Lean.IR.elimDeadBranches,[Bind.bind, MonadState.get, Lean.IR.CompilerM, Array, Lean.IR.Decl, modify, Lean.IR.CompilerState.mk, Lean.IR.CompilerState.log, Pure.pure, Array.mapIdx, Lean.IR.UnreachableBranches.elimDead, Array.getOp, Fin.val],[Lean.IR.CompilerM, Array, Lean.IR.Decl]]
[Lean.instInhabitedTheoremVal,[Inhabited.mk, Lean.TheoremVal.mk, arbitrary],[Inhabited, Lean.TheoremVal]]
[Nat.dvd_add,[Exists.elim, Exists.intro, HAdd.hAdd, of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.left_distrib, eq_self, HMul.hMul],[Dvd.dvd, HAdd.hAdd]]
[Id.instLawfulMonadId.proof_1,[LawfulMonad.mk, rfl],[LawfulMonad, Id]]
[Lean.IR.HasIndex.visitExpr,[Bool, Lean.IR.HasIndex.visitArgs, Lean.IR.HasIndex.visitVar, or, Bool.false],[Bool]]
[instRandomGenStdGen,[RandomGen.mk, stdRange, stdNext, stdSplit],[RandomGen, StdGen]]
[Lean.IR.Decl.normalizeIds,[StateT.run', Lean.IR.NormalizeIds.normDecl, EmptyCollection.emptyCollection, OfNat.ofNat],[Lean.IR.Decl]]
[Subtype.instInhabitedSubtype,[Inhabited.mk, Subtype.mk],[Inhabited, Subtype]]
[Lean.Meta.Simp.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Simp.State.mk, HAdd.hAdd, OfNat.ofNat]]
[List.toArrayAux,[Array, PProd.fst, Array.push],[Array]]
[Lean.NameSet,[Std.RBTree, Lean.Name, Lean.Name.quickCmp],[]]
[List.ne_nil_of_length_eq_succ,[],[Ne, List.nil]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isHBinOp,[Id.run, ite, Eq, bne, Lean.Expr.getAppNumArgs, OfNat.ofNat, Bool.true, Pure.pure, Bool.false, Bind.bind, PUnit.unit],[Bool]]
[pow_mul_comm,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HMul.hMul, HPow.hPow, Nat.zero_eq, pow_zero, one_mul, mul_one, eq_self, pow_succ', mul_assoc],[Eq, HMul.hMul, HPow.hPow]]
[Lean.Parser.Term.matchAlt.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.ppIndent.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Bool.false, Lean.Parser.darrow.formatter, Lean.PrettyPrinter.Formatter.checkColGe.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.parentIsApp,[],[Bool]]
[Lean.Parser.chFn,[Lean.Parser.rawFn, Lean.Parser.satisfyFn, BEq.beq, HAppend.hAppend, ToString.toString],[Lean.Parser.ParserFn]]
[Lean.mkCasesOn,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.MonadEnv.modifyEnv, Lean.throwKernelException, Lean.mkCasesOnImp],[Unit]]
[Lean.Parser.syntaxParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Parenthesizer]]
[Subtype.forall',[Iff.symm, Subtype.forall],[Iff, Subtype.val, Subtype.property]]
[Lean.isInductive,[Bind.bind, Lean.MonadEnv.getEnv, Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Bool, Lean.Environment.find?, Pure.pure, Bool.true, Bool.false],[Bool]]
[Nat.mul_mod_mul_left,[dite, Eq, OfNat.ofNat, Eq.mpr, Eq.refl, HMod.hMod, HMul.hMul, Nat.mul_zero, Nat.mod_zero, rfl, Nat.zero_mul, Nat.strong_rec_on],[Eq, HMod.hMod, HMul.hMul]]
[Lean.Meta.ParamInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.ParamInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.LetRecDeclView.declName,[],[Lean.Name]]
[Lean.Elab.InfoTree.context.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.InfoTree.context, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.SyntheticMVarKind.typeClass.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Term.SyntheticMVarKind.typeClass, OfNat.ofNat]]
[IO.Process.Child.noConfusionType,[],[]]
[Lean.Elab.Command.Scope.levelNames,[],[List, Lean.Name]]
[Lean.Elab.Term.Do.ToCodeBlock.withFor,[MonadWithReader.withReader, Lean.Elab.Term.Do.ToCodeBlock.Context.mk, Lean.Elab.Term.Do.ToCodeBlock.Context.ref, Lean.Elab.Term.Do.ToCodeBlock.Context.m, Lean.Elab.Term.Do.ToCodeBlock.Context.mutableVars, Bool.true],[Lean.Elab.Term.Do.ToCodeBlock.M]]
[Lean.Parser.Term.termBeforeDo.formatter,[Lean.PrettyPrinter.Formatter.withForbidden.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Lean.StructureInfo.noConfusionType,[],[]]
[Lean.AttributeApplicationTime.afterCompilation.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.AttributeApplicationTime.afterCompilation, OfNat.ofNat]]
[Lean.Lsp.instHashablePosition,[Hashable.mk, UInt64, mixHash, OfNat.ofNat, Hashable.hash],[Hashable, Lean.Lsp.Position]]
[Lean.Meta.instBEqAbstractMVarsResult,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Meta.AbstractMVarsResult]]
[Lean.Parser.ParserContext.savedPos?,[],[Option, String.Pos]]
[xor_self,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, congr, Or, eq_false, and_not_self, eq_false_of_decide, Eq.refl, Bool.false, False, eq_true_of_decide, Bool.true],[Eq, xor, False]]
[Lean.Parser.ParserAliasValue,[Lean.Parser.AliasValue, Lean.Parser.Parser],[]]
[Lean.Elab.Term.expandApp,[Bind.bind, Lean.Elab.Term.expandArgs, Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat, Bool.false, Lean.Elab.Term.TermElabM, Prod, Lean.Syntax, Array, Lean.Elab.Term.NamedArg, Lean.Elab.Term.Arg, Bool, Pure.pure, Prod.mk],[Lean.Elab.Term.TermElabM, Prod, Lean.Syntax, Array, Lean.Elab.Term.NamedArg, Lean.Elab.Term.Arg, Bool]]
[iff_def',[Iff.trans, iff_def, And.comm],[Iff, And]]
[Lean.Parser.Tactic.symm,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Parser.Term.trailing_parser,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.optExprPrecedence, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[List.isSuffix,[Exists, Eq, HAppend.hAppend],[]]
[Int.instCommRingInt.proof_7,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Int.negSucc, Int.ofNat, Neg.neg, Nat.succ, Int.negSucc_ofNat_ofNat, Int.negOfNat, Int.ofNat_mul_ofNat, rfl, Eq.symm, Int.mul_negSucc_ofNat_negSucc_ofNat, Int.ofNat_mul_negSucc_ofNat],[Eq, HMul.hMul, Int.negSucc, Neg.neg, Int.ofNat, Nat.succ]]
[Fin.mul.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, HMul.hMul]]
[bind_pure_unit,[Eq.mpr, Eq.refl, Eq, Bind.bind, Pure.pure, PUnit.unit, bind_pure, rfl],[Eq, Bind.bind, Pure.pure, PUnit.unit]]
[Lean.instForInFVarIdSetFVarId,[inferInstanceAs, ForIn, Std.RBTree, Lean.FVarId, Lean.Name.quickCmp, Lean.FVarId.name],[ForIn, Lean.FVarIdSet, Lean.FVarId]]
[Lean.MonadHashMapCacheAdapter.modifyCache,[],[Unit]]
[Lean.Meta.Context.synthPendingDepth,[],[Nat]]
[Lean.ParametricAttributeImpl.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.Quotation.HeadInfo.mk.inj,[And.intro],[And, Eq]]
[instHModUInt16NatUInt16,[HMod.mk, UInt16.modn],[HMod, UInt16, Nat]]
[instMulUInt16,[Mul.mk, UInt16.mul],[Mul, UInt16]]
[Lean.Elab.Term.Arg.stx.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Arg.stx, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Attr.toAdditive!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.IR.FnBody.jmp.inj,[And.intro],[And, Eq]]
[Nat.lt_wfRel,[WellFoundedRelation.mk, Nat.lt, Nat.lt_wfRel.proof_1],[WellFoundedRelation, Nat]]
[implies_congr,[rfl],[Eq]]
[Lean.Parser.AliasValue.const.inj,[],[Eq]]
[Lean.Meta.mkAuxMVar,[Lean.Meta.mkFreshExprMVarAt, Lean.MetavarKind.natural, Lean.Name.anonymous],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Expr.sort.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.sort, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Expr.sort, And]]
[Lean.Elab.Term.«termλ.»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Nat.coprime,[Eq, Nat.gcd, OfNat.ofNat],[]]
[Lean.IR.Borrow.ownArgsIfParam,[Bind.bind, MonadReader.read, Array.forM, Lean.IR.Arg.irrelevant, Lean.IR.Borrow.M, PUnit, ite, Eq, Std.RBTree.contains, Lean.IR.Borrow.BorrowInfCtx.paramSet, Lean.IR.VarId.idx, Bool.true, Lean.IR.Borrow.ownVar, Pure.pure, PUnit.unit, Unit.unit, OfNat.ofNat, Array.size],[Lean.IR.Borrow.M, Unit]]
[Lean.Parser.Term.have,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, Lean.Parser.symbol, Lean.Parser.Term.haveDecl, Lean.Parser.Term.optSemicolon, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[instInhabitedProp,[Inhabited.mk, True],[Inhabited]]
[Fin.lor.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, Nat.lor]]
[USize.instSemiringUSize,[Semiring.mk, USize.instSemiringUSize.proof_1, USize.instSemiringUSize.proof_2, USize.mk, Semiring.nsmul, USize.val, USize.instSemiringUSize.proof_3, USize.instSemiringUSize.proof_4, USize.instSemiringUSize.proof_5, USize.instSemiringUSize.proof_6, USize.instSemiringUSize.proof_7, USize.instSemiringUSize.proof_8, USize.instSemiringUSize.proof_9, USize.instSemiringUSize.proof_10, USize.instSemiringUSize.proof_11, USize.instSemiringUSize.proof_12, USize.instSemiringUSize.proof_13],[Semiring, USize]]
[Lean.IR.FnBody.jmp.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.FnBody.jmp, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.MarkupKind.noConfusion,[noConfusionEnum, Lean.Lsp.MarkupKind.toCtorIdx],[Lean.Lsp.MarkupKind.noConfusionType]]
[StateT.run_modify,[rfl],[Eq, StateT.run, modify, Pure.pure, Prod.mk, PUnit.unit]]
[Quotient.hrecOn,[Quot.hrecOn],[]]
[Lean.instInhabitedPrefixTreeNode,[Inhabited.mk, Lean.PrefixTreeNode.Node, Option.none, Std.RBNode.leaf],[Inhabited, Lean.PrefixTreeNode]]
[instMonadWithReaderOfReaderT,[MonadWithReaderOf.mk],[MonadWithReaderOf, ReaderT]]
[Lean.instInhabitedAttributeImpl,[Inhabited.mk, Lean.AttributeImpl.mk, arbitrary],[Inhabited, Lean.AttributeImpl]]
[Lean.Meta.getMVarsAtDecl,[Bind.bind, StateRefT'.run, Lean.Meta.collectMVarsAtDecl, Lean.CollectMVars.State.mk, Lean.Meta.MetaM, Array, Lean.MVarId, Pure.pure, Lean.CollectMVars.State.result],[Lean.Meta.MetaM, Array, Lean.MVarId]]
[Nat.mod_le,[LE.le, HMod.hMod, Nat.lt_or_ge, Eq.mpr, Eq.refl, Nat.mod_eq_of_lt, Nat.le_refl, Nat.eq_zero_or_pos, OfNat.ofNat, Nat.mod_zero, Nat.le_trans, Nat.le_of_lt, Nat.mod_lt],[LE.le, HMod.hMod]]
[Lean.IR.UnreachableBranches.Value.truncate,[Lean.IR.UnreachableBranches.Value.truncateMaxDepth, Lean.IR.UnreachableBranches.Value.truncate.go],[Lean.IR.UnreachableBranches.Value]]
[Lean.IR.EmitC.emitCName,[Bind.bind, Lean.IR.EmitC.toCName, Lean.IR.EmitC.emit],[Lean.IR.EmitC.M, Unit]]
[Lean.Parser.Command.structImplicitBinder.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Command.declModifiers.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.inferMod.formatter, Lean.Parser.Command.declSig.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Tactic.guardTarget',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Int.negOfNat,[Unit.unit, Int, OfNat.ofNat, Int.negSucc],[Int]]
[instDecidableLe_1,[UInt8.decLe],[Decidable, LE.le]]
[Lean.Elab.Term.StructInst.ExplicitSourceInfo.noConfusionType,[],[]]
[Lean.Elab.ContextInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.ParserState.popSyntax,[Lean.Parser.ParserState.mk, Array.pop, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.pos, Lean.Parser.ParserState.cache, Lean.Parser.ParserState.errorMsg],[Lean.Parser.ParserState]]
[Lean.IR.AlphaEqv.noConfusionType,[],[]]
[Lean.mkAttributeImplOfConstantUnsafe,[Unit.unit, Except, String, Lean.AttributeImpl, Lean.Environment.find?, MonadExcept.throw, HAppend.hAppend, ToString.toString, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Name.anonymous, Lean.Name.str, dite, Eq, Eq.symm, Lean.Name.num, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.ConstantInfo.type, Lean.Environment.evalConst],[Except, String, Lean.AttributeImpl]]
[Lean.Elab.Command.StructFieldInfo.inferMod,[],[Bool]]
[Lean.ConstantInfo.quotInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ConstantInfo.quotInfo, HAdd.hAdd, OfNat.ofNat]]
[Int.distrib_right,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Int.mul_comm, HAdd.hAdd, Int.distrib_left, congr, HMul.hMul, eq_self],[Eq, HMul.hMul, HAdd.hAdd]]
[Lean.Meta.Simp.simp.simpConst,[Bind.bind, liftM, Pure.pure, Lean.Meta.Simp.Result.mk],[Lean.Meta.Simp.M, Lean.Meta.Simp.Result]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.KeyedDeclsAttribute.AttributeEntry.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.Match.Alt.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.Alt.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Match.Alt.mk, And]]
[Lean.IR.Checker.checkExpr,[Lean.IR.LitVal.num, Lean.IR.Checker.M, Unit, SeqRight.seqRight, Lean.IR.Checker.checkPartialApp, Lean.IR.Checker.checkObjType, Lean.IR.Checker.checkObjVar, Lean.IR.Checker.checkArgs, Lean.IR.Checker.checkFullApp, ite, GT.gt, Lean.IR.CtorInfo.size, Lean.IR.Checker.maxCtorFields, Bind.bind, MonadExcept.throw, HAppend.hAppend, ToString.toString, Lean.IR.CtorInfo.name, Pure.pure, PUnit.unit, Lean.IR.Checker.checkScalarVar, Lean.IR.Checker.checkVarType, BEq.beq, Lean.IR.Checker.checkScalarType, Lean.IR.Checker.getType, Lean.IR.IRType.float, Lean.IR.IRType.uint8, Lean.IR.IRType.uint16, Lean.IR.IRType.uint32, Lean.IR.IRType.uint64, Lean.IR.IRType.usize, Lean.IR.IRType.irrelevant, Unit.unit, dite, LT.lt, Array.size, Lean.IR.Checker.checkEqTypes, Array.get, Fin.mk, Lean.IR.Checker.checkType],[Lean.IR.Checker.M, Unit]]
[Std.Format.MonadPrettyFormat.pushNewline,[],[Unit]]
[Lean.mkForallEx,[Lean.mkForall],[Lean.Expr]]
[Lean.Syntax.Traverser.cur,[],[Lean.Syntax]]
[Lean.Expr.isAtomic,[Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Elab.Info.fmtHover?.isAtomicFormat,[Std.Format.nil, Std.Format.line, Std.Format.append, Bool, Bool.true, PProd.fst, Bool.false],[Bool]]
[Set.inter,[setOf, And, Mem.mem],[Set]]
[Lean.IR.UnreachableBranches.addFunctionSummary,[Lean.PersistentEnvExtension.addEntry, Lean.IR.UnreachableBranches.functionSummariesExt, Prod.mk],[Lean.Environment]]
[Array.get?,[dite, LT.lt, Array.size, Option.some, Array.get, Fin.mk, Option.none],[Option]]
[Lean.IR.mkCtorExpr,[Lean.IR.Expr.ctor, Lean.IR.CtorInfo.mk],[Lean.IR.Expr]]
[Lean.Elab.Term.SyntheticMVarDecl.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.SyntheticMVarDecl.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.SyntheticMVarDecl.mk, And]]
[Lean.IR.Checker.markVar,[Lean.IR.Checker.markIndex, Lean.IR.VarId.idx],[Lean.IR.Checker.M, Unit]]
[Lean.Expr.isSort,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false],[Bool]]
[ExceptCpsT.run_lift,[rfl],[Eq, ExceptCpsT.run, ExceptCpsT.lift, Bind.bind, Pure.pure, Except.ok]]
[Lean.IR.UnreachableBranches.Value.choice.injEq,[Eq.propIntro, Eq.refl, Lean.IR.UnreachableBranches.Value.choice, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.UnreachableBranches.Value.choice]]
[Lean.getOptionDescr,[Bind.bind, Lean.getOptionDecl, Pure.pure, Lean.OptionDecl.descr],[IO, String]]
[Lean.MapDeclarationExtension.instInhabitedMapDeclarationExtension,[inferInstanceAs, Inhabited, Lean.SimplePersistentEnvExtension, Prod, Lean.Name, Lean.NameMap],[Inhabited, Lean.MapDeclarationExtension]]
[Lean.Meta.DiscrTree.Key.lit.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.DiscrTree.Key.lit, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.DiscrTree.Key.lit]]
[Lean.Meta.AltVarNames.varNames,[],[List, Lean.Name]]
[Lean.Meta.AssertAfterResult.noConfusionType,[],[]]
[Lean.Meta.InjectionResult.solved.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.InjectionResult.solved, OfNat.ofNat]]
[Lean.Meta.FindOptions.mk.inj,[And.intro],[And, Eq]]
[Lean.mkLetEx,[Lean.mkLet, Bool.false],[Lean.Expr]]
[Lean.IR.addBoxedVersion,[Except, String, Lean.Environment, EStateM.run, Lean.IR.addBoxedVersionAux, Lean.Options.empty, Lean.IR.CompilerState.mk, Except.ok, Lean.IR.CompilerState.env, Except.error],[Except, String, Lean.Environment]]
[Lean.ppLine.formatter,[Lean.PrettyPrinter.Formatter.push, Std.Format.text],[Lean.PrettyPrinter.Formatter]]
[Std.mkHashMap,[Subtype.mk, Std.mkHashMapImp, Std.HashMapImp.WellFormed.mkWff],[Std.HashMap]]
[Lean.instBEqBinderInfo,[BEq.mk, BEq.beq, Lean.BinderInfo.toCtorIdx],[BEq, Lean.BinderInfo]]
[Lean.Parser.Tactic.Conv.ringExp!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[USize.div,[USize.mk, HDiv.hDiv, USize.val],[USize]]
[Lean.Parser.Term.implicitBinder.parenthesizer,[Lean.Parser.ppGroup.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.Parser.Term.binderType.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[instHashableString,[Hashable.mk, String.hash],[Hashable, String]]
[IO.FS.SystemTime.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.FS.SystemTime.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Info.ofTermInfo.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Info.ofTermInfo, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Info.ofTermInfo]]
[Lean.isProtected,[Lean.TagDeclarationExtension.isTagged, Lean.protectedExt],[Bool]]
[Lean.mkSort,[Lean.Expr.sort, Lean.Expr.mkData, mixHash, OfNat.ofNat, Hashable.hash, Bool.false, Lean.Level.hasMVar, Lean.Level.hasParam],[Lean.Expr]]
[exists_and_distrib_right,[of_eq_true, Eq.trans, congr, congrArg, Iff, Exists, funext, propext, and_comm, exists_and_distrib_left, iff_self, And],[Iff, Exists, And]]
[Lean.Meta.DefaultInstances.defaultInstances,[],[Lean.NameMap, List, Prod, Lean.Name, Nat]]
[Lean.Expr.getAppNumArgs,[Lean.Expr.getAppNumArgsAux, OfNat.ofNat],[Nat]]
[Lean.ClassState.hasOutParam,[],[Lean.SMap, Lean.Name, Bool]]
[Lean.Syntax.mkSep,[Lean.mkNullNode, Lean.mkSepArray],[Lean.Syntax]]
[Lean.IR.JPParamsMap,[Std.HashMap, Lean.IR.JoinPointId, Array, Lean.IR.Param],[]]
[GroupWithZero.exists_pair_ne,[],[Exists, Ne]]
[USize.val_eq_of_lt,[Fin.val_eq_of_lt],[Eq, Fin.val, USize.val, USize.ofNat]]
[Lean.Meta.InjectionResultCore.subgoal.inj,[And.intro],[And, Eq]]
[Lean.JsonRpc.instToJsonRequestID,[Lean.ToJson.mk, Unit.unit, Lean.Json, Lean.Json.str, Lean.Json.num, Lean.Json.null],[Lean.ToJson, Lean.JsonRpc.RequestID]]
[StateT.instMonadStateT,[Monad.mk],[Monad, StateT]]
[Lean.Parser.Tactic.replace,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.PrettyPrinter.Delaborator.liftMetaM,[liftM],[Lean.PrettyPrinter.Delaborator.DelabM]]
[Lean.Meta.addInstance,[Bind.bind, Lean.mkConstWithLevelParams, Lean.Meta.inferType, Lean.Meta.withNewMCtxDepth, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.MetaM, Array, Lean.Meta.DiscrTree.Key, Lean.Meta.DiscrTree.mkPath, Lean.Meta.addGlobalInstance, Lean.ScopedEnvExtension.add, Lean.Meta.instanceExtension, Lean.Meta.InstanceEntry.mk, Option.some],[Lean.Meta.MetaM, Unit]]
[and_symm_left,[Iff.intro, And, Eq, And.intro, Eq.symm],[Iff, And, Eq]]
[Lean.Server.Watchdog.WorkerState.crashed.injEq,[Eq.propIntro, Eq.refl, Lean.Server.Watchdog.WorkerState.crashed, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.Watchdog.WorkerState.crashed]]
[instInhabitedOption,[Inhabited.mk, Option.none],[Inhabited, Option]]
[Lean.Elab.Term.mkInstMVar,[Bind.bind, liftM, Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.synthetic, Lean.Name.anonymous, Lean.Elab.Term.synthesizeInstMVarCore, Option.none, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Elab.Term.registerSyntheticMVarWithCurrRef, Lean.Elab.Term.SyntheticMVarKind.typeClass],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Lean.Elab.Tactic.SavedState.restore,[Bind.bind, liftM, Lean.Elab.Term.SavedState.restore, Lean.Elab.Tactic.SavedState.term, Bool.false, MonadStateOf.set, Lean.Elab.Tactic.SavedState.tactic],[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.Meta.IndPredBelow.Variables.target,[],[Array, Lean.Expr]]
[Lean.PPContext.runMetaM,[Lean.PPContext.runCoreM, Lean.Meta.MetaM.run', Lean.Meta.Context.mk, Lean.PPContext.lctx, Lean.Meta.State.mk, Lean.PPContext.mctx],[IO]]
[Lean.Expr.etaExpanded?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Expr, PProd.fst, PProd.snd, HAdd.hAdd, OfNat.ofNat, Lean.Expr.lam, ite, Eq, BEq.beq, Bool.true, Option.none, Lean.Expr.hasLooseBVars, Option.some],[Option, Lean.Expr]]
[Lean.MonadHashMapCacheAdapter.cache,[Lean.MonadHashMapCacheAdapter.modifyCache, Std.HashMap.insert],[Unit]]
[Lean.Server.FileWorker.SemanticTokensContext.endPos,[],[String.Pos]]
[IO.AsyncList.ibelow,[And, True],[]]
[Lean.Elab.Command.expandInitialize,[Lean.Elab.Command.expandInitCmd, Bool.false],[Lean.Macro]]
[Lean.Meta.SimpAll.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SimpAll.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.withMacroExpansion,[Lean.Elab.withMacroExpansionInfo, MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.Context.declName?, List.cons, Lean.Elab.MacroStackElem.mk, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.currMacroScope, Lean.Elab.Term.Context.mayPostpone, Lean.Elab.Term.Context.errToSorry, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.Term.Context.autoBoundImplicits, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection],[Lean.Elab.Term.TermElabM]]
[Int.sub,[HAdd.hAdd, Neg.neg],[Int]]
[Lean.LocalDecl.binderInfoEx,[Lean.LocalDecl.ldecl, Lean.BinderInfo, Lean.BinderInfo.default],[Lean.BinderInfo]]
[UInt16.instSemiringUInt16.proof_9,[rfl],[Eq, OfNat.ofNat]]
[Lean.Elab.OpenDecl.State.currNamespace,[],[Lean.Name]]
[Lean.Elab.Command.liftTermElabM,[Bind.bind, MonadReader.read, MonadState.get, liftM, IO.getNumHeartbeats, Lean.Elab.Command.liftEIO, Lean.Elab.Command.CommandElabM, modify, Lean.Elab.Command.State.mk, Lean.Core.State.env, Std.PersistentArray.foldl, Lean.TraceState.traces, Lean.MessageLog.add, Lean.Elab.mkMessageCore, Lean.Elab.Command.Context.fileName, Lean.Elab.Command.Context.fileMap, Lean.TraceElem.msg, Lean.MessageSeverity.information, OfNat.ofNat, HAppend.hAppend, Lean.Elab.Command.State.messages, Lean.Elab.Term.State.messages, Lean.Core.State.traceState, Lean.Elab.Command.State.scopes, Lean.Core.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Core.State.ngen, Lean.Elab.InfoState.mk, Lean.Elab.InfoState.enabled, Lean.Elab.InfoState.assignment, Std.PersistentArray.append, Lean.Elab.InfoState.trees, Lean.Elab.Command.State.infoState, Lean.Elab.Term.State.infoState, Lean.Elab.Command.State.traceState, Pure.pure, MonadExcept.throw],[Lean.Elab.Command.CommandElabM]]
[Nat.lt_wfRel.proof_1,[WellFounded.intro, Acc.intro, OfNat.ofNat, absurd, Nat.not_lt_zero, Nat.succ],[WellFounded, Nat.lt]]
[inv_mul_cancel_left,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Inv.inv, Eq.symm, mul_assoc, mul_left_inv, OfNat.ofNat, one_mul, rfl],[Eq, HMul.hMul, Inv.inv]]
[Lean.Compiler.isUnsafeRecName?,[Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Option, Lean.Name, Option.some, Option.none],[Option, Lean.Name]]
[Lean.Meta.Contradiction.Config.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.TextDocumentSyncOptions.save?,[],[Option, Lean.Lsp.SaveOptions]]
[Std.RBMap.contains,[Option.isSome, Std.RBMap.find?],[Bool]]
[Function.injective_of_partial_inv_right,[Eq.trans, Eq.symm, Iff.mp],[Eq]]
[Lean.Meta.IndPredBelow.mkCtorType.checkCount,[Bind.bind, Lean.Meta.transform, Option.none, StateRefT', IO.RealWorld, Nat, Lean.Meta.MetaM, Lean.TransformStep, Lean.Expr.constName?, Array.findIdx?, Lean.Meta.IndPredBelow.Context.typeInfos, BEq.beq, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, modify, HAdd.hAdd, OfNat.ofNat, Pure.pure, PUnit.unit, Lean.TransformStep.done, Bool, ite, GT.gt, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr],[Lean.Meta.MetaM, Bool]]
[Std.Range.«term[:_:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Deriving.Context.usePartial,[],[Bool]]
[Lean.Server.applyDocumentChange,[Lean.FileMap, Lean.Server.replaceLspRange, String.toFileMap],[Lean.FileMap]]
[Lean.Elab.Command.elabElabRules,[Lean.Elab.Command.adaptExpander, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Option.some, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Command.CommandElab]]
[Lean.matchConstRec,[Lean.matchConst, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Unit.unit],[]]
[List.append_eq_has_append,[rfl],[Eq, List.append, HAppend.hAppend]]
[Command.simpsRule,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Command.simpsRule.rename, Command.simpsRule.erase, Lean.ParserDescr.unary, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Meta.ToHide.isMarked,[Bind.bind, MonadState.get, Pure.pure, or, Std.RBTree.contains, Lean.Meta.ToHide.State.hiddenInaccessible, Lean.Meta.ToHide.State.hiddenInaccessibleProp],[Lean.Meta.ToHide.M, Bool]]
[Lean.Parser.commandParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Parser.Parser]]
[Subtype.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Subtype.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.instToJsonRange,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.Range.start, List.nil, Lean.Lsp.Range.end],[Lean.ToJson, Lean.Lsp.Range]]
[Mathlib.Tactic.Lint.simpVarHead,[Mathlib.Tactic.Lint.Linter.mk, Bind.bind, Mathlib.Tactic.Lint.isSimpLemma, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Option.none, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format],[Mathlib.Tactic.Lint.Linter]]
[Lean.Lsp.instFromJsonLocation,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, Lean.Lsp.Range, Pure.pure, Lean.Lsp.Location.mk],[Lean.FromJson, Lean.Lsp.Location]]
[Alternative.noConfusionType,[],[]]
[Lean.Lsp.SymbolKind.package.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.package, OfNat.ofNat]]
[Lean.IR.ExplicitBoxing.eqvTypes,[and, BEq.beq, Lean.IR.IRType.isScalar, or, not],[Bool]]
[Lean.Lsp.DocumentHighlightKind.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.MapDeclarationExtension.contains,[Unit.unit, Bool, Lean.Environment.getModuleIdxFor?, Array.binSearchContains, Lean.PersistentEnvExtension.getModuleEntries, Prod.mk, arbitrary, Lean.Name.quickLt, Prod.fst, OfNat.ofNat, HSub.hSub, Array.size, Lean.NameMap.contains, Lean.SimplePersistentEnvExtension.getState],[Bool]]
[IO.Process.SpawnArgs.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Process.SpawnArgs.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Process.SpawnArgs.mk, And]]
[Int.subNatNat_add_left,[],[Eq, Int.subNatNat, HAdd.hAdd, Int.ofNat]]
[Fin.decLt,[Nat.decLt, Fin.val],[Decidable, LT.lt]]
[Lean.Parser.Tactic.nestedTactic.formatter,[Lean.Parser.Tactic.tacticSeqBracketed.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parsec.ws,[Lean.Parsec.ParseResult.success, Lean.Parsec.skipWs, Unit.unit],[Lean.Parsec, Unit]]
[not_imp_comm,[Decidable.not_imp_comm],[Iff]]
[Lean.SMap.toList,[Lean.SMap.fold, List.cons, Prod.mk, List.nil],[List, Prod]]
[Std.instToFormatString,[Std.ToFormat.mk, Std.Format.text],[Std.ToFormat, String]]
[Lean.KVMap.find,[Option, Lean.DataValue, Lean.KVMap.findCore],[Option, Lean.DataValue]]
[ST.Ref.swap,[liftM, ST.Prim.Ref.swap],[]]
[Lean.Meta.CaseArraySizesSubgoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.CaseArraySizesSubgoal.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.rwSearch,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.Parser.Tactic.rwRuleSeq],[Lean.ParserDescr]]
[Subarray.allM,[Array.allM, Subarray.as, Subarray.start, Subarray.stop],[Bool]]
[lt_or_gt_of_ne,[Or, LT.lt, GT.gt, lt_trichotomy, Or.inl, absurd, Or.inr],[Or, LT.lt, GT.gt]]
[Lean.Elab.Deriving.mkDiscr,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Lean.mkIdent],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Lean.Compiler.getNumLit,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Literal.strVal, Option, Nat, Option.some, ite, Eq, Lean.Compiler.isOfNat, Bool.true, PProd.fst, PProd.snd, Option.none],[Option, Nat]]
[Lean.Occurrences.neg.inj,[],[Eq]]
[Lean.IR.Borrow.ParamMap,[Std.HashMap, Lean.IR.Borrow.ParamMap.Key, Array, Lean.IR.Param],[]]
[instDivUInt64,[Div.mk, UInt64.div],[Div, UInt64]]
[Lean.Parsec.ParseResult.success.inj,[And.intro],[And, Eq]]
[IO.FS.DirEntry.noConfusionType,[],[]]
[Quotient.ind₂,[Quotient.ind],[]]
[Lean.IR.FnBody.jmp.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.jmp, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.FnBody.jmp, And]]
[UInt16.decLt,[Decidable, LT.lt, inferInstanceAs],[Decidable, LT.lt]]
[Lean.Parser.errorAtSavedPos,[Lean.Parser.Parser.mk, Lean.Parser.errorAtSavedPosFn],[Lean.Parser.Parser]]
[Lean.JsonRpc.Response.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.JsonRpc.Response.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.LocalContext.addParam,[Std.RBMap.insert, Lean.IR.VarId.idx, Lean.IR.Param.x, Lean.IR.LocalContextEntry.param, Lean.IR.Param.ty],[Lean.IR.LocalContext]]
[Lean.Meta.instMonadMCtxMetaM,[Lean.MonadMCtx.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Meta.State.mctx, modify, Lean.Meta.State.mk, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed],[Lean.MonadMCtx, Lean.Meta.MetaM]]
[Nonempty.elim,[Nonempty.elim.proof_1],[]]
[Lean.PrettyPrinter.Parenthesizer.parenthesizeCategoryCore,[MonadWithReader.withReader, Lean.PrettyPrinter.Parenthesizer.Context.mk, Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.visitArgs, Nat.forM, Array.size, Lean.Syntax.getArgs, Lean.PrettyPrinter.Parenthesizer.parenthesizerForKind, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.mkAntiquot.parenthesizer', Lean.Name.toString, Option.none],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.instToStringDataValue,[ToString.mk, Lean.DataValue.str],[ToString, Lean.DataValue]]
[instCommMonoid_1,[CommMonoid.mk, CommSemiring.mul_comm],[CommMonoid]]
[Lean.Parser.Command.openHiding.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.ident.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.PrettyPrinter.Formatter.checkColGt.formatter],[Lean.PrettyPrinter.Formatter]]
[StateCpsT.instMonadStateCpsT,[Monad.mk],[Monad, StateCpsT]]
[Lean.Parser.Term.attributes,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.sepBy1, Lean.Parser.Term.attrInstance, Bool.false],[Lean.Parser.Parser]]
[Lean.Elab.Command.instInhabitedInductiveView,[Inhabited.mk, Lean.Elab.Command.InductiveView.mk, arbitrary],[Inhabited, Lean.Elab.Command.InductiveView]]
[Iff.elim.proof_1,[Iff.mp, Iff.mpr],[]]
[Std.Format.joinSuffix,[Std.Format, Std.Format.nil, HAppend.hAppend, Std.ToFormat.format, PProd.fst],[Std.Format]]
[Array.instForInArray,[ForIn.mk, Array.forIn],[ForIn, Array]]
[Lean.Elab.expandDeclId,[Lean.Elab.ExpandDeclIdResult, ite, Eq, Lean.Syntax.isNone, Bool.true, Bind.bind, Pure.pure, Array.foldlM, OfNat.ofNat, Array.size],[Lean.Elab.ExpandDeclIdResult]]
[Lean.Parser.Term.prop.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[ExceptT,[Except],[]]
[Lean.Parser.Tactic.changeWith,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Mul.noConfusionType,[],[]]
[ShiftLeft.noConfusionType,[],[]]
[Lean.ExternEntry.standard.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.ExternEntry.standard, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Match.Unify.occurs,[Option.isSome, Lean.Expr.find?, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, BEq.beq, Bool.false],[Bool]]
[Functor.discard,[Functor.mapConst, PUnit.unit],[PUnit]]
[Lean.Meta.splitTarget?,[Lean.commitWhenSome?, Bind.bind, Lean.MonadEnv.getEnv, Lean.Meta.getMVarType, Lean.Meta.instantiateMVars, Option.none, Lean.Meta.MetaM, Option, List, Lean.MVarId, Lean.Meta.Split.findSplit?, ite, Eq, or, Lean.Expr.isIte, Lean.Expr.isDIte, Bool.true, Lean.Meta.splitIfTarget?, Pure.pure, Option.map, List.cons, Lean.Meta.ByCasesSubgoal.mvarId, List.nil, coeM, Lean.Meta.Split.splitMatch, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MessageData.ofGoal, PUnit.unit],[Lean.Meta.MetaM, Option, List, Lean.MVarId]]
[Lean.mkHole,[Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkAtomFrom, List.nil],[Lean.Syntax]]
[Function.update_comp_eq_of_forall_ne',[funext, Function.update_noteq],[Eq, Function.update]]
[Lean.Elab.Term.SavedContext.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.mapply',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Fin.modn.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod]]
[Lean.MessageDataContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MessageDataContext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MessageDataContext.mk, And]]
[Lean.Expr.FoldConstsImpl.fold,[Lean.Expr.FoldConstsImpl.fold.visit],[Lean.Expr.FoldConstsImpl.FoldM]]
[Substring.bsize,[Nat, Nat.sub],[Nat]]
[Lean.Elab.Term.ToParserDescrContext.mk.inj,[And.intro],[And, Eq]]
[plift.down_up,[rfl],[Eq, plift.down, plift.up]]
[Lean.profileitIOUnsafe,[EIO, Lean.profileit, unsafeEIO, Pure.pure, MonadExcept.throw],[EIO]]
[Fin.decLe,[Nat.decLe, Fin.val],[Decidable, LE.le]]
[lt_iff_le_not_le,[Preorder.lt_iff_le_not_le],[Iff, LT.lt, And, LE.le, Not]]
[Lean.Parser.Term.attrKind.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.scoped.formatter, Lean.Parser.Term.local.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.ToParserDescrContext.leftRec,[],[Bool]]
[Lean.IR.Borrow.ownParamsUsingArgs,[Nat.forM, Array.size, Lean.IR.Arg.irrelevant, Lean.IR.Borrow.M, Unit, Bind.bind, Lean.IR.Borrow.isOwned, ite, Eq, Bool.true, Lean.IR.Borrow.ownVar, Lean.IR.Param.x, Pure.pure, PUnit.unit, Unit.unit],[Lean.IR.Borrow.M, Unit]]
[UInt32.mul_def,[rfl],[Eq, HMul.hMul, UInt32.mk, UInt32.val]]
[Lean.Parser.Term.unreachable.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[UInt16.neg_def,[rfl],[Eq, Neg.neg, UInt16.mk, UInt16.val]]
[Lean.OpaqueVal.isUnsafeEx,[Lean.OpaqueVal.isUnsafe],[Bool]]
[Lean.Elab.Command.instMonadTraceCommandElabM,[Lean.MonadTrace.mk, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Bind.bind, MonadState.get, Pure.pure],[Lean.MonadTrace, Lean.Elab.Command.CommandElabM]]
[Lean.Parser.Command.addTacticDoc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[List.length,[Unit.unit, Nat, OfNat.ofNat, HAdd.hAdd, PProd.fst],[Nat]]
[Lean.Server.FileWorker.SemanticTokensState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.FileWorker.SemanticTokensState.mk, HAdd.hAdd, OfNat.ofNat]]
[Substring.noConfusionType,[],[]]
[Lean.Lsp.RpcReleaseParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.RpcReleaseParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.RpcReleaseParams.mk, And]]
[non_contradictory_intro,[absurd],[Not]]
[StateRefT'.set,[ST.Ref.set],[StateRefT', PUnit]]
[Array.forIn,[Array.size, Nat.le_refl, Array.forIn.loop],[]]
[Lean.Elab.MacroStackElem.noConfusionType,[],[]]
[Lean.Elab.Frontend.State.noConfusionType,[],[]]
[Lean.Elab.Tactic.evalIntro.introStep,[Lean.Elab.Tactic.liftMetaTactic, Bind.bind, Lean.Meta.intro, Lean.Meta.MetaM, List, Lean.MVarId, Pure.pure, List.cons, List.nil],[Lean.Elab.Tactic.TacticM, Unit]]
[instInhabitedUInt8.proof_1,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt8.size]]
[Lean.Elab.MacroStackElem.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.MacroStackElem.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.delabDo,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPNotation, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, guard, Eq, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Bool.true, Lean.PrettyPrinter.Delaborator.delabDoElems, Array.mapM, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, List.nil, Lean.Syntax.atom, Array.append],[Lean.PrettyPrinter.Delaborator.Delab]]
[Std.HashSet,[Subtype, Std.HashSetImp.WellFormed],[]]
[Lean.Elab.Command.StructFieldInfo.isFromParent,[Lean.Elab.Command.StructFieldKind.newField, Lean.Elab.Command.StructFieldKind.copiedField, Unit.unit, Lean.Elab.Command.StructFieldKind.subobject, Bool, Lean.Elab.Command.StructFieldInfo.kind, Bool.true, Bool.false],[Bool]]
[Lean.Parser.Term.doReassign.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.notFollowedByRedefinedTermToken.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.letIdDeclNoBinders.formatter, Lean.Parser.Term.letPatDecl.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.EnvExtensionInterfaceUnsafe.Ext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.EnvExtensionInterfaceUnsafe.Ext.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.EnvExtensionInterfaceUnsafe.Ext.mk, And]]
[Lean.Lsp.instToJsonRpcCallParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.RpcCallParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position, Lean.Lsp.RpcCallParams.sessionId, Lean.Lsp.RpcCallParams.method, Lean.Lsp.RpcCallParams.params],[Lean.ToJson, Lean.Lsp.RpcCallParams]]
[exists₃_congr,[exists_congr, exists₂_congr],[Iff, Exists]]
[Lean.DeclarationRange.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.instReprCongrLemma,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.Meta.CongrLemma.theoremName, Std.Format.line, Lean.Meta.CongrLemma.funName, Lean.Meta.CongrLemma.hypothesesPos, Lean.Meta.CongrLemma.priority],[Repr, Lean.Meta.CongrLemma]]
[IO.Error.otherError.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.otherError, HAdd.hAdd, OfNat.ofNat]]
[Lean.Exception.internal.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Exception.internal, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Exception.internal, And]]
[Array.instInhabitedArray,[Inhabited.mk, Array.empty],[Inhabited, Array]]
[Lean.Parser.leadingIdentBehavior,[Unit.unit, Lean.Parser.LeadingIdentBehavior, Lean.Parser.getCategory, Lean.Parser.ParserExtension.State.categories, Lean.ScopedEnvExtension.getState, Lean.Parser.parserExtension, Lean.Parser.LeadingIdentBehavior.default, Lean.Parser.ParserCategory.behavior],[Lean.Parser.LeadingIdentBehavior]]
[Array.filterSepElemsM,[OfNat.ofNat, List.toArray, List.nil],[Array, Lean.Syntax]]
[Lean.Elab.WF.TerminationStrategy.mk.inj,[And.intro],[And, Eq]]
[UInt64.neg_def,[rfl],[Eq, Neg.neg, UInt64.mk, UInt64.val]]
[Lean.Server.FileWorker.CancelToken.mk.inj,[],[Eq]]
[Lean.Meta.DefaultInstanceEntry.priority,[],[Nat]]
[not_imp_not,[Decidable.not_imp_not],[Iff, Not]]
[Lean.Meta.SortLocalDecls.State.mk.inj,[And.intro],[And, Eq]]
[coeFun,[CoeFun.coe],[]]
[Lean.Server.Snapshots.Snapshot.noConfusionType,[],[]]
[Lean.PrettyPrinter.Formatter.withAntiquotSuffixSplice.formatter,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, Lean.Syntax.isAntiquotSuffixSplice, Bool.true, Lean.PrettyPrinter.Formatter.visitArgs, SeqRight.seqRight],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.instFromJsonCompletionList,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Bool, Array, Lean.Lsp.CompletionItem, Pure.pure, Lean.Lsp.CompletionList.mk],[Lean.FromJson, Lean.Lsp.CompletionList]]
[Fin.mod,[Fin, Fin.mk, HMod.hMod, Fin.mod.proof_1],[Fin]]
[Lean.Parser.Term.elseIf,[Lean.Parser.atomic, Lean.Parser.group, Lean.Parser.withPosition, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.checkLineEq],[Lean.Parser.Parser]]
[Lean.Elab.Command.StructView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.StructView.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Command.StructView.mk, And]]
[Lean.NamePart.num.inj,[],[Eq]]
[instDecidableEqProd.proof_1,[rfl],[Eq, Prod.mk]]
[Lean.Elab.Command.elbChoice,[Lean.Syntax.getArgs, OfNat.ofNat],[Lean.Elab.Command.CommandElab]]
[Lean.Parser.Command.sample,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.IR.Checker.maxCtorScalarsSize,[Lean.IR.Checker.getMaxCtorScalarsSize, Unit.unit],[Nat]]
[Lean.Syntax.isAntiquot,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Syntax.atom, Lean.Syntax.ident, Bool, Bool.true, Bool.false],[Bool]]
[Nat.sub_lt_of_pos_le,[Nat.sub_lt, lt_of_lt_of_le],[LT.lt, HSub.hSub]]
[ByteArray.toList,[OfNat.ofNat, List.nil, ByteArray.toList.loop],[List, UInt8]]
[Lean.PrettyPrinter.Delaborator.whenPPOption,[Bind.bind, Lean.PrettyPrinter.Delaborator.getPPOption, ite, Eq, Bool.true, Alternative.failure],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.Meta.getDefaultInstances,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Option.getD, Lean.NameMap.find?, Lean.Meta.DefaultInstances.defaultInstances, Lean.SimplePersistentEnvExtension.getState, Lean.Meta.defaultInstanceExtension, List.nil],[List, Prod, Lean.Name, Nat]]
[Lean.IR.VarId.idx,[],[Lean.IR.Index]]
[Lean.Parser.Term.strictImplicitRightBracket.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.group.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Command.MkInstanceName.mkFreshInstanceName,[Bind.bind, MonadState.get, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, HAdd.hAdd, Lean.Elab.Command.State.nextInstIdx, OfNat.ofNat, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Pure.pure, Lean.Elab.mkFreshInstanceName],[Lean.Elab.Command.CommandElabM, Lean.Name]]
[Lean.Widget.TaggedText.appendTag,[dite, Eq, Unit.unit, Eq.symm, Lean.Widget.TaggedText.text, Lean.Widget.TaggedText.tag, Lean.Widget.TaggedText, Lean.Widget.TaggedText.append, Array.push, List.toArray, List.cons, List.nil],[Lean.Widget.TaggedText]]
[Lean.Elab.Term.applyAttributesAt,[Bind.bind, ForIn.forIn, PUnit.unit, Lean.MonadEnv.getEnv, Lean.Elab.Term.TermElabM, ForInStep, PUnit, Lean.getAttributeImpl, Lean.Elab.Attribute.name, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Pure.pure, ForInStep.yield, Unit.unit, liftM, Lean.AttributeImpl.add, Lean.Elab.Attribute.stx, Lean.Elab.Attribute.kind, ite, Eq, BEq.beq, Lean.AttributeImplCore.applicationTime, Lean.AttributeImpl.toAttributeImplCore, Bool.true, Option.some],[Lean.Elab.Term.TermElabM, Unit]]
[Array.getEvenElems,[Prod.snd, Array.foldl, Prod, Bool, Array, ite, Eq, Bool.true, Prod.mk, Bool.false, Array.push, Array.empty, OfNat.ofNat, Array.size],[Array]]
[List.mem_reverseAux,[Iff, Mem.mem, List.reverseAux, Or, of_eq_true, Eq.trans, congrArg, congrFun, propext, List.mem_nil_iff, false_or, iff_self, Eq.mpr, congr, PProd.fst, List.cons, List.mem_cons_iff, Eq.refl, Eq, Eq.symm, or_assoc, or_comm, Iff.rfl],[Iff, Mem.mem, List.reverseAux, Or]]
[IO.Error.interrupted.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.interrupted, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.interrupted, And]]
[Lean.QuotVal.kindEx,[Lean.QuotVal.kind],[Lean.QuotKind]]
[Lean.LocalContext.foldrM,[Std.PersistentArray.foldrM, Lean.LocalContext.decls, Unit.unit, Pure.pure],[]]
[Lean.Expr.mdata.inj,[And.intro],[And, Eq]]
[Nat.mul_div_right,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HDiv.hDiv, HMul.hMul, Nat.zero_eq, Nat.mul_zero, Nat.zero_div, eq_true_of_decide, Eq.refl, Bool.true, Nat.mul_succ, Nat.add_div_right, eq_true, Nat.succ, eq_self],[Eq, HDiv.hDiv, HMul.hMul]]
[Std.termF!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.profileitM,[MonadFunctorT.monadMap, Lean.profileitIO],[]]
[Lean.Meta.Simp.getSimpLemmas,[Bind.bind, readThe, Lean.Meta.Simp.Context, Pure.pure, Lean.Meta.Simp.Context.simpLemmas],[Lean.Meta.Simp.M, Lean.Meta.SimpLemmas]]
[Lean.MacroScope,[Nat],[]]
[Lean.Meta.NormNum.instLawfulOfNatInt.proof_1,[Lean.Meta.NormNum.LawfulOfNat.mk, rfl],[Lean.Meta.NormNum.LawfulOfNat, Int]]
[Lean.Meta.Simp.getSimpLetCase,[Lean.Meta.withLocalDeclD, Bind.bind, Lean.Meta.isTypeCorrect, ite, Eq, Bool.true, Lean.Meta.inferType, Lean.Meta.whnf, Lean.Meta.dependsOn, Lean.Expr.fvarId!, Pure.pure, Lean.Meta.Simp.SimpLetCase.nondepDepVar, Lean.Meta.Simp.SimpLetCase.nondep, Lean.Meta.Simp.SimpLetCase.dep],[Lean.Meta.MetaM, Lean.Meta.Simp.SimpLetCase]]
[Lean.Elab.Command.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Command.macro,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.suppressInsideQuot, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.docComment, Lean.Parser.Term.attrKind, Lean.Parser.symbol, Lean.Parser.optPrecedence, Lean.Parser.Command.optNamedName, Lean.Parser.Command.optNamedPrio, Lean.Parser.many1, Lean.Parser.Command.macroArg, Lean.Parser.Command.macroTail],[Lean.Parser.Parser]]
[IO.Process.Output.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Process.Output.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Process.Output.mk, And]]
[Lean.Meta.withTrackingZeta,[Lean.Meta.withConfig, Lean.Meta.Config.mk, Lean.Meta.Config.foApprox, Lean.Meta.Config.ctxApprox, Lean.Meta.Config.quasiPatternApprox, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Bool.true, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct],[]]
[Lean.Elab.Term.Do.ToCodeBlock.M,[ReaderT, Lean.Elab.Term.Do.ToCodeBlock.Context, Lean.Elab.Term.TermElabM],[]]
[Lean.Widget.msgToInteractiveDiagnostic,[Bind.bind, MonadExcept.tryCatch, Lean.Widget.msgToInteractive, Lean.Message.data, OfNat.ofNat, Pure.pure, Lean.Widget.TaggedText.text, HAppend.hAppend, ToString.toString, IO.Error.toString],[IO, Lean.Widget.InteractiveDiagnostic]]
[System.FilePath.toString,[],[String]]
[Lean.Lsp.DefinitionParams.toTextDocumentPositionParams,[],[Lean.Lsp.TextDocumentPositionParams]]
[instToStringFloatArray,[ToString.mk, List.toString, FloatArray.toList],[ToString, FloatArray]]
[Lean.Meta.Match.mkMatcherAuxDefinition,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.Meta.MetaM, Prod, Lean.Expr, Option, Unit]]
[Lean.AttributeExtension,[Lean.PersistentEnvExtension, Lean.AttributeExtensionOLeanEntry, Prod, Lean.AttributeImpl, Lean.AttributeExtensionState],[]]
[List.removeAll,[List.filter, List.notElem],[List]]
[Lean.Parser.getCategory,[Std.PersistentHashMap.find?],[Option, Lean.Parser.ParserCategory]]
[Lean.Lsp.StaticRegistrationOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.StaticRegistrationOptions.mk, HAdd.hAdd, OfNat.ofNat]]
[apply_ite,[apply_dite],[Eq, ite]]
[Lean.IR.EmitC.emitArg,[Lean.IR.EmitC.emit, Lean.IR.EmitC.argToCString],[Lean.IR.EmitC.M, Unit]]
[Lean.Parser.Command.reassoc_axiom,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Meta.SynthInstance.isNewAnswer,[Array.all, bne, Lean.Meta.SynthInstance.Answer.resultType, OfNat.ofNat, Array.size],[Bool]]
[Lean.PrettyPrinter.Formatter.visitAtom,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, bne, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Formatter.checkKind, Pure.pure, PUnit.unit],[Lean.PrettyPrinter.Formatter]]
[NeqIffBeqFalse,[Iff.intro, decide_eq_false, of_decide_eq_false],[Iff, Ne, Eq, BEq.beq, Bool.false]]
[Lean.instToFormatDataValue,[Std.ToFormat.mk, Std.Format, Std.ToFormat.format, repr, HAppend.hAppend, Std.Format.text],[Std.ToFormat, Lean.DataValue]]
[Lean.Elab.Term.StructInst.elabStructInst,[Bind.bind, ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, Option.none, Lean.Syntax.isMissing, Lean.Elab.throwAbortTerm, PUnit.unit, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Syntax, Lean.Syntax.setArg, OfNat.ofNat, Lean.Syntax.getOp, Lean.Elab.Term.isLocalIdent?, Option.isSome, PProd.fst, Array.push, Lean.MonadQuotation.withFreshMacroScope, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Lean.Expr, Lean.Elab.Term.withMacroExpansion, Lean.Elab.Term.elabTerm, Lean.withRef, and, Lean.Elab.Term.StructInst.Source.none, Lean.Elab.Term.StructInst.Source.implicit, Array.mapM, Lean.Elab.Term.StructInst.ExplicitSourceInfo, liftM, Lean.Meta.inferType, Lean.Meta.whnf, Lean.Elab.Term.tryPostponeIfMVar, Lean.Meta.getStructureName, Lean.Elab.Term.StructInst.ExplicitSourceInfo.mk, panicWithPosWithDecl, Lean.Syntax.getSepArgs, Lean.Elab.Term.StructInst.Source.explicit, Lean.throwError, Lean.ToMessageData.toMessageData, Array.foldlM, BEq.beq, Lean.Syntax.getKind, Option, Option.some, Lean.throwErrorAt, Lean.Syntax.getArgs, Array.size, GT.gt, Lean.Elab.Term.tryPostponeIfNoneOrMVar, Lean.Name, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr.getAppFn, Lean.MonadEnv.getEnv, Lean.isStructure, HAppend.hAppend, Lean.indentExpr, Lean.Meta.instantiateMVars, Lean.Expr.isMVar, Lean.Elab.liftMacroM, List.mapM, Lean.Elab.Term.StructInst.FieldLHS.modifyOp, Lean.Syntax.isIdent, Lean.Elab.Term.StructInst.FieldLHS.fieldName, Lean.Name.eraseMacroScopes, Lean.Syntax.getId, Lean.MacroM, Lean.Elab.Term.StructInst.FieldLHS, Lean.Syntax.isFieldIdx?, Lean.Elab.Term.StructInst.FieldLHS.fieldIndex, Lean.Macro.throwError, Array.toList, Lean.Elab.Term.StructInst.Field.mk, Lean.Elab.Term.StructInst.FieldVal.term, Lean.Elab.Term.StructInst.Struct.mk, Lean.isTracingEnabledFor, Lean.addTrace],[Lean.Elab.Term.TermElab]]
[instDecidableAnd.proof_1,[And.right],[False]]
[Lean.Expr.hasSorry,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.lit, Bool, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, or, PProd.fst, PProd.snd, Bool.false],[Bool]]
[Lean.Elab.Attribute.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Attribute.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Attribute.mk, And]]
[instSemiringFin.proof_6,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, OfNat.ofNat, add_comm, instSemiringFin.proof_1],[Eq, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.completion.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[instBEqOrdering,[BEq.mk, BEq.beq, Ordering.toCtorIdx],[BEq, Ordering]]
[Lean.Server.FileWorker.handleReferences.referencesTo,[Array, Lean.Lsp.Location, List.toArray, List.eraseDups, Array.toList],[Array, Lean.Lsp.Location]]
[Lean.instInhabitedReducibilityStatus,[Inhabited.mk, Lean.ReducibilityStatus.reducible],[Inhabited, Lean.ReducibilityStatus]]
[Array.eraseIdx,[ite, LT.lt, Array.size, Array.eraseIdxAux, HAdd.hAdd, OfNat.ofNat],[Array]]
[Lean.profileit,[Unit.unit],[]]
[Quotient.recOnSubsingleton₂.proof_1,[Quot.recOnSubsingleton],[Subsingleton, Quot.mk, Setoid.r]]
[Command.simpsRule.rename,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.IR.FnBody.mapVars,[Lean.IR.MapVars.mapFnBody],[Lean.IR.FnBody]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.analyzeFVar,[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.maybeAddBlockImplicit],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM, Unit]]
[Lean.Syntax.formatStx,[Lean.Syntax.formatStxAux, OfNat.ofNat],[Std.Format]]
[bne,[not, BEq.beq],[Bool]]
[IO.print,[Bind.bind, liftM, IO.getStdout, IO.FS.Stream.putStr, ToString.toString],[IO, Unit]]
[Lean.PrettyPrinter.Formatter.mkAntiquot.formatter,[Lean.Parser.mkAntiquot.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.FunInfo.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.Term.toParserDescr.processAtom,[Unit.unit, Lean.Elab.Term.ToParserDescrM, Lean.Syntax, Lean.Syntax.isStrLit?, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, Lean.Elab.Term.toParserDescr.isValidAtom, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.ToParserDescrM, Lean.Syntax]]
[AddCommGroup.add_comm,[],[Eq, HAdd.hAdd]]
[Lean.Parser.Command.genInjectiveTheorems,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident],[Lean.Parser.Parser]]
[IO.Process.Output.exitCode,[],[UInt32]]
[Lean.Parser.Term.hole,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Int.mul_comm,[Eq, HMul.hMul, of_eq_true, Eq.trans, congr, congrArg, Int.ofNat_mul_ofNat, Int.ofNat, Nat.mul_comm, eq_self, Eq.symm, Int.ofNat_mul_negSucc_ofNat, Int.negSucc_ofNat_ofNat, Int.negOfNat, Nat.succ, Eq.refl, Int.mul_negSucc_ofNat_negSucc_ofNat],[Eq, HMul.hMul]]
[Lean.Lsp.instToJsonClientInfo,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.ClientInfo.name, List.nil, Lean.Json.opt, Lean.Lsp.ClientInfo.version?],[Lean.ToJson, Lean.Lsp.ClientInfo]]
[Lean.Elab.Command.Linter,[Lean.Elab.Command.CommandElabM, Unit],[]]
[forall_congr',[Iff.intro, Iff.mp, Iff.mpr],[Iff]]
[MonadLiftT.monadLift,[],[]]
[HEq.noConfusionType,[],[]]
[Lean.Expr.findMVar?,[Lean.FindMVar.main, Option.none],[Option, Lean.MVarId]]
[Lean.Elab.Term.MutualClosure.LetRecClosure.localDecls,[],[Array, Lean.LocalDecl]]
[Inv.noConfusionType,[],[]]
[Lean.ParserCompiler.Context.tyName,[Lean.KeyedDeclsAttribute.Def.valueTypeName, Lean.KeyedDeclsAttribute.defn, Lean.ParserCompiler.Context.categoryAttr],[Lean.Name]]
[Lean.JsonRpc.Message.request.inj,[And.intro],[And, Eq]]
[Lean.PrettyPrinter.Delaborator.delabOfScientific,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPCoercions, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, guard, Eq, BEq.beq, Lean.Expr.getAppNumArgs, OfNat.ofNat, Bool.true, Pure.pure, Lean.Expr.getArg!, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.strVal, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Lean.Name.anonymous, Lean.Name.str, dite, Eq.symm, Lean.Name.num, Bool.false, Alternative.failure],[Lean.PrettyPrinter.Delaborator.Delab]]
[Lean.Lsp.TextDocumentRegistrationOptions.noConfusionType,[],[]]
[Lean.Parser.ParserExtension.State.kinds,[],[Lean.Parser.SyntaxNodeKindSet]]
[Lean.IR.DeclMap,[Lean.SMap, Lean.Name, Lean.IR.Decl],[]]
[Lean.Lsp.instFromJsonDefinitionParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.DefinitionParams.mk, Lean.Lsp.TextDocumentPositionParams.mk],[Lean.FromJson, Lean.Lsp.DefinitionParams]]
[Lean.IR.IRType.uint32.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.IR.IRType.uint32, OfNat.ofNat]]
[Fin.lor,[Fin, Fin.mk, HMod.hMod, Nat.lor, Fin.lor.proof_1],[Fin]]
[Lean.Elab.Term.StructInst.instToFormatFieldLHS,[Std.ToFormat.mk, Std.Format, Std.ToFormat.format, HAppend.hAppend, Std.Format.text, Lean.Syntax.prettyPrint],[Std.ToFormat, Lean.Elab.Term.StructInst.FieldLHS]]
[Lean.Meta.Closure.collectLevel,[Lean.Meta.Closure.visitLevel, Lean.Meta.Closure.collectLevelAux],[Lean.Meta.Closure.ClosureM, Lean.Level]]
[Prod.fst_surjective,[Nonempty.elim, Exists.intro, Prod.mk, rfl],[Function.surjective, Prod.fst]]
[Lean.Parser.Term.quotedName.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.nameLit.formatter],[Lean.PrettyPrinter.Formatter]]
[Or.resolve_left,[Or.elim, absurd, id],[]]
[Lean.BinderInfo.noConfusionType,[noConfusionTypeEnum, Lean.BinderInfo.toCtorIdx],[]]
[Lean.PrettyPrinter.Formatter.many1NoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.manyNoAntiquot.formatter],[Lean.PrettyPrinter.Formatter]]
[«termΣ'_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.QuotVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.QuotVal.mk, HAdd.hAdd, OfNat.ofNat]]
[Subtype.property,[],[Subtype.val]]
[Prod.mk.inj,[And.intro],[And, Eq]]
[Lean.getPPMotivesNonConst,[Lean.KVMap.get, Lean.Option.name, Lean.pp.motives.nonConst, Lean.Option.defValue],[Bool]]
[Lean.Environment.addAndCompile,[Bind.bind, Lean.Environment.addDecl, Lean.Environment.compileDecl],[Except, Lean.KernelException, Lean.Environment]]
[Lean.Elab.addCompletionInfo,[Lean.Elab.pushInfoLeaf, Lean.Elab.Info.ofCompletionInfo],[Unit]]
[Lean.instInhabitedJson,[Inhabited.mk, Lean.Json.null],[Inhabited, Lean.Json]]
[String.Iterator.hasNext,[Bool, Decidable.decide, LT.lt, String.utf8ByteSize],[Bool]]
[PSigma.fst,[],[]]
[Lean.Elab.Deriving.DecEq.mkEnumOfNatThm,[Bind.bind, Lean.getConstInfoInduct, Lean.Meta.withLocalDeclD, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.mkLambdaFVars, List.toArray, List.cons, List.nil, Bool.false, Bool.true, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Meta.mkForallFVars, Lean.addAndCompile, Lean.Declaration.thmDecl, Lean.TheoremVal.mk, Lean.ConstantVal.mk],[Lean.Meta.MetaM, Unit]]
[«term_∨_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Elab.Term.Do.ToCodeBlock.Context.noConfusionType,[],[]]
[Lean.Meta.CongrLemma.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.CongrLemma.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.CongrLemma.mk, And]]
[Lean.Parsec.manyChars,[Lean.Parsec.manyCharsCore],[Lean.Parsec, String]]
[Lean.Server.Watchdog.OpenDocument.headerAst,[],[Lean.Syntax]]
[Lean.Meta.Closure.ToProcessElement.fvarId,[],[Lean.FVarId]]
[Array.foldrM.fold.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self],[LE.le, Array.size]]
[Lean.Parser.Tactic.swap,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const],[Lean.ParserDescr]]
[instMonadWithReaderOf,[MonadWithReaderOf.mk, MonadFunctorT.monadMap, withTheReader],[MonadWithReaderOf]]
[Nat.add_mul_mod_self_right,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, HMul.hMul, Nat.mul_comm, Nat.add_mul_mod_self_left, rfl],[Eq, HMod.hMod, HAdd.hAdd, HMul.hMul]]
[Lean.Lsp.InitializeParams.rootUri?,[],[Option, String]]
[Lean.Elab.Term.ExtractMonadResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.ExtractMonadResult.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.RequestM.readDoc,[Pure.pure, Lean.Server.RequestContext.doc],[Lean.Server.RequestM, Lean.Server.FileWorker.EditableDocument]]
[add_assoc,[AddSemigroup.add_assoc],[Eq, HAdd.hAdd]]
[Nat.le_of_sub_eq_zero,[Nat.zero, Nat.succ, LE.le, of_eq_true, Eq.trans, congrFun, congrArg, Eq.mp, Eq.refl, Eq, HSub.hSub, OfNat.ofNat, Nat.sub_zero, eq_true_of_decide, Bool.true, Nat.zero_le, HAdd.hAdd, Nat.add_le_add_right, PProd.fst, Nat.add_sub_add_right],[LE.le]]
[Lean.Syntax.getQuotContent,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Syntax]]
[Lean.Environment.declsInModuleIdx,[Std.HashMap.fold, ite, Eq, List.cons, List.nil, Lean.Environment.const2ModIdx],[List, Lean.Name]]
[Lean.Json.escape,[String.foldl, ite, Eq, Char.ofNat, HAppend.hAppend, And, LE.le, OfNat.ofNat, Char.val, String.singleton, List.asString, List.cons, Nat.digitChar, HDiv.hDiv, HMod.hMod, List.nil],[String]]
[Nat.dvd_iff_mod_eq_zero,[Iff.intro, Nat.mod_eq_zero_of_dvd, Nat.dvd_of_mod_eq_zero],[Iff, Dvd.dvd, Eq, HMod.hMod, OfNat.ofNat]]
[Lean.ClassEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ClassEntry.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ClassEntry.mk, And]]
[Lean.isBuiltinAttribute,[Bind.bind, ST.Ref.get, Lean.attributeMapRef, Pure.pure, Std.PersistentHashMap.contains],[IO, Bool]]
[le_refl,[Preorder.le_refl],[LE.le]]
[Lean.Lsp.instToJsonSemanticTokensOptions,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.SemanticTokensOptions.legend, List.nil, Lean.Lsp.SemanticTokensOptions.range, Lean.Lsp.SemanticTokensOptions.full],[Lean.ToJson, Lean.Lsp.SemanticTokensOptions]]
[Bool.true_and,[rfl, Eq.symm, Eq.refl],[Eq, and, Bool.true]]
[Lean.IR.FnBody.vdecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.FnBody.vdecl, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.doIdDecl.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.Term.optType.formatter, Lean.Parser.Term.leftArrow.formatter, Lean.Parser.doElemParser.formatter],[Lean.PrettyPrinter.Formatter]]
[IO.FS.Stream.writeLspRequest,[IO.FS.Stream.writeLspMessage, Lean.JsonRpc.Message.request, Lean.JsonRpc.Request.id, Lean.JsonRpc.Request.method, Except.toOption, Lean.Json.toStructured?, Lean.JsonRpc.Request.param],[IO, Unit]]
[Nat.gcd_eq_left_iff_dvd,[Iff.intro, Eq.mpr, Eq.refl, Eq, Nat.gcd, Nat.gcd_rec, HMod.hMod, Nat.mod_eq_zero_of_dvd, OfNat.ofNat, Nat.gcd_zero_left, rfl, Nat.gcd_dvd_right],[Iff, Dvd.dvd, Eq, Nat.gcd]]
[EIO.toIO',[liftM, EIO.toBaseIO],[IO, Except]]
[Lean.Parser.Term.funStrictImplicitBinder,[HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.lookahead, Lean.Parser.Term.strictImplicitLeftBracket, Lean.Parser.many1, Lean.Parser.Term.binderIdent, HOrElse.hOrElse, Lean.Parser.symbol, Lean.Parser.Term.strictImplicitRightBracket, Lean.Parser.Term.strictImplicitBinder, Bool.false],[Lean.Parser.Parser]]
[Lean.Lsp.Range.end,[],[Lean.Lsp.Position]]
[Lean.Parser.rawIdentFn,[ite, Eq, String.atEnd, Bool.true, Lean.Parser.ParserState.mkEOIError, List.nil, Lean.Parser.identFnAux, Option.none, Lean.Name.anonymous],[Lean.Parser.ParserFn]]
[Lean.instInhabitedData,[inferInstanceAs, Inhabited, UInt64],[Inhabited, Lean.Level.Data]]
[Lean.SimpleScopedEnvExtension.Descr.mk.inj,[And.intro],[And, Eq]]
[Nat.gcd.induction,[WellFounded.induction, WellFoundedRelation.wf, Nat.lt_wfRel, HAdd.hAdd, OfNat.ofNat, Nat.succ_pos, HMod.hMod, Nat.mod_lt],[]]
[Lean.NameHashSet.insert,[Std.HashSet.insert],[Std.HashSet, Lean.Name]]
[Lean.Expr.data,[Lean.Expr.Data],[Lean.Expr.Data]]
[Lean.Parser.Term.macroLastArg.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.macroDollarArg.formatter, Lean.Parser.Term.macroArg.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.GeneralizeArg.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.GeneralizeArg.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.GeneralizeArg.mk, And]]
[Lean.Parser.Tactic.tacticSeq1Indented.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.many1Indent.parenthesizer, Lean.Parser.group.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.Parser.tacticParser.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Array.findSomeRevM?.find.proof_1,[Nat.lt_of_lt_of_le, Nat.lt_succ_self],[LT.lt, Array.size]]
[DoResultPRBC.return.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultPRBC.return, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.symbolInfo,[Lean.Parser.ParserInfo.mk, List.cons, Lean.Parser.FirstTokens.tokens, List.nil],[Lean.Parser.ParserInfo]]
[UInt32.instSemiringUInt32.proof_10,[rfl],[Eq, Nat.succ]]
[Lean.Elab.Level.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.DefinitionParams.noConfusionType,[],[]]
[Std.Format.prefixJoin,[Unit.unit, Std.Format, Std.Format.nil, HAppend.hAppend, Std.ToFormat.format, PProd.fst],[Std.Format]]
[Lean.IR.ExpandResetReuse.Mask,[Array, Option, Lean.IR.VarId],[]]
[Function.right_inverse.injective,[Function.left_inverse.injective, Function.right_inverse.left_inverse],[Function.injective]]
[Lean.MonadQuotation.addMacroScope,[Bind.bind, Lean.MonadQuotation.getMainModule, Lean.MonadQuotation.getCurrMacroScope, Pure.pure, Lean.addMacroScope],[Lean.Name]]
[Classical.byCases,[Decidable.byCases],[]]
[Lean.Constructor.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Constructor.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Constructor.mk, And]]
[Lean.Parser.Tactic.elementwise,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Server.FileWorker.GoToKind.definition.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Server.FileWorker.GoToKind.definition, OfNat.ofNat]]
[Std.PersistentHashMap.isUnaryNode,[Option, Prod, Std.PersistentHashMap.isUnaryEntries, OfNat.ofNat, Option.none, dite, Eq, Array.size],[Option, Prod]]
[Nat.min_zero,[min_eq_right, Nat.zero_le],[Eq, Nat.min, OfNat.ofNat]]
[Lean.Parser.Attr.higherOrder,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Json.arr.inj,[],[Eq]]
[instDecidableEqProd.proof_3,[absurd],[False]]
[iff_def,[iff_iff_implies_and_implies],[Iff, And]]
[IO.Error.mkAlreadyExists,[IO.Error.alreadyExists, Option.none],[IO.Error]]
[Array.ext.extAux,[rfl, Eq.symm, Eq.mp, Eq.refl, Eq, List.length, List.nil, List.cons, List.length_cons],[Eq]]
[Lean.Parser.ParserExtension.Entry.parser.inj,[And.intro],[And, Eq]]
[Lean.IR.UnreachableBranches.InterpContext.env,[],[Lean.Environment]]
[Lean.Meta.SortLocalDecls.State.noConfusionType,[],[]]
[Lean.IR.UnboxResult.hasUnboxAttr,[Lean.TagAttribute.hasTag, Lean.IR.UnboxResult.unboxAttr],[Bool]]
[Std.instInhabitedPersistentArray,[Inhabited.mk, Std.PersistentArray.mk, arbitrary],[Inhabited, Std.PersistentArray]]
[Lean.Parser.Command.classInductive.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.Command.optDeclSig.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.Command.ctor.parenthesizer, Lean.Parser.Command.optDeriving.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.Simp.Config.maxSteps,[],[Nat]]
[HasEquiv.Equiv,[],[]]
[MonadControl.noConfusionType,[],[]]
[Lean.Elab.Term.StructInst.FieldLHS.fieldIndex.inj,[And.intro],[And, Eq]]
[Ordering.eq.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Ordering.eq, OfNat.ofNat]]
[Lean.Elab.Tactic.liftMetaMAtMain,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM],[Lean.Elab.Tactic.TacticM]]
[Lean.Level.updateIMax,[Lean.mkLevelIMax'],[Lean.Level]]
[gt_of_gt_of_ge,[lt_of_le_of_lt],[GT.gt]]
[BaseIO,[EIO, Empty],[]]
[Nat.gcd_gcd_self_left_left,[Eq.mpr, Eq.refl, Eq, Nat.gcd, Nat.gcd_comm, Nat.gcd_gcd_self_left_right, rfl],[Eq, Nat.gcd]]
[Lean.Parser.doElemParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.PrettyPrinter.Formatter]]
[Nat.forRevM.loop,[Unit.unit, Unit, Pure.pure, Bind.bind, PProd.fst],[Unit]]
[Lean.Parser.Term.ensureTypeOf.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.strLit.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Level.depthEx,[Lean.Level.Data.depth, Lean.Level.data],[UInt32]]
[Lean.PrettyPrinter.Parenthesizer.numLitNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken],[Lean.PrettyPrinter.Parenthesizer]]
[ne_true_of_not,[],[Ne, True]]
[Lean.catchInternalId,[MonadExcept.tryCatch, MonadExcept.throw, ite, Eq, BEq.beq, Bool.true],[]]
[Lean.MetavarContext.isLevelAssigned,[Std.PersistentHashMap.contains, Lean.MetavarContext.lAssignment],[Bool]]
[Lean.MetavarContext.isAnonymousMVar,[Unit.unit, Bool, Lean.MetavarContext.findDecl?, Bool.false, Lean.Name.isAnonymous, Lean.MetavarDecl.userName],[Bool]]
[Lean.Position.instToStringPosition,[ToString.mk, String, HAppend.hAppend, ToString.toString],[ToString, Lean.Position]]
[Lean.Meta.Contradiction.Config.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Contradiction.Config.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.MessageLog.toList,[List.reverse, Std.PersistentArray.foldl, Lean.MessageLog.msgs, List.cons, List.nil, OfNat.ofNat],[List, Lean.Message]]
[Lean.Server.FileWorker.CancelToken.set,[ST.Ref.set, Lean.Server.FileWorker.CancelToken.ref, Bool.true],[IO, Unit]]
[Lean.Elab.PreDefinition.ref,[],[Lean.Syntax]]
[Lean.EnvExtension.setState,[Lean.EnvExtensionInterface.setState, Lean.EnvExtensionInterfaceImp],[Lean.Environment]]
[Lean.Meta.DiscrTree.getUnify,[Lean.Meta.withReducible, Bind.bind, ite, Eq, Bool.true, Lean.Expr.bvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.mdata, Lean.Meta.MetaM, Prod, Lean.Meta.DiscrTree.Key, Array, Lean.Expr, Lean.Expr.getAppFn, Pure.pure, Prod.mk, Lean.Meta.DiscrTree.Key.lit, List.toArray, List.nil, Lean.Meta.DiscrTree.Key.const, Lean.Expr.getAppRevArgs, Lean.Meta.DiscrTree.Key.fvar, Lean.Meta.DiscrTree.Key.other, MonadReader.read, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Context.config, Lean.Meta.DiscrTree.Key.star, Lean.Meta.isReadOnlyOrSyntheticOpaqueExprMVar, Lean.Meta.DiscrTree.Key.proj, List.cons, Lean.Expr.hasLooseBVars, Lean.Meta.DiscrTree.Key.arrow, Bool.false, Unit.unit, Std.PersistentHashMap.foldlM, Lean.Meta.DiscrTree.root, Lean.Meta.DiscrTree.Key.arity, Std.PersistentHashMap.find?, OfNat.ofNat, Lean.Meta.DiscrTree.getUnify.process],[Lean.Meta.MetaM, Array]]
[mul_right_cancel_iff,[Iff.intro, mul_right_cancel, rfl],[Iff, Eq, HMul.hMul]]
[Lean.Elab.DefKind.def.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.DefKind.def, OfNat.ofNat]]
[Lean.Elab.Term.tryCoeThunk?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Elab.Term.TermElabM, Option, Lean.Expr, Bind.bind, liftM, Lean.Meta.isDefEq, ite, Bool.true, Pure.pure, Option.some, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.mkSimpleThunk, Option.none],[Lean.Elab.Term.TermElabM, Option, Lean.Expr]]
[Lean.BinderInfo.isExplicit,[Lean.BinderInfo.default, Unit.unit, Lean.BinderInfo.auxDecl, Bool, Bool.false, Bool.true],[Bool]]
[Lean.ScopedEnvExtension.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ScopedEnvExtension.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ScopedEnvExtension.State.mk, And]]
[Lean.IR.ExplicitBoxing.visitVDeclExpr,[Lean.IR.Expr.reset, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Lean.IR.ExplicitBoxing.M, Lean.IR.FnBody, ite, Eq, and, Lean.IR.CtorInfo.isScalar, Lean.IR.IRType.isScalar, Bool.true, Pure.pure, Lean.IR.FnBody.vdecl, Lean.IR.LitVal.num, Lean.IR.CtorInfo.cidx, Lean.IR.ExplicitBoxing.boxArgsIfNeeded, Lean.IR.Expr.ctor, Lean.IR.Expr.reuse, Bind.bind, Lean.IR.ExplicitBoxing.getDecl, Lean.IR.ExplicitBoxing.castArgsIfNeeded, Lean.IR.Decl.params, Lean.IR.ExplicitBoxing.castResultIfNeeded, Lean.IR.Expr.fap, Lean.IR.Decl.resultType, Lean.IR.ExplicitBoxing.getEnv, Lean.IR.Expr.pap, Lean.IR.ExplicitBoxing.unboxResultIfNeeded, Lean.IR.Expr.ap],[Lean.IR.ExplicitBoxing.M, Lean.IR.FnBody]]
[instDecidableEqProd,[Decidable, Eq, Prod.mk, decEq, Decidable.isTrue, instDecidableEqProd.proof_1, Decidable.isFalse, instDecidableEqProd.proof_2, instDecidableEqProd.proof_3],[DecidableEq, Prod]]
[Lean.Elab.Term.MVarErrorKind.hole.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Term.MVarErrorKind.hole, OfNat.ofNat]]
[List.format,[Unit.unit, List.cons, Std.Format, Std.Format.text, Std.Format.sbracket, Std.Format.joinSep, HAppend.hAppend, Std.Format.line],[Std.Format]]
[Int.add_right_neg,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat, Int.add_comm, Int.add_left_neg, rfl],[Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat]]
[Lean.Elab.Term.LetRecToLift.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.LetRecToLift.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Compiler.CSimp.State,[Lean.SMap, Lean.Name],[]]
[Lean.Elab.Term.StructInst.FieldVal.nested.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.StructInst.FieldVal.nested, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.SortLocalDecls.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.SortLocalDecls.Context.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.SortLocalDecls.Context.mk]]
[Lean.Elab.checkSyntaxNodeKindAtCurrentNamespaces,[Bind.bind, MonadReader.read, Lean.Elab.checkSyntaxNodeKindAtNamespaces, Lean.Core.Context.currNamespace],[Lean.AttrM, Lean.Name]]
[IO.AsyncList.instCoeListAsyncList,[Coe.mk, IO.AsyncList.ofList],[Coe, List, IO.AsyncList]]
[Lean.Parser.withAntiquotSpliceAndSuffix.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquotSplice.formatter, Lean.PrettyPrinter.Formatter.withoutInfo.formatter, Lean.PrettyPrinter.Formatter.withAntiquotSuffixSplice.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Tactic.equivRwType,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Command.terminationBy,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.terminationHint, Lean.Parser.termParser],[Lean.Parser.Parser]]
[StateCpsT.runK_bind_lift,[rfl],[Eq, StateCpsT.runK, Bind.bind, StateCpsT.lift]]
[Lean.PrettyPrinter.Parenthesizer.fieldIdx.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.CtorInfo.isScalar,[not, Lean.IR.CtorInfo.isRef],[Bool]]
[UInt64.decEq.proof_2,[absurd],[False]]
[Nat.mul_dvd_mul_left,[Nat.mul_dvd_mul, Nat.dvd_refl],[Dvd.dvd, HMul.hMul]]
[Prod.fst_injective,[Prod.ext', Subsingleton.elim, Prod.snd],[Function.injective, Prod.fst]]
[Lean.Server.Watchdog.ServerContext.args,[],[List, String]]
[Lean.Elab.Term.LetRecToLift.ref,[],[Lean.Syntax]]
[List.forM_nil,[rfl],[Eq, ForM.forM, List.nil, Pure.pure, PUnit.unit]]
[Lean.Elab.Term.StructInst.Source.none.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Elab.Term.StructInst.Source.none, OfNat.ofNat]]
[Lean.Meta.SynthInstance.getInstances,[Bind.bind, Lean.Meta.getLocalInstances, Lean.Meta.forallTelescopeReducing, Lean.Meta.isClass?, Unit.unit, Lean.Meta.MetaM, Array, Lean.Expr, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, liftM, Lean.Meta.getGlobalInstancesIndex, Lean.Meta.DiscrTree.getUnify, Lean.Meta.getErasedInstances, Array.filterMapM, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Meta.InstanceEntry.val, ite, Eq, Std.PersistentHashSet.contains, Bool.true, Pure.pure, Option.none, List.mapM, Lean.Meta.mkFreshLevelMVar, Option.some, Lean.Expr.updateConst!, panicWithPosWithDecl, OfNat.ofNat, Array.size, Lean.isTracingEnabledFor, Lean.addTrace, PUnit.unit],[Lean.Meta.MetaM, Array, Lean.Expr]]
[Std.Format.MonadPrettyFormat.endTags,[],[Unit]]
[Lean.Elab.Term.SavedState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.SavedState.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.SavedState.mk, And]]
[Lean.Elab.Term.ensureHasType,[Unit.unit, Option.some, Lean.Elab.Term.TermElabM, Lean.Expr, Pure.pure, Bind.bind, liftM, Lean.Meta.inferType, Lean.Elab.Term.ensureHasTypeAux, Option.none],[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Lean.Lsp.TextEdit.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.TextEdit.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.TextEdit.mk, And]]
[Lean.IR.LiveVars.Collector,[Lean.IR.LiveVarSet],[]]
[Lean.MetavarContext.revert,[Lean.MetavarContext.MkBinding.revert],[Lean.MetavarContext.MkBindingM, Prod, Lean.Expr, Array]]
[Std.RBTree.forIn,[Std.RBNode.forIn, Subtype.val],[]]
[instSubsingletonPUnit,[Subsingleton.intro, PUnit.subsingleton],[Subsingleton, PUnit]]
[Lean.Elab.instMonadLog,[Lean.Elab.MonadLog.mk, liftM, Lean.Elab.MonadLog.getRef, Lean.Elab.MonadLog.getFileName, Lean.Elab.MonadLog.logMessage],[Lean.Elab.MonadLog]]
[Lean.Meta.Context.lctx,[],[Lean.LocalContext]]
[Lean.Server.Watchdog.WorkerState.noConfusionType,[],[]]
[Lean.Lsp.instToJsonDiagnosticSeverity,[Lean.ToJson.mk, Unit.unit, Lean.Json, OfNat.ofNat],[Lean.ToJson, Lean.Lsp.DiagnosticSeverity]]
[Lean.getRevAliases,[Lean.SMap.fold, ite, Eq, List.contains, Bool.true, List.cons, List.nil, Lean.SimplePersistentEnvExtension.getState, Lean.aliasExtension],[List, Lean.Name]]
[USize.lt,[LT.lt, USize.val],[]]
[add_right_eq_self,[Eq.mpr, Eq.refl, Iff, Eq, HAdd.hAdd, OfNat.ofNat, Eq.symm, propext, add_left_cancel_iff, add_zero, Iff.rfl],[Iff, Eq, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.EmitC.throwInvalidExportName,[MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.IR.EmitC.M]]
[Lean.Parser.Module.module,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Module.header, Lean.Parser.many, Lean.Parser.commandParser, Lean.Parser.ppLine],[Lean.Parser.Parser]]
[Lean.Parser.setExpectedFn,[Lean.Parser.ParserState.mk, Option.none, Option.some, Lean.Parser.ParserState, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.pos, Lean.Parser.ParserState.cache, Lean.Parser.Error.mk, Lean.Parser.Error.unexpected, List.nil],[Lean.Parser.ParserFn]]
[Lean.RecursorVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.RecursorVal.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.JsonNumber.instOrdJsonNumber,[Ord.mk, ite, LT.lt, Ordering.lt, GT.gt, Ordering.gt, Ordering.eq],[Ord, Lean.JsonNumber]]
[Lean.Parser.Term.letIdDeclNoBinders.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.pushNone.parenthesizer, Lean.Parser.Term.optType.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat],[Lean.PrettyPrinter.Parenthesizer]]
[List.decidableMem.proof_2,[Or.inr],[Or, Eq, List.mem]]
[Lean.Parser.Term.doAssert,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[instSubsingletonStateM,[instSubsingletonStateM.proof_1],[Subsingleton, StateM]]
[Function.surjective,[Exists, Eq],[]]
[Lean.DataValue.str,[String, ToString.toString],[String]]
[Lean.mkLevelIMax',[ite, Eq, Lean.Level.isNeverZero, Bool.true, Lean.mkLevelMax', Lean.Level.isZero, BEq.beq, Lean.mkLevelIMax],[Lean.Level]]
[Lean.Meta.SizeOfSpecNested.Context.ctorName,[],[Lean.Name]]
[Lean.Lsp.instFromJsonRpcKeepAliveParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, UInt64, Pure.pure, Lean.Lsp.RpcKeepAliveParams.mk],[Lean.FromJson, Lean.Lsp.RpcKeepAliveParams]]
[Lean.Elab.Command.checkValidCtorModifier,[ite, Eq, Lean.Elab.Modifiers.isNoncomputable, Bool.true, Bind.bind, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Unit]]
[Lean.OptionDecls,[Lean.NameMap, Lean.OptionDecl],[]]
[Function.const_apply,[rfl],[Eq, Function.const]]
[Tactic.Ring.evalHorner,[Tactic.Ring.HornerExpr.const, Tactic.Ring.HornerExpr.xadd, Tactic.Ring.RingM, Prod, Tactic.Ring.HornerExpr, Lean.Expr, ite, Eq, OfNat.ofNat, Bind.bind, Tactic.Ring.mkAppCS, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Prod.fst, Tactic.Ring.HornerExpr.e, List.nil, Pure.pure, Prod.mk, Tactic.Ring.HornerExpr.xadd', Tactic.Ring.HornerExpr.reflConv, And, Prod.snd, Lean.Expr.numeral?, Option.some, Lean.mkRawNatLit, HAdd.hAdd, liftM, Lean.Meta.mkEqRefl],[Tactic.Ring.RingM, Prod, Tactic.Ring.HornerExpr, Lean.Expr]]
[AndThen.noConfusionType,[],[]]
[Lean.Server.handleLspRequest,[Bind.bind, liftM, ST.Ref.get, Lean.Server.requestHandlers, Pure.pure, Std.PersistentHashMap.find?, Unit.unit, Lean.Server.RequestM, Lean.Server.RequestTask, Lean.Json, MonadExcept.throw, Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.internalError, ToString.toString, IO.userError, HAppend.hAppend],[Lean.Server.RequestM, Lean.Server.RequestTask, Lean.Json]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.bInfos,[],[Array, Lean.BinderInfo]]
[Lean.Parser.Term.doFinally.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.doSeq.formatter],[Lean.PrettyPrinter.Formatter]]
[OptionT.instAlternativeOptionT,[Alternative.mk, OptionT.fail, OptionT.orElse],[Alternative, OptionT]]
[decidable_eq_inl_refl,[Eq, Decidable.isTrue, Eq.refl, rfl, absurd],[Eq, Decidable.isTrue, Eq.refl]]
[Fin.mul,[Fin, Fin.mk, HMod.hMod, HMul.hMul, Fin.mul.proof_1],[Fin]]
[Lean.Meta.AbstractMVars.mkFreshId,[Bind.bind, MonadState.get, modify, Lean.Meta.AbstractMVars.State.mk, Lean.NameGenerator.next, Lean.Meta.AbstractMVars.State.ngen, Lean.Meta.AbstractMVars.State.lctx, Lean.Meta.AbstractMVars.State.mctx, Lean.Meta.AbstractMVars.State.nextParamIdx, Lean.Meta.AbstractMVars.State.paramNames, Lean.Meta.AbstractMVars.State.fvars, Lean.Meta.AbstractMVars.State.lmap, Lean.Meta.AbstractMVars.State.emap, Pure.pure],[Lean.Meta.AbstractMVars.M, Lean.Name]]
[Lean.Syntax.Traverser.left,[ite, GT.gt, Array.size, Lean.Syntax.Traverser.parents, OfNat.ofNat, Lean.Syntax.Traverser.down, Lean.Syntax.Traverser.up, HSub.hSub, Array.back, Lean.Syntax.Traverser.idxs],[Lean.Syntax.Traverser]]
[Lean.PrettyPrinter.Parenthesizer.rawIdentNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.PrettyPrinter.Delaborator.ParamKind.isAutoParam,[],[Bool]]
[Lean.EnvExtensionInterface.mkInitialExtStates,[],[IO, Array, Lean.EnvExtensionState]]
[Lean.IR.Borrow.instToFormatParamMap,[Std.ToFormat.mk, Lean.IR.Borrow.ParamMap.fmt],[Std.ToFormat, Lean.IR.Borrow.ParamMap]]
[Lean.Meta.mkFalseElim,[Bind.bind, Lean.Meta.getLevel, Pure.pure, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Elab.Term.BinOp.elabBinOp,[Bind.bind, Lean.Elab.liftMacroM, Lean.expandMacros, Lean.Elab.Term.synthesizeSyntheticMVars, Bool.true, Bool.false, Pure.pure, Unit.unit, Lean.Elab.Term.TermElabM, Option.none, liftM, Lean.Meta.instantiateMVars, ite, Eq, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.proj, Bool, PProd.fst, PProd.snd, Option.some, MonadState.get, PUnit.unit, StateRefT', IO.RealWorld, Unit, Lean.Meta.inferType, modify, Lean.Meta.withNewMCtxDepth, Lean.Meta.isDefEqGuarded, Lean.MonadEnv.getEnv, Lean.Environment.contains, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getLevel, Lean.MonadOptions.getOptions, Lean.Meta.trySynthInstance, Lean.Option.get, Lean.Elab.Term.maxCoeSize, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Elab.Term.TermElab]]
[Command.initializeSimpsProjections,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const, Command.simpsProj],[Lean.ParserDescr]]
[Lean.Parser.Term.structInst.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.ppHardSpace.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.termParser.formatter, Bool.false, Lean.Parser.manyIndent.formatter, Lean.Parser.group.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.structInstFieldAbbrev.formatter, Lean.Parser.Term.structInstField.formatter, Lean.Parser.Term.optEllipsis.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.instFromJsonCompletionParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.CompletionParams.mk, Lean.Lsp.TextDocumentPositionParams.mk],[Lean.FromJson, Lean.Lsp.CompletionParams]]
[Lean.Meta.orelseMergeErrors,[controlAt, Lean.Meta.MetaM, Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadMCtx.getMCtx, MonadExcept.tryCatch, Lean.setEnv, Lean.Meta.setMCtx, Lean.Exception.internal, MonadExcept.throw, Lean.Exception.error],[]]
[Lean.KernelException.funExpected.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.funExpected, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KernelException.funExpected, And]]
[Lean.setReducibilityStatus,[Lean.MonadEnv.modifyEnv, Lean.setReducibilityStatusImp],[Unit]]
[Lean.Server.FileWorker.instInhabitedEditableDocument,[Inhabited.mk, Lean.Server.FileWorker.EditableDocument.mk, arbitrary],[Inhabited, Lean.Server.FileWorker.EditableDocument]]
[instReprNat,[Repr.mk, Std.Format.text, Nat.repr],[Repr, Nat]]
[Lean.IR.instBEqLitVal,[BEq.mk, Lean.IR.LitVal.beq],[BEq, Lean.IR.LitVal]]
[Tactic.Ring.const_add_horner,[of_eq_true, Eq.trans, congr, congrArg, Eq, add_comm, HAdd.hAdd, HMul.hMul, HPow.hPow, add_assoc, Eq.symm, eq_self],[Eq, HAdd.hAdd, Tactic.Ring.horner]]
[Lean.Lsp.TextDocumentSyncOptions.noConfusionType,[],[]]
[Lean.Elab.Term.CollectPatternVars.State.vars,[],[Array, Lean.Elab.Term.PatternVar]]
[Lean.Parser.Term.prec.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.precedenceParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Attribute.Builtin.getId,[Bind.bind, Lean.Attribute.Builtin.getIdent, Pure.pure, Lean.Syntax.getId],[Lean.AttrM, Lean.Name]]
[Lean.Compiler.toDecidableExpr,[Unit.unit, Lean.Expr, Lean.mkDecIsTrue, Lean.Compiler.neutralExpr, Lean.mkDecIsFalse, Lean.Compiler.mkLcProof],[Lean.Expr]]
[Lean.OpenDecl.instInhabitedOpenDecl,[Inhabited.mk, Lean.OpenDecl.simple, Lean.Name.anonymous, List.nil],[Inhabited, Lean.OpenDecl]]
[Lean.Parser.checkTailNoWs,[Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Bool, Lean.Syntax.getTailInfo, BEq.beq, Substring.stopPos, Substring.startPos, Bool.false],[Bool]]
[Lean.Parser.instInhabitedParserCategory,[Inhabited.mk, Lean.Parser.ParserCategory.mk, arbitrary],[Inhabited, Lean.Parser.ParserCategory]]
[Lean.Elab.Info.size?,[OptionM.run, Bind.bind, Lean.Elab.Info.pos?, Lean.Elab.Info.tailPos?, Pure.pure, HSub.hSub],[Option, Nat]]
[StateT.run_seqRight,[],[Eq, StateT.run, SeqRight.seqRight, Bind.bind, Prod.snd]]
[ReaderT.run_map,[rfl],[Eq, ReaderT.run, Functor.map]]
[Lean.Parser.instCoeArrowParserParserParserAliasValue,[Coe.mk, Lean.Parser.AliasValue.unary],[Coe, Lean.Parser.Parser, Lean.Parser.ParserAliasValue]]
[instHashableUInt64,[Hashable.mk],[Hashable, UInt64]]
[Lean.Widget.InteractiveGoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Widget.InteractiveGoal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Widget.InteractiveGoal.mk, And]]
[Lean.Expr.instantiateBetaRevRange,[ite, Eq, and, Lean.Expr.hasLooseBVars, Decidable.decide, GT.gt, Bool.true, LE.le, Array.size, Lean.MonadStateCacheT.run, OfNat.ofNat, panicWithPosWithDecl, HAppend.hAppend, Lean.Expr.instantiateBetaRevRange.visit],[Lean.Expr]]
[Lean.Meta.RewriteResult.mk.inj,[And.intro],[And, Eq]]
[Lean.Elab.InfoState.assignment,[],[Std.PersistentHashMap, Lean.MVarId, Lean.Elab.InfoTree]]
[CommRing.toRing,[],[Ring]]
[Std.HashMap.foldM,[Std.HashMapImp.foldM],[]]
[Lean.catchInternalIds,[MonadExcept.tryCatch, MonadExcept.throw, ite, Eq, List.contains, Bool.true],[]]
[Lean.Parser.Term.scientific.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.scientificLit.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.SyntaxNode,[Subtype, Lean.IsNode],[]]
[Lean.Parser.symbolNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.symbolInfo, Lean.Parser.symbolFn],[Lean.Parser.Parser]]
[Subtype.ext_iff,[Iff.intro, congrArg, Subtype.val, Subtype.ext],[Iff, Eq, Subtype.val]]
[Lean.ParserCompiler.CombinatorAttribute.ext,[],[Lean.SimplePersistentEnvExtension, Prod, Lean.Name, Lean.NameMap]]
[IO.ofExcept,[IO, Pure.pure, MonadExcept.throw, IO.userError, ToString.toString],[IO]]
[Lean.Meta.SimpEntry.noConfusionType,[],[]]
[UInt8.toNat,[Fin.val, UInt8.val],[Nat]]
[Lean.PrettyPrinter.Formatter.push,[modify, Lean.PrettyPrinter.Formatter.State.mk, Lean.PrettyPrinter.Formatter.State.stxTrav, Lean.PrettyPrinter.Formatter.State.leadWord, Array.push, Lean.PrettyPrinter.Formatter.State.stack],[Lean.PrettyPrinter.FormatterM, Unit]]
[Lean.Parser.prattParser,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Parser.trailingLoop],[Lean.Parser.ParserFn]]
[Tactic.Ring.addAtom,[Bind.bind, MonadState.get, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, liftM, Lean.Meta.isDefEq, Array.getOp, Tactic.Ring.State.atoms, ite, Eq, Bool.true, Pure.pure, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, Tactic.Ring.RingM, Nat, MProd.fst],[Tactic.Ring.RingM, Nat]]
[Lean.Parser.Term.open.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.openDecl.formatter, Lean.PrettyPrinter.Formatter.withOpenDecl.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat],[Lean.PrettyPrinter.Formatter]]
[Nat.case_strong_rec_on,[Nat.strong_rec_on, Nat.lt_succ_of_le],[]]
[throwThe,[MonadExceptOf.throw],[]]
[Lean.PrettyPrinter.Formatter.dbgTraceState.formatter,[],[Lean.PrettyPrinter.Formatter]]
[List.mem_insert_of_mem,[Iff.mpr, List.mem_insert_iff, Or.inr],[Mem.mem, List.insert]]
[Lean.Parser.Tactic.ringExpEq!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.IR.Expr.ctor.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.ctor, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Expr.ctor, And]]
[Lean.IR.Borrow.ParamMap.Key.noConfusionType,[],[]]
[Prod.map_def,[funext, of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, prod_map, Prod.mk, Prod.fst, Prod.snd, eq_self, propext, implies_true_iff, Prod],[Eq, Prod.map, Prod.mk, Prod.fst, Prod.snd]]
[Fin.instDivFin,[Div.mk, Fin.div],[Div, Fin]]
[List.toAssocList,[Unit.unit, Std.AssocList, Std.AssocList.nil, Std.AssocList.cons, PProd.fst],[Std.AssocList]]
[Lean.Elab.Command.elabDeclareSyntaxCat,[Bind.bind, Lean.MonadEnv.getEnv, liftM, Lean.Parser.registerParserCategory, Lean.setEnv, Lean.Name.anonymous, Lean.Name.num, Lean.Elab.Command.CommandElabM, Unit, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, List.toArray, List.cons, List.nil, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.mkIdent, Prod.mk, Lean.Quote.quote, Lean.Parser.maxPrec, Lean.Elab.Command.elabCommand, PUnit.unit],[Lean.Elab.Command.CommandElab]]
[Lean.Elab.Term.Do.ToCodeBlock.Catch.codeBlock,[],[Lean.Elab.Term.Do.CodeBlock]]
[Lean.Elab.Term.Do.ToTerm.seqToTerm,[Lean.withRef, Lean.MonadQuotation.withFreshMacroScope, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadReader.read, Lean.Elab.Term.Do.ToTerm.Context.m, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk],[Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax]]
[Std.PersistentHashMap.Stats.noConfusionType,[],[]]
[Lean.KernelException.invalidProj.inj,[And.intro],[And, Eq]]
[Lean.OpaqueVal.isUnsafe,[],[Bool]]
[Semiring.ofNat_succ,[],[Eq, Numeric.ofNat, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.Context.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.fixLevelParams,[Bind.bind, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Elab.Term.TermElabM, List, Lean.Name, Lean.Elab.sortDeclLevelParams, Lean.CollectLevelParams.State.params, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Array.map, Lean.Elab.PreDefinition.mk, Lean.Elab.PreDefinition.ref, Lean.Elab.PreDefinition.kind, Lean.Elab.PreDefinition.modifiers, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.type, Lean.Elab.PreDefinition.value],[Lean.Elab.Term.TermElabM, Array, Lean.Elab.PreDefinition]]
[Lean.NameSanitizerState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.NameSanitizerState.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.elabLetDecl,[Lean.Elab.Term.elabLetDeclCore, Bool.true, Bool.false],[Lean.Elab.Term.TermElab]]
[Monoid.npow,[],[]]
[Nat.sub_lt_succ,[Nat.lt_succ_of_le, Nat.sub_le],[LT.lt, HSub.hSub, Nat.succ]]
[Lean.Parser.Tactic.match,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.Term.generalizingParam, Lean.Parser.sepBy1, Lean.Parser.Term.matchDiscr, Bool.false, Lean.Parser.Term.optType, Lean.Parser.Tactic.matchAlts],[Lean.Parser.Parser]]
[UInt32.mod,[UInt32.mk, HMod.hMod, UInt32.val],[UInt32]]
[Lean.InternalExceptionId.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.InternalExceptionId.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Command.classTk.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.mkFreshMVarId,[Bind.bind, Lean.mkFreshId, Pure.pure, Lean.MVarId.mk],[Lean.MVarId]]
[Lean.Export.instCoeLevelEntry,[Coe.mk, Lean.Export.Entry.level],[Coe, Lean.Level, Lean.Export.Entry]]
[Lean.Meta.SynthInstance.State.noConfusionType,[],[]]
[Lean.Position.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Position.mk, HAdd.hAdd, OfNat.ofNat]]
[PSigma.mkSkipLeft,[PSigma.mkSkipLeft.proof_1],[PSigma.SkipLeft, PSigma.mk]]
[Bool.true_or,[rfl, Eq.symm, Eq.refl],[Eq, or, Bool.true]]
[Lean.Xml.Parser.prolog,[SeqRight.seqRight, optional, Lean.Xml.Parser.XMLdecl, Lean.Parsec.many, Lean.Xml.Parser.Misc, SeqLeft.seqLeft, Lean.Xml.Parser.doctypedecl, Pure.pure, Unit.unit],[Lean.Parsec, Unit]]
[Lean.Meta.MatcherApp.addArg,[Lean.Meta.lambdaTelescope, Lean.Meta.MatcherApp.motive, ite, Eq, BEq.beq, Array.size, Lean.Meta.MatcherApp.discrs, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Meta.MetaM, Lean.Meta.MatcherApp]]
[Lean.Parser.Tactic.rcasesPat.clear,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.TheoremVal.toConstantVal,[],[Lean.ConstantVal]]
[EST,[EStateM],[]]
[Lean.ScopedEnvExtension.ScopedEntries.map,[],[Lean.SMap, Lean.Name, Std.PArray]]
[Lean.Server.Watchdog.FileWorker.pendingRequestsRef,[],[IO.Ref, Lean.Server.Watchdog.PendingRequestMap]]
[Function.update,[dite, Eq, Eq.symm],[]]
[Std.HashMapImp.foldBuckets,[Id.run, Std.HashMapImp.foldBucketsM],[]]
[Lean.PrefixTreeNode.foldMatchingM,[Lean.PrefixTreeNode.foldMatchingM.find, Lean.PrefixTreeNode.foldMatchingM.fold],[]]
[Lean.Parser.Command.mkIffOfInductiveProp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Std.PersistentHashMap.CollisionNode,[Subtype, Std.PersistentHashMap.IsCollisionNode],[]]
[Lean.IR.containsDecl',[ite, Eq, Array.any, BEq.beq, Lean.IR.Decl.name, OfNat.ofNat, Array.size, Bool.true, Pure.pure, Bind.bind, MonadState.get, Lean.SMap.contains, Lean.SimplePersistentEnvExtension.getState, Lean.IR.declMapExt, Lean.IR.CompilerState.env],[Lean.IR.CompilerM, Bool]]
[USize.shiftRight,[USize.mk, HShiftRight.hShiftRight, USize.val, USize.modn, System.Platform.numBits],[USize]]
[Lean.instBEqDataValue,[BEq.mk, Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.DataValue]]
[Lean.PPContext.mk.inj,[And.intro],[And, Eq]]
[Nat.coprime.pow_right,[Nat.coprime.symm, Nat.coprime.pow_left],[Nat.coprime, HPow.hPow]]
[Lean.Core.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Core.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Core.State.mk, And]]
[Lean.Parser.Command.prefix.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Nat.mod.inductionOn,[Nat.div.inductionOn],[]]
[Except.error.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Except.error, HAdd.hAdd, OfNat.ofNat]]
[Lean.Export.State.noConfusionType,[],[]]
[eq_true_of_ne_false,[Eq, Bool.true, rfl, False.elim],[Eq, Bool.true]]
[Lean.PPContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PPContext.mk, HAdd.hAdd, OfNat.ofNat]]
[Tactic.Ring.RingM,[ReaderT, Tactic.Ring.Cache, StateRefT', IO.RealWorld, Tactic.Ring.State, Lean.Meta.MetaM],[]]
[Std.PersistentArray.instToStringStats,[ToString.mk, Std.PersistentArray.Stats.toString],[ToString, Std.PersistentArray.Stats]]
[Lean.Elab.Term.SyntheticMVarDecl.kind,[],[Lean.Elab.Term.SyntheticMVarKind]]
[Lean.Parser.Term.bracketedBinder.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.evalInsideQuot, Lean.Parser.Term.bracketedBinder, Bool.false],[Lean.Parser.Parser]]
[Lean.FromJson.fromJson?,[],[Except, String]]
[Lean.Meta.Closure.visitLevel,[ite, Eq, and, not, Lean.Level.hasMVar, Lean.Level.hasParam, Bool.true, Pure.pure, Bind.bind, MonadState.get, Unit.unit, Lean.Meta.Closure.ClosureM, Lean.Level, Std.HashMap.find?, Lean.Meta.Closure.State.visitedLevel, modify, Lean.Meta.Closure.State.mk, Std.HashMap.insert, Lean.Meta.Closure.State.visitedExpr, Lean.Meta.Closure.State.levelParams, Lean.Meta.Closure.State.nextLevelIdx, Lean.Meta.Closure.State.levelArgs, Lean.Meta.Closure.State.newLocalDecls, Lean.Meta.Closure.State.newLocalDeclsForMVars, Lean.Meta.Closure.State.newLetDecls, Lean.Meta.Closure.State.nextExprIdx, Lean.Meta.Closure.State.exprMVarArgs, Lean.Meta.Closure.State.exprFVarArgs, Lean.Meta.Closure.State.toProcess],[Lean.Meta.Closure.ClosureM, Lean.Level]]
[Lean.IR.FnBody.setTag.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.FnBody.setTag, HAdd.hAdd, OfNat.ofNat]]
[Lean.Syntax.mkLit,[Lean.mkNode, List.toArray, List.cons, List.nil],[Lean.Syntax]]
[Lean.Elab.Term.addTermInfo,[Functor.discard, Lean.Elab.withInfoContext', Pure.pure, Unit.unit, Lean.Elab.Term.mkTermInfo],[Lean.Elab.Term.TermElabM, Unit]]
[Nat.instCommSemiringNat.proof_2,[of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.pow_succ, Nat.mul_comm, HPow.hPow, eq_self, HMul.hMul],[Eq, HPow.hPow, Nat.succ, HMul.hMul]]
[Subset.noConfusionType,[],[]]
[Lean.Lsp.instFromJsonTextDocumentChangeRegistrationOptions,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, Lean.Lsp.DocumentSelector, Lean.Lsp.TextDocumentSyncKind, Pure.pure, Lean.Lsp.TextDocumentChangeRegistrationOptions.mk],[Lean.FromJson, Lean.Lsp.TextDocumentChangeRegistrationOptions]]
[Lean.Parser.Tactic.contrapose,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Meta.withIncRecDepth,[Lean.Meta.mapMetaM, Lean.withIncRecDepth],[]]
[String.Range.toLspRange,[Lean.Lsp.Range.mk, Lean.FileMap.utf8PosToLspPos, String.Range.start, String.Range.stop],[Lean.Lsp.Range]]
[instDecidableEqQuotient.proof_2,[absurd, Quotient.exact],[False]]
[Lean.Elab.Tactic.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Tactic.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.charLitFnAux,[ite, Eq, String.atEnd, Bool.true, Lean.Parser.ParserState.mkEOIError, List.nil, Lean.Parser.ParserState.hasError, BEq.beq, Char.ofNat, Lean.Parser.mkNodeToken, Lean.charLitKind, Lean.Parser.ParserState.mkUnexpectedError],[Lean.Parser.ParserFn]]
[Lean.Expr.ReplaceImpl.initCache,[Lean.Expr.ReplaceImpl.State.mk, Array.mkArray, USize.toNat, Lean.Expr.ReplaceImpl.cacheSize, cast, Lean.Expr.ReplaceImpl.initCache.proof_1, Unit.unit, arbitrary],[Lean.Expr.ReplaceImpl.State]]
[Lean.Elab.Command.instMonadLiftTIOCommandElabM,[MonadLiftT.mk, Lean.Elab.Command.liftIO],[MonadLiftT, IO, Lean.Elab.Command.CommandElabM]]
[Lean.Parser.Term.letMVar.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.delta?,[Lean.matchConst, Lean.Expr.getAppFn, Pure.pure, Option.none, ite, Eq, and, Lean.ConstantInfo.name, Lean.ConstantInfo.hasValue, BEq.beq, List.length, Lean.ConstantInfo.levelParams, Bool.true, Option.some, Lean.Expr.betaRev, Lean.Expr.getAppRevArgs],[Lean.Core.CoreM, Option, Lean.Expr]]
[Lean.IR.ExplicitBoxing.getResultType,[Functor.map, Lean.IR.ExplicitBoxing.BoxingContext.resultType, MonadReader.read],[Lean.IR.ExplicitBoxing.M, Lean.IR.IRType]]
[Lean.Parser.checkColGeFn,[Unit.unit, Lean.Parser.ParserState, Lean.Parser.ParserContext.savedPos?, ite, GE.ge, Lean.Position.column, Lean.Parser.ParserState.mkError],[Lean.Parser.ParserFn]]
[Lean.Meta.assertAfter,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarTag, Lean.Meta.getMVarType, Lean.Meta.getLocalDecl, Lean.MonadLCtx.getLCtx, Lean.Meta.getLocalInstances, Lean.Meta.mkForallFVars, Bool.false, Lean.Meta.mkFreshExprMVarAt, Lean.MetavarKind.syntheticOpaque, OfNat.ofNat, Lean.Meta.assignExprMVar, Lean.mkAppN, Lean.Meta.intro1P, Lean.Expr.mvarId!, Lean.Meta.MetaM, Lean.Meta.AssertAfterResult, Lean.Meta.introNP, Array.size, Pure.pure, Lean.Meta.AssertAfterResult.mk],[Lean.Meta.MetaM, Lean.Meta.AssertAfterResult]]
[AddMonoid.toZero,[],[Zero]]
[Lean.Parser.Tactic.Conv.conv.quot,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Array.getIdx?,[Array.findIdx?, BEq.beq],[Option, Nat]]
[Lean.Meta.TransparencyMode.noConfusion,[noConfusionEnum, Lean.Meta.TransparencyMode.toCtorIdx],[Lean.Meta.TransparencyMode.noConfusionType]]
[Lean.registerPersistentEnvExtensionUnsafe,[Bind.bind, ST.Ref.get, Lean.persistentEnvExtensionsRef, ite, Eq, Array.any, BEq.beq, Lean.PersistentEnvExtension.name, Lean.PersistentEnvExtensionDescr.name, OfNat.ofNat, Array.size, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Pure.pure, PUnit.unit],[IO, Lean.PersistentEnvExtension]]
[Lean.Parser.Term.haveIdLhs,[HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Term.ident, Lean.Parser.many, Lean.Parser.ppSpace, HOrElse.hOrElse, Lean.Parser.Term.simpleBinderWithoutType, Lean.Parser.Term.bracketedBinder, Bool.false, Lean.Parser.Term.optType],[Lean.Parser.Parser]]
[Lean.mkMDataEx,[Lean.mkMData],[Lean.Expr]]
[Lean.Elab.Command.expandDeclId,[Bind.bind, Lean.MonadResolveName.getCurrNamespace, Lean.Elab.Command.getLevelNames, Lean.Elab.expandDeclId],[Lean.Elab.Command.CommandElabM, Lean.Elab.ExpandDeclIdResult]]
[Std.ShareCommon.State.empty,[Std.ShareCommon.mkState, Unit.unit],[Std.ShareCommon.State]]
[forall_prop_decidable.proof_2,[absurd],[]]
[UInt16.instSemiringUInt16.proof_13,[UInt16.eq_of_val_eq, Eq.mpr, congrArg, Eq, Fin.ofNat', HAdd.hAdd, OfNat.ofNat, Fin.size_positive', UInt16.val, Eq.trans, UInt16.mk, UInt16.one_def, UInt16.add_def],[Eq, Numeric.ofNat, HAdd.hAdd, OfNat.ofNat]]
[Std.HashMapImp.find?.proof_1,[Subtype.property],[GT.gt, Array.size, Subtype.val, OfNat.ofNat]]
[Lean.HeadIndex.lit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.HeadIndex.lit, HAdd.hAdd, OfNat.ofNat]]
[rawNatLit,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Elab.Term.Do.DoIfView.elseBranch,[],[Lean.Syntax]]
[List.headD,[],[]]
[Lean.Lsp.Range.mk.inj,[And.intro],[And, Eq]]
[Lean.MetavarContext.exprDependsOn,[Lean.MetavarContext.findExprDependsOn, BEq.beq],[Bool]]
[Std.AssocList.erase,[Unit.unit, Std.AssocList, Std.AssocList.nil, BEq.beq, Std.AssocList.cons, PProd.fst],[Std.AssocList]]
[UInt8.instRingUInt8.proof_5,[UInt8.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, UInt8.val, congrFun, HAdd.hAdd, UInt8.neg_def, UInt8.add_def, UInt8.mk, Neg.neg, add_left_neg, UInt8.zero_def, eq_true_of_decide, Eq.refl, Bool.true],[Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat]]
[Lean.PrettyPrinter.Formatter.checkNoImmediateColon.formatter,[Pure.pure, Unit.unit],[Lean.PrettyPrinter.Formatter]]
[Lean.Server.FileWorker.handleDidChange,[Bind.bind, MonadState.get, Pure.pure, Lean.Lsp.VersionedTextDocumentIdentifier.version?, Option.none, Lean.Server.FileWorker.WorkerM, Unit, ite, LE.le, Lean.Server.DocumentMeta.version, Lean.Server.FileWorker.EditableDocument.meta, liftM, IO.eprintln, HAppend.hAppend, ToString.toString, Not, Eq, Array.isEmpty, Bool.true, Lean.Server.FileWorker.updateDocument, Lean.Server.DocumentMeta.mk, Lean.Lsp.VersionedTextDocumentIdentifier.uri, PUnit.unit, IO.throwServerError],[Lean.Server.FileWorker.WorkerM, Unit]]
[Nat.sub_succ,[rfl],[Eq, HSub.hSub, Nat.succ, Nat.pred]]
[ST.Ref.get,[liftM, ST.Prim.Ref.get],[]]
[List.mapIdxM.loop,[List, Pure.pure, List.nil, Seq.seq, Functor.map, List.cons, PProd.fst, HAdd.hAdd, OfNat.ofNat],[List]]
[Lean.MessageLog.mk.injEq,[Eq.propIntro, Eq.refl, Lean.MessageLog.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MessageLog.mk]]
[Lean.IR.Expr.unbox.injEq,[Eq.propIntro, Eq.refl, Lean.IR.Expr.unbox, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.IR.Expr.unbox]]
[Std.HashMapImp.size,[],[Nat]]
[Lean.Elab.Term.SavedContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.SavedContext.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Tactic.evalTacticAt,[Bind.bind, Lean.Elab.Tactic.getGoals, tryFinally, Lean.Elab.Tactic.setGoals, List.cons, List.nil, Lean.Elab.Tactic.evalTactic, Lean.Elab.Tactic.pruneSolvedGoals],[Lean.Elab.Tactic.TacticM, List, Lean.MVarId]]
[Lean.Meta.reduceRecMatcher?,[ite, Eq, not, Lean.Expr.isApp, Bool.true, Pure.pure, Option.none, Bind.bind, Lean.Meta.reduceMatcher?, Lean.Meta.ReduceMatcherResult.stuck, Lean.Meta.ReduceMatcherResult.notMatcher, Lean.Meta.ReduceMatcherResult.partialApp, Lean.Meta.MetaM, Option, Lean.Expr, Option.some, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.getConst?, Unit.unit, Lean.Expr.getAppFn, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, dite, LT.lt, Array.size, Lean.Meta.whnf, Lean.RecursorVal.k, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Lean.Expr.isConstOf, Lean.RecursorVal.getInduct, and, Lean.Expr.hasExprMVar, Subarray.any, Array.toSubarray, Lean.RecursorVal.numParams, Lean.Meta.getConstNoEx?, Lean.ConstantInfo.quotInfo, Lean.InductiveVal.mk, Lean.ConstantVal.mk, List.nil, Lean.ConstantInfo.recInfo, Lean.Name, Lean.mkAppN, Lean.mkConst, Array.shrink, Lean.Expr.getAppArgs, Lean.Meta.isDefEq, PUnit.unit, Lean.QuotKind.type, Lean.QuotKind.ctor, Lean.QuotVal.kind, OfNat.ofNat, Lean.Meta.isAuxDef, Lean.ConstantInfo.name, bne, List.length, Lean.ConstantInfo.levelParams, Lean.Expr.getAppRevArgs],[Lean.Meta.MetaM, Option, Lean.Expr]]
[Lean.Elab.Command.getMainModule,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Environment.mainModule],[Lean.Elab.Command.CommandElabM, Lean.Name]]
[instToStringFormat,[ToString.mk, Std.Format.pretty, Std.Format.defWidth],[ToString, Std.Format]]
[Lean.Lsp.instBEqPublishDiagnosticsParams,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Lsp.PublishDiagnosticsParams]]
[Lean.Meta.Simp.instInhabitedMethods,[Inhabited.mk, Lean.Meta.Simp.Methods.mk, arbitrary],[Inhabited, Lean.Meta.Simp.Methods]]
[Lean.IR.ExplicitBoxing.castVarIfNeeded,[Bind.bind, Lean.IR.ExplicitBoxing.getVarType, ite, Eq, Lean.IR.ExplicitBoxing.eqvTypes, Bool.true, getModify, Lean.IR.ExplicitBoxing.BoxingState.mk, HAdd.hAdd, Lean.IR.ExplicitBoxing.BoxingState.nextIdx, OfNat.ofNat, Lean.IR.ExplicitBoxing.BoxingState.auxDecls, Lean.IR.ExplicitBoxing.BoxingState.auxDeclCache, Lean.IR.ExplicitBoxing.BoxingState.nextAuxId, Pure.pure, Lean.IR.VarId.mk, Lean.IR.ExplicitBoxing.mkCast, Functor.map, Lean.IR.FnBody.vdecl],[Lean.IR.ExplicitBoxing.M, Lean.IR.FnBody]]
[List.product_spec,[Iff.intro, Eq.mpr, Eq.trans, implies_congr, propext, List.mem_bind, congrArg, Exists, funext, And, Mem.mem, List.mem_map, Prod.mk.injEq, exists_eq_right_right', Eq.refl, and_imp, And.intro, id],[Iff, Mem.mem, Prod.mk, List.product, And]]
[List.isPrefixOf,[List.nil, List.cons, Bool, Bool.true, Bool.false, and, BEq.beq, PProd.fst],[Bool]]
[instInhabitedPUnit,[Inhabited.mk, PUnit.unit],[Inhabited, PUnit]]
[List.mem_append_left,[Iff.mpr, List.mem_append, Or.inl],[Mem.mem, HAppend.hAppend]]
[Lean.Compiler.SpecializeAttributeKind.specialize.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Compiler.SpecializeAttributeKind.specialize, OfNat.ofNat]]
[Lean.Server.Watchdog.OpenDocument.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.Watchdog.OpenDocument.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Server.Watchdog.OpenDocument.mk, And]]
[instSubUInt64,[Sub.mk, UInt64.sub],[Sub, UInt64]]
[Lean.Widget.TaggedText.append.injEq,[Eq.propIntro, Eq.refl, Lean.Widget.TaggedText.append, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Widget.TaggedText.append]]
[Std.MonadShareCommon.withShareCommon,[],[]]
[CommMonoid.toMonoid,[],[Monoid]]
[Fin.instSubFin,[Sub.mk, Fin.sub],[Sub, Fin]]
[Lean.Parser.Term.optIdent.formatter,[Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.IndPredBelow.BrecOnVariables.witness,[],[Lean.FVarId]]
[Lean.Elab.defaultHandler,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Elab.Command.CommandElabM, Unit]]
[Lean.instToJsonOption,[Lean.ToJson.mk, Unit.unit, Lean.Json, Lean.Json.null, Lean.ToJson.toJson],[Lean.ToJson, Option]]
[Lean.Parser.registerBuiltinNodeKind,[ST.Ref.modify, Lean.Parser.builtinSyntaxNodeKindSetRef, Lean.Parser.SyntaxNodeKindSet.insert],[IO, Unit]]
[Lean.Meta.AbstractNestedProofs.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.AbstractNestedProofs.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.instToJsonServerCapabilities,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Lsp.ServerCapabilities.textDocumentSync?, Lean.Lsp.ServerCapabilities.completionProvider?, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.ServerCapabilities.hoverProvider, List.nil, Lean.Lsp.ServerCapabilities.documentHighlightProvider, Lean.Lsp.ServerCapabilities.documentSymbolProvider, Lean.Lsp.ServerCapabilities.definitionProvider, Lean.Lsp.ServerCapabilities.declarationProvider, Lean.Lsp.ServerCapabilities.typeDefinitionProvider, Lean.Lsp.ServerCapabilities.referencesProvider, Lean.Lsp.ServerCapabilities.semanticTokensProvider?],[Lean.ToJson, Lean.Lsp.ServerCapabilities]]
[Nat.add_right_cancel,[Nat.add_left_cancel, Eq.mp, Eq.refl, Eq, HAdd.hAdd, Nat.add_comm],[Eq]]
[Lean.inaccessible?,[Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous],[Option, Lean.Expr]]
[DoResultSBC.pureReturn.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultSBC.pureReturn, HAdd.hAdd, OfNat.ofNat]]
[Array.map,[Id.run, Array.mapM],[Array]]
[IO.Process.Child.stderr,[],[IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stderr]]
[Lean.Meta.Match.CounterExample,[List, Lean.Meta.Match.Example],[]]
[Lean.instToExprDeclarationRange,[Lean.ToExpr.mk, Lean.mkAppN, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, List.toArray, List.cons, Lean.ToExpr.toExpr, Lean.DeclarationRange.pos, Lean.DeclarationRange.charUtf16, Lean.DeclarationRange.endPos, Lean.DeclarationRange.endCharUtf16],[Lean.ToExpr, Lean.DeclarationRange]]
[Lean.Meta.InferTypeCache,[Lean.PersistentExprStructMap, Lean.Expr],[]]
[Lean.Elab.Term.State.infoState,[],[Lean.Elab.InfoState]]
[Lean.Parser.optionaInfo,[Lean.Parser.ParserInfo.mk, Lean.Parser.ParserInfo.collectTokens, Lean.Parser.ParserInfo.collectKinds, Lean.Parser.FirstTokens.toOptional, Lean.Parser.ParserInfo.firstTokens],[Lean.Parser.ParserInfo]]
[Nat.zero_min,[min_eq_left, Nat.zero_le],[Eq, Nat.min, OfNat.ofNat]]
[Lean.Elab.Term.LetRecView.body,[],[Lean.Syntax]]
[UInt8.instSemiringUInt8.proof_5,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, congrFun, HMul.hMul, UInt8.zero_def, UInt8.mul_def, UInt8.mk, OfNat.ofNat, MonoidWithZero.zero_mul, UInt8.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt8],[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Parser.group,[Lean.Parser.node, Lean.groupKind],[Lean.Parser.Parser]]
[Lean.Parser.Level.num,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.numLit],[Lean.Parser.Parser]]
[Lean.IR.LocalContext.isLocalVar,[Option.none, Option.some, Lean.IR.LocalContextEntry.param, Lean.IR.LocalContextEntry.joinPoint, Bool, Std.RBMap.find?, Bool.true, Bool.false],[Bool]]
[Lean.Meta.SynthInstance.instInhabitedAnswer,[Inhabited.mk, Lean.Meta.SynthInstance.Answer.mk, arbitrary, OfNat.ofNat],[Inhabited, Lean.Meta.SynthInstance.Answer]]
[Lean.Lsp.instToJsonDidCloseTextDocumentParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.DidCloseTextDocumentParams.textDocument, List.nil],[Lean.ToJson, Lean.Lsp.DidCloseTextDocumentParams]]
[Lean.Syntax.mkAntiquotNode,[Lean.mkNode, HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkAtom, List.nil],[Lean.Syntax]]
[Lean.Lsp.instToJsonTextEditBatch,[Lean.ToJson.mk, Lean.ToJson.toJson],[Lean.ToJson, Lean.Lsp.TextEditBatch]]
[Repr.noConfusionType,[],[]]
[Lean.Meta.FVarSubst.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.FVarSubst.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.FVarSubst.mk]]
[Lean.Elab.Term.CollectPatternVars.Context.noConfusionType,[],[]]
[Lean.Parser.Parser.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.Parser.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.MkInstResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.MkInstResult.mk, HAdd.hAdd, OfNat.ofNat]]
[String.Range.noConfusionType,[],[]]
[Lean.Rat.add,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, HAdd.hAdd, HMul.hMul, Lean.Rat.num, Int.ofNat, Lean.Rat.den, HDiv.hDiv],[Lean.Rat]]
[Lean.Parser.Command.openRenaming.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.Command.openRenamingItem.parenthesizer, Bool.false],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.instMonadTrace,[Lean.MonadTrace.mk, liftM, Lean.MonadTrace.modifyTraceState, Lean.MonadTrace.getTraceState],[Lean.MonadTrace]]
[instShiftLeftUInt8,[ShiftLeft.mk, UInt8.shiftLeft],[ShiftLeft, UInt8]]
[Nat.coprime.gcd_mul,[Nat.dvd_antisymm, Nat.gcd_mul_dvd_mul_gcd, Nat.coprime.mul_dvd_of_dvd_of_dvd, Nat.coprime.gcd_both, Nat.gcd_dvd_gcd_mul_right_right, Nat.gcd_dvd_gcd_mul_left_right],[Eq, Nat.gcd, HMul.hMul]]
[Lean.Name.hasMacroScopes,[Lean.Name.anonymous, Bool, BEq.beq, PProd.fst, Bool.false],[Bool]]
[Subarray.popFront,[dite, LT.lt, Subarray.start, Subarray.stop, Subarray.mk, Subarray.as, HAdd.hAdd, OfNat.ofNat, Subarray.popFront.proof_1, Subarray.h₂],[Subarray]]
[Lean.Elab.Term.elabDoubleQuotedName,[Bind.bind, Lean.Elab.resolveGlobalConstNoOverloadWithInfo, Lean.Syntax.getOp, OfNat.ofNat, Option.none, Pure.pure, Lean.ToExpr.toExpr],[Lean.Elab.Term.TermElab]]
[Lean.Lsp.instFromJsonRpcCallParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, UInt64, Lean.Name, Lean.Json, Pure.pure, Lean.Lsp.RpcCallParams.mk, Lean.Lsp.TextDocumentPositionParams.mk],[Lean.FromJson, Lean.Lsp.RpcCallParams]]
[Lean.Elab.Term.MutualClosure.FixPoint.run,[Lean.Elab.Term.MutualClosure.UsedFVarsMap, Lean.Elab.Term.MutualClosure.FixPoint.State.usedFVarsMap],[Lean.Elab.Term.MutualClosure.UsedFVarsMap]]
[Lean.Server.RpcEncoding.DerivingParams.noConfusionType,[],[]]
[Lean.Meta.ToHide.State.mk.inj,[And.intro],[And, Eq]]
[or_iff_not_imp_right,[Decidable.or_iff_not_imp_right],[Iff, Or]]
[Lean.Environment.allImportedModuleNames,[Lean.EnvironmentHeader.moduleNames, Lean.Environment.header],[Array, Lean.Name]]
[Lean.Parser.Tactic.continue,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Lean.Rat.instLTRat,[LT.mk, Eq, Lean.Rat.lt, Bool.true],[LT, Lean.Rat]]
[Lean.SSet.contains,[Lean.SMap.contains],[Bool]]
[Lean.Server.publishDiagnostics,[IO.FS.Stream.writeLspNotification, Lean.JsonRpc.Notification.mk, Lean.Lsp.PublishDiagnosticsParams.mk, Lean.Server.DocumentMeta.uri, Option.some, Int.ofNat, Lean.Server.DocumentMeta.version],[IO, Unit]]
[Lean.Environment.getNamespaceSet,[Lean.SimplePersistentEnvExtension.getState, Lean.namespacesExt],[Lean.NameSSet]]
[Lean.MetavarDecl.localInstances,[],[Lean.LocalInstances]]
[Lean.Meta.SynthInstance.GeneratorNode.mk.inj,[And.intro],[And, Eq]]
[Array.mapIdxM.map.proof_2,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, OfNat.ofNat, Array.size, Eq.symm, Nat.add_comm, Nat.add_assoc, rfl],[Eq, HAdd.hAdd, OfNat.ofNat, Array.size]]
[Lean.Elab.Term.StructInst.FieldLHS.fieldIndex.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Term.StructInst.FieldLHS.fieldIndex, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.byCases',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.IR.mkExternDecl,[Lean.IR.Decl.extern],[Lean.IR.Decl]]
[Lean.Meta.Simp.preDefault,[Lean.Meta.Simp.tryRewriteCtorEq, Lean.Meta.Simp.rewritePre],[Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step]]
[Lean.Meta.mkHCongrWithArity.withNewEqs,[OfNat.ofNat, List.toArray, List.nil, Lean.Meta.mkHCongrWithArity.withNewEqs.loop],[Lean.Meta.MetaM]]
[Lean.Attribute.Builtin.getIdent?,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, and, not, Lean.Syntax.isNone, Lean.Syntax.getOp, OfNat.ofNat, Lean.Syntax.isIdent, Pure.pure, Option.some, Option.none, or, Lean.throwErrorAt, Lean.ToMessageData.toMessageData],[Lean.AttrM, Option, Lean.Syntax]]
[Lean.Parser.Tactic.skip,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.instReprDeclarationRange,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.DeclarationRange.pos, Std.Format.line, Lean.DeclarationRange.charUtf16, Lean.DeclarationRange.endPos, Lean.DeclarationRange.endCharUtf16],[Repr, Lean.DeclarationRange]]
[Lean.Meta.exfalso,[Lean.Meta.withMVarContext, Bind.bind, Lean.observing?, Lean.Meta.mkFreshLevelMVar, Lean.Meta.apply, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil, Option.none, Option.some, Lean.Meta.MetaM, Lean.MVarId, Pure.pure, Lean.Meta.throwTacticEx, Lean.Syntax.missing],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.Parser.group.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.groupKind],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Server.FileWorker.EditableDocument.headerSnap,[],[Lean.Server.Snapshots.Snapshot]]
[Lean.KVMap.instValueNat,[Lean.KVMap.Value.mk, Lean.DataValue.ofNat, Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofName, Lean.DataValue.ofInt, Option, Nat, Option.some, Option.none],[Lean.KVMap.Value, Nat]]
[List.ibelow,[True, And],[]]
[Lean.MonadResolveName.getOpenDecls,[],[List, Lean.OpenDecl]]
[Lean.Meta.AltVarNames.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.AltVarNames.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.AltVarNames.mk, And]]
[Lean.Elab.Term.Do.ToCodeBlock.getTryCatchUpdatedVars,[],[Lean.NameSet]]
[Lean.instInhabitedFVarIdMap,[Inhabited.mk, EmptyCollection.emptyCollection],[Inhabited, Lean.FVarIdMap]]
[Lean.Parser.Term.optSemicolon.formatter,[Lean.ppDedent.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.symbol.formatter, Lean.ppLine.formatter],[Lean.PrettyPrinter.Formatter]]
[Int.negSucc.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Int.negSucc, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Command.withLogging,[MonadExcept.tryCatch, Lean.Elab.Command.CommandElabM, Unit, Lean.Elab.logException, ite, Eq, Lean.Elab.isAbortExceptionId, Bool.true, Pure.pure, Unit.unit, Bind.bind, Lean.Elab.Command.liftIO, Lean.InternalExceptionId.getName, Lean.Elab.logError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Lean.Elab.Command.CommandElabM, Unit]]
[Nat.zero_lt_succ,[Nat.succ_le_succ, Nat.zero_le],[LT.lt, OfNat.ofNat, Nat.succ]]
[Lean.Parser.Command.whereStructField,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.Term.letDecl],[Lean.Parser.Parser]]
[Lean.Elab.Command.elabClassInductive,[Bind.bind, Lean.Elab.Command.checkValidInductiveModifier, Lean.Elab.Command.CommandElabM, Lean.Elab.Command.InductiveView, Lean.Elab.Command.expandDeclId, Lean.Elab.addDeclarationRanges, Array.mapM, Lean.withRef, Lean.Elab.elabModifiers, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, and, Lean.Elab.Modifiers.isPrivate, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Syntax.getArgs, Lean.Elab.getOptDerivingClasses, Lean.Elab.Command.InductiveView.mk, Lean.Elab.Command.elabInductiveViews, List.toArray, List.cons, List.nil],[Lean.Elab.Command.CommandElabM, Unit]]
[Lean.MetavarContext.MkBinding.reduceLocalContext,[Array.foldr, Lean.LocalContext.erase, Lean.Expr.fvarId!, Array.size, OfNat.ofNat],[Lean.LocalContext]]
[Lean.Elab.Term.elabBorrowed,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Term.elabTerm, Pure.pure, Lean.markBorrowed, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Term.TermElab]]
[OptionT.pure,[OptionT.mk, Pure.pure, Option.some],[OptionT]]
[Lean.Elab.Term.StructInst.Struct.modifyFieldsM,[Lean.Elab.Term.StructInst.Struct, Bind.bind, Pure.pure, Lean.Elab.Term.StructInst.Struct.mk],[Lean.Elab.Term.StructInst.Struct]]
[Lean.Json.CompressWorkItem.objectEnd.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Json.CompressWorkItem.objectEnd, OfNat.ofNat]]
[Lean.Elab.CommandInfo.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.CommandInfo.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.CommandInfo.mk]]
[Lean.Exception.toMessageData,[Lean.MessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.InternalExceptionId.toString],[Lean.MessageData]]
[Lean.Core.instMetaEvalCoreM,[Lean.MetaEval.mk, Bind.bind, Lean.Core.CoreM.toIO, Lean.Core.Context.mk, Lean.Option.get, Lean.maxRecDepth, Lean.Core.State.mk, IO, Lean.Environment, Lean.MetaEval.eval, Lean.Core.State.env, Bool.true],[Lean.MetaEval, Lean.Core.CoreM]]
[Lean.registerTagAttribute,[Bind.bind, Lean.registerPersistentEnvExtension, Lean.PersistentEnvExtensionDescr.mk, Pure.pure, EmptyCollection.emptyCollection, Lean.NameSet.insert, Array.qsort, Lean.Name.quickLt, OfNat.ofNat, HSub.hSub, Array.size, HAppend.hAppend, Std.Format.text, Std.Format.line, Std.ToFormat.format, Std.RBMap.size, Lean.registerBuiltinAttribute, Lean.TagAttribute.mk],[IO, Lean.TagAttribute]]
[Lean.Meta.GetUnfoldEqnFn,[Lean.Meta.MetaM, Option, Lean.Name],[]]
[Lean.instToJsonBool,[Lean.ToJson.mk, Lean.Json.bool],[Lean.ToJson, Bool]]
[Lean.Parser.Command.elab_rules.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.suppressInsideQuot.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.docComment.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.optKind.formatter, Lean.Parser.ident.formatter, Lean.Parser.Term.matchAlts.formatter, Lean.Parser.termParser.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.ToHide.collect,[Bind.bind, Lean.MonadOptions.getOptions, ite, Eq, Lean.Option.get, Lean.Meta.pp.inaccessibleNames, Bool.true, Pure.pure, Prod.mk, EmptyCollection.emptyCollection, Lean.MonadLCtx.getLCtx, StateRefT'.run, ReaderT.run, Lean.Meta.ToHide.fixpoint, Lean.Meta.ToHide.Context.mk, Lean.Meta.ToHide.State.mk, Lean.Meta.MetaM, Prod, Lean.FVarIdSet, Lean.Meta.ToHide.State.hiddenInaccessible, Lean.Meta.ToHide.State.hiddenInaccessibleProp],[Lean.Meta.MetaM, Prod, Lean.FVarIdSet]]
[«term_<=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Parser.Term.ellipsis.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.mkDecIsTrue,[Lean.mkAppB, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil],[Lean.Expr]]
[Lean.Syntax.getAntiquotSuffixSpliceInner,[Lean.Syntax.getOp, OfNat.ofNat],[Lean.Syntax]]
[Lean.Parser.Syntax.sepBy1.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.syntaxParser.formatter, Lean.Parser.strLit.formatter, Lean.Parser.optional.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.Range.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.Range.mk, HAdd.hAdd, OfNat.ofNat]]
[instDecidableTrue,[Decidable.isTrue, trivial],[Decidable, True]]
[Lean.Expr.lam.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Expr.lam, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.assignExprMVar,[Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.assignExpr],[Lean.Meta.MetaM, Unit]]
[Char.ofNat.proof_2,[Or.inl, of_decide_eq_true, Eq.refl, Bool.true],[Or, LT.lt, UInt32.toNat, UInt32.mk, Fin.mk, OfNat.ofNat, of_decide_eq_true, Eq.refl, Bool.true, And]]
[Lean.Meta.DiscrTree.format,[Std.Format, Std.Format.group, Std.Format.FlattenBehavior.allOrNone],[Std.Format]]
[precMax,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[List.eq_of_mem_singleton,[Or.elim, List.eq_or_mem_of_mem_cons, absurd, List.not_mem_nil],[Eq]]
[List.map_append,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.map, List.nil_append, congrFun, HAppend.hAppend, List.map_nil, eq_self, List.cons_append, List.map_cons, List.cons],[Eq, List.map, HAppend.hAppend]]
[Lean.PrettyPrinter.instOrElseParenthesizerM,[OrElse.mk, Lean.PrettyPrinter.ParenthesizerM.orElse],[OrElse, Lean.PrettyPrinter.ParenthesizerM]]
[StdGen.s1,[],[Nat]]
[Std.RBNode.fold,[PProd.fst, PProd.snd],[]]
[Lean.Meta.CongrLemmas.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.CongrLemmas.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.CongrLemmas.mk]]
[Lean.Json.toStructured?,[Lean.FromJson.fromJson?, Lean.ToJson.toJson],[Except, String, Lean.Json.Structured]]
[Lean.JsonRpc.Request.param,[],[]]
[instHashableUInt16,[Hashable.mk, UInt16.toUInt64],[Hashable, UInt16]]
[Lean.Elab.Tactic.ElimApp.Context.targets,[],[Array, Lean.Expr]]
[Lean.Parser.Tactic.measurability!?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.MetavarContext.MkBinding.Exception.revertFailure.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MetavarContext.MkBinding.Exception.revertFailure, HAdd.hAdd, OfNat.ofNat]]
[Lean.mkBaseNameFor,[ite, Eq, not, Lean.Environment.contains, HAppend.hAppend, Bool.true, OfNat.ofNat, Lean.mkBaseNameFor.go],[Lean.Name]]
[Array.findSome?,[Id.run, Array.findSomeM?],[Option]]
[Lean.Parsec.pchar,[Lean.Parsec.attempt, Bind.bind, Lean.Parsec.anyChar, ite, Eq, Pure.pure, Lean.Parsec.fail, HAppend.hAppend, ToString.toString],[Lean.Parsec, Char]]
[Lean.Parser.Command.open.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.openDecl.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Lsp.ClientCapabilities.noConfusion,[noConfusionEnum, Lean.Lsp.ClientCapabilities.toCtorIdx],[Lean.Lsp.ClientCapabilities.noConfusionType]]
[Lean.Elab.Term.MatchAltView.mk.inj,[And.intro],[And, Eq]]
[Lean.SimplePersistentEnvExtension.modifyState,[Lean.PersistentEnvExtension.modifyState, Prod, List, Prod.mk],[Lean.Environment]]
[Lean.Meta.instBEqInfoCacheKey,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Meta.InfoCacheKey]]
[Lean.Elab.Command.StructView.modifiers,[],[Lean.Elab.Modifiers]]
[Lean.registerParametricAttribute,[Bind.bind, Lean.registerPersistentEnvExtension, Lean.PersistentEnvExtensionDescr.mk, Lean.AttributeImplCore.name, Lean.ParametricAttributeImpl.toAttributeImplCore, Pure.pure, EmptyCollection.emptyCollection, SeqRight.seqRight, Lean.ParametricAttributeImpl.afterImport, Lean.NameMap.insert, Prod.fst, Prod.snd, Array.qsort, Lean.Name.quickLt, OfNat.ofNat, HSub.hSub, Array.size, HAppend.hAppend, Std.Format.text, Std.Format.line, Std.ToFormat.format, Std.RBMap.size, Lean.registerBuiltinAttribute, Lean.ParametricAttribute.mk],[IO, Lean.ParametricAttribute]]
[Lean.ScopedEnvExtension.instInhabitedDescr,[Inhabited.mk, Lean.ScopedEnvExtension.Descr.mk, arbitrary],[Inhabited, Lean.ScopedEnvExtension.Descr]]
[ReaderT.run_bind,[rfl],[Eq, ReaderT.run, Bind.bind]]
[Lean.ConstructorVal.mk.inj,[And.intro],[And, Eq]]
[Lean.mkSimpleFnCall,[HAppend.hAppend, List.foldl, List.intersperse],[String]]
[Lean.Meta.Match.Alt.checkAndReplaceFVarId,[Unit.unit, Lean.Meta.MetaM, Lean.Meta.Match.Alt, List.find?, BEq.beq, Lean.LocalDecl.fvarId, Lean.Meta.Match.Alt.fvarDecls, Lean.throwErrorAt, Lean.Meta.Match.Alt.ref, Lean.ToMessageData.toMessageData, Bind.bind, Lean.Meta.inferType, Lean.Meta.isDefEqGuarded, Lean.LocalDecl.type, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.withExistingLocalDecls, Lean.Meta.addPPExplicitToExposeDiff, PUnit, HAppend.hAppend, Lean.mkFVar, Lean.indentExpr],[Lean.Meta.MetaM, Lean.Meta.Match.Alt]]
[Int.ofNat_mul,[rfl],[Eq, Int.ofNat, HMul.hMul]]
[Lean.Parser.FirstTokens.optTokens.inj,[],[Eq]]
[Lean.Meta.Simp.SimpLetCase.noConfusion,[noConfusionEnum, Lean.Meta.Simp.SimpLetCase.toCtorIdx],[Lean.Meta.Simp.SimpLetCase.noConfusionType]]
[Lean.Elab.Term.Do.getDoLetVars,[Lean.Elab.Term.Do.getLetDeclVars, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Elab.Term.TermElabM, Array, Lean.Name]]
[Lean.IR.CtorLayout.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.CtorLayout.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.LeadingIdentBehavior.both.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Parser.LeadingIdentBehavior.both, OfNat.ofNat]]
[Lean.KeyedDeclsAttribute.Def.noConfusionType,[],[]]
[Lean.Lsp.instFromJsonDocumentFilter,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, String, Pure.pure, Lean.Lsp.DocumentFilter.mk],[Lean.FromJson, Lean.Lsp.DocumentFilter]]
[Lean.Meta.Match.mkMatcher,[Lean.Meta.MetaM, Lean.Meta.Match.MatcherResult, Lean.Meta.forallBoundedTelescope, Option.some, Bind.bind, ite, Eq, List.any, bne, List.length, Lean.Meta.Match.AltLHS.patterns, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Meta.getLevel, BEq.beq, Lean.levelZero, Lean.Meta.mkFreshLevelMVar],[Lean.Meta.MetaM, Lean.Meta.Match.MatcherResult]]
[Lean.Elab.CompletionInfo.dot.inj,[And.intro],[And, Eq]]
[Lean.IR.instToStringDecl,[ToString.mk, Lean.IR.declToString],[ToString, Lean.IR.Decl]]
[Lean.Parser.Attr.simple,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.optional, HOrElse.hOrElse, Lean.Parser.priorityParser],[Lean.Parser.Parser]]
[Lean.Meta.RecursorUnivLevelPos.majorType.inj,[],[Eq]]
[Lean.ConstantInfo.isCtor,[Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo, Bool, Bool.true, Bool.false],[Bool]]
[IO.FS.Handle.putStrLn,[IO.FS.Handle.putStr, String.push, Char.ofNat],[IO, Unit]]
[fix1,[fixCore1, arbitrary],[]]
[Lean.Widget.MsgEmbed.instToJsonRpcEncodingPacket,[Lean.ToJson.mk, Lean.Json, Lean.Json.mkObj, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil, Lean.Json.arr, List.toArray],[Lean.ToJson]]
[Lean.Elab.Term.withoutErrToSorry,[MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.Context.declName?, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.currMacroScope, Lean.Elab.Term.Context.mayPostpone, Bool.false, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.Term.Context.autoBoundImplicits, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection],[Lean.Elab.Term.TermElabM]]
[instMonadExceptOfExceptT_1,[MonadExceptOf.mk, ExceptT.mk, Pure.pure, Except.error, ExceptT.tryCatch],[MonadExceptOf, ExceptT]]
[Std.RBTree.fromList,[List.foldl, Std.RBTree.insert, Std.mkRBTree],[Std.RBTree]]
[Lean.Lsp.SymbolKind.module.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.module, OfNat.ofNat]]
[Lean.MonadNameGenerator.noConfusionType,[],[]]
[Array.all,[Id.run, Array.allM],[Bool]]
[fixCore,[fixCore1],[]]
[Lean.Parser.Term.structInstFieldAbbrev,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.atomic, HAndThen.hAndThen, Lean.Parser.Term.ident, Lean.Parser.notFollowedBy, HOrElse.hOrElse, Lean.Parser.symbol],[Lean.Parser.Parser]]
[Lean.getNumBuiltiAttributesImpl,[Bind.bind, ST.Ref.get, Lean.attributeMapRef, Pure.pure, Std.PersistentHashMap.size],[IO, Nat]]
[«term_↔_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Meta.AbstractNestedProofs.Context.mk.inj,[],[Eq]]
[Lean.Parser.Tactic.simpa!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[ExceptT.run_throw,[rfl],[Eq, ExceptT.run, MonadExcept.throw, Pure.pure, Except.error]]
[Lean.Elab.Deriving.FromToJson.mkFromJsonInstanceHandler.mkAlts,[Bind.bind, Array.mapM, Lean.getConstInfoCtor, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, ForIn.forIn, MProd.mk, liftM, Lean.Meta.getLocalDecl, Lean.Expr.fvarId!, ite, Eq, not, Lean.Name.hasMacroScopes, Lean.LocalDecl.userName, Bool.true, Pure.pure, PUnit.unit, Lean.Elab.Term.TermElabM, Prod, Lean.Syntax, Nat, Array.mapIdxM, Fin.val, BEq.beq, Array.size, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.InductiveVal.ctors, Prod.fst],[Lean.Elab.Term.TermElabM, Array, Lean.Syntax]]
[Lean.Meta.RewriteResult.eNew,[],[Lean.Expr]]
[Lean.Syntax.find?,[Lean.Syntax.findAux],[Option, Lean.Syntax]]
[Lean.Meta.Simp.instInhabitedConfig,[Inhabited.mk, Lean.Meta.Simp.Config.mk, arbitrary],[Inhabited, Lean.Meta.Simp.Config]]
[Lean.Meta.PostponedEntry.mk.inj,[And.intro],[And, Eq]]
[Lean.Lsp.instFromJsonServerInfo,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, String, Option, Pure.pure, Lean.Lsp.ServerInfo.mk],[Lean.FromJson, Lean.Lsp.ServerInfo]]
[Std.Range.«term[:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[termPrintln!__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[ByteArray.toSlice,[ByteSlice.mk, OfNat.ofNat, ByteArray.size],[ByteSlice]]
[Lean.Meta.Context.mk.inj,[And.intro],[And, Eq]]
[Lean.Meta.Match.examplesToMessageData,[Lean.MessageData.joinSep, List.map, Function.comp, Lean.Meta.Match.Example.toMessageData, Lean.Meta.Match.Example.varsToUnderscore, Lean.MessageData.ofFormat, Std.ToFormat.format],[Lean.MessageData]]
[Lean.Parser.Term.binop_lazy.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.ppSpace.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Formatter]]
[instOrdNat,[Ord.mk, compareOfLessAndEq],[Ord, Nat]]
[Lean.Parser.Error.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.Error.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.Error.mk, And]]
[IO.FileRight.noConfusionType,[],[]]
[Std.RBTree.depth,[Std.RBMap.depth],[Nat]]
[Lean.Lsp.DiagnosticWith.severity?,[],[Option, Lean.Lsp.DiagnosticSeverity]]
[panicWithPos,[panic, HAppend.hAppend, ToString.toString],[]]
[Nat.coprime.coprime_div_right,[Nat.coprime.symm, Nat.coprime.coprime_div_left],[Nat.coprime, HDiv.hDiv]]
[Lean.Meta.ToHide.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.ToHide.State.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.ToHide.State.mk, And]]
[Lean.DataValue.ofBool.inj,[],[Eq]]
[Lean.Elab.Term.Do.ToCodeBlock.Context.mk.inj,[And.intro],[And, Eq]]
[Std.PersistentHashSet.fold,[Id.run, Std.PersistentHashSet.foldM],[]]
[UInt8.instSemiringUInt8.proof_6,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, HMul.hMul, UInt8.zero_def, UInt8.mul_def, UInt8.mk, OfNat.ofNat, MonoidWithZero.mul_zero, UInt8.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt8],[Eq, HMul.hMul, OfNat.ofNat]]
[Subsingleton.allEq,[],[Eq]]
[ByteArray.forInUnsafe,[OfNat.ofNat, ByteArray.forInUnsafe.loop],[]]
[Lean.getPPNotation,[Lean.KVMap.get, Lean.Option.name, Lean.pp.notation, not, Lean.getPPAll],[Bool]]
[Except.bind,[Except, Except.error],[Except]]
[Lean.IR.EmitC.emitNumLit,[ite, Eq, Lean.IR.IRType.isObj, Bool.true, LT.lt, UInt32.size, Bind.bind, Lean.IR.EmitC.emit],[Lean.IR.EmitC.M, Unit]]
[Lean.Parser.Command.reduce,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.Expr.ReplaceLevelImpl.State.keys,[],[Array, Lean.Expr]]
[Lean.KernelException.toMessageData,[Lean.MessageData, Lean.MessageData.withContext, Lean.MessageDataContext.mk, Lean.MetavarContext.mk, Lean.LocalContext.mk, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Declaration.axiomDecl, Lean.Declaration.opaqueDecl, Lean.Declaration.quotDecl, Lean.Declaration.mutualDefnDecl, Lean.Declaration.inductDecl, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr],[Lean.MessageData]]
[Lean.Xml.Parser.Eq,[SeqLeft.seqLeft, SeqRight.seqRight, optional, Lean.Xml.Parser.S, Lean.Parsec.skipChar, Char.ofNat],[Lean.Parsec, Unit]]
[PProd.mk.inj,[And.intro],[And, Eq]]
[List.mapIdx,[OfNat.ofNat, List.mapIdx.loop],[List]]
[Nat.lt_le_antisymm,[Nat.le_lt_antisymm],[False]]
[Lean.Parser.Term.doCatchMatch.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.doMatchAlts.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.isReadOnlyExprMVar,[Bind.bind, Lean.Meta.getMVarDecl, Lean.MonadMCtx.getMCtx, Pure.pure, bne, Lean.MetavarDecl.depth, Lean.MetavarContext.depth],[Lean.Meta.MetaM, Bool]]
[Lean.IR.IRType.union.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, Eq.refl, List.nil, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.IR.IRType.union, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.CommandInfo.toElabInfo,[],[Lean.Elab.ElabInfo]]
[Lean.Macro.instMonadQuotationMacroM,[Lean.MonadQuotation.mk, Pure.pure, Lean.Macro.Context.currMacroScope, Lean.Macro.Context.mainModule, Lean.Macro.withFreshMacroScope],[Lean.MonadQuotation, Lean.MacroM]]
[Lean.Parser.optPrecedence.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.precedence.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Parser.Tactic.existsi,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Sigma.noConfusionType,[],[]]
[Lean.Elab.Term.elabBinders,[Lean.Elab.Term.elabBindersEx, Array.map, Prod.snd],[Lean.Elab.Term.TermElabM]]
[Lean.JsonRpc.instDecidableLt,[inferInstanceAs, Decidable, Eq, Lean.JsonRpc.RequestID.str, Lean.JsonRpc.RequestID.num, Lean.JsonRpc.RequestID.null, Bool, Decidable.decide, LT.lt, Bool.true, Bool.false],[Decidable, LT.lt]]
[Mathlib.Tactic.Ext.commandDeclareExtTheoremsFor__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Meta.mkLetBodyCongr,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Compiler.atMostOnce,[Bool],[Bool]]
[Lean.PrefixTree.foldM,[Lean.PrefixTree.foldMatchingM, List.nil],[]]
[Lean.Meta.cleanup,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, StateRefT'.run', Prod.mk, Bool.false, EmptyCollection.emptyCollection, Lean.MonadLCtx.getLCtx, ForIn.forIn, ite, Eq, Std.RBTree.contains, Lean.LocalDecl.fvarId, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Meta.getLocalInstances, Lean.Meta.getMVarType, Lean.Meta.instantiateMVars, Lean.Meta.getMVarTag, Lean.Meta.mkFreshExprMVarAt, Lean.MetavarKind.syntheticOpaque, OfNat.ofNat, Lean.Meta.assignExprMVar, Lean.Expr.mvarId!, Lean.Meta.cleanup.addUsedFVars, Lean.Meta.cleanup.addDeps, Lean.Meta.cleanup.addUsedFVar, Lean.Meta.cleanup.collectPropsStep, Lean.Meta.cleanup.collectProps, Lean.Meta.cleanup.collectUsed],[Lean.Meta.MetaM, Lean.MVarId]]
[IO.Error.noFileOrDirectory.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.noFileOrDirectory, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.noFileOrDirectory, And]]
[Lean.Elab.Term.Context.fileMap,[],[Lean.FileMap]]
[Lean.Elab.throwAlreadyDeclaredUniverseLevel,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData],[]]
[Lean.Xml.Parser.Nmtoken,[Lean.Parsec.many1Chars, Lean.Xml.Parser.NameChar],[Lean.Parsec, String]]
[Lean.Lsp.SymbolKind.namespace.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SymbolKind.namespace, OfNat.ofNat]]
[Lean.Elab.Term.elabBinRelNoProp,[Lean.Elab.Term.elabBinRelCore, Bool.true],[Lean.Elab.Term.TermElab]]
[Lean.Meta.DiscrTree.Trie.below,[PProd, PUnit],[]]
[Lean.MessageData.ofName.injEq,[Eq.propIntro, Eq.refl, Lean.MessageData.ofName, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.MessageData.ofName]]
[Lean.Parser.Command.noncomputableSection.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.KernelException.declTypeMismatch.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.declTypeMismatch, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.KernelException.declTypeMismatch, And]]
[congr_fun,[congrFun],[Eq]]
[Lean.PrettyPrinter.Parenthesizer.ident.parenthesizer,[Lean.Parser.Term.ident.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Elab.CompletionInfo.id.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.CompletionInfo.id, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.CompletionInfo.id, And]]
[Lean.IR.EmitC.emitFullApp,[Bind.bind, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.getDecl, Lean.IR.Decl.fdecl, Lean.IR.EmitC.M, Unit, Lean.IR.EmitC.emitExternCall, Lean.IR.EmitC.emitCName, ite, GT.gt, Array.size, OfNat.ofNat, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitArgs, Pure.pure, PUnit.unit],[Lean.IR.EmitC.M, Unit]]
[String.revFind,[ite, Eq, BEq.beq, String.bsize, OfNat.ofNat, Bool.true, Option.none, String.revFindAux, String.prev],[Option, String.Pos]]
[Lean.Meta.Match.Example.val.inj,[],[Eq]]
[Lean.PPFns.ppTerm,[],[IO, Std.Format]]
[Lean.Meta.Cases.Context.majorTypeFn,[],[Lean.Expr]]
[Lean.Lsp.instFileSourceRpcConnectParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.RpcConnectParams.uri],[Lean.Lsp.FileSource, Lean.Lsp.RpcConnectParams]]
[Lean.Meta.Match.Unify.Context.altFVarDecls,[],[List, Lean.LocalDecl]]
[Lean.Parser.Term.match,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.Term.generalizingParam, Lean.Parser.sepBy1, Lean.Parser.Term.matchDiscr, Bool.false, Lean.Parser.Term.optType, Lean.Parser.Term.matchAlts, Lean.Parser.termParser, OfNat.ofNat],[Lean.Parser.Parser]]
[Lean.Meta.PostponedEntry.noConfusionType,[],[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.funBinders,[],[Array, Bool]]
[Lean.Expr.instHashableExpr,[Hashable.mk, Lean.Expr.hash],[Hashable, Lean.Expr]]
[Lean.Elab.Term.Context.errToSorry,[],[Bool]]
[Lean.Parser.Term.matchAltsWhereDecls,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.matchAlts, Lean.Parser.termParser, Lean.Parser.optional, Lean.Parser.Term.whereDecls],[Lean.Parser.Parser]]
[Lean.Meta.ToHide.Context.noConfusionType,[],[]]
[Lean.AxiomVal.noConfusionType,[],[]]
[USize.one_def,[rfl],[Eq, OfNat.ofNat, USize.mk]]
[Lean.termEval_prec_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Tactic.closeMainGoalUsing,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.getMainTarget, Lean.Elab.Tactic.closeMainGoal],[Lean.Elab.Tactic.TacticM, Unit]]
[ExceptT.run_pure,[rfl],[Eq, ExceptT.run, Pure.pure, Except.ok]]
[Std.RBNode.max,[Unit.unit, Std.RBNode.node, Option, Sigma, Option.none, Option.some, Sigma.mk, PProd.fst, PProd.snd],[Option, Sigma]]
[instSizeOfName,[SizeOf.mk, Lean.Name.sizeOf],[SizeOf, Lean.Name]]
[Lean.Lsp.instToStringPosition,[ToString.mk, HAppend.hAppend, ToString.toString, Lean.Lsp.Position.line, Lean.Lsp.Position.character],[ToString, Lean.Lsp.Position]]
[Lean.Lsp.SemanticTokensLegend.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Lsp.SemanticTokensLegend.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Compiler.natFoldFns,[List.cons, Prod.mk, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Compiler.foldNatAdd, Lean.Compiler.foldNatMul, Lean.Compiler.foldNatDiv, Lean.Compiler.foldNatMod, Lean.Compiler.foldNatPow, Lean.Compiler.foldNatDecEq, Lean.Compiler.foldNatDecLt, Lean.Compiler.foldNatDecLe, List.nil],[List, Prod, Lean.Name, Lean.Compiler.BinFoldFn]]
[Lean.Elab.Command.mkCommandElabAttributeUnsafe,[Lean.Elab.mkElabAttribute, Lean.Elab.Command.CommandElab, Lean.Name.mkStr, Lean.Name.anonymous],[IO, Lean.KeyedDeclsAttribute, Lean.Elab.Command.CommandElab]]
[instMonadEIO,[inferInstanceAs, Monad, EStateM, IO.RealWorld],[Monad, EIO]]
[Lean.Elab.CompletionInfo.namespaceId.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.CompletionInfo.namespaceId, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.ExplicitBoxing.mkBoxedName,[Lean.Name.mkStr],[Lean.Name]]
[dbgTraceIfShared,[],[]]
[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.next,[ite, Eq, BEq.beq, HAdd.hAdd, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.curr, OfNat.ofNat, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.top, Bool.true, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.mk, HMul.hMul, Lean.PrettyPrinter.Delaborator.SubExpr.maxChildren],[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator]]
[Lean.Meta.Match.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Match.State.mk, HAdd.hAdd, OfNat.ofNat]]
[HDiv.noConfusionType,[],[]]
[Lean.Meta.mkId,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getLevel, Pure.pure, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[Std.RBMap.insert,[Std.RBMap, Subtype.mk, Std.RBNode.insert, Std.RBMap.insert.proof_1],[Std.RBMap]]
[Lean.Elab.abstractNestedProofs,[ite, Eq, or, Lean.Elab.DefKind.isTheorem, Lean.Elab.PreDefinition.kind, Lean.Elab.DefKind.isExample, Bool.true, Pure.pure, Bind.bind, Lean.Meta.abstractNestedProofs, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.value, Lean.Elab.PreDefinition.mk, Lean.Elab.PreDefinition.ref, Lean.Elab.PreDefinition.levelParams, Lean.Elab.PreDefinition.modifiers, Lean.Elab.PreDefinition.type],[Lean.Meta.MetaM, Lean.Elab.PreDefinition]]
[Lean.Json.instFromJsonStructured,[Lean.FromJson.mk, Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Except, String, Lean.Json.Structured, Pure.pure, Lean.Json.Structured.arr, Lean.Json.Structured.obj, MonadExcept.throw, HAppend.hAppend, ToString.toString],[Lean.FromJson, Lean.Json.Structured]]
[Lean.Elab.checkNotAlreadyDeclared,[Bind.bind, Lean.MonadEnv.getEnv, ite, Eq, Lean.Environment.contains, Bool.true, Unit.unit, Unit, Lean.privateToUserName?, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Unit]]
[Lean.DeclarationRanges.range,[],[Lean.DeclarationRange]]
[Lean.Elab.Term.StructInst.mkProjStx?,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.findField?, ite, Eq, Option.isNone, Bool.true, Option.none, PUnit.unit],[Lean.Elab.Term.TermElabM, Option, Lean.Syntax]]
[Lean.Parser.Command.attribute,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.sepBy1, HOrElse.hOrElse, Lean.Parser.Command.eraseAttr, Lean.Parser.Term.attrInstance, Bool.false, Lean.Parser.many1, Lean.Parser.ident],[Lean.Parser.Parser]]
[Sum.inl.injEq,[Eq.propIntro, Eq.refl, Sum.inl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Sum.inl]]
[Std.HashSetImp.find?.proof_1,[Subtype.property],[GT.gt, Array.size, Subtype.val, OfNat.ofNat]]
[Lean.ppGroup.formatter,[Lean.PrettyPrinter.Formatter.group, Lean.PrettyPrinter.Formatter.indent, Option.none],[Lean.PrettyPrinter.Formatter]]
[Lean.IR.ExplicitBoxing.BoxingContext.noConfusionType,[],[]]
[Lean.Elab.Deriving.Repr.mkAuxFunction,[Bind.bind, Pure.pure, Array.getOp, Lean.Elab.Deriving.Context.auxFunNames, Lean.Elab.Deriving.Context.typeInfos, Lean.Elab.Deriving.Repr.mkReprHeader, Lean.Elab.Deriving.Repr.mkBody, ite, Eq, Lean.Elab.Deriving.Context.usePartial, Bool.true, Lean.Elab.Deriving.mkLocalInstanceLetDecls, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.Deriving.Header.argNames, Lean.Elab.Deriving.mkLet, PUnit.unit],[Lean.Elab.Term.TermElabM, Lean.Syntax]]
[Lean.Meta.abstractMVars,[Bind.bind, Lean.Meta.instantiateMVars, Lean.MonadMCtx.getMCtx, Lean.MonadLCtx.getLCtx, Lean.MonadNameGenerator.getNGen, Lean.Meta.MetaM, Lean.Meta.AbstractMVarsResult, Lean.MonadNameGenerator.setNGen, Lean.Meta.AbstractMVars.State.ngen, Lean.Meta.setMCtx, Lean.Meta.AbstractMVars.State.mctx, Pure.pure, Lean.Meta.AbstractMVarsResult.mk, Lean.Meta.AbstractMVars.State.paramNames, Array.size, Lean.Meta.AbstractMVars.State.fvars],[Lean.Meta.MetaM, Lean.Meta.AbstractMVarsResult]]
[Lean.IR.Checker.checkArgs,[Array.forM, Lean.IR.Checker.checkArg, OfNat.ofNat, Array.size],[Lean.IR.Checker.M, Unit]]
[Lean.Meta.whnfForall,[Bind.bind, Lean.Meta.whnf, ite, Eq, Lean.Expr.isForall, Bool.true, Pure.pure],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.Lsp.TextDocumentChangeRegistrationOptions.syncKind,[],[Lean.Lsp.TextDocumentSyncKind]]
[Set,[],[]]
[Lean.BinderInfo.isAuxDecl,[Lean.BinderInfo.default, Lean.BinderInfo.implicit, Lean.BinderInfo.strictImplicit, Lean.BinderInfo.instImplicit, Unit.unit, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Elab.Frontend.elabCommandAtFrontend,[Lean.Elab.Frontend.runCommandElabM, Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, Lean.MonadOptions.getOptions, ite, Eq, Lean.checkTraceOption, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.enableInfoTree, Pure.pure, PUnit.unit],[Lean.Elab.Frontend.FrontendM, Unit]]
[Subrelation.accessible,[Subrelation.accessible.proof_1],[Acc]]
[Lean.LocalDecl.binderInfo,[Lean.BinderInfo, Lean.BinderInfo.default],[Lean.BinderInfo]]
[Lean.MetavarContext.LevelMVarToParam.State.mctx,[],[Lean.MetavarContext]]
[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.top,[],[Nat]]
[Lean.Expr.looseBVarRange,[UInt32.toNat, Lean.Expr.Data.looseBVarRange, Lean.Expr.data],[Nat]]
[HSub.noConfusionType,[],[]]
[Array.unzip,[Array.foldl, Prod, Array, Prod.mk, Array.push, List.toArray, List.nil, OfNat.ofNat, Array.size],[Prod, Array]]
[Prod.swap_left_inverse,[Prod.swap_swap],[Function.left_inverse, Prod.swap]]
[Lean.Lsp.PlainTermGoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.PlainTermGoal.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.PlainTermGoal.mk, And]]
[Lean.InductiveVal.isNestedEx,[Lean.InductiveVal.isNested],[Bool]]
[MonadExcept.noConfusionType,[],[]]
[Std.AssocList.foldl,[Id.run, Std.AssocList.foldlM],[]]
[Lean.Meta.withReducibleAndInstances,[Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.instances],[]]
[Lean.Elab.Term.processDefDeriving,[Bind.bind, MonadExcept.tryCatch, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.Elab.Term.TermElabM, Bool, liftM, Lean.Meta.mkConstWithFreshMVarLevels, Lean.Meta.inferType, List.toArray, List.nil, Lean.DefinitionVal.value, Option.none, Lean.Meta.check, Lean.Elab.liftMacroM, Lean.Elab.mkUnusedBaseName, Lean.Name.appendAfter, Lean.Name.appendBefore, Lean.Name.getString!, Lean.Meta.instantiateMVars, Lean.Elab.Term.MkInstResult.instVal, Lean.addAndCompile, Lean.Declaration.defnDecl, Lean.DefinitionVal.mk, Lean.ConstantVal.mk, Lean.ConstantVal.levelParams, Lean.DefinitionVal.toConstantVal, Lean.DefinitionVal.hints, Lean.DefinitionVal.safety, Lean.Meta.addInstance, Lean.AttributeKind.global, OfNat.ofNat, Pure.pure, Bool.true, Bool.false],[Lean.Elab.Term.TermElabM, Bool]]
[Lean.Parser.Tactic.simp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpStar, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Parser.Term.waitIfTypeMVar,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.termParser],[Lean.Parser.Parser]]
[USize.toNat,[Fin.val, USize.val],[Nat]]
[Lean.EnvExtensionInterfaceUnsafe.Ext.idx,[],[Nat]]
[Lean.Parser.Term.structInstField,[Lean.Parser.ppGroup, Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.structInstLVal, Lean.Parser.symbol, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.Elab.Tactic.ElimApp.Context.mk.inj,[And.intro],[And, Eq]]
[UInt32.instCommRingUInt32.proof_1,[UInt32.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, UInt32.val, UInt32.mul_def, CommSemiring.mul_comm],[Eq, HMul.hMul]]
[Lean.HeadIndex.mvar.inj,[],[Eq]]
[set.piecewise,[ite, Mem.mem],[]]
[Lean.Parser.charLitNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.charLitFn],[Lean.Parser.Parser]]
[Lean.Compiler.getInfoFromFn,[Unit.unit, Option, Lean.Compiler.NumScalarTypeInfo, Option.none, ite, Eq, BEq.beq, Lean.Compiler.NumScalarTypeInfo.ofNatFn, Bool.true, Option.some, PProd.fst],[Option, Lean.Compiler.NumScalarTypeInfo]]
[exists₄_congr,[exists_congr, exists₃_congr],[Iff, Exists]]
[Subtype.ext,[Eq, of_eq_true, Eq.trans, Subtype.mk.injEq, congrFun, congrArg, eq_self],[Eq]]
[Lean.Lsp.PlainTermGoalParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.PlainTermGoalParams.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Lsp.PlainTermGoalParams.mk]]
[Nat.gcd_pos_of_pos_right,[Nat.pos_of_dvd_of_pos, Nat.gcd_dvd_right],[LT.lt, OfNat.ofNat, Nat.gcd]]
[ite,[],[]]
[Monad.toApplicative,[],[Applicative]]
[Lean.Elab.Term.MutualClosure.ClosureState.noConfusionType,[],[]]
[Tactic.Ring.HornerExpr.const.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Tactic.Ring.HornerExpr.const, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.State.cache,[],[Lean.Meta.Cache]]
[LawfulMonad.noConfusionType,[],[]]
[Lean.Elab.Tactic.ElimApp.mkElimApp,[Bind.bind, Lean.Elab.Term.mkConst, List.nil, liftM, Lean.Meta.inferType, StateRefT'.run, ReaderT.run, Lean.Elab.Tactic.ElimApp.Context.mk, Lean.Elab.Tactic.ElimApp.State.mk, Lean.Elab.Term.TermElabM, Lean.Elab.Tactic.ElimApp.Result, ForIn.forIn, MonadExcept.tryCatch, Lean.Elab.Term.synthesizeInstMVarCore, Option.none, ite, Eq, Bool.true, Pure.pure, PUnit.unit, MProd.mk, Lean.Meta.setMVarKind, Lean.MetavarKind.syntheticOpaque, MProd.fst, ForInStep.yield, Lean.Meta.instantiateMVars, Lean.Elab.Tactic.ElimApp.State.f, Lean.Elab.Tactic.ElimApp.Result.mk, Lean.Elab.Tactic.ElimApp.State.alts, Lean.Elab.Tactic.ElimApp.mkElimApp.loop],[Lean.Elab.Term.TermElabM, Lean.Elab.Tactic.ElimApp.Result]]
[Lean.Meta.mkSyntheticSorry,[Bind.bind, Lean.Meta.getLevel, Pure.pure, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil],[Lean.Meta.MetaM, Lean.Expr]]
[List.nil.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, List.nil, OfNat.ofNat]]
[Lean.Parser.darrow.formatter,[Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Subarray.foldl,[Id.run, Subarray.foldlM],[]]
[Lean.Meta.whenUndefDo,[Bind.bind, Unit.unit, Lean.Meta.MetaM, Bool, Pure.pure, Bool.true, Bool.false],[Lean.Meta.MetaM, Bool]]
[Lean.Parser.precedence,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.precedenceParser, Lean.Parser.maxPrec],[Lean.Parser.Parser]]
[Lean.Meta.Match.instantiateAltLHSMVars,[Bind.bind, List.mapM, Lean.Meta.instantiateLocalDeclMVars, Lean.Meta.Match.AltLHS.fvarDecls, Lean.Meta.Match.instantiatePatternMVars, Lean.Meta.Match.AltLHS.patterns, Pure.pure, Lean.Meta.Match.AltLHS.mk, Lean.Meta.Match.AltLHS.ref],[Lean.Meta.MetaM, Lean.Meta.Match.AltLHS]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withLetValue,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.SubExpr.descend, OfNat.ofNat, panicWithPosWithDecl],[]]
[Lean.Elab.Command.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Command.State.mk, HAdd.hAdd, OfNat.ofNat]]
[String.firstDiffPos,[OfNat.ofNat, String.firstDiffPos.loop],[String.Pos]]
[Lean.IR.LogEntry.message.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.LogEntry.message, HAdd.hAdd, OfNat.ofNat]]
[Lean.MonadError.toMonadExceptOf,[],[MonadExceptOf, Lean.Exception]]
[Lean.mkMVarEx,[Lean.mkMVar],[Lean.Expr]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.collectHigherOrders,[Bind.bind, MonadReader.read, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit, ForIn.forIn, PUnit.unit, ite, Eq, not, or, BEq.beq, Array.getOp, Lean.BinderInfo.implicit, Lean.BinderInfo.strictImplicit, Bool.true, Pure.pure, ForInStep.yield],[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit]]
[UInt64.val_eq_of_eq,[Eq, UInt64.val, congrArg],[Eq, UInt64.val]]
[Function.id_def,[rfl],[Eq, id]]
[Lean.Elab.logTrace,[Lean.Elab.logInfo, Lean.MessageData.tagged, HAppend.hAppend, Lean.ToMessageData.toMessageData],[Unit]]
[Decidable.imp_iff_not_or,[Iff.intro, Decidable.not_or_of_imp, Or.neg_resolve_left],[Iff, Or, Not]]
[Lean.Elab.Term.getMVarDecl,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.getDecl],[Lean.Elab.Term.TermElabM, Lean.MetavarDecl]]
[Lean.Meta.State.noConfusionType,[],[]]
[Std.HashMap.insert',[Prod, Std.HashMap, Bool, Std.HashMapImp.insert, Std.HashMap.insert'.proof_1, Prod.mk, Subtype.mk, Std.HashMap.insert'.proof_2],[Prod, Std.HashMap, Bool]]
[Lean.PrefixTree,[Subtype, Lean.PrefixTreeNode.WellFormed],[]]
[Lean.Meta.NormNum.instLawfulOfNatNat,[Lean.Meta.NormNum.instLawfulOfNatNat.proof_1],[Lean.Meta.NormNum.LawfulOfNat, Nat]]
[Lean.Parser.AliasValue.const.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.AliasValue.const, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Parser.AliasValue.const]]
[Lean.Parser.Tactic.eapply',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Elab.Term.StructInst.Struct.setFields,[Lean.Elab.Term.StructInst.Struct.modifyFields],[Lean.Elab.Term.StructInst.Struct]]
[Lean.Parser.Tactic.Conv.change,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.instToJsonArray,[Lean.ToJson.mk, Lean.Json.arr, Array.map, Lean.ToJson.toJson],[Lean.ToJson, Array]]
[Lean.Level.PP.Result.offset.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Level.PP.Result.offset, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Level.PP.Result.offset, And]]
[tacticExfalso,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Std.RBMap.min!,[Unit.unit, Prod, Std.RBMap.min, panicWithPosWithDecl, OfNat.ofNat],[Prod]]
[Lean.Server.RequestContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.RequestContext.mk, HAdd.hAdd, OfNat.ofNat]]
[instTransEq,[Trans.mk, instTransEq.proof_1],[Trans, Eq]]
[Lean.Meta.SynthInstanceCache,[Std.PersistentHashMap, Lean.Expr, Option],[]]
[dif_neg,[Eq, dite, absurd, rfl],[Eq, dite]]
[USize.xor,[USize.mk, Fin.xor, USize.val],[USize]]
[Lean.ConstantInfo.thmInfo.injEq,[Eq.propIntro, Eq.refl, Lean.ConstantInfo.thmInfo, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.ConstantInfo.thmInfo]]
[Lean.Elab.Tactic.ElimApp.evalAlts.applyPreTac,[ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, List.cons, List.nil, Lean.Elab.Tactic.evalTacticAt, Lean.Syntax.getOp, OfNat.ofNat],[Lean.Elab.Tactic.TacticM, List, Lean.MVarId]]
[Bool.and_true,[rfl, Eq.symm, Eq.refl],[Eq, and, Bool.true]]
[Lean.Lsp.instToJsonWorkDoneProgressEnd,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.WorkDoneProgressEnd.kind, List.nil, Lean.Json.opt, Lean.Lsp.WorkDoneProgressEnd.message?],[Lean.ToJson, Lean.Lsp.WorkDoneProgressEnd]]
[Lean.Server.WithRpcRef.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Server.WithRpcRef.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Tactic.mkTacticAttribute,[Lean.Elab.mkElabAttribute, Lean.Elab.Tactic.Tactic, Lean.Name.mkStr, Lean.Name.anonymous],[IO, Lean.KeyedDeclsAttribute, Lean.Elab.Tactic.Tactic]]
[instToStringList,[ToString.mk, List.toString],[ToString, List]]
[Lean.Lsp.instToJsonSemanticTokens,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.SemanticTokens.data, List.nil],[Lean.ToJson, Lean.Lsp.SemanticTokens]]
[Option.getD,[],[]]
[Lean.Parser.Tactic.tacticLet_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[and_self,[propext, Iff.intro, And.left, And.intro],[Eq, And]]
[Lean.IR.UnreachableBranches.resetParamAssignment,[Lean.IR.UnreachableBranches.resetVarAssignment, Lean.IR.Param.x],[Lean.IR.UnreachableBranches.M, Unit]]
[Lean.Elab.Term.expandCDot?,[ite, Eq, Bool.true, Bind.bind, StateT.run, List.toArray, List.nil, Lean.MacroM, Option, Lean.Syntax, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Option.some, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.Syntax.atom, Array.append, Option.none, Lean.Elab.Term.expandCDot?.go],[Lean.MacroM, Option, Lean.Syntax]]
[Lean.Meta.GeneralizeIndicesSubgoal.mvarId,[],[Lean.MVarId]]
[Lean.Elab.Term.Quotation.MatchResult.covered.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Quotation.MatchResult.covered, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Elab.Term.Quotation.MatchResult.covered, And]]
[Lean.Elab.Command.State.noConfusionType,[],[]]
[Lean.Meta.IndPredBelow.mkBrecOnDecl,[Bind.bind, Lean.Meta.IndPredBelow.proveBrecOn, Pure.pure, Lean.Declaration.thmDecl, Lean.TheoremVal.mk, Lean.ConstantVal.mk, Lean.ConstantVal.levelParams, Lean.InductiveVal.toConstantVal, Lean.Meta.IndPredBelow.mkBrecOnDecl.mkType, Lean.Meta.IndPredBelow.mkBrecOnDecl.mkIH],[Lean.Meta.MetaM, Lean.Declaration]]
[Array.foldrMUnsafe.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bind.bind, Array.uget, HSub.hSub, OfNat.ofNat, lcProof, Array.foldrMUnsafe.fold],[]]
[Lean.PrettyPrinter.Formatter.nonReservedSymbolNoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.symbolNoAntiquot.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.ImportM.Context.env,[],[Lean.Environment]]
[Lean.MetavarDecl.numScopeArgs,[],[Nat]]
[Lean.ppGoal,[Lean.PPFns.ppGoal, Lean.EnvExtension.getState, Lean.ppExt, Lean.PPContext.env],[IO, Std.Format]]
[Lean.instToStringLOption,[ToString.mk, Unit.unit, String, HAppend.hAppend, ToString.toString],[ToString, Lean.LOption]]
[Lean.Core.getMaxHeartbeats,[HMul.hMul, Lean.Option.get, Lean.Core.maxHeartbeats, OfNat.ofNat],[Nat]]
[Lean.Parser.Term.doExpr.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.notFollowedByRedefinedTermToken.formatter, Lean.Parser.termParser.formatter, Lean.PrettyPrinter.Formatter.notFollowedBy.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.symbol.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Parser.Command.structSimpleBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Command.declModifiers.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.inferMod.parenthesizer, Lean.Parser.Command.optDeclSig.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.binderTactic.parenthesizer, Lean.Parser.Term.binderDefault.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Lsp.instToJsonRpcConnected,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.RpcConnected.sessionId, List.nil],[Lean.ToJson, Lean.Lsp.RpcConnected]]
[Lean.Parser.Tactic.first,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.reservedMacroScope,[OfNat.ofNat],[Nat]]
[Lean.indentExpr,[Lean.indentD, Lean.MessageData.ofExpr],[Lean.MessageData]]
[imp_self,[iff_true_intro, id],[Iff, True]]
[Prod.Lex.decidable.proof_1,[Iff.symm, Prod.lex_def],[Iff, Or, Prod.fst, And, Eq, Prod.snd, Prod.Lex]]
[Lean.Meta.assertExt,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarTag, Lean.Meta.getMVarType, Lean.Meta.getLevel, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.mkEqRefl, Lean.Meta.assignExprMVar, Lean.mkApp2, Pure.pure, Lean.Expr.mvarId!],[Lean.Meta.MetaM, Lean.MVarId]]
[Lean.Meta.isDefEqNoConstantApprox,[Lean.Meta.approxDefEq, Lean.Meta.isDefEq],[Lean.Meta.MetaM, Bool]]
[Lean.IR.EmitC.toCInitName,[Bind.bind, Lean.IR.EmitC.getEnv, Unit.unit, Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Lean.IR.EmitC.M, String, Lean.getExportNameFor, Pure.pure, HAppend.hAppend, Lean.IR.EmitC.throwInvalidExportName, Lean.Name.mangle],[Lean.IR.EmitC.M, String]]
[Lean.Parser.ppHardSpace,[Lean.Parser.skip],[Lean.Parser.Parser]]
[Lean.Lsp.instToJsonTypeDefinitionParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.TypeDefinitionParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position],[Lean.ToJson, Lean.Lsp.TypeDefinitionParams]]
[Lean.Parser.nodeWithAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.PrettyPrinter.Parenthesizer.node.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.IR.Sorry.State.noConfusionType,[],[]]
[AddSemigroup.toAdd,[],[Add]]
[calc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, calcStep, Lean.ParserDescr.const],[Lean.ParserDescr]]
[List.disjoint_singleton,[Eq.mpr, Eq.refl, Iff, List.disjoint, List.cons, List.nil, Not, Mem.mem, propext, List.disjoint_comm, List.singleton_disjoint, Iff.rfl],[Iff, List.disjoint, List.cons, List.nil, Not, Mem.mem]]
[Lean.MetavarKind.isNatural,[Unit.unit, Lean.MetavarKind.synthetic, Lean.MetavarKind.syntheticOpaque, Bool, Bool.true, Bool.false],[Bool]]
[Lean.Parser.Term.stx.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.syntaxParser.parenthesizer],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.Meta.GeneralizeIndicesSubgoal.numEqs,[],[Nat]]
[Lean.IR.CtorInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.IR.CtorInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.instMonadLogTermElabM,[Lean.Elab.MonadLog.mk, Lean.MonadRef.getRef, Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Term.Context.fileName, readThe, Lean.Core.Context, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.MessageLog.add, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState],[Lean.Elab.MonadLog, Lean.Elab.Term.TermElabM]]
[Lean.Elab.Term.Context.declName?,[],[Option, Lean.Name]]
[Lean.IR.emitC,[Except, String, EStateM.run, Lean.IR.EmitC.main, Lean.IR.EmitC.Context.mk, Except.ok, Except.error],[Except, String]]
[Lean.PrettyPrinter.Formatter.Context.options,[],[Lean.Options]]
[Lean.Parser.Attr.toAdditive,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const],[Lean.ParserDescr]]
[ExceptCpsT.run_throw,[rfl],[Eq, ExceptCpsT.run, MonadExcept.throw, Pure.pure, Except.error]]
[instToStringChar,[ToString.mk, Char.toString],[ToString, Char]]
[Lean.Expr.Data.approxDepth,[UInt64.toUInt8, UInt64.land, UInt64.shiftRight, OfNat.ofNat],[UInt8]]
[Lean.Meta.Match.MatcherInfo.arity,[HAdd.hAdd, Lean.Meta.Match.MatcherInfo.numParams, OfNat.ofNat, Lean.Meta.Match.MatcherInfo.numDiscrs, Lean.Meta.Match.MatcherInfo.numAlts],[Nat]]
[instOrOpUInt64,[OrOp.mk, UInt64.lor],[OrOp, UInt64]]
[Lean.Meta.Match.Unify.assign,[ite, Eq, Lean.Meta.Match.Unify.occurs, Bool.true, Bind.bind, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkFVar, Pure.pure, PUnit.unit, MonadReader.read, Lean.Meta.Match.Unify.isAltVar],[Lean.Meta.Match.Unify.M, Bool]]
[Lean.Meta.Attribute.Recursor.getMajorPos,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, OfNat.ofNat, Bind.bind, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit],[Lean.AttrM, Nat]]
[Lean.Elab.Command.StructFieldView.binders,[],[Lean.Syntax]]
[forall_congr,[],[Eq]]
[Lean.RecursorRule.nfields,[],[Nat]]
[IO.Error.mkPermissionDenied,[IO.Error.permissionDenied, Option.none],[IO.Error]]
[Lean.isProjectionFn,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Environment.isProjectionFn],[Bool]]
[Lean.Parser.Command.openScoped,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.checkColGt, Lean.Parser.ident],[Lean.Parser.Parser]]
[Lean.Xml.Parser.PEDef,[HOrElse.hOrElse, SeqRight.seqRight, Lean.Xml.Parser.EntityValue, Pure.pure, Unit.unit, Lean.Xml.Parser.ExternalID],[Lean.Parsec, Unit]]
[Char.isDigit,[and, Decidable.decide, GE.ge, Char.val, OfNat.ofNat, LE.le],[Bool]]
[Lean.Parser.sepByInfo,[Lean.Parser.ParserInfo.mk, Function.comp, Lean.Parser.ParserInfo.collectTokens, Lean.Parser.ParserInfo.collectKinds],[Lean.Parser.ParserInfo]]
[Lean.Elab.Term.NamedArg.val,[],[Lean.Elab.Term.Arg]]
[Lean.TagAttribute.mk.inj,[And.intro],[And, Eq]]
[Lean.Parser.Term.simpleBinder.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.Parser.Term.optType.formatter],[Lean.PrettyPrinter.Formatter]]
[Int.negSucc_ofNat_add_ofNat,[rfl],[Eq, HAdd.hAdd, Int.negSucc, Int.ofNat, Int.subNatNat, Nat.succ]]
[Lean.AxiomVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.AxiomVal.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Syntax.getOptionalIdent?,[Unit.unit, Option, Lean.Name, Lean.Syntax.getOptional?, Option.some, Lean.Syntax.getId, Option.none],[Option, Lean.Name]]
[Lean.Xml.Parser.GEDecl,[SeqRight.seqRight, Lean.Parsec.skipString, Lean.Xml.Parser.S, Lean.Xml.Parser.Name, Lean.Xml.Parser.EntityDef, optional, Lean.Parsec.skipChar, Char.ofNat],[Lean.Parsec, Unit]]
[Int.add,[Int, Int.ofNat, HAdd.hAdd, Int.subNatNat, Nat.succ, Int.negSucc],[Int]]
[Lean.Lsp.WorkDoneProgressBegin.title,[],[String]]
[List.toByteArray.loop,[ByteArray, PProd.fst, ByteArray.push],[ByteArray]]
[Lean.IR.findDecl',[Bind.bind, MonadState.get, Pure.pure, Lean.IR.findEnvDecl', Lean.IR.CompilerState.env],[Lean.IR.CompilerM, Option, Lean.IR.Decl]]
[Std.Format.instInhabitedFlattenBehavior,[Inhabited.mk, Std.Format.FlattenBehavior.allOrNone],[Inhabited, Std.Format.FlattenBehavior]]
[PointedType.noConfusionType,[],[]]
[Std.HashMapImp.expand,[],[Std.HashMapImp]]
[ExceptT.tryCatch,[ExceptT.mk, Bind.bind, Except, Pure.pure, Except.ok],[ExceptT]]
[Lean.Meta.instToMessageDataSimpLemma,[Lean.ToMessageData.mk, Lean.MessageData.ofFormat, Std.ToFormat.format],[Lean.ToMessageData, Lean.Meta.SimpLemma]]
[Lean.Parser.Tactic.clear,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.isRecCore,[Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Bool, Lean.Environment.find?, Bool.true, Bool.false],[Bool]]
[String.Iterator.remainingBytes,[Nat, HSub.hSub, String.bsize],[Nat]]
[UInt8.instSemiringUInt8.proof_10,[rfl],[Eq, Nat.succ]]
[Lean.instMVarIdSetInhabited,[Std.instInhabitedRBTree],[Inhabited, Lean.MVarIdSet]]
[Lean.Elab.Term.elabScientificLit,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Syntax.isScientificLit?, Lean.Elab.throwIllFormedSyntax, Bind.bind, liftM, Lean.Meta.mkFreshTypeMVar, Lean.MetavarKind.synthetic, Lean.Name.anonymous, Option.none, Functor.discard, Lean.Meta.isDefEq, Pure.pure, Lean.Meta.getDecLevel, Lean.Elab.Term.mkInstMVar, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, List.cons, List.nil, Lean.Elab.Term.registerMVarErrorImplicitArgInfo, Lean.Expr.mvarId!],[Lean.Elab.Term.TermElab]]
[Lean.Widget.InteractiveGoal.pretty,[Id.run, Bind.bind, ForIn.forIn, Unit.unit, Id, ForInStep, Std.Format, Lean.Widget.InteractiveHypothesis.val?, Pure.pure, PUnit.unit, ForInStep.yield, HAppend.hAppend, Std.ToFormat.format, Std.Format.nest, Std.Format.text, Lean.Widget.TaggedText.stripTags, Lean.Widget.InteractiveGoal.type],[Std.Format]]
[Lean.Parser.ParserCategory.noConfusionType,[],[]]
[Lean.Expr.updateSort!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateSort, Lean.Expr.sort, Lean.Expr.updateSort!.proof_1, panicWithPosWithDecl, OfNat.ofNat],[Lean.Expr]]
[Lean.Elab.Tactic.Conv.evalArg,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, BEq.beq, OfNat.ofNat, Bind.bind, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Elab.throwUnsupportedSyntax],[Lean.Elab.Tactic.Tactic]]
[UInt16.instSemiringUInt16.proof_12,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HMul.hMul, UInt16.add_def, UInt16.mul_def, UInt16.mk, HAdd.hAdd, UInt16.val, UInt16.eq_of_val_eq, Semiring.add_mul],[Eq, HMul.hMul, HAdd.hAdd]]
[Lean.Lsp.instFileSourceVersionedTextDocumentIdentifier,[Lean.Lsp.FileSource.mk, Lean.Lsp.VersionedTextDocumentIdentifier.uri],[Lean.Lsp.FileSource, Lean.Lsp.VersionedTextDocumentIdentifier]]
[Lean.getStructureInfo?,[Unit.unit, Option, Lean.StructureInfo, Lean.Environment.getModuleIdxFor?, Array.binSearch, Lean.PersistentEnvExtension.getModuleEntries, Lean.structureExt, Lean.StructureInfo.mk, Lean.StructureInfo.lt, OfNat.ofNat, HSub.hSub, Array.size, Std.PersistentHashMap.find?, Lean.SimplePersistentEnvExtension.getState],[Option, Lean.StructureInfo]]
[Lean.Parser.Term.macroArg.parenthesizer,[Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec],[Lean.PrettyPrinter.Parenthesizer]]
[Lean.PrettyPrinter.formatCommand,[Lean.PrettyPrinter.format, Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Core.CoreM, Std.Format]]
[Lean.MonadTracer.trace,[Lean.trace],[Unit]]
[StateCpsT.run_eq,[rfl],[Eq, StateCpsT.run, StateCpsT.runK, Pure.pure, Prod.mk]]
[Lean.PrettyPrinter.Formatter.fold,[Bind.bind, Lean.PrettyPrinter.Formatter.getStackSize, Lean.PrettyPrinter.Formatter.getStack, Lean.PrettyPrinter.Formatter.setStack, Array.push, Array.shrink],[Lean.PrettyPrinter.FormatterM, Unit]]
[Lean.Lsp.DocumentHighlight.kind?,[],[Option, Lean.Lsp.DocumentHighlightKind]]
[Std.PersistentArray.filter,[Std.PersistentArray.foldl, ite, Eq, Bool.true, Std.PersistentArray.push, Std.PersistentArray.mk, OfNat.ofNat],[Std.PersistentArray]]
[Lean.Parser.Command.macro_rules,[Lean.Parser.suppressInsideQuot, Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.docComment, Lean.Parser.Term.attrKind, Lean.Parser.symbol, Lean.Parser.Command.optKind, Lean.Parser.Term.matchAlts, Lean.Parser.termParser],[Lean.Parser.Parser]]
[Lean.Elab.Term.Quotation.HeadInfo.onMatch,[],[Lean.Elab.Term.Quotation.MatchResult]]
[Lean.Parser.ParserCategory.tables,[],[Lean.Parser.PrattParsingTables]]
[Std.PersistentArray.toArray,[Std.PersistentArray.foldl, Array.push, List.toArray, List.nil, OfNat.ofNat],[Array]]
[Lean.MacroScopesView.scopes,[],[List, Lean.MacroScope]]
[Lean.PrettyPrinter.Formatter.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.PrettyPrinter.Formatter.State.mk, HAdd.hAdd, OfNat.ofNat]]
[Tactic.Ring.subst_into_mul,[Eq.mpr, Eq.refl, Eq, HMul.hMul, rfl],[Eq, HMul.hMul]]
[Lean.Expr.collectMVars,[Lean.CollectMVars.visit],[Lean.CollectMVars.State]]
[Lean.Meta.SynthInstance.ConsumerNode.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.SynthInstance.ConsumerNode.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.instCoeParserParserAliasValue,[Coe.mk, Lean.Parser.AliasValue.const],[Coe, Lean.Parser.Parser, Lean.Parser.ParserAliasValue]]
[Lean.IR.LocalContextEntry.localVar.inj,[And.intro],[And, Eq]]
[Lean.Meta.AltVarNames.noConfusionType,[],[]]
[Lean.Elab.TerminationHints.mk.inj,[And.intro],[And, Eq]]
[instInhabitedNat,[Inhabited.mk, Nat.zero],[Inhabited, Nat]]
[Lean.PrettyPrinter.Formatter.getStackSize,[Bind.bind, Lean.PrettyPrinter.Formatter.getStack, Pure.pure, Array.size],[Lean.PrettyPrinter.FormatterM, Nat]]
[IO.userError,[IO.Error.userError],[IO.Error]]
[ite_false,[rfl],[Eq, ite, False]]
[Lean.Lsp.SemanticTokenType.variable.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Lsp.SemanticTokenType.variable, OfNat.ofNat]]
[Nat.toUInt64,[UInt64.ofNat],[UInt64]]
[Substring.any,[Bool, String.anyAux],[Bool]]
[Lean.Parser.Syntax.atom,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.strLit],[Lean.Parser.Parser]]
[Lean.Elab.Level.instMonadRefLevelElabM,[Lean.MonadRef.mk, Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Level.Context.ref, MonadWithReader.withReader, Lean.Elab.Level.Context.mk, Lean.Elab.Level.Context.options, Lean.Elab.Level.Context.autoBoundImplicit],[Lean.MonadRef, Lean.Elab.Level.LevelElabM]]
[Lean.Parser.sepByElemParser.formatter,[Lean.Parser.withAntiquotSpliceAndSuffix.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol.formatter, HAppend.hAppend, String.trim],[Lean.PrettyPrinter.Formatter]]
[Lean.Meta.SimpLemmas.noConfusionType,[],[]]
[Lean.Lsp.instFromJsonTrace,[Lean.FromJson.mk, Except.error, dite, Eq, Unit.unit, Eq.symm, Except.ok, Except, String, Lean.Lsp.Trace, Lean.Json.getStr?, Pure.pure, Lean.Lsp.Trace.off, Lean.Lsp.Trace.messages, Lean.Lsp.Trace.verbose, MonadExcept.throw],[Lean.FromJson, Lean.Lsp.Trace]]
[Lean.Elab.Term.PatternVar.noConfusionType,[],[]]
[Lean.ImportState.moduleNames,[],[Array, Lean.Name]]
[AddCommSemigroup.toAddSemigroup,[],[AddSemigroup]]
[Std.PersistentArray.getOp,[Std.PersistentArray.get!],[]]
[Nat.succ_sub_succ_eq_sub,[rfl, congrArg, Nat.pred],[Eq, HSub.hSub, Nat.succ]]
[Lean.Elab.Term.instInhabitedTermElabResult,[Inhabited.mk, EStateM.Result.ok, arbitrary],[Inhabited, Lean.Elab.Term.TermElabResult]]
[Lean.instToMessageDataSyntax,[Lean.ToMessageData.mk, Lean.MessageData.ofSyntax],[Lean.ToMessageData, Lean.Syntax]]
[Lean.PrettyPrinter.Formatter.nameLitNoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.visitAtom, Lean.nameLitKind],[Lean.PrettyPrinter.Formatter]]
[Lean.Elab.throwAbortTerm,[MonadExcept.throw, Lean.Exception.internal, Lean.Elab.abortTermExceptionId, Lean.KVMap.mk],[]]
[Lean.Parser.Command.macroArg.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.ident.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.Parser.syntaxParser.formatter, Lean.Parser.argPrec],[Lean.PrettyPrinter.Formatter]]
[Lean.CollectLevelParams.State.getUnusedLevelParam,[ite, Eq, Std.HashSet.contains, Lean.CollectLevelParams.State.visitedLevel, Bool.true, OfNat.ofNat, Lean.CollectLevelParams.State.getUnusedLevelParam.loop],[Lean.Level]]
[Lean.Parser.Attr.extern,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.optional, Lean.Parser.numLit, Lean.Parser.many, Lean.Parser.Attr.externEntry],[Lean.Parser.Parser]]
[id,[],[]]
[Lean.Meta.matchNot?,[Lean.Meta.matchHelper?, Option.none, Lean.Meta.MetaM, Option, Lean.Expr, Lean.Expr.not?, Pure.pure, Option.some, Lean.Expr.arrow?, Bind.bind, Lean.Meta.matchFalse, ite, Eq, Bool.true],[Lean.Meta.MetaM, Option, Lean.Expr]]
[Fin.sub.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, HAdd.hAdd, HSub.hSub]]
[Lean.PersistentEnvExtension.toEnvExtension,[],[Lean.EnvExtension, Lean.PersistentEnvExtensionState]]
[UInt8.modn,[UInt8.mk, HMod.hMod, UInt8.val],[UInt8]]
[FloatSpec.decLe,[],[DecidableRel, FloatSpec.le]]
[Char.quoteCore,[ite, Eq, Char.ofNat, Or, LE.le, Char.toNat, OfNat.ofNat, HAppend.hAppend, charToHex, String.singleton],[String]]
[Lean.Meta.PrioritySet,[Std.RBTree, Nat, Ord.compare],[]]
[List.concat_eq_append,[Eq.trans, List.concat_eq_append', List.append'_eq_append, List.cons, List.nil],[Eq, List.concat, HAppend.hAppend, List.cons, List.nil]]
[Lean.LocalContext.containsFVar,[Lean.LocalContext.contains, Lean.Expr.fvarId!],[Bool]]
[Lean.Elab.ContextInfo.currNamespace,[],[Lean.Name]]
[Lean.Meta.Simp.rewritePost,[Bind.bind, MonadReader.read, Pure.pure, Lean.Meta.Simp.Context.simpLemmas, Lean.Meta.Simp.rewrite, Lean.Meta.SimpLemmas.post, Lean.Meta.SimpLemmas.erased, Lean.Meta.Simp.Step.visit],[Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step]]
[Lean.Widget.InteractiveTermGoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Widget.InteractiveTermGoal.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.MetavarContext.dAssignment,[],[Std.PersistentHashMap, Lean.MVarId, Lean.DelayedMetavarAssignment]]
[Lean.Elab.Structural.EqnInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Elab.Structural.EqnInfo.mk, HAdd.hAdd, OfNat.ofNat]]
[Std.ShareCommon.ObjectPersistentSet.insert,[Std.PersistentHashSet.insert],[Std.ShareCommon.ObjectPersistentSet]]
[Lean.Lsp.instFromJsonRpcConnected,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, UInt64, Pure.pure, Lean.Lsp.RpcConnected.mk],[Lean.FromJson, Lean.Lsp.RpcConnected]]
[Lean.Elab.ContextInfo.mctx,[],[Lean.MetavarContext]]
[Function.has_right_inverse.surjective,[Function.surjective, Function.right_inverse.surjective],[Function.surjective]]
[Lean.Lsp.CompletionOptions.mk.inj,[And.intro],[And, Eq]]
[Lean.Widget.MsgToInteractive.noConfusionType,[],[]]
[Lean.IR.LogEntry.noConfusionType,[],[]]
[Lean.Parser.AliasValue.const.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Parser.AliasValue.const, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.doMatchAlts,[Lean.Parser.Term.matchAlts, Lean.Parser.Term.doSeq],[Lean.Parser.Parser]]
[Lean.Elab.Term.StructInst.DefaultFields.propagate,[StateRefT'.run', Lean.Elab.Term.StructInst.DefaultFields.propagateLoop, OfNat.ofNat, Lean.Elab.Term.StructInst.DefaultFields.Context.mk, Lean.Elab.Term.StructInst.DefaultFields.State.mk],[Lean.Elab.Term.TermElabM, Unit]]
[instToStringIterator,[ToString.mk, String.Iterator.remainingToString],[ToString, String.Iterator]]
[Lean.Elab.Frontend.setMessages,[modify, Lean.Elab.Frontend.State.mk, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Lean.Elab.Frontend.State.parserState, Lean.Elab.Frontend.State.cmdPos, Lean.Elab.Frontend.State.commands],[Lean.Elab.Frontend.FrontendM, Unit]]
[Lean.Parser.Term.doIfCond,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.none, Bool.false, HOrElse.hOrElse, Lean.Parser.Term.doIfLet, Lean.Parser.Term.doIfProp],[Lean.Parser.Parser]]
[Lean.Parser.Command.end.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.ident.formatter],[Lean.PrettyPrinter.Formatter]]
[Lean.Macro.getCurrNamespace,[Bind.bind, Lean.Macro.getMethods, Lean.Macro.Methods.getCurrNamespace],[Lean.MacroM, Lean.Name]]
[Lean.Elab.Command.Scope.varDecls,[],[Array, Lean.Syntax]]
[Lean.Meta.IndPredBelow.BrecOnVariables.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.IndPredBelow.BrecOnVariables.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.IndPredBelow.BrecOnVariables.mk, And]]
[Array.filter,[Array.foldl, ite, Eq, Bool.true, Array.push, List.toArray, List.nil],[Array]]
[Lean.Server.FileWorker.RpcSession.hasExpired,[Bind.bind, liftM, IO.monoMsNow, Pure.pure, Decidable.decide, LE.le, Lean.Server.FileWorker.RpcSession.expireTime],[IO, Bool]]
[Lean.Expr.mkAppRevRange,[],[Lean.Expr]]
[Decidable.not_forall,[Iff.intro, not.decidable_imp_symm, Exists.intro, not_forall_of_exists_not],[Iff, Not, Exists]]
[List.disjoint_left,[of_eq_true, iff_self, False],[Iff, List.disjoint, Not, Mem.mem]]
[Nat.sub_le,[Nat.le_refl, HSub.hSub, OfNat.ofNat, Nat.le_trans, Nat.pred_le],[LE.le, HSub.hSub]]
[Decidable.not_imp_comm,[Iff.intro, Not.decidable_imp_symm],[Iff]]
[Lean.SMap.mk.inj,[And.intro],[And, Eq]]
[StateCpsT.runK_lift,[rfl],[Eq, StateCpsT.runK, StateCpsT.lift, Bind.bind]]
[Lean.Expr.updateSort!.proof_1,[rfl],[Eq, Lean.Expr.isSort, Lean.Expr.sort]]
[Int.negSucc_ofNat_add_negSucc_ofNat,[rfl],[Eq, HAdd.hAdd, Int.negSucc, Nat.succ]]
[Lean.Parser.Command.private,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol],[Lean.Parser.Parser]]
[«term_∣_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Meta.Simp.rewrite,[Bind.bind, liftM, Lean.Meta.DiscrTree.getMatchWithExtra, ite, Eq, Array.isEmpty, Bool.true, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, ForIn.forIn, MProd.mk, Option.none, Lean.Meta.Simp.SimpM, ForInStep, MProd, Option, Lean.Meta.Simp.Result, PUnit, ForInStep.yield, Lean.Meta.Simp.tryLemmaWithExtraArgs?, ForInStep.done, Option.some, Unit.unit, MProd.fst, Lean.Meta.Simp.rewrite.inErasedSet],[Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Result]]
[Lean.MapDeclarationExtension.find?,[Unit.unit, Option, Lean.Environment.getModuleIdxFor?, Array.binSearch, Lean.PersistentEnvExtension.getModuleEntries, Prod.mk, arbitrary, Lean.Name.quickLt, Prod.fst, OfNat.ofNat, HSub.hSub, Array.size, Option.some, Prod.snd, Option.none, Lean.NameMap.find?, Lean.SimplePersistentEnvExtension.getState],[Option]]
[Lean.Parser.Term.stateRefT,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.macroArg, Lean.Parser.Term.macroLastArg],[Lean.Parser.Parser]]
[Nat.coprime.gcd_mul_left_cancel,[Nat.dvd_antisymm, Nat.dvd_gcd, Nat.coprime.dvd_of_dvd_mul_left, Nat.gcd_dvd_left, HMul.hMul, Nat.gcd_dvd_right, Nat.gcd_dvd_gcd_mul_left],[Eq, Nat.gcd, HMul.hMul]]
[IO.FS.Stream.ofHandle,[IO.FS.Stream.mk, liftM, IO.FS.Handle.isEof, IO.FS.Handle.flush, IO.FS.Handle.read, IO.FS.Handle.write, IO.FS.Handle.getLine, IO.FS.Handle.putStr],[IO.FS.Stream]]
[Lean.Meta.addImplicitTargets,[Lean.Meta.withNewMCtxDepth, Bind.bind, Lean.Meta.mkConstWithFreshMVarLevels, Lean.Meta.ElimInfo.name, Lean.Meta.inferType, OfNat.ofNat, List.toArray, List.nil, Array.mapM, Lean.Meta.instantiateMVars, ForIn.forIn, PUnit.unit, Lean.Meta.hasAssignableMVar, ite, Eq, Bool.true, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Pure.pure, ForInStep.yield, Lean.Meta.addImplicitTargets.collect],[Lean.Meta.MetaM, Array, Lean.Expr]]
[Lean.Meta.whnfD,[Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.default, Lean.Meta.whnf],[Lean.Meta.MetaM, Lean.Expr]]
[Lean.ParametricAttribute.noConfusionType,[],[]]
[ForInStep.noConfusionType,[],[]]
[Lean.Elab.Term.Quotation.mkPrecheckAttribute,[Lean.KeyedDeclsAttribute.init, Lean.KeyedDeclsAttribute.Def.mk, Lean.Name.mkStr, Lean.Name.anonymous],[IO, Lean.KeyedDeclsAttribute, Lean.Elab.Term.Quotation.Precheck]]
[Lean.SMap.stage₁,[],[Bool]]
[Substring.get,[Char, String.get, HAdd.hAdd],[Char]]
[Lean.MessageData.compose.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.MessageData.compose, HAdd.hAdd, OfNat.ofNat]]
[Lean.getPPProofsWithType,[Lean.KVMap.get, Lean.Option.name, Lean.pp.proofs.withType, Lean.Option.defValue],[Bool]]
[Lean.Parser.Tactic.trace,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.IR.FnBody.replaceVar,[Lean.IR.FnBody.mapVars, ite, Eq, BEq.beq, Bool.true],[Lean.IR.FnBody]]
[Lean.Parser.Tactic.casesType,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser],[Lean.ParserDescr]]
[Array.toList,[Array.foldr, List.cons, List.nil, Array.size, OfNat.ofNat],[List]]
