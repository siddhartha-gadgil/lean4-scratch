[Int.negOfNat_mul_ofNat,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Int.negOfNat, Int.ofNat, Int.mul_comm, of_eq_true, Eq.trans, congrFun, congrArg, Int.ofNat_mul_negOfNat, Nat.mul_comm, eq_self]]
[Lean.HeadIndex.HeadIndex.hash,[Unit.unit, UInt64, mixHash, OfNat.ofNat, Hashable.hash]]
[Lean.Parser.mkAtomicInfo,[Lean.Parser.ParserInfo.mk, Lean.Parser.FirstTokens.tokens, List.cons, List.nil]]
[Lean.Parser.InputContext.mk.inj,[And.intro]]
[Lean.Widget.getInteractiveDiagnostics,[Bind.bind, Lean.Server.RequestM.readDoc, Pure.pure, Option.map, Lean.FileMap.lspPosToUtf8Pos, Lean.Server.DocumentMeta.text, Lean.Server.FileWorker.EditableDocument.meta, Lean.Lsp.Position.mk, Lean.Lsp.LineRange.end, OfNat.ofNat, Lean.Widget.GetInteractiveDiagnosticsParams.lineRange?, liftM, IO.AsyncList.waitAll, Option.all, Decidable.decide, LT.lt, Lean.Server.Snapshots.Snapshot.beginPos, Lean.Server.FileWorker.EditableDocument.cmdSnaps, Task.map, Except, Lean.Server.RequestError, Array, Lean.Widget.InteractiveDiagnostic, Option.getD, List.toArray, List.nil, Task.Priority.default]]
[Lean.Elab.Term.Quotation.MatchResult.covered.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Name.instToStringName,[ToString.mk, Lean.Name.toString, Bool.true]]
[Nat.lt_ge_by_cases,[dite, LT.lt, Nat.lt_ge_by_cases.proof_1]]
[Nat.div_self,[Eq.mp, Eq.refl, Eq, HDiv.hDiv, Nat.succ, OfNat.ofNat, Nat.zero_div, HAdd.hAdd, Nat.zero_add]]
[«term_×__1»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.bracketedExplicitBinders, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Term.trailing_parser.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.optExprPrecedence.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Lean.Lsp.ServerCapabilities.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.ServerCapabilities.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.AbstractNestedProofs.State.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.AbstractNestedProofs.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[heq_of_eq_rec_left,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, HEq, HEq.rfl]]
[Lean.ConstantInfo.toConstantVal,[Lean.ConstantVal]]
[instToStringUInt16,[ToString.mk, ToString.toString, UInt16.toNat]]
[Lean.Elab.Term.Do.mkReassignCore,[ite, Eq, Array.any, not, Lean.NameSet.contains, OfNat.ofNat, Array.size, Bool.true, Bind.bind, Lean.Elab.Term.Do.extendUpdatedVarsAux, Lean.Elab.Term.Do.CodeBlock.code, Pure.pure]]
[Lean.Expr.updateSort,[Lean.mkSort]]
[Lean.Parser.ParserExtension.OLeanEntry.category.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserExtension.OLeanEntry.category, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.SynthInstance.checkMaxHeartbeats,[Bind.bind, MonadReader.read, liftM, Lean.Core.checkMaxHeartbeatsCore, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.SynthInstance.Context.maxHeartbeats]]
[Std.Format.join,[List.foldl, HAppend.hAppend, Std.Format.text]]
[Lean.AttributeKind.noConfusionType,[noConfusionTypeEnum, Lean.AttributeKind.toCtorIdx]]
[Lean.Parser.Tactic.casesTarget,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat]]
[Lean.Elab.Structural.EqnInfo.noConfusionType,[]]
[Lean.Lsp.ServerCapabilities.noConfusionType,[]]
[Lean.Elab.Term.Do.CodeBlock.code,[]]
[Mathlib.Tactic.Lint.simpComm,[Mathlib.Tactic.Lint.Linter.mk, Lean.Meta.withReducible, Bind.bind, Mathlib.Tactic.Lint.isSimpLemma, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Option.none, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[Lean.Elab.Structural.RecArgInfo.indIndices,[]]
[Array.instReprArray,[Repr.mk, Std.Format, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Std.Format.text, Std.Format.bracketFill, Std.Format.joinSep, Array.toList, HAppend.hAppend, Std.Format.line]]
[IsAddLeftCancel.noConfusionType,[]]
[Lean.Parser.Command.moduleDoc,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.ppDedent, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.commentBody, Lean.Parser.ppLine]]
[Lean.Elab.InfoTree.smallestInfo?,[Option.map, Prod, Lean.Elab.ContextInfo, Lean.Elab.Info, Prod.mk, Array.getMax?, List.toArray, Decidable.decide, GT.gt, Prod.fst]]
[Lean.Expr.updateConst!.proof_1,[rfl]]
[Lean.ExternAttrData.noConfusionType,[]]
[Array.findSomeRev?,[Id.run, Array.findSomeRevM?]]
[Lean.Parser.Tactic.failIfSuccess,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Lean.Lsp.Position.character,[]]
[Nat.pred_le,[Unit.unit, LE.le, Nat.pred, Nat.le.refl, Nat.le_succ, Nat.succ]]
[Decidable.not_and_distrib,[Iff.intro, dite, Or.inr, And.intro, Or.inl, not_and_of_not_or_not]]
[exists_false,[False]]
[unexpandSigma,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[instAddSemigroupFin.proof_1,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, congrFun, HAdd.hAdd, Fin.add_def, Fin.mk, HMod.hMod, Nat.mod_lt, Fin.size_positive, Nat.mod_add_mod, Nat.add_assoc, Nat.add_mod_mod, eq_self]]
[Lean.Elab.Term.ExtractMonadResult.expectedType,[]]
[Lean.Parser.ppLine,[Lean.Parser.skip]]
[Lean.IR.IRType.isUnion,[Lean.IR.IRType.float, Lean.IR.IRType.uint8, Lean.IR.IRType.uint16, Lean.IR.IRType.uint32, Lean.IR.IRType.uint64, Lean.IR.IRType.usize, Lean.IR.IRType.irrelevant, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.struct, Bool, Bool.true, Bool.false]]
[Lean.Parser.ParserExtension.Entry.category.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[ex_of_PSigma,[Exists, Exists.intro]]
[Lean.Parser.Term.show.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.fromTerm.parenthesizer, Lean.Parser.Term.byTactic.parenthesizer]]
[Lean.Meta.casesOnStuckLHS,[Bind.bind, Lean.Meta.getMVarType, Lean.Meta.matchEq?, Option.none, Lean.Meta.MetaM, Array, Lean.MVarId, Lean.Meta.cases, List.toArray, List.nil, Pure.pure, Array.map, Lean.Meta.InductionSubgoal.mvarId, Lean.Meta.CasesSubgoal.toInductionSubgoal, PUnit.unit, Lean.Meta.casesOnStuckLHS.findFVar?]]
[instMonadFunctorT,[MonadFunctorT.mk, MonadFunctor.monadMap, MonadFunctorT.monadMap]]
[Lean.Elab.Term.Do.Code.break.inj,[]]
[Lean.expandExternPatternAux,[String, ite, Not, Eq, String.Iterator.hasNext, Bool.true, Ne, Char.ofNat, PProd.fst, String.Iterator.next, String.push, HAppend.hAppend, List.getD]]
[Nat.le_of_add_le_add_left,[Nat.le.intro, Eq.mp, Eq.refl, Eq, HAdd.hAdd, propext, Nat.add_left_cancel_iff, Nat.add_assoc]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[String.toNat?,[ite, Eq, String.isNat, Bool.true, Option.some, String.foldl, HAdd.hAdd, HMul.hMul, OfNat.ofNat, HSub.hSub, Char.toNat, Char.ofNat, Option.none]]
[Lean.Server.FileWorker.handleReferences.identOf,[Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofCompletionInfo, Option, Prod, Lean.Server.FileWorker.RefIdent, Bool, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Elab.TermInfo.expr, Option.some, Prod.mk, Lean.Server.FileWorker.RefIdent.const, Lean.Elab.TermInfo.isBinder, Lean.Server.FileWorker.RefIdent.fvar, Option.none, Lean.Elab.FieldInfo.projName, Bool.false]]
[Lean.IR.Expr.isShared.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[IO.FS.Stream.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FS.Stream.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Classical.epsilon_singleton,[Classical.epsilon_spec, Exists.intro, rfl]]
[Lean.Parser.Tactic.reassoc!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const]]
[Lean.Parser.Command.optKind.formatter,[Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.ident.formatter]]
[Lean.Parser.Term.binderIdent.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.Term.hole.parenthesizer]]
[Char.utf8Size_pos,[Classical.em, LE.le, Char.val, UInt32.ofNatCore, OfNat.ofNat, Char.utf8Size.proof_1, Eq.mpr, congrArg, LT.lt, if_pos, of_decide_eq_true, Eq.refl, Bool.true, if_neg, Char.utf8Size.proof_3, Char.utf8Size.proof_5]]
[Lean.Elab.InfoState.mk.inj,[And.intro]]
[Lean.maxSmallNat,[Lean.maxSmallNatFn, Unit.unit]]
[Lean.Elab.Term.ToParserDescrContext.catName,[]]
[UInt64.mk_val_eq,[Eq, UInt64.mk, UInt64.val, rfl]]
[Lean.Meta.SynthInstance.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SynthInstance.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Widget.Lean.Widget.InteractiveGoal.instToJsonRpcEncodingPacket,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil, Lean.Json.opt]]
[Std.HashMap.size,[Nat]]
[Lean.MonadQuotation.getMainModule,[]]
[Std.PersistentHashMap.noConfusionType,[]]
[Lean.evalConstCheck,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, Lean.ofExcept, Lean.Environment.evalConstCheck]]
[Int.natAbs_ofNat,[rfl]]
[Lean.Syntax.TopDown.mk.inj,[And.intro]]
[FloatArray.uset,[FloatArray, FloatArray.mk, Array.uset]]
[Tactic.instInhabitedDeclCache,[inferInstanceAs, Inhabited, Prod, Tactic.Cache, Lean.Meta.MetaM]]
[System.Platform.numBits,[Subtype.val, System.Platform.getNumBits, Unit.unit]]
[Lean.Parser.Term.doSeqBracketed.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.withoutPosition.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.doSeqItem.formatter, Lean.ppLine.formatter]]
[Lean.Parser.Tactic.Conv.paren,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.Conv.convSeq, Lean.ParserDescr.symbol]]
[Lean.Lsp.instFileSourceRpcReleaseParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.RpcReleaseParams.uri]]
[Functor.mapConst,[]]
[Mathlib.Prelude.Rename.lookup3,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Lean.Parser.Term.prec.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.precedenceParser.formatter]]
[Lean.Meta.Match.Extension.Entry.name,[]]
[Array.toArrayLit_eq'.aux,[Eq, Array.toListLitAux, List.drop, Array.data, rfl]]
[Lean.Elab.Command.ElabHeaderResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.symbolFnAux,[Lean.Parser.satisfySymbolFn, BEq.beq, List.cons, List.nil]]
[Lean.Elab.Command.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.div,[WellFounded.fix, Nat.div.proof_1, dite, And, LT.lt, OfNat.ofNat, LE.le, HAdd.hAdd, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le, Nat.zero]]
[Char.utf8Size.proof_4,[of_decide_eq_true, Eq.refl, Bool.true]]
[List.card,[Unit.unit, Nat, OfNat.ofNat, ite, Mem.mem, PProd.fst, HAdd.hAdd]]
[Lean.Elab.Term.Do.eraseOptVar,[Unit.unit, Lean.NameSet, Lean.NameSet.insert]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.noConfusionType,[]]
[Nat.coprime.coprime_dvd_left,[Nat.eq_one_of_dvd_one]]
[Lean.setEnv,[Lean.MonadEnv.modifyEnv]]
[Lean.MessageData.withNamingContext.inj,[And.intro]]
[String.toAsciiByteArray,[String.toAsciiByteArray.loop, ByteArray.empty, OfNat.ofNat]]
[Lean.Lsp.ReferenceParams.context,[]]
[Functor.map_equiv_apply,[rfl]]
[Subarray.mk.inj,[And.intro]]
[Lean.Elab.Command.Context.macroStack,[]]
[Lean.Elab.Command.StructFieldView.declName,[]]
[lt_trans,[LT.lt, le_not_le_of_lt, lt_of_le_not_le, le_trans]]
[Lean.Parser.Tactic.case',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.caseArg, Lean.ParserDescr.parser]]
[Lean.Message.data,[]]
[Lean.PrettyPrinter.Delaborator.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.LetRecToLift.attrs,[]]
[Lean.IR.NormalizeIds.normExpr,[Lean.IR.Expr.lit, Id, Lean.IR.Expr, Lean.IR.Expr.ctor, Lean.IR.NormalizeIds.normArgs, Lean.IR.Expr.reset, Lean.IR.NormalizeIds.normVar, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.fap, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr]]
[Lean.Elab.Term.FunBinders.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Widget.InfoWithCtx.mk.inj,[And.intro]]
[Lean.IR.instInhabitedJoinPointId,[Inhabited.mk, Lean.IR.JoinPointId.mk, arbitrary]]
[Lean.Meta.Context.localInstances,[]]
[le_min,[dite, LE.le, Eq.mpr, congrArg, if_pos, if_neg]]
[Nat.dvd_of_mul_dvd_mul_left,[Exists.elim, Exists.intro, Nat.eq_of_mul_eq_mul_left, Eq.mp, Eq.refl, Eq, HMul.hMul, Nat.mul_assoc]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.rhs,[]]
[List.init,[Unit.unit, List.cons, List, List.nil, PProd.fst]]
[Lean.Meta.Context.noConfusionType,[]]
[Lean.Name.mkSimple,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Parser.Command.attribute.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.eraseAttr.formatter, Lean.Parser.Term.attrInstance.formatter, Bool.false, Lean.Parser.many1.formatter, Lean.Parser.ident.formatter]]
[Lean.Parser.testParseFile,[Bind.bind, IO.FS.readFile, Lean.Parser.testParseModule, System.FilePath.toString]]
[Lean.IR.ExplicitBoxing.getLocalContext,[Functor.map, Lean.IR.ExplicitBoxing.BoxingContext.localCtx, MonadReader.read]]
[Lean.MonadWithOptions.noConfusionType,[]]
[Lean.Elab.Term.Do.ToTerm.mkJmp,[Lean.Syntax.mkApp, Lean.mkIdentFrom]]
[Lean.PrefixTreeNode.empty,[Lean.PrefixTreeNode.Node, Option.none, Std.RBNode.leaf]]
[Nat.gcd_comm,[Nat.dvd_antisymm, Nat.dvd_gcd, Nat.gcd_dvd_right, Nat.gcd_dvd_left]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM,[ReaderT, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context, StateT, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM]]
[UInt32.land,[UInt32.mk, Fin.land, UInt32.val]]
[Function.has_uncurry.noConfusionType,[]]
[Lean.Lsp.CompletionOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.VarId.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Fin.checkedMul,[Option, Fin, Fin.overflowingMul, Option.none, Option.some]]
[imp_imp_imp,[Function.comp]]
[Lean.Meta.sortFVarIds,[Bind.bind, Lean.MonadLCtx.getLCtx, Pure.pure, Array.qsort, Unit.unit, Bool, Lean.LocalContext.find?, Decidable.decide, LT.lt, Lean.LocalDecl.index, Bool.false, Bool.true, Lean.Name.quickLt, Lean.FVarId.name, OfNat.ofNat, HSub.hSub, Array.size]]
[Lean.Server.Watchdog.handleNotification,[dite, Eq, Unit.unit, Eq.symm, Lean.Server.Watchdog.ServerM, Unit, Lean.Lsp.DidOpenTextDocumentParams, Lean.Lsp.instFromJsonDidOpenTextDocumentParams, Lean.Server.Watchdog.handleDidOpen, Lean.Lsp.DidCloseTextDocumentParams, Lean.Lsp.instFromJsonDidCloseTextDocumentParams, Lean.Server.Watchdog.handleDidClose, Lean.Lsp.CancelParams, Lean.Lsp.instFromJsonCancelParams, Lean.Server.Watchdog.handleCancelRequest, Lean.Lsp.RpcConnectParams, Lean.Lsp.instFromJsonRpcConnectParams, Lean.Server.Watchdog.forwardNotification, Lean.Lsp.RpcReleaseParams, Lean.Lsp.instFromJsonRpcReleaseParams, Lean.Lsp.RpcKeepAliveParams, Lean.Lsp.instFromJsonRpcKeepAliveParams, ite, not, String.isPrefixOf, Bool.true, Bind.bind, MonadReader.read, liftM, IO.FS.Stream.putStrLn, Lean.Server.Watchdog.ServerContext.hLog, HAppend.hAppend, ToString.toString, Pure.pure, PUnit.unit]]
[Lean.Declaration.isUnsafeInductiveDeclEx,[Lean.Declaration.axiomDecl, Lean.Declaration.defnDecl, Lean.Declaration.thmDecl, Lean.Declaration.opaqueDecl, Lean.Declaration.quotDecl, Lean.Declaration.mutualDefnDecl, Bool, Bool.false]]
[Lean.ParserCompiler.instInhabitedCombinatorAttribute,[Inhabited.mk, Lean.ParserCompiler.CombinatorAttribute.mk, arbitrary]]
[Lean.Meta.assumption,[Bind.bind, Lean.Meta.assumptionCore, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing]]
[Lean.ParametricAttribute.setParam,[ite, Eq, Option.isSome, Lean.Environment.getModuleIdxFor?, Bool.true, Except.error, HAppend.hAppend, ToString.toString, Lean.AttributeImplCore.name, Lean.AttributeImpl.toAttributeImplCore, Lean.ParametricAttribute.attr, Lean.NameMap.find?, Lean.PersistentEnvExtension.getState, Lean.ParametricAttribute.ext, Except.ok, Lean.PersistentEnvExtension.addEntry, Prod.mk]]
[Lean.Meta.DiscrTree.Key.lt,[Lean.Meta.DiscrTree.Key.const, Lean.Meta.DiscrTree.Key.fvar, Lean.Meta.DiscrTree.Key.lit, Lean.Meta.DiscrTree.Key.star, Lean.Meta.DiscrTree.Key.other, Lean.Meta.DiscrTree.Key.arrow, Lean.Meta.DiscrTree.Key.proj, Bool, Decidable.decide, LT.lt, or, Lean.Name.quickLt, Lean.FVarId.name, and, BEq.beq, Lean.Meta.DiscrTree.Key.ctorIdx]]
[Lean.Meta.IndPredBelow.BrecOnVariables.indHyps,[]]
[«term_=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Command.openRenamingItem.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.Parser.unicodeSymbol.formatter, Lean.PrettyPrinter.Formatter.checkColGt.formatter]]
[Nat.sub_lt_left_of_lt_add,[]]
[Lean.Server.Watchdog.ServerContext.workerPath,[]]
[Lean.Option.set,[Lean.KVMap.set, Lean.Option.name]]
[Lean.Meta.Config.mk.inj,[And.intro]]
[Lean.Meta.instInhabitedPostponedEntry,[Inhabited.mk, Lean.Meta.PostponedEntry.mk, arbitrary]]
[Function.involutive,[Eq]]
[congr,[rfl]]
[Stream.noConfusionType,[]]
[Lean.Meta.NormNum.LawfulOne.isNat_one,[]]
[Lean.Elab.Command.Scope.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.Scope.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.LocalContext.getAt?,[Std.PersistentArray.get!, Lean.LocalContext.decls]]
[Lean.KeyedDeclsAttribute.Def.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Syntax.decodeNatLitVal?,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Option.none, Char.ofNat, Option.some, or, Char.isDigit]]
[Prod.lt_def,[rfl]]
[Ring.toNeg,[]]
[Lean.Meta.matchMatcherApp?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Meta.MatcherApp, Lean.Expr.getAppFn, Bind.bind, Lean.Meta.getMatcherInfo?, Unit.unit, Pure.pure, Option.none, ite, LT.lt, Array.size, Lean.Meta.Match.MatcherInfo.arity, Option.some, Lean.Meta.MatcherApp.mk, List.toArray, Lean.Meta.Match.MatcherInfo.uElimPos?, Array.extract, OfNat.ofNat, Lean.Meta.Match.MatcherInfo.numParams, Array.getOp, Lean.Meta.Match.MatcherInfo.getMotivePos, Array.ofSubarray, Array.toSubarray, HAdd.hAdd, Lean.Meta.Match.MatcherInfo.numDiscrs, Lean.Meta.Match.MatcherInfo.altNumParams, Lean.Meta.Match.MatcherInfo.numAlts]]
[Lean.LocalContext.allM,[Std.PersistentArray.allM, Lean.LocalContext.decls, Unit.unit, Bool, Pure.pure, Bool.true]]
[BEq.beq,[]]
[Lean.withImporting,[tryFinally, Bind.bind, ST.Ref.set, Bool.true, Bool.false]]
[Lean.Elab.Term.StructInst.DefaultFields.State.mk.inj,[]]
[Lean.Elab.Term.StructInst.DefaultFields.Context.maxDistance,[]]
[instHAdd,[HAdd.mk, Add.add]]
[instInhabitedUInt64.proof_1,[of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Meta.SortLocalDecls.State.result,[]]
[Lean.Xml.Parser.Name,[Bind.bind, Lean.Xml.Parser.NameStartChar, Lean.Parsec.manyCharsCore, Lean.Xml.Parser.NameChar, Char.toString]]
[Lean.Parser.Term.doExpr.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.notFollowedByRedefinedTermToken.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.PrettyPrinter.Parenthesizer.notFollowedBy.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.symbol.parenthesizer]]
[Lean.Server.FileWorker.RefIdent.noConfusionType,[]]
[Fin.mk.inj,[]]
[Lean.Parser.Term.prio.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.priorityParser]]
[Std.PersistentArray.anyM,[orM, Std.PersistentArray.anyMAux, Std.PersistentArray.root, Array.anyM, Std.PersistentArray.tail, OfNat.ofNat, Array.size]]
[StdGen.noConfusionType,[]]
[Lean.Elab.deltaLHS,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getMVarType', Pure.pure, Lean.Expr.eq?, Option.none, Lean.Meta.MetaM, Lean.MVarId, liftM, Lean.Meta.delta?, Bool.true, Lean.Meta.mkEq, Lean.Meta.replaceTargetDefEq, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing]]
[Nat.succ_pos,[Nat.zero_lt_succ]]
[Lean.Meta.matchNe?,[Lean.Meta.matchHelper?, Option.none, Lean.Meta.MetaM, Option, Prod, Lean.Expr, Lean.Expr.ne?, Pure.pure, Option.some, Bind.bind, Lean.Meta.matchNot?, Lean.Meta.matchEq?]]
[UInt8.div,[UInt8.mk, HDiv.hDiv, UInt8.val]]
[WellFoundedRelation.wf,[]]
[Lean.instEmptyCollectionNameTrie,[EmptyCollection.mk, Lean.NameTrie.empty]]
[Semiring.one_mul,[]]
[Lean.Meta.applyRefl,[Lean.Meta.withMVarContext, Bind.bind, Lean.observing?, Lean.Meta.mkFreshLevelMVar, Lean.Meta.apply, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil, Option.none, Unit.unit, Option.some, Lean.Meta.MetaM, Unit, Pure.pure, PUnit.unit, Lean.Meta.throwTacticEx, Lean.Syntax.missing]]
[Std.PersistentHashSet.foldM,[Std.PersistentHashMap.foldlM, Std.PersistentHashSet.set]]
[Lean.HeadIndex.mvar.injEq,[Eq.propIntro, Eq.refl, Lean.HeadIndex.mvar, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Compiler.SpecInfo.noConfusionType,[]]
[Lean.Lsp.SymbolKind.variable.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Term.registerMVarErrorCustomInfo,[Lean.Elab.Term.registerMVarErrorInfo, Lean.Elab.Term.MVarErrorInfo.mk, Lean.Elab.Term.MVarErrorKind.custom]]
[Lean.Parser.Term.structInst,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ppHardSpace, Lean.Parser.optional, Lean.Parser.atomic, Lean.Parser.sepBy1, Lean.Parser.termParser, Bool.false, Lean.Parser.manyIndent, Lean.Parser.group, HOrElse.hOrElse, Lean.Parser.Term.structInstFieldAbbrev, Lean.Parser.Term.structInstField, Lean.Parser.Term.optEllipsis]]
[Lean.Meta.getLocalDecl,[Bind.bind, Lean.MonadLCtx.getLCtx, Unit.unit, Lean.Meta.MetaM, Lean.LocalDecl, Lean.LocalContext.find?, Pure.pure, Lean.Meta.throwUnknownFVar]]
[Lean.Lsp.instFromJsonReferenceContext,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Bool, Pure.pure, Lean.Lsp.ReferenceContext.mk]]
[Array.filterMap,[Id.run, Array.filterMapM]]
[System.FilePath.pathExists,[Bind.bind, EIO.toBaseIO, System.FilePath.metadata, Pure.pure, Except.toBool]]
[Lean.Parser.Term.forall.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.unicodeSymbol.formatter, Lean.Parser.many1.formatter, Lean.ppSpace.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.simpleBinder.formatter, Lean.Parser.Term.bracketedBinder.formatter, Bool.false, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Char.toUInt8,[UInt32.toUInt8, Char.val]]
[mul_left_inj,[Iff.intro, mul_right_cancel, rfl]]
[Lean.Name.toStringWithSep,[Unit.unit, Lean.Name.str, Lean.Name.num, String, Lean.Name.toStringWithSep.maybeEscape, ToString.toString, HAppend.hAppend, PProd.fst, Nat.repr]]
[Fin.val_eq_of_lt,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Nat.mod_eq_of_lt, eq_self]]
[Lean.Parser.ParserModuleContext.mk.inj,[And.intro]]
[Lean.PrettyPrinter.Formatter.withAntiquot.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter]]
[Lean.registerOption,[Bind.bind, Lean.initializing, ite, Eq, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, IO.userError]]
[Lean.Level.mvar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.inductionAlt,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[And.comm,[Iff.intro, And.symm]]
[Lean.Elab.Command.elabMutual,[ite, Eq, Array.all, Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Array.size, Bool.true, Option.none, Lean.Elab.Command.CommandElabM, Unit, Lean.Elab.TerminationHints.terminationBy?, Bind.bind, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Elab.Command.isDefLike, ForIn.forIn, ForInStep, PUnit, Lean.Elab.Command.elabMutualDef, Lean.throwError]]
[Lean.Elab.Term.Do.pullExitPoints,[ite, Eq, Lean.Elab.Term.Do.hasExitPoint, Bool.true, Bind.bind, StateRefT'.run, Lean.Elab.Term.Do.pullExitPointsAux, EmptyCollection.emptyCollection, List.toArray, List.nil, Lean.Elab.Term.TermElabM, Lean.Elab.Term.Do.Code, Pure.pure, Lean.Elab.Term.Do.attachJPs]]
[Lean.Lsp.WaitForDiagnostics.toCtorIdx,[OfNat.ofNat]]
[Std.HashMap.find!,[Unit.unit, Std.HashMap.find?, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.NameSSet.empty,[Lean.SSet.empty]]
[Lean.Parser.Term.isIdent,[or, Lean.Syntax.isAntiquot, Lean.Syntax.isIdent]]
[Lean.Meta.Match.InjectionAnyResult.solved.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Term.trueVal.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false]]
[Lean.Lsp.MarkupKind.markdown.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[instSemiringFin.proof_9,[Eq.mpr, Eq.refl, Eq, HMul.hMul, OfNat.ofNat, instSemiringFin.proof_4, instSemiringFin.proof_2]]
[Lean.Server.FileWorker.handleWaitForDiagnostics,[Bind.bind, Lean.Server.RequestM.asTask, Lean.Server.RequestM.bindTask, liftExcept, liftM, IO.AsyncList.waitAll, Bool.true, Lean.Server.FileWorker.EditableDocument.cmdSnaps, Pure.pure, Task.map, Lean.Lsp.WaitForDiagnostics.mk, Task.Priority.default, Lean.Server.FileWorker.handleWaitForDiagnostics.waitLoop]]
[Lean.Elab.TacticInfo.goalsAfter,[]]
[Lean.Elab.Tactic.Conv.getRhs,[Bind.bind, Lean.Elab.Tactic.Conv.getLhsRhs, Pure.pure, Prod.snd]]
[Lean.Compiler.NumScalarTypeInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Compiler.NumScalarTypeInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Match.Extension.State.map,[]]
[Lean.IR.EmitC.Context.mk.inj,[And.intro]]
[Lean.KVMap.Value.ofDataValue?,[]]
[EStateM.instMonadEStateM,[Monad.mk]]
[String.extract,[String, ite, GE.ge, String.mk, List.nil, List.cons, List, Char, Eq, PProd.fst, HAdd.hAdd, String.csize, OfNat.ofNat]]
[Lean.Meta.mkEqRec,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.eq?, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr, Lean.Meta.getLevel, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.mkAppN, Lean.mkConst, List.cons, List.nil, List.toArray]]
[Lean.Lsp.InitializedParams.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Term.scoped.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.writeModule,[Bind.bind, Lean.mkModuleData, Lean.saveModuleData, Lean.Environment.mainModule]]
[Lean.NameSSet.instInhabitedNameSSet,[Inhabited.mk, Lean.NameSSet.empty]]
[Lean.Lsp.LeanFileProgressProcessingInfo.noConfusionType,[]]
[Int.ofNat_add_negSucc_ofNat,[rfl]]
[instHashableNat,[Hashable.mk, UInt64.ofNat]]
[Lean.Meta.DiscrTree.Key.lit.inj,[]]
[Lean.IR.IRType.isScalar,[Unit.unit, Lean.IR.IRType.irrelevant, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.struct, Lean.IR.IRType.union, Bool, Bool.true, Bool.false]]
[Lean.Lsp.RpcReleaseParams.noConfusionType,[]]
[Set.«term{_|_}»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Mathlib.ExtendedBinder.extBinder, Lean.ParserDescr.cat]]
[Lean.Expr.isHeadBetaTargetFn,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Bool, Bool.true, PProd.fst, Bool.false]]
[Tactic.Ring.HornerExpr.const.inj,[And.intro]]
[List.decidableBall,[Unit.unit, Decidable, Decidable.isTrue, List.decidableBall.proof_1, Decidable.isFalse, List.decidableBall.proof_2, PProd.fst, List.decidableBall.proof_3, List.decidableBall.proof_4]]
[Except.orElseLazy,[Except, Except.ok, Unit.unit]]
[Lean.IR.ExplicitRC.instInhabitedVarInfo,[Inhabited.mk, Lean.IR.ExplicitRC.VarInfo.mk, arbitrary]]
[Lean.instEvalUnit,[Lean.Eval.mk, ite, Eq, Bool.true, Pure.pure, Unit.unit, IO.println, repr]]
[Lean.updateEnvAttributesImpl,[Bind.bind, ST.Ref.get, Lean.attributeMapRef, Pure.pure, Lean.PersistentEnvExtension.getState, Lean.attributeExtension, Lean.PersistentEnvExtension.setState]]
[Lean.Server.Completion.State.itemsMain,[]]
[Lean.Elab.Structural.M,[StateRefT', IO.RealWorld, Lean.Elab.Structural.State, Lean.Meta.MetaM]]
[instReprString,[Repr.mk, Std.Format.text, String.quote]]
[Lean.Elab.Term.Do.CodeBlock.uvars,[]]
[Lean.Elab.Term.declareTacticSyntax,[Lean.MonadQuotation.withFreshMacroScope, Bind.bind, Lean.MonadQuotation.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.Term.quoteAutoTactic, Lean.Elab.Term.elabTerm, Option.some, Bool.true, liftM, Lean.Meta.instantiateMVars, Lean.isTracingEnabledFor, ite, Eq, Lean.addTrace, Lean.MessageData.ofExpr, Pure.pure, PUnit.unit]]
[Lean.Meta.Simp.Context.mkDefault,[Bind.bind, liftM, Lean.Meta.getSimpLemmas, Lean.Meta.getCongrLemmas, Pure.pure, Lean.Meta.Simp.Context.mk, Lean.Meta.Simp.Config.mk]]
[Lean.Server.FileWorker.GoToKind.noConfusionType,[noConfusionTypeEnum, Lean.Server.FileWorker.GoToKind.toCtorIdx]]
[Fin.checked_add_spec,[Decidable.em, LE.le, HAdd.hAdd, Fin.val, of_eq_true, Eq.trans, congrFun, congrArg, Iff, Eq, Unit.unit, Bool, Option, Fin, Prod.mk, decide_eq_true, eq_true, Option.none, Option.some, Bool.true, Bool.false, eq_false', LT.lt, false_iff, propext, not_lt, Eq.symm, congr, decide_eq_false, Not, eq_false, eq_true_of_decide, Eq.refl, Eq.mp, not_le]]
[Lean.instInhabitedTagAttribute,[Inhabited.mk, Lean.TagAttribute.mk, arbitrary]]
[Lean.Expr.fvar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.instToJsonVersionedTextDocumentIdentifier,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.VersionedTextDocumentIdentifier.uri, List.nil, Lean.Json.opt, Lean.Lsp.VersionedTextDocumentIdentifier.version?]]
[Lean.Meta.getDelayedAssignment?,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.getDelayedAssignment?]]
[Lean.Parser.Command.macroTailTactic.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.identEq.formatter, Lean.Name.mkSimple, Lean.Parser.darrow.formatter, Lean.Parser.Command.macroRhs.formatter, Lean.Parser.Tactic.seq1.formatter]]
[Decidable.not_and_not_right,[Iff.intro, Not.decidable_imp_symm, And.intro, False]]
[Lean.Server.RequestError.methodNotFound,[Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.methodNotFound, HAppend.hAppend, ToString.toString]]
[Lean.Elab.Term.StructInst.DefaultFields.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.StructInst.instInhabitedStruct,[Inhabited.mk, Lean.Elab.Term.StructInst.Struct.mk, arbitrary]]
[Mathlib.Tactic.Ext.withExtHyps,[Bind.bind, Lean.MonadEnv.getEnv, ite, Eq, Lean.isStructure, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.Parser.lookahead,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.lookaheadFn, Lean.Parser.Parser.fn]]
[Lean.Constructor.noConfusionType,[]]
[Lean.PersistentEnvExtension.addEntry,[Lean.EnvExtension.modifyState, Lean.PersistentEnvExtension.toEnvExtension, Lean.PersistentEnvExtensionState.mk, Lean.PersistentEnvExtensionState.importedEntries]]
[Lean.IR.EmitC.emitAllocCtor,[Bind.bind, Lean.IR.EmitC.emit, Lean.IR.CtorInfo.cidx, Lean.IR.CtorInfo.size, Lean.IR.EmitC.emitCtorScalarSize, Lean.IR.CtorInfo.usize, Lean.IR.CtorInfo.ssize, Lean.IR.EmitC.emitLn]]
[Lean.Server.Watchdog.WorkerState.crashed.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[IO.Error.invalidArgument.inj,[And.intro]]
[Lean.Meta.mkHCongrWithArity,[Bind.bind, Lean.Meta.inferType, Lean.Meta.forallBoundedTelescope, Option.some, ite, Eq, bne, Array.size, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.MonadLCtx.getLCtx, Lean.Meta.getLocalInstances, Lean.Meta.withLCtx, Lean.Meta.CongrTheorem, ForIn.forIn, MProd.mk, Unit.unit, Lean.Meta.MetaM, ForInStep, MProd, Subarray, Lean.Expr, Array, Stream.next?, Pure.pure, ForInStep.done, PUnit.unit, ForInStep.yield, BEq.beq, Lean.Meta.mkEq, Lean.Meta.mkHEq, Lean.Meta.mkHCongrWithArity.withNewEqs, Lean.Meta.mkHCongrWithArity.mkProof]]
[Lean.Xml.Parser.EntityRef,[Lean.Parsec.attempt, SeqLeft.seqLeft, SeqRight.seqRight, Lean.Parsec.skipChar, Char.ofNat, Functor.map, Lean.Xml.Parser.predefinedEntityToChar, Lean.Xml.Parser.Name]]
[USize.val,[]]
[Lean.Elab.Term.MkInstResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.MkInstResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.IndPredBelow.proveBrecOn.applyCtors,[Bind.bind, Array.mapIdxM, List.toArray, Lean.Meta.IndPredBelow.proveBrecOn.introNPRec, Lean.Meta.getMVarType, Lean.Expr.withApp, Lean.Meta.withMVarContext, Array.back, Lean.getConstInfoCtor, Lean.Meta.forallMetaTelescope, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, Lean.MetavarKind.natural, Lean.Meta.MetaM, List, Lean.MVarId, Lean.Meta.apply, Pure.pure, Array.foldr, List.append, List.nil, Array.size, OfNat.ofNat]]
[Nat.zero_mod,[Eq.mpr, Eq.refl, Eq, HMod.hMod, OfNat.ofNat, Nat.mod_eq]]
[DivInvMonoid.gpow,[]]
[Lean.Server.Watchdog.WorkerEvent.ioError.inj,[]]
[Lean.Parser.Command.optKind.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.ident.parenthesizer]]
[Lean.Expr.isHeadBetaTarget,[Lean.Expr.isHeadBetaTargetFn, Lean.Expr.getAppFn]]
[Lean.ToMessageData.noConfusionType,[]]
[USize.decEq,[Decidable, Eq, dite, Decidable.isTrue, USize.decEq.proof_1, Decidable.isFalse, USize.decEq.proof_2]]
[Lean.Parser.Term.matchAlts.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.ppDedent.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.many1Indent.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.ppLine.formatter, Lean.Parser.Term.matchAlt.formatter]]
[Quot.hrecOn.proof_1,[eq_of_heq]]
[Lean.Parsec.many1,[Bind.bind, Lean.Parsec.manyCore, List.toArray, List.cons, List.nil]]
[Lean.Meta.getConfig,[Bind.bind, MonadReader.read, Pure.pure, Lean.Meta.Context.config]]
[Lean.Server.RpcEncoding.DerivingParams.mk.inj,[]]
[Lean.instMonadEnv,[Lean.MonadEnv.mk, liftM, Lean.MonadEnv.getEnv, Lean.MonadEnv.modifyEnv]]
[inferInstanceAs,[]]
[Lean.Parser.Syntax.numPrec,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.numLit]]
[Lean.Parser.Command.declValSimple.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.whereDecls.formatter]]
[Lean.Elab.Tactic.appendGoals,[modify, Lean.Elab.Tactic.State.mk, HAppend.hAppend, Lean.Elab.Tactic.State.goals]]
[Lean.IR.getSorryDep,[Option.none, Option.some, Lean.IR.Decl.extern, Option, Lean.Name, Lean.SMap.find?, Lean.SimplePersistentEnvExtension.getState, Lean.IR.declMapExt]]
[and_congr_right',[and_congr, Iff.rfl]]
[Lean.Server.Watchdog.FileWorker.stdout,[IO.FS.Stream.ofHandle, IO.Process.Child.stdout, Lean.Server.Watchdog.FileWorker.proc]]
[Lean.Server.Watchdog.FileWorker.state,[]]
[Lean.Meta.isAuxDef,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, or, Lean.isAuxRecursor, Lean.isNoConfusion]]
[Lean.mkGroupNode,[Lean.mkNode, Lean.groupKind]]
[Substring.isNat,[Substring.all, Char.isDigit]]
[Lean.TraceState.mk.inj,[And.intro]]
[Prod.foldI,[Nat.foldAux, Prod.snd, HSub.hSub, Prod.fst]]
[Int.negSucc_ofNat_mul_negOfNat,[Unit.unit, Eq, HMul.hMul, Int.negSucc, Int.negOfNat, Int.ofNat, Nat.succ, rfl]]
[Char.lt,[LT.lt, Char.val]]
[Lean.IR.UnreachableBranches.InterpContext.currFnIdx,[]]
[Lean.LocalContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.ParametricAttribute.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.simpleBinder,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.many1, Lean.Parser.Term.binderIdent, Lean.Parser.Term.optType]]
[Lean.Elab.Term.addAutoBoundImplicits,[Bind.bind, MonadReader.read, ForIn.forIn, PUnit.unit, liftM, Lean.Meta.getLocalDecl, Lean.Expr.fvarId!, Lean.MonadMCtx.getMCtx, ite, Eq, Lean.MetavarContext.localDeclDependsOn, Bool.true, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, ForInStep.yield, Std.PersistentArray.toArray]]
[Std.RBNode.del,[Unit.unit, Std.RBNode, Std.RBNode.leaf, ite, Eq, Std.RBNode.isBlack, Bool.true, Std.RBNode.balLeft, PProd.fst, Std.RBNode.node, Std.Rbcolor.red, Std.RBNode.balRight, PProd.snd, Std.RBNode.appendTrees]]
[Lean.Elab.Term.TermElabM.run,[Lean.Meta.withConfig, Lean.Elab.Term.setElabConfig, StateRefT'.run]]
[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.noConfusionType,[]]
[Array.concatMap,[Array.foldl, HAppend.hAppend, Array.empty, OfNat.ofNat, Array.size]]
[Lean.Elab.Term.TermElab,[Lean.Elab.Term.TermElabM, Lean.Expr]]
[Lean.IR.LocalContext.eraseJoinPointDecl,[Std.RBMap.erase, Lean.IR.JoinPointId.idx]]
[Std.HashSetImp.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.HashSetImp.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.decimalNumberFn,[ite, Eq, or, BEq.beq, Char.ofNat, Bool.true, Lean.Parser.mkNodeToken, Lean.scientificLitKind, Lean.numLitKind, Lean.Parser.decimalNumberFn.parseOptDot, Lean.Parser.decimalNumberFn.parseOptExp]]
[Lean.PrettyPrinter.Parenthesizer.optionalNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitArgs]]
[Lean.PrettyPrinter.Formatter.lookahead.formatter,[Pure.pure, Unit.unit]]
[Lean.Json.Structured.obj.inj,[]]
[Lean.Elab.Term.Do.Code.seq.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Code.seq, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.SimpAll.Entry.id,[]]
[Lean.isIdFirst,[or, Char.isAlpha, Decidable.decide, Eq, Char.ofNat, Lean.isLetterLike]]
[Lean.instToExprChar,[Lean.ToExpr.mk, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.ToExpr.toExpr, Char.toNat]]
[Lean.Parser.Term.binderTactic.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Tactic.tacticSeq.formatter]]
[Lean.Elab.DefViewElabHeader.modifiers,[]]
[Lean.privatePrefix?,[ite, Eq, Lean.isPrivateName, Bool.true, Option.some, Lean.Name.anonymous, Lean.Name.num, Lean.Name, PProd.fst, Option.none]]
[Lean.Lsp.TypeDefinitionParams.mk.inj,[]]
[Lean.JsonRpc.RequestID.noConfusionType,[]]
[Lean.Parser.Tactic.clearExcept,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[Nat.gcd_dvd_right,[And.right, Nat.gcd_dvd]]
[Lean.ProjectionFunctionInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Array.insertAt,[ite, GT.gt, Array.size, panicWithPosWithDecl, OfNat.ofNat, Array.insertAtAux]]
[Subtype.coind_surjective,[Exists, Eq, Subtype.coind, Exists.intro, Subtype.coe_injective]]
[Lean.Meta.instInhabitedGeneralizeArg,[Inhabited.mk, Lean.Meta.GeneralizeArg.mk, arbitrary]]
[Function.involutive.comp_self,[funext]]
[Lean.Meta.Cache.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Cache.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Array.insertionSort.swapLoop,[Array, Eq.refl]]
[Std.PersistentArray.mod2Shift,[USize.land, HSub.hSub, USize.shiftLeft, OfNat.ofNat]]
[Lean.IR.Borrow.ParamMap.instBEqKey,[BEq.mk, Lean.IR.Borrow.ParamMap.Key.decl, Lean.IR.Borrow.ParamMap.Key.jp, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Elab.Tactic.getMainTag,[Bind.bind, Lean.Elab.Tactic.getMainDecl, Pure.pure, Lean.MetavarDecl.userName]]
[Lean.Parser.instReprLeadingIdentBehavior,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone]]
[Lean.KernelException.declHasFVars.inj,[And.intro]]
[Lean.Expr.FoldConstsImpl.visited,[Bind.bind, MonadState.get, ite, Eq, BEq.beq, ptrAddrUnsafe, Bool.true, Pure.pure, modify, Lean.Expr.FoldConstsImpl.State.mk, Array.uset, Lean.Expr.FoldConstsImpl.State.visitedTerms, Lean.Expr.FoldConstsImpl.visited.proof_2, Lean.Expr.FoldConstsImpl.State.visitedConsts, Bool.false]]
[Lean.Lsp.Location.uri,[]]
[Lean.Message.noConfusionType,[]]
[Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.noConfusionType,[]]
[Array.find?,[Id.run, Array.findM?]]
[IO.AsyncList.nil.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.MVarId.mk.inj,[]]
[Lean.Meta.withNewLocalInstances,[Lean.Meta.mapMetaM]]
[Lean.Server.Watchdog.GroupedEdits.applyTime,[]]
[Lean.Meta.instBEqTransparencyMode,[BEq.mk, BEq.beq, Lean.Meta.TransparencyMode.toCtorIdx]]
[Lean.mkIBelow,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.MonadEnv.modifyEnv, Lean.throwKernelException, Lean.mkIBelowImp]]
[instDecidableEqBool.proof_2,[]]
[Lean.IR.CtorFieldInfo.noConfusionType,[]]
[Or.symm,[Or, Or.inr, Or.inl]]
[Nat.gcd_gcd_self_right_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, Nat.gcd_comm, Nat.gcd_gcd_self_right_left, rfl]]
[Tactic.Ring.horner_mul_horner_zero,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Tactic.Ring.horner, OfNat.ofNat, Eq.symm, of_eq_true, Eq.trans, congr, congrArg, HAdd.hAdd, HPow.hPow, add_zero, add_mul, congrFun, mul_assoc, eq_self]]
[Lean.findDeclarationRanges?,[Bind.bind, liftM, ST.Ref.get, Lean.builtinDeclRanges, Option.none, Option, Lean.DeclarationRanges, Lean.NameMap.find?, Pure.pure, Option.some, PUnit.unit]]
[Lean.PrettyPrinter.Formatter.symbolNoAntiquot.formatter,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, Lean.Syntax.isToken, Bool.true, Pure.pure, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Lean.PrettyPrinter.FormatterM, Unit, Lean.PrettyPrinter.Formatter.pushToken, Lean.Syntax.MonadTraverser.goLeft, panicWithPosWithDecl, OfNat.ofNat, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Std.ToFormat.format, PUnit.unit]]
[Lean.Parser.longestMatchFn,[Unit.unit, List.cons, Lean.Parser.ParserFn, Lean.Parser.ParserState.mkError, Lean.Parser.runLongestMatchParser, Lean.Parser.ParserState.lhsPrec, Lean.Parser.Parser.fn, Prod.fst, Lean.Parser.longestMatchFnAux, Prod.snd]]
[Nat.pos_pow_of_pos,[Nat.pow_le_pow_of_le_right, Nat.zero_le]]
[Std.PersistentArray.findSomeRevM?,[Bind.bind, Array.findSomeRevM?, Std.PersistentArray.tail, Unit.unit, Option, Std.PersistentArray.findSomeRevMAux, Std.PersistentArray.root, Pure.pure, Option.some]]
[Lean.Meta.CheckAssignment.Context.noConfusionType,[]]
[Lean.Meta.Match.Pattern.val.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Pattern.val, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.SimpleScopedEnvExtension,[Lean.ScopedEnvExtension]]
[Lean.Elab.logInfo,[Lean.Elab.log, Lean.MessageSeverity.information]]
[prioHigh,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.mkSimpleThunk,[Lean.mkLambda, Lean.Name.mkStr, Lean.Name.anonymous, Lean.BinderInfo.default, Lean.mkConst, List.nil]]
[Lean.Parser.Term.doNested.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.doSeq.formatter]]
[instReprAtomUInt64,[ReprAtom.mk]]
[Lean.Meta.SizeOfSpecNested.Context.recMap,[]]
[Lean.QuotVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.QuotVal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[HAndThen.noConfusionType,[]]
[Lean.Compiler.unreachableExpr,[Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Subarray.any,[Id.run, Subarray.anyM]]
[Lean.TheoremVal.mk.inj,[And.intro]]
[ForIn.noConfusionType,[]]
[Std.ShareCommon.ObjectMap.find?,[Std.HashMap.find?]]
[Lean.Elab.Tactic.evalInduction.checkTargets,[Bind.bind, ForIn.forIn, PUnit.unit, Pure.pure]]
[Lean.Parser.Term.optEllipsis.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.optional.formatter, Lean.Parser.symbol.formatter]]
[Lean.Meta.forallTelescopeReducing,[Lean.Meta.map2MetaM, Option.none]]
[Lean.Parser.Tactic.Conv.normNum,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg]]
[Lean.LocalContext.mkForall,[Lean.LocalContext.mkBinding, Bool.false]]
[Lean.Parser.Term.sufficesDecl.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.optIdent.formatter, Lean.Parser.termParser.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.fromTerm.formatter, Lean.Parser.Term.byTactic.formatter]]
[Lean.Parser.Tactic.Conv.convSeq1Indented,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Lean.Parsec.many,[Lean.Parsec.manyCore, List.toArray, List.nil]]
[Lean.Elab.Frontend.FrontendM,[ReaderT, Lean.Elab.Frontend.Context, StateRefT', IO.RealWorld, Lean.Elab.Frontend.State, IO]]
[Lean.mkApp4,[Lean.mkAppB]]
[Nat.le_sub_iff_add_le,[Eq.mpr, Eq.refl, Iff, LE.le, HSub.hSub, HAdd.hAdd, Eq.symm, Nat.add_sub_cancel, propext, Nat.sub_le_sub_right_iff, Iff.rfl]]
[Lean.MVarId.mk.injEq,[Eq.propIntro, Eq.refl, Lean.MVarId.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.ExplicitRC.Context.noConfusionType,[]]
[Lean.Meta.Config.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Closure.MkValueTypeClosureResult.levelArgs,[]]
[MonadWithReaderOf.withReader,[]]
[Lean.Parser.Term.byTactic.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Tactic.tacticSeq.formatter]]
[Lean.IR.Expr.pap.inj,[And.intro]]
[Lean.Parser.checkColGt,[Lean.Parser.Parser.mk, Lean.Parser.checkColGtFn]]
[Lean.Expr.toHeadIndex,[Unit.unit, Lean.HeadIndex, Lean.Expr.bvar, Option, Option.some, Lean.HeadIndex.mvar, Lean.HeadIndex.fvar, Lean.HeadIndex.const, Lean.HeadIndex.proj, Lean.HeadIndex.sort, Lean.HeadIndex.lam, Lean.HeadIndex.forallE, Lean.HeadIndex.lit, PProd.fst, PProd.snd, Option.none]]
[Lean.ExternEntry.inline.inj,[And.intro]]
[Lean.Meta.RecursorUnivLevelPos.majorType.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.RecursorUnivLevelPos.majorType, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.SimpEntry.lemma.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.SimpEntry.lemma, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.ParenthesizerM.orElse,[Bind.bind, MonadState.get, Lean.catchInternalId, Lean.PrettyPrinter.backtrackExceptionId, MonadStateOf.set, Unit.unit]]
[Lean.Meta.SynthInstance.TableEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Or.by_cases,[dite, False.elim, Or.elim]]
[PProd.fst,[]]
[Lean.PrettyPrinter.Formatter.withoutInfo.formatter,[]]
[Lean.Meta.ReduceEval.noConfusionType,[]]
[Lean.Elab.Term.ElabAppArgs.State.mk.inj,[And.intro]]
[Lean.PrettyPrinter.Delaborator.isStructureInstance,[Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.Meta.MetaM, Bool, Lean.Expr.isConstructorApp?, Pure.pure, Lean.isStructure, Lean.ConstructorVal.induct, Bool.false]]
[FloatArray.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.Diagnostic,[Lean.Lsp.DiagnosticWith, String]]
[Lean.Parser.Tactic.rwModCast,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[instSubsingletonEmpty,[instSubsingletonEmpty.proof_1]]
[Lean.Meta.applySimpResultToTarget,[Unit.unit, Lean.Meta.MetaM, Lean.MVarId, Lean.Meta.Simp.Result.proof?, Lean.Meta.replaceTargetEq, Lean.Meta.Simp.Result.expr, ite, Eq, bne, Bool.true, Lean.Meta.replaceTargetDefEq, Pure.pure]]
[and_false,[propext, Iff.intro, And.right, False.elim]]
[Lean.instQuoteProd,[Lean.Quote.mk, Lean.Syntax, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Quote.quote, List.nil]]
[Lean.Parser.Term.fun.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.maxPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.unicodeSymbol.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.basicFun.formatter, Lean.Parser.Term.matchAlts.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[HAdd.hAdd,[]]
[Lean.Parser.Term.strictImplicitBinder.parenthesizer,[Lean.Parser.ppGroup.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.strictImplicitLeftBracket.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.Parser.Term.binderType.parenthesizer, Lean.Parser.Term.strictImplicitRightBracket.parenthesizer]]
[Lean.stringToMessageData,[Lean.MessageData.joinSep, Lean.MessageData.ofFormat, Std.Format.line]]
[Lean.Meta.Instances.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Instances.mk, Eq.symm, eq_of_heq, HEq.refl]]
[instDecidableLt_2,[UInt16.decLt]]
[UInt16.instRingUInt16.proof_3,[congrArg, UInt16.mk, Ring.gsmul_succ', UInt16.val]]
[List.filterMapM,[List.reverse, List.nil, List.filterMapM.loop]]
[Lean.getProjFnForField?,[Option.none, Option, Lean.Name, Lean.getFieldInfo?, Option.some, Lean.StructureFieldInfo.projFn]]
[Lean.IR.addDeclAux,[Lean.PersistentEnvExtension.addEntry, Lean.IR.declMapExt]]
[Lean.Parser.Command.elabArg,[Lean.Parser.Command.macroArg]]
[Std.Rbcolor.red.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parsec.ParseResult.error.inj,[And.intro]]
[Lean.Server.FileWorker.instBEqReference,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Option.«commandRegister_builtin_option__:_:=_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Lean.Parser.Command.notationItem.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.ppSpace.formatter, Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.strLit.formatter, Lean.Parser.Command.identPrec.formatter]]
[Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer,[Bind.bind, Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.PrettyPrinter.Parenthesizer.addPrecCheck, modify, Lean.PrettyPrinter.Parenthesizer.State.mk, Lean.PrettyPrinter.Parenthesizer.State.stxTrav, Option.some, Nat.min, HSub.hSub, Lean.Parser.maxPrec, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.State.contCat, Lean.PrettyPrinter.Parenthesizer.State.minPrec, Lean.PrettyPrinter.Parenthesizer.State.trailPrec, Lean.PrettyPrinter.Parenthesizer.State.trailCat, Lean.PrettyPrinter.Parenthesizer.State.visitedToken]]
[Lean.Export.exportLevel,[Bind.bind, MonadState.get, Unit.unit, Lean.ExportM, Nat, Std.HashMap.find?, Lean.Export.Alloc.map, Lean.Export.State.levels, Pure.pure, OfNat.ofNat, Lean.Export.alloc, PProd.fst, liftM, IO.println, HAppend.hAppend, ToString.toString, PProd.snd, Lean.Export.exportName, panicWithPosWithDecl]]
[USize.instRingUSize.proof_1,[congrArg, USize.mk, Ring.sub_eq_add_neg, USize.val]]
[Lean.MetavarContext.MkBinding.State.ngen,[]]
[coeOfHeafOfTCOfTail,[CoeHTCT.mk, coeTail, coeTC, coeHead]]
[Lean.mkBoolDataValueEx,[Lean.DataValue.ofBool]]
[Lean.KernelException.appTypeMismatch.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.syntax.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.docComment.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optPrecedence.formatter, Lean.Parser.Command.optNamedName.formatter, Lean.Parser.Command.optNamedPrio.formatter, Lean.Parser.many1.formatter, Lean.Parser.syntaxParser.formatter, Lean.Parser.argPrec, Lean.Parser.ident.formatter]]
[Lean.MessageData.instCoeStringMessageData,[Coe.mk, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[instInhabitedArrow_1,[Inhabited.mk, Pure.pure]]
[Lean.Meta.forallTelescopeCompatibleAux,[Lean.Meta.MetaM, Bind.bind, Lean.Meta.whnf, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, ite, Eq, BEq.beq, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.Parser.Term.scientific,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.scientificLit]]
[Lean.ReducibilityHints.lt,[Lean.ReducibilityHints.opaque, Unit.unit, Lean.ReducibilityHints.regular, Lean.ReducibilityHints.abbrev, Bool, Bool.false, Bool.true, Decidable.decide, LT.lt]]
[Lean.Parser.ParserExtension.Entry.noConfusionType,[]]
[Lean.IR.UnreachableBranches.instInhabitedValue,[Inhabited.mk, Lean.IR.UnreachableBranches.Value.bot]]
[StateM,[StateT, Id]]
[peirce',[id]]
[instMulFloat,[Mul.mk, Float.mul]]
[Lean.Compiler.atMostOnce.Visitor,[Lean.Compiler.atMostOnce.AtMostOnceData]]
[Lean.Elab.Term.MutualClosure.FixPoint.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PersistentEnvExtensionState.state,[]]
[true_and,[propext, Iff.intro, And.right, And.intro, trivial]]
[Lean.Meta.instBEqSimpLemma,[BEq.mk, BEq.beq, Lean.Meta.SimpLemma.proof]]
[Lean.Parser.Tactic.rcasesPat.paren,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.Parser.Tactic.rcasesPatLo]]
[Lean.Expr.ReplaceImpl.State.keys,[]]
[List.append_ne_nil_of_left_ne_nil,[of_eq_true, Eq.trans, ne_eq, HAppend.hAppend, List.nil, congrArg, Not, propext, List.append_eq_nil, congrFun, And, eq_false, Eq, false_and, eq_true_of_decide, Eq.refl, Bool.true]]
[Lean.Parser.Command.optDeclSig.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.many.formatter, Lean.ppSpace.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.simpleBinderWithoutType.formatter, Lean.Parser.Term.bracketedBinder.formatter, Bool.false, Lean.Parser.Term.optType.formatter]]
[getThe,[MonadStateOf.get]]
[Lean.StructureInfo.fieldNames,[]]
[Lean.Elab.Deriving.BEq.mkBEqHeader,[Lean.Elab.Deriving.mkHeader, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat]]
[Nat.coprime.gcd_mul_right_cancel,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.mul_comm, Nat.coprime.gcd_mul_left_cancel, rfl]]
[IO.Process.Child.stdout,[]]
[Std.HashMapImp.foldM,[Std.HashMapImp.foldBucketsM, Std.HashMapImp.buckets]]
[Lean.IR.EmitC.isIf,[ite, Eq, bne, Array.size, OfNat.ofNat, Bool.true, Option.none, Lean.IR.AltCore.default, Option, Prod, Nat, Lean.IR.FnBody, Array.getOp, Option.some, Prod.mk, Lean.IR.CtorInfo.cidx, Lean.IR.AltCore.body]]
[Lean.Xml.Parser.EntityDef,[HOrElse.hOrElse, SeqRight.seqRight, Lean.Xml.Parser.EntityValue, Pure.pure, Unit.unit, SeqLeft.seqLeft, Lean.Xml.Parser.ExternalID, optional, Lean.Xml.Parser.NDataDecl]]
[Lean.addProtected,[Lean.TagDeclarationExtension.tag, Lean.protectedExt]]
[UInt16.instSemiringUInt16.proof_7,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt16.one_def, UInt16.mul_def, UInt16.mk, OfNat.ofNat, one_mul, UInt16.val, UInt16.mk_val_eq, eq_self, propext, forall_const, UInt16]]
[Lean.Meta.replaceTargetEq,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarTag, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.getMVarType, Lean.Meta.getLevel, Lean.Meta.mkEq, Lean.Meta.mkExpectedTypeHint, Lean.Meta.assignExprMVar, Pure.pure, Lean.Expr.mvarId!]]
[Lean.IR.FnBody.sset.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.instInhabitedPosition,[Inhabited.mk, Lean.Lsp.Position.mk, arbitrary]]
[Lean.Meta.mkSmartUnfoldingNameFor,[Lean.Name.mkStr, Lean.Meta.smartUnfoldingSuffix]]
[Lean.Expr.isMVar,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[Lean.Server.Watchdog.startFileWorker,[Bind.bind, MonadReader.read, liftM, Lean.Server.publishProgressAtPos, OfNat.ofNat, Lean.Server.Watchdog.ServerContext.hOut, Lean.Parser.parseHeader, IO, Lean.Syntax, Pure.pure, Lean.FileMap.source, Lean.Server.DocumentMeta.text, IO.Process.spawn, IO.Process.SpawnArgs.mk, Lean.Server.Watchdog.workerCfg, System.FilePath.toString, Lean.Server.Watchdog.ServerContext.workerPath, HAppend.hAppend, List.toArray, List.cons, List.nil, Lean.Server.Watchdog.ServerContext.args, IO.mkRef, Std.RBMap.empty, Option.none, IO.asTask, Task.Priority.dedicated, Task.map, Lean.Server.Watchdog.WorkerEvent, Lean.Server.Watchdog.WorkerEvent.ioError, Task.Priority.default, IO.FS.Stream.writeLspRequest, Lean.Server.Watchdog.FileWorker.stdin, Lean.JsonRpc.Request.mk, Lean.Server.Watchdog.ServerContext.initParams, IO.FS.Stream.writeLspNotification, Lean.JsonRpc.Notification.mk, Lean.Lsp.DidOpenTextDocumentParams.mk, Lean.Lsp.TextDocumentItem.mk, Lean.Server.DocumentMeta.uri, Lean.Server.DocumentMeta.version, Lean.Server.Watchdog.updateFileWorkers]]
[Lean.Lsp.instToJsonTextDocumentSyncOptions,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentSyncOptions.openClose, List.nil, Lean.Lsp.TextDocumentSyncOptions.change, Lean.Lsp.TextDocumentSyncOptions.willSave, Lean.Lsp.TextDocumentSyncOptions.willSaveWaitUntil, Lean.Json.opt, Lean.Lsp.TextDocumentSyncOptions.save?]]
[Lean.Parser.Tactic.Conv.whnf,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Meta.SimpAll.State.entries,[]]
[Lean.Meta.SizeOfSpecNested.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SizeOfSpecNested.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.findLocalDecl?,[Bind.bind, Lean.MonadLCtx.getLCtx, Pure.pure, Lean.LocalContext.find?]]
[Lean.MonadStateCacheT.instMonadControlMonadStateCacheT,[inferInstanceAs, MonadControl, StateT, Std.HashMap]]
[List.getLast.proof_1,[rfl]]
[Lean.LocalDecl.setIndex,[Lean.LocalDecl, Lean.LocalDecl.cdecl, Lean.LocalDecl.ldecl]]
[Except.ok.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.LiveVarSet,[Lean.IR.VarIdSet]]
[Lean.Parser.ParserAttributeHook.mk.inj,[]]
[instAddSemigroupFin,[AddSemigroup.mk, instAddSemigroupFin.proof_1]]
[Lean.MessageLog.empty,[Lean.MessageLog.mk, Std.PersistentArray.mk]]
[Id.instLawfulMonadId,[Id.instLawfulMonadId.proof_1]]
[Lean.Syntax.MonadTraverser.goUp,[modify, Lean.Syntax.Traverser.up]]
[Lean.Elab.Term.MVarErrorKind.custom.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instOrOpUInt32,[OrOp.mk, UInt32.lor]]
[Lean.Elab.Command.StructView.params,[]]
[Nat.coprime.pow,[Nat.coprime.pow_right, Nat.coprime.pow_left]]
[Function.left_inverse.comp,[]]
[Lean.Lsp.TextDocumentSyncOptions.willSaveWaitUntil,[]]
[Lean.NameSanitizerState.mk.inj,[And.intro]]
[Std.HashMapImp.foldBucketsM,[Array.foldlM, Std.AssocList.foldlM, Subtype.val, OfNat.ofNat, Array.size]]
[Lean.DataValue.ofName.inj,[]]
[Lean.Elab.tryURefl,[Lean.MonadWithOptions.withOptions, Lean.Option.set, Lean.Meta.smartUnfolding, Bool.false, Bind.bind, MonadExcept.tryCatch, Lean.Meta.applyRefl, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Pure.pure, Bool.true]]
[Std.PersistentArray.shift,[]]
[Nat.eq_or_lt_of_le,[Or, Eq, LT.lt, Or.inl, rfl, Or.inr, Nat.succ_le_succ, Nat.zero_le, absurd, Nat.not_succ_le_zero]]
[Lean.Elab.DefView.value,[]]
[Lean.Elab.Tactic.withTacticInfoContext,[Bind.bind, Lean.Elab.Tactic.mkInitialTacticInfo, Lean.Elab.withInfoContext]]
[ofNat_pow,[Eq.mpr, Eq.refl, Eq, Numeric.ofNat, HPow.hPow, Nat.zero, pow_zero, OfNat.ofNat, Nat.pow_zero, rfl, Nat.succ, pow_succ, HMul.hMul, Nat.pow_succ, ofNat_mul]]
[Lean.MessageData.ofExpr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.addHintTactic,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Tactic.tacticSeq.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Tactic.tacticSeqBracketed.formatter, Lean.Parser.Tactic.tacticSeq1Indented.formatter, Bool.false]]
[Lean.Meta.CaseValueSubgoal.mvarId,[]]
[Std.RBNode.node.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.RBNode.node, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.setMCtx,[modify, Lean.Meta.State.mk, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed]]
[instShiftRightUInt64,[ShiftRight.mk, UInt64.shiftRight]]
[Lean.MonadCacheT.instMonadMonadCacheT,[inferInstanceAs, Monad, StateRefT', Std.HashMap]]
[Lean.Json.getObj?,[Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Lean.Json.arr, Except, String, Std.RBNode, Lean.Json, Pure.pure, MonadExcept.throw]]
[FloatSpec.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, FloatSpec.mk, Eq.symm, eq_of_heq, DecidableRel, HEq.refl]]
[Lean.Elab.Term.Do.Code.joinpoint.inj,[And.intro]]
[Lean.Elab.Tactic.saveState,[Bind.bind, liftM, Lean.Elab.Term.saveState, MonadState.get, Pure.pure, Lean.Elab.Tactic.SavedState.mk]]
[instHSub,[HSub.mk, Sub.sub]]
[One.one,[]]
[UInt8.toChar.proof_1,[UInt8.toChar_aux, Fin.val, UInt8.val, Fin.isLt]]
[Lean.Elab.Term.Do.eraseVars,[Array.foldl, Std.RBTree.erase, OfNat.ofNat, Array.size]]
[Lean.Elab.Term.Do.ToTerm.run,[Bind.bind, Lean.Elab.Term.Do.ToTerm.toTerm, Lean.Elab.Term.Do.ToTerm.Context.mk, Pure.pure]]
[Std.ShareCommon.mkObjectPersistentMap,[Std.PersistentHashMap.empty]]
[Lean.Parser.Command.notation.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optPrecedence.formatter, Lean.Parser.Command.optNamedName.formatter, Lean.Parser.Command.optNamedPrio.formatter, Lean.Parser.many.formatter, Lean.Parser.Command.notationItem.formatter, Lean.Parser.darrow.formatter, Lean.Parser.termParser.formatter]]
[UInt16.decEq.proof_2,[absurd]]
[Lean.Parser.precedenceParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Meta.SynthInstance.ConsumerNode.subgoals,[]]
[ExceptT.instMonadFunctorExceptT,[MonadFunctor.mk, Except]]
[Lean.instInhabitedOption,[Inhabited.mk, Lean.Option.mk, arbitrary]]
[Lean.Parser.Command.structCtor.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Command.declModifiers.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.inferMod.parenthesizer, Lean.Parser.symbol.parenthesizer]]
[Lean.registerScopedEnvExtensionUnsafe,[Bind.bind, Lean.registerPersistentEnvExtension, Lean.PersistentEnvExtensionDescr.mk, Lean.ScopedEnvExtension.Descr.name, Lean.ScopedEnvExtension.mkInitial, Lean.ScopedEnvExtension.addImportedFn, Lean.ScopedEnvExtension.addEntryFn, Lean.ScopedEnvExtension.exportEntriesFn, HAppend.hAppend, Std.ToFormat.format, List.length, Lean.ScopedEnvExtension.StateStack.newEntries, ST.Ref.modify, Lean.scopedEnvExtensionsRef, Array.push, unsafeCast, Pure.pure]]
[Decidable.not_or_iff_and_not,[Iff.intro, And, Not, False.elim, Or.inl, Or.inr, And.intro, False, Or.elim]]
[Lean.InductiveVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.InductiveVal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[leOfOrd,[LE.mk, Eq, Ordering.isLE, Ord.compare, Bool.true]]
[Nat.lcm_comm,[]]
[Lean.QuotKind.ind.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Lsp.instToJsonCommand,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.Command.title, List.nil, Lean.Lsp.Command.command, Lean.Json.opt, Lean.Lsp.Command.arguments?]]
[Std.PersistentHashMap.size,[]]
[WellFoundedRelation.mk.injEq,[Eq.propIntro, Eq.refl, WellFoundedRelation.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.LValResolution.projIdx.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LValResolution.projIdx, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.InitializeParams.initializationOptions?,[]]
[Lean.NameGenerator.mkChild,[Prod.mk, Lean.NameGenerator.mk, Lean.Name.mkNum, Lean.NameGenerator.namePrefix, Lean.NameGenerator.idx, OfNat.ofNat, HAdd.hAdd]]
[Lean.IR.EmitC.emitExternCall,[Option.none, Option.some, Lean.ExternEntry.adhoc, Lean.IR.EmitC.M, Unit, Lean.getExternEntryFor, Lean.Name.mkStr, Lean.Name.anonymous, Lean.IR.EmitC.emitSimpleExternalCall, Bind.bind, Lean.IR.EmitC.emit, Lean.expandExternPattern, Lean.IR.EmitC.toStringArgs, Lean.IR.EmitC.emitLn, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[List.ball_nil,[False.elim]]
[Lean.Meta.Match.MatcherInfo.mk.inj,[And.intro]]
[Lean.Meta.InductionSubgoal.mk.inj,[And.intro]]
[Lean.Parser.darrow.parenthesizer,[Lean.Parser.symbol.parenthesizer]]
[Lean.Elab.Command.ElabHeaderResult.localInsts,[]]
[Lean.Parser.Tactic.eConstructor,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[List.eq_nil_iff_forall_not_mem,[]]
[Lean.Parser.Term.doNested.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer]]
[Lean.Parser.Term.do.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.argPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.doSeq.formatter]]
[List.le,[Not, LT.lt]]
[Lean.instToMessageDataList,[Lean.ToMessageData.mk, Lean.MessageData.ofList, List.map, Lean.ToMessageData.toMessageData]]
[Lean.Parser.Tactic.unitInterval,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.PrettyPrinter.Delaborator.SubExpr.noConfusionType,[]]
[Lean.MonadCacheT.instMonadHashMapCacheAdapterMonadCacheT,[Lean.MonadHashMapCacheAdapter.mk, MonadState.get, modify]]
[ExceptCpsT.runCatch_throw,[rfl]]
[UInt8.instNegUInt8,[Neg.mk, UInt8.mk, Neg.neg, UInt8.val]]
[Lean.Lsp.LocationLink.noConfusionType,[]]
[Lean.IR.ExplicitBoxing.withVDecl,[MonadWithReader.withReader, Lean.IR.ExplicitBoxing.BoxingContext.mk, Lean.IR.ExplicitBoxing.BoxingContext.f, Lean.IR.LocalContext.addLocal, Lean.IR.ExplicitBoxing.BoxingContext.localCtx, Lean.IR.ExplicitBoxing.BoxingContext.resultType, Lean.IR.ExplicitBoxing.BoxingContext.decls, Lean.IR.ExplicitBoxing.BoxingContext.env]]
[Ne.irrefl,[rfl]]
[HEq.elim,[eq_of_heq]]
[List.isPrefix,[Exists, Eq, HAppend.hAppend]]
[Lean.Name.num.inj,[And.intro]]
[Lean.Lsp.CompletionParams.toTextDocumentPositionParams,[]]
[Lean.Parser.Tactic.induction',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.casesTarget, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.binderIdent]]
[Std.PersistentHashMap.instInhabitedPersistentHashMap,[Inhabited.mk, Std.PersistentHashMap.mk]]
[Lean.Elab.Command.ElabStructResult.mctx,[]]
[Lean.Parser.Term.elseIf.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.group.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkLineEq.parenthesizer]]
[Functor.map_equiv,[Equiv.mk, Functor.map, Equiv.toFun, Equiv.symm, Functor.map_equiv.proof_1, Functor.map_equiv.proof_2]]
[Lean.Expr.letE.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.letE, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.withLocalDecl,[Lean.Meta.map1MetaM, Bind.bind, Lean.mkFreshFVarId, MonadReader.read, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.localInstances, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth, Lean.Meta.isClass?, Unit.unit, Lean.Meta.MetaM, Lean.Meta.withNewLocalInstance]]
[Lean.Meta.isExprDefEq,[Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.lctx, Lean.Meta.Context.localInstances, Option.some, Lean.Meta.DefEqContext.mk, Lean.Meta.Context.synthPendingDepth, Bind.bind, Lean.Meta.checkpointDefEq, Lean.Meta.isExprDefEqAux, Bool.true, Lean.isTracingEnabledFor, ite, Eq, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[ExceptCpsT.runCatch_bind_lift,[rfl]]
[Lean.Compiler.instInhabitedSpecEntry,[Inhabited.mk, Lean.Compiler.SpecEntry.info, arbitrary]]
[Lean.Parser.Tactic.cases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.casesTarget, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlts]]
[Lean.Elab.Command.MkInstanceName.main,[Bind.bind, Lean.Elab.liftMacroM, Lean.expandMacros, StateRefT'.run, Lean.Elab.Command.MkInstanceName.collect, Lean.Elab.Command.CommandElabM, Lean.Name, ite, Eq, String.isEmpty, Bool.true, Lean.Elab.Command.MkInstanceName.mkFreshInstanceName, Lean.Elab.mkUnusedBaseName, Lean.Name.mkSimple, HAppend.hAppend]]
[List.disjoint_of_disjoint_cons_right,[List.disjoint_of_subset_right, List.subset_cons]]
[Lean.Widget.InteractiveDiagnostic.toDiagnostic,[Lean.Lsp.DiagnosticWith.mk, Lean.Lsp.DiagnosticWith.range, Lean.Lsp.DiagnosticWith.fullRange, Lean.Lsp.DiagnosticWith.severity?, Lean.Lsp.DiagnosticWith.code?, Lean.Lsp.DiagnosticWith.source?, Lean.Lsp.DiagnosticWith.message, Lean.Lsp.DiagnosticWith.tags?, Lean.Lsp.DiagnosticWith.relatedInformation?, Lean.Widget.InteractiveDiagnostic.toDiagnostic.prettyTt]]
[Std.PersistentHashMap.Entry.entry.inj,[And.intro]]
[Lean.Parser.Tactic.squeezeDSimp?!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.Elab.mkAttrKindGlobal,[Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkNullNode, List.nil]]
[Lean.KernelException.declHasFVars.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.declHasFVars, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Tactic.ElimApp.Result.mk.inj,[And.intro]]
[Array.«term__[:_]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Command.reduce.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter]]
[Lean.PersistentEnvExtensionDescr.addEntryFn,[]]
[Lean.Meta.Match.Example.ctor.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.Example.ctor, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.ElimAltInfo.mk.inj,[And.intro]]
[UInt64.mul,[UInt64.mk, HMul.hMul, UInt64.val]]
[Lean.nullKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Meta.RecursorInfo.numMinors,[HSub.hSub, HAdd.hAdd, Lean.Meta.RecursorInfo.majorPos, OfNat.ofNat, Lean.Meta.RecursorInfo.firstIndexPos]]
[Lean.Meta.Match.Problem.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt8.instSemigroupUInt8.proof_1,[congrArg, UInt8.mk, Semigroup.mul_assoc, UInt8.val]]
[Lean.Lsp.DocumentHighlightKind.read.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[String.intercalate,[Unit.unit, String, String.intercalate.go]]
[Lean.IR.ExplicitRC.Context.jpLiveVarMap,[]]
[Lean.Meta.Match.Extension.State.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Extension.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Position.instToFormatPosition,[Std.ToFormat.mk, Std.Format, HAppend.hAppend, Std.Format.text, Std.ToFormat.format]]
[Lean.Parser.Tactic.right,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[ST.mkRef,[liftM, ST.Prim.mkRef]]
[Lean.Meta.DefaultInstanceEntry.mk.inj,[And.intro]]
[Lean.Elab.TacticInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Function.uncurry_bicompr,[rfl]]
[Lean.Parser.Tactic.introMatch.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.Tactic.matchAlts.parenthesizer]]
[Lean.PrettyPrinter.Parenthesizer.checkNoImmediateColon.parenthesizer,[Pure.pure, Unit.unit]]
[Lean.ScopedEnvExtension.Descr.mk.inj,[And.intro]]
[Lean.Parser.Tactic.simpa?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser]]
[instDecidableLt_5,[LinearOrder.decidable_lt]]
[Lean.Elab.Command.runTermElabM,[Bind.bind, Lean.Elab.Command.getScope, Lean.Elab.Command.liftTermElabM, Lean.Elab.Term.withAutoBoundImplicit, Lean.Elab.Term.elabBinders, Lean.Elab.Command.Scope.varDecls, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Bool.false, ForIn.forIn, MProd.mk, Unit.unit, Lean.Elab.Term.TermElabM, ForInStep, MProd, Subarray, Lean.Expr, Lean.NameMap, Stream.next?, Pure.pure, ForInStep.done, PUnit.unit, ForInStep.yield, MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.Context.declName?, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.currMacroScope, Lean.Elab.Term.Context.mayPostpone, Lean.Elab.Term.Context.errToSorry, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.Term.Context.autoBoundImplicits, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection, Lean.Elab.Term.resetMessageLog, Lean.Elab.Term.addAutoBoundImplicits, Lean.Elab.Term.withoutAutoBoundImplicit]]
[Nat.eq_zero_of_gcd_eq_zero_right,[Nat.eq_zero_of_gcd_eq_zero_left, Eq.mp, Eq.refl, Eq, Nat.gcd, OfNat.ofNat, Nat.gcd_comm]]
[Std.AssocList.forM,[Unit.unit, PUnit, Pure.pure, PUnit.unit, Bind.bind, PProd.fst]]
[Lean.Lsp.DiagnosticSeverity.toCtorIdx,[OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.Context.optionsPerPos,[]]
[lt_of_le_of_ne,[lt_of_le_not_le, mt, le_antisymm]]
[Lean.PrettyPrinter.Formatter.scientificLitNoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.visitAtom, Lean.scientificLitKind]]
[Lean.Elab.Term.containsPendingMVar,[Bind.bind, OptionT.run, Lean.MonadCacheT.run, Lean.Elab.Term.ContainsPendingMVar.visit, Unit.unit, Lean.Elab.Term.TermElabM, Bool, Pure.pure, Bool.false, Bool.true]]
[Std.PersistentHashSet.noConfusionType,[]]
[Lean.Parser.Command.section.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.ident.parenthesizer]]
[Lean.Meta.Simp.tryRewriteUsingDecide,[Bind.bind, MonadReader.read, ite, Eq, Lean.Meta.Simp.Config.decide, Lean.Meta.Simp.Context.config, Bool.true, liftM, Lean.Meta.Simp.rewriteUsingDecide?, Unit.unit, Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step, Pure.pure, Lean.Meta.Simp.Step.done]]
[Eq.to_iff,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Iff, Iff.rfl]]
[Lean.Meta.CheckAssignment.State.noConfusionType,[]]
[Lean.Elab.Tactic.MkSimpContextResult.mk.inj,[And.intro]]
[AddMonoid.add_zero,[]]
[Lean.Meta.CheckAssignment.throwCheckAssignmentFailure,[MonadExcept.throw, Lean.Exception.internal, Lean.Meta.CheckAssignment.checkAssignmentExceptionId, Lean.KVMap.mk]]
[Lean.Meta.SimpLemmas.post,[]]
[Lean.Elab.Deriving.FromToJson.mkFromJsonInstanceHandler,[ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.isStructure, Array.getOp, Lean.Elab.Command.liftTermElabM, Option.none, Lean.Elab.Deriving.mkContext, Lean.Elab.Deriving.mkHeader, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.Deriving.Context.typeInfos, Lean.Elab.Deriving.mkInductiveApp, Lean.Elab.Deriving.Header.argNames, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, List.nil, Lean.Syntax.atom, Lean.mkIdent, Lean.Elab.Deriving.Context.auxFunNames, Array.push, Array.append, Lean.Elab.Deriving.Header.binders, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Array.map, Lean.Syntax, Array.zip, Lean.Elab.Deriving.mkInstanceCmds, HAppend.hAppend, Array.forM, Lean.Elab.Command.elabCommand, Lean.getConstInfoInduct, Lean.Elab.Deriving.mkDiscrs, Array.foldrM, Lean.Elab.Deriving.Context.usePartial, Lean.Elab.Deriving.mkLocalInstanceLetDecls, Lean.Elab.Deriving.mkLet, PUnit.unit, Bool.false, Lean.Elab.Deriving.FromToJson.mkFromJsonInstanceHandler.mkAlts]]
[Array.foldrM.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure]]
[Lean.KernelException.declTypeMismatch.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.SynthInstance.Waiter.consumerNode.inj,[]]
[Lean.Parser.leadingNode,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.node, Lean.Parser.setLhsPrec]]
[Lean.Elab.Modifiers.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Modifiers.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Do.getLetPatDeclVars,[Lean.Elab.Term.Do.getPatternVarsEx]]
[Lean.Lsp.LocationLink.targetRange,[]]
[Lean.SourceInfo.noConfusionType,[]]
[instMonadEST,[inferInstanceAs, Monad, EStateM]]
[Lean.Parser.Tactic.tauto,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[termWithout_expected_type_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instBEqProd,[BEq.mk, Bool, and, BEq.beq]]
[Nat.le_or_le,[Or.imp_left, Nat.le_of_lt, Nat.lt_or_ge]]
[Lean.JsonRpc.instBEqResponseError,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.PrettyPrinter.Formatter.State.leadWord,[]]
[Lean.AxiomVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.AxiomVal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.mkLevelIMaxEx,[Lean.mkLevelIMax]]
[Lean.OpaqueVal.toConstantVal,[]]
[Lean.MetavarContext.getDecl,[Unit.unit, Lean.MetavarDecl, Std.PersistentHashMap.find?, Lean.MetavarContext.decls, panicWithPosWithDecl, OfNat.ofNat]]
[UInt8.toChar_aux,[Eq.mpr, Eq.refl, Nat.isValidChar, Fin.val, UInt32.val, UInt32.ofNat, UInt32.val_eq_of_lt, Nat.lt_trans, of_decide_eq_true, Bool.true, Or.inl]]
[Lean.Parser.Level.imax,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.nonReservedSymbol, Lean.Parser.many1, Lean.Parser.ppSpace, Lean.Parser.levelParser, Lean.Parser.maxPrec]]
[Lean.Expr.instantiateLevelParams,[Lean.Expr.instantiateLevelParamsCore, List.nil, List.cons, Option, Lean.Level, ite, Eq, BEq.beq, Bool.true, Option.some, PProd.fst, Option.none]]
[Nat.eq_zero_or_pos,[Unit.unit, Or, Eq, OfNat.ofNat, GT.gt, Or.inl, rfl, Or.inr, Nat.succ_pos]]
[List.card_insert_of_mem,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.card, List.insert_of_mem, eq_true, eq_self]]
[Lean.Literal.hash,[UInt64, Hashable.hash]]
[Lean.Server.Completion.HoverInfo.noConfusionType,[]]
[Lean.JsonNumber.fromNat,[Lean.JsonNumber.mk, Int.ofNat, OfNat.ofNat]]
[Lean.Meta.SimpLemmas.add,[ite, Eq, Lean.Expr.isConst, Bool.true, Lean.Meta.SimpLemmas.addConst, Lean.Expr.constName!, Bind.bind, Lean.Meta.mkSimpLemmas, Pure.pure, Array.foldl, Lean.Meta.addSimpLemmaEntry, OfNat.ofNat, Array.size, Lean.Meta.SimpLemmas.add.getName?]]
[Lean.Lsp.instFromJsonSemanticTokensParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Pure.pure, Lean.Lsp.SemanticTokensParams.mk]]
[Lean.ExprMap,[Std.HashMap, Lean.Expr]]
[Lean.getPPPrivateNames,[Lean.KVMap.get, Lean.Option.name, Lean.pp.privateNames, Lean.getPPAll]]
[List.bind,[List.join, List.map]]
[Lean.Meta.SynthInstance.TableEntry.mk.inj,[And.intro]]
[Lean.Meta.Match.MatchEqns.noConfusionType,[]]
[List.erasep_map,[Unit.unit, Eq, List.erasep, List.map, Function.comp, rfl, Classical.em, of_eq_true, Eq.trans, congr, congrArg, List.map_cons, List.erasep_cons_of_pos, eq_true, Function.comp_apply, eq_self, Eq.symm, List.erasep_cons_of_neg, Not, eq_false, eq_true_of_decide, Eq.refl, Bool.true, List.cons, PProd.fst]]
[Nat.not_le,[Iff.intro, Nat.lt_of_not_le, Nat.not_le_of_lt]]
[Lean.JsonRpc.Message.response.inj,[And.intro]]
[Lean.Parser.TokenCacheEntry.stopPos,[]]
[Lean.Parser.Command.structInstBinder.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Command.declModifiers.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.inferMod.formatter, Lean.Parser.Command.declSig.formatter]]
[Lean.Lsp.instFromJsonTextDocumentContentChangeEvent,[Lean.FromJson.mk, HOrElse.hOrElse, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.Range, String, Pure.pure, Lean.Lsp.TextDocumentContentChangeEvent.rangeChange, Functor.map, Lean.Lsp.TextDocumentContentChangeEvent.fullChange]]
[List.«term_~_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Macro.Methods.noConfusionType,[]]
[Fin.xor.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[Lean.Widget.MsgEmbed.goal.inj,[]]
[Lean.Meta.SimpLemma.perm,[]]
[String.join,[List.foldl, HAppend.hAppend]]
[Lean.Meta.RecursorInfo.typeName,[]]
[Lean.MessageData.compose.inj,[And.intro]]
[Lean.Lsp.SemanticTokens.mk.inj,[]]
[Lean.ParserCompiler.Context.varName,[]]
[Lean.Syntax.isAntiquotSplice,[Option.isSome, Lean.Syntax.antiquotSpliceKind?]]
[Nat.ble,[Unit.unit, Bool, Bool.true, Bool.false, PProd.fst]]
[Lean.IR.FnBody.collectFreeIndices,[Lean.IR.FreeIndices.collectFnBody, EmptyCollection.emptyCollection]]
[Decidable.lt_or_eq_of_le,[dite, LE.le, Or.inr, le_antisymm, Or.inl, lt_of_le_not_le]]
[List.append',[List, List.cons, PProd.fst]]
[dif_ctx_congr,[Eq, dite, absurd, Iff.mp, not_iff_not_of_iff, Iff.mpr]]
[Nat.zero_sub,[Unit.unit, Eq, HSub.hSub, OfNat.ofNat, rfl, congr_arg, Nat.pred, PProd.fst]]
[Lean.Compiler.CSimp.Entry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.sepByNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.sepByInfo, Lean.Parser.Parser.info, Lean.Parser.sepByFn, Lean.Parser.Parser.fn]]
[IO.mkRef,[ST.mkRef]]
[Option.filter,[Unit.unit, Option, ite, Eq, Bool.true, Option.some, Option.none]]
[UInt8.instSemiringUInt8.proof_11,[Eq.mpr, congr, congrArg, Eq, Eq.trans, HMul.hMul, UInt8.add_def, UInt8.mul_def, UInt8.mk, HAdd.hAdd, UInt8.val, UInt8.eq_of_val_eq, Semiring.mul_add]]
[Option.some.inj,[]]
[Lean.Parser.Tactic.uniqueDiffWithinAt_Ici_Iic_univ,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Meta.withNatValue,[Bind.bind, Lean.Meta.whnf, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Name.anonymous, Lean.Name.str, dite, Eq, Eq.symm, Lean.Name.num, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.strVal, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Option, OfNat.ofNat, Pure.pure, Option.none]]
[Lean.Elab.Tactic.SavedState.tactic,[]]
[Lean.Meta.mkAppOptM',[Bind.bind, Lean.Meta.inferType, Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.withNewMCtxDepth, OfNat.ofNat, List.toArray, List.nil]]
[Lean.Meta.getResetPostponed,[Bind.bind, Lean.Meta.getPostponed, Lean.Meta.setPostponed, Std.PersistentArray.mk, Pure.pure]]
[Nat.prod_dvd_and_dvd_of_dvd_prod.proof_3,[Nat.zero_lt_succ, Eq.symm]]
[Lean.IR.LogEntry.message.injEq,[Eq.propIntro, Eq.refl, Lean.IR.LogEntry.message, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.ScopedEnvExtension.ScopedEntries.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.Checker.checkJP,[Bind.bind, MonadReader.read, ite, Eq, Lean.IR.LocalContext.isJP, Lean.IR.Checker.CheckerContext.localCtx, Lean.IR.JoinPointId.idx, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Lean.Elab.Term.Do.Code.jmp.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[String.isPrefixOf,[String.substrEq, OfNat.ofNat, String.bsize]]
[instDecidableEqOption,[Unit.unit, Decidable, Eq, Decidable.isTrue, rfl, Decidable.isFalse, dite]]
[pure_id_seq,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, LawfulApplicative.pure_seq, id, LawfulFunctor.id_map, eq_self]]
[Lean.NameSet.instInhabitedNameSet,[Inhabited.mk, Lean.NameSet.empty]]
[IO.Error.permissionDenied.inj,[And.intro]]
[Lean.Elab.Term.expandFunBinders,[OfNat.ofNat, List.toArray, List.nil, Lean.Elab.Term.expandFunBinders.loop]]
[Lean.Compiler.SpecState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Compiler.SpecState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Xml.Element.ibelow,[And, True]]
[type_eq_of_heq,[type_eq_of_heq.proof_1]]
[Char.utf8Size.proof_7,[of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Widget.MsgEmbed.rpcPacketFor,[]]
[Std.PersistentArray.set,[ite, GE.ge, Std.PersistentArray.tailOff, Std.PersistentArray.mk, Std.PersistentArray.root, Array.set!, Std.PersistentArray.tail, HSub.hSub, Std.PersistentArray.size, Std.PersistentArray.shift, Std.PersistentArray.setAux, USize.ofNat]]
[Lean.Meta.ApplyNewGoals.toCtorIdx,[OfNat.ofNat]]
[Lean.getPPStructureProjections,[Lean.KVMap.get, Lean.Option.name, Lean.pp.structureProjections, not, Lean.getPPAll]]
[Lean.IR.Borrow.updateParamSet,[Lean.IR.Borrow.BorrowInfCtx.mk, Lean.IR.Borrow.BorrowInfCtx.env, Lean.IR.Borrow.BorrowInfCtx.decls, Lean.IR.Borrow.BorrowInfCtx.currFn, Array.foldl, Std.RBTree.insert, Lean.IR.VarId.idx, Lean.IR.Param.x, Lean.IR.Borrow.BorrowInfCtx.paramSet, OfNat.ofNat, Array.size]]
[Lean.KVMap.subsetAux,[Bool, Bool.true, Unit.unit, Lean.KVMap.find, and, BEq.beq, PProd.fst, Bool.false]]
[Lean.Parser.Term.precheckedQuot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.quot.parenthesizer]]
[Lean.AttributeImplCore.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Level.isSucc,[Lean.Level.zero, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Bool, Bool.true, Bool.false]]
[Lean.Meta.CongrLemma.priority,[]]
[instToStringUInt32,[ToString.mk, ToString.toString, UInt32.toNat]]
[Lean.MacroScopesView.format,[Std.ToFormat.format, ite, Eq, List.isEmpty, Lean.MacroScopesView.scopes, Bool.true, Lean.MacroScopesView.name, BEq.beq, Lean.MacroScopesView.mainModule, List.foldl, Lean.Name.mkNum, HAppend.hAppend, Lean.MacroScopesView.imported]]
[Lean.PrettyPrinter.Delaborator.Delab,[Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax]]
[Lean.Parser.ParserState.setError,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Option.some, Lean.Parser.Error.mk, List.cons, List.nil]]
[Nat.le_step,[Nat.le.step]]
[Lean.Widget.GetInteractiveDiagnosticsParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Widget.GetInteractiveDiagnosticsParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.SCC.State.data,[]]
[Lean.Lsp.TextDocumentContentChangeEvent.hasToJson,[Lean.ToJson.mk, Lean.Json.mkObj, List, Prod, String, Lean.Json, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil]]
[Lean.Parser.Term.doIfLetBind.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.Lsp.TextDocumentPositionParams.position,[]]
[Lean.IR.Arg.noConfusionType,[]]
[Lean.Parser.Term.doBreak.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.Parser.Command.bindersItem,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol]]
[Lean.Lsp.instToJsonLocationLink,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Lsp.LocationLink.originSelectionRange?, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.LocationLink.targetUri, List.nil, Lean.Lsp.LocationLink.targetRange, Lean.Lsp.LocationLink.targetSelectionRange]]
[Lean.MetavarContext.renameMVar,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Std.PersistentHashMap.insert, Lean.MetavarContext.decls, Lean.MetavarDecl.mk, Lean.MetavarDecl.lctx, Lean.MetavarDecl.type, Lean.MetavarDecl.depth, Lean.MetavarDecl.localInstances, Lean.MetavarDecl.kind, Lean.MetavarDecl.numScopeArgs, Lean.MetavarDecl.index, ite, Eq, Lean.Name.isAnonymous, Bool.true, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment]]
[Lean.Parser.Command.inductive.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.Command.optDeclSig.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.many.formatter, Lean.Parser.Command.ctor.formatter, Lean.Parser.Command.optDeriving.formatter]]
[Lean.Parser.Term.arrayRef.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter]]
[Ring.gsmul_succ',[]]
[Lean.Elab.Tactic.evalIntroMatch,[Bind.bind, Lean.Elab.liftMacroM, Lean.Elab.Term.expandMatchAltsIntoMatchTactic, Lean.Elab.Tactic.withMacroExpansion, Lean.Elab.Tactic.evalTactic]]
[Lean.SearchPath,[System.SearchPath]]
[Lean.JsonNumber.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.instBEqOccurrences,[BEq.mk, Unit.unit, Lean.Occurrences.all, Lean.Occurrences.pos, Lean.Occurrences.neg, Bool, Bool.true, and, BEq.beq, Bool.false]]
[Lean.ClassEntry.name,[]]
[Seq.noConfusionType,[]]
[Lean.IR.ExplicitRC.VarInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.macro.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.suppressInsideQuot.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.docComment.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optPrecedence.formatter, Lean.Parser.Command.optNamedName.formatter, Lean.Parser.Command.optNamedPrio.formatter, Lean.Parser.many1.formatter, Lean.Parser.Command.macroArg.formatter, Lean.Parser.Command.macroTail.formatter]]
[instStreamSubarray.proof_1,[Nat.succ_le_of_lt]]
[Lean.ParserCompiler.CombinatorAttribute.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Name.str.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Name.str, Eq.symm, eq_of_heq, HEq.refl]]
[forall_not_of_not_exists,[Exists.intro]]
[Lean.Elab.Modifiers.isNonrec,[Lean.Elab.Modifiers.mk, Lean.Elab.RecKind.partial, Lean.Elab.RecKind.default, Bool, Bool.true, Bool.false]]
[String.utf16PosToCodepointPosFrom,[OfNat.ofNat]]
[Lean.PrettyPrinter.Parenthesizer.instCoeArrowParenthesizerArrowParenthesizerParenthesizerParenthesizerAliasValue,[Coe.mk, Lean.Parser.AliasValue.binary]]
[not_and_self_iff,[Iff.intro, False, False.elim]]
[Nat.mul_comm,[Eq, HMul.hMul, rfl, Eq.symm, Nat.mul_zero, Nat.zero_mul, PProd.fst, Nat.succ_mul, Nat.mul_succ]]
[Function.injective.eq_iff,[Iff.intro, congr_arg]]
[Lean.Parser.notFollowedBy,[Lean.Parser.Parser.mk, Lean.Parser.notFollowedByFn, Lean.Parser.Parser.fn]]
[Lean.Import.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.setReducibleAttribute,[Lean.setReducibilityStatus, Lean.ReducibilityStatus.reducible]]
[Lean.Option.mk.inj,[And.intro]]
[EIO.mapTasks,[BaseIO.mapTasks, EIO.toBaseIO]]
[Lean.Meta.resettingSynthInstanceCache,[Lean.Meta.mapMetaM, Bind.bind, Lean.Meta.saveAndResetSynthInstanceCache, tryFinally, Lean.Meta.restoreSynthInstanceCache]]
[Lean.Elab.Term.Quotation.MatchResult.undecided.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Expr.updateLambdaE!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateLambda, Lean.Expr.lam, Lean.Expr.Data.binderInfo, Lean.Expr.updateLambdaE!.proof_1, panicWithPosWithDecl, OfNat.ofNat]]
[ExceptT.instMonadExceptT,[Monad.mk]]
[Lean.Elab.Term.Do.Code.below,[PProd, PUnit]]
[Lean.term_Matches_,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.instInhabitedMessageSeverity,[Inhabited.mk, Lean.MessageSeverity.information]]
[Std.RBNode.singleton,[Std.RBNode.node, Std.Rbcolor.red, Std.RBNode.leaf]]
[instDivUInt32,[Div.mk, UInt32.div]]
[Std.PersistentHashMap.getCollisionNodeSize,[Nat, Array.size, False.elim, Std.PersistentHashMap.getCollisionNodeSize.proof_2]]
[Lean.Parser.Tactic.tfaeFinish,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Compiler.foldUIntDiv,[Lean.Compiler.foldBinUInt, Div.div]]
[instDecidableEqUSize,[USize.decEq]]
[Lean.Parser.ParserInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Command.accLevelAtCtor,[Lean.Level.succ, Nat.zero, Lean.Level.param, Lean.Level.mvar, Lean.Elab.Term.TermElabM, Array, Lean.Level, Bind.bind, PProd.fst, PProd.snd, Pure.pure, ite, Eq, and, BEq.beq, OfNat.ofNat, Bool.true, Lean.Level.occurs, Lean.throwError, Lean.ToMessageData.toMessageData, GT.gt, Array.contains, Array.push]]
[and_comm,[And.comm]]
[Lean.Elab.Tactic.Conv.evalRhs,[Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Elab.Tactic.Conv.congr, ite, GE.ge, OfNat.ofNat, dite, LT.lt, List.length, ForIn.forIn, Unit.unit, Lean.Elab.Tactic.TacticM, ForInStep, Std.Range, Stream.next?, Pure.pure, ForInStep.done, Eq, bne, Bool.true, Lean.Meta.applyRefl, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, ForInStep.yield, PUnit.unit, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.get, List.nil, HSub.hSub, Int.ofNat]]
[Lean.MessageData.ibelow,[True, And]]
[Lean.Meta.DiscrTree.getMatch,[Lean.Meta.withReducible, Bind.bind, ite, Eq, Bool.true, Lean.Expr.bvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.mdata, Lean.Meta.MetaM, Prod, Lean.Meta.DiscrTree.Key, Array, Lean.Expr, Lean.Expr.getAppFn, Pure.pure, Prod.mk, Lean.Meta.DiscrTree.Key.lit, List.toArray, List.nil, Lean.Meta.DiscrTree.Key.const, Lean.Expr.getAppRevArgs, Lean.Meta.DiscrTree.Key.fvar, Lean.Meta.DiscrTree.Key.other, MonadReader.read, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Context.config, Lean.Meta.DiscrTree.Key.star, Lean.Meta.isReadOnlyOrSyntheticOpaqueExprMVar, Lean.Meta.DiscrTree.Key.proj, List.cons, Lean.Expr.hasLooseBVars, Lean.Meta.DiscrTree.Key.arrow, Unit.unit, Std.PersistentHashMap.find?, Lean.Meta.DiscrTree.root]]
[Lean.Elab.Command.StructFieldInfo.isSubobject,[Lean.Elab.Command.StructFieldKind.newField, Lean.Elab.Command.StructFieldKind.copiedField, Lean.Elab.Command.StructFieldKind.fromParent, Unit.unit, Bool, Lean.Elab.Command.StructFieldInfo.kind, Bool.true, Bool.false]]
[Fin.mulOverflows?,[Decidable.decide, LE.le, HMul.hMul, Fin.val]]
[Lean.Parser.Term.liftMethod,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.minPrec, HAndThen.hAndThen, Lean.Parser.Term.leftArrow, Lean.Parser.termParser, OfNat.ofNat]]
[Lean.Syntax.isFieldIdx?,[Option.none, Option, Nat, Lean.Syntax.isLit?, Lean.Syntax.decodeNatLitVal?, Lean.fieldIdxKind]]
[UInt32.instSemiringUInt32.proof_6,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, HMul.hMul, UInt32.zero_def, UInt32.mul_def, UInt32.mk, OfNat.ofNat, MonoidWithZero.mul_zero, UInt32.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt32]]
[Lean.Lsp.RpcCallParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.RpcCallParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Command.CtorView.mk.inj,[And.intro]]
[ReaderT.instMonadFunctorReaderT,[MonadFunctor.mk]]
[Lean.PrettyPrinter.Delaborator.annotatePos,[Lean.Syntax.setInfo, Lean.SourceInfo.synthetic]]
[MProd.noConfusionType,[]]
[Lean.Parser.Term.set_option.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.ppSpace.formatter, Lean.Parser.Command.optionValue.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Lean.Elab.Term.withFreshMacroScope,[Bind.bind, modifyGetThe, Lean.Core.State, Prod.mk, Lean.Core.State.nextMacroScope, Lean.Core.State.mk, Lean.Core.State.env, HAdd.hAdd, OfNat.ofNat, Lean.Core.State.ngen, Lean.Core.State.traceState, MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.Context.declName?, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.mayPostpone, Lean.Elab.Term.Context.errToSorry, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.Term.Context.autoBoundImplicits, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection]]
[Lean.Meta.CheckAssignment.Context.fvars,[]]
[ne_eq,[rfl]]
[Lean.HeadIndex.fvar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Std.Format.text.injEq,[Eq.propIntro, Eq.refl, Std.Format.text, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Parenthesizer.interpolatedStr.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.PrettyPrinter.Parenthesizer.visitArgs, Array.forM, Array.reverse, Lean.Syntax.getArgs, OfNat.ofNat, Array.size]]
[instReprSSet,[Repr.mk, Repr.addAppParen, HAppend.hAppend, reprArg, Lean.SSet.toList, Std.Format.text]]
[Lean.Parser.Term.funBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.funStrictImplicitBinder.parenthesizer, Lean.Parser.Term.funImplicitBinder.parenthesizer, Lean.Parser.Term.instBinder.parenthesizer, Lean.Parser.Term.funSimpleBinder.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec]]
[Lean.Elab.Term.SyntheticMVarKind.postponed.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.SyntheticMVarKind.postponed, Eq.symm, eq_of_heq, HEq.refl]]
[Subtype.instHasEquivSubtype,[HasEquiv.mk, HasEquiv.Equiv, Subtype.val]]
[Lean.Elab.Term.StructInst.expandStructInstFieldAbbrev,[ite, Eq, Array.any, Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Array.size, Bool.true, Bind.bind, Array.mapM, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, List.nil, Lean.Syntax.atom, Lean.Syntax.setArg, Lean.mkNullNode, Lean.Macro.throwUnsupported]]
[heq_of_eq_of_heq,[HEq.trans, heq_of_eq]]
[Lean.Elab.Command.ElabHeaderResult.mk.inj,[And.intro]]
[Lean.Elab.Command.instMonadEnvCommandElabM,[Lean.MonadEnv.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Command.State.env, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState]]
[Lean.Meta.ToHide.unmark,[modify, Lean.Meta.ToHide.State.mk, Std.RBTree.erase, Lean.Meta.ToHide.State.hiddenInaccessibleProp, Lean.Meta.ToHide.State.hiddenInaccessible, Bool.true]]
[Lean.Meta.SynthInstance.step,[Bind.bind, Lean.Meta.SynthInstance.checkMaxHeartbeats, MonadState.get, ite, Eq, not, Array.isEmpty, Lean.Meta.SynthInstance.State.resumeStack, Bool.true, Lean.Meta.SynthInstance.resume, Pure.pure, Lean.Meta.SynthInstance.State.generatorStack, Lean.Meta.SynthInstance.generate, Bool.false]]
[Array.filterMapM,[Array.foldlM, Bind.bind, Unit.unit, Array, Pure.pure, Array.push, List.toArray, List.nil]]
[Lean.Meta.DiscrTree.Key.noConfusionType,[]]
[Lean.IR.FnBody.isTerminal,[Lean.IR.FnBody.vdecl, Lean.IR.FnBody.jdecl, Lean.IR.FnBody.set, Lean.IR.FnBody.setTag, Lean.IR.FnBody.uset, Lean.IR.FnBody.sset, Lean.IR.FnBody.inc, Lean.IR.FnBody.dec, Lean.IR.FnBody.del, Lean.IR.FnBody.mdata, Unit.unit, Bool, Bool.true, Bool.false]]
[Std.PersistentArray.initShift,[OfNat.ofNat]]
[Lean.IR.Decl.fdecl.inj,[And.intro]]
[Lean.PrettyPrinter.Parenthesizer.checkStackTop.parenthesizer,[Pure.pure, Unit.unit]]
[Lean.Lsp.ServerCapabilities.documentSymbolProvider,[]]
[Lean.IR.Borrow.ParamMap.Key.jp.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[StateT.tryFinally,[MonadFinally.mk, Bind.bind, MonadFinally.tryFinally', Unit.unit, Prod, Option.some, Option.none, Pure.pure, Prod.mk]]
[Lean.Lsp.WorkDoneProgressEnd.mk.inj,[And.intro]]
[Lean.instCoeStringName,[Coe.mk, Lean.Name.mkSimple]]
[Char.utf8Size.proof_3,[of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Name.sizeOf,[Unit.unit, Nat, OfNat.ofNat, HAdd.hAdd, PProd.fst, SizeOf.sizeOf]]
[Lean.Parser.setLhsPrecFn,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Parser.ParserState.mk, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.pos, Lean.Parser.ParserState.cache, Lean.Parser.ParserState.errorMsg]]
[Lean.Syntax.Traverser.fromSyntax,[Lean.Syntax.Traverser.mk, List.toArray, List.nil]]
[IO.FS.instLESystemTime,[leOfOrd]]
[Lean.Elab.Term.setMessageLog,[modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState]]
[Lean.NameGenerator.curr,[Lean.Name.mkNum, Lean.NameGenerator.namePrefix, Lean.NameGenerator.idx]]
[Std.Rbcolor.noConfusionType,[noConfusionTypeEnum, Std.Rbcolor.toCtorIdx]]
[Lean.MonadTrace.noConfusionType,[]]
[Std.RBNode.ins,[Std.RBNode, Std.RBNode.node, Std.Rbcolor.red, Std.RBNode.leaf, Unit.unit, PProd.fst, PProd.snd, ite, Eq, Std.RBNode.isRed, Bool.true, Std.RBNode.balance1, Std.Rbcolor.black, Std.RBNode.balance2]]
[instDecidableEqSum.proof_2,[absurd]]
[Lean.Expr.isBinding,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[Lean.Elab.Term.LetRecToLift.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LetRecToLift.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.elabAnonymousCtor,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Term.tryPostponeIfNoneOrMVar, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, liftM, Lean.Meta.whnf, Lean.matchConstInduct, Lean.Expr.getAppFn, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, List.nil, List.cons, Lean.InductiveVal.ctors, Lean.getConstInfoCtor, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, ForIn.forIn, Lean.Meta.getFVarLocalDecl, Array.getOp, Lean.BinderInfo.isExplicit, Lean.LocalDecl.binderInfo, Pure.pure, PUnit.unit, ForInStep.yield, LT.lt, Array.size, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Elab.Tactic.Conv.remarkAsConvGoal,[Bind.bind, Lean.Elab.Tactic.getUnsolvedGoals, List.mapM, Lean.Meta.withMVarContext, liftM, Lean.Meta.getMVarType, Lean.Meta.matchEq?, Option.none, Lean.Elab.Tactic.TacticM, Lean.MVarId, ite, Eq, Lean.Expr.isMVar, Lean.Expr.getAppFn, Bool.true, Lean.Meta.replaceTargetDefEq, Lean.mkLHSGoal, Pure.pure, Lean.Elab.Tactic.setGoals]]
[Lean.compileDecl,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, Lean.KernelException.unknownConstant, Lean.KernelException.alreadyDeclared, Lean.KernelException.declTypeMismatch, Lean.KernelException.declHasMVars, Lean.KernelException.declHasFVars, Lean.KernelException.funExpected, Lean.KernelException.typeExpected, Lean.KernelException.letTypeMismatch, Lean.KernelException.exprTypeMismatch, Lean.KernelException.appTypeMismatch, Lean.KernelException.invalidProj, Unit, Lean.Environment.compileDecl, Lean.setEnv, Lean.Declaration.forExprM, Option.none, Option.some, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, Unit.unit, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.throwKernelException]]
[List.mem_append_right,[Iff.mpr, List.mem_append, Or.inr]]
[Lean.IR.Checker.checkEqTypes,[ite, Eq, BEq.beq, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw]]
[Lean.Elab.Deriving.BEq.mkMatch.mkElseAlt,[Bind.bind, ForIn.forIn, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, PUnit.unit, ForInStep.yield, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom]]
[Subarray.stop,[]]
[Lean.Meta.CheckAssignment.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.basicFun,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.many1, Lean.Parser.ppSpace, Lean.Parser.Term.funBinder, Lean.Parser.darrow, Lean.Parser.termParser, OfNat.ofNat, Bool.false]]
[Lean.MonadFileMap.getFileMap,[]]
[UInt32.toUSize,[Nat.toUSize, UInt32.toNat]]
[instInhabitedSubstring,[Inhabited.mk, Substring.mk, OfNat.ofNat]]
[Lean.Meta.mkLe,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil]]
[IO.FS.Stream.Buffer.mk.inj,[And.intro]]
[Lean.PrettyPrinter.Parenthesizer.nameLitNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken]]
[Nat.gcd_dvd_gcd_mul_left,[Nat.gcd_dvd_gcd_of_dvd_left, Nat.dvd_mul_left]]
[Lean.Compiler.InlineAttributeKind.toCtorIdx,[OfNat.ofNat]]
[Lean.PrettyPrinter.Parenthesizer.State.contPrec,[]]
[Lean.instInhabitedOccurrences,[Inhabited.mk, Lean.Occurrences.all]]
[Lean.IR.Expr.fap.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.registerStructure,[Lean.PersistentEnvExtension.addEntry, Lean.structureExt, Lean.StructureInfo.mk, Lean.StructureDescr.structName, Array.map, Lean.StructureFieldInfo.fieldName, Lean.StructureDescr.fields, Array.qsort, Lean.StructureFieldInfo.lt, OfNat.ofNat, HSub.hSub, Array.size]]
[Lean.Lsp.TextDocumentContentChangeEvent.fullChange.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.Do.Alt.mk.inj,[And.intro]]
[Lean.Meta.Match.AltLHS.ref,[]]
[Lean.Elab.elabAttr,[Bind.bind, Lean.Elab.liftMacroM, Lean.Elab.toAttributeKind, Lean.Syntax.getOp, OfNat.ofNat, Lean.expandMacros, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Lean.Name.eraseMacroScopes, Lean.Syntax.getId, Lean.Name.num, Lean.Elab.Attribute, Lean.Name.mkSimple, Lean.throwErrorAt, Lean.ToMessageData.toMessageData]]
[Lean.Meta.Simp.mkCongr,[Unit.unit, Lean.Meta.MetaM, Lean.Meta.Simp.Result, Lean.Meta.Simp.Result.proof?, Pure.pure, Lean.Meta.Simp.Result.mk, Option.none, Bind.bind, Lean.Meta.mkCongrFun, Lean.Meta.Simp.Result.expr, Option.some, Lean.Meta.mkCongrArg, Lean.Meta.mkCongr]]
[Lean.Lsp.TextDocumentChangeRegistrationOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Tactic.AuxMatchTermState.cases,[]]
[Lean.IR.ExplicitBoxing.requiresBoxedVersion,[or, and, Decidable.decide, GT.gt, Array.size, OfNat.ofNat, Lean.IR.IRType.isScalar, Lean.IR.Decl.resultType, Array.any, Lean.IR.Param.ty, Lean.IR.Param.borrow, Lean.isExtern, Lean.IR.Decl.name, Lean.closureMaxArgs]]
[List.erase_cons,[Classical.em, Eq, of_eq_true, Eq.trans, congr, congrArg, congrFun, Unit.unit, List, Iff.mp, EqIffBeqTrue, Eq.symm, List.cons, List.erase, if_pos, eq_self, NeqIffBeqFalse, Ne.symm, if_neg, Eq.refl]]
[Lean.Level.isNeverZero,[Bool, Bool.false, Bool.true, or, PProd.fst, PProd.snd]]
[UInt8.instSemiringUInt8.proof_12,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HMul.hMul, UInt8.add_def, UInt8.mul_def, UInt8.mk, HAdd.hAdd, UInt8.val, UInt8.eq_of_val_eq, Semiring.add_mul]]
[Lean.Meta.AbstractMVars.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.AbstractMVars.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Modifiers.docString?,[]]
[Equiv.symm,[Equiv.mk, Equiv.invFun, Equiv.toFun, Equiv.rightInv, Equiv.leftInv]]
[IO.withStdout,[Bind.bind, liftM, IO.setStdout, tryFinally, Functor.discard]]
[Lean.Server.FileWorker.RpcSession.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.FileWorker.RpcSession.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.HeadIndex.lam.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer,[Bind.bind, modify, Lean.PrettyPrinter.Parenthesizer.State.mk, Lean.PrettyPrinter.Parenthesizer.State.stxTrav, Option.none, Lean.PrettyPrinter.Parenthesizer.State.contCat, Lean.PrettyPrinter.Parenthesizer.State.minPrec, Lean.PrettyPrinter.Parenthesizer.State.trailPrec, Lean.PrettyPrinter.Parenthesizer.State.trailCat, Lean.PrettyPrinter.Parenthesizer.State.visitedToken]]
[Int.ofNat_mul_ofNat,[rfl]]
[Lean.Parser.Command.structureTk.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.Server.RequestM.asTask,[Bind.bind, liftM, EIO.asTask, Task.Priority.default, Pure.pure, Task.map, liftExcept]]
[UInt64.xor,[UInt64.mk, Fin.xor, UInt64.val]]
[Std.ToFormat.format,[]]
[Lean.Parser.Tactic.rfl',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Lsp.TextDocumentRegistrationOptions.mk.inj,[]]
[Xor.xor,[]]
[Lean.Parser.mkParserState,[Lean.Parser.ParserState.mk, Lean.Parser.initCacheForInput]]
[termMax_prec,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Lean.SMap.fold,[Std.PersistentHashMap.foldl, Lean.SMap.map₂, Std.HashMap.fold, Lean.SMap.map₁]]
[instToStringOption,[ToString.mk, Unit.unit, String, HAppend.hAppend, addParenHeuristic, ToString.toString]]
[Lean.Parser.Term.app.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.leadPrec, Lean.Parser.maxPrec, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.argument.parenthesizer]]
[Lean.Meta.CheckAssignment.Context.mvarId,[]]
[Lean.Parser.Command.terminationHint1.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat]]
[List.exists_of_mem_map,[Exists, And, Mem.mem, List.nil, Eq, Eq.refl, List.eq_or_mem_of_mem_cons, Exists.intro, And.intro, List.mem_cons_self, Eq.symm, List.cons, List.mem_cons_of_mem]]
[Lean.Parser.ppGroup.parenthesizer,[]]
[Lean.Json.num.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.universe,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.ident]]
[le_iff_lt_or_eq,[Decidable.le_iff_lt_or_eq]]
[Lean.MetavarContext.LevelMVarToParam.State.noConfusionType,[]]
[Lean.PrettyPrinter.Formatter.indent,[Bind.bind, Lean.PrettyPrinter.Formatter.concat, MonadReader.read, modify, Lean.PrettyPrinter.Formatter.State.mk, Lean.PrettyPrinter.Formatter.State.stxTrav, Lean.PrettyPrinter.Formatter.State.leadWord, Array.modify, Lean.PrettyPrinter.Formatter.State.stack, HSub.hSub, Array.size, OfNat.ofNat, Std.Format.nest]]
[UInt8.val_eq_of_lt,[Fin.val_eq_of_lt]]
[Lean.Elab.Command.elabExport,[Bind.bind, Lean.resolveNamespace, Lean.MonadResolveName.getCurrNamespace, ite, Eq, BEq.beq, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Array.indexOf?,[Array.indexOfAux, OfNat.ofNat]]
[Lean.QuotKind.type.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.Closure.visitExpr,[ite, Eq, and, not, Lean.Expr.hasLevelParam, Lean.Expr.hasFVar, Lean.Expr.hasMVar, Bool.true, Pure.pure, Bind.bind, MonadState.get, Unit.unit, Lean.Meta.Closure.ClosureM, Lean.Expr, Std.HashMap.find?, Lean.Meta.Closure.State.visitedExpr, Lean.ExprStructEq.mk, modify, Lean.Meta.Closure.State.mk, Lean.Meta.Closure.State.visitedLevel, Std.HashMap.insert, Lean.Meta.Closure.State.levelParams, Lean.Meta.Closure.State.nextLevelIdx, Lean.Meta.Closure.State.levelArgs, Lean.Meta.Closure.State.newLocalDecls, Lean.Meta.Closure.State.newLocalDeclsForMVars, Lean.Meta.Closure.State.newLetDecls, Lean.Meta.Closure.State.nextExprIdx, Lean.Meta.Closure.State.exprMVarArgs, Lean.Meta.Closure.State.exprFVarArgs, Lean.Meta.Closure.State.toProcess]]
[Iff.refl,[Iff.intro]]
[Lean.KeyedDeclsAttribute.ExtensionState.noConfusionType,[]]
[of_heq_true,[of_eq_true, eq_of_heq]]
[Nat.gcd_le_right,[Nat.le_of_dvd, Nat.gcd_dvd_right]]
[Lean.Parser.Tactic.clean,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Semiring.add_zero,[]]
[Char.utf8Size.proof_6,[of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Elab.Term.elabOpen,[tryFinally, Bind.bind, Lean.pushScope, Lean.Elab.OpenDecl.elabOpenDecl, Lean.Syntax.getOp, OfNat.ofNat, withTheReader, Lean.Core.Context, Lean.Core.Context.mk, Lean.Core.Context.options, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats, Lean.Elab.Term.elabTerm, Bool.true, Lean.popScope]]
[Lean.Meta.SimpLemmas.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[ReaderT.map,[Functor.map]]
[Std.PersistentHashMap.stats,[Std.PersistentHashMap.collectStats, Std.PersistentHashMap.root, Std.PersistentHashMap.Stats.mk, OfNat.ofNat]]
[Lean.Lsp.TextEdit.newText,[]]
[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, bne, Lean.Syntax.getKind, Bool.true, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.Syntax.ident.inj,[And.intro]]
[Lean.MetavarContext.isDelayedAssigned,[Std.PersistentHashMap.contains, Lean.MetavarContext.dAssignment]]
[Tactic.Ring.HornerExpr.reflConv,[Bind.bind, liftM, Lean.Meta.mkEqRefl, Tactic.Ring.HornerExpr.e, Pure.pure, Prod.mk]]
[Lean.Meta.CongrLemmas.noConfusionType,[]]
[Functor.map_equiv_symm_apply,[rfl]]
[Lean.MetavarContext.getExprAssignment?,[Std.PersistentHashMap.find?, Lean.MetavarContext.eAssignment]]
[FloatArray.instInhabitedFloatArray,[Inhabited.mk, FloatArray.empty]]
[Lean.InternalExceptionId.mk.inj,[]]
[Lean.RecursorRule.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.initRing,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.SynthInstance.GeneratorNode.mvar,[]]
[Lean.IR.collectLiveVars,[Lean.IR.LiveVars.collectFnBody]]
[Lean.Elab.Tactic.instMonadExceptExceptionTacticM,[MonadExcept.mk, MonadExcept.throw, Lean.Elab.Tactic.tryCatch]]
[Lean.enableTracing,[Bind.bind, Lean.MonadTrace.getTraceState, Lean.MonadTrace.modifyTraceState, Lean.TraceState.mk, Lean.TraceState.traces, Pure.pure]]
[Lean.Elab.Term.BinOp.elabBinOpLazy,[Lean.Elab.Term.BinOp.elabBinOp]]
[Lean.Parser.FirstTokens.tokens.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Int.add_left_cancel,[]]
[Lean.Meta.replaceLocalDecl.findMaxFVar,[Lean.Expr.forEach', ite, Eq, Lean.Expr.isFVar, Bool.true, Bind.bind, liftM, Lean.Meta.getLocalDecl, Lean.Expr.fvarId!, modify, GT.gt, Lean.LocalDecl.index, Pure.pure, Bool.false, Lean.Expr.hasFVar]]
[Lean.Meta.SimpLemmas.isLemma,[Std.PersistentHashSet.contains, Lean.Meta.SimpLemmas.lemmaNames]]
[Lean.Parser.unicodeSymbolNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.unicodeSymbolInfo, Lean.Parser.unicodeSymbolFn]]
[Lean.instInhabitedNameGenerator,[Inhabited.mk, Lean.NameGenerator.mk, arbitrary]]
[Prod.map_mk,[rfl]]
[Lean.Parser.Term.syntheticHole.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.Term.hole.parenthesizer]]
[Lean.Meta.lambdaTelescope,[Lean.Meta.map2MetaM, Bind.bind, Lean.MonadLCtx.getLCtx, List.toArray, List.nil, OfNat.ofNat, Bool.false]]
[Lean.Name.ibelow,[True, And]]
[Lean.Parser.Term.borrowed.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.leadPrec]]
[Lean.Parser.Term.doIfLetBind,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser]]
[MonadControlT.liftWith,[]]
[Lean.IR.LogEntry.step.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.LogEntry.step, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Macro.resolveGlobalName,[Bind.bind, Lean.Macro.getMethods, Lean.Macro.Methods.resolveGlobalName]]
[Lean.Meta.withPPInaccessibleNames,[Lean.Meta.mapMetaM, Lean.Meta.withPPInaccessibleNamesImp]]
[Or.elim3,[Or.elim]]
[Lean.Elab.Command.elabStructure,[Bind.bind, Lean.Elab.Command.checkValidInductiveModifier, Lean.Elab.getOptDerivingClasses, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, Lean.Syntax.isNone, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Lean.Parser.Term.letrec.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.group.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.Term.letRecDecls.formatter, Lean.Parser.Term.optSemicolon.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Lean.Server.toFileUri,[HAppend.hAppend, String.dropWhile, BEq.beq, Char.ofNat]]
[Lean.EnvExtensionInterface.ensureExtensionsSize,[]]
[Lean.MetavarContext.LevelMVarToParam.State.nextParamIdx,[]]
[Lean.OpenDecl.explicit.inj,[And.intro]]
[Lean.Elab.Term.State.mk.inj,[And.intro]]
[Lean.instInhabitedEnvExtensionState,[Inhabited.mk, PointedType.val, Lean.EnvExtensionStateSpec]]
[Mathlib.Tactic.Lint.isSimpLemma,[Bind.bind, liftM, Lean.Meta.getSimpLemmas, Pure.pure, Std.PersistentHashSet.contains, Lean.Meta.SimpLemmas.lemmaNames]]
[Fin.mod_def,[Eq, HMod.hMod, Fin.mk, Fin.val, Nat.mod_lt, Fin.size_positive, rfl]]
[Nat.div_div_eq_div_mul,[Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, OfNat.ofNat, Nat.mul_zero, Nat.div_zero, rfl, Eq.symm, Nat.zero_mul, Nat.zero_div, Nat.le_antisymm, Iff.mpr, Nat.le_div_iff_mul_le, Nat.mul_pos, LE.le, Nat.mul_comm, Nat.mul_assoc, Iff.mp, Nat.le_refl]]
[Eq.mpr,[Eq.symm]]
[Lean.MessageData.ofLevel.injEq,[Eq.propIntro, Eq.refl, Lean.MessageData.ofLevel, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.set!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.OpenDecl.simple.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.OpenDecl.simple, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Parenthesizer.parenthesizerForKindUnsafe,[ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Unit.unit, Bind.bind, liftM, Lean.PrettyPrinter.runForNodeKind, Lean.PrettyPrinter.parenthesizerAttribute, Lean.PrettyPrinter.Parenthesizer.interpretParserDescr']]
[Lean.Level.PP.Result.num.inj,[]]
[instToStringNat,[ToString.mk, Nat.repr]]
[instSemiringFin.proof_7,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.mul_def, Fin.mk, HMod.hMod, OfNat.ofNat, Nat.mod_lt, Fin.size_positive, congrFun, HMul.hMul, Nat.zero_mod, MonoidWithZero.zero_mul, Fin.zero_def, eq_true_of_decide, Eq.refl, Bool.true]]
[Lean.IR.CompilerState.env,[]]
[Lean.Server.FileWorker.handleSemanticTokensRange,[Bind.bind, Lean.Server.RequestM.readDoc, Lean.Server.FileWorker.handleSemanticTokens]]
[Lean.Compiler.atMostOnce.AtMostOnceData.found,[]]
[Lean.Elab.Tactic.ElimApp.State.targetPos,[]]
[Lean.Meta.NormNum.isNat_mul,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, OfNat.ofNat, Lean.Meta.NormNum.isNat, HMul.hMul, ofNat_mul]]
[Lean.Parser.Term.structInstField.formatter,[Lean.ppGroup.formatter, Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.structInstLVal.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter]]
[not_not_of_not_imp,[mt, Not.elim]]
[Lean.Parser.Term.explicit.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec]]
[Lean.Server.FileWorker.handleSemanticTokens.highlightKeyword,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, ReaderT, Lean.Server.FileWorker.SemanticTokensContext, StateT, Lean.Server.FileWorker.SemanticTokensState, Lean.Server.RequestM, PUnit, ite, Eq, and, Decidable.decide, GT.gt, String.bsize, OfNat.ofNat, Char.isAlpha, String.getOp, Bool.true, Lean.Server.FileWorker.handleSemanticTokens.addToken, Lean.Lsp.SemanticTokenType.keyword, Pure.pure, PUnit.unit]]
[Lean.Parser.FirstTokens.unknown.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Server.Snapshots.compileNextCmd.withNewInteractiveDiags,[Bind.bind, ForIn.forIn, Lean.Widget.msgToInteractiveDiagnostic, Pure.pure, PUnit.unit, ForInStep.yield]]
[Lean.PrettyPrinter.Delaborator.getParamKinds,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, MonadExcept.tryCatch, Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.all, Lean.Expr.getAppFn, Lean.Expr.getAppArgs, Array.mapM, liftM, Lean.Meta.getLocalDecl, Lean.Expr.fvarId!, Pure.pure, Lean.PrettyPrinter.Delaborator.ParamKind.mk, Lean.LocalDecl.userName, Lean.LocalDecl.binderInfo, Lean.Expr.getOptParamDefault?, Lean.LocalDecl.type, Lean.Expr.isAutoParam, List.toArray, List.nil, Lean.PrettyPrinter.Delaborator.getParamKinds.forallTelescopeArgs]]
[Lean.ParametricAttribute.ext,[]]
[Lean.Lsp.RpcReleaseParams.refs,[]]
[Lean.Lsp.instToJsonDeclarationParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.DeclarationParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position]]
[Lean.Meta.SortLocalDecls.M,[ReaderT, Lean.Meta.SortLocalDecls.Context, StateRefT', IO.RealWorld, Lean.Meta.SortLocalDecls.State, Lean.Meta.MetaM]]
[Lean.Widget.TaggedText.instMonadPrettyFormatStateMTaggedState,[Std.Format.MonadPrettyFormat.mk, modify, Lean.Widget.TaggedText.appendText, HAdd.hAdd, String.length, String.pushn, Char.ofNat, Bind.bind, MonadState.get, Pure.pure, Lean.Widget.TaggedText.text, List.cons, Prod.mk]]
[Lean.Elab.Term.instInhabitedMVarErrorInfo,[Inhabited.mk, Lean.Elab.Term.MVarErrorInfo.mk, arbitrary]]
[Lean.IR.modifyJPs,[Array.map, Lean.IR.FnBody.vdecl, Lean.IR.FnBody.set, Lean.IR.FnBody.setTag, Lean.IR.FnBody.uset, Lean.IR.FnBody.sset, Lean.IR.FnBody.inc, Lean.IR.FnBody.dec, Lean.IR.FnBody.del, Lean.IR.FnBody.mdata, Lean.IR.FnBody.case, Lean.IR.FnBody.ret, Lean.IR.FnBody.jmp, Lean.IR.FnBody.unreachable, Lean.IR.FnBody, Lean.IR.FnBody.jdecl]]
[instToStringByteArray,[ToString.mk, List.toString, ByteArray.toList]]
[Lean.Meta.SizeOfSpecNested.throwUnexpected,[Bind.bind, MonadReader.read, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.SizeOfSpecNested.Context.ctorName]]
[Lean.Meta.mkFreshExprMVarAt,[Bind.bind, Lean.mkFreshMVarId, Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.addExprMVarDecl, Pure.pure, Lean.mkMVar]]
[Lean.Parser.Command.init_quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.PPFns.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.SynthInstance.getEntry,[Bind.bind, Lean.Meta.SynthInstance.findEntry?, Unit.unit, Lean.Meta.SynthInstance.SynthM, Lean.Meta.SynthInstance.TableEntry, panicWithPosWithDecl, OfNat.ofNat, Pure.pure]]
[Lean.Environment.getProjectionStructureName?,[Unit.unit, Option, Lean.Name, Lean.Environment.getProjectionFnInfo?, Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo, Lean.Environment.find?, Lean.ProjectionFunctionInfo.ctorName, Lean.ConstructorVal.induct]]
[Lean.AttributeApplicationTime.noConfusion,[noConfusionEnum, Lean.AttributeApplicationTime.toCtorIdx]]
[dbgSleep,[Unit.unit]]
[PSigma.eta,[rfl]]
[String.singleton,[String.push]]
[Lean.Elab.Term.addDotCompletionInfo,[Bind.bind, Lean.MonadLCtx.getLCtx, Lean.Elab.addCompletionInfo, Lean.Elab.CompletionInfo.dot, Lean.Elab.TermInfo.mk, Lean.Elab.ElabInfo.mk, Lean.Name.anonymous]]
[Lean.Expr.FindImpl.visited.proof_1,[lcProof]]
[Lean.TransformStep.done.injEq,[Eq.propIntro, Eq.refl, Lean.TransformStep.done, Eq.symm, eq_of_heq, HEq.refl]]
[instCommMonoid_1.proof_4,[Semiring.npow_succ']]
[Lean.LocalDecl.cdecl.inj,[And.intro]]
[Lean.Parser.ParserExtension.Entry.token.inj,[]]
[StateT.run,[]]
[instDecidableEqString,[String.decEq]]
[List.decidableBall.proof_4,[Iff.mp, List.mem_cons, Eq.symm]]
[Lean.Lsp.PlainTermGoal.range,[]]
[Lean.SMap.find?,[Option, Std.HashMap.find?, Option.orElse, Std.PersistentHashMap.find?]]
[Lean.Parser.notFollowedByFn,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Parser.ParserState.restore, Lean.Parser.ParserState.mkUnexpectedError, HAppend.hAppend, ToString.toString, List.nil]]
[Lean.Name.modifyBase,[ite, Eq, Lean.Name.hasMacroScopes, Bool.true, Lean.MacroScopesView.review, Lean.MacroScopesView.mk, Lean.MacroScopesView.name, Lean.MacroScopesView.imported, Lean.MacroScopesView.mainModule, Lean.MacroScopesView.scopes]]
[Function.injective_of_subsingleton,[Subsingleton.elim]]
[IO.Process.SpawnArgs.cmd,[]]
[Function.injective.of_comp_iff',[Iff.intro, Eq, rfl, Function.injective.comp, Function.bijective.injective]]
[Lean.Lsp.instFileSourceRpcKeepAliveParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.RpcKeepAliveParams.uri]]
[List.leftpad_prefix,[Exists.intro, rfl]]
[Lean.Parser.CategoryParserFn,[Lean.Parser.ParserFn]]
[CoeDep.coe,[]]
[Nat.add_lt_add,[Nat.lt_trans, Nat.add_lt_add_right, Nat.add_lt_add_left]]
[Lean.Meta.AuxLemmas.idx,[]]
[Lean.Lsp.DocumentSymbol.mk.inj,[]]
[Lean.Meta.IndPredBelow.mkContext.mkHeader,[Bind.bind, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.InductiveVal.toConstantVal, Lean.Meta.mkArrow, Lean.mkAppN, Lean.Meta.IndPredBelow.mkContext.mkIndValConst, Lean.Meta.withNewBinderInfos, Array.map, Prod.mk, Lean.Expr.fvarId!, Lean.BinderInfo.implicit, Lean.Meta.mkForallFVars, Bool.false, Bool.true, Lean.Meta.IndPredBelow.mkContext.addMotives]]
[Classical.propComplete,[Or, Eq, True, False, Classical.em, Or.inl, propext, Iff.intro, True.intro, Or.inr, False.elim]]
[Lean.Meta.Simp.simp.simpLit,[Unit.unit, Lean.Meta.Simp.M, Lean.Meta.Simp.Result, Lean.Expr.natLit?, Bind.bind, Lean.Meta.Simp.getSimpLemmas, ite, Eq, Lean.Meta.SimpLemmas.isDeclToUnfold, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Lean.Meta.Simp.Result.mk, liftM, Lean.Meta.mkNumeral, Lean.mkConst, List.nil]]
[Lean.MetavarContext.MkBinding.preserveOrder,[MonadReader.read]]
[Lean.Elab.logUnknownDecl,[Lean.Elab.logError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.Meta.Match.MatcherInfo.getMotivePos,[Lean.Meta.Match.MatcherInfo.numParams]]
[Lean.Parser.Parser.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.Parser.mk, Eq.symm, eq_of_heq, HEq.refl]]
[IO.Error.mkInvalidArgument,[IO.Error.invalidArgument, Option.none]]
[Lean.ClassState.mk.injEq,[Eq.propIntro, Eq.refl, Lean.ClassState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[USize.instSemiringUSize.proof_6,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, HMul.hMul, USize.zero_def, USize.mul_def, USize.mk, OfNat.ofNat, MonoidWithZero.mul_zero, USize.val, eq_self, propext, forall_const, USize]]
[Std.Format.getUnicode,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Std.Format.defUnicode]]
[IO.FS.Handle.mk,[IO.FS.Handle.mkPrim, HAppend.hAppend]]
[Lean.Elab.Term.StructInst.defaultMissing?,[Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous]]
[Subtype.refl,[Setoid.refl, Subtype.val]]
[UInt16.decEq,[Decidable, Eq, dite, Decidable.isTrue, UInt16.decEq.proof_1, Decidable.isFalse, UInt16.decEq.proof_2]]
[Lean.isExport,[or, Option.isSome, Lean.getExportNameFor, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Meta.Rewrite.Config.offsetCnstrs,[]]
[Lean.Elab.Term.mkNoImplicitLambdaAnnotation,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Lsp.instFromJsonPlainTermGoalParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.PlainTermGoalParams.mk, Lean.Lsp.TextDocumentPositionParams.mk]]
[Lean.Meta.caseArraySizes,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getArrayArgType, Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Lean.Meta.assertExt, Lean.mkConst, Lean.Meta.intro1, Lean.Meta.MetaM, Array, Lean.Meta.CaseArraySizesSubgoal, Lean.Meta.caseValues, Array.map, Lean.mkRawNatLit, Array.mapIdxM, dite, LT.lt, Fin.val, Array.size, Lean.Meta.clear, Array.getOp, Lean.Meta.CaseValuesSubgoal.newHs, OfNat.ofNat, Lean.Expr.fvarId!, Lean.Meta.FVarSubst.get, Lean.Meta.mkEqSymm, Lean.mkFVar, Lean.MVarId, Lean.Meta.getMVarTag, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.assignExprMVar, Lean.mkAppN, Pure.pure, Lean.Expr.mvarId!, Lean.Meta.introN, Bool.false, Lean.Meta.substCore, Bool.true, Lean.Meta.CaseArraySizesSubgoal.mk]]
[StateT.run_map,[of_eq_true, Eq.trans, congrArg, Eq, Bind.bind, Pure.pure, Prod.mk, map_eq_pure_bind, Prod.fst, Prod.snd, eq_self]]
[Lean.Meta.restoreSynthInstanceCache,[Lean.Meta.modifyCache, Lean.Meta.Cache.mk, Lean.Meta.Cache.inferType, Lean.Meta.Cache.funInfo, Lean.Meta.Cache.whnfDefault, Lean.Meta.Cache.whnfAll, Lean.Meta.Cache.defEqDefault, Lean.Meta.Cache.defEqAll]]
[Lean.Parser.Tactic.deriveReassocProof,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Environment.getProjectionFnInfo?,[Lean.MapDeclarationExtension.find?, Lean.projectionFnInfoExt]]
[Lean.KeyedDeclsAttribute.init,[Bind.bind, liftM, IO.mkRef, Lean.SMap.mk, Lean.registerScopedEnvExtension, Lean.ScopedEnvExtension.Descr.mk, Lean.KeyedDeclsAttribute.Def.name, ST.Ref.get, Pure.pure, Lean.KeyedDeclsAttribute.mkStateOfTable, MonadReader.read, Lean.ImportM, Lean.KeyedDeclsAttribute.AttributeEntry, Lean.Environment.evalConstCheck, Lean.ImportM.Context.env, Lean.ImportM.Context.opts, Lean.KeyedDeclsAttribute.Def.valueTypeName, Lean.KeyedDeclsAttribute.OLeanEntry.declName, Lean.KeyedDeclsAttribute.AttributeEntry.mk, MonadExcept.throw, IO.userError, Lean.KeyedDeclsAttribute.AttributeEntry.toOLeanEntry, Lean.KeyedDeclsAttribute.ExtensionState.insert, ite, Eq, Lean.Name.isAnonymous, Lean.KeyedDeclsAttribute.Def.builtinName, Bool.true, PUnit.unit, Lean.registerBuiltinAttribute, Lean.AttributeImpl.mk, Lean.AttributeImplCore.mk, HAppend.hAppend, Lean.KeyedDeclsAttribute.Def.descr, Lean.AttributeApplicationTime.afterCompilation, BEq.beq, Lean.AttributeKind.global, Lean.throwError, Lean.ToMessageData.toMessageData]]
[instNegFloat,[Neg.mk, Float.neg]]
[Lean.Parser.Command.macro.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.suppressInsideQuot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.docComment.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optPrecedence.parenthesizer, Lean.Parser.Command.optNamedName.parenthesizer, Lean.Parser.Command.optNamedPrio.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Command.macroArg.parenthesizer, Lean.Parser.Command.macroTail.parenthesizer]]
[System.Platform.isWindows,[System.Platform.getIsWindows, Unit.unit]]
[«term_∉_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.PrefixTree.forM,[Lean.PrefixTree.forMatchingM, List.nil]]
[OptionT.tryCatch,[OptionT.mk, Bind.bind, Option.none, Option, Pure.pure, Option.some, Unit.unit]]
[plift.up_down,[Eq, plift.up, plift.down, rfl]]
[Lean.Elab.Deriving.mkHeader,[Bind.bind, Lean.Elab.Deriving.mkInductArgNames, Lean.Elab.Deriving.mkImplicitBinders, Lean.Elab.Deriving.mkInductiveApp, ForIn.forIn, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Elab.Deriving.mkInstImplicitBinders, Array.mapM, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Lean.mkIdent, List.nil, Lean.Elab.Deriving.Header.mk]]
[Lean.Parser.Command.structInstBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Command.declModifiers.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.inferMod.parenthesizer, Lean.Parser.Command.declSig.parenthesizer]]
[Lean.Lsp.SymbolKind.object.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Term.PatternElabException.pathToIndex,[]]
[Lean.Quote.noConfusionType,[]]
[«term_>>=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.SynthInstance.mapMetaM,[MonadFunctorT.monadMap]]
[Lean.Elab.Term.Do.mkAuxDeclFor,[Lean.withRef, Lean.MonadQuotation.withFreshMacroScope, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Lean.Elab.Term.Do.Code.decl]]
[eq_min,[le_antisymm, le_min, min, min_le_left, min_le_right]]
[not_iff_self,[iff_not_self, Iff.symm]]
[Lean.IR.UnreachableBranches.findArgValue,[Lean.IR.Arg.irrelevant, Lean.IR.UnreachableBranches.M, Lean.IR.UnreachableBranches.Value, Lean.IR.UnreachableBranches.findVarValue, Pure.pure, Lean.IR.UnreachableBranches.Value.top]]
[Lean.Parser.Command.check.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter]]
[Tactic.Ring.State.noConfusionType,[]]
[Lean.Parser.numLit.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.numLitKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.numLitNoAntiquot.parenthesizer]]
[Lean.Server.routeLspRequest,[Bind.bind, ST.Ref.get, Lean.Server.requestHandlers, Pure.pure, Std.PersistentHashMap.find?, Unit.unit, IO, Except, Lean.Server.RequestError, Lean.Lsp.DocumentUri, Except.error, Lean.Server.RequestError.methodNotFound]]
[Lean.Parser.Term.binderIdent.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.Term.hole.formatter]]
[Lean.IR.UnreachableBranches.InterpContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Attr.macro.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter]]
[Lean.Elab.FieldInfo.lctx,[]]
[StdGen.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.inj_on_of_subset,[]]
[Nat.lcm_zero_left,[]]
[Lean.Elab.Tactic.evalSpecialize,[Lean.Elab.Tactic.withMainContext, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Tactic.elabTermWithHoles, Option.none, Lean.Elab.Tactic.TacticM, Unit, Lean.Expr.isFVar, liftM, Lean.Meta.getLocalDecl, Lean.Expr.fvarId!, Lean.Elab.Tactic.getMainGoal, Lean.Meta.inferType, Lean.Meta.assert, Lean.LocalDecl.userName, Lean.Expr.headBeta, Lean.Meta.intro1P, Lean.Meta.tryClear, Lean.Elab.Tactic.replaceMainGoal, List.cons, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Elab.throwUnsupportedSyntax]]
[Lean.instInhabitedPersistentEnvExtensionState,[Inhabited.mk, Lean.PersistentEnvExtensionState.mk, List.toArray, List.nil, arbitrary]]
[Mathlib.ExtendedBinder.extBinderCollection,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.unary, Mathlib.ExtendedBinder.extBinderParenthesized]]
[Lean.LocalDecl.ldecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Rat.instDecidableLe,[inferInstanceAs, Decidable, Not, LT.lt]]
[Lean.Syntax.getAntiquotTerm,[ite, Eq, Lean.Syntax.isIdent, Bool.true, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Parser.longestMatchFnAux.parse,[Unit.unit, Lean.Parser.ParserFn, Lean.Parser.longestMatchMkResult, Lean.Parser.ParserState, PProd.fst]]
[Lean.Elab.Term.isAtomicDiscr?,[cond, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.Term.isLocalIdent?, ite, Eq, Bool.true, Lean.Syntax.isMissing, Lean.Elab.throwAbortTerm, Pure.pure, Option.none]]
[Lean.Meta.Closure.State.mk.inj,[And.intro]]
[Lean.getBuiltinAttributeApplicationTime,[Bind.bind, Lean.getBuiltinAttributeImpl, Pure.pure, Lean.AttributeImplCore.applicationTime, Lean.AttributeImpl.toAttributeImplCore]]
[USize.decLt,[Decidable, LT.lt, inferInstanceAs]]
[Nat.iterate,[PProd.fst]]
[Std.Format.below,[PUnit, PProd]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.nameNotRoundtrippable,[or, Lean.Name.hasMacroScopes, Lean.isPrivateName, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.nameNotRoundtrippable.containsNum]]
[Lean.Core.CoreM.toIO,[Bind.bind, liftM, IO.getNumHeartbeats, EIO.toIO', Lean.Core.CoreM.run, Lean.Core.Context.mk, Lean.Core.Context.options, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.maxHeartbeats, IO, Prod, Lean.Core.State, Lean.MessageData.toString, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Lean.InternalExceptionId.idx, Pure.pure]]
[Lean.Parsec.ParseResult.noConfusionType,[]]
[Lean.KeyedDeclsAttribute.AttributeEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KeyedDeclsAttribute.AttributeEntry.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.LevelMap,[Std.HashMap, Lean.Level]]
[Lean.PrettyPrinter.Formatter.withoutForbidden.formatter,[]]
[Lean.printTraces,[Bind.bind, Lean.MonadTrace.getTraceState, Std.PersistentArray.forM, Lean.TraceState.traces, liftM, Lean.MessageData.format, Lean.TraceElem.msg, IO.println]]
[Lean.Meta.Match.Alt.rhs,[]]
[Std.HashMap.findD,[Option.getD, Std.HashMap.find?]]
[Lean.LocalInstance.fvar,[]]
[Lean.Meta.addCongrLemmaEntry,[Lean.Meta.CongrLemmas.mk, Unit.unit, Lean.SMap, Lean.Name, List, Lean.Meta.CongrLemma, Lean.SMap.find?, Lean.Meta.CongrLemmas.lemmas, Lean.Meta.CongrLemma.funName, Lean.SMap.insert, List.cons, List.nil, Lean.Meta.addCongrLemmaEntry.insert]]
[Lean.IR.instInhabitedLiveVarSet,[Inhabited.mk, EmptyCollection.emptyCollection]]
[Lean.MetavarContext.getLevelDepth,[Unit.unit, Nat, Lean.MetavarContext.findLevelDepth?, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Lsp.SaveOptions.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.SaveOptions.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.ServerCapabilities.declarationProvider,[]]
[Lean.Elab.Term.resolveName',[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Elab.Term.TermElabM, List, Prod, Lean.Expr, Lean.Syntax, Bind.bind, Lean.Elab.Term.resolveName, List.mapM, Pure.pure, Prod.mk, List.head!, List.tail!, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.Meta.mkFreshTypeMVar,[Bind.bind, Lean.Meta.mkFreshLevelMVar, Lean.Meta.mkFreshExprMVar, Option.some, Lean.mkSort]]
[Lean.Elab.Deriving.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Deriving.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Sum.inr.inj,[]]
[UInt64.decLt,[Decidable, LT.lt, inferInstanceAs]]
[Lean.instBEqHeadIndex,[BEq.mk, Lean.HeadIndex.fvar, Lean.HeadIndex.mvar, Lean.HeadIndex.const, Lean.HeadIndex.proj, Lean.HeadIndex.lit, Lean.HeadIndex.sort, Lean.HeadIndex.lam, Lean.HeadIndex.forallE, Unit.unit, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.AttrM,[Lean.Core.CoreM]]
[UInt16.instSemiringUInt16.proof_2,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt16.zero_def, UInt16.add_def, UInt16.mk, OfNat.ofNat, zero_add, UInt16.val, UInt16.mk_val_eq, eq_self, propext, forall_const, UInt16]]
[Subtype.ext_val,[Subtype.ext]]
[Nat.le_of_le_of_sub_le_sub_right,[Nat.zero_le, Eq.symm, LE.le, Nat.succ, Nat.zero, Nat.not_succ_le_zero, Eq.refl, Nat.succ_le_succ, Nat.le_of_succ_le_succ, Eq.mp, congr, congrArg, Nat.succ_sub_succ]]
[Lean.Elab.Term.MatchAltView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.Parenthesizer.many1NoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.manyNoAntiquot.parenthesizer]]
[Lean.AttributeExtensionOLeanEntry.decl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Core.restore,[modify, Lean.Core.State.mk, Lean.Core.State.env, Lean.Core.State.nextMacroScope, Lean.Core.State.ngen, Lean.Core.State.traceState]]
[Lean.Elab.Term.commitIfDidNotPostpone,[Bind.bind, Lean.Elab.Term.observing, Lean.Elab.Term.applyResult]]
[Lean.Lsp.Ipc.readMessage,[Bind.bind, Lean.Lsp.Ipc.stdout, liftM, IO.FS.Stream.readLspMessage]]
[«tacticBy_cases__:_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Lsp.Command.noConfusionType,[]]
[Lean.Compiler.mkNatEq,[Lean.mkAppN, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.levelOne, List.nil, List.toArray]]
[Nat.gcd_dvd_left,[And.left, Nat.gcd_dvd]]
[Lean.Lsp.WaitForDiagnosticsParams.noConfusionType,[]]
[Std.RBTree,[Std.RBMap, Unit]]
[Lean.Parser.Term.doForDecl,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.termParser, Lean.Parser.symbol, Lean.Parser.withForbidden]]
[Std.RBNode.balance2,[Std.RBNode.leaf, Std.RBNode.node, Std.Rbcolor.black, Std.Rbcolor.red, Std.RBNode]]
[Lean.Parser.ParserState.setCache,[Lean.Parser.ParserState.mk, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.pos, Lean.Parser.ParserState.errorMsg]]
[Lean.Lsp.instFileSourceDidCloseTextDocumentParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.DidCloseTextDocumentParams.textDocument]]
[Semiring.toAddCommSemigroup,[]]
[Lean.Elab.MonadLog.logMessage,[]]
[Lean.Lsp.StaticRegistrationOptions.mk.inj,[]]
[Lean.JsonRpc.instCoeStringRequestID,[Coe.mk, Lean.JsonRpc.RequestID.str]]
[Lean.PrefixTree.forMatchingM,[Lean.PrefixTreeNode.foldMatchingM, Subtype.val, Unit.unit]]
[Lean.getParentStructures,[Array.foldl, Unit.unit, Array, Lean.Name, Lean.isSubobjectField?, Array.push, List.toArray, List.nil, OfNat.ofNat, Array.size]]
[Option.any,[Unit.unit, Bool, Bool.false]]
[Lean.Meta.NormNum.instLawfulZero.proof_1,[Lean.Meta.NormNum.LawfulZero.mk, rfl]]
[Lean.Parser.registerBuiltinDynamicParserAttribute,[Lean.registerBuiltinAttribute, Lean.Parser.mkParserAttributeImpl]]
[Lean.TraceState.traces,[]]
[Lean.Meta.Closure.State.visitedLevel,[]]
[Lean.Meta.RecursorInfo.recursive,[]]
[Lean.Parser.Term.bracketedBinder.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.PrettyPrinter.Parenthesizer.evalInsideQuot.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Bool.false]]
[Lean.Option.Decl.descr,[]]
[Mathlib.Eval.evalTerm,[Bind.bind, Lean.Elab.Term.elabTermEnsuringType, Option.some, Bool.true, Option.none, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Bool.false, liftM, Lean.Meta.instantiateMVars, Lean.Meta.getMVars, Lean.Elab.Term.logUnassignedUsingErrorInfos, ite, Eq, Lean.Elab.throwAbortTerm, Pure.pure, PUnit.unit]]
[IsAddLeftCancel.add_left_cancel,[]]
[Lean.Parser.Command.printAxioms,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.ident]]
[Lean.Elab.Deriving.Header.mk.inj,[And.intro]]
[Lean.PrettyPrinter.Parenthesizer.notFollowedBy.parenthesizer,[Pure.pure, Unit.unit]]
[Lean.Lsp.LineRange.end,[]]
[Lean.IR.EmitC.emitVDecl,[Lean.IR.EmitC.M, Unit, Lean.IR.EmitC.emitCtor, Lean.IR.EmitC.emitReset, Lean.IR.EmitC.emitReuse, Lean.IR.EmitC.emitProj, Lean.IR.EmitC.emitUProj, Lean.IR.EmitC.emitSProj, Lean.IR.EmitC.emitFullApp, Lean.IR.EmitC.emitPartialApp, Lean.IR.EmitC.emitApp, Lean.IR.EmitC.emitBox, Lean.IR.EmitC.emitUnbox, Lean.IR.EmitC.emitIsShared, Lean.IR.EmitC.emitIsTaggedPtr, Lean.IR.EmitC.emitLit]]
[iff_false_right,[Iff.trans, Iff.comm, iff_false_left]]
[Lean.Parser.Term.cdot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HOrElse.hOrElse, Lean.Parser.symbol]]
[Lean.Parser.numLit.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.numLitKind, Bool.true, Lean.PrettyPrinter.Formatter.numLitNoAntiquot.formatter]]
[Lean.NameSanitizerState.noConfusionType,[]]
[Lean.Parser.Command.macro_rules.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.suppressInsideQuot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.docComment.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.optKind.parenthesizer, Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[IO.Process.StdioConfig.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Process.StdioConfig.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Match.Example.underscore.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Term.Do.Code.ite.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.doSeqIndent.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.many1Indent.parenthesizer, Lean.Parser.Term.doSeqItem.parenthesizer]]
[Lean.Server.Snapshots.parseAhead,[Lean.Server.Snapshots.Snapshot.mpState, List.toArray, List.nil, Lean.Server.Snapshots.parseAhead.go]]
[Lean.IR.Decl.uniqueIds,[StateT.run', Lean.IR.UniqueIds.checkDecl, EmptyCollection.emptyCollection]]
[instReprIterator,[Repr.mk, Std.Format, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg]]
[Lean.Server.Watchdog.FileWorker.groupedEditsRef,[]]
[Array.qsort,[Array.qsort.sort]]
[Lean.Elab.Info.range?,[Lean.Syntax.getRange?, Lean.Elab.Info.stx, Bool.true]]
[Lean.MessageLog.add,[Lean.MessageLog.mk, Std.PersistentArray.push, Lean.MessageLog.msgs]]
[Lean.Lsp.SemanticTokensOptions.legend,[]]
[Lean.Parser.satisfyFn,[ite, Eq, String.atEnd, Lean.Parser.InputContext.input, Lean.Parser.ParserContext.toInputContext, Bool.true, Lean.Parser.ParserState.mkEOIError, List.nil, String.get, Lean.Parser.ParserState.next, Lean.Parser.ParserState.mkUnexpectedError]]
[Lean.AxiomVal.mk.inj,[And.intro]]
[Lean.Parser.Term.implicitBinder,[Lean.Parser.ppGroup, Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.Term.binderIdent, Lean.Parser.Term.binderType]]
[Lean.Parser.Tactic.guardExprEq',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[Lean.Elab.Term.Quotation.withNewLocal,[MonadWithReader.withReader, Lean.Elab.Term.Quotation.Precheck.Context.mk, Lean.NameSet.insert, Lean.Elab.Term.Quotation.Precheck.Context.quotLCtx]]
[Lean.Parser.Command.«termExpandBinders%(__=>_)_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.cat, Lean.explicitBinders]]
[USize.instSemiringUSize.proof_7,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, USize.one_def, USize.mul_def, USize.mk, OfNat.ofNat, one_mul, USize.val, USize.mk_val_eq, eq_self, propext, forall_const, USize]]
[Lean.Meta.DiscrTree.Key.const.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.DiscrTree.Key.const, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.CompletionOptions.resolveProvider,[]]
[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Id.instMonadId,[Monad.mk]]
[Std.PersistentArray.mul2Shift,[USize.shiftLeft]]
[Lean.MetavarKind.noConfusionType,[noConfusionTypeEnum, Lean.MetavarKind.toCtorIdx]]
[List.card_append_disjoint,[Eq, List.card, HAppend.hAppend, HAdd.hAdd, of_eq_true, Eq.trans, congr, congrArg, List.nil_append, congrFun, List.card_nil, Nat.zero_add, eq_self]]
[Std.RBMap.toList,[List, Prod, Std.RBNode.revFold, List.cons, Prod.mk, List.nil]]
[«term{__:_//_}»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[Nat.prod_dvd_and_dvd_of_dvd_prod,[Nat.gcd, Nat.prod_dvd_and_dvd_of_dvd_prod.proof_1, Nat.prod_dvd_and_dvd_of_dvd_prod.proof_2, Nat.prod_dvd_and_dvd_of_dvd_prod.proof_4]]
[Lean.MetavarKind.syntheticOpaque.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Mathlib.Tactic.Lint.isSimpEq,[Lean.Meta.withReducible, ite, Eq, Bool.true, Bind.bind, Lean.Meta.whnf, Pure.pure]]
[Nat.sub_add_cancel,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HSub.hSub, Nat.add_comm, Nat.add_sub_of_le, rfl]]
[Lean.Parser.Term.ident.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.ident.formatter]]
[Lean.Parser.many,[Lean.Parser.manyNoAntiquot, Lean.Parser.withAntiquotSpliceAndSuffix, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol]]
[Lean.Parser.Term.doUnless.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.withForbidden.formatter, Lean.Parser.termParser.formatter, Lean.Parser.Term.doSeq.formatter]]
[Lean.Parser.Command.noncomputable.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Nat.mul_le_mul,[Nat.le_trans, Nat.mul_le_mul_right, Nat.mul_le_mul_left]]
[Lean.Elab.syntaxNodeKindOfAttrParam,[Bind.bind, Lean.Attribute.Builtin.getId, HOrElse.hOrElse, Lean.Elab.checkSyntaxNodeKindAtCurrentNamespaces, Lean.Elab.checkSyntaxNodeKind, HAppend.hAppend, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.Elab.Tactic.Conv.evalDelta,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.resolveGlobalConstNoOverload, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.Conv.getLhs, liftM, Lean.Meta.deltaExpand, BEq.beq, Lean.Elab.Tactic.Conv.changeLhs]]
[Lean.KVMap.instForInKVMapProdNameDataValue,[ForIn.mk, Lean.KVMap.forIn]]
[List.not_bex_nil,[False]]
[Lean.Meta.ReduceMatcherResult.stuck.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.AliasValue.binary.inj,[]]
[Lean.Meta.Simp.simp.cacheResult,[ite, Eq, Lean.Meta.Simp.Config.memoize, Bool.true, Bind.bind, modify, Lean.Meta.Simp.State.mk, Std.HashMap.insert, Lean.Meta.Simp.State.cache, Lean.Meta.Simp.State.numSteps, Pure.pure, PUnit.unit]]
[Lean.DeclarationRanges.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.DataValue.ofInt.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.declValEqns,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.Term.matchAltsWhereDecls]]
[Std.ShareCommon.PersistentState.inhabited,[Inhabited.mk, Std.ShareCommon.PersistentState.empty]]
[Lean.strLitKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Syntax.node.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, Eq.refl, List.nil, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec]]
[Lean.Lsp.SymbolKind.array.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.IR.instInhabitedParam,[Inhabited.mk, Lean.IR.Param.mk, arbitrary]]
[Lean.Expr.getAppRevArgs,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Array, Lean.Expr, PProd.fst, Array.push, Array.mkEmpty, Lean.Expr.getAppNumArgs]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk.inj,[And.intro]]
[HEq.rfl.proof_1,[HEq.refl]]
[Lean.modToFilePath,[System.FilePath.withExtension, Lean.modToFilePath.go]]
[Lean.Lsp.PlainGoal.mk.inj,[And.intro]]
[Lean.Meta.SimpEntry.toUnfold.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.SimpEntry.toUnfold, Eq.symm, eq_of_heq, HEq.refl]]
[left_neg_eq_right_neg,[Eq.mpr, Eq.refl, Eq, Eq.symm, zero_add, HAdd.hAdd, OfNat.ofNat, add_assoc, add_zero, rfl]]
[Nat.mul_mod_mul_right,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HMul.hMul, Nat.mul_comm, Nat.mul_mod_mul_left]]
[Function.injective_of_partial_inv,[Option.some.inj, Eq.trans, Eq.symm, Iff.mpr, rfl]]
[Lean.Parser.sepBy1Fn,[Bool.false]]
[Lean.Meta.IndPredBelow.mkContext.mkIndValConst,[Lean.mkConst, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, List.map, Lean.mkLevelParam, Lean.ConstantVal.levelParams]]
[IO.Process.StdioConfig.noConfusionType,[]]
[IO.setRandSeed,[ST.Ref.set, IO.stdGenRef, mkStdGen]]
[Lean.Parser.argPrec,[OfNat.ofNat]]
[tacticTransitivity__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Lean.Meta.SimpLemma.proof,[]]
[Lean.Meta.SynthInstance.getResult,[Bind.bind, MonadState.get, Pure.pure, Lean.Meta.SynthInstance.State.result?]]
[Array.toArrayLit,[List.toArray, Array.toListLitAux, Array.toArrayLit.proof_1, List.nil]]
[Lean.Elab.Command.expandDeclIdNamespace?,[Option, Prod, Lean.Name, Lean.Syntax, Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Lean.MacroScopesView.name, Option.none, ite, Eq, Lean.Syntax.isIdent, Bool.true, Option.some, Prod.mk, Lean.mkIdentFrom, Lean.Syntax.setArg, OfNat.ofNat]]
[Lean.Meta.Config.trackZeta,[]]
[OptionT.orElse,[OptionT.mk, Bind.bind, Option.none, Option, Pure.pure, Option.some, Unit.unit]]
[Lean.Elab.Term.elabCompletion,[ite, Eq, Lean.Syntax.isIdent, Lean.Syntax.getOp, OfNat.ofNat, Bool.true, Bind.bind, Lean.MonadBacktrack.saveState, MonadExcept.tryCatch, Lean.Elab.Term.elabTerm, Option.none, Lean.Elab.Term.addDotCompletionInfo, Lean.Elab.Term.SavedState.restore, Bool.false, Lean.MonadLCtx.getLCtx, Lean.Elab.addCompletionInfo, Lean.Elab.CompletionInfo.id, Lean.Syntax.getId, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, Lean.Elab.Term.elabPipeCompletion]]
[Lean.Meta.IndPredBelow.mkBelowDecl,[Bind.bind, Array.mapIdxM, Lean.Meta.IndPredBelow.Context.typeInfos, Lean.Meta.IndPredBelow.mkInductiveType, Pure.pure, Lean.Declaration.inductDecl, HAdd.hAdd, Lean.Meta.IndPredBelow.Context.numParams, Array.size, Lean.Meta.IndPredBelow.Context.motives, Array.toList, Lean.InductiveVal.isUnsafe, Array.getOp, OfNat.ofNat]]
[instDecidableXor.proof_1,[False]]
[Lean.Parser.Term.doReassignArrow.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.notFollowedByRedefinedTermToken.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.doIdDecl.formatter, Lean.Parser.Term.doPatDecl.formatter]]
[Lean.Parser.Term.falseVal,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.nonReservedSymbol, Bool.false]]
[List.forall_mem_of_forall_mem_cons,[And.right, Iff.mp, List.forall_mem_cons]]
[instOfNatNat,[OfNat.mk]]
[Lean.instInhabitedConstructorVal,[Inhabited.mk, Lean.ConstructorVal.mk, arbitrary]]
[instShiftLeftUInt16,[ShiftLeft.mk, UInt16.shiftLeft]]
[Std.rbtreeOf,[Std.RBTree.fromList]]
[Lean.Parser.Term.argument.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkWsBefore.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.namedArgument.parenthesizer, Lean.Parser.Term.ellipsis.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.argPrec]]
[Lean.Syntax.SepArray.elemsAndSeps,[]]
[Lean.Parser.Term.show.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.fromTerm.formatter, Lean.Parser.Term.byTactic.formatter]]
[floatDecLt,[Float.decLt]]
[Lean.PrettyPrinter.Formatter.interpretParserDescr,[Lean.Core.CoreM, Lean.PrettyPrinter.Formatter, liftM, Lean.Parser.getConstAlias, Lean.PrettyPrinter.Formatter.formatterAliasesRef, Bind.bind, Lean.Parser.getUnaryAlias, Lean.PrettyPrinter.Formatter.interpretParserDescr, Pure.pure, Lean.Parser.getBinaryAlias, Lean.PrettyPrinter.Formatter.node.formatter, Lean.Parser.sepBy.formatter, Lean.Parser.sepBy1.formatter, Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.ParserCompiler.CombinatorAttribute.runDeclFor, Lean.PrettyPrinter.combinatorFormatterAttribute, Lean.PrettyPrinter.Formatter.categoryParser.formatter]]
[Lean.mkNode,[Lean.Syntax.node, Lean.SourceInfo.none]]
[Lean.Xml.Parser.ETag,[SeqRight.seqRight, Lean.Parsec.skipString, Lean.Xml.Parser.Name, optional, Lean.Xml.Parser.S, Lean.Parsec.skipChar, Char.ofNat]]
[Lean.Server.FileWorker.handleRpcKeepAlive,[Bind.bind, MonadState.get, Unit.unit, Lean.Server.FileWorker.WorkerM, Unit, Std.RBMap.find?, Lean.Server.FileWorker.WorkerState.rpcSessions, Lean.Lsp.RpcKeepAliveParams.sessionId, Pure.pure, PUnit.unit, ST.Ref.get, liftM, Lean.Server.FileWorker.RpcSession.keptAlive, ST.Ref.set]]
[UInt64.sub,[UInt64.mk, HSub.hSub, UInt64.val]]
[forall_and_distrib,[Iff.intro, And.intro, And.left, And.right, And]]
[Nat.mul_pred_left,[Eq, HMul.hMul, Nat.pred, HSub.hSub, of_eq_true, Eq.trans, congr, congrArg, congrFun, Nat.pred_zero, Nat.zero_mul, Nat.zero_sub, eq_true_of_decide, Eq.refl, Bool.true, Eq.mpr, HAdd.hAdd, OfNat.ofNat, Nat.pred_succ, Nat.succ_mul, Nat.add_sub_cancel, rfl]]
[Lean.Parser.Term.doSeqItem,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.ppLine, Lean.Parser.doElemParser, Lean.Parser.optional, Lean.Parser.symbol]]
[Lean.instToExprNat,[Lean.ToExpr.mk, Lean.mkNatLit, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Int.neg_inj,[Eq.mpr, Eq.refl, Eq, Eq.symm, Int.neg_neg, Neg.neg, rfl]]
[Nat.succ_mul,[rfl, Eq.mpr, Eq.refl, Eq, HMul.hMul, Nat.succ, HAdd.hAdd, Nat.mul_succ, Nat.add_succ, Nat.add_right_comm]]
[Lean.HeadIndex.noConfusionType,[]]
[Lean.Elab.Term.withSavedContext,[MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.SavedContext.declName?, Lean.Elab.Term.SavedContext.macroStack, Lean.Elab.Term.Context.currMacroScope, Lean.Elab.Term.Context.mayPostpone, Lean.Elab.Term.SavedContext.errToSorry, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.Term.Context.autoBoundImplicits, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection, withTheReader, Lean.Core.Context, Lean.Core.Context.mk, Lean.Elab.Term.SavedContext.options, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Elab.Term.SavedContext.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats]]
[Lean.Elab.Term.MVarErrorInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Level.Context.noConfusionType,[]]
[Lean.Parser.Term.binop.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec]]
[optParam_eq,[rfl]]
[Tactic.Ring.evalAtom,[Bind.bind, Tactic.Ring.addAtom, MonadReader.read, liftM, Lean.Meta.mkAppOptM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Option.some, Tactic.Ring.Cache.α, Lean.mkRawNatLit, OfNat.ofNat, Option.none, List.nil, Pure.pure, Tactic.Ring.HornerExpr.const, Tactic.Ring.HornerExpr.xadd', Prod.mk, Tactic.Ring.mkAppCS]]
[PNonScalar.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[not_not_intro,[]]
[Lean.IR.Expr.uproj.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Widget.formatExplicitInfos,[Bind.bind, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, Lean.MonadOptions.getOptions, Lean.Meta.instantiateMVars, Lean.PrettyPrinter.delabCore, Lean.Meta.MetaM, Prod, Std.Format, Std.RBMap, Nat, Lean.Elab.Info, Ord.compare, liftM, Lean.PrettyPrinter.parenthesizeTerm, Lean.PrettyPrinter.formatTerm, Pure.pure, Prod.mk]]
[Lean.Parser.Command.identPrec.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.Parser.optPrecedence.formatter]]
[Lean.Lsp.Location.mk.inj,[And.intro]]
[List.decidablePairwise.proof_1,[Eq.refl]]
[Lean.replaceFVarIdAtLocalDecl,[ite, Eq, BEq.beq, Lean.LocalDecl.fvarId, Bool.true, Lean.LocalDecl, Lean.LocalDecl.cdecl, Lean.Expr.replaceFVarId, Lean.LocalDecl.ldecl]]
[Lean.Meta.ForEachExpr.M,[Lean.MonadCacheT, Lean.Expr, Unit, Lean.Meta.MetaM]]
[ReaderT.instMonadLiftReaderT,[MonadLift.mk]]
[UInt8.decEq,[Decidable, Eq, dite, Decidable.isTrue, UInt8.decEq.proof_1, Decidable.isFalse, UInt8.decEq.proof_2]]
[Lean.Parser.satisfySymbolFn,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Lean.Parser.ParserState, Array.back, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.mkErrorsAt, Option.some]]
[Nat.gcd_div,[Eq, Nat.gcd, HDiv.hDiv, Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, OfNat.ofNat, Nat.div_zero, Nat.gcd_zero_right, rfl, Nat.eq_of_mul_eq_mul_right, HMul.hMul, Nat.div_mul_cancel, Nat.dvd_gcd, Eq.symm, Nat.gcd_mul_right]]
[Lean.Meta.SynthInstance.Context.maxResultSize,[]]
[List.getLast?,[Unit.unit, Option, Option.none, Option.some, List.getLast, List.cons, List.getLast?.proof_1]]
[«term_&&&_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.MonadMCtx.noConfusionType,[]]
[Lean.Meta.Config.assignSyntheticOpaque,[]]
[List.not_mem_cons_of_ne_of_not_mem,[absurd, List.eq_or_mem_of_mem_cons, Iff.mpr, not_or, Eq, Mem.mem, And.intro]]
[Lean.Level.occurs,[Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Bool, or, BEq.beq, PProd.fst, PProd.snd]]
[instSemiringFin.proof_3,[Fin.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, Fin.val, Eq.trans, HMul.hMul, Fin.add_def, Fin.mul_def, Fin.mk, HMod.hMod, HAdd.hAdd, Nat.mod_lt, Fin.size_positive, Nat.add_mod_mod, Nat.mod_add_mod, Eq.refl, Eq.symm, Eq.mp, Nat.mul_mod, Nat.mod_eq_of_lt, Fin.isLt, Semiring.mul_add, rfl]]
[Lean.Meta.DiscrTree.instInhabitedTrie,[Inhabited.mk, Lean.Meta.DiscrTree.Trie.node, List.toArray, List.nil]]
[Lean.SimplePersistentEnvExtensionDescr.noConfusionType,[]]
[Lean.mkNoConfusionEnum.mkNoConfusion,[Lean.Meta.withLocalDecl, Lean.Name.mkStr, Lean.Name.anonymous, Lean.BinderInfo.implicit, Bind.bind, Lean.Meta.mkEq, Lean.Meta.withLocalDeclD, Lean.Meta.mkForallFVars, List.toArray, List.cons, List.nil, Lean.mkApp3, Bool.false, Bool.true, Lean.Meta.mkAppOptM, Option.none, Option.some, Lean.Meta.mkLambdaFVars, Lean.addAndCompile, Lean.Declaration.defnDecl, Lean.DefinitionVal.mk, Lean.ConstantVal.mk, Lean.ReducibilityHints.abbrev, Lean.DefinitionSafety.safe]]
[String.revPosOf,[ite, Eq, BEq.beq, String.bsize, OfNat.ofNat, Bool.true, Option.none, String.revPosOfAux, String.prev]]
[Lean.Parser.Tactic.unfoldAux,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Core.State.nextMacroScope,[]]
[Char.instLTChar,[LT.mk, Char.lt]]
[Nat.add_sub_cancel_left,[]]
[EStateM,[EStateM.Result]]
[Lean.Elab.Term.levelMVarToParam',[Bind.bind, MonadState.get, liftM, Lean.Elab.Term.levelMVarToParam, StateRefT', IO.RealWorld, Nat, Lean.Elab.Term.TermElabM, Lean.Expr, MonadStateOf.set, Pure.pure]]
[Lean.mkPrivateName,[HAppend.hAppend, Lean.Name.mkNum, Lean.privateHeader, Lean.Environment.mainModule, OfNat.ofNat]]
[Lean.Parser.Command.structExplicitBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Command.declModifiers.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.inferMod.parenthesizer, Lean.Parser.Command.optDeclSig.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.binderTactic.parenthesizer, Lean.Parser.Term.binderDefault.parenthesizer]]
[Int.gcd,[Nat.gcd, Int.natAbs]]
[Lean.Meta.Simp.tryLemma?,[Lean.Meta.withNewMCtxDepth, Bind.bind, liftM, Lean.Meta.SimpLemma.getValue, Lean.Meta.inferType, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.Simp.SimpM, Option, Lean.Meta.Simp.Result, Lean.Meta.instantiateMVars, Lean.Meta.whnf, ForIn.forIn, MProd.mk, Pure.pure, PUnit.unit, ForInStep.yield, Unit.unit, Option.some, Lean.Meta.Simp.Result.mk, Lean.mkAppN, Lean.Meta.mkCongrFun, Lean.Meta.isDefEq, ite, Eq, Bool.true, Lean.Meta.Simp.synthesizeArgs, Lean.Meta.SimpLemma.getName, Lean.Expr.isMVar, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, OfNat.ofNat, GT.gt, HSub.hSub]]
[Lean.Elab.Command.ElabHeaderResult.noConfusionType,[]]
[Lean.IR.EmitC.isTailCall,[Bind.bind, MonadReader.read, Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.fap, Lean.IR.FnBody.vdecl, Lean.IR.FnBody.jdecl, Lean.IR.FnBody.set, Lean.IR.FnBody.setTag, Lean.IR.FnBody.uset, Lean.IR.FnBody.sset, Lean.IR.FnBody.inc, Lean.IR.FnBody.dec, Lean.IR.FnBody.del, Lean.IR.FnBody.mdata, Lean.IR.FnBody.case, Lean.IR.FnBody.ret, Lean.IR.Arg.irrelevant, Lean.IR.FnBody.jmp, Lean.IR.FnBody.unreachable, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Lean.IR.EmitC.M, Bool, Pure.pure, and, BEq.beq, Lean.IR.EmitC.Context.mainFn, Bool.false]]
[Lean.Elab.FieldInfo.fieldName,[]]
[Std.HashMapImp.WellFormed.brecOn,[Std.HashMapImp.WellFormed.below.mkWff, Std.HashMapImp.WellFormed.below.insertWff, Std.HashMapImp.WellFormed.below.eraseWff]]
[Nat.decLt,[Nat.decLe, Nat.succ]]
[Lean.IR.HasIndex.visitVar,[BEq.beq, Lean.IR.VarId.idx]]
[Lean.Elab.Term.MutualClosure.getModifiersForLetRecs,[Lean.Elab.Modifiers.mk, Array.any, Lean.Elab.Modifiers.isNoncomputable, Lean.Elab.DefViewElabHeader.modifiers, OfNat.ofNat, Array.size, ite, Eq, Lean.Elab.Modifiers.isPartial, Bool.true, Lean.Elab.RecKind.partial, Lean.Elab.RecKind.default, Lean.Elab.Modifiers.isUnsafe]]
[Lean.Parser.ParserContext.toInputContext,[]]
[Lean.Parser.Command.elab.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.suppressInsideQuot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.docComment.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optPrecedence.parenthesizer, Lean.Parser.Command.optNamedName.parenthesizer, Lean.Parser.Command.optNamedPrio.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Command.elabArg.parenthesizer, Lean.Parser.Command.elabTail.parenthesizer]]
[Lean.IR.AltCore.ctor.inj,[And.intro]]
[Lean.Level.param.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Monad.toBind,[]]
[Lean.Meta.Cache.noConfusionType,[]]
[Lean.KeyedDeclsAttribute.Def.name,[]]
[Lean.Parser.Term.ellipsis.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.Meta.SynthInstance.State.tableEntries,[]]
[Std.PersistentHashSet.insert,[Std.PersistentHashSet.mk, Std.PersistentHashMap.insert, Std.PersistentHashSet.set, Unit.unit]]
[FloatArray.instForInFloatArrayFloat,[ForIn.mk, FloatArray.forIn]]
[Lean.Meta.SynthInstance.SubgoalsResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SynthInstance.SubgoalsResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.RecursorRule.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.RecursorRule.mk, Eq.symm, eq_of_heq, HEq.refl]]
[ExistsUnique.exists,[Exists, Exists.intro]]
[Std.RBTree.isEmpty,[Std.RBMap.isEmpty]]
[Lean.Option.Decl.noConfusionType,[]]
[Lean.Lsp.DocumentSymbol.mk.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.trans, HAdd.hAdd, SizeOf.sizeOf, Eq.refl, Option.none, List.nil, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec, Option.some.sizeOf_spec, Lean.Lsp.DocumentSymbolAux.mk.sizeOf_spec]]
[Std.PersistentHashMap.Stats.numNodes,[]]
[Lean.ExternEntry.inline.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Ne.elim,[]]
[Lean.KernelException.appTypeMismatch.inj,[And.intro]]
[Lean.Parser.InputContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instToStringSigma,[ToString.mk, String, HAppend.hAppend, ToString.toString]]
[Lean.Parser.tokenWithAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.tokenWithAntiquotFn, Lean.Parser.Parser.fn]]
[Lean.Meta.getCtorNumPropFields,[Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, Bind.bind, ForIn.forIn, Lean.Meta.inferType, Array.getOp, HAdd.hAdd, Lean.ConstructorVal.numParams, Lean.Meta.isProp, ite, Eq, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield]]
[Lean.choiceKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Expr.isDIte,[Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat]]
[Lean.JsonRpc.Message.notification.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonRpc.Message.notification, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.instBEqLocation,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Level.max.inj,[And.intro]]
[Std.ShareCommon.ObjectPersistentMap,[Std.PersistentHashMap, Std.ShareCommon.Object]]
[Lean.Parser.Syntax.atom.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.strLit.parenthesizer]]
[Bind.noConfusionType,[]]
[Lean.PrettyPrinter.Parenthesizer.withoutForbidden.parenthesizer,[]]
[Lean.LazyInitExtension.mk.inj,[And.intro]]
[Lean.NameMap.insert,[Std.RBMap.insert]]
[Function.comp_update,[funext, Function.apply_update]]
[Lean.Elab.Modifiers.isProtected,[Lean.Elab.Modifiers.mk, Lean.Elab.Visibility.regular, Lean.Elab.Visibility.private, Bool, Bool.true, Bool.false]]
[Lean.Syntax.SepArray.noConfusionType,[]]
[Lean.Elab.Term.StructInst.CtorHeaderResult.noConfusionType,[]]
[Lean.Elab.Modifiers.isPrivate,[Lean.Elab.Modifiers.mk, Lean.Elab.Visibility.regular, Lean.Elab.Visibility.protected, Bool, Bool.true, Bool.false]]
[Lean.Elab.Structural.EqnInfo.type,[]]
[Lean.IR.Expr.isTaggedPtr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.div_eq_of_eq_mul_left,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, Nat.mul_div_cancel, rfl]]
[Lean.Parser.ParserExtension.OLeanEntry.kind.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.ParserExtension.OLeanEntry.kind, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.doIdDecl.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.Term.optType.parenthesizer, Lean.Parser.Term.leftArrow.parenthesizer, Lean.Parser.doElemParser.parenthesizer]]
[Lean.KeyedDeclsAttribute.Extension,[Lean.ScopedEnvExtension, Lean.KeyedDeclsAttribute.OLeanEntry, Lean.KeyedDeclsAttribute.AttributeEntry, Lean.KeyedDeclsAttribute.ExtensionState]]
[Prod.lexAccessible.proof_1,[Acc.intro, Prod.mk, Eq.symm, eq_of_heq, Eq.refl, HEq.refl]]
[Function.left_inverse.surjective,[Function.right_inverse.surjective, Function.left_inverse.right_inverse]]
[Lean.instToMessageDataSubarray,[Lean.ToMessageData.mk, Lean.ToMessageData.toMessageData, Array.toList, Subarray.toArray]]
[Lean.ppSpace.formatter,[Lean.PrettyPrinter.Formatter.pushLine]]
[instInhabitedBool,[Inhabited.mk, Bool.false]]
[UInt8.ofNatCore,[UInt8.mk, Fin.mk]]
[Lean.Lsp.instBEqDiagnosticCode,[BEq.mk, Lean.Lsp.DiagnosticCode.int, Lean.Lsp.DiagnosticCode.string, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Meta.addCongrLemmaEntry.insert,[Unit.unit, List, Lean.Meta.CongrLemma, List.cons, List.nil, ite, GE.ge, Lean.Meta.CongrLemma.priority, PProd.fst]]
[Lean.IR.FnBody.uset.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[IO.Error.resourceVanished.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[PUnit.ext,[rfl]]
[Ring.add_left_neg,[]]
[instOrdUInt64,[Ord.mk, compareOfLessAndEq]]
[Lean.Elab.Term.StructInst.DefaultFields.State.progress,[]]
[List.length_add_eq_lengthTRAux,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Nat.zero_add, eq_self, Eq.mpr, congr, Nat.succ_add, List.length, Eq.symm, Nat.succ, rfl]]
[Lean.Meta.Config.noConfusionType,[]]
[Lean.Name.isNum,[Lean.Name.anonymous, Lean.Name.str, Bool, Bool.true, Bool.false]]
[Lean.Elab.Term.Quotation.elabPrecheckedQuot,[Bind.bind, Lean.Elab.Term.Quotation.runPrecheck, Lean.Syntax.getQuotContent, Lean.Elab.Term.adaptExpander, Pure.pure]]
[«term_!=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.JsonNumber.shiftr,[Lean.JsonNumber, Lean.JsonNumber.mk, HAdd.hAdd]]
[UInt16.val_eq_of_lt,[Fin.val_eq_of_lt]]
[Lean.Elab.Command.StructFieldView.ref,[]]
[Lean.Meta.mkAuxDefinitionFor,[Bind.bind, Lean.Meta.inferType, Lean.Meta.mkAuxDefinition, Bool.true]]
[Lean.PrettyPrinter.Formatter.skip.formatter,[Pure.pure, Unit.unit]]
[Lean.Option.Decl.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Option.Decl.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.levelZero,[Lean.Level.zero, Lean.Level.mkData, OfNat.ofNat, Bool.false]]
[Lean.Elab.Term.withSynthesizeLight,[MonadFunctorT.monadMap, Bind.bind, MonadState.get, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, List.nil, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState, tryFinally, Lean.Elab.Term.synthesizeSyntheticMVars, Bool.false, ite, Eq, and, Bool.true, Pure.pure, PUnit.unit, HAppend.hAppend, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.TermElabM]]
[Lean.Elab.Deriving.Repr.mkBodyForInduct,[Bind.bind, Lean.Elab.Deriving.mkDiscrs, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.Elab.Deriving.Repr.mkBodyForInduct.mkAlts]]
[Lean.Parser.Command.optDeriving.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.notSymbol.parenthesizer, Lean.Parser.Command.derivingClasses.parenthesizer]]
[Lean.Parser.Tactic.existsIntro,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.instToJsonInt,[Lean.ToJson.mk, Lean.Json.num, Lean.JsonNumber.fromInt]]
[Lean.Lsp.instBEqDiagnosticTag,[BEq.mk, BEq.beq, Lean.Lsp.DiagnosticTag.toCtorIdx]]
[ByteSlice.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, ByteSlice.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Server.FileWorker.compileHeader,[Bind.bind, Lean.Parser.parseHeader, IO, Prod, Lean.Server.Snapshots.Snapshot, Lean.SearchPath, liftM, IO.getEnv, Unit.unit, Pure.pure, System.FilePath.mk, System.FilePath.pathExists, Option.none, HDiv.hDiv, IO.appDir]]
[WellFounded.fix',[WellFounded.fix]]
[Lean.IR.CtorLayout.scalarSize,[]]
[List.append,[List, List.cons, PProd.fst]]
[Lean.Server.RequestM.withWaitFindSnap,[Bind.bind, liftM, IO.AsyncList.waitFind?, Lean.Server.FileWorker.EditableDocument.cmdSnaps, Lean.Server.RequestM.mapTask, Unit.unit, Lean.Server.RequestM, throwThe, Lean.Server.RequestError, Lean.Server.RequestError.fileChanged, MonadExcept.throw, Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.internalError, ToString.toString]]
[Lean.Lsp.SymbolKind.toCtorIdx,[OfNat.ofNat]]
[Lean.Widget.InfoWithCtx.info,[]]
[Lean.Meta.isUIntPatLit,[Option.isSome, Lean.Meta.isUIntPatLit?]]
[Nat.dvd_sub,[Iff.mpr, Nat.dvd_add_iff_left, Eq.mpr, Eq.refl, Dvd.dvd, HAdd.hAdd, HSub.hSub, Nat.sub_add_cancel]]
[Lean.Parser.strLit.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.strLitKind, Bool.true, Lean.PrettyPrinter.Formatter.strLitNoAntiquot.formatter]]
[Lean.instInhabitedConstantInfo,[Inhabited.mk, Lean.ConstantInfo.axiomInfo, arbitrary]]
[Exists.elim,[]]
[Lean.Elab.Term.StructInst.Field.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.StructInst.Field.mk, Eq.symm, eq_of_heq, HEq.refl]]
[List.reduceOption,[List.filterMap, id]]
[Std.PersistentArray.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.CompletionList.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.instFromJsonWaitForDiagnostics,[Lean.FromJson.mk, Pure.pure, Lean.Lsp.WaitForDiagnostics.mk]]
[List.remove,[Unit.unit, List, List.nil, ite, Eq, PProd.fst, List.cons]]
[Lean.Elab.Tactic.instMonadBacktrackSavedStateTacticM,[Lean.MonadBacktrack.mk, Lean.Elab.Tactic.saveState, Lean.Elab.Tactic.SavedState.restore]]
[Lean.Json.CompressWorkItem.arrayEnd.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.LocalContext.getFVars,[Array.map, Lean.mkFVar, Lean.LocalContext.getFVarIds]]
[Lean.initializing,[orM, liftM, IO.initializing, ST.Ref.get]]
[DoResultSBC.noConfusionType,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.provideds,[]]
[Lean.Server.FileWorker.WorkerContext.hOut,[]]
[Lean.getPPFullNames,[Lean.KVMap.get, Lean.Option.name, Lean.pp.fullNames, Lean.getPPAll]]
[Quot.recOnSubsingleton.proof_1,[Subsingleton.elim, Quot.sound]]
[Lean.Elab.CommandInfo.mk.inj,[]]
[Lean.termThrowErrorAt___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.unary]]
[Lean.Expr.bindingBody!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Expr.ReplaceImpl.initCache.proof_1,[lcProof]]
[Lean.instEval_1,[Lean.Eval.mk, IO.println, repr, Unit.unit]]
[Lean.Meta.collectPrivateIn,[Bind.bind, Lean.getConstInfo, Pure.pure, Lean.Expr.foldConsts, Lean.ConstantInfo.value!, ite, Eq, Lean.isPrivateName, Bool.true, Lean.NameSet.insert]]
[Lean.Name.beq,[Unit.unit, Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Bool, Bool.true, and, BEq.beq, PProd.fst, Bool.false]]
[Lean.TraceState.noConfusionType,[]]
[Prod.swap_injective,[Function.left_inverse.injective, Prod.swap_left_inverse]]
[Prod.mk.eta,[Eq, Prod.mk, Prod.fst, Prod.snd, rfl]]
[ne_self_iff_false,[not_iff_false_intro, rfl]]
[USize.zero_def,[rfl]]
[Lean.Meta.SynthInstance.ConsumerNode.mvar,[]]
[Int.subNatNat_elim,[]]
[Lean.instInhabitedRecursorRule,[Inhabited.mk, Lean.RecursorRule.mk, arbitrary]]
[Nat.decEq.proof_1,[Eq.refl, Nat.beq]]
[Lean.ConstantInfo.axiomInfo.inj,[]]
[Lean.Parser.Term.show,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat, HOrElse.hOrElse, Lean.Parser.Term.fromTerm, Lean.Parser.Term.byTactic]]
[Char.val_ne_of_ne,[absurd, Char.eq_of_val_eq]]
[Lean.Parser.Syntax.sepBy.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.syntaxParser.parenthesizer, Lean.Parser.strLit.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false]]
[Std.PersistentHashMap.Node.entries.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.trans, Eq.refl, SizeOf.sizeOf, List.nil, congr, Std.PersistentHashMap.Entry.entry, Std.PersistentHashMap.Entry.ref, Std.PersistentHashMap.Entry.null, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec]]
[Lean.Lsp.WaitForDiagnostics.noConfusion,[noConfusionEnum, Lean.Lsp.WaitForDiagnostics.toCtorIdx]]
[Lean.Elab.Tactic.withMacroExpansion,[Lean.Elab.withMacroExpansionInfo, withTheReader, Lean.Elab.Term.Context, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.Context.declName?, List.cons, Lean.Elab.MacroStackElem.mk, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.currMacroScope, Lean.Elab.Term.Context.mayPostpone, Lean.Elab.Term.Context.errToSorry, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.Term.Context.autoBoundImplicits, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection]]
[Functor.map,[]]
[UInt8.add,[UInt8.mk, HAdd.hAdd, UInt8.val]]
[StateT.run_monadLift,[rfl]]
[MonoidWithZero.toMonoid,[]]
[Lean.Syntax.isQuot,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Syntax.atom, Lean.Syntax.ident, Bool, Bool.true, Bool.false]]
[Lean.SMap.map₂,[]]
[Lean.Syntax.hasMissing,[Id.run, Bind.bind, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, Unit.unit, Id, Bool, MProd.fst, Pure.pure]]
[Lean.Elab.Deriving.Ord.mkOrdInstanceHandler,[Bind.bind, Array.allM, Lean.isInductive, OfNat.ofNat, Array.size, ite, Eq, and, Decidable.decide, GT.gt, Bool.true, Lean.Elab.Command.liftTermElabM, Option.none, Lean.Elab.Deriving.mkContext, Array.getOp, Lean.Elab.Deriving.Ord.mkMutualBlock, Lean.Elab.Deriving.mkInstanceCmds, Lean.Name.mkStr, Lean.Name.anonymous, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Array.forM, Lean.Elab.Command.elabCommand, Bool.false]]
[Lean.Xml.Parser.children,[SeqLeft.seqLeft, HOrElse.hOrElse, Lean.Xml.Parser.choice, Lean.Xml.Parser.seq, optional, Lean.Parsec.skipChar, Char.ofNat]]
[BaseIO.mapTasks.go,[BaseIO, Task, BaseIO.bindTask, PProd.fst, List.cons, BaseIO.asTask, List.reverse]]
[ToStream.toStream,[]]
[Lean.mkEmptyEnvironment,[Bind.bind, liftM, IO.initializing, ite, Eq, Bool.true, MonadExcept.throw, IO.userError, Pure.pure, PUnit.unit]]
[Repr.addAppParen,[ite, GE.ge, OfNat.ofNat, Std.Format.paren]]
[Lean.Parser.Command.optDeriving.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.notSymbol.formatter, Lean.Parser.Command.derivingClasses.formatter]]
[Lean.Parser.Tactic.nlinarith,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy]]
[List.forM_cons,[rfl]]
[Lean.IR.UnreachableBranches.InterpContext.mk.inj,[And.intro]]
[Lean.Parser.Term.bracketedBinder.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.none, Bool.false, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.explicitBinder.formatter, Lean.Parser.Term.strictImplicitBinder.formatter, Lean.Parser.Term.implicitBinder.formatter, Lean.Parser.Term.instBinder.formatter]]
[Lean.Lsp.TextDocumentSyncKind.toCtorIdx,[OfNat.ofNat]]
[UInt32.ofNatCore,[UInt32.mk, Fin.mk]]
[Lean.Elab.Term.StructInst.DefaultFields.getFieldName,[List.nil, List.cons, Lean.Elab.Term.StructInst.FieldLHS.fieldName, Lean.Elab.Term.StructInst.FieldLHS.fieldIndex, Lean.Elab.Term.StructInst.FieldLHS.modifyOp, Lean.Name, Lean.Elab.Term.StructInst.Field.lhs, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Lsp.WorkDoneProgressEnd.kind,[]]
[Lean.Server.foldDocumentChanges,[Array.foldl, Lean.Server.applyDocumentChange, OfNat.ofNat, Array.size]]
[Lean.NamePart.lt,[Lean.NamePart.str, Lean.NamePart.num, Bool, Decidable.decide, LT.lt, Bool.true, Bool.false]]
[Lean.Parser.getTokenTable,[Lean.Parser.ParserExtension.State.tokens, Lean.ScopedEnvExtension.getState, Lean.Parser.parserExtension]]
[UInt64.shiftRight,[UInt64.mk, HShiftRight.hShiftRight, UInt64.val, UInt64.modn, OfNat.ofNat]]
[Lean.Lsp.WorkDoneProgressBegin.noConfusionType,[]]
[Lean.Meta.modifyTargetEqLHS,[Lean.Meta.modifyTarget, Bind.bind, Lean.Meta.matchEq?, Option.none, Lean.Meta.MetaM, Lean.Expr, Lean.Meta.mkEq, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Syntax.missing]]
[Lean.Lsp.DidChangeTextDocumentParams.noConfusionType,[]]
[Lean.Elab.Command.StructFieldInfo.declName,[]]
[Lean.Export.State.levels,[]]
[Lean.Parser.Level.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.levelParser.formatter]]
[Lean.Elab.InfoState.enabled,[]]
[Lean.Elab.InfoTree.goalsAt?,[Id.run, Lean.Elab.InfoTree.deepestNodes, Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofTermInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.Info.ofCompletionInfo, Option, Lean.Elab.GoalsAtResult, OptionM.run, Prod.mk, Option.none, Option.some, OptionM, Lean.Elab.Info.pos?, Lean.Elab.Info.tailPos?, Bind.bind, guard, And, LE.le, Eq, or, Decidable.decide, LT.lt, HAdd.hAdd, Bool.true, Pure.pure, Lean.Elab.GoalsAtResult.mk, and, GT.gt, GE.ge, not, Std.PersistentArray.any, Alternative.failure, Lean.Elab.InfoTree.goalsAt?.hasNestedTactic]]
[Prod.exists',[Prod.exists]]
[decidable_eq_of_bool_pred,[dite, Eq, Bool.true, Decidable.isTrue, Decidable.isFalse, decidable_eq_of_bool_pred.proof_1]]
[Std.Format.nest.inj,[And.intro]]
[Lean.Xml.Parser.CharRef,[Bind.bind, Lean.Parsec.skipString, HOrElse.hOrElse, Functor.map, Lean.Xml.Parser.digitsToNat, OfNat.ofNat, Lean.Parsec.many1, Lean.Xml.Parser.hexDigitToNat, Lean.Parsec.digit, SeqRight.seqRight, Lean.Parsec.skipChar, Char.ofNat, Lean.Parsec.hexDigit, Pure.pure]]
[Lean.Unhygienic.run,[StateT.run', Lean.Unhygienic.Context.mk, Lean.Syntax.missing, Lean.firstFrontendMacroScope, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.MatcherApp.motive,[]]
[Lean.Elab.Command.elabCheckCore,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.withoutModifyingEnv, Lean.Elab.Command.runTermElabM, Option.some, Bind.bind, Lean.Elab.Term.elabTerm, Option.none, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, liftM, Lean.Meta.instantiateMVars, Lean.Elab.Term.levelMVarToParam, OfNat.ofNat, Lean.Elab.Term.TermElabM, Unit, Lean.Meta.inferType, Lean.Expr.isSyntheticSorry, Pure.pure, PUnit.unit, Lean.Elab.logInfoAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Lsp.instToJsonRpcRef,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.RpcRef.p, List.nil]]
[Lean.Elab.Deriving.DecEq.mkEnumOfNat,[Bind.bind, Lean.getConstInfoInduct, Lean.Meta.withLocalDeclD, Lean.Name.mkStr, Lean.Name.anonymous, Lean.mkConst, List.nil, Lean.Meta.mkLambdaFVars, List.toArray, List.cons, OfNat.ofNat, Array.size, Bool.false, Bool.true, Lean.Meta.mkArrow, Lean.addAndCompile, Lean.Declaration.defnDecl, Lean.DefinitionVal.mk, Lean.ConstantVal.mk, Lean.ReducibilityHints.abbrev, Lean.DefinitionSafety.safe, Lean.Elab.Deriving.DecEq.mkEnumOfNat.mkDecTree]]
[Lean.Parser.Attr.intro,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Core.Context.ref,[]]
[ByteSliceT.getOp,[ByteArray.get!, ByteSliceT.arr, HAdd.hAdd, ByteSliceT.off]]
[List.rangeAux,[List, Nat, PProd.fst, List.cons]]
[Lean.PrettyPrinter.Formatter.categoryParser.formatter,[Lean.PrettyPrinter.Formatter.group, Lean.PrettyPrinter.Formatter.indent, Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.ofFormat, Std.ToFormat.format, Pure.pure, PUnit.unit, Option.none]]
[Lean.Meta.RewriteResult.noConfusionType,[]]
[Lean.Elab.Term.LVal.fieldName.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.NamePart.str.injEq,[Eq.propIntro, Eq.refl, Lean.NamePart.str, Eq.symm, eq_of_heq, HEq.refl]]
[IO.FS.Stream.mk.inj,[And.intro]]
[Lean.Parser.Command.axiom.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.Command.declSig.formatter]]
[Lean.Elab.Info.toElabInfo?,[Option, Lean.Elab.ElabInfo, Option.some, Lean.Elab.TacticInfo.toElabInfo, Lean.Elab.TermInfo.toElabInfo, Lean.Elab.CommandInfo.toElabInfo, Option.none]]
[Lean.Elab.Term.Do.getDoHaveVar,[ite, Eq, Lean.Syntax.isNone, Bool.true, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.getId, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Lsp.InitializationOptions.editDelay?,[]]
[UInt32.add,[UInt32.mk, HAdd.hAdd, UInt32.val]]
[Function.cantor_injective,[Function.cantor_surjective, Function.right_inverse.surjective, funext, propext, Iff.intro, rfl]]
[Std.HashMap,[Subtype, Std.HashMapImp.WellFormed]]
[Lean.Parser.isIdCont,[ite, Eq, BEq.beq, Char.ofNat, Bool.true, String.atEnd, Bool.false, or, Lean.isIdFirst, Lean.isIdBeginEscape]]
[Lean.Parser.Tactic.linarith,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy]]
[Lean.Elab.Tactic.ElimApp.State.argPos,[]]
[IO.FS.FileType.toCtorIdx,[OfNat.ofNat]]
[List.mem_append,[of_eq_true, Eq.trans, congr, congrArg, Iff, Mem.mem, List.nil_append, congrFun, Or, propext, List.mem_nil_iff, false_or, iff_self, List.cons_append, List.mem_cons_iff, HAppend.hAppend, Eq, or_assoc]]
[Lean.IR.ExpandResetReuse.ProjMap,[Std.HashMap, Lean.IR.VarId, Lean.IR.Expr]]
[Nat.not_succ_le_zero,[False, Eq.refl, OfNat.ofNat, HEq.refl]]
[Lean.SyntaxNodeKind,[Lean.Name]]
[List.decidableBall.proof_2,[List.mem_cons_self]]
[Lean.Meta.ByCasesSubgoal.mvarId,[]]
[CoeSort.coe,[]]
[Lean.Meta.Match.Alt.idx,[]]
[Lean.Elab.Tactic.liftMetaTactic,[Lean.Elab.Tactic.liftMetaTacticAux, Bind.bind, Pure.pure, Prod.mk, Unit.unit]]
[List.appendTR,[List.reverseAux, List.reverse]]
[Lean.IR.LocalContext.addJP,[Std.RBMap.insert, Lean.IR.JoinPointId.idx, Lean.IR.LocalContextEntry.joinPoint]]
[Lean.IR.Sorry.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Sorry.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.ParserDescr.below,[PUnit, PProd]]
[Lean.Xml.Parser.PITarget,[SeqLeft.seqLeft, Lean.Xml.Parser.Name, HOrElse.hOrElse, Lean.Parsec.skipChar, Char.ofNat]]
[Lean.Meta.AbstractMVars.State.mctx,[]]
[Lean.Parser.nameLitFn,[ite, Eq, and, not, Lean.Parser.ParserState.hasError, Lean.Syntax.isOfKind, Array.back, Lean.Parser.ParserState.stxStack, Lean.nameLitKind, Bool.true, Lean.Parser.ParserState.mkErrorAt, Option.some]]
[Std.PersistentHashMap.Node.below,[PProd, PUnit]]
[Lean.MessageSeverity.toCtorIdx,[OfNat.ofNat]]
[Lean.MetavarDecl.userName,[]]
[Lean.Elab.Term.ToParserDescrM,[ReaderT, Lean.Elab.Term.ToParserDescrContext, StateRefT', IO.RealWorld, Option, Nat, Lean.Elab.Term.TermElabM]]
[Lean.Name.updatePrefix,[Lean.Name, Lean.Name.anonymous, Lean.Name.mkStr, Lean.Name.mkNum]]
[Lean.Elab.Tactic.focus,[Bind.bind, Lean.Elab.Tactic.getUnsolvedGoals, List.nil, Lean.Elab.Tactic.TacticM, Lean.Elab.Tactic.setGoals, List.cons, HAppend.hAppend, Pure.pure, Lean.Elab.Tactic.throwNoGoalsToBeSolved]]
[unsafeCast.proof_1,[lcProof]]
[Lean.Meta.IndPredBelow.Context.numParams,[]]
[Lean.IR.instReprCtorInfo,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.IR.CtorInfo.name, Std.Format.line, Lean.IR.CtorInfo.cidx, Lean.IR.CtorInfo.size, Lean.IR.CtorInfo.usize, Lean.IR.CtorInfo.ssize]]
[Lean.Meta.mkCongrArg,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Meta.mkEqRefl, Lean.mkApp, Lean.Expr.appArg!, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Option.none, Option.some, Prod.mk, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.arrow?, Lean.Expr.eq?, Lean.Meta.getLevel, Pure.pure, Lean.mkApp6, Lean.mkConst, List.cons, List.nil, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr]]
[SubNegMonoid.gsmul_zero',[]]
[Nat.coprime.eq_one_of_dvd,[Eq.mpr, Eq.refl, Eq, OfNat.ofNat, Eq.symm, Nat.coprime.gcd_eq_one, Nat.gcd, Nat.gcd_eq_left, rfl]]
[Lean.Widget.Lean.Widget.InteractiveGoal.instFromJsonRpcEncodingPacket,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Array, Lean.Widget.TaggedText, Option, String, Pure.pure]]
[Lean.Compiler.SpecState.specInfo,[]]
[Lean.IR.LitVal.noConfusionType,[]]
[Lean.getInitFnNameForCore?,[Option.none, Unit.unit, Lean.Name.str, Lean.Name.num, Option, Lean.Name, Lean.ParametricAttribute.getParam, Option.some]]
[UInt8.decEq.proof_1,[rfl]]
[Lean.Declaration.thmDecl.inj,[]]
[Mathlib.Tactic.Lint.Linter.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Mathlib.Tactic.Lint.Linter.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.findLocalDeclWithType?,[Bind.bind, Lean.MonadLCtx.getLCtx, Lean.LocalContext.findDeclRevM?, ite, Eq, Lean.LocalDecl.isAuxDecl, Bool.true, Pure.pure, Option.none, Lean.Meta.isDefEq, Lean.LocalDecl.type, Option.some, Lean.LocalDecl.fvarId]]
[Lean.Parser.Tactic.group,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.MetavarContext.assignLevel,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Lean.MetavarContext.decls, Lean.MetavarContext.userNames, Std.PersistentHashMap.insert, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment]]
[Lean.Elab.Term.Do.getDoIdDeclVar,[Lean.Syntax.getId, Lean.Syntax.getOp, OfNat.ofNat]]
[ExceptCpsT.runCatch_bind_throw,[rfl]]
[Lean.Meta.Cache.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Deriving.mkInstImplicitBinders,[Lean.Meta.forallBoundedTelescope, Lean.ConstantVal.type, Lean.InductiveVal.toConstantVal, Option.some, Lean.InductiveVal.numParams, Bind.bind, ForIn.forIn, MonadExcept.tryCatch, liftM, Lean.Meta.mkAppM, List.toArray, List.cons, List.nil, Lean.Meta.isTypeCorrect, ite, Eq, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.atom, Lean.mkIdent, PUnit.unit, MProd.mk, Unit.unit, MProd.fst, ForInStep.yield]]
[Nat.Up.WF,[Subrelation.wf, WellFoundedRelation.rel, measure, HSub.hSub, Nat.sub_lt_sub_left, WellFoundedRelation.wf]]
[Nat.succ_ne_zero,[]]
[Lean.Lsp.SymbolKind.enum.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[ST.instInhabitedRef.proof_1,[Nonempty.intro, arbitrary]]
[Lean.Elab.Tactic.AuxMatchTermState.mk.inj,[And.intro]]
[Lean.Parser.Syntax.sepBy,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.syntaxParser, Lean.Parser.strLit, Lean.Parser.optional, Lean.Parser.nonReservedSymbol, Bool.false]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.hBinOpHeuristic,[Bind.bind, MonadReader.read, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, andM, Pure.pure, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isHBinOp, orM, liftM, Lean.Meta.instantiateMVars, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.hasMVarAtCurrDepth, Array.getOp, OfNat.ofNat, ite, Eq, Bool.true, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.tryUnify, PUnit.unit]]
[instDecidableLe_2,[UInt16.decLe]]
[panic,[panicCore]]
[typedExpr,[]]
[And.noConfusionType,[]]
[Function.is_partial_inv,[Iff, Eq, Option.some]]
[Mathlib.Tactic.Lint.getDeclsInCurrModule,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Array.map, Prod.fst, List.toArray, Std.PersistentHashMap.toList, Lean.SMap.map₂, Lean.Environment.constants]]
[Std.HashMapImp.expand.proof_1,[Nat.mul_pos, Subtype.property, of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Declaration.opaqueDecl.injEq,[Eq.propIntro, Eq.refl, Lean.Declaration.opaqueDecl, Eq.symm, eq_of_heq, HEq.refl]]
[Function.injective,[Eq]]
[UInt64.one_def,[rfl]]
[Lean.Meta.setInlineAttribute,[Bind.bind, Lean.MonadEnv.getEnv, Lean.Meta.MetaM, Unit, Lean.Compiler.setInlineAttribute, Lean.setEnv, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[instTransEq_1,[Trans.mk, instTransEq_1.proof_1]]
[Std.HashMap.insert.proof_1,[Eq.refl, Std.HashMapImp.insert]]
[Lean.Parser.unicodeSymbol.formatter,[Lean.PrettyPrinter.Formatter.tokenWithAntiquot.formatter, Lean.PrettyPrinter.Formatter.unicodeSymbolNoAntiquot.formatter]]
[Mem.noConfusionType,[]]
[Tactic.Ring.Cache.mk.inj,[And.intro]]
[Decidable.noConfusionType,[]]
[recSubsingleton,[Subsingleton]]
[Lean.Meta.ElimEmptyInductive.M,[StateRefT', IO.RealWorld, Nat, Lean.Meta.MetaM]]
[Lean.Parser.Term.doAssert.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[not_and',[Iff.trans, not_and, imp_not_comm]]
[Lean.Widget.MsgEmbed.lazyTrace.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.AltCore.noConfusionType,[]]
[Lean.Meta.clear,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.MonadLCtx.getLCtx, ite, Eq, Lean.LocalContext.contains, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.throwTacticEx, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkFVar, Lean.Syntax.missing]]
[IO.FS.SystemTime.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FS.SystemTime.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.AbstractNestedProofs.isNonTrivialProof,[Bind.bind, Lean.Meta.isProof, ite, Eq, not, Bool.true, Pure.pure, Bool.false, Lean.Expr.withApp, or, Lean.Expr.isAtomic, Array.any, OfNat.ofNat, Array.size]]
[and_self_left,[Iff.intro, And.intro, And.left, And.right]]
[Lean.Elab.Term.expandShow,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, cond, Option.getD, Lean.Syntax.getHeadInfo?, Lean.Macro.throwUnsupported]]
[List.notElem,[not, List.elem]]
[Lean.Parser.ParserState.mergeErrors,[Lean.Parser.ParserState.mk, Option.none, Lean.Parser.ParserState, ite, Eq, BEq.beq, Bool.true, Array.shrink, Option.some, Lean.Parser.Error.merge]]
[Nat.add_assoc,[Eq, HAdd.hAdd, rfl, congrArg, Nat.succ, PProd.fst]]
[IO.Error.invalidArgument.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.leftArrow,[Lean.Parser.unicodeSymbol]]
[Lean.Parser.Tactic.rwSeq,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq, Lean.Parser.Tactic.location]]
[Lean.KeyedDeclsAttribute.mkStateOfTable,[Lean.KeyedDeclsAttribute.ExtensionState.mk, Lean.SMap.fold, List.foldl, Std.PersistentHashSet.insert, Lean.KeyedDeclsAttribute.OLeanEntry.declName, Lean.KeyedDeclsAttribute.AttributeEntry.toOLeanEntry, EmptyCollection.emptyCollection]]
[Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat.lt_of_le_of_lt]]
[IO.FS.Handle.readBinToEnd,[ByteArray.empty, IO.FS.Handle.readBinToEnd.loop]]
[Lean.Lsp.SymbolKind.operator.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Term.MutualClosure.pushLetRecs,[List.foldl, Array.push, Lean.Elab.PreDefinition.mk, Lean.Elab.Term.MutualClosure.LetRecClosure.ref, List.nil, Lean.Elab.Modifiers.mk, Lean.Elab.Modifiers.docString?, Lean.Elab.Modifiers.visibility, Lean.Elab.Modifiers.isNoncomputable, Lean.Elab.Modifiers.recKind, Lean.Elab.Modifiers.isUnsafe, Lean.Elab.Term.LetRecToLift.attrs, Lean.Elab.Term.MutualClosure.LetRecClosure.toLift, Lean.Elab.Term.LetRecToLift.declName]]
[Quotient.sound,[Quotient.sound.proof_1]]
[Nat.sub_add_eq_max,[le_total, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HSub.hSub, max, max_eq_right, Iff.mpr, Nat.sub_eq_zero_iff_le, OfNat.ofNat, Nat.zero_add, rfl, Eq.symm, max_eq_left, Nat.sub_add_cancel]]
[Lean.Widget.TaggedText.tag.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Widget.TaggedText.tag, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Level.addLit,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.numLit]]
[Lean.Xml.Parser.Char,[HOrElse.hOrElse, Lean.Parsec.attempt, Bind.bind, Lean.Parsec.anyChar, Pure.pure, Char.toNat, ite, Or, And, LE.le, OfNat.ofNat, Lean.Parsec.fail, Lean.Parsec.pchar, Char.ofNat, Lean.Xml.Parser.endl]]
[Lean.Lsp.DiagnosticWith.message,[]]
[Lean.Parsec.instReprParseResult,[Repr.mk, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, HAppend.hAppend, Std.Format.text, Std.Format.line, reprArg, Std.Format.FlattenBehavior.allOrNone]]
[Lean.Option.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Command.mkSimpleDelab,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Bind.bind, liftM, Lean.Macro.resolveGlobalName, Lean.Syntax.getId, List.nil, List.cons, Prod.mk, OptionT, Lean.MacroM, Lean.Syntax, guard, Array.all, Function.comp, Lean.Syntax.isIdent, Lean.Syntax.getAntiquotTerm, OfNat.ofNat, Array.size, Array.allDiff, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.mkIdent, Array.append, Alternative.failure]]
[Lean.Server.FileWorker.handlePlainTermGoal,[Bind.bind, Lean.Server.FileWorker.getInteractiveTermGoal, Pure.pure, Task.map, Except.map, Option.map, Lean.Lsp.PlainTermGoal.mk, ToString.toString, Lean.Widget.InteractiveGoal.pretty, Lean.Widget.InteractiveTermGoal.toInteractiveGoal, Lean.Widget.InteractiveTermGoal.range, Task.Priority.default]]
[Lean.Syntax.Traverser.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[if_simp_congr_prop,[if_ctx_simp_congr_prop]]
[Lean.AttributeApplicationTime.beforeElaboration.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Level.paren.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.levelParser.parenthesizer]]
[Lean.Literal.type,[Lean.Expr, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Lean.Elab.Tactic.tryCatch,[Bind.bind, Lean.MonadBacktrack.saveState, MonadExcept.tryCatch, Lean.Elab.Tactic.SavedState.restore]]
[Lean.IR.IRType.float.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.MonadNameGenerator.getNGen,[]]
[StateCpsT.runK_bind_get,[rfl]]
[Lean.Expr.constName!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Name, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Compiler.SpecArgKind.toCtorIdx,[OfNat.ofNat]]
[Lean.Widget.InfoPopup.noConfusionType,[]]
[Function.bijective,[And, Function.injective, Function.surjective]]
[Lean.Meta.SynthInstance.generate,[Bind.bind, Lean.Meta.SynthInstance.getTop, ite, Eq, BEq.beq, Lean.Meta.SynthInstance.GeneratorNode.currInstanceIdx, OfNat.ofNat, Bool.true, modify, Lean.Meta.SynthInstance.State.mk, Lean.Meta.SynthInstance.State.result?, Array.pop, Lean.Meta.SynthInstance.State.generatorStack, Lean.Meta.SynthInstance.State.resumeStack, Lean.Meta.SynthInstance.State.tableEntries, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.Elab.Level.State.noConfusionType,[]]
[List.mem_union_iff,[of_eq_true, Eq.trans, congr, congrArg, Iff, Mem.mem, List.nil_union, congrFun, Or, propext, List.mem_nil_iff, false_or, iff_self, List.cons_union, List.mem_insert_iff, Eq, List.mem_cons_iff, or_assoc]]
[Lean.MetavarDecl.index,[]]
[Quotient.lift,[Quot.lift]]
[Lean.KVMap.get?,[Option.bind, Lean.KVMap.find, Lean.KVMap.Value.ofDataValue?]]
[Array.foldr,[Id.run, Array.foldrM]]
[ByteArray.toUInt64LE!,[ite, Eq, BEq.beq, ByteArray.size, OfNat.ofNat, Bool.true, HOr.hOr, HShiftLeft.hShiftLeft, UInt8.toUInt64, ByteArray.get!, panicWithPosWithDecl, HAppend.hAppend]]
[Lean.Parser.Term.liftMethod.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.minPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.leftArrow.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[List.append_ne_nil_of_ne_nil_left,[of_eq_true, Eq.trans, implies_congr_ctx, ne_eq, List.nil, HAppend.hAppend, congrArg, Not, propext, List.append_eq_nil, congrFun, And, eq_false, Eq, false_and, eq_true_of_decide, Eq.refl, Bool.true, implies_true]]
[Lean.KernelException.appTypeMismatch.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.appTypeMismatch, Eq.symm, eq_of_heq, HEq.refl]]
[Int.ofNat_zero,[rfl]]
[instSubsingletonDecidable.proof_1,[Subsingleton.intro, Eq, Decidable.isTrue, rfl, absurd, Decidable.isFalse]]
[Lean.mkLocalDeclEx,[Lean.LocalDecl.cdecl]]
[Nat.lcm_dvd,[Dvd.dvd, Nat.lcm, Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, Nat.dvd_zero, Nat.dvd_of_mul_dvd_mul_left, Nat.gcd_pos_of_pos_left, Nat.pos_of_dvd_of_pos, HMul.hMul, Nat.gcd, Nat.gcd_mul_lcm, Eq.symm, Nat.gcd_mul_right, Nat.mul_comm, Nat.dvd_gcd, Nat.mul_dvd_mul_left, Nat.mul_dvd_mul_right]]
[Lean.Elab.TacticInfo.mctxAfter,[]]
[Lean.Server.Watchdog.tryWriteMessage,[Bind.bind, Lean.Server.Watchdog.findFileWorker?, Option.none, Lean.Server.Watchdog.ServerM, Unit, ST.Ref.modifyGet, Lean.Server.Watchdog.FileWorker.groupedEditsRef, Unit.unit, Prod, Bool, Option, Lean.Server.Watchdog.GroupedEdits, Prod.mk, Bool.true, Option.some, Lean.Server.Watchdog.GroupedEdits.mk, Lean.Server.Watchdog.GroupedEdits.applyTime, Lean.Server.Watchdog.GroupedEdits.params, Lean.Server.Watchdog.GroupedEdits.signalTask, Array.push, Lean.Server.Watchdog.GroupedEdits.queuedMsgs, Bool.false, ite, Eq, Pure.pure, PUnit.unit, MonadReader.read, liftM, IO.FS.Stream.putStrLn, Lean.Server.Watchdog.ServerContext.hLog, HAppend.hAppend, ToString.toString, Lean.Json.compress, Lean.ToJson.toJson]]
[IO.FS.Stream.Buffer.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.ParserModuleContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserModuleContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.ImportM.Context.noConfusionType,[]]
[Nat.Up.next,[And.intro, Nat.lt_succ_self]]
[Lean.Elab.Term.ToDepElimPattern.State.found,[]]
[instAddUSize,[Add.mk, USize.add]]
[Lean.Parser.Command.syntaxCat.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.Command.catBehavior.parenthesizer]]
[Lean.Lsp.CompletionList.items,[]]
[Lean.Elab.Tactic.forEachVar,[Bind.bind, ForIn.forIn, PUnit.unit, Lean.Elab.Tactic.withMainContext, Lean.Elab.Tactic.getFVarId, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.nil, Pure.pure, ForInStep.yield]]
[Lean.Elab.Term.Quotation.stxQuot.expand,[Bind.bind, Lean.Syntax.getQuotContent, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom]]
[Lean.Elab.Visibility.protected.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Macro,[Lean.MacroM, Lean.Syntax]]
[Function.injective2,[And, Eq]]
[List.hasDecidableLt.proof_3,[Eq.symm, eq_of_heq, Eq.refl, List.cons, HEq.refl, False, absurd]]
[Lean.Elab.Visibility.regular.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.FVarId.mk.injEq,[Eq.propIntro, Eq.refl, Lean.FVarId.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.InstanceEntry.priority,[]]
[Mathlib.Tactic.Lint.getLinter,[arbitrary]]
[withPtrEqDecEq.proof_1,[toBoolUsing_eq_true, Unit.unit]]
[and_imp,[Iff.intro, And.intro]]
[Lean.Parser.checkWsBefore,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.checkWsBeforeFn]]
[Std.HashSetImp.fold,[Std.HashSetImp.foldBuckets, Std.HashSetImp.buckets]]
[Lean.Elab.resolveGlobalConstNoOverloadWithInfo,[Bind.bind, Lean.resolveGlobalConstNoOverload, Lean.Elab.MonadInfoTree.getInfoState, ite, Eq, Lean.Elab.InfoState.enabled, Bool.true, Lean.mkConstWithLevelParams, Lean.Elab.pushInfoLeaf, Lean.Elab.Info.ofTermInfo, Lean.Elab.TermInfo.mk, Lean.Elab.ElabInfo.mk, Lean.Name.anonymous, Lean.LocalContext.empty, Pure.pure, PUnit.unit]]
[Lean.IR.LiveVars.collectExpr,[Lean.IR.LiveVars.Collector, Array.foldl, OfNat.ofNat, Array.size, Lean.IR.Arg.irrelevant, Std.RBTree.insert, Function.comp]]
[Lean.IR.EmitC.emitCInitName,[Bind.bind, Lean.IR.EmitC.toCInitName, Lean.IR.EmitC.emit]]
[Substring.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.mkRecursorValEx,[Lean.RecursorVal.mk, Lean.ConstantVal.mk]]
[Lean.Parser.takeWhile1Fn,[Lean.Parser.andthenFn, Lean.Parser.satisfyFn, Lean.Parser.takeWhileFn]]
[Lean.KernelException.alreadyDeclared.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.alreadyDeclared, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.addPreDefinitions,[Lean.Meta.withLCtx, Lean.LocalContext.mk, EmptyCollection.emptyCollection, Bind.bind, ForIn.forIn, PUnit.unit, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.type, Lean.Elab.PreDefinition.value, Pure.pure, ForInStep.yield, Array.mapM, liftM, StateRefT'.run, Lean.Meta.collectMVars, Lean.CollectMVars.State.mk, Lean.Meta.MetaM, Array, Lean.MVarId, Lean.CollectMVars.State.result, Lean.Elab.Term.logUnassignedUsingErrorInfos, Option.none, Lean.Meta.mkSorry, Array.isEmpty, Lean.Elab.throwAbortCommand, Array.map, List.toArray, Lean.Elab.liftMacroM, Lean.Elab.WF.expandTerminationHint, Lean.Elab.TerminationHints.terminationBy?, Lean.Elab.TerminationHints.decreasingBy?, MProd.mk, Lean.Elab.Term.TermElabM, Unit, Lean.Elab.WF.TerminationHint.ensureIsEmpty]]
[Lean.AttributeImplCore.mk.inj,[And.intro]]
[Lean.Elab.Command.StructView.noConfusionType,[]]
[LE.noConfusionType,[]]
[Std.Rbcolor.noConfusion,[noConfusionEnum, Std.Rbcolor.toCtorIdx]]
[Lean.Elab.Term.Do.ToCodeBlock.tryCatchPred,[or, Lean.Elab.Term.Do.CodeBlock.code, Array.any, Lean.Elab.Term.Do.ToCodeBlock.Catch.codeBlock, OfNat.ofNat, Array.size, Unit.unit, Bool, Bool.false]]
[Lean.PrettyPrinter.Formatter.unicodeSymbolNoAntiquot.formatter,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Lean.PrettyPrinter.FormatterM, Unit, ite, Eq, BEq.beq, String.trim, Bool.true, Lean.PrettyPrinter.Formatter.pushToken, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.MetavarContext.MkBinding.Exception.revertFailure.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MetavarContext.MkBinding.Exception.revertFailure, Eq.symm, eq_of_heq, HEq.refl]]
[FloatSpec.mk.inj,[And.intro]]
[instReprUInt64,[Repr.mk, repr, UInt64.toNat]]
[Lean.setOptionFromString,[Bind.bind, Pure.pure, List.nil, List.cons, IO, Lean.Options, Lean.getOptionDefaulValue, Lean.KVMap.setString, ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.KVMap.setBool, Bool.false, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Lean.KVMap.setName, String.toName, Unit.unit, String.toNat?, Lean.KVMap.setNat, String.toInt?, Lean.KVMap.setInt]]
[Lean.MonadEnv.modifyEnv,[]]
[FloatArray.mk.inj,[]]
[LawfulApplicative.map_pure,[]]
[Lean.PrettyPrinter.Formatter.Context.noConfusionType,[]]
[Lean.Elab.Term.Do.ToCodeBlock.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[«term∃!_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
[Lean.Parser.ParserInfo.firstTokens,[]]
[instLawfulMonadStateRefT'.proof_1,[inferInstanceAs, LawfulMonad, ReaderT, ST.Ref]]
[Lean.IR.EmitC.toCType,[Unit.unit, String, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.MetavarContext.MkBinding.Exception.noConfusionType,[]]
[Lean.Meta.DefEqContext.rhs,[]]
[instLEUInt32,[LE.mk, LE.le, UInt32.val]]
[Lean.Lsp.PlainGoalParams.noConfusionType,[]]
[is_dec_eq,[Eq]]
[Lean.Elab.Deriving.BEq.mkMutualBlock,[Bind.bind, ForIn.forIn, Lean.Elab.Deriving.BEq.mkAuxFunction, Pure.pure, PUnit.unit, ForInStep.yield, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Array.append, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil]]
[Lean.Elab.Term.elabHole,[Bind.bind, liftM, Lean.Meta.mkFreshExprMVar, Lean.MetavarKind.natural, Lean.Name.anonymous, Lean.Elab.Term.registerMVarErrorHoleInfo, Lean.Expr.mvarId!, Pure.pure]]
[IO.Error.alreadyExists.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Int.neg_neg,[Unit.unit, Eq, Neg.neg, rfl]]
[Substring.hasBeq,[BEq.mk, Substring.beq]]
[Lean.Elab.admitGoal,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.inferType, Lean.mkMVar, Lean.Meta.mkSorry, Bool.true, Lean.Meta.assignExprMVar]]
[String.Range.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, String.Range.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.setLevelNames,[modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState]]
[Lean.Lsp.DocumentSymbol.ibelow,[And, True]]
[Lean.Meta.Rewrite.Config.noConfusionType,[]]
[Lean.Meta.State.mctx,[]]
[Lean.Parser.Term.optExprPrecedence,[Lean.Parser.optional, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.maxPrec]]
[Lean.Lsp.WorkDoneProgressEnd.noConfusionType,[]]
[Lean.CollectLevelParams.State.noConfusionType,[]]
[LinearOrder.decidable_eq,[]]
[Lean.Meta.instInhabitedSimpEntry,[Inhabited.mk, Lean.Meta.SimpEntry.lemma, arbitrary]]
[Lean.Parser.Command.check,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser]]
[Zero.noConfusionType,[]]
[Lean.Parser.Command.openDecl,[HOrElse.hOrElse, Lean.Parser.Command.openHiding, Lean.Parser.Command.openRenaming, Lean.Parser.Command.openOnly, Lean.Parser.Command.openSimple, Lean.Parser.Command.openScoped]]
[Lean.JsonNumber.ltProp,[LT.mk, Eq, Lean.JsonNumber.lt, Bool.true]]
[Lean.IR.ExplicitBoxing.withParams,[MonadWithReader.withReader, Lean.IR.ExplicitBoxing.BoxingContext.mk, Lean.IR.ExplicitBoxing.BoxingContext.f, Lean.IR.LocalContext.addParams, Lean.IR.ExplicitBoxing.BoxingContext.localCtx, Lean.IR.ExplicitBoxing.BoxingContext.resultType, Lean.IR.ExplicitBoxing.BoxingContext.decls, Lean.IR.ExplicitBoxing.BoxingContext.env]]
[ExistsUnique,[Exists, And, Eq]]
[Lean.Elab.Info.ofTacticInfo.inj,[]]
[Lean.KeyedDeclsAttribute.OLeanEntry.declName,[]]
[Tactic.Ring.HornerExpr.pp,[Lean.Meta.MetaM, Std.Format, Bind.bind, Lean.PrettyPrinter.ppExpr, Lean.Name.anonymous, List.nil, Pure.pure, HAppend.hAppend, Std.Format.text, ToString.toString, PProd.fst, PProd.snd, Prod.fst]]
[List.mem_join,[Unit.unit, Iff, Mem.mem, List.join, Exists, And, of_eq_true, Eq.trans, congr, congrArg, List.join_nil, propext, List.mem_nil_iff, funext, congrFun, false_and, eq_false, exists_false, eq_true_of_decide, Eq.refl, Bool.true, Eq.mpr, List.mem_append, Or, PProd.fst, List.cons, Iff.intro, Exists.intro, And.intro, Or.inl, rfl, Or.inr, Eq.symm, eq_of_heq, HEq.refl]]
[Std.Format.sbracket,[Std.Format.bracket]]
[Tactic.TryThis.addSuggestion,[Lean.Elab.logInfoAt, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[UInt64.decLe,[Decidable, LE.le, inferInstanceAs]]
[Lean.Parser.Attr.notationClass,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser]]
[Std.ShareCommon.ObjectSet,[Std.HashSet, Std.ShareCommon.Object]]
[Lean.Elab.Term.LetIdDeclView.noConfusionType,[]]
[Lean.Meta.IndPredBelow.Variables.indVal,[]]
[Char.instDecidableLe,[UInt32.decLe, Char.val]]
[Lean.Level.PP.Result.imax,[Lean.Level.PP.Result.leaf, Lean.Level.PP.Result.num, Lean.Level.PP.Result.offset, Lean.Level.PP.Result.maxNode, Lean.Level.PP.Result, Lean.Level.PP.Result.imaxNode, List.cons, List.nil]]
[Lean.Meta.Simp.synthesizeArgs,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, Unit.unit, Lean.Meta.Simp.SimpM, ForInStep, MProd, Option, Bool, Subarray, Lean.BinderInfo, Stream.next?, Pure.pure, ForInStep.done, liftM, Lean.Meta.inferType, ite, Eq, Lean.BinderInfo.isInstImplicit, Bool.true, PUnit.unit, ForInStep.yield, Option.some, Bool.false, Lean.Meta.instantiateMVars, Lean.Expr.isMVar, Lean.Meta.isProp, Lean.Meta.isDefEq, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Meta.isClass?, Option.isSome, MProd.fst, Lean.Meta.Simp.synthesizeArgs.synthesizeInstance]]
[Lean.Meta.Config.unificationHints,[]]
[UInt32.noConfusionType,[]]
[Lean.IR.IsLive.visitArg,[Pure.pure, Lean.IR.HasIndex.visitArg]]
[Lean.IR.NormalizeIds.withParams,[Bind.bind, Array.foldlM, getModify, HAdd.hAdd, OfNat.ofNat, Pure.pure, Std.RBMap.insert, Lean.IR.VarId.idx, Lean.IR.Param.x, Array.size]]
[Lean.LocalContext.firstDeclM,[Bind.bind, Lean.LocalContext.findDeclM?, Function.comp, optional, Unit.unit, Alternative.failure, Pure.pure]]
[Lean.Elab.Command.CtorView.binders,[]]
[Lean.PrettyPrinter.Parenthesizer.instMonadTraverserParenthesizerM,[Lean.Syntax.MonadTraverser.mk, MonadState.mk, Functor.map, Lean.PrettyPrinter.Parenthesizer.State.stxTrav, MonadState.get, modify, Lean.PrettyPrinter.Parenthesizer.State.mk, Lean.PrettyPrinter.Parenthesizer.State.contPrec, Lean.PrettyPrinter.Parenthesizer.State.contCat, Lean.PrettyPrinter.Parenthesizer.State.minPrec, Lean.PrettyPrinter.Parenthesizer.State.trailPrec, Lean.PrettyPrinter.Parenthesizer.State.trailCat, Lean.PrettyPrinter.Parenthesizer.State.visitedToken, MonadState.modifyGet, Prod, Lean.PrettyPrinter.Parenthesizer.State, Prod.mk]]
[Subtype.coe_injective,[Subtype.ext]]
[Set.instInterSet,[Inter.mk, Set.inter]]
[Lean.Elab.Term.LValResolution.projFn.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LValResolution.projFn, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Server.RequestContext.noConfusionType,[]]
[Lean.Syntax.getArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Array, Lean.Syntax, Array.empty]]
[Lean.Elab.getDeclarationSelectionRef,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, not, Lean.Syntax.isNone, Lean.Syntax.getOp, OfNat.ofNat, Lean.Syntax.isIdent]]
[Lean.expandBrackedBinders,[Bind.bind, Lean.MonadRef.getRef, Lean.expandBrackedBindersAux, List.toArray, List.cons, List.nil]]
[Classical.strongIndefiniteDescription,[dite, Exists, Subtype.mk, Classical.choice, Classical.strongIndefiniteDescription.proof_2]]
[Lean.Elab.Term.SavedState.mk.inj,[And.intro]]
[Nat.ctor_eq_zero,[rfl]]
[Std.HashMap.insert,[Std.HashMap, Std.HashMapImp.insert, Std.HashMap.insert.proof_1, Subtype.mk, Std.HashMap.insert.proof_2]]
[Lean.Meta.ByCasesSubgoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.ByCasesSubgoal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Delaborator.delabNamedPattern,[Bind.bind, MonadReader.read, guard, Eq, Lean.PrettyPrinter.Delaborator.Context.inPattern, Bool.true, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, BEq.beq, Lean.Expr.getAppNumArgs, OfNat.ofNat, Lean.PrettyPrinter.Delaborator.SubExpr.withAppFn, Lean.PrettyPrinter.Delaborator.SubExpr.withAppArg, Lean.PrettyPrinter.Delaborator.delab, Lean.Syntax.isIdent, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Lean.Meta.Instances.discrTree,[]]
[Lean.Elab.Level.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MetavarContext.getDelayedAssignment?,[Std.PersistentHashMap.find?, Lean.MetavarContext.dAssignment]]
[Std.RBTree.ofList,[Unit.unit, Std.RBTree, Std.mkRBTree, Std.RBTree.insert, PProd.fst]]
[Lean.Elab.Command.StructFieldView.type?,[]]
[Lean.Elab.Term.StructInst.markDefaultMissing,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.JsonRpc.ErrorCode.noConfusionType,[noConfusionTypeEnum, Lean.JsonRpc.ErrorCode.toCtorIdx]]
[Lean.Elab.Command.expandMixfix,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Lean.Syntax.isNone, Unit.unit, Option.none, Option.some, Lean.Macro.throwUnsupported, Lean.Elab.Command.expandMixfix.withAttrKindGlobal]]
[Lean.IR.FnBody.flatten,[Lean.IR.flattenAux, List.toArray, List.nil]]
[Lean.Parser.Level.hole.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.EnumAttributes.mk.inj,[And.intro]]
[Lean.Meta.Match.MatcherResult.matcher,[]]
[MonadStateOf.set,[]]
[Lean.Parser.Command.infixr.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.TransformStep.visit.inj,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.fType,[]]
[Lean.Elab.Term.elabTypeOf,[Bind.bind, Lean.Elab.Term.elabTerm, Lean.Syntax.getOp, OfNat.ofNat, Option.none, Bool.true, liftM, Lean.Meta.inferType]]
[Array.findM?,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, ite, Eq, Bool.true, Pure.pure, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, Option, MProd.fst]]
[Lean.LocalDecl.setValue,[Lean.LocalDecl.cdecl, Lean.LocalDecl, Lean.LocalDecl.ldecl]]
[Lean.PrettyPrinter.Delaborator.delabNameMkNum,[Lean.PrettyPrinter.Delaborator.delabNameMkStr]]
[Lean.Meta.DiscrTree.mk.inj,[]]
[Mathlib.ExtendedBinder.extBinderParenthesized,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Mathlib.ExtendedBinder.extBinder]]
[Lean.Compiler.SpecInfo.mutualDecls,[]]
[Lean.ConstantInfo.hints,[Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.ReducibilityHints, Lean.ReducibilityHints.opaque]]
[Lean.Parser.categoryParserOfStackFn,[ite, LT.lt, Array.size, HAdd.hAdd, OfNat.ofNat, Lean.Parser.ParserState.mkUnexpectedError, List.nil, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Parser.ParserState, Array.get!, HSub.hSub, Lean.Parser.categoryParserFn]]
[Lean.CollectLevelParams.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.instToExprBool,[Lean.ToExpr.mk, ite, Eq, Bool.true, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Lean.IR.UnreachableBranches.Value.top.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Declaration.opaqueDecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.registerSimpAttr,[Bind.bind, Lean.Meta.mkSimpExt, Lean.Meta.mkSimpAttr, Pure.pure]]
[Lean.Parser.Syntax.sepBy.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.syntaxParser.formatter, Lean.Parser.strLit.formatter, Lean.Parser.optional.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false]]
[instAddNat,[Add.mk, Nat.add]]
[instDecidableEqSum,[Decidable, Eq, dite, Decidable.isTrue, instDecidableEqSum.proof_1, Decidable.isFalse, instDecidableEqSum.proof_2, instDecidableEqSum.proof_3, instDecidableEqSum.proof_4, instDecidableEqSum.proof_5, instDecidableEqSum.proof_6]]
[Array.push,[Array.mk, List.concat, Array.data]]
[Std.Range.instForMRangeNat,[ForM.mk, Std.Range.forM]]
[Function.injective2.left,[And.left]]
[dif_ctx_simp_congr,[dif_ctx_congr]]
[Lean.Meta.reduce,[Lean.MonadCacheT.run, Lean.Meta.reduce.visit]]
[Lean.ProjectionFunctionInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ProjectionFunctionInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Function.has_left_inverse.injective,[Exists.elim, Function.left_inverse.injective]]
[notM,[Functor.map, not]]
[IO.Process.StdioConfig.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.ParserState.cache,[]]
[Lean.Elab.Term.elabLevel,[Lean.Elab.Term.liftLevelM, Lean.Elab.Level.elabLevel]]
[Lean.MonadResolveName.getCurrNamespace,[]]
[Lean.Lsp.DidOpenTextDocumentParams.noConfusionType,[]]
[Std.HashSet.instEmptyCollectionHashSet,[EmptyCollection.mk, Std.mkHashSet, OfNat.ofNat]]
[true_implies,[propext, Iff.intro, trivial]]
[Lean.Meta.intro1,[Lean.Meta.intro1Core, Bool.false]]
[LinearOrder.decidable_lt,[]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.discrs,[]]
[Lean.Parser.Tactic.lift,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.binderIdent]]
[Lean.Lsp.instToJsonInitializeResult,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.InitializeResult.capabilities, List.nil, Lean.Json.opt, Lean.Lsp.InitializeResult.serverInfo?]]
[Eq.trans,[]]
[Nat.gcd_one_right,[Eq.trans, Nat.gcd_comm, OfNat.ofNat, Nat.gcd_one_left]]
[Std.PersistentHashMap.mkEmptyEntries,[Std.PersistentHashMap.Node.entries, Std.PersistentHashMap.mkEmptyEntriesArray]]
[Lean.Parser.longestMatchStep,[Unit.unit, Prod, Lean.Parser.ParserState, Nat, Lean.Parser.ParserState.errorMsg, ite, Eq, or, Decidable.decide, GT.gt, Lean.Parser.ParserState.pos, and, BEq.beq, Bool.true, Prod.mk, Lean.Parser.ParserState.replaceLongest, LT.lt, Lean.Parser.ParserState.mk, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.cache, Nat.min, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.keepNewError, Lean.Parser.ParserState.keepPrevError, Lean.Parser.ParserState.mergeErrors, Lean.Parser.ParserState.pushSyntax]]
[Lean.PrettyPrinter.Delaborator.SubExpr.mkRoot,[Lean.PrettyPrinter.Delaborator.SubExpr.mk, OfNat.ofNat]]
[instHModUInt64NatUInt64,[HMod.mk, UInt64.modn]]
[Lean.MetavarContext.LevelMVarToParam.Context.noConfusionType,[]]
[HOrElse.noConfusionType,[]]
[UInt32.ofNat',[UInt32.mk, Fin.mk]]
[Lean.SimplePersistentEnvExtension.setState,[Lean.PersistentEnvExtension.modifyState, Prod, List, Prod.mk]]
[Lean.Parser.PrattParsingTables.trailingParsers,[]]
[Lean.Meta.CaseValuesSubgoal.noConfusionType,[]]
[Lean.Lsp.TextDocumentChangeRegistrationOptions.documentSelector?,[]]
[Lean.SCC.State.noConfusionType,[]]
[Lean.Syntax.getRange?,[Option.none, Option.some, Option, String.Range, Lean.Syntax.getPos?, Lean.Syntax.getTailPos?, String.Range.mk]]
[Nat.pos_of_ne_zero,[Or.resolve_left, Nat.eq_zero_or_pos]]
[Function.comp.right_id,[rfl]]
[Lean.IR.EmitC.emitCtorSetArgs,[Nat.forM, Array.size, Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitArg, Array.getOp, Lean.IR.EmitC.emitLn]]
[instSemiringFin.proof_13,[]]
[Lean.Meta.IndPredBelow.mkCtorType.mkBelowBinder,[Lean.Meta.forallTelescopeReducing, Lean.Expr.withApp, Option.none, Lean.Meta.MetaM, Lean.Expr.constName?, Array.findIdx?, Lean.Meta.IndPredBelow.Context.typeInfos, BEq.beq, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Bind.bind, Lean.Meta.mkForallFVars, Bool.false, Bool.true, Lean.Meta.IndPredBelow.mkCtorType.copyVarName, Lean.Expr.fvarId!, Lean.Meta.withLocalDecl, Lean.Expr.binderInfo, Unit.unit]]
[IO.AccessRight.execution,[]]
[Lean.Elab.Command.getTerminationHints,[ite, Eq, or, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.TerminationHints.mk, Lean.Syntax.getOptional?, Array.getOp, HSub.hSub, Array.size, OfNat.ofNat]]
[instMonadFinallyStateRefT',[inferInstanceAs, MonadFinally, ReaderT, ST.Ref]]
[Lean.Elab.addNonRec,[Lean.withRef, Lean.Elab.PreDefinition.ref, Bind.bind, liftM, Lean.Elab.abstractNestedProofs, Lean.MonadEnv.getEnv, Lean.addDecl, Lean.Elab.withSaveInfoContext, Lean.mkConstWithLevelParams, Lean.Elab.PreDefinition.declName, Lean.Elab.Term.addTermInfo, Option.none, Lean.Name.anonymous, Bool.true, Lean.Elab.applyAttributesOf, List.toArray, List.cons, List.nil, Lean.AttributeApplicationTime.afterTypeChecking, ite, Eq, and, not, Lean.Elab.DefKind.isTheorem, Lean.Elab.PreDefinition.kind, Lean.Elab.Modifiers.isNoncomputable, Lean.Elab.PreDefinition.modifiers, MonadExcept.tryCatch, Lean.compileDecl, Pure.pure, DoResultPR.pure, PUnit.unit, MonadReader.read, Lean.Elab.Term.Context.isNoncomputableSection, DoResultPR.return, Bool.false, MonadExcept.throw, Lean.Elab.Term.TermElabM, Bool, Unit.unit]]
[Lean.Meta.introN,[Lean.Meta.introNCore, Bool.false]]
[Lean.Server.Watchdog.FileWorker.runEditsSignalTask,[Bind.bind, liftM, IO.asTask, Task.Priority.default, Pure.pure, Task.map, Lean.Server.Watchdog.WorkerEvent, Lean.Server.Watchdog.WorkerEvent.ioError, Lean.Server.Watchdog.FileWorker.runEditsSignalTask.loopAction]]
[String.contains,[String.any, BEq.beq]]
[Lean.Core.instMonadRecDepthCoreM,[Lean.MonadRecDepth.mk, MonadWithReader.withReader, Lean.Core.Context.mk, Lean.Core.Context.options, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats, Bind.bind, MonadReader.read, Pure.pure, Lean.Core.Context.currRecDepth]]
[proofIrrel,[rfl]]
[Lean.Server.FileWorker.ElabTaskError.ioError.inj,[]]
[Nat.find_x.proof_1,[And.intro]]
[instShiftRightUSize,[ShiftRight.mk, USize.shiftRight]]
[Lean.Parser.Term.byTactic,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Tactic.tacticSeq]]
[Lean.Parser.Command.optNamedName.formatter,[Lean.Parser.optional.formatter, Lean.Parser.Command.namedName.formatter]]
[Lean.KVMap.instBEqKVMap,[BEq.mk, Lean.KVMap.eqv]]
[Lean.Elab.FieldInfo.noConfusionType,[]]
[Lean.Parser.Term.pipeProj.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.minPrec, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.fieldIdx.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.many.formatter, Lean.Parser.Term.argument.formatter]]
[Equiv.trans.proof_1,[Function.left_inverse.comp, Equiv.leftInv]]
[Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.mk.inj,[And.intro]]
[Lean.Lsp.instToJsonRpcKeepAliveParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.RpcKeepAliveParams.uri, List.nil, Lean.Lsp.RpcKeepAliveParams.sessionId]]
[Lean.Elab.Term.toParserDescr.isValidAtom,[and, not, String.isEmpty, bne, String.getOp, OfNat.ofNat, Char.ofNat, BEq.beq, or, String.bsize, Lean.isIdFirst, Lean.isIdBeginEscape, Char.isDigit]]
[Lean.Parser.identFn,[ite, Eq, and, not, Lean.Parser.ParserState.hasError, Lean.Syntax.isIdent, Array.back, Lean.Parser.ParserState.stxStack, Bool.true, Lean.Parser.ParserState.mkErrorAt, Option.some]]
[Lean.Level.PP.Result.leaf.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.InjectionResultCore.noConfusionType,[]]
[Lean.IR.ExpandResetReuse.isSelfSSet,[Option.none, Option.some, Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.fap, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Bool, Std.HashMap.find?, Lean.IR.ExpandResetReuse.Context.projMap, and, BEq.beq, Bool.false]]
[Equiv.noConfusionType,[]]
[decidable_of_bool.proof_2,[mt, Iff.mpr, Bool.ff_ne_tt]]
[Std.HashSetImp.mk.inj,[And.intro]]
[instHModUInt32NatUInt32,[HMod.mk, UInt32.modn]]
[Lean.MessageDataContext.lctx,[]]
[Lean.Expr.app4?,[ite, Eq, Lean.Expr.isAppOfArity, OfNat.ofNat, Bool.true, Option.some, Prod.mk, Lean.Expr.appArg!, Lean.Expr.appFn!, Option.none]]
[Lean.Expr.getOptParamDefault?,[ite, Eq, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Bool.true, Option.some, Lean.Expr.appArg!, Option.none]]
[Lean.PrettyPrinter.FormatterM,[ReaderT, Lean.PrettyPrinter.Formatter.Context, StateRefT', IO.RealWorld, Lean.PrettyPrinter.Formatter.State, Lean.Core.CoreM]]
[Lean.Meta.Match.getMkMatcherInputInContext,[Bind.bind, Lean.Meta.getMatcherInfo?, Option.none, Lean.Meta.MetaM, Lean.Meta.Match.MkMatcherInput, Lean.getConstInfo, Lean.Meta.instantiateForall, Lean.ConstantInfo.type, HAppend.hAppend, Lean.Meta.MatcherApp.params, List.toArray, List.cons, Lean.Meta.MatcherApp.motive, List.nil, Lean.Meta.forallBoundedTelescope, Option.some, Lean.Meta.Match.MatcherInfo.numDiscrs, Lean.Meta.mkForallFVars, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.Elab.InfoTree.ofJson.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Std.PersistentHashMap.Node.entries.injEq,[Eq.propIntro, Eq.refl, Std.PersistentHashMap.Node.entries, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.RecursorInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.RecursorInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Command.State.nextInstIdx,[]]
[Std.PersistentHashMap.maxCollisions,[OfNat.ofNat]]
[Lean.Compiler.mkUIntLit,[Lean.mkApp, Lean.mkConst, Lean.Compiler.NumScalarTypeInfo.ofNatFn, List.nil, Lean.mkRawNatLit, HMod.hMod, Lean.Compiler.NumScalarTypeInfo.size]]
[«term_^_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instToStringFin,[ToString.mk, ToString.toString, Fin.val]]
[Lean.Meta.Match.State.noConfusionType,[]]
[Std.Format.append.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.Format.append, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.le_of_eq,[Nat.le_refl]]
[Int.negSucc_ofNat_ofNat,[rfl]]
[Lean.Parser.Command.catBehaviorBoth,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.nonReservedSymbol, Bool.false]]
[«term-[1+_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.PrettyPrinter.Formatter.getStack,[Bind.bind, MonadState.get, Pure.pure, Lean.PrettyPrinter.Formatter.State.stack]]
[Lean.Widget.TaggedText.append.inj,[]]
[Function.Equiv.isEquivalence,[Equivalence.mk, Function.Equiv.refl, Function.Equiv.symm, Function.Equiv.trans]]
[Lean.Compiler.atMostOnce.visit,[Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lit, Lean.Compiler.atMostOnce.Visitor, Lean.Compiler.atMostOnce.visitFVar, HAndThen.hAndThen, PProd.fst, PProd.snd, Lean.Compiler.atMostOnce.skip]]
[List.forall_mem_map_iff,[Iff.intro, List.mem_map_of_mem, Iff.mp, List.mem_map, Eq.mpr, Eq.refl]]
[Lean.Lsp.HoverParams.noConfusionType,[]]
[Lean.Widget.InfoWithCtx.noConfusionType,[]]
[Nat.sub_mul_div,[Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HSub.hSub, HMul.hMul, OfNat.ofNat, Nat.div_zero, Nat.zero_sub, rfl, Eq.symm, Nat.zero, Nat.mul_zero, Nat.sub_zero]]
[Int.instMulInt,[Mul.mk, Int.mul]]
[USize.instSemiringUSize.proof_1,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, USize.zero_def, USize.add_def, USize.mk, OfNat.ofNat, add_zero, USize.val, USize.mk_val_eq, eq_self, propext, forall_const, USize]]
[Lean.Meta.normalizeLevel,[Bind.bind, Lean.Meta.instantiateLevelMVars, Pure.pure, Lean.Level.normalize]]
[Lean.getOptionDecls,[ST.Ref.get]]
[instHashableUInt8,[Hashable.mk, UInt8.toUInt64]]
[Lean.Meta.fullApproxDefEq,[Lean.Meta.mapMetaM, Lean.Meta.withConfig, Lean.Meta.Config.mk, Bool.true, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct]]
[Lean.Elab.Command.mkDefViewOfExample,[Lean.Elab.DefView, Lean.Elab.DefView.mk, Lean.Elab.DefKind.example, Option.some, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Syntax.isNone,[Unit.unit, Lean.Syntax.atom, Lean.Syntax.ident, Bool, and, BEq.beq, Lean.nullKind, Array.size, OfNat.ofNat, Bool.true, Bool.false]]
[Lean.Syntax.isAntiquotSuffixSplice,[Option.isSome, Lean.Syntax.antiquotSuffixSplice?]]
[or_false,[propext, Iff.intro, False.elim, Or.inl]]
[Lean.Lsp.Position.noConfusionType,[]]
[DecidableEq,[Decidable, Eq]]
[instOrdUInt32,[Ord.mk, compareOfLessAndEq]]
[String.Iterator.toString,[String]]
[List.instLEList,[LE.mk, List.le]]
[String.Iterator.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, String.Iterator.mk, Eq.symm, eq_of_heq, HEq.refl]]
[emptyRelation,[False]]
[Nat.succ_add_eq_succ_add,[of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.succ_add, Nat.add_succ, eq_self, Nat.succ, HAdd.hAdd]]
[Lean.Meta.SplitIf.splitIfAt?,[Option.none, Lean.Meta.MetaM, Option, Prod, Lean.Meta.ByCasesSubgoal, Lean.Meta.SplitIf.findIfToSplit?, Unit.unit, Bind.bind, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure]]
[Lean.Elab.DefView.ref,[]]
[Function.Equiv.trans,[Eq.trans]]
[Array.foldlMUnsafe,[ite, LT.lt, LE.le, Array.size, USize.ofNat, Pure.pure, Array.foldlMUnsafe.fold]]
[Pure.noConfusionType,[]]
[Nonempty.elim.proof_1,[]]
[Lean.Elab.Command.elabOpenPrivate,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Lean.Elab.throwUnsupportedSyntax]]
[Lean.AttributeImpl.toAttributeImplCore,[]]
[Lean.Elab.OpenDecl.State.noConfusionType,[]]
[Lean.KernelException.exprTypeMismatch.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.exprTypeMismatch, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.extends.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.termParser.formatter, Bool.false]]
[Std.HashMap.insert'.proof_1,[Eq.refl, Std.HashMapImp.insert]]
[Lean.Elab.Term.ElabAppArgs.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Std.PersistentHashMap.mul2Shift,[USize.shiftLeft]]
[Lean.Elab.PreDefinition.modifiers,[]]
[Lean.Elab.Command.StructView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.simpArg,[Lean.ParserDescr.binary, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.Tactic.simpStar, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma]]
[Lean.Elab.printImports,[Bind.bind, Lean.Elab.parseImports, IO, Unit, ForIn.forIn, PUnit.unit, Lean.findOLean, Lean.Import.module, IO.println, Pure.pure, ForInStep.yield]]
[Lean.instEmptyCollectionPrefixTree,[EmptyCollection.mk, Lean.PrefixTree.empty]]
[IO.Error.unsatisfiedConstraints.inj,[And.intro]]
[Nat.le.brecOn,[Nat.le.below.refl, Nat.le.below.step]]
[Lean.PrettyPrinter.Parenthesizer.charLit.parenthesizer,[Lean.Parser.Term.char.parenthesizer]]
[Lean.Meta.Match.Unify.State.fvarSubst,[]]
[Lean.Parser.mkParserContext,[Lean.Parser.ParserContext.mk, OfNat.ofNat, Lean.Parser.getTokenTable, Lean.Parser.ParserModuleContext.env]]
[Lean.Elab.Command.elabEvalUnsafe,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, MonadReader.read, Lean.MonadEnv.getEnv, Lean.Environment.contains, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Parser.Tactic.rcasesPat.one,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.const]]
[Lean.Server.Watchdog.ServerEvent.clientError.injEq,[Eq.propIntro, Eq.refl, Lean.Server.Watchdog.ServerEvent.clientError, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.Borrow.ParamMap.Key.jp.inj,[And.intro]]
[Lean.Meta.splitLocalDecl?,[Lean.commitWhenSome?, Lean.Meta.withMVarContext, Bind.bind, Lean.MonadEnv.getEnv, Lean.Meta.inferType, Lean.mkFVar, Lean.Meta.instantiateMVars, Option.none, Lean.Meta.MetaM, Option, List, Lean.MVarId, Lean.Meta.Split.findSplit?, ite, Eq, or, Lean.Expr.isIte, Lean.Expr.isDIte, Bool.true, Lean.Meta.splitIfLocalDecl?, Pure.pure, Option.map, List.cons, List.nil, Lean.Meta.revert, List.toArray, Bool.false, Lean.Meta.Split.splitMatch, List.mapM, Lean.Meta.introNP, Prod.snd, Option.some]]
[Lean.Parser.Term.sort,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.checkWsBefore, Lean.Parser.checkPrec, Lean.Parser.leadPrec, Lean.Parser.checkColGt, Lean.Parser.levelParser, Lean.Parser.maxPrec]]
[Nat.lt_trichotomy,[Nat.lt_by_cases, Or.inl, Function.comp, Or.inr]]
[Lean.MonadRef.getRef,[]]
[Lean.Elab.DefView.type?,[]]
[Lean.findDeclarationRangesCore?,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.MapDeclarationExtension.find?, Lean.declRangeExt]]
[UInt16.one_def,[rfl]]
[Lean.Parser.Attr.normCast,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[CoeTail.coe,[]]
[Lean.IR.Param.x,[]]
[Lean.SMap.insert',[Lean.SMap, Lean.SMap.mk, Bool.true, Std.HashMap.insert, Bool.false, Std.PersistentHashMap.insert]]
[if_ctx_congr,[Eq, ite, absurd, Iff.mp, not_iff_not_of_iff, Iff.mpr]]
[Lean.Parser.epsilonInfo,[Lean.Parser.ParserInfo.mk, Lean.Parser.FirstTokens.epsilon]]
[ne_false_of_self,[]]
[Std.PersistentArray.tail,[]]
[Lean.NameSanitizerState.nameStem2Idx,[]]
[Lean.Meta.Match.Unify.M,[ReaderT, Lean.Meta.Match.Unify.Context, StateRefT', IO.RealWorld, Lean.Meta.Match.Unify.State, Lean.Meta.MetaM]]
[Lean.Parser.Command.structFields,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.manyIndent, HAndThen.hAndThen, Lean.Parser.ppLine, Lean.Parser.checkColGe, HOrElse.hOrElse, Lean.Parser.Command.structExplicitBinder, Lean.Parser.Command.structImplicitBinder, Lean.Parser.Command.structInstBinder, Lean.Parser.Command.structSimpleBinder]]
[Lean.Parser.Term.haveEqnsDecl.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.haveIdLhs.formatter, Lean.Parser.Term.matchAlts.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Bool.false]]
[Lean.Lsp.instToJsonTextDocumentIdentifier,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentIdentifier.uri, List.nil]]
[Lean.Meta.Closure.MkValueTypeClosureResult.value,[]]
[Lean.Expr.Data.hasLevelMVar,[BEq.beq, UInt64.land, UInt64.shiftRight, OfNat.ofNat]]
[Lean.Elab.Term.Quotation.precheckIdent,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Elab.Term.Quotation.PrecheckM, Unit, ite, Eq, not, List.isEmpty, Bool.true, Pure.pure, PUnit.unit, Bind.bind, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Parser.Syntax.subPrec,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.Match.addMatcherInfo,[Lean.MonadEnv.modifyEnv, Lean.Meta.Match.Extension.addMatcherInfo]]
[Nat.one_add,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Nat.add_comm, OfNat.ofNat, Nat.succ, eq_self, HAdd.hAdd]]
[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer,[Bind.bind, MonadState.get, HOrElse.hOrElse]]
[Lean.IR.UnreachableBranches.findVarValue,[Bind.bind, MonadReader.read, MonadState.get, Pure.pure, Std.HashMap.findD, Lean.IR.UnreachableBranches.Value.bot]]
[Iff.elim,[Iff.elim.proof_1]]
[Quotient.inductionOn,[Quot.inductionOn]]
[Lean.InductiveType.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.Param.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Param.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Syntax.getId,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Name, Lean.Name.anonymous]]
[Lean.Elab.Term.CollectPatternVars.State.noConfusionType,[]]
[Float.ofNat,[OfScientific.ofScientific, Bool.false, OfNat.ofNat]]
[fix3,[fixCore3, arbitrary]]
[Lean.Parser.Term.matchDiscr.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.PrettyPrinter.Parenthesizer.evalInsideQuot.parenthesizer, Lean.Parser.Term.matchDiscr.parenthesizer]]
[Nat.sub_add_comm,[Iff.mpr, Nat.sub_eq_iff_eq_add, Nat.le_trans, Nat.le_add_right, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HSub.hSub, Nat.add_right_comm, Nat.sub_add_cancel, rfl]]
[Lean.Lsp.instToJsonLeanFileProgressParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.LeanFileProgressParams.textDocument, List.nil, Lean.Lsp.LeanFileProgressParams.processing]]
[Lean.Elab.Term.MutualClosure.LetRecClosure.ref,[]]
[String.isEmpty,[BEq.beq, String.bsize, OfNat.ofNat]]
[Lean.Meta.DiscrTree.Key.arity,[Lean.Meta.DiscrTree.Key.lit, Lean.Meta.DiscrTree.Key.star, Lean.Meta.DiscrTree.Key.other, Unit.unit, Nat, OfNat.ofNat]]
[Lean.Export.Entry.expr.injEq,[Eq.propIntro, Eq.refl, Lean.Export.Entry.expr, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.RpcKeepAliveParams.mk.inj,[And.intro]]
[Lean.IR.Borrow.OwnedSet.getHash,[UInt64, mixHash, Hashable.hash]]
[Lean.PersistentEnvExtensionDescr.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Closure.preprocess,[Bind.bind, liftM, Lean.Meta.instantiateMVars, MonadReader.read, ite, Eq, not, Lean.Meta.Closure.Context.zeta, Bool.true, Lean.Meta.check, Pure.pure, PUnit.unit]]
[fix4,[fixCore4, arbitrary]]
[Lean.mkLHSGoal,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.IR.Alt.ctor,[Lean.IR.AltCore.ctor]]
[Lean.Lsp.InitializeParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Set.instSdiffSet,[Sdiff.mk, Set.diff]]
[instOrdString,[Ord.mk, compareOfLessAndEq]]
[Lean.Parser.Term.tupleTail.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.termParser.parenthesizer, Bool.false]]
[Lean.Server.Completion.HoverInfo.inside.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Set.instSubsetSet,[Subset.mk, Set.subset]]
[Lean.MetavarContext.UnivMVarParamResult.expr,[]]
[Lean.getBuiltinAttributeNames,[Bind.bind, ST.Ref.get, Lean.attributeMapRef, Pure.pure, Std.PersistentHashMap.foldl, List.cons, List.nil]]
[Lean.Meta.Match.Problem.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.Problem.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.typeOf,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.maxPrec]]
[StateCpsT.runK,[]]
[Lean.Elab.Term.MkInstResult.instVal,[]]
[Lean.IR.HasIndex.visitArg,[Lean.IR.Arg.irrelevant, Bool, Lean.IR.HasIndex.visitVar, Bool.false]]
[Lean.AttributeImplCore.name,[]]
[UInt16.instRingUInt16.proof_1,[congrArg, UInt16.mk, Ring.sub_eq_add_neg, UInt16.val]]
[Lean.Parser.Term.doBreak,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Lean.Parser.Term.depArrow,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.bracketedBinder, Lean.Parser.unicodeSymbol, Lean.Parser.termParser]]
[Lean.IR.collectUsedDecls,[StateT.run', Lean.IR.CollectUsedDecls.collectDecl]]
[Lean.Elab.Tactic.evalRevert,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Tactic.getMainGoal, Lean.Elab.Tactic.getFVarIds, liftM, Lean.Meta.revert, Bool.false, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.nil, Lean.Elab.throwUnsupportedSyntax]]
[Array.mk.inj,[]]
[Fin.val_ne_of_ne,[absurd, Fin.eq_of_val_eq]]
[Lean.Elab.Term.MutualClosure.FixPoint.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.MutualClosure.FixPoint.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.elabTail,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.darrow, Lean.Parser.withPosition, Lean.Parser.termParser]]
[Lean.Parser.Command.initialize.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.visibility.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.Term.typeSpec.parenthesizer, Lean.Parser.Term.leftArrow.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer]]
[Lean.Elab.Term.Do.Code.reassign.inj,[And.intro]]
[Std.HashMap.instEmptyCollectionHashMap,[EmptyCollection.mk, Std.mkHashMap, OfNat.ofNat]]
[Lean.Elab.Command.mkResultUniverse,[ite, Eq, and, Array.isEmpty, BEq.beq, OfNat.ofNat, Bool.true, Lean.levelOne, not, Lean.Level.isZero, Lean.Level.isNeverZero, Lean.Level.normalize, Lean.mkLevelMax]]
[Lean.PrefixTreeNode.noConfusionType,[]]
[instHOrElse,[HOrElse.mk, OrElse.orElse]]
[Mathlib.Tactic.Lint.isConditionalHyps,[Unit.unit, Lean.Meta.MetaM, Bool, Pure.pure, Bool.false, Bind.bind, Lean.Meta.getFVarLocalDecl, List.anyM, Lean.Meta.inferType, Lean.Expr.containsFVar, Lean.Expr.fvarId!, ite, Eq, and, not, Lean.BinderInfo.isInstImplicit, Lean.LocalDecl.binderInfo, Bool.true, PUnit.unit]]
[ExceptT.run_map,[Eq.mpr, congrArg, Eq, ExceptT.run, ExceptT.mk, Bind.bind, Except, Pure.pure, Except.ok, Except.error, map_eq_pure_bind, Except.map, bind_congr, of_eq_true, eq_self, Eq.symm, Eq.refl]]
[add_right_cancel,[IsAddRightCancel.add_right_cancel]]
[Lean.CollectFVars.State.mk.inj,[And.intro]]
[Lean.MetavarContext.LevelMVarToParam.State.mk.inj,[And.intro]]
[Lean.getBuildDir,[Bind.bind, IO.appDir, Pure.pure, Option.get!, System.FilePath.parent]]
[Lean.Elab.Term.toParserDescr.ensureNoPrec,[ite, Eq, Lean.Syntax.isNone, Lean.Syntax.getOp, OfNat.ofNat, Bool.true, Pure.pure, PUnit.unit, Lean.throwErrorAt, Lean.ToMessageData.toMessageData]]
[Lean.Parser.Syntax.nonReserved.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.strLit.formatter]]
[List.subset_append_right,[List.mem_append_right]]
[IO.FS.Stream.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.instBEqMVarId,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.ParametricAttribute.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ParametricAttribute.mk, Eq.symm, eq_of_heq, HEq.refl]]
[StateCpsT.runK_modify,[rfl]]
[Lean.IR.Expr.ap.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Structural.EqnInfo.value,[]]
[Lean.Widget.TaggedText.ibelow,[True, And]]
[Lean.Parser.ParserExtension.OLeanEntry.parser.inj,[And.intro]]
[Lean.Expr.isProp,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[Lean.Lsp.CompletionOptions.allCommitCharacters?,[]]
[Lean.SyntaxNode.getKind,[Lean.SyntaxNodeKind, Lean.unreachIsNodeMissing, Lean.unreachIsNodeAtom, Lean.unreachIsNodeIdent]]
[Lean.Lsp.ReferenceContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.toSuperDigits,[Nat.toSuperDigitsAux, List.nil]]
[Lean.Parser.Command.identPrec.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optPrecedence.parenthesizer]]
[Int.instLTInt,[LT.mk, Int.lt]]
[Lean.mkModuleData,[Bind.bind, ST.Ref.get, Lean.persistentEnvExtensionsRef, Pure.pure, Lean.ModuleData.mk, Lean.EnvironmentHeader.imports, Lean.Environment.header, Lean.SMap.foldStage2, Array.push, List.toArray, List.nil, Lean.Environment.constants]]
[Lean.LocalContext.anyM,[Std.PersistentArray.anyM, Lean.LocalContext.decls, Unit.unit, Bool, Pure.pure, Bool.false]]
[List.lengthTRAux,[Nat, PProd.fst, Nat.succ]]
[USize.val_eq_of_eq,[Eq, USize.val, congrArg]]
[Lean.Server.RequestContext.doc,[]]
[Nat.ble_eq_true_of_le,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Eq, Nat.ble, Bool.true, Nat.ble_self_eq_true, Nat.ble_succ_eq_true, PProd.fst]]
[Lean.JsonRpc.Response.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonRpc.Response.mk, Eq.symm, eq_of_heq, HEq.refl]]
[FloatArray.set!,[FloatArray, FloatArray.mk, Array.set!]]
[Lean.Parser.evalParserConstUnsafe,[Lean.Parser.ParserState, HOrElse.hOrElse, Lean.Environment.evalConstCheck, Lean.Parser.Parser, Lean.Parser.ParserModuleContext.env, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserModuleContext.options, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.Parser.fn, Lean.Parser.ParserState.mkUnexpectedError, HAppend.hAppend, ToString.toString, List.nil]]
[Lean.Lsp.SymbolKind.struct.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.PrettyPrinter.Formatter.checkLineEq.formatter,[Pure.pure, Unit.unit]]
[Lean.Meta.mkEqTrans,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Option.none, Option.some, Prod.mk, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.eq?, Lean.Meta.getLevel, Lean.mkApp6, Lean.mkConst, List.cons, List.nil, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr]]
[Lean.Parser.sepBy,[Lean.Parser.sepByNoAntiquot, Lean.Parser.sepByElemParser]]
[instReprAtomUInt32,[ReprAtom.mk]]
[Mathlib.ExtendedBinder.«binderTerm>_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Term.structInstArrayRef.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[List.Perm.symm,[List.Perm.nil, List.Perm.cons, List.Perm.swap, List.Perm.trans]]
[Nat.lt_of_succ_lt,[Nat.le_of_succ_le]]
[Lean.MessageData.ofLevel.inj,[]]
[Lean.Json.instBEqJson,[BEq.mk]]
[Lean.Elab.Command.State.scopes,[]]
[Lean.IR.IRType.isStruct,[Lean.IR.IRType.float, Lean.IR.IRType.uint8, Lean.IR.IRType.uint16, Lean.IR.IRType.uint32, Lean.IR.IRType.uint64, Lean.IR.IRType.usize, Lean.IR.IRType.irrelevant, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.union, Bool, Bool.true, Bool.false]]
[Lean.Meta.whnfUntil,[Bind.bind, Lean.Meta.whnfHeadPred, Pure.pure, not, Lean.Expr.isAppOf, ite, Eq, Bool.true, Option.some, Option.none]]
[Except.tryCatch,[Except, Except.ok]]
[Lean.IR.Checker.CheckerState.mk.injEq,[Eq.propIntro, Eq.refl, Lean.IR.Checker.CheckerState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.ensureExpectedType.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.strLit.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec]]
[Lean.Syntax.copyHeadTailInfoFrom,[Lean.Syntax.setTailInfo, Lean.Syntax.setHeadInfo, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo]]
[Lean.PrettyPrinter.FormatterM.orElse,[Bind.bind, MonadState.get, Lean.catchInternalId, Lean.PrettyPrinter.backtrackExceptionId, MonadStateOf.set, Unit.unit]]
[Lean.Meta.DiscrTree.instToFormatTrie,[Std.ToFormat.mk, Lean.Meta.DiscrTree.Trie.format]]
[Task.Priority,[Nat]]
[Lean.Lsp.instInhabitedLocation,[Inhabited.mk, Lean.Lsp.Location.mk, arbitrary]]
[Lean.Expr.constName,[Option.getD, Lean.Expr.constName?, Lean.Name.anonymous]]
[HAppend.hAppend,[]]
[USize.instCommRingUSize,[CommRing.mk, USize.instCommRingUSize.proof_1]]
[Lean.Expr.ReplaceImpl.cache,[Bind.bind, modify, Lean.Expr.ReplaceImpl.State, Lean.Expr.ReplaceImpl.State.mk, Array.uset, Lean.Expr.ReplaceImpl.cache.proof_1, Lean.Expr.ReplaceImpl.cache.proof_2, Pure.pure]]
[instComplementUInt64,[Complement.mk, UInt64.complement]]
[Lean.Parser.Term.instBinder.formatter,[Lean.ppGroup.formatter, Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.optIdent.formatter, Lean.Parser.termParser.formatter]]
[Lean.Parser.Attr.extern.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.optional.parenthesizer, Lean.Parser.numLit.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.Attr.externEntry.parenthesizer]]
[Lean.OpenDecl.instToStringOpenDecl,[ToString.mk, String, HAppend.hAppend, ToString.toString, ite, Eq, BEq.beq, List.nil, Bool.true]]
[Lean.Parser.ParserState.keepNewError,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Lean.Parser.ParserState.keepTop]]
[Lean.ClosedTermCache.map,[]]
[Lean.IR.FnBody.hasLiveVar,[StateT.run', Lean.IR.IsLive.visitFnBody, Lean.IR.VarId.idx]]
[Mathlib.Tactic.Ext.tacticExt__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Lean.ParametricAttributeImpl.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.StructInst.Source.isNone,[Unit.unit, Lean.Elab.Term.StructInst.Source.implicit, Lean.Elab.Term.StructInst.Source.explicit, Bool, Bool.true, Bool.false]]
[List.mapM,[Unit.unit, List, Pure.pure, List.nil, Bind.bind, PProd.fst, List.cons]]
[Lean.Elab.Tactic.focusAndDone,[Lean.Elab.Tactic.focus, Bind.bind, Lean.Elab.Tactic.done, Pure.pure]]
[Lean.Server.FileWorker.handleDocumentHighlight,[Bind.bind, Lean.Server.RequestM.readDoc, Lean.Server.RequestM.withWaitFindSnap, Decidable.decide, GT.gt, Lean.Server.Snapshots.Snapshot.endPos, Pure.pure, List.toArray, List.nil, Option.none, Lean.Server.RequestM, Array, Lean.Lsp.DocumentHighlight, Lean.Server.Snapshots.Snapshot.stx, List.cons, PUnit.unit, Lean.Server.FileWorker.handleDocumentHighlight.highlightReturn?]]
[Lean.Elab.WF.TerminationStrategy.decreasingTactic,[]]
[Lean.Meta.Contradiction.Config.useDecide,[]]
[Lean.PersistentEnvExtension.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.mkDeclName,[ite, Eq, or, Lean.Name.isAtomic, Lean.Elab.isFreshInstanceName, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[ExceptT.instLawfulMonadExceptT,[ExceptT.instLawfulMonadExceptT.proof_1]]
[Lean.Elab.MonadLog.getFileName,[]]
[Lean.Json.getStr?,[Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.arr, Lean.Json.obj, Except, String, Pure.pure, MonadExcept.throw]]
[Nat.toLevel,[Lean.Level.ofNat]]
[Lean.Elab.CompletionInfo.id.inj,[And.intro]]
[EIO.toBaseIO,[EStateM.Result, Empty, IO.RealWorld, Except, EStateM.Result.ok, Except.ok, Except.error]]
[Lean.Parser.Command.declValSimple.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.whereDecls.parenthesizer]]
[Lean.Parser.Term.matchAltExpr,[Lean.Parser.Term.matchAlt, Lean.Parser.termParser, OfNat.ofNat]]
[Lean.ExternAttrData.mk.inj,[And.intro]]
[Iff.rfl,[Iff.refl]]
[Function.has_uncurry_induction,[Function.has_uncurry.mk, Function.has_uncurry.uncurry, Prod.fst, Prod.snd]]
[Lean.PersistentEnvExtensionState.noConfusionType,[]]
[Lean.Server.FileWorker.WorkerContext.noConfusionType,[]]
[Lean.Meta.AbstractMVarsResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.AbstractMVarsResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[BaseIO.toIO,[liftM]]
[Lean.mkAppN,[Array.foldl, Lean.mkApp, OfNat.ofNat, Array.size]]
[Lean.Elab.Term.Do.DoIfView.thenBranch,[]]
[Lean.mkNoConfusionCore,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.MonadEnv.modifyEnv, Lean.throwKernelException, Lean.mkNoConfusionCoreImp]]
[precMin,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[instOrdUSize,[Ord.mk, compareOfLessAndEq]]
[Lean.getStructureFields,[Option.none, Array, Lean.Name, Lean.getStructureInfo?, Lean.StructureInfo.fieldNames, panicWithPosWithDecl, OfNat.ofNat]]
[Nat.superDigitChar,[ite, Eq, OfNat.ofNat, Char.ofNat]]
[inv_inv,[inv_eq_of_mul_eq_one, mul_left_inv]]
[List.lt.brecOn,[List.lt.below.nil, List.lt.below.head, List.lt.below.tail]]
[Lean.Expr.mdata.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MessageData.withContext.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instSemiringFin.proof_4,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.mul_def, congrFun, HMod.hMod, Nat.mul_comm, eq_self, HMul.hMul]]
[Nat.gcd_mul_right_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.gcd_comm, Nat.gcd_mul_right_left, rfl]]
[Mathlib.Tactic.Ext.«termExtType%__»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Lean.PrettyPrinter.Formatter.atomic.formatter,[]]
[Option.toBool,[Unit.unit, Bool, Bool.true, Bool.false]]
[Lean.Meta.getMatcherInfo?,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Meta.getMatcherInfoCore?]]
[Array.foldlM.loop,[dite, LT.lt, Unit.unit, Pure.pure, Bind.bind, Array.get, Fin.mk, Array.foldlM.loop.proof_1, PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[Std.PersistentArrayNode.leaf.injEq,[Eq.propIntro, Eq.refl, Std.PersistentArrayNode.leaf, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.getPPAnalysisBlockImplicit,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false]]
[Lean.SimplePersistentEnvExtension,[Lean.PersistentEnvExtension, Prod, List]]
[Lean.Elab.Term.Quotation.ArrayStxBuilder.empty,[Sum.inl, List.toArray, List.nil]]
[Preorder.noConfusionType,[]]
[Lean.Elab.Term.Do.ToCodeBlock.Catch.optType,[]]
[Std.RBNode.depth,[Unit.unit, Nat, OfNat.ofNat, Nat.succ, PProd.fst, PProd.snd]]
[Lean.Level.PP.Result.leaf.injEq,[Eq.propIntro, Eq.refl, Lean.Level.PP.Result.leaf, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Command.InductiveView.binders,[]]
[Lean.IR.EmitC.main,[Bind.bind, Lean.IR.EmitC.emitFileHeader, Lean.IR.EmitC.emitFnDecls, Lean.IR.EmitC.emitFns, Lean.IR.EmitC.emitInitFn, Lean.IR.EmitC.emitMainFnIfNeeded, Lean.IR.EmitC.emitFileFooter]]
[IO.Error.illegalOperation.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.illegalOperation, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.DefEqContext.lhs,[]]
[Lean.Lsp.instToJsonTextDocumentItem,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentItem.uri, List.nil, Lean.Lsp.TextDocumentItem.languageId, Lean.Lsp.TextDocumentItem.version, Lean.Lsp.TextDocumentItem.text]]
[Lean.Expr.updateForallE!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateForall, Lean.Expr.forallE, Lean.Expr.Data.binderInfo, Lean.Expr.updateForallE!.proof_1, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.IR.MaxIndex.instAndThenCollector,[AndThen.mk, Function.comp, Unit.unit]]
[Lean.Level.isMVar,[Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Bool, Bool.true, Bool.false]]
[Nat.sub_le_sub_left,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, LE.le, HSub.hSub, Nat.le.dest, Eq.mpr, Nat.sub_sub, Nat.sub_le]]
[Lean.Parser.Command.initialize.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.visibility.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.ident.formatter, Lean.Parser.Term.typeSpec.formatter, Lean.Parser.Term.leftArrow.formatter, Lean.Parser.Term.doSeq.formatter]]
[Substring.takeRight,[Substring.mk, Substring, HAdd.hAdd, Substring.prevn, Substring.bsize]]
[Lean.ScopedEnvExtension.StateStack.stateStack,[]]
[Lean.Widget.instBEqTaggedText,[BEq.mk]]
[Lean.Elab.Term.LVal.fieldIdx.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.builtin_initialize.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.visibility.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.ident.formatter, Lean.Parser.Term.typeSpec.formatter, Lean.Parser.Term.leftArrow.formatter, Lean.Parser.Term.doSeq.formatter]]
[Lean.Elab.Term.SyntheticMVarDecl.mk.inj,[And.intro]]
[UInt64.toUInt16,[Nat.toUInt16, UInt64.toNat]]
[instDecidableEq_1,[LinearOrder.decidable_eq]]
[Lean.Lsp.instFromJsonRange,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.Position, Pure.pure, Lean.Lsp.Range.mk]]
[Lean.Elab.Term.elabExplicit,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Bind.bind, List.nil, Bool.false, List.toArray, BEq.beq, Array.size, OfNat.ofNat, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.Elab.Term.TermElabM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Pure.pure, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError, Lean.Elab.Term.elabTerm, Lean.Syntax.matchesNull, Lean.Elab.throwUnsupportedSyntax]]
[Int.subNatNat_add_negSucc_ofNat,[]]
[Classical.strongIndefiniteDescription.proof_1,[Subtype.property, Classical.indefiniteDescription]]
[Lean.Meta.DiscrTree.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Compiler.instBEqSpecializeAttributeKind,[BEq.mk, BEq.beq, Lean.Compiler.SpecializeAttributeKind.toCtorIdx]]
[Lean.Server.Completion.HoverInfo.inside.injEq,[Eq.propIntro, Eq.refl, Lean.Server.Completion.HoverInfo.inside, Eq.symm, eq_of_heq, HEq.refl]]
[IO.Error.timeExpired.inj,[And.intro]]
[tactic_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Meta.Hypothesis.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.decidableBall.proof_3,[List.mem_cons_of_mem]]
[Lean.Meta.DiscrTree.Key.proj.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instDecidableNot,[Decidable, Not, Decidable.isFalse, absurd, Decidable.isTrue]]
[Lean.Parser.Term.unreachable.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.Parser.symbol.parenthesizer]]
[Lean.Syntax.node.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Syntax.node, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.instFVarIdSetInhabited,[Std.instInhabitedRBTree]]
[Lean.Elab.Term.mkLetIdDeclView,[Lean.Elab.Term.LetIdDeclView.mk]]
[Lean.Parser.unicodeSymbol.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.tokenWithAntiquot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.unicodeSymbolNoAntiquot.parenthesizer]]
[UInt64.instCommRingUInt64,[CommRing.mk, UInt64.instCommRingUInt64.proof_1]]
[Lean.PrettyPrinter.Formatter.checkLhsPrec.formatter,[Pure.pure, Unit.unit]]
[Lean.Meta.Match.Alt.applyFVarSubst,[Lean.Meta.Match.Alt.mk, Lean.Meta.Match.Alt.ref, Lean.Meta.Match.Alt.idx, Lean.Expr.applyFVarSubst, Lean.Meta.Match.Alt.rhs, List.map, Lean.LocalDecl.applyFVarSubst, Lean.Meta.Match.Alt.fvarDecls, Lean.Meta.Match.Pattern.applyFVarSubst, Lean.Meta.Match.Alt.patterns]]
[Lean.Json.CompressWorkItem.json.injEq,[Eq.propIntro, Eq.refl, Lean.Json.CompressWorkItem.json, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Command.elabPrintPrefix,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Lean.Elab.Command.liftTermElabM, Option.none, Bind.bind, Lean.Meta.find, Pure.pure, Lean.Name.isPrefixOf, Lean.ConstantInfo.name, Lean.Meta.FindOptions.mk, String.isEmpty, Lean.resolveGlobalConst, List.nil, List.cons, Lean.Elab.Term.TermElabM, Unit, PUnit.unit, Lean.Elab.throwUnsupportedSyntax]]
[Nat.eq_of_mul_eq_mul_left,[Nat.le_antisymm, Nat.le_of_mul_le_mul_left, Nat.le_of_eq, Eq.symm]]
[UInt64.instRingUInt64,[Ring.mk, UInt64.instRingUInt64.proof_1, UInt64.mk, Ring.gsmul, UInt64.val, UInt64.instRingUInt64.proof_2, UInt64.instRingUInt64.proof_3, UInt64.instRingUInt64.proof_4, UInt64.instRingUInt64.proof_5]]
[Lean.Widget.Lean.Widget.MsgToInteractive.instRpcEncodingMsgToInteractiveRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Lean.Widget.MsgToInteractive.msg, Lean.Widget.MsgToInteractive.indent, Pure.pure, Lean.Server.RpcEncoding.rpcDecode, Lean.Widget.MsgToInteractive.mk]]
[Lean.Meta.Match.MkMatcherInput.matcherName,[]]
[Lean.Elab.Tactic.SavedState.mk.inj,[And.intro]]
[Lean.IR.MaxIndex.Collector,[Lean.IR.Index]]
[Lean.Name.getNumParts,[Unit.unit, Nat, OfNat.ofNat, HAdd.hAdd, PProd.fst]]
[Lean.Meta.Simp.rewriteUsingDecide?,[Lean.Meta.withReducibleAndInstances, ite, Eq, or, Lean.Expr.hasFVar, Lean.Expr.hasMVar, Lean.Expr.isConstOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Option.none, Bind.bind, MonadExcept.tryCatch, Lean.Meta.mkDecide, Lean.Meta.withDefault, Lean.Meta.whnf, Lean.Meta.mkEqRefl, Lean.mkConst, List.nil, Option.some, Lean.Meta.Simp.Result.mk, Lean.mkAppN, List.toArray, List.cons, Lean.Expr.appArg!]]
[Lean.MetavarContext.MkBinding.revert,[Bind.bind, MonadState.modifyGet, Prod.mk, Lean.MetavarContext.MkBinding.State.cache, Lean.MetavarContext.MkBinding.State.mk, Lean.MetavarContext.MkBinding.State.mctx, Lean.MetavarContext.MkBinding.State.ngen, EmptyCollection.emptyCollection, modify, Pure.pure, List.toArray, List.nil]]
[Lean.Parser.Command.deriving.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.derivingClasses.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.ident.parenthesizer, Bool.false]]
[Lean.Elab.Structural.instInhabitedEqnsExtState,[Inhabited.mk, Lean.Elab.Structural.EqnsExtState.mk, arbitrary]]
[Lean.Parser.checkColGe,[Lean.Parser.Parser.mk, Lean.Parser.checkColGeFn]]
[Lean.Parser.Term.dynamicQuot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.incQuotDepth, Lean.Parser.parserOfStack]]
[Lean.Elab.Term.ToParserDescrContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.ToParserDescrContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[List.length_singleton,[rfl]]
[Lean.Server.FileWorker.handleSemanticTokens.addToken,[Bind.bind, MonadReader.read, ReaderT, Lean.Server.FileWorker.SemanticTokensContext, StateT, Lean.Server.FileWorker.SemanticTokensState, Lean.Server.RequestM, PUnit, Prod.mk, Option.none, Option.some, Lean.Syntax.getPos?, Bool.false, Lean.Syntax.getTailPos?, ite, Eq, and, Decidable.decide, LE.le, LT.lt, Bool.true, MonadState.get, modify, Lean.Server.FileWorker.SemanticTokensState.mk, HAppend.hAppend, Lean.Server.FileWorker.SemanticTokensState.data, List.toArray, List.cons, List.nil, Pure.pure, PUnit.unit]]
[List.length_reverse,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, List.length, List.reverse_cons, List.length_append, List.reverse, List.cons, List.nil, HAdd.hAdd, List.length_cons, Nat.succ, List.length_nil, eq_self, OfNat.ofNat]]
[Lean.Parser.Attr.toAdditiveReorder,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[instNegFin,[Neg.mk, Fin.mk, HMod.hMod, HSub.hSub, Fin.val, instNegFin.proof_1]]
[String.trim,[Substring.toString, Substring.trim, String.toSubstring]]
[instOfNatUInt16,[OfNat.mk, UInt16.ofNat]]
[Lean.Elab.Term.ToDepElimPattern.State.localDecls,[]]
[Lean.Meta.Closure.ClosureM,[ReaderT, Lean.Meta.Closure.Context, StateRefT', IO.RealWorld, Lean.Meta.Closure.State, Lean.Meta.MetaM]]
[Lean.Meta.isCoeDecl,[or, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.IR.MData,[Lean.KVMap]]
[Lean.Parser.Command.end.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.ident.parenthesizer]]
[Nat.mod_eq_sub_mod,[Eq, HMod.hMod, HSub.hSub, Nat.eq_zero_or_pos, rfl, Eq.symm, Nat.sub_zero, if_pos, And.intro, Nat.mod_eq]]
[Lean.Elab.MacroStack,[List, Lean.Elab.MacroStackElem]]
[Lean.Meta.liftMetaM,[liftM]]
[Lean.Meta.mkFunUnit,[Bind.bind, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Lean.mkLambda, Lean.BinderInfo.default, Lean.mkConst, List.nil]]
[Lean.RecursorVal.rules,[]]
[Lean.CollectLevelParams.State.params,[]]
[Lean.Parser.withAntiquotSpliceAndSuffix,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquotSplice, Lean.Parser.withoutInfo, Lean.Parser.withAntiquotSuffixSplice]]
[Lean.Meta.SynthInstance.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Simp.rewritePre,[Bind.bind, MonadReader.read, Pure.pure, Lean.Meta.Simp.Context.simpLemmas, Lean.Meta.Simp.rewrite, Lean.Meta.SimpLemmas.pre, Lean.Meta.SimpLemmas.erased, Lean.Meta.Simp.Step.visit]]
[Lean.Parser.leadingParserAux,[Id.run, Id, Lean.Parser.ParserState, ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Pure.pure, Bind.bind, PUnit.unit]]
[Lean.Elab.expandDeclIdCore,[ite, Eq, Lean.Syntax.isIdent, Bool.true, Prod.mk, Lean.Syntax.getId, Lean.mkNullNode, List.toArray, List.nil]]
[Lean.Meta.Config.quasiPatternApprox,[]]
[Lean.IR.Borrow.M,[ReaderT, Lean.IR.Borrow.BorrowInfCtx, StateM, Lean.IR.Borrow.BorrowInfState]]
[Lean.MessageData.ofList,[Unit.unit, List.cons, Lean.MessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.MessageData.sbracket, Lean.MessageData.joinSep, HAppend.hAppend, Std.Format.text, Std.Format.line]]
[Lean.Expr.proj.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.proj, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.MetavarContext.findExprDependsOn,[StateT.run', Lean.MetavarContext.DependsOn.main, EmptyCollection.emptyCollection]]
[Lean.PrettyPrinter.Delaborator.failure,[MonadExcept.throw, Lean.Exception.internal, Lean.PrettyPrinter.Delaborator.delabFailureId, Lean.KVMap.mk]]
[Lean.IR.EmitC.emitDec,[Bind.bind, Lean.IR.EmitC.emit, ite, Eq, Bool.true, bne, OfNat.ofNat, Pure.pure, PUnit.unit]]
[Lean.Syntax.matchesNull,[Lean.Syntax.isNodeOf, Lean.nullKind]]
[Lean.Elab.Command.InductiveView.ref,[]]
[Except.map,[Except, Except.error, Except.ok]]
[Nat.gcd_gcd_self_left_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, Nat.gcd_comm, Nat.gcd_gcd_self_right_right, rfl]]
[Lean.Compiler.InlineAttributeKind.noConfusion,[noConfusionEnum, Lean.Compiler.InlineAttributeKind.toCtorIdx]]
[Char.isValidUInt32,[LT.lt, UInt32.size, Nat.lt_trans, of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Parser.Command.mkSimpAttribute,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[Lean.TagAttribute.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instRingFin.proof_5,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat, add_comm, Eq.symm, instRingFin.proof_1, Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Fin.val, Fin.sub_def, congrFun, HMod.hMod, Nat.add_sub_cancel', Nat.le_of_lt, Fin.isLt, Nat.mod_self, Fin.zero_def, eq_true_of_decide, Bool.true]]
[Lean.Elab.Tactic.Context.mk.inj,[And.intro]]
[List.cons_union,[of_eq_true, eq_self, List.insert, List.foldr]]
[Lean.DefinitionVal.safety,[]]
[Nat.not_coprime_of_dvd_of_dvd,[]]
[Lean.ExternEntry.foreign.inj,[And.intro]]
[Lean.Parser.ParserAttributeHook.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.precedenceParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous]]
[PSum.inl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.structInstLVal,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, HOrElse.hOrElse, Lean.Parser.Term.ident, Lean.Parser.fieldIdx, Lean.Parser.Term.structInstArrayRef, Lean.Parser.many, Lean.Parser.group, Lean.Parser.symbol]]
[Exists.imp,[exists_imp_exists]]
[Lean.Elab.Command.Context.ref,[]]
[Lean.DefinitionVal.hints,[]]
[Lean.Elab.Command.CtorView.type?,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.mvarName,[Bind.bind, Lean.Meta.getMVarDecl, Lean.Expr.mvarId!, Pure.pure, Lean.MetavarDecl.userName]]
[Lean.ParserCompiler.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.instToJsonLeanFileProgressProcessingInfo,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.LeanFileProgressProcessingInfo.range, List.nil]]
[prioMid,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Iff.elim_left.proof_1,[Iff.mp]]
[Lean.Export.Alloc.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Export.Alloc.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Server.FileWorker.SemanticTokensState.lastLspPos,[]]
[ExceptCpsT.lift,[Bind.bind]]
[Lean.Server.RequestError.noConfusionType,[]]
[Lean.Parser.Term.matchAlt,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ppIndent, Lean.Parser.sepBy1, Lean.Parser.termParser, OfNat.ofNat, Bool.false, Lean.Parser.darrow, Lean.Parser.checkColGe]]
[not_le_of_gt,[And.right, le_not_le_of_lt]]
[Function.involutive.left_inverse,[]]
[Lean.IR.VarId.noConfusionType,[]]
[LE.le,[]]
[Lean.Parser.ModuleParserState.pos,[]]
[Lean.Elab.MonadInfoTree.noConfusionType,[]]
[WellFounded.noConfusionType,[]]
[Lean.Meta.ElimInfo.altsInfo,[]]
[Lean.Json.str.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.charLit,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.charLitKind, Bool.true, Lean.Parser.charLitNoAntiquot]]
[IO.FS.DirEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FS.DirEntry.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.namedPrio,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.priorityParser]]
[Lean.Elab.Term.StructInst.instInhabitedExplicitSourceInfo,[Inhabited.mk, Lean.Elab.Term.StructInst.ExplicitSourceInfo.mk, arbitrary]]
[not_iff,[Decidable.not_iff]]
[List.mem_of_mem_erase,[List.erase_subset]]
[Lean.Parser.Term.letDecl,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.notFollowedBy, Lean.Parser.nonReservedSymbol, Bool.false, HOrElse.hOrElse, Lean.Parser.Term.letIdDecl, Lean.Parser.Term.letPatDecl, Lean.Parser.Term.letEqnsDecl]]
[Nat.dvd_add_iff_right,[Iff.intro, Nat.dvd_add, Exists.elim, Eq.symm, eq_of_heq, Eq.refl, HMul.hMul, HEq.refl, Dvd.dvd, Exists.intro, HSub.hSub, Eq.mpr, Eq, Nat.mul_sub_left_distrib, HAdd.hAdd, Nat.add_sub_cancel_left, rfl]]
[Lean.Expr.setAppPPExplicit,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.setPPExplicit, Lean.mkAppN, Bool.true]]
[Lean.Lsp.instToJsonWorkDoneProgressBegin,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.WorkDoneProgressReport.kind, Lean.Lsp.WorkDoneProgressBegin.toWorkDoneProgressReport, List.nil, Lean.Json.opt, Lean.Lsp.WorkDoneProgressReport.message?, Lean.Lsp.WorkDoneProgressReport.cancellable, Lean.Lsp.WorkDoneProgressReport.percentage?, Lean.Lsp.WorkDoneProgressBegin.title]]
[Lean.Parser.Tactic.failIfSuccess?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.parser]]
[Lean.Elab.MacroExpansionInfo.noConfusionType,[]]
[Nat.strong_rec_on,[WellFounded.fix', WellFoundedRelation.wf, Nat.lt_wfRel]]
[Std.Range.forM.loop,[ite, GE.ge, Std.Range.stop, Pure.pure, PUnit.unit, Unit.unit, PUnit, Bind.bind, PProd.fst, HAdd.hAdd, Std.Range.step]]
[Lean.IR.ExplicitBoxing.run,[Lean.IR.ExplicitBoxing.addBoxedVersions]]
[Lean.Elab.InfoTree.noConfusionType,[]]
[Lean.Level.imax.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Command.expandElab,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Option.some, Lean.Macro.throwUnsupported]]
[instReprAtomChar,[ReprAtom.mk]]
[Lean.Server.FileWorker.handleReferences,[Bind.bind, Lean.Server.RequestM.readDoc, liftM, IO.AsyncList.waitAll, Bool.true, Lean.Server.FileWorker.EditableDocument.cmdSnaps, Lean.Server.RequestM.mapTask, Lean.Server.RequestM, Array, Lean.Lsp.Location, Option.none, List.find?, Decidable.decide, GT.gt, Lean.Server.Snapshots.Snapshot.endPos, Lean.Elab.InfoTree.hoverableInfoAt?, Lean.Server.Snapshots.Snapshot.infoTree, Pure.pure, Lean.Lsp.ReferenceContext.includeDeclaration, Lean.Lsp.ReferenceParams.context, PUnit.unit, Lean.Server.FileWorker.handleReferences.identOf, Lean.Server.FileWorker.handleReferences.findReferences, Lean.Server.FileWorker.handleReferences.applyIdMap, Lean.Server.FileWorker.handleReferences.combineFvars, Lean.Server.FileWorker.handleReferences.referencesTo]]
[Int.subNatNat_of_sub_eq_succ,[]]
[Lean.instInhabitedDataValue,[Inhabited.mk, Lean.DataValue.ofString, arbitrary]]
[Nat.to_digits_core_lens_eq,[of_eq_true, eq_self, HAdd.hAdd, List.length, OfNat.ofNat, Classical.em, Eq, HDiv.hDiv, Eq.trans, congr, congrArg, ite_congr, congrFun, eq_true_of_decide, Eq.refl, Bool.true, List.cons, Nat.digitChar, HMod.hMod, Nat.toDigitsCore, if_true, Eq.symm, Eq.mpr, eq_false, if_false]]
[Lean.Parser.registerAlias,[Lean.Parser.registerAliasCore, Lean.Parser.parserAliasesRef]]
[Lean.Elab.Term.MVarErrorKind.implicitArg.inj,[]]
[Lean.Meta.ElimInfo.targetsPos,[]]
[Lean.Elab.Modifiers.isNoncomputable,[]]
[Lean.Elab.Tactic.MkSimpContextResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.MkSimpContextResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[IO.FS.Stream.withPrefix,[IO.FS.Stream.mk, IO.FS.Stream.isEof, IO.FS.Stream.flush, IO.FS.Stream.read, Bind.bind, IO.FS.Stream.putStr, IO.FS.Stream.write, IO.FS.Stream.getLine, HAppend.hAppend]]
[IO.FS.Mode.noConfusionType,[noConfusionTypeEnum, IO.FS.Mode.toCtorIdx]]
[Lean.Meta.headBetaMVarType,[Bind.bind, Lean.Meta.getMVarType, Lean.Meta.setMVarType, Lean.Expr.headBeta]]
[Lean.JsonRpc.RequestID.str.injEq,[Eq.propIntro, Eq.refl, Lean.JsonRpc.RequestID.str, Eq.symm, eq_of_heq, HEq.refl]]
[List.instListDecidableLe,[inferInstanceAs, Decidable, Not, LT.lt]]
[Lean.Name.toStringWithSep.maybeEscape,[ite, Eq, Bool.true, Option.getD, Lean.Name.escapePart]]
[Lean.Meta.Closure.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Closure.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Deriving.Header.targetNames,[]]
[Nat.mul_div_cancel_left,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, Nat.mul_comm, Nat.mul_div_cancel, rfl]]
[Lean.Meta.DiscrTree.Key.format,[Unit.unit, Std.Format, Std.Format.text, Std.ToFormat.format, repr, HAppend.hAppend, Lean.FVarId.name]]
[Lean.Parser.ModuleParserState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ModuleParserState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Level.find?.visit,[ite, Eq, Bool.true, Pure.pure, Lean.Level.zero, Lean.Level.param, Lean.Level.mvar, OptionM, Lean.Level, PProd.fst, HOrElse.hOrElse, PProd.snd, Alternative.failure]]
[Lean.Elab.Term.MkInstResult.mk.inj,[And.intro]]
[Lean.Elab.Term.withLevelNames,[Bind.bind, Lean.Elab.Term.getLevelNames, Lean.Elab.Term.setLevelNames, tryFinally]]
[UInt64.instSemiringUInt64.proof_3,[congrArg, UInt64.mk, Semiring.nsmul_zero', UInt64.val]]
[Lean.Parser.Tactic.normCast,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.Elab.InfoTree.hole.inj,[]]
[Lean.AttributeExtensionOLeanEntry.builder.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.AttributeExtensionOLeanEntry.builder, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.quotedName,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.nameLit]]
[Lean.EnvExtensionInterfaceUnsafe.ensureExtensionsArraySize,[Array.size, Lean.Environment.extensions, Lean.EnvExtensionInterfaceUnsafe.ensureExtensionsArraySize.loop]]
[Lean.Parser.Tactic.nativeDecide.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false]]
[Lean.Syntax.rewriteBottomUp,[Id.run, Lean.Syntax.rewriteBottomUpM]]
[Lean.Widget.InteractiveHypothesis.names,[]]
[instDecidableLt,[UInt32.decLt]]
[Lean.ConstructorVal.numParams,[]]
[Lean.ExternEntry.standard.inj,[And.intro]]
[Std.RBTree.toList,[Std.RBTree.revFold, List.cons, List.nil]]
[Lean.instInhabitedModuleData,[Inhabited.mk, Lean.ModuleData.mk, arbitrary]]
[Lean.Parser.antiquotExpr.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.identNoAntiquot.parenthesizer, Lean.Parser.antiquotNestedExpr.parenthesizer]]
[Lean.Core.Context.currNamespace,[]]
[StateT.run_seqLeft,[]]
[Lean.Elab.Deriving.DecEq.mkMatch.mkSameCtorRhs,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Syntax, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.MonadQuotation.withFreshMacroScope, PProd.fst, Lean.Syntax.atom, ite, Eq, Bool.true, Lean.mkIdent]]
[Lean.Elab.TerminationHints.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.TerminationHints.mk, Eq.symm, eq_of_heq, HEq.refl]]
[IO.FS.Stream.chainRight,[IO.FS.Stream.mk, IO.FS.Stream.isEof, SeqRight.seqRight, IO.FS.Stream.flush, Bind.bind, IO.FS.Stream.read, IO.FS.Stream.write, ite, Eq, Bool.true, Pure.pure, PUnit.unit, IO.FS.Stream.getLine, IO.FS.Stream.putStr]]
[Lean.PrettyPrinter.Delaborator.Context.mk.inj,[And.intro]]
[Lean.Meta.NormNum.LawfulOne.noConfusionType,[]]
[Lean.KeyedDeclsAttribute.Table,[Lean.SMap, Lean.KeyedDeclsAttribute.Key, List, Lean.KeyedDeclsAttribute.AttributeEntry]]
[List.decidablePairwise,[Decidable, List.pairwise, List.decidablePairwise.proof_1, Decidable.isTrue, List.pairwise.nil, List.cons, PProd.fst, List.decidableBall, Decidable.isFalse, List.decidablePairwise.proof_2, List.decidablePairwise.proof_3, List.decidablePairwise.proof_4]]
[StateT.set,[Pure.pure, Prod.mk, PUnit.unit]]
[Lean.Xml.Parser.doctypedecl,[Bind.bind, Lean.Parsec.skipString, SeqLeft.seqLeft, SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Xml.Parser.Name, optional, Lean.Xml.Parser.ExternalID, Pure.pure, Unit.unit, Lean.Parsec.skipChar, Char.ofNat, Lean.Xml.Parser.intSubset]]
[Lean.Compiler.instInhabitedSpecArgKind,[Inhabited.mk, Lean.Compiler.SpecArgKind.fixed]]
[DivInvMonoid.toInv,[]]
[liftCoeM,[Bind.bind, liftM, Pure.pure, coe]]
[Lean.getExternConstArity,[Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.Core.CoreM, Option, Nat, Lean.getExternAttrData, Pure.pure, Option.none, Lean.ExternAttrData.arity?, Option.some, Lean.getConstInfo, Lean.Meta.MetaM.run, Lean.Meta.forallTelescopeReducing, Lean.ConstantInfo.type, Array.size, Lean.Meta.Context.mk, Lean.Meta.State.mk]]
[Lean.Lsp.Trace.noConfusion,[noConfusionEnum, Lean.Lsp.Trace.toCtorIdx]]
[instInhabitedEIO,[inferInstanceAs, Inhabited, EStateM, IO.RealWorld]]
[Lean.InductiveVal.ctors,[]]
[Lean.Elab.Term.Do.extendUpdatedVars,[ite, Eq, Std.RBTree.any, not, Lean.NameSet.contains, Lean.Elab.Term.Do.CodeBlock.uvars, Bool.true, Bind.bind, Lean.Elab.Term.Do.extendUpdatedVarsAux, Lean.Elab.Term.Do.CodeBlock.code, Pure.pure, Lean.Elab.Term.Do.CodeBlock.mk]]
[coeHead,[CoeHead.coe]]
[Lean.IR.Expr.pap.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.pap, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Level.PP.Result.num.injEq,[Eq.propIntro, Eq.refl, Lean.Level.PP.Result.num, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Json.CompressWorkItem.comma.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.MonadCacheT.run,[StateRefT'.run', Std.mkHashMap, OfNat.ofNat]]
[Lean.Parser.Term.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, HOrElse.hOrElse, Lean.Parser.termParser, Lean.Parser.many1Unbox, Lean.Parser.commandParser]]
[Std.PersistentArrayNode.node.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.trans, Eq.refl, SizeOf.sizeOf, List.nil, HAdd.hAdd, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec]]
[Lean.Parser.Term.hole.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.Lsp.LeanFileProgressParams.mk.inj,[And.intro]]
[Lean.Elab.Command.StructCtorView.mk.inj,[And.intro]]
[Lean.Server.Snapshots.Snapshot.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.Snapshots.Snapshot.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.Hover.range?,[]]
[Std.RBMap.instReprRBMap,[Repr.mk, Repr.addAppParen, HAppend.hAppend, Std.Format.text, repr, Std.RBMap.toList]]
[CoeHead.noConfusionType,[]]
[Lean.Parsec.instAlternativeParsec,[Alternative.mk, Lean.Parsec.fail, Lean.Parsec.orElse]]
[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.mk, Eq.symm, eq_of_heq, HEq.refl]]
[UInt32.instSemiringUInt32.proof_2,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt32.zero_def, UInt32.add_def, UInt32.mk, OfNat.ofNat, zero_add, UInt32.val, UInt32.mk_val_eq, eq_self, propext, forall_const, UInt32]]
[Lean.Elab.Term.Quotation.HeadInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Quotation.HeadInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.ClientCapabilities.toCtorIdx,[OfNat.ofNat]]
[Lean.Lsp.ServerInfo.version?,[]]
[Lean.Parser.Tactic.field,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser, Lean.ParserDescr.symbol]]
[Lean.RecursorVal.noConfusionType,[]]
[Lean.Elab.Tactic.ElimApp.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.ElimApp.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Formatter.tokenWithAntiquot.formatter,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, Lean.Syntax.isTokenAntiquot, Bool.true, Lean.PrettyPrinter.Formatter.visitArgs]]
[Lean.AttributeImplCore.descr,[]]
[Lean.Lsp.FileSource.noConfusionType,[]]
[Lean.Parser.Term.char,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.charLit]]
[Lean.Meta.SimpExtension,[Lean.SimpleScopedEnvExtension, Lean.Meta.SimpEntry, Lean.Meta.SimpLemmas]]
[Lean.instFromJsonLeanPaths,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.SearchPath, Pure.pure, Lean.LeanPaths.mk]]
[StateCpsT.runK_bind_pure,[rfl]]
[Lean.Parser.InputContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.InputContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.numLitFn,[ite, Eq, and, not, Lean.Parser.ParserState.hasError, Lean.Syntax.isOfKind, Array.back, Lean.Parser.ParserState.stxStack, Lean.numLitKind, Bool.true, Lean.Parser.ParserState.mkErrorAt, Option.some]]
[Lean.Lsp.TextDocumentSyncOptions.openClose,[]]
[EStateM.throw,[EStateM.Result.error]]
[Lean.Meta.DiscrTree.instToFormatKey,[Std.ToFormat.mk, Lean.Meta.DiscrTree.Key.format]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.lhs,[]]
[Lean.Meta.exactlyOne,[List.nil, List.cons, Lean.Meta.MetaM, Lean.MVarId, Pure.pure, Lean.throwError]]
[Lean.Export.Entry.defn.inj,[]]
[Lean.Meta.AuxLemmas.lemmas,[]]
[Lean.Parser.testParseModuleAux,[Lean.Parser.testParseModuleAux.parse]]
[Lean.Meta.removeUnused,[Bind.bind, Lean.Meta.getLocalInstances, Lean.MonadLCtx.getLCtx, Array.foldrM, Lean.Meta.MetaM, Prod, Lean.LocalContext, Lean.LocalInstances, Array, Lean.Expr, Lean.CollectFVars.State, ite, Eq, Std.RBTree.contains, Lean.CollectFVars.State.fvarSet, Lean.Expr.fvarId!, Bool.true, Lean.Meta.inferType, StateRefT'.run, Lean.Meta.collectUsedFVars, Pure.pure, Prod.mk, Array.push, Lean.LocalContext.erase, Lean.LocalInstances.erase, List.toArray, List.nil, Array.size, OfNat.ofNat, Array.reverse]]
[Lean.Core.checkMaxHeartbeats,[Bind.bind, MonadReader.read, Lean.Core.checkMaxHeartbeatsCore, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Core.Context.maxHeartbeats]]
[Lean.Lsp.TextDocumentRegistrationOptions.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.TextDocumentRegistrationOptions.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Int.negSucc_ofNat_eq,[rfl]]
[Lean.Level.data,[Lean.Level.Data]]
[Lean.Elab.OpenDecl.instMonadResolveNameM,[Lean.MonadResolveName.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Elab.OpenDecl.State.currNamespace, Lean.Elab.OpenDecl.State.openDecls]]
[Lean.Elab.Frontend.State.commandState,[]]
[Lean.IR.formatDecl,[Std.Format, HAppend.hAppend, Std.Format.text, Std.ToFormat.format, Lean.IR.formatParams, Std.Format.nest, Int.ofNat, Std.Format.line, Lean.IR.formatFnBody]]
[Lean.IR.EmitC.emitUSet,[Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn]]
[Lean.Parser.Command.set_option.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter, Lean.ppSpace.formatter, Lean.Parser.Command.optionValue.formatter]]
[PSigma.revLex.proof_1,[WellFounded.intro, Acc, PSigma.RevLex, PSigma.revLexAccessible, WellFounded.apply]]
[Subtype.coind_injective,[congrArg, Subtype.val]]
[iff_self,[propext, Iff.intro, trivial, id]]
[Std.Format.noConfusionType,[]]
[Lean.Export.Alloc.map,[]]
[Lean.Lsp.WaitForDiagnostics.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.WaitForDiagnostics.toCtorIdx]]
[Lean.Meta.replaceTargetDefEq,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType, ite, Eq, BEq.beq, Bool.true, Pure.pure, Lean.Meta.getMVarTag, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.mkExpectedTypeHint, Lean.Meta.assignExprMVar, Lean.Expr.mvarId!]]
[LawfulApplicative.noConfusionType,[]]
[Lean.Syntax.atom.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Syntax.atom, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.mkFreshLevelMVarsFor,[Lean.Meta.mkFreshLevelMVars, Lean.ConstantInfo.numLevelParams]]
[Lean.MonadFileMap.noConfusionType,[]]
[Lean.Elab.Info.fmtHover?.fmtTerm?,[Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofCompletionInfo, Lean.Meta.MetaM, Option, Std.Format, Bind.bind, Lean.Meta.inferType, Lean.Elab.TermInfo.expr, Lean.MonadWithOptions.withOptions, Lean.Option.set, Lean.pp.fullNames, Bool.true, Lean.Meta.ppExpr, Pure.pure, Option.some, HAppend.hAppend, Std.ToFormat.format, Lean.Elab.FieldInfo.val, Lean.Elab.FieldInfo.fieldName, Option.none]]
[ByteArray.getOp,[ByteArray.get!]]
[Subtype.val_prop,[Subtype.property]]
[Char.val_eq_of_eq,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Eq, Char.val, rfl]]
[Lean.ExprStructEq.hash,[UInt64, Lean.Expr.hash]]
[Lean.Elab.Term.instInhabitedNamedArg,[Inhabited.mk, Lean.Elab.Term.NamedArg.mk, arbitrary]]
[Lean.Meta.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.instInhabitedAxiomVal,[Inhabited.mk, Lean.AxiomVal.mk, arbitrary]]
[Lean.MetavarContext.LevelMVarToParam.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MetavarContext.LevelMVarToParam.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.symbolFn,[Lean.Parser.symbolFnAux, HAppend.hAppend]]
[Lean.Parser.precedence.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.precedenceParser.parenthesizer, Lean.Parser.maxPrec]]
[Lean.Parser.Command.declModifiersF.formatter,[Lean.Parser.Command.declModifiers.formatter, Bool.false]]
[Lean.Meta.CongrTheorem.argKinds,[]]
[Lean.Core.State.mk.inj,[And.intro]]
[Std.PersistentHashMap.Node.noConfusionType,[]]
[Std.PersistentHashSet.instInhabitedPersistentHashSet,[Inhabited.mk, Std.PersistentHashSet.empty]]
[Lean.Widget.addInteractiveHypothesis,[Bind.bind, Lean.Widget.exprToInteractive, Option.mapM, Lean.Meta.isClass?, Lean.Meta.instantiateMVars, Pure.pure, Array.push, Lean.Widget.InteractiveHypothesis.mk, Array.map, ToString.toString, Option.isSome, Lean.Expr.isSort]]
[Equivalence.refl,[]]
[instDivUInt16,[Div.mk, UInt16.div]]
[Lean.InductiveVal.isReflexive,[]]
[max_lt,[Or.elim, le_or_gt, Eq.mpr, Eq.refl, LT.lt, max, max_eq_right, max_eq_left_of_lt]]
[UInt64.land,[UInt64.mk, Fin.land, UInt64.val]]
[Lean.Parser.Attr.externEntry.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.ident.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.strLit.formatter]]
[Lean.Server.Snapshots.Snapshot.cmdState,[]]
[Lean.Elab.Command.ElabStructResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[«term_\_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.change,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getMVarType, ite, Eq, Bool.true, Lean.Meta.isDefEq, Pure.pure, PUnit.unit, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Syntax.missing]]
[Lean.Server.Watchdog.FileWorkerMap,[Std.RBMap, Lean.Lsp.DocumentUri, Lean.Server.Watchdog.FileWorker, Ord.compare]]
[Mathlib.Prelude.Rename.getRenameMap,[Lean.SimplePersistentEnvExtension.getState, Mathlib.Prelude.Rename.renameExtension]]
[Lean.Level.PP.Result.maxNode.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.refl, SizeOf.sizeOf, List.nil, Eq.trans, HAdd.hAdd, Eq.symm, List.cons.sizeOf_spec]]
[List.length_map,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.length, List.map_nil, List.length_nil, eq_true_of_decide, Eq.refl, Bool.true, List.map_cons, List.length_cons, List.map, Nat.succ, eq_self]]
[Lean.Parser.ident.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.identKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.identNoAntiquot.parenthesizer]]
[Lean.Meta.hasAssignableMVar,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.hasAssignableMVar]]
[Lean.Widget.InteractiveTermGoal.hyps,[]]
[Lean.Parser.Term.doIdDecl,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.Term.ident, Lean.Parser.Term.optType, Lean.Parser.Term.leftArrow, Lean.Parser.doElemParser]]
[Lean.Elab.DefKind.isTheorem,[Lean.Elab.DefKind.def, Unit.unit, Lean.Elab.DefKind.example, Lean.Elab.DefKind.opaque, Lean.Elab.DefKind.abbrev, Bool, Bool.true, Bool.false]]
[Lean.IR.IRType.tobject.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Tactic.trans,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[eq_true_of_decide,[propext, Iff.intro, trivial, of_decide_eq_true]]
[Lean.Elab.Tactic.getInductiveValFromMajor,[Lean.Elab.Tactic.liftMetaMAtMain, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnf, Lean.matchConstInduct, Lean.Expr.getAppFn, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Syntax.missing, Pure.pure]]
[Lean.Lsp.DocumentHighlightKind.noConfusion,[noConfusionEnum, Lean.Lsp.DocumentHighlightKind.toCtorIdx]]
[Lean.instHashableLiteral,[Hashable.mk, Lean.Literal.hash]]
[Lean.observing?,[Bind.bind, Lean.MonadBacktrack.saveState, MonadExcept.tryCatch, Pure.pure, DoResultPR.pure, PUnit.unit, Lean.MonadBacktrack.restoreState, DoResultPR.return, Option.none, Option, Option.some]]
[Lean.KeyedDeclsAttribute.Def.evalKey,[]]
[instLTUInt64,[LT.mk, UInt64.lt]]
[Lean.Elab.instInhabitedMacroExpansionInfo,[Inhabited.mk, Lean.Elab.MacroExpansionInfo.mk, arbitrary]]
[Lean.Meta.mkGeneralizationForbiddenSet.visit,[Bind.bind, Lean.Meta.getLocalDecl, Lean.Meta.instantiateMVars, Lean.LocalDecl.type, Option.none, Lean.Meta.MetaM, Prod, List, Lean.FVarId, Lean.FVarIdSet, Lean.LocalDecl.value?, Pure.pure, PUnit.unit]]
[Lean.Lsp.CompletionList.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.CompletionList.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.instInhabitedData_1,[inferInstanceAs, Inhabited, UInt64]]
[Lean.NamingContext.noConfusionType,[]]
[Lean.PrettyPrinter.Formatter.node.formatter,[Bind.bind, Lean.PrettyPrinter.Formatter.checkKind, Lean.PrettyPrinter.Formatter.visitArgs]]
[xor_false,[funext, of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, Or, false_and, Not, And, eq_true_of_decide, Eq.refl, Bool.true, and_true, false_or, id_eq, eq_self, propext, implies_true_iff]]
[Lean.Parser.Tactic.clarify,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.sepBy1]]
[List.inj_on,[Eq]]
[List.decidablePairwise.proof_4,[Eq.symm, eq_of_heq, Eq.refl, List.cons, HEq.refl, False]]
[Mathlib.Tactic.Lint.nolint,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[Lean.getPPAnalyzeTypeAscriptions,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.typeAscriptions, Lean.Option.defValue]]
[Lean.Environment.noConfusionType,[]]
[Lean.Declaration.thmDecl.injEq,[Eq.propIntro, Eq.refl, Lean.Declaration.thmDecl, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.withNestedTraces,[Bind.bind, Lean.getTraces, Lean.modifyTraces, Std.PersistentArray.mk, Lean.MonadRef.getRef, tryFinally, ite, Eq, BEq.beq, Std.PersistentArray.size, OfNat.ofNat, Bool.true, and, Lean.MessageData.isNest, Lean.TraceElem.msg, Std.PersistentArray.getOp, HAppend.hAppend, Std.PersistentArray.push, Lean.TraceElem.mk, Lean.MessageData.nestD]]
[UInt16.eq_of_val_eq,[Eq, congrArg, UInt16.mk]]
[ExceptT.bind_pure_comp,[rfl]]
[instToFormat,[Std.ToFormat.mk, Function.comp, Std.Format.text, ToString.toString]]
[SeqLeft.noConfusionType,[]]
[Lean.Elab.Term.Do.ToCodeBlock.Catch.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.injections,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Meta.markSmartUnfoldigMatchAlt,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Parser.ParserState.errorMsg,[]]
[Lean.StructureDescr.fields,[]]
[OptionT,[Option]]
[Fin.overflowingAdd,[Prod.mk, Decidable.decide, LE.le, HAdd.hAdd, Fin.val]]
[Lean.Meta.AssertAfterResult.mvarId,[]]
[Lean.Parser.Attr.elementwise,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[decidable_of_decidable_of_iff,[dite, Decidable.isTrue, Iff.mp, Decidable.isFalse, decidable_of_decidable_of_iff.proof_1]]
[Lean.IR.mkFAppExpr,[Lean.IR.Expr.fap]]
[Lean.Parser.Term.binderTactic.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Tactic.tacticSeq.parenthesizer]]
[Lean.instBEqAttributeKind,[BEq.mk, BEq.beq, Lean.AttributeKind.toCtorIdx]]
[Mathlib.Tactic.Ext.mkAndN,[Unit.unit, List.cons, Lean.Expr, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.mkAnd, PProd.fst]]
[Lean.Parser.Command.«command_Notation3_____=>_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.Parser.Command.notation3Item, Lean.ParserDescr.cat]]
[Lean.mkApp10,[Lean.mkApp6, Lean.mkApp4]]
[UInt8.size,[OfNat.ofNat]]
[Lean.Level.isParam,[Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.mvar, Bool, Bool.true, Bool.false]]
[Lean.PrettyPrinter.Delaborator.SubExpr.mk.inj,[And.intro]]
[Lean.Meta.AbstractMVars.State.fvars,[]]
[Lean.Server.Watchdog.WorkerState.running.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.FVarSubst.erase,[Lean.Meta.FVarSubst.mk, Std.AssocList.erase, Lean.Meta.FVarSubst.map]]
[Lean.Lsp.instToJsonTextDocumentPositionParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, List.nil, Lean.Lsp.TextDocumentPositionParams.position]]
[Lean.Xml.Parser.Enumeration,[Bind.bind, Lean.Parsec.skipChar, Char.ofNat, SeqRight.seqRight, optional, Lean.Xml.Parser.S, Lean.Xml.Parser.Nmtoken, Lean.Parsec.many]]
[Lean.Elab.TermInfo.noConfusionType,[]]
[Std.RBMap.size,[Std.RBMap.fold, HAdd.hAdd, OfNat.ofNat]]
[Lean.Level.hash,[Lean.Level.Data.hash, Lean.Level.data]]
[Lean.Meta.SimpExtension.getLemmas,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.ScopedEnvExtension.getState]]
[Prod.swap_bijective,[And.intro, Prod.swap_injective, Prod.swap_surjective]]
[Lean.PrettyPrinter.Delaborator.SubExpr.descend,[withTheReader, Lean.PrettyPrinter.Delaborator.SubExpr, Lean.PrettyPrinter.Delaborator.SubExpr.mk, HAdd.hAdd, HMul.hMul, Lean.PrettyPrinter.Delaborator.SubExpr.pos, Lean.PrettyPrinter.Delaborator.SubExpr.maxChildren]]
[Lean.Elab.Tactic.evalExistsIntro,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Tactic.evalApplyLikeTactic, Bind.bind, Lean.Meta.existsIntro, Pure.pure, List.cons, List.nil, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Elab.Term.ElabAppArgs.State.toSetErrorCtx,[]]
[not_exists,[exists_imp_distrib]]
[Lean.Expr.hasExprMVarEx,[Lean.Expr.hasExprMVar]]
[Lean.PrettyPrinter.Delaborator.State.infos,[]]
[Lean.BinderInfo.isImplicit,[Lean.BinderInfo.default, Unit.unit, Lean.BinderInfo.strictImplicit, Lean.BinderInfo.instImplicit, Lean.BinderInfo.auxDecl, Bool, Bool.true, Bool.false]]
[Lean.getPPAnalyzeTrustKnownFOType2TypeHOFuns,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.trustKnownFOType2TypeHOFuns, Lean.Option.defValue]]
[Lean.Server.FileWorker.WorkerContext.srcSearchPath,[]]
[Lean.Expr.getUsedConstants,[Lean.Expr.foldConsts, List.toArray, List.nil, Array.push]]
[imp_congr_ctx,[Iff.trans, imp_congr_left, imp_congr_right]]
[Lean.DefinitionSafety.partial.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Expr.withApp,[Lean.Expr.withAppAux, Array.mkArray, HSub.hSub, OfNat.ofNat]]
[Lean.Elab.Term.Do.mkFreshJP,[ite, Eq, Array.isEmpty, Bool.true, Bind.bind, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, List.toArray, List.cons, Prod.mk, Bool.false, List.nil]]
[Lean.Elab.Command.StructView.type,[]]
[IsMulLeftCancel.noConfusionType,[]]
[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer,[SeqRight.seqRight]]
[«term_>>>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Syntax.getSepArgs,[Array.getSepElems, Lean.Syntax.getArgs]]
[Lean.StructureInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Function.«term_∘₂_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[List.toFloatArray.loop,[FloatArray, PProd.fst, FloatArray.push]]
[bind_congr,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Bind.bind, funext, eq_self]]
[Equiv.invFun,[]]
[Lean.KeyedDeclsAttribute.ExtensionState.insert,[Lean.KeyedDeclsAttribute.ExtensionState.mk, List.cons, Lean.KeyedDeclsAttribute.AttributeEntry.toOLeanEntry, Lean.KeyedDeclsAttribute.ExtensionState.newEntries, Unit.unit, Lean.KeyedDeclsAttribute.Table, Lean.SMap.find?, Lean.KeyedDeclsAttribute.OLeanEntry.key, Lean.SMap.insert, List.nil, Lean.KeyedDeclsAttribute.ExtensionState.table, Std.PersistentHashSet.insert, Lean.KeyedDeclsAttribute.ExtensionState.declNames, Lean.KeyedDeclsAttribute.OLeanEntry.declName, Std.PersistentHashSet.erase, Lean.KeyedDeclsAttribute.ExtensionState.erased]]
[Lean.Meta.Match.Extension.Entry.mk.inj,[And.intro]]
[Lean.Elab.Command.StructCtorView.noConfusionType,[]]
[Lean.MessageData.withNamingContext.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Export.biStr,[Unit.unit, String, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.PrettyPrinter.mkFormatterAttribute,[Lean.KeyedDeclsAttribute.init, Lean.KeyedDeclsAttribute.Def.mk, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.MonadEnv.getEnv, Lean.Attribute.Builtin.getId, ite, Eq, or, and, Option.isSome, Lean.Environment.find?, Lean.Parser.isValidSyntaxNodeKind, Bool.true, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.PrettyPrinter.Parenthesizer.State.contCat,[]]
[Lean.Rat.instDivRat,[Div.mk, HMul.hMul, Lean.Rat.inv]]
[runST,[Unit, Unit.unit]]
[Lean.MessageData.node.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.trans, Eq.refl, SizeOf.sizeOf, List.nil, HAdd.hAdd, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec]]
[Lean.instInhabitedMetavarKind,[Inhabited.mk, Lean.MetavarKind.natural]]
[Lean.Elab.Term.Do.hasExitPointPred,[Lean.Elab.Term.Do.hasExitPointPred.loop]]
[Lean.ToJson.toJson,[]]
[Lean.Parser.ParserExtension.Entry.kind.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.ParserExtension.Entry.kind, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.mkApp,[Lean.Expr.app, Lean.Expr.mkData, mixHash, UInt8.toUInt64, Hashable.hash, max, Lean.Expr.looseBVarRange, or, Lean.Expr.hasFVar, Lean.Expr.hasExprMVar, Lean.Expr.hasLevelMVar, Lean.Expr.hasLevelParam]]
[Lean.IR.FnBody.ret.injEq,[Eq.propIntro, Eq.refl, Lean.IR.FnBody.ret, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.instantiateForall,[OfNat.ofNat]]
[Lean.Expr.binderInfo,[Lean.Expr.Data.binderInfo, Lean.Expr.data]]
[Lean.Elab.log,[Bind.bind, Lean.Elab.MonadLog.getRef, Lean.Elab.logAt]]
[Function.sometimes_spec,[Eq.mpr, Eq.refl, Function.sometimes, Function.sometimes_eq]]
[Lean.Meta.GeneralizeIndicesSubgoal.fvarId,[]]
[Lean.Lsp.WorkDoneProgressReport.message?,[]]
[Array.forInUnsafe,[OfNat.ofNat, Array.forInUnsafe.loop]]
[Lean.Macro.instInhabitedMethods,[Inhabited.mk, Lean.Macro.Methods.mk, arbitrary]]
[Lean.Parser.PrattParsingTables.leadingParsers,[]]
[Mathlib.Tactic.Ext.tacticApplyExtLemma,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Core.betaReduce,[Lean.Core.transform, Pure.pure, Lean.TransformStep.visit, Lean.Expr.headBeta, Lean.TransformStep.done]]
[Lean.getDefaultFnForField?,[Option.none, Option, Lean.Name, Lean.getProjFnForField?, ite, Eq, Lean.Environment.contains, Bool.true, Option.some]]
[Nat.pred_inj,[Eq, Eq.mpr, Eq.refl, HAdd.hAdd, OfNat.ofNat, rfl, absurd, Nat.lt_irrefl]]
[Lean.Syntax.antiquotKind?,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Syntax.atom, Lean.Syntax.ident, Option, Lean.SyntaxNodeKind, ite, Lean.Syntax.isOfKind, Array.getOp, OfNat.ofNat, Lean.Name.mkStr, Bool.true, Option.some, Option.none]]
[Lean.Parser.Tactic.mkDecorations,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[noConfusionEnum,[dite, Eq, cast, noConfusionEnum.proof_1, False.elim, noConfusionEnum.proof_2]]
[Lean.Meta.SizeOfSpecNested.Context.indInfo,[]]
[Lean.Meta.revert,[ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Prod.mk, List.toArray, List.nil, Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, ForIn.forIn, PUnit.unit, Lean.Meta.getLocalDecl, Lean.LocalDecl.isAuxDecl, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkFVar, ForInStep.yield, Lean.MonadMCtx.getMCtx, Lean.MonadLCtx.getLCtx, Lean.Meta.MetaM, Prod, Array, Lean.FVarId, Lean.MVarId, Lean.MetavarContext.MkBinding.collectDeps, MProd.mk, Lean.Expr.fvarId!, Lean.Meta.clear, Lean.Meta.getMVarTag, Lean.Meta.setMVarKind, Lean.MetavarKind.natural, tryFinally, Lean.Meta.liftMkBindingM, Lean.MetavarContext.revert, Lean.MetavarKind.syntheticOpaque]]
[Lean.Elab.Command.expandBuiltinInitialize,[Lean.Elab.Command.expandInitCmd, Bool.true]]
[monadLift_self,[rfl]]
[Lean.Elab.Deriving.Context.typeInfos,[]]
[Lean.IR.LocalContextEntry.noConfusionType,[]]
[StateT.seqLeft_eq,[StateT.ext, of_eq_true, Eq.trans, congr, congrArg, Eq, StateT.run_seqLeft, StateT.run_seq, Functor.map, Function.const, Bind.bind, StateT.run_map, map_eq_pure_bind, Prod.mk, Prod.fst, Prod.snd, StateT.run, funext, LawfulMonad.bind_assoc, Pure.pure, LawfulMonad.pure_bind, congrFun, Function.const_apply, eq_self]]
[Lean.Meta.Match.instInhabitedPattern,[Inhabited.mk, Lean.Meta.Match.Pattern.inaccessible, arbitrary]]
[Nat.add_le_add,[Nat.le_trans, Nat.add_le_add_right, Nat.add_le_add_left]]
[Lean.Meta.Instances.eraseCore,[Lean.Meta.Instances.mk, Lean.Meta.Instances.discrTree, Std.PersistentHashSet.erase, Lean.Meta.Instances.instanceNames, Std.PersistentHashSet.insert, Lean.Meta.Instances.erased]]
[Lean.Meta.Cases.cases,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.MonadEnv.getEnv, ite, Eq, or, not, Lean.Environment.contains, Bool.true, Pure.pure, Option.none, Lean.Meta.getLocalDecl, Lean.Meta.whnf, Lean.LocalDecl.type, Lean.Expr.withApp, Lean.matchConstInduct, bne, Array.size, HAdd.hAdd, Lean.InductiveVal.numIndices, Lean.InductiveVal.numParams, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.Meta.MetaM, Option, Lean.Meta.Cases.Context, Lean.Environment.find?, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Lean.Meta.Cases.Context.mk, Unit.unit, Array, Lean.Meta.CasesSubgoal, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing, BEq.beq, Lean.Meta.Cases.Context.inductiveVal, OfNat.ofNat, Lean.Meta.inferType, Lean.mkFVar, Lean.Meta.getInductiveUniverseAndParams, Lean.Meta.induction, Array.mapIdx, Lean.Meta.CasesSubgoal.mk, Lean.Meta.generalizeIndices, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MessageData.ofGoal, Lean.Meta.GeneralizeIndicesSubgoal.mvarId, PUnit.unit]]
[Lean.Parser.Command.commentBody.formatter,[Lean.PrettyPrinter.Formatter.visitAtom, Lean.Name.anonymous]]
[Lean.PrettyPrinter.Parenthesizer.decQuotDepth.parenthesizer,[]]
[Lean.StructureInfo.mk.inj,[And.intro]]
[ulift.noConfusionType,[]]
[Lean.Parser.Command.declValEqns.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.Term.matchAltsWhereDecls.parenthesizer]]
[Lean.Export.Entry.name.inj,[]]
[Lean.Meta.mkFreshExprMVarWithId,[Unit.unit, Lean.Meta.MetaM, Lean.Expr, Bind.bind, Lean.MonadLCtx.getLCtx, Lean.Meta.getLocalInstances, Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.addExprMVarDecl, Pure.pure, Lean.mkMVar, OfNat.ofNat, Lean.Meta.mkFreshLevelMVar, Lean.Meta.mkFreshExprMVar, Option.some, Lean.mkSort, Lean.MetavarKind.natural, Lean.Name.anonymous]]
[IO.Error.inappropriateType.inj,[And.intro]]
[Lean.mkNatLit,[Lean.mkApp3, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.levelZero, List.nil, Lean.mkApp]]
[Lean.Meta.IndPredBelow.Context.noConfusionType,[]]
[MonadWithReader.noConfusionType,[]]
[Lean.ConstantInfo.opaqueInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.charLit.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.charLitKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.charLitNoAntiquot.parenthesizer]]
[Lean.Meta.InstanceEntry.val,[]]
[Lean.Lsp.instInhabitedPublishDiagnosticsParams,[Inhabited.mk, Lean.Lsp.PublishDiagnosticsParams.mk, arbitrary]]
[BEq.noConfusionType,[]]
[Lean.Expr.FindImpl.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.introMatch,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.matchAlts]]
[Array.back,[Array.get!, HSub.hSub, Array.size, OfNat.ofNat]]
[Nat.two_step_induction,[Unit.unit, PProd.fst, PProd.snd]]
[Classical.skolem,[Iff.intro, Classical.axiomOfChoice, Exists, Exists.intro]]
[Lean.Meta.DiscrTree.Trie.node.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, Eq.refl, List.nil, congr, Prod.mk, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec]]
[Lean.Meta.getExpectedNumArgs,[Bind.bind, Lean.Meta.getExpectedNumArgsAux, Lean.Meta.MetaM, Nat, Pure.pure]]
[instComplementUSize,[Complement.mk, USize.complement]]
[Lean.Parser.sepByElemParser.parenthesizer,[Lean.Parser.withAntiquotSpliceAndSuffix.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol.parenthesizer, HAppend.hAppend, String.trim]]
[Lean.SimplePersistentEnvExtensionDescr.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.SimplePersistentEnvExtensionDescr.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.registerSyntheticMVarWithCurrRef,[Bind.bind, Lean.MonadRef.getRef, Lean.Elab.Term.registerSyntheticMVar]]
[Lean.Parser.Term.doUnless.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withForbidden.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer]]
[Lean.MonadRecDepth.getMaxRecDepth,[]]
[Lean.IR.containsDecl,[Bind.bind, MonadState.get, Pure.pure, Lean.SMap.contains, Lean.SimplePersistentEnvExtension.getState, Lean.IR.declMapExt, Lean.IR.CompilerState.env]]
[ExceptCpsT.run_bind_lift,[rfl]]
[Int.subNatNat_add,[]]
[Lean.Parser.Tactic.omega,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary]]
[instMonadFinallyBaseIO,[inferInstanceAs, MonadFinally, EIO, Empty]]
[Lean.Meta.ToHide.Context.mk.inj,[]]
[Lean.getBuiltinAttributeImpl,[Bind.bind, ST.Ref.get, Lean.attributeMapRef, Unit.unit, IO, Lean.AttributeImpl, Std.PersistentHashMap.find?, Pure.pure, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString]]
[Lean.Compiler.SpecArgKind.fixed.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Attribute.Builtin.getPrio,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.getAttrParamOptPrio, Lean.Syntax.getOp, OfNat.ofNat, Lean.throwErrorAt, Lean.ToMessageData.toMessageData]]
[sorry,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[instDecidableEqUInt64,[UInt64.decEq]]
[IO.FS.Stream.Buffer.noConfusionType,[]]
[Lean.Compiler.FFI.getLinkerFlags,[HAppend.hAppend, List.toArray, List.cons, System.FilePath.toString, HDiv.hDiv, System.FilePath.mk, List.nil, String.splitOn, String.trim]]
[Lean.Parser.Command.structFields.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.manyIndent.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.ppLine.formatter, Lean.PrettyPrinter.Formatter.checkColGe.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.structExplicitBinder.formatter, Lean.Parser.Command.structImplicitBinder.formatter, Lean.Parser.Command.structInstBinder.formatter, Lean.Parser.Command.structSimpleBinder.formatter]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.motiveNamed,[]]
[String.nextWhile,[String.bsize]]
[Lean.Lsp.MarkupKind.plaintext.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[List.or_exists_of_exists_mem_cons,[Or, Exists, And, Mem.mem, Eq.mpr, Eq.refl, Eq.symm, Or.inl, Or.inr, Exists.intro, And.intro]]
[modify,[MonadState.modifyGet, Prod.mk, PUnit.unit]]
[Function.surjective.of_comp,[Exists, Eq, Exists.intro]]
[Lean.Elab.Term.MutualClosure.Replacement.apply,[Lean.Expr.replace, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Expr, Option.none, Std.RBMap.find?, Option.some]]
[Lean.Expr.isSyntheticSorry,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Name.anonymous, dite, Eq, Lean.Name.str, Eq.symm, Lean.Name.num, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[Lean.Parser.noFirstTokenInfo,[Lean.Parser.ParserInfo.mk, Lean.Parser.ParserInfo.collectTokens, Lean.Parser.ParserInfo.collectKinds]]
[Lean.Parser.AliasValue.unary.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Nat.forRevM,[Nat.forRevM.loop]]
[Lean.IR.Borrow.BorrowInfCtx.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.elabArg.parenthesizer,[Lean.Parser.Command.macroArg.parenthesizer]]
[Lean.Parser.Tactic.triv,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Parser.Level.ident.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.ident.parenthesizer]]
[instReprAtomBool,[ReprAtom.mk]]
[Lean.Server.RequestError.message,[]]
[Lean.Meta.Simp.Step.visit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.CompletionInfo.endSection.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.MaxIndex.collectDecl,[Lean.IR.MaxIndex.Collector, HAndThen.hAndThen, Array.foldl, OfNat.ofNat, Array.size, ite, GT.gt, Lean.IR.VarId.idx, Lean.IR.Param.x, Lean.IR.MaxIndex.collectFnBody]]
[List.get.proof_1,[Nat.le_of_succ_le_succ, List.length_cons]]
[List.card_insert_of_not_mem,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.card, List.insert_of_not_mem, Not, eq_false, eq_true_of_decide, Eq.refl, Bool.true, List.card_cons_of_not_mem, HAdd.hAdd, OfNat.ofNat, eq_self]]
[Lean.Xml.Parser.endl,[SeqRight.seqRight, HOrElse.hOrElse, Lean.Parsec.skipString, Lean.Parsec.skipChar, Char.ofNat, Pure.pure]]
[Lean.Meta.Simp.Config.iota,[]]
[ite_not,[dite_not]]
[Lean.Meta.processPostponed,[Bind.bind, Lean.Meta.getPostponed, Pure.pure, Std.PersistentArray.size, ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.processPostponed.loop]]
[exists_unique_congr,[exists_congr, and_congr, forall_congr', imp_congr_left]]
[USize.modn,[USize.mk, HMod.hMod, USize.val]]
[Lean.Lsp.instFromJsonDiagnosticSeverity,[Lean.FromJson.mk, Except.error, dite, Eq, Unit.unit, Eq.symm, Except.ok, Except, String, Lean.Lsp.DiagnosticSeverity, Lean.Json.getNat?, Pure.pure, Lean.Lsp.DiagnosticSeverity.error, Lean.Lsp.DiagnosticSeverity.warning, Lean.Lsp.DiagnosticSeverity.information, Lean.Lsp.DiagnosticSeverity.hint, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Lean.instReprPosition,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.Position.line, Std.Format.line, Lean.Position.column]]
[Function.involutive.bijective,[And.intro, Function.involutive.injective, Function.involutive.surjective]]
[IO.FileRight.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[String.pushn,[Nat.repeat, String.push]]
[trans_rel_right,[Eq.symm]]
[Lean.MessageLog.getInfoMessages,[Lean.MessageLog.mk, Std.PersistentArray.filter, Lean.MessageLog.msgs, Unit.unit, Lean.MessageSeverity.warning, Lean.MessageSeverity.error, Bool, Lean.Message.severity, Bool.true, Bool.false]]
[Lean.Elab.Term.StructInst.CtorHeaderResult.ctorFn,[]]
[Lean.mkRecName,[Lean.Name.mkStr]]
[Lean.Lsp.DocumentSymbolResult.noConfusionType,[]]
[StateT.monadControl,[MonadControl.mk, Prod, Bind.bind, MonadState.get, liftM, StateT.run, StateT, MonadStateOf.set, Pure.pure]]
[instInhabitedUInt64,[Inhabited.mk, UInt64.ofNatCore, OfNat.ofNat, instInhabitedUInt64.proof_1]]
[Lean.Lsp.instToJsonPosition,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.Position.line, List.nil, Lean.Lsp.Position.character]]
[List.filterMap,[Unit.unit, List, List.nil, PProd.fst, List.cons]]
[Lean.Elab.Command.mkNameFromParserSyntax,[Lean.Elab.mkUnusedBaseName, Lean.Name.mkSimple, Lean.Elab.Command.mkNameFromParserSyntax.visit, Lean.Elab.Command.mkNameFromParserSyntax.appendCatName]]
[Lean.Parser.convParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.IR.Checker.checkDecl,[Lean.IR.Checker.M, Unit, Lean.IR.Checker.withParams, Lean.IR.Checker.checkFnBody, Pure.pure, Unit.unit]]
[Lean.Elab.DefViewElabHeader.mk.inj,[And.intro]]
[Std.PersistentArray.branching,[USize.ofNat, HPow.hPow, OfNat.ofNat, USize.toNat, Std.PersistentArray.initShift]]
[Lean.Parser.Command.synth,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser]]
[Acc.ndrecOn,[]]
[Lean.Widget.MsgToInteractive.msg,[]]
[Lean.IR.HasIndex.visitJP,[BEq.beq, Lean.IR.JoinPointId.idx]]
[Lean.Meta.NormNum.LawfulZero.isNat_zero,[]]
[UInt8.instSemiringUInt8.proof_1,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt8.zero_def, UInt8.add_def, UInt8.mk, OfNat.ofNat, add_zero, UInt8.val, UInt8.mk_val_eq, eq_self, propext, forall_const, UInt8]]
[Array.toSubarray.proof_1,[Nat.le_refl, Array.size]]
[Lean.Parser.symbol.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.tokenWithAntiquot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.symbolNoAntiquot.parenthesizer]]
[Lean.Elab.Structural.mkIndPredBRecOn,[Bind.bind, liftM, Lean.Meta.inferType, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.Structural.RecArgInfo.fixedParams, Pure.pure, PUnit.unit]]
[Lean.Meta.PostponedEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.PostponedEntry.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.SymbolKind.field.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.PlainTermGoalParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt32.instRingUInt32.proof_4,[congrArg, UInt32.mk, SubNegMonoid.gsmul_neg', UInt32.val]]
[Lean.Expr.instToStringExpr,[ToString.mk, Lean.Expr.dbgToString]]
[Lean.Elab.Term.StructInst.trySynthStructInstance?,[ite, Eq, not, Lean.Elab.Term.StructInst.Struct.allDefault, Bool.true, Pure.pure, Option.none, MonadExcept.tryCatch, liftM, Lean.Meta.synthInstance?]]
[Prod.id_prod,[funext, Eq, Prod.mk, Prod.fst, Prod.snd, id, rfl]]
[EStateM.instReprResult,[Repr.mk, Std.Format, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg]]
[Lean.Parser.ppDedent,[id]]
[Lean.Module.noConfusionType,[]]
[Nat.right_distrib,[]]
[Lean.Lsp.instFromJsonCompletionItem,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, String, Option, Lean.Lsp.MarkupContent, Pure.pure, Lean.Lsp.CompletionItem.mk]]
[Lean.Syntax.expandInterpolatedStr,[Bind.bind, Lean.Syntax.expandInterpolatedStrChunks, Lean.Syntax.getArgs, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Lean.Meta.getArrayArgType,[Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, ite, Eq, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr]]
[Lean.Elab.PreDefinition.kind,[]]
[Lean.Elab.Term.elabLiftMethod,[Lean.throwErrorAt, Lean.ToMessageData.toMessageData]]
[Lean.Meta.Cases.Context.majorTypeArgs,[]]
[Lean.PrettyPrinter.Parenthesizer.maybeParenthesize,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.Syntax.MonadTraverser.getIdx, MonadState.get, MonadStateOf.set, Lean.PrettyPrinter.Parenthesizer.State.mk, Lean.PrettyPrinter.Parenthesizer.State.stxTrav, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Prod.mk, Lean.PrettyPrinter.Parenthesizer.State.contPrec, Lean.PrettyPrinter.Parenthesizer.State.contCat, Lean.indentD, Lean.MessageData.ofFormat, Std.ToFormat.format, Pure.pure, PUnit.unit]]
[Lean.Meta.mkEqNDRec,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.eq?, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr, Lean.Meta.getLevel, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.mkAppN, Lean.mkConst, List.cons, List.nil, List.toArray]]
[forall_imp,[]]
[Lean.Lsp.RpcKeepAliveParams.sessionId,[]]
[Lean.ConstructorVal.numFields,[]]
[Lean.Meta.SimpLemmas.lemmaNames,[]]
[Lean.Elab.Term.resolveName,[Bind.bind, MonadExcept.tryCatch, Lean.Elab.Term.resolveLocalName, Option.none, Lean.Elab.Term.TermElabM, DoResultPR, List, Prod, Lean.Expr, String, PUnit, ite, Eq, List.isEmpty, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, and, Lean.MonadLCtx.getLCtx, Lean.Elab.addCompletionInfo, Lean.Elab.CompletionInfo.id, Lean.Syntax.getId, Bool.false, Lean.Elab.Term.resolveName.process]]
[Lean.Elab.Tactic.instAlternativeTacticM,[Alternative.mk, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Elab.Tactic.orElse]]
[Std.ShareCommon.PersistentState.empty,[Std.ShareCommon.mkPersistentState, Unit.unit]]
[Lean.Elab.Term.LetIdDeclView.mk.inj,[And.intro]]
[Lean.Parser.Tactic.substVars,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Classical.propDecidable,[Classical.choice, Classical.propDecidable.proof_1]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.knowsLevel,[]]
[Lean.privateHeader,[Lean.Name.mkStr, Lean.Name.anonymous]]
[eq_max,[le_antisymm, max, le_max_left, le_max_right, max_le]]
[Nat.instAndOpNat,[AndOp.mk, Nat.land]]
[Lean.StructureDescr.mk.inj,[And.intro]]
[IO.Process.Stdio.null.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Expr.sort.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MetavarContext.DependsOn.main,[ite, Eq, and, not, Lean.Expr.hasFVar, Lean.Expr.hasMVar, Bool.true, Pure.pure, Bool.false]]
[Lean.Widget.InteractiveHypothesis.noConfusionType,[]]
[Lean.PersistentEnvExtension.getModuleEntries,[Array.get!, Lean.PersistentEnvExtensionState.importedEntries, Lean.EnvExtension.getState, Lean.PersistentEnvExtension.toEnvExtension]]
[Lean.Meta.mkLetCongr,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil]]
[Int.mul_negSucc_ofNat_negSucc_ofNat,[rfl]]
[Lean.Parser.AliasTable,[Lean.NameMap, Lean.Parser.AliasValue]]
[Std.PersistentHashMap.isEmpty,[BEq.beq, Std.PersistentHashMap.size, OfNat.ofNat]]
[StateT.run',[Functor.map, Prod.fst]]
[Mathlib.Tactic.Lint.NamedLinter.mk.inj,[And.intro]]
[ToStream.noConfusionType,[]]
[Std.PersistentHashMap.Entry.entry.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Level.hashEx,[UInt64.toUInt32, Hashable.hash]]
[Lean.Parser.ParserInfo.noConfusionType,[]]
[instSTWorld,[STWorld.mk]]
[Lean.Expr.hasFVar,[Lean.Expr.Data.hasFVar, Lean.Expr.data]]
[Lean.Parser.getBinaryAlias,[Bind.bind, Lean.Parser.getAlias, Unit.unit, Lean.Parser.AliasValue.const, Lean.Parser.AliasValue.unary, IO, Pure.pure, MonadExcept.throw, coe, HAppend.hAppend, ToString.toString]]
[WellFounded.induction,[WellFounded.recursion]]
[Lean.Parser.Command.in.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.withOpen.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.commandParser.formatter]]
[String.foldrAux,[String.foldrAux.loop]]
[Lean.IR.ExpandResetReuse.mkFresh,[MonadState.modifyGet, Prod.mk, Lean.IR.VarId.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Tactic.evalManyTacticOptSemi,[Lean.Syntax.forArgsM, Bind.bind, Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.saveTacticInfoForToken]]
[Lean.IR.mkIndexSet,[Std.RBTree.insert, Std.RBTree.empty]]
[guardHyp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.InfoCacheKey.nargs?,[]]
[Lean.Expr.ReplaceLevelImpl.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.ReplaceLevelImpl.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.CompletionItem.label,[]]
[instDecidableXor,[dite, Decidable.isFalse, instDecidableXor.proof_1, Decidable.isTrue, instDecidableXor.proof_2, instDecidableXor.proof_3, instDecidableXor.proof_4]]
[Lean.Elab.Deriving.mkInductArgNames,[Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.InductiveVal.toConstantVal, Bind.bind, ForIn.forIn, liftM, Lean.Meta.getLocalDecl, Lean.Expr.fvarId!, Lean.Core.mkFreshUserName, Lean.Name.eraseMacroScopes, Lean.LocalDecl.userName, Pure.pure, PUnit.unit, ForInStep.yield]]
[PSigma.lex,[PSigma.lex.proof_1]]
[Lean.Elab.Term.elabNumLit,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Syntax.isNatLit?, Bind.bind, Pure.pure, Lean.Elab.throwIllFormedSyntax]]
[Lean.Parser.Command.elab,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.suppressInsideQuot, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.docComment, Lean.Parser.Term.attrKind, Lean.Parser.symbol, Lean.Parser.optPrecedence, Lean.Parser.Command.optNamedName, Lean.Parser.Command.optNamedPrio, Lean.Parser.many1, Lean.Parser.Command.elabArg, Lean.Parser.Command.elabTail]]
[Lean.Elab.Term.NamedArg.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.NamedArg.mk, Eq.symm, eq_of_heq, HEq.refl]]
[List.decidablePairwise.proof_3,[Iff.mpr, List.pairwise_cons, And.intro]]
[Lean.Elab.Term.getCurrMacroScope,[Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Term.Context.currMacroScope]]
[ReaderT.read,[Pure.pure]]
[Lean.Meta.CaseArraySizesSubgoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.CaseArraySizesSubgoal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Closure.mkNextUserName,[Bind.bind, MonadState.get, modify, Lean.Meta.Closure.State.mk, Lean.Meta.Closure.State.visitedLevel, Lean.Meta.Closure.State.visitedExpr, Lean.Meta.Closure.State.levelParams, Lean.Meta.Closure.State.nextLevelIdx, Lean.Meta.Closure.State.levelArgs, Lean.Meta.Closure.State.newLocalDecls, Lean.Meta.Closure.State.newLocalDeclsForMVars, Lean.Meta.Closure.State.newLetDecls, HAdd.hAdd, Lean.Meta.Closure.State.nextExprIdx, OfNat.ofNat, Lean.Meta.Closure.State.exprMVarArgs, Lean.Meta.Closure.State.exprFVarArgs, Lean.Meta.Closure.State.toProcess, Pure.pure]]
[Lean.Widget.Lean.Widget.InteractiveGoals.instFromJsonRpcEncodingPacket,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Array, Pure.pure]]
[Lean.Meta.withDefault,[Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.default]]
[Lean.Server.FileWorker.RpcSession.store,[Prod.mk]]
[Equiv.refl.proof_2,[rfl]]
[Std.PersistentHashMap.EntriesNode,[Subtype, Std.PersistentHashMap.IsEntriesNode]]
[Lean.Elab.Term.MatchAltView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.MatchAltView.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.getPPAnalysisLetVarType,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false]]
[ByteSliceT.size,[HSub.hSub, ByteArray.size, ByteSliceT.arr, ByteSliceT.off]]
[iff_of_true,[Iff.intro]]
[Lean.Lsp.SymbolKind.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.SymbolKind.toCtorIdx]]
[EStateM.instMonadStateOfEStateM,[MonadStateOf.mk, EStateM.get, EStateM.set, EStateM.modifyGet]]
[Lean.Parser.Tactic.location,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.Parser.Tactic.locationWildcard, Lean.Parser.Tactic.locationHyp]]
[Option.some.injEq,[Eq.propIntro, Eq.refl, Option.some, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.MonadInfoTree.modifyInfoState,[]]
[MonadReaderOf.noConfusionType,[]]
[ExceptT.lift_pure,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, ExceptT.mk, LawfulApplicative.map_pure, Except.ok, Pure.pure, eq_self]]
[Lean.Meta.SynthInstance.ConsumerNode.size,[]]
[Eq.propIntro,[propext, Iff.intro]]
[Lean.Lsp.WorkDoneProgressReport.mk.inj,[And.intro]]
[Lean.addAlias,[Lean.PersistentEnvExtension.addEntry, Lean.aliasExtension, Prod.mk]]
[Lean.Meta.SynthInstance.resume,[Bind.bind, Lean.Meta.SynthInstance.getNextToResume, Lean.Meta.SynthInstance.SynthM, Unit, Unit.unit, Lean.Meta.SynthInstance.ConsumerNode.subgoals, panicWithPosWithDecl, OfNat.ofNat, Lean.Meta.SynthInstance.tryAnswer, Lean.Meta.SynthInstance.ConsumerNode.mctx, Pure.pure, Lean.Meta.withMCtx, Lean.traceM, Lean.Name.mkStr, Lean.Name.anonymous, liftM, Lean.Meta.inferType, Lean.Meta.SynthInstance.ConsumerNode.mvar, HAppend.hAppend, Lean.ToMessageData.toMessageData, HAdd.hAdd, Lean.Meta.SynthInstance.ConsumerNode.size, Lean.Meta.SynthInstance.Answer.size, Lean.Meta.SynthInstance.consume, Lean.Meta.SynthInstance.ConsumerNode.mk, Lean.Meta.SynthInstance.ConsumerNode.key]]
[Lean.Elab.isAbortTacticException,[Lean.Exception.error, Bool, BEq.beq, Lean.Elab.abortTacticExceptionId, Bool.false]]
[true_eq_false_of_false,[False.elim]]
[Char.toNat,[UInt32.toNat, Char.val]]
[Lean.Parser.optPrecedence.formatter,[Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.precedence.formatter]]
[Lean.Meta.IndPredBelow.BrecOnVariables.motives,[]]
[or_iff_right_of_imp,[Iff.intro, id, Or.inr]]
[Std.HashMap.insert'.proof_2,[]]
[Lean.ReducibilityStatus.reducible.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Nat.min,[ite, LE.le]]
[Lean.Parser.Tactic.Conv.convTrace_state,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.JsonRpc.Message.response.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Prod.snd,[]]
[Lean.Constructor.name,[]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withNaryFn,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.PrettyPrinter.Delaborator.SubExpr.getPos, withTheReader, Lean.PrettyPrinter.Delaborator.SubExpr, Lean.PrettyPrinter.Delaborator.SubExpr.mk, Lean.Expr.getAppFn]]
[Lean.Elab.Command.isDefLike,[or, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous]]
[lt_irrefl,[False, le_not_le_of_lt]]
[Lean.TransformStep.done.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.analyzeSort,[Pure.pure, Unit.unit]]
[Lean.Lsp.DocumentSymbol.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DocumentSymbol.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Simp.State.noConfusionType,[]]
[List.eraseReps,[Unit.unit, List, List.nil, List.eraseRepsAux]]
[NonScalar.noConfusionType,[]]
[Lean.Elab.WF.TerminationHint.none.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[List.map_subset,[Eq.mpr, Eq.trans, implies_congr, propext, List.mem_map, exists_imp_distrib, forall_congr, and_imp, Exists.intro, And.intro]]
[Lean.Parser.mkInputContext,[Lean.Parser.InputContext.mk, String.toFileMap]]
[Lean.Elab.MacroExpansionInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.MacroExpansionInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Json.parse,[Except, String, Lean.Json, Lean.Json.Parser.any, String.mkIterator, Except.ok, Except.error, HAppend.hAppend, ToString.toString, Nat.repr, String.Iterator.i]]
[Nat.coprime_one_right,[Nat.gcd_one_right]]
[Lean.getPPAnalyzeTrustSubtypeMk,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.trustSubtypeMk, Lean.Option.defValue]]
[Lean.Expr.hasMVarEx,[Lean.Expr.hasMVar]]
[Lean.Meta.mkArrow,[Bind.bind, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Lean.mkForall, Lean.BinderInfo.default]]
[Lean.LocalContext.isEmpty,[Std.PersistentHashMap.isEmpty, Lean.LocalContext.fvarIdToDecl]]
[Lean.Elab.DefKind.noConfusionType,[noConfusionTypeEnum, Lean.Elab.DefKind.toCtorIdx]]
[Array.swap,[Array.set, Array.swap.proof_1]]
[Lean.Meta.FunInfo.resultDeps,[]]
[Lean.Parser.withAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.orelseInfo, Lean.Parser.Parser.info, Lean.Parser.withAntiquotFn, Lean.Parser.Parser.fn]]
[Lean.MessageLog.errorsToWarnings,[Lean.MessageLog.mk, Std.PersistentArray.map, Lean.MessageSeverity.information, Lean.MessageSeverity.warning, Unit.unit, Lean.Message, Lean.Message.severity, Lean.Message.mk, Lean.Message.fileName, Lean.Message.pos, Lean.Message.endPos, Lean.Message.caption, Lean.Message.data, Lean.MessageLog.msgs]]
[Lean.setBuiltinInitAttr,[Lean.ParametricAttribute.setParam, Lean.builtinInitAttr]]
[SubNegMonoid.toAddMonoid,[]]
[Lean.Lsp.ClientInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.coprime.gcd_both,[Nat.coprime.gcd_right, Nat.coprime.gcd_left]]
[Lean.Widget.InteractiveGoals.noConfusionType,[]]
[Lean.mkQuotValEx,[Lean.QuotVal.mk, Lean.ConstantVal.mk]]
[Lean.Environment.freeRegions,[Array.forM, Lean.CompactedRegion.free, Lean.EnvironmentHeader.regions, Lean.Environment.header, OfNat.ofNat, Array.size]]
[Subtype.restrict,[Subtype.val]]
[Lean.Parser.Trie.instToStringTrie,[ToString.mk, Std.Format.pretty, flip, Std.Format.joinSep, Std.Format.line, Std.Format.defWidth]]
[List.eraseDupsAux,[List, List.reverse, Unit.unit, List.elem, PProd.fst, List.cons]]
[Lean.IR.UnreachableBranches.InterpState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.UnreachableBranches.InterpState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.FnBody.dec.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.elab.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.suppressInsideQuot.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.docComment.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optPrecedence.formatter, Lean.Parser.Command.optNamedName.formatter, Lean.Parser.Command.optNamedPrio.formatter, Lean.Parser.many1.formatter, Lean.Parser.Command.elabArg.formatter, Lean.Parser.Command.elabTail.formatter]]
[UInt8.isUpper,[and, Decidable.decide, GE.ge, OfNat.ofNat, LE.le]]
[Lean.KernelException.letTypeMismatch.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.MarkupContent.value,[]]
[or_self_right,[Iff.intro, Or.elim, id, Or.inr, Function.comp, Or.inl]]
[Lean.Lsp.instFromJsonHoverParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.HoverParams.mk, Lean.Lsp.TextDocumentPositionParams.mk]]
[Lean.Parsec.skip,[Lean.Parsec.ParseResult.success, String.Iterator.next, Unit.unit]]
[Sum.inhabitedRight,[Inhabited.mk, Sum.inr, arbitrary]]
[Lean.Elab.Term.registerMVarErrorInfo,[modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Std.RBMap.insert, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.MVarErrorInfo.mvarId, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState]]
[Lean.IR.ExpandResetReuse.releaseUnreadFields,[Nat.foldM, Unit.unit, Lean.IR.ExpandResetReuse.M, Lean.IR.FnBody, Array.get!, Pure.pure, Bind.bind, Lean.IR.ExpandResetReuse.mkFresh, Lean.IR.FnBody.vdecl, Lean.IR.IRType.object, Lean.IR.Expr.proj, Lean.IR.FnBody.dec, OfNat.ofNat, Bool.true, Bool.false, Array.size]]
[IO.FileRight.other,[]]
[Lean.Expr.headNumArgs,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.proj, Nat, PProd.fst, HAdd.hAdd, OfNat.ofNat, PProd.snd]]
[Lean.Elab.Term.elabLetDelayedDecl,[Lean.Elab.Term.elabLetDeclCore, Bool.true, Bool.false]]
[IO.Error.mkResourceExhaustedFile,[Function.comp, IO.Error.resourceExhausted, Option.some]]
[ulift.down,[]]
[Lean.Parser.Command.open.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.openDecl.parenthesizer]]
[IO.Error.protocolError.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.protocolError, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Syntax.SepArray.instCoeTailSepArrayArraySyntax,[CoeTail.mk, Lean.Syntax.SepArray.getElems]]
[Lean.Lsp.instToJsonSemanticTokensParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.SemanticTokensParams.textDocument, List.nil]]
[Lean.Parser.ParserState.lhsPrec,[]]
[Std.AssocList.instForInAssocListProd,[ForIn.mk, Std.AssocList.forIn]]
[Lean.Unhygienic.Context.noConfusionType,[]]
[Lean.Parser.Tactic.generalizeArg,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat]]
[Lean.Parser.Command.structExplicitBinder.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Command.declModifiers.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.inferMod.formatter, Lean.Parser.Command.optDeclSig.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.binderTactic.formatter, Lean.Parser.Term.binderDefault.formatter]]
[Lean.Elab.Command.checkRuleKind,[or, BEq.beq, HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous]]
[Std.PersistentHashMap.foldl,[Id.run, Std.PersistentHashMap.foldlM]]
[Lean.instToJsonLeanPaths,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.LeanPaths.oleanPath, List.nil, Lean.LeanPaths.srcPath]]
[instInhabitedForInStep,[Inhabited.mk, ForInStep.done, arbitrary]]
[Lean.Meta.AssertAfterResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Array.instBEqArray,[BEq.mk, Array.isEqv, BEq.beq]]
[Nat.lt_succ_of_lt,[Nat.le_succ_of_le]]
[Lean.Parser.Term.haveDecl,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HOrElse.hOrElse, Lean.Parser.Term.haveIdDecl, Lean.Parser.Term.letPatDecl, Lean.Parser.Term.haveEqnsDecl, Bool.false]]
[Lean.IR.Borrow.OwnedSet.instHashableKey,[Hashable.mk, Lean.IR.Borrow.OwnedSet.getHash]]
[UInt16.instCommRingUInt16,[CommRing.mk, UInt16.instCommRingUInt16.proof_1]]
[Lean.Meta.Match.instInhabitedAlt,[Inhabited.mk, Lean.Meta.Match.Alt.mk, arbitrary]]
[Lean.Meta.GeneralizeArg.expr,[]]
[List.nodupDecidable,[List.decidablePairwise]]
[Lean.instForInMVarIdMapProdMVarId,[inferInstanceAs, ForIn, Std.RBMap, Lean.MVarId, Lean.Name.quickCmp, Lean.MVarId.name, Prod]]
[Lean.Elab.Tactic.Simp.DischargeWrapper.custom.inj,[And.intro]]
[Lean.Server.FileWorker.updatePendingRequests,[modify, Lean.Server.FileWorker.WorkerState.mk, Lean.Server.FileWorker.WorkerState.doc, Lean.Server.FileWorker.WorkerState.pendingRequests, Lean.Server.FileWorker.WorkerState.rpcSessions]]
[Lean.Elab.Term.PatternVar.anonymousVar.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.PatternVar.anonymousVar, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.attr.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.attrParser.formatter]]
[Lean.Lsp.instReprLineRange,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.Lsp.LineRange.start, Std.Format.line, Lean.Lsp.LineRange.end]]
[Prod.ext_iff,[Eq.mpr, Eq.refl, Iff, Eq, And, Prod.fst, Prod.snd, Eq.symm, Prod.mk.eta, Prod.mk, propext, Prod.mk.inj_iff, Iff.rfl]]
[Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.addPrecCheck]]
[Nat.shiftLeft,[Nat, PProd.fst, HMul.hMul, OfNat.ofNat]]
[Lean.Parser.Command.declVal,[HOrElse.hOrElse, Lean.Parser.Command.declValSimple, Lean.Parser.Command.declValEqns, Lean.Parser.Command.whereStructInst]]
[Lean.Meta.Match.MatchEqns.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.MatchEqns.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Delaborator.DelabM,[ReaderT, Lean.PrettyPrinter.Delaborator.Context, StateRefT', IO.RealWorld, Lean.PrettyPrinter.Delaborator.State, Lean.Meta.MetaM]]
[Lean.Parser.Term.dynamicQuot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.PrettyPrinter.Formatter.parserOfStack.formatter]]
[Lean.instInhabitedStructureFieldInfo,[Inhabited.mk, Lean.StructureFieldInfo.mk, arbitrary]]
[Lean.Parser.Term.doTry.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer, Lean.Parser.many.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.doCatch.parenthesizer, Lean.Parser.Term.doCatchMatch.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.doFinally.parenthesizer]]
[StateCpsT.instMonadLiftStateCpsT,[MonadLift.mk, StateCpsT.lift]]
[Lean.Parser.Term.«term%%ₓ_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.Term.expandOptType,[ite, Eq, Lean.Syntax.isNone, Bool.true, Lean.mkHole, Lean.Syntax.getOp, OfNat.ofNat]]
[coe,[CoeT.coe]]
[Lean.Meta.getEqnsFor?,[Bind.bind, ST.Ref.get, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, Lean.Meta.MetaM, ForInStep, MProd, Option, Array, Lean.Name, PUnit, Pure.pure, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, MProd.fst]]
[Lean.instHashableMVarId,[Hashable.mk, UInt64, mixHash, OfNat.ofNat, Hashable.hash]]
[Lean.Compiler.foldNatMod,[Lean.Compiler.foldNatBinOp, Mod.mod]]
[Option.noConfusionType,[]]
[Lean.Parser.addBuiltinTrailingParser,[Lean.Parser.addBuiltinParser, Bool.false]]
[UInt16.instCommRingUInt16.proof_1,[UInt16.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, UInt16.val, UInt16.mul_def, CommSemiring.mul_comm]]
[List.nil_eq_append_iff,[Eq.mpr, Eq.refl, Iff, Eq, List.nil, HAppend.hAppend, And, propext, eq_comm, List.append_eq_nil, Iff.rfl]]
[Char.isValidChar_of_isValidChar_Nat,[isValidChar, UInt32.ofNat', Char.isValidUInt32, Or.inl, Or.inr, And.intro]]
[Lean.Meta.Match.Example.ctor.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.refl, List.nil, Eq.trans, Eq.symm, List.cons.sizeOf_spec]]
[IO.Error.illegalOperation.inj,[And.intro]]
[Id,[]]
[Lean.IR.ExplicitBoxing.BoxingContext.f,[]]
[Lean.Meta.getNondepPropHyps,[Lean.Meta.withMVarContext, Bind.bind, Lean.MonadLCtx.getLCtx, ForIn.forIn, Lean.Meta.getMVarType, ite, Eq, Std.HashSet.isEmpty, Bool.true, Pure.pure, List.toArray, List.nil, Std.HashSet.contains, Lean.LocalDecl.fvarId, PUnit.unit, ForInStep.yield, Lean.Meta.getNondepPropHyps.removeDeps]]
[Std.PHashSet,[Std.PersistentHashSet]]
[Lean.Elab.Command.ElabStructResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.ElabStructResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.mkInhabitantFor,[Bind.bind, MonadExcept.tryCatch, Lean.Meta.mkArbitrary, Pure.pure, Option.some, Option.none, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.Meta.mkLambdaFVars, Bool.false, Bool.true, Array.findM?, Lean.Meta.inferType, Lean.Meta.isDefEq, Array.size, Option, Lean.Meta.mkForallFVars, List.toArray, List.cons, List.nil, PProd.fst, Array.ofSubarray, Array.toSubarray, OfNat.ofNat, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[instToStreamRangeRange,[ToStream.mk]]
[List.forall_mem_singleton,[Eq.mpr, congrFun, congrArg, Iff, Eq.trans, forall_congr, implies_congr, propext, List.mem_singleton, Eq.refl, forall_eq, Iff.rfl]]
[Lean.Parser.evalInsideQuot,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, ite, Eq, and, Decidable.decide, GT.gt, Lean.Parser.ParserContext.quotDepth, OfNat.ofNat, not, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Option.get, Lean.Parser.ParserModuleContext.options, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.internal.parseQuotWithCurrentStage, Lean.Environment.contains, Lean.Parser.ParserModuleContext.env, Bool.true, Lean.Parser.evalParserConst, Lean.Parser.Parser.fn]]
[Lean.Elab.Structural.RecArgInfo.recArgPos,[HAdd.hAdd, Array.size, Lean.Elab.Structural.RecArgInfo.fixedParams, Lean.Elab.Structural.RecArgInfo.pos]]
[Lean.Server.instInhabitedRequestM,[Inhabited.mk, MonadExcept.throw, Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.internalError, ToString.toString, IO.userError]]
[Lean.HeadIndex.forallE.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Lsp.LocationLink.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.LocationLink.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Compiler.CSimp.Entry.fromDeclName,[]]
[Nat.eq_zero_or_eq_succ_pred,[of_eq_true, Eq.trans, congr, congrArg, Or, congrFun, Eq, Nat.zero_eq, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true, eq_false', Eq.symm, Nat.succ, Nat.pred_succ, eq_self]]
[ExceptCpsT.run_pure,[rfl]]
[Lean.Xml.Parser.NameStartChar,[Lean.Parsec.attempt, Bind.bind, Lean.Parsec.anyChar, ite, Or, And, LE.le, Char.ofNat, Pure.pure, Eq, Array.any, List.toArray, List.cons, Prod.mk, OfNat.ofNat, List.nil, Bool, Decidable.decide, Array.size, Bool.true, Lean.Parsec.fail]]
[Lean.Json.instToStringJson,[ToString.mk, Lean.Json.pretty, OfNat.ofNat]]
[Lean.isAttribute,[Std.PersistentHashMap.contains, Lean.AttributeExtensionState.map, Lean.PersistentEnvExtension.getState, Lean.attributeExtension]]
[Lean.Elab.Term.CoeImpl.«termCoe%_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Set.image,[setOf, Exists, And, Mem.mem, Eq]]
[Lean.Parser.Term.assert,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat, Lean.Parser.Term.optSemicolon]]
[Lean.Parser.Tactic.Conv.congr,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.IR.Arg.var.inj,[]]
[Tactic.TryThis.delabToRefinableSyntax,[Bind.bind, readThe, Lean.Core.Context, liftM, Lean.PrettyPrinter.delab, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, EmptyCollection.emptyCollection, Tactic.TryThis.replaceMVarsByUnderscores]]
[Nat.mul_zero,[rfl]]
[instStreamRangeNat,[Stream.mk, ite, LT.lt, Std.Range.start, Std.Range.stop, Option.some, Prod.mk, Std.Range.mk, HAdd.hAdd, Std.Range.step, Option.none]]
[Lean.Elab.Tactic.AuxMatchTermState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.AuxMatchTermState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Do.concat,[ite, Eq, Lean.Elab.Term.Do.hasTerminalAction, Lean.Elab.Term.Do.CodeBlock.code, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.throwErrorAt, Lean.ToMessageData.toMessageData]]
[Lean.Elab.Tactic.Location.targets.inj,[And.intro]]
[Lean.LocalContext.mkLocalDecl,[Lean.LocalContext, Lean.LocalContext.mk, Std.PersistentHashMap.insert, Std.PersistentArray.push, Option.some]]
[Lean.LazyInitExtension.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.UnreachableBranches.interpExpr,[Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Lean.IR.UnreachableBranches.M, Lean.IR.UnreachableBranches.Value, Bind.bind, Array.mapM, Lean.IR.UnreachableBranches.findArgValue, Pure.pure, Lean.IR.UnreachableBranches.Value.ctor, Lean.IR.UnreachableBranches.findVarValue, Lean.IR.UnreachableBranches.projValue, MonadReader.read, Unit.unit, Lean.IR.UnreachableBranches.getFunctionSummary?, Lean.IR.UnreachableBranches.InterpContext.env, MonadState.get, Array.findIdx?, Lean.IR.UnreachableBranches.InterpContext.decls, BEq.beq, Lean.IR.Decl.name, Std.PersistentArray.getOp, Lean.IR.UnreachableBranches.InterpState.funVals, Lean.IR.UnreachableBranches.Value.top]]
[noConfusionEnum.proof_2,[congrArg]]
[Lean.Server.Snapshots.Snapshot.beginPos,[]]
[Lean.«command_Unif_hint___Where_|-⊢_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.unifConstraintElem, Lean.unifConstraint]]
[Lean.SMap.switch,[ite, Eq, Lean.SMap.stage₁, Bool.true, Lean.SMap.mk, Bool.false, Lean.SMap.map₁, Lean.SMap.map₂]]
[Lean.registerTraceClass,[Lean.registerOption, HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous, Lean.OptionDecl.mk, Lean.DataValue.ofBool, Bool.false]]
[ByteArray.forIn.loop.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self]]
[Function.bijective.exists_unique,[Iff.mp, Function.bijective_iff_exists_unique]]
[Lean.IR.FnBody.split,[Prod.mk]]
[Std.RBNode.ibelow,[True, And]]
[Lean.Elab.Term.Quotation.elabMatchSyntax,[Lean.Elab.Term.adaptExpander, Lean.Elab.Term.Quotation.match_syntax.expand]]
[Std.PersistentHashMap.Node.collision.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.JsonRpc.RequestID.num.inj,[]]
[min,[ite, LE.le]]
[Lean.ExprSet,[Std.HashSet, Lean.Expr]]
[Lean.IR.FnBody.freeIndices,[Lean.IR.FnBody.collectFreeIndices, EmptyCollection.emptyCollection]]
[Lean.Parser.Term.parenSpecial.formatter,[Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.tupleTail.formatter, Lean.Parser.Term.typeAscription.formatter]]
[Array.reverse,[OfNat.ofNat, Array.reverse.rev]]
[Lean.Elab.Term.instInhabitedTermElabM,[Inhabited.mk, MonadExcept.throw, arbitrary]]
[Lean.popScope,[Bind.bind, ST.Ref.get, Lean.scopedEnvExtensionsRef, ForIn.forIn, PUnit.unit, Lean.MonadEnv.modifyEnv, Lean.ScopedEnvExtension.popScope, Pure.pure, ForInStep.yield]]
[Fin.ofNat,[Fin.mk, HMod.hMod, Nat.succ, Fin.ofNat.proof_1]]
[Lean.Meta.getDefaultInstancesPriorities,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Meta.DefaultInstances.priorities, Lean.SimplePersistentEnvExtension.getState, Lean.Meta.defaultInstanceExtension]]
[Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing,[Lean.Elab.Term.synthesizeSyntheticMVars, Bool.false]]
[ULift.down_up,[rfl]]
[List.append_ne_nil_of_ne_nil_right,[of_eq_true, Eq.trans, implies_congr_ctx, ne_eq, List.nil, HAppend.hAppend, congrArg, Not, propext, List.append_eq_nil, And, Eq, eq_false, and_false, eq_true_of_decide, Eq.refl, Bool.true, implies_true]]
[List.and,[List.all, id]]
[Lean.Parser.Trie.insert,[OfNat.ofNat, Lean.Parser.Trie.insert.loop, Lean.Parser.Trie.insert.insertEmpty]]
[Lean.Meta.dependsOn,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.exprDependsOn]]
[Lean.Elab.Term.Do.Alt.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Alt.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.JsonNumber.normalize,[Prod, Int, Nat, Id.run, ite, Eq, OfNat.ofNat, Prod.mk, Bind.bind, ForIn.forIn, HMod.hMod, Pure.pure, PUnit.unit, ForInStep.yield, ForInStep.done, HAdd.hAdd, Neg.neg, Int.ofNat]]
[InvImage.accessible,[InvImage.accessible.proof_1]]
[Nat.div_zero,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, OfNat.ofNat, Nat.div_eq, of_eq_true, Eq.trans, congrFun, congrArg, ite_congr, And, eq_false_of_decide, Bool.false, LE.le, false_and, HAdd.hAdd, Nat.sub_zero, ite_false, eq_true_of_decide, Bool.true]]
[Lean.Meta.getFVarsToGeneralize,[Bind.bind, Lean.Meta.mkGeneralizationForbiddenSet, Lean.Meta.getFVarSetToGeneralize, Lean.Meta.sortFVarIds, Std.RBTree.toArray]]
[Lean.Meta.Match.MatchEqns.mk.inj,[And.intro]]
[Lean.Expr.isArrow,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, not, Lean.Expr.hasLooseBVars, Bool.false]]
[IO.Error.mkInterrupted,[IO.Error.interrupted]]
[Lean.MapDeclarationExtension,[Lean.SimplePersistentEnvExtension, Prod, Lean.Name, Lean.NameMap]]
[Lean.Parser.ParserExtension.OLeanEntry.token.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.namedPattern.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkStackTop.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec]]
[Lean.Server.FileWorker.RpcSession.expireTime,[]]
[List.foldrM,[Pure.pure, Bind.bind, PProd.fst]]
[Function.inv_fun_eq_of_injective_of_right_inverse,[funext, Function.inv_fun, Eq.mpr, Eq.refl, Eq, Function.inv_fun_eq, Exists.intro]]
[Seq.seq,[]]
[Lean.Syntax.mkAntiquotSuffixSpliceNode,[Lean.mkNode, HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkAtom, List.nil]]
[UInt32.neg_def,[rfl]]
[Lean.Parser.Tactic.tacticSeqBracketed.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many.formatter, Lean.Parser.group.formatter, Lean.ppLine.formatter, Lean.Parser.tacticParser.formatter, Lean.Parser.optional.formatter, Lean.ppDedent.formatter]]
[decide_eq_false,[Eq, Decidable.decide, Bool.false, absurd, rfl]]
[Lean.IR.FnBody.case.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.case, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.DidChangeTextDocumentParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.DidChangeTextDocumentParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.MessageData.tagged.inj,[And.intro]]
[Lean.Meta.AssertAfterResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.AssertAfterResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isSubstLike,[or, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat]]
[Lean.IR.addDecls,[Array.forM, Lean.IR.addDecl, OfNat.ofNat, Array.size]]
[Lean.Constructor.type,[]]
[Lean.Parser.instInhabitedModuleParserState,[Inhabited.mk, Lean.Parser.ModuleParserState.mk, arbitrary]]
[Lean.Elab.Term.PatternVarDecl.anonymousVar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[SizeOf.sizeOf,[]]
[Lean.Elab.TermInfo.expr,[]]
[Lean.Lsp.RpcReleaseParams.sessionId,[]]
[Lean.PersistentExprStructMap,[Std.PHashMap, Lean.ExprStructEq]]
[Lean.Elab.Term.mkPairs,[HSub.hSub, Array.size, OfNat.ofNat, Array.back, Lean.Elab.Term.mkPairs.loop]]
[Lean.Expr.ibelow,[True, And]]
[Lean.Elab.Info.occursBefore?,[OptionM.run, Bind.bind, Lean.Elab.Info.tailPos?, guard, LE.le, Pure.pure, HSub.hSub]]
[Lean.Meta.CongrTheorem.noConfusionType,[]]
[Lean.Expr.looseBVarRangeEx,[Lean.Expr.Data.looseBVarRange, Lean.Expr.data]]
[Lean.MetaEval.noConfusionType,[]]
[Lean.Elab.Structural.RecArgInfo.indParams,[]]
[Lean.Meta.ToHide.Context.goalTarget,[]]
[List.toString,[Unit.unit, String, HAppend.hAppend, List.toStringAux, Bool.true, List.cons]]
[UInt16.sub,[UInt16.mk, HSub.hSub, UInt16.val]]
[Lean.Meta.getLevel,[Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Lean.Level, Pure.pure, Lean.Meta.isReadOnlyOrSyntheticOpaqueExprMVar, ite, Eq, Bool.true, Lean.Meta.throwTypeExcepted, Lean.Meta.mkFreshLevelMVar, Lean.Meta.assignExprMVar, Lean.mkSort]]
[Lean.Lsp.TextDocumentSyncKind.none.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.QuotVal.noConfusionType,[]]
[Std.Format.FlattenBehavior.noConfusion,[noConfusionEnum, Std.Format.FlattenBehavior.toCtorIdx]]
[String.csize,[UInt32.toNat, Char.utf8Size]]
[Lean.Lsp.LineRange.mk.inj,[And.intro]]
[lt_min,[Or.elim, le_or_gt, Eq.mpr, Eq.refl, LT.lt, min, min_eq_left, min_eq_right_of_lt]]
[Lean.Elab.instInhabitedInfoTree,[Inhabited.mk, Lean.Elab.InfoTree.node, arbitrary]]
[Lean.Parser.Tactic.cases',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.casesTarget, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.binderIdent]]
[Std.PersistentArray.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.PersistentArray.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.instFromJsonSemanticTokens,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Array, Nat, Pure.pure, Lean.Lsp.SemanticTokens.mk]]
[Lean.Parser.Term.doFor,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.sepBy1, Lean.Parser.Term.doForDecl, Bool.false, Lean.Parser.Term.doSeq]]
[Lean.ImportM.Context.mk.inj,[And.intro]]
[Lean.Parser.Tactic.ext1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.cat]]
[Nat.prod_dvd_and_dvd_of_dvd_prod.proof_1,[Eq.symm]]
[EStateM.Result.error.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[IO.FS.Stream.flush,[]]
[Lean.Meta.Match.InjectionAnyResult.noConfusionType,[]]
[Ring.gsmul_zero',[]]
[Lean.IR.EmitC.toHexDigit,[String.singleton, Nat.digitChar]]
[Lean.PrettyPrinter.Formatter,[Lean.PrettyPrinter.FormatterM, Unit]]
[Lean.Parser.Tactic.rcasesPat.quot,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[Lean.Elab.Command.Context.noConfusionType,[]]
[IO.FS.Stream.readMessage,[Bind.bind, IO.FS.Stream.readJson, IO, Lean.JsonRpc.Message, Lean.FromJson.fromJson?, Pure.pure, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Lean.Json.compress]]
[Lean.Lsp.ReferenceContext.includeDeclaration,[]]
[UInt32.shiftLeft,[UInt32.mk, HShiftLeft.hShiftLeft, UInt32.val, UInt32.modn, OfNat.ofNat]]
[MonadReader.noConfusionType,[]]
[Lean.PrettyPrinter.instOrElseFormatterM,[OrElse.mk, Lean.PrettyPrinter.FormatterM.orElse]]
[let_body_congr,[]]
[List.reverse_reverse,[Eq.mpr, Eq.refl, Eq, List.reverseAux, List.nil, List.reverseAux_reverseAux_nil, rfl]]
[FloatArray.getOp,[FloatArray.get!]]
[Function.surjective.exists,[Iff.intro, Exists, Exists.intro, Eq.symm]]
[Lean.MetavarContext.UnivMVarParamResult.mk.inj,[And.intro]]
[Int.natAbs_mul_self,[Eq, Int.ofNat, HMul.hMul, Int.natAbs, rfl]]
[Preorder.toLE,[]]
[Lean.Parser.Attr.instance.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.priorityParser.formatter]]
[Lean.Elab.Term.SyntheticMVarKind.postponed.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Syntax.antiquotSpliceKind?,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Syntax.atom, Lean.Syntax.ident, Option, Lean.SyntaxNodeKind, Option.some, Option.none]]
[Lean.IR.addBoxedVersionAux,[Bind.bind, Lean.IR.getEnv, ite, Eq, not, Lean.IR.ExplicitBoxing.requiresBoxedVersion, Bool.true, Pure.pure, Unit.unit, Lean.IR.explicitRC, Array.forM, Lean.IR.modifyEnv, Lean.IR.addDeclAux, OfNat.ofNat, Array.size]]
[Lean.Lsp.instFromJsonLineRange,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Nat, Pure.pure, Lean.Lsp.LineRange.mk]]
[MonadWithReader.withReader,[]]
[Lean.rootNamespace,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Xml.Parser.LeanChar,[Char]]
[Lean.NameSanitizerState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.NameSanitizerState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[CoeT.noConfusionType,[]]
[UInt64.le,[LE.le, UInt64.val]]
[Lean.«termMacro.trace[__]_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[Lean.Elab.Command.CollectAxioms.State.noConfusionType,[]]
[Std.PersistentArray.Stats.numNodes,[]]
[Lean.getPPAnalyzeKnowsType,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.knowsType, Lean.Option.defValue]]
[Lean.firstFrontendMacroScope,[HAdd.hAdd, Lean.reservedMacroScope, OfNat.ofNat]]
[min_eq_left,[Eq.symm, eq_min, le_refl]]
[Lean.Parser.Tactic.constructorM,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat]]
[Lean.IR.Checker.checkType,[ite, Eq, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Lean.Meta.SynthInstance.getSubgoals,[Bind.bind, Lean.Meta.inferType, List.toArray, List.nil, OfNat.ofNat, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Lean.Meta.SynthInstance.SubgoalsResult, Lean.Expr.getAppFn, Lean.MonadEnv.getEnv, ite, Eq, Lean.Meta.SynthInstance.hasInferTCGoalsRLAttribute, Bool.true, Pure.pure, Lean.Meta.SynthInstance.SubgoalsResult.mk, List.reverse, Lean.Meta.SynthInstance.SubgoalsResult.subgoals, Lean.Meta.SynthInstance.SubgoalsResult.instVal, Lean.Meta.SynthInstance.SubgoalsResult.instTypeBody]]
[Lean.Parser.scientificLitNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.scientificLitFn]]
[imp_false,[Iff.rfl]]
[Lean.SourceInfo.updateTrailing,[Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Lean.SourceInfo, Lean.SourceInfo.original]]
[List.findM?,[Unit.unit, Option, Pure.pure, Option.none, Bind.bind, Option.some, PProd.fst]]
[Quot.indBeta,[rfl]]
[Lean.Parser.withResultOfFn,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Parser.ParserState.pushSyntax, Lean.Parser.ParserState.popSyntax]]
[Tactic.Ring.horner_add_horner_gt,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Tactic.Ring.horner, Eq.symm, OfNat.ofNat, of_eq_true, Eq.trans, congr, congrArg, add_comm, HMul.hMul, HPow.hPow, add_assoc, congrFun, add_zero, add_mul, mul_assoc, pow_add, eq_self]]
[Nat.coprime.gcd_mul_left_cancel_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.gcd_comm, Nat.coprime.gcd_mul_left_cancel, rfl]]
[Lean.Parser.Tactic.tacticRfl,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.NamingContext.currNamespace,[]]
[UInt8.val_eq_of_eq,[Eq, UInt8.val, congrArg]]
[Lean.Meta.mkArbitrary,[Lean.Meta.mkAppOptM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Option.some, Option.none, List.nil]]
[Lean.Meta.Match.MatcherResult.counterExamples,[]]
[Lean.PrettyPrinter.Formatter.Context.table,[]]
[Lean.Meta.SimpLemma.keys,[]]
[Lean.Elab.Term.StructInst.Source.explicit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.le_refl,[Nat.le.refl]]
[Lean.OpenDecl.explicit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt32.toUInt8,[Nat.toUInt8, UInt32.toNat]]
[andM,[Bind.bind, Unit.unit, ToBool.toBool, Pure.pure]]
[Lean.Elab.Term.Do.ToCodeBlock.ensureEOS,[ite, Eq, List.isEmpty, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Std.RBNode.isBlack,[Std.RBNode.leaf, Std.RBNode.node, Std.Rbcolor.red, Bool, Bool.true, Bool.false]]
[List.rotateRight,[ite, LE.le, OfNat.ofNat, HAppend.hAppend]]
[IO.FS.Stream.Buffer.data,[]]
[Lean.PrettyPrinter.ppModule,[Bind.bind, Lean.PrettyPrinter.parenthesize, Lean.Parser.Module.module.parenthesizer, Lean.PrettyPrinter.format, Lean.Parser.Module.module.formatter]]
[Lean.Xml.Content.Element.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.tupleTail,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.sepBy1, Lean.Parser.termParser, Bool.false]]
[«term_::_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.mkOptionalNode,[Unit.unit, Lean.Syntax, Lean.mkNullNode, List.toArray, List.cons, List.nil]]
[Lean.KeyedDeclsAttribute.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.instToMessageDataExpr,[Lean.ToMessageData.mk, Lean.MessageData.ofExpr]]
[Lean.Meta.State.zetaFVarIds,[]]
[Lean.Compiler.natPowThreshold,[OfNat.ofNat]]
[Function.surj_inv,[Classical.choose]]
[Lean.Meta.IndPredBelow.BrecOnVariables.mk.inj,[And.intro]]
[Lean.InternalExceptionId.toString,[HAppend.hAppend, ToString.toString, Lean.InternalExceptionId.idx]]
[List.map_nil,[rfl]]
[String.instLTString,[LT.mk, LT.lt, String.data]]
[List.mem_inter_iff,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, List.mem_filter, List.nil, Decidable.decide, Mem.mem, congrFun, And, List.mem_nil_iff, Eq, Bool.true, false_and, eq_true_of_decide, Eq.refl, List.cons, List.mem_cons_iff, decide_eq_true_iff, iff_self, Or]]
[Lean.ConstantInfo.inductInfo.inj,[]]
[IO.AsyncList.instAppendAsyncList,[Append.mk, IO.AsyncList.append]]
[Lean.Lsp.Command.title,[]]
[Lean.Level.PP.Result.imaxNode.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.refl, SizeOf.sizeOf, List.nil, Eq.trans, HAdd.hAdd, Eq.symm, List.cons.sizeOf_spec]]
[SizeOf.noConfusionType,[]]
[Lean.instToExprUnit,[Lean.ToExpr.mk, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Lean.MonadHashMapCacheAdapter.noConfusionType,[]]
[Lean.Parser.Term.str.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.strLit.formatter]]
[Lean.Level.hasMVar,[Lean.Level.Data.hasMVar, Lean.Level.data]]
[Lean.ppDedent.formatter,[Bind.bind, Lean.MonadOptions.getOptions, Lean.PrettyPrinter.Formatter.indent, Option.some, HSub.hSub, OfNat.ofNat, Int.ofNat, Std.Format.getIndent]]
[LawfulFunctor.id_map,[]]
[Lean.Elab.Command.elabCheckFailure,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Elab.Command.failIfSucceeds, Lean.Elab.Command.elabCheckCore, Bool.false, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Elab.registerBuiltinDerivingHandlerWithArgs,[Bind.bind, liftM, IO.initializing, ite, Eq, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, IO.userError]]
[Nat.add_left_cancel,[Eq.mpr, implies_congr, congr, congrArg, Eq, Eq.trans, congrFun, HAdd.hAdd, Nat.zero_eq, Nat.zero_add, Eq.refl, Nat.succ_add, Nat.succ.injEq]]
[Lean.MetavarContext.instantiateMVars,[ite, Eq, not, Lean.Expr.hasMVar, Bool.true, Prod.mk, runST, StateRefT'.run, Lean.MonadCacheT.run]]
[Function.right_inverse_inv_fun,[Function.inv_fun_eq]]
[Lean.Parser.TokenCacheEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.TokenCacheEntry.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.StructInst.DefaultFields.State.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.StructInst.DefaultFields.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.nativeDecide.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.nonReservedSymbol.formatter, Bool.false]]
[List.disjoint_append_left,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, forall_congr, implies_congr, propext, List.mem_append, Eq.refl, False, or_imp_distrib, forall_and_distrib, And, iff_self]]
[Lean.Level.any,[Option.isSome, Lean.Level.find?]]
[Lean.Widget.Lean.MessageData.instRpcEncodingWithRpcRefMessageDataRpcRef,[Lean.Server.RpcEncoding.mk]]
[Lean.Lsp.TextDocumentItem.uri,[]]
[Lean.instToFormatKVMap,[Std.ToFormat.mk, Lean.formatKVMap]]
[Lean.Parser.ParserExtension.OLeanEntry.parser.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Json.instCoeRBNodeStringJsonStructured,[Coe.mk, Lean.Json.Structured.obj]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withLetVarType,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.SubExpr.descend, OfNat.ofNat, panicWithPosWithDecl]]
[Lean.Meta.IndPredBelow.Variables.mk.inj,[And.intro]]
[Lean.Xml.Parser.NameChar,[HOrElse.hOrElse, Lean.Xml.Parser.NameStartChar, Lean.Parsec.digit, Lean.Parsec.pchar, Char.ofNat, Lean.Parsec.satisfy, Decidable.decide, Or, And, LE.le]]
[Lean.Elab.Term.Do.DoIfView.noConfusionType,[]]
[instToStringUInt64,[ToString.mk, ToString.toString, UInt64.toNat]]
[Lean.Compiler.unFoldFns,[HAppend.hAppend, List.cons, Prod.mk, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Compiler.foldNatSucc, Lean.Compiler.foldCharOfNat, List.nil, Lean.Compiler.uintFoldToNatFns]]
[Lean.ConstantInfo.recInfo.injEq,[Eq.propIntro, Eq.refl, Lean.ConstantInfo.recInfo, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Structural.RecArgInfo.pos,[]]
[UInt16.sub_def,[rfl]]
[Lean.ParametricAttributeImpl.afterSet,[]]
[Std.AssocList.cons.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.instInhabitedPPFns,[Inhabited.mk, Lean.PPFns.mk, arbitrary]]
[Lean.Lsp.instFromJsonLeanFileProgressParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.VersionedTextDocumentIdentifier, Array, Lean.Lsp.LeanFileProgressProcessingInfo, Pure.pure, Lean.Lsp.LeanFileProgressParams.mk]]
[Nat.div.proof_1,[WellFoundedRelation.wf, measure, id]]
[Int.neg_ofNat_zero,[rfl]]
[Lean.Export.instOfStateName,[Lean.Export.OfState.mk, Lean.Export.State.names, Lean.Export.State.mk, Lean.Export.State.levels, Lean.Export.State.exprs, Lean.Export.State.defs, Lean.Export.State.stk]]
[Lean.Json.Parser.lookahead,[Bind.bind, Lean.Parsec.peek!, ite, Pure.pure, Unit.unit, Lean.Parsec.fail, HAppend.hAppend]]
[Lean.expandBrackedBindersAux.loop,[Unit.unit, Lean.MacroM, Lean.Syntax, Pure.pure, Bind.bind, Lean.expandExplicitBindersAux, Option.some, PProd.fst]]
[Lean.Environment.isConstructor,[Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo, Bool, Lean.Environment.find?, Bool.true, Bool.false]]
[Lean.KernelException.alreadyDeclared.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.DiagnosticSeverity.error.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Server.Completion.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Expr.FoldConstsImpl.State.visitedTerms,[]]
[List.not_mem_of_not_mem_cons,[absurd, Or.inr]]
[Function.decidable_eq_pfun.proof_1,[Iff.symm, Function.funext_iff]]
[Lean.IR.Borrow.ParamMap.getHash,[UInt64, Hashable.hash, mixHash]]
[Functor.map_equiv.proof_1,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Functor.map_map, Equiv.toFun, Equiv.symm, Functor.map, Equiv.symm_comp_self, LawfulFunctor.id_map, eq_self]]
[Lean.Meta.CaseValuesSubgoal.mk.inj,[And.intro]]
[Lean.PrettyPrinter.Delaborator.delabAppMatch,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPNotation, Lean.getPPMatch, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.withAppFnArgs, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.PrettyPrinter.Delaborator.AppMatchState, Lean.Meta.getMatcherInfo?, Option.none, Lean.getConstInfo, Pure.pure, Lean.PrettyPrinter.Delaborator.AppMatchState.mk, Lean.ConstantInfo.instantiateTypeLevelParams, Alternative.failure, ite, LT.lt, Array.size, Lean.PrettyPrinter.Delaborator.AppMatchState.params, Lean.Meta.Match.MatcherInfo.numParams, Lean.PrettyPrinter.Delaborator.AppMatchState.info, Lean.PrettyPrinter.Delaborator.AppMatchState.matcherTy, Array.push, Lean.PrettyPrinter.Delaborator.AppMatchState.motive, Lean.PrettyPrinter.Delaborator.AppMatchState.motiveNamed, Lean.PrettyPrinter.Delaborator.AppMatchState.discrs, Lean.PrettyPrinter.Delaborator.AppMatchState.varNames, Lean.PrettyPrinter.Delaborator.AppMatchState.rhss, Lean.PrettyPrinter.Delaborator.AppMatchState.moreArgs, Eq, Option.isNone, Bool.true, Lean.Meta.lambdaTelescope, liftM, Lean.Meta.mkForallFVars, Bool.false, withTheReader, Lean.PrettyPrinter.Delaborator.SubExpr, Lean.PrettyPrinter.Delaborator.SubExpr.mk, Lean.PrettyPrinter.Delaborator.SubExpr.pos, Lean.PrettyPrinter.Delaborator.delab, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPAnalysisNamedArg, Option.some, Prod.mk, Lean.Meta.Match.MatcherInfo.numDiscrs, Lean.Meta.Match.MatcherInfo.altNumParams, List.toArray, List.nil, Array.getOp, or, Decidable.decide, PUnit.unit]]
[Nat.to_digits_core_lens_eq_aux,[Classical.em, Eq, HDiv.hDiv, OfNat.ofNat, of_eq_true, Eq.trans, congr, congrArg, List.length, ite_congr, congrFun, eq_true_of_decide, Eq.refl, Bool.true, List.cons, Nat.digitChar, HMod.hMod, Nat.toDigitsCore, if_true, HAdd.hAdd, eq_self, Eq.symm, Eq.mpr, eq_false, if_false, Eq.mp, implies_congr, trivial]]
[Lean.Unhygienic.Context.ref,[]]
[Lean.Widget.goalToInteractive.pushPending,[ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Lean.Meta.MetaM, Array, Lean.Widget.InteractiveHypothesis, Lean.Widget.addInteractiveHypothesis, Option.none]]
[System.FilePath.extension,[Option.bind, System.FilePath.fileName, Unit.unit, dite, Eq, Eq.symm, Option, String, String.revPosOf, Char.ofNat, Option.none, Option.some, String.extract, HAdd.hAdd, OfNat.ofNat, String.bsize]]
[Lean.Meta.withoutProofIrrelevance,[Lean.Meta.withConfig, Lean.Meta.Config.mk, Lean.Meta.Config.foApprox, Lean.Meta.Config.ctxApprox, Lean.Meta.Config.quasiPatternApprox, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Bool.false, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct]]
[Lean.PPFns.ppGoal,[]]
[instToStringBool,[ToString.mk, cond]]
[Lean.PrettyPrinter.Parenthesizer.Context.mk.inj,[]]
[Lean.Elab.Term.MVarErrorInfo.argName?,[]]
[Lean.Meta.GeneralizeTelescope.Entry.expr,[]]
[Lean.IR.CtorInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.CtorInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.termReturn.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.checkLineEq.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Nat.gcd_rec,[Unit.unit, Eq, Nat.gcd, HMod.hMod, of_eq_true, Eq.trans, congrFun, congrArg, Nat.gcd_succ, HAdd.hAdd, OfNat.ofNat, eq_self, Nat.succ]]
[Lean.mkModuleInitializationFunctionName,[HAppend.hAppend, Lean.Name.mangle]]
[Lean.IR.instInhabitedDecl,[Inhabited.mk, Lean.IR.Decl.extern, arbitrary]]
[Lean.Elab.Structural.EqnsExtState.noConfusionType,[]]
[Lean.MonadCacheT.instMonadExceptOfMonadCacheT,[inferInstanceAs, MonadExceptOf, StateRefT', Std.HashMap]]
[Ordering.isLE,[Unit.unit, Bool, Bool.true, Bool.false]]
[Lean.IR.Borrow.ParamMap.Key.decl.injEq,[Eq.propIntro, Eq.refl, Lean.IR.Borrow.ParamMap.Key.decl, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Server.Completion.HoverInfo.inside.inj,[]]
[Lean.ConstantVal.noConfusionType,[]]
[MonoidWithZero.toZero,[]]
[Lean.Elab.Command.elabOpenPrivateLike,[Bind.bind, ForIn.forIn, Lean.resolveGlobalConstNoOverload, Lean.Meta.collectPrivateIn, Pure.pure, PUnit.unit, ForInStep.yield, Lean.MonadEnv.getEnv, Lean.Environment.moduleIdxForModule?, Lean.Syntax.getId, Option.none, Lean.Elab.Command.CommandElabM, ForInStep, Lean.NameSet, ite, Eq, Lean.isPrivateName, Bool.true, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, and, Array.isEmpty, not, Std.RBTree.isEmpty, Lean.Elab.logInfo, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[add_comm,[AddCommSemigroup.add_comm]]
[Lean.ppIndent.formatter,[Lean.PrettyPrinter.Formatter.indent, Option.none]]
[Array.empty,[Array.mkEmpty, OfNat.ofNat]]
[Lean.Parser.Command.explode,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser]]
[Lean.Parser.Term.match.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.generalizingParam.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.Term.matchDiscr.formatter, Bool.false, Lean.Parser.Term.optType.formatter, Lean.Parser.Term.matchAlts.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Lean.«tacticMatch_,,With.»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[Lean.PrettyPrinter.Parenthesizer.setExpected.parenthesizer,[]]
[HEq.ndrecOn,[]]
[Lean.NameSanitizerState.options,[]]
[Lean.SSet.fold,[Lean.SMap.fold]]
[Lean.throwKernelException,[Bind.bind, Lean.MonadOptions.getOptions, Lean.throwError, Lean.KernelException.toMessageData]]
[Lean.Parser.Term.doSeqItem.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.Parser.doElemParser.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.symbol.parenthesizer]]
[Array.forInUnsafe.loop,[ite, LT.lt, Bind.bind, Pure.pure, Array.forInUnsafe.loop, HAdd.hAdd, OfNat.ofNat]]
[Lean.Compiler.CSimp.add,[Bind.bind, Lean.getConstInfo, Option.none, Option.some, Prod.mk, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Core.CoreM, Option, Lean.Compiler.CSimp.Entry, Lean.Expr.eq?, Lean.ConstantInfo.type, ite, Eq, BEq.beq, Bool.true, Pure.pure, Lean.Compiler.CSimp.Entry.mk, Unit, Lean.ScopedEnvExtension.add, Lean.Compiler.CSimp.ext, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.ParserCompiler.CombinatorAttribute.impl,[]]
[Lean.Compiler.InlineAttributeKind.inline.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Term.elabRawNatLit,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Syntax.isNatLit?, Lean.Syntax.getOp, OfNat.ofNat, Pure.pure, Lean.mkRawNatLit, Lean.Elab.throwIllFormedSyntax]]
[Lean.Parser.Term.sufficesDecl.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.optIdent.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.fromTerm.parenthesizer, Lean.Parser.Term.byTactic.parenthesizer]]
[Lean.JsonRpc.Request.noConfusionType,[]]
[Lean.Parser.Tactic.simpPre,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol]]
[Quotient.exists_rep,[Quot.exists_rep]]
[Lean.Parser.Command.inductive.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.Command.optDeclSig.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.Command.ctor.parenthesizer, Lean.Parser.Command.optDeriving.parenthesizer]]
[Lean.Elab.Structural.RecArgInfo.indName,[]]
[Lean.Parser.InputContext.input,[]]
[Nat.forM,[Nat.forM.loop]]
[Lean.Elab.Command.checkResultingUniverse,[Bind.bind, Lean.MonadOptions.getOptions, ite, Eq, Lean.Option.get, Lean.Elab.Command.bootstrap.inductiveCheckResultingUniverse, Bool.true, liftM, Lean.Meta.instantiateLevelMVars, and, not, Lean.Level.isZero, Lean.Level.isNeverZero, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.ofLevel, Pure.pure, PUnit.unit]]
[IO.AsyncList.cons.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.AsyncList.cons, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.instHashableVarId,[Hashable.mk, Hashable.hash, Lean.IR.VarId.idx]]
[ByteSlice.noConfusionType,[]]
[Append.append,[]]
[PSigma.lexAccessible,[PSigma.lexAccessible.proof_1]]
[Lean.Expr.ReplaceLevelImpl.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.ScopedEnvExtension.StateStack.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.ElimAltInfo.noConfusionType,[]]
[Lean.Parser.Tactic.Conv.convDone,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Meta.Rewrite.Config.transparency,[]]
[FloatSpec.decLt,[]]
[Lean.Elab.instInhabitedInfoState,[Inhabited.mk, Lean.Elab.InfoState.mk, arbitrary]]
[Lean.IR.ExplicitBoxing.isBoxedName,[Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Bool, Bool.true, Bool.false]]
[Lean.Syntax.antiquotSuffixSplice?,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Syntax.atom, Lean.Syntax.ident, Option, Lean.SyntaxNodeKind, Option.some, Option.none]]
[Lean.Option.setIfNotSet,[ite, Eq, Lean.KVMap.contains, Lean.Option.name, Bool.true, Lean.Option.set]]
[List.tail_eq_of_cons_eq,[]]
[Lean.Meta.MVarRenaming.noConfusionType,[]]
[Nat.le_add_left,[Nat.le_add_right, Nat.add_comm]]
[Lean.Xml.Parser.VersionInfo,[Bind.bind, SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Parsec.skipString, Lean.Xml.Parser.Eq, Lean.Xml.Parser.quote, Lean.Xml.Parser.VersionNum]]
[Lean.JsonRpc.ErrorCode.invalidParams.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Tactic.nestedTactic,[Lean.Parser.Tactic.tacticSeqBracketed]]
[Nat.sub_sub_self,[Iff.mpr, Nat.sub_eq_iff_eq_add, Nat.sub_le, Eq.symm, Nat.add_sub_of_le]]
[Lean.Parser.Tactic.piInstanceDeriveField,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Nat.dvd_zero,[Exists.intro, OfNat.ofNat, of_eq_true, Eq.trans, congrArg, Eq, Nat.mul_zero, eq_true_of_decide, Eq.refl, Bool.true]]
[Lean.Json.CompressWorkItem.noConfusionType,[]]
[Lean.Parser.Tactic.delta,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.Parser.Tactic.location]]
[Lean.Json.isNull,[Unit.unit, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Bool, Bool.true, Bool.false]]
[Lean.Parser.Term.letRecDecl.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.docComment.formatter, Lean.Parser.Term.attributes.formatter, Lean.Parser.Term.letDecl.formatter]]
[Lean.Meta.Simp.SimpLetCase.noConfusionType,[noConfusionTypeEnum, Lean.Meta.Simp.SimpLetCase.toCtorIdx]]
[Lean.Expr.constLevels!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, List, Lean.Level, panicWithPosWithDecl, OfNat.ofNat]]
[Subarray.forInUnsafe,[USize.ofNat, Subarray.start, Subarray.forInUnsafe.loop]]
[Lean.Meta.mkLambdaFVars,[ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Lean.Meta.liftMkBindingM, Lean.MetavarContext.mkLambda]]
[Lean.Widget.InteractiveDiagnostic,[Lean.Lsp.DiagnosticWith, Lean.Widget.TaggedText, Lean.Widget.MsgEmbed]]
[Lean.Elab.Command.elabOpen,[Bind.bind, Lean.Elab.OpenDecl.elabOpenDecl, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Command.modifyScope, Lean.Elab.Command.Scope.mk, Lean.Elab.Command.Scope.header, Lean.Elab.Command.Scope.opts, Lean.Elab.Command.Scope.currNamespace, Lean.Elab.Command.Scope.levelNames, Lean.Elab.Command.Scope.varDecls, Lean.Elab.Command.Scope.varUIds, Lean.Elab.Command.Scope.isNoncomputable]]
[OfNat.noConfusionType,[]]
[Lean.IR.Checker.maxCtorFields,[Lean.IR.Checker.getMaxCtorFields, Unit.unit]]
[Lean.Meta.CheckAssignment.CheckAssignmentM,[ReaderT, Lean.Meta.CheckAssignment.Context, StateRefT', IO.RealWorld, Lean.Meta.CheckAssignment.State, Lean.Meta.MetaM]]
[Lean.Server.FileWorker.WorkerState.mk.inj,[And.intro]]
[Lean.Parser.Term.structInstArrayRef,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser]]
[Lean.addDocString',[Unit.unit, Unit, Lean.addDocString, Pure.pure]]
[Lean.TagDeclarationExtension,[Lean.SimplePersistentEnvExtension, Lean.Name, Lean.NameSet]]
[Lean.LeanPaths.oleanPath,[]]
[Lean.IR.Checker.CheckerState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Name.isPrefixOf,[Lean.Name.str, Lean.Name.num, Bool, BEq.beq, Lean.Name.anonymous, or, PProd.fst]]
[Lean.Parser.Term.typeOf.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec]]
[Lean.getPPAnalysisHole,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false]]
[Lean.ClosedTermCache.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[IO.FS.Stream.write,[]]
[Lean.ConstantInfo.noConfusionType,[]]
[Lean.ScopedEnvExtension.State.state,[]]
[Lean.Elab.Structural.instInhabitedEqnInfo,[Inhabited.mk, Lean.Elab.Structural.EqnInfo.mk, arbitrary]]
[Lean.Parser.Attr.toAdditive!?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const]]
[Lean.Meta.SynthInstance.Answer.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.DocumentSymbolAux.kind,[]]
[Std.PersistentHashMap.contains,[Bool, Std.PersistentHashMap.containsAux, UInt64.toUSize, Hashable.hash]]
[Lean.Lsp.LineRange.start,[]]
[UInt8.eq_of_val_eq,[Eq, congrArg, UInt8.mk]]
[UInt64.mul_def,[rfl]]
[Lean.Expr.prod?,[Lean.Expr.app2?, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Parser.Tactic.focus,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.params,[]]
[Lean.Elab.Term.LVal.fieldIdx.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LVal.fieldIdx, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.DiagnosticTag.unnecessary.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Structural.State.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Structural.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Unit.ext,[rfl]]
[Lean.Elab.DefViewElabHeader.kind,[]]
[Lean.ReducibilityStatus.toCtorIdx,[OfNat.ofNat]]
[Lean.Elab.Term.mkFreshBinderName,[Lean.MonadQuotation.withFreshMacroScope, Lean.MonadQuotation.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous]]
[ExceptCpsT,[]]
[UInt64.instCommRingUInt64.proof_1,[UInt64.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, UInt64.val, UInt64.mul_def, CommSemiring.mul_comm]]
[List.redLength,[Unit.unit, Nat, OfNat.ofNat, Nat.succ, PProd.fst]]
[Lean.Parser.Attr.simp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.simpPre, Lean.Parser.Tactic.simpPost, Lean.ParserDescr.cat]]
[Lean.Parser.decQuotDepth,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.addQuotDepthFn, Neg.neg, OfNat.ofNat, Lean.Parser.Parser.fn]]
[OfNat.ofNat,[]]
[Lean.activateScoped,[Bind.bind, ST.Ref.get, Lean.scopedEnvExtensionsRef, ForIn.forIn, PUnit.unit, Lean.MonadEnv.modifyEnv, Lean.ScopedEnvExtension.activateScoped, Pure.pure, ForInStep.yield]]
[Nat.coprime_iff_gcd_eq_one,[Iff.rfl]]
[Lean.Environment.setMainModule,[Lean.Environment.mk, Lean.Environment.const2ModIdx, Lean.Environment.constants, Lean.Environment.extensions, Lean.EnvironmentHeader.mk, Lean.EnvironmentHeader.trustLevel, Lean.EnvironmentHeader.quotInit, Lean.EnvironmentHeader.imports, Lean.EnvironmentHeader.regions, Lean.EnvironmentHeader.moduleNames]]
[ReaderT.run_monadLift,[rfl]]
[Lean.Parser.ParserCache.mk.inj,[]]
[Lean.Parser.Term.binrel.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.ppSpace.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec]]
[Lean.Parser.Tactic.ext1?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.cat]]
[Lean.LBool.false.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Command.optionValue.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.strLit.formatter, Lean.Parser.numLit.formatter]]
[Lean.instInhabitedScopedEnvExtension,[Inhabited.mk, Lean.ScopedEnvExtension.mk, arbitrary]]
[Lean.Meta.Match.Unify.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Sdiff.sdiff,[]]
[Lean.RecursorRule.rhs,[]]
[Std.HashSetImp.noConfusionType,[]]
[Lean.Parser.Tactic.deriveElementwiseProof,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Elab.logException,[Unit, Lean.Elab.logErrorAt, ite, Eq, Lean.Elab.isAbortExceptionId, Bool.true, Pure.pure, PUnit.unit, Bind.bind, liftM, Lean.InternalExceptionId.getName, Lean.Elab.logError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[List.tail!,[Unit.unit, List, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Elab.Structural.State.noConfusionType,[]]
[Lean.instMVarIdSetEmptyCollection,[Std.instEmptyCollectionRBTree, Lean.MVarId, Lean.Name.quickCmp, Lean.MVarId.name]]
[exists_eq',[Exists.intro, rfl]]
[Lean.mkLet,[Lean.Expr.letE, Lean.Expr.mkDataForLet, mixHash, UInt8.toUInt64, Hashable.hash, max, Lean.Expr.looseBVarRange, HSub.hSub, OfNat.ofNat, or, Lean.Expr.hasFVar, Lean.Expr.hasExprMVar, Lean.Expr.hasLevelMVar, Lean.Expr.hasLevelParam]]
[Lean.Parser.Tactic.Conv.conv,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.Conv.convSeq]]
[Lean.Export.Alloc.noConfusionType,[]]
[List.join,[Unit.unit, List, List.nil, HAppend.hAppend, PProd.fst]]
[Lean.Elab.Tactic.throwNoGoalsToBeSolved,[Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.IR.Borrow.infer,[StateT.run', Lean.IR.Borrow.collectDecls, Lean.IR.Borrow.BorrowInfCtx.mk, Lean.IR.Borrow.BorrowInfState.mk, Lean.IR.Borrow.mkInitParamMap]]
[Lean.ExternEntry.standard.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ExternEntry.standard, Eq.symm, eq_of_heq, HEq.refl]]
[OrOp.or,[]]
[Lean.LocalContext.noConfusionType,[]]
[Lean.MetavarContext.MkBinding.M,[ReaderT, Bool, Lean.MetavarContext.MkBinding.MCore]]
[Lean.KVMap.eqv,[and, Lean.KVMap.subset]]
[Std.HashMapImp.insert,[Prod, Std.HashMapImp, Bool, ite, Eq, Std.AssocList.contains, Bool.true, Prod.mk, Std.HashMapImp.mk, Std.HashMapBucket.update, Std.AssocList.replace, LE.le, HDiv.hDiv, HMul.hMul, OfNat.ofNat, Array.size, Subtype.val, Bool.false, Std.HashMapImp.expand]]
[Lean.Elab.Frontend.processCommand,[Bind.bind, Lean.Elab.Frontend.updateCmdPos, Lean.Elab.Frontend.getCommandState, Lean.Elab.Frontend.getInputContext, Lean.Elab.Frontend.getParserState, Lean.Elab.Frontend.FrontendM, Bool, Lean.profileit, Lean.Elab.Command.Scope.opts, Lean.Parser.parseCommand, Lean.Elab.Command.State.messages, modify, Lean.Elab.Frontend.State.mk, Lean.Elab.Frontend.State.commandState, Lean.Elab.Frontend.State.parserState, Lean.Elab.Frontend.State.cmdPos, Array.push, Lean.Elab.Frontend.State.commands, Lean.Elab.Frontend.setParserState, Lean.Elab.Frontend.setMessages, ite, Eq, or, Lean.Parser.isEOI, Lean.Parser.isExitCommand, Bool.true, Pure.pure, Lean.profileitM, IO.Error, Lean.Elab.Frontend.elabCommandAtFrontend, Bool.false]]
[Lean.Lsp.WorkDoneProgressReport.kind,[]]
[Lean.IR.VarId.mk.inj,[]]
[WellFounded.fixF,[]]
[Lean.Lsp.TextDocumentItem.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.TextDocumentItem.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.runLongestMatchParser,[Id.run, Option.none, Id, Lean.Parser.ParserState, Bind.bind, Pure.pure, PUnit.unit]]
[Lean.Elab.Tactic.Context.main,[]]
[Lean.SMap.instInhabitedSMap,[Inhabited.mk, Lean.SMap.mk]]
[Lean.mkAppEx,[Lean.mkApp]]
[Lean.mkDefinitionValEx,[Lean.DefinitionVal.mk, Lean.ConstantVal.mk]]
[Lean.ParametricAttribute.getParam,[Unit.unit, Option, Lean.Environment.getModuleIdxFor?, Array.binSearch, Lean.PersistentEnvExtension.getModuleEntries, Lean.ParametricAttribute.ext, Prod.mk, arbitrary, Lean.Name.quickLt, Prod.fst, OfNat.ofNat, HSub.hSub, Array.size, Option.some, Option.none, Lean.NameMap.find?, Lean.PersistentEnvExtension.getState]]
[Lean.Expr.ReplaceImpl.cache.proof_2,[lcProof]]
[Lean.DelayedMetavarAssignment.lctx,[]]
[Lean.Meta.Simp.Discharge,[Lean.Meta.Simp.SimpM, Option, Lean.Expr]]
[Substring.front,[Substring.get, OfNat.ofNat]]
[Lean.Parser.declareLeadingBuiltinParser,[Lean.Parser.declareBuiltinParser, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.JsonNumber.noConfusionType,[]]
[Lean.StructureFieldInfo.mk.inj,[And.intro]]
[Lean.brecOnSuffix,[]]
[Lean.IR.EmitC.emitDeclAux,[Bind.bind, Lean.IR.EmitC.getEnv, Lean.IR.EmitC.M, Unit, MonadWithReader.withReader, Lean.IR.EmitC.Context.mk, Lean.IR.EmitC.Context.env, Lean.IR.EmitC.Context.modName, Lean.IR.EmitC.Context.mainFn, Lean.IR.EmitC.Context.mainParams, ite, Eq, Lean.hasInitAttr, Lean.IR.Decl.name, Bool.true, Pure.pure, PUnit.unit, Lean.IR.Decl.extern, Lean.IR.EmitC.toCName, BEq.beq, Array.size, OfNat.ofNat, Lean.IR.EmitC.emit, Unit.unit]]
[Std.ShareCommon.ObjectPersistentSet.find?,[Std.PersistentHashSet.find?]]
[Lean.PrettyPrinter.Delaborator.isRegularApp,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, ite, Eq, not, Lean.Expr.isConst, Lean.PrettyPrinter.Delaborator.unfoldMDatas, Lean.Expr.getAppFn, Bool.true, Pure.pure, Bool.false, PUnit.unit]]
[Lean.Meta.SynthInstance.Answer.noConfusionType,[]]
[Lean.IR.FnBody.ret.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.isTracingEnabledFor,[Bind.bind, Lean.MonadTrace.getTraceState, ite, Eq, not, Lean.TraceState.enabled, Bool.true, Pure.pure, Bool.false, Lean.MonadOptions.getOptions, Lean.checkTraceOption]]
[Lean.Elab.Command.instInhabitedState,[Inhabited.mk, Lean.Elab.Command.State.mk, arbitrary]]
[Lean.IR.LocalContext.addParams,[Array.foldl, Lean.IR.LocalContext.addParam, OfNat.ofNat, Array.size]]
[Lean.Meta.mapError,[controlAt, Lean.Meta.MetaM, Lean.Meta.mapErrorImp]]
[Lean.Expr.ReplaceLevelImpl.initCache,[Lean.Expr.ReplaceLevelImpl.State.mk, Array.mkArray, USize.toNat, Lean.Expr.ReplaceLevelImpl.cacheSize, cast, Lean.Expr.ReplaceLevelImpl.initCache.proof_1, Unit.unit, arbitrary]]
[ST.Ref.mk.inj,[]]
[Lean.Elab.Term.Do.ToTerm.mkNestedKind,[Unit.unit, Lean.Elab.Term.Do.ToTerm.Kind, Lean.Elab.Term.Do.ToTerm.Kind.regular, Lean.Elab.Term.Do.ToTerm.Kind.nestedBC, Lean.Elab.Term.Do.ToTerm.Kind.nestedPR, Lean.Elab.Term.Do.ToTerm.Kind.nestedSBC, Lean.Elab.Term.Do.ToTerm.Kind.nestedPRBC, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Lsp.DiagnosticSeverity.information.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Server.FileWorker.lakeSetupSearchPath,[Bind.bind, IO.Process.spawn, IO.Process.SpawnArgs.mk, IO.Process.StdioConfig.mk, IO.Process.Stdio.null, IO.Process.Stdio.piped, System.FilePath.toString, liftM, IO.asTask, Task.Priority.dedicated, IO.FS.Handle.readToEnd, IO.Process.Child.stdout, IO.ofExcept, Task.get, IO.Process.Child.wait, dite, Eq, UInt32.ofNat, Unit.unit, Eq.symm, IO, Lean.SearchPath, Pure.pure, Lean.Json.parse, Lean.FromJson.fromJson?, Except.error, Lean.getBuildDir, Lean.initSearchPath, Lean.LeanPaths.oleanPath, List.mapM, Lean.realPathNormalized, Lean.LeanPaths.srcPath, IO.throwServerError, HAppend.hAppend, ToString.toString, List.nil, Lean.Server.FileWorker.lakeSetupSearchPath.processStderr]]
[Array.allM,[Bind.bind, Array.anyM, Pure.pure, not, OfNat.ofNat, Array.size]]
[USize.instSemiringUSize.proof_5,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, congrFun, HMul.hMul, USize.zero_def, USize.mul_def, USize.mk, OfNat.ofNat, MonoidWithZero.zero_mul, USize.val, eq_self, propext, forall_const, USize]]
[panicWithPosWithDecl,[panic, HAppend.hAppend, ToString.toString]]
[Lean.Meta.matchHelper?,[Bind.bind, Unit.unit, Option.some, Lean.Meta.MetaM, Option, Lean.Meta.whnf, Pure.pure]]
[PUnit.eq_punit,[PUnit.subsingleton, PUnit.unit]]
[Lean.Meta.getHygienicIntro,[Bind.bind, Lean.MonadOptions.getOptions, Pure.pure, Lean.Option.get, Lean.Meta.tactic.hygienic]]
[Lean.Server.Snapshots.parseNextCmd,[IO, Lean.Syntax, Pure.pure]]
[Bool.noConfusionType,[]]
[Lean.ScopedEnvExtension.pushScope,[Unit.unit, Lean.Environment, Lean.ScopedEnvExtension.StateStack.stateStack, Lean.PersistentEnvExtension.setState, Lean.ScopedEnvExtension.ext, Lean.ScopedEnvExtension.StateStack.mk, List.cons, Lean.ScopedEnvExtension.StateStack.scopedEntries, Lean.ScopedEnvExtension.StateStack.newEntries]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.mk.inj,[And.intro]]
[Lean.Meta.NormNum.evalEq,[Bind.bind, Lean.Meta.getLevel, Lean.Level.zero, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Meta.MetaM, Lean.Expr, Lean.Meta.synthInstance, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil, Option.none, Lean.Meta.NormNum.evalIsNat, guard, Eq, BEq.beq, Lean.Expr.natLit!, Bool.true, Pure.pure, Lean.mkApp7, Lean.throwError, Lean.ToMessageData.toMessageData]]
[dite_not,[Decidable.em, of_eq_true, Eq.trans, congr, congrArg, Eq, dite_congr, Not, eq_true, eq_false_of_decide, Eq.refl, Bool.false, Eq.mpr_prop, Eq.mpr_not, dite_false, not_not_intro, dite_true, eq_self, not_false, Eq.symm, eq_false, eq_true_of_decide, Bool.true, True.intro]]
[instAddCommMonoid_1.proof_1,[AddCommSemigroup.add_comm]]
[Nat.add_mod,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, Nat.add_mod_mod, Nat.mod_add_mod, rfl]]
[List.hasDecEq.proof_5,[absurd]]
[Lean.Lsp.SemanticTokensParams.noConfusionType,[]]
[Lean.IR.mkAppExpr,[Lean.IR.Expr.ap]]
[UInt32.val,[]]
[Fin.instShiftRightFin,[ShiftRight.mk, Fin.shiftRight]]
[Lean.Environment.header,[]]
[Lean.Meta.NormNum.instLawfulZero,[Lean.Meta.NormNum.instLawfulZero.proof_1]]
[Lean.instCoeBoolDataValue,[Coe.mk, Lean.DataValue.ofBool]]
[Lean.Meta.mkFreshLevelMVars,[Nat.foldM, Bind.bind, Lean.Meta.mkFreshLevelMVar, Pure.pure, List.cons, List.nil]]
[Lean.JsonNumber.instReprJsonNumber,[Repr.mk, Std.Format, Std.Format.bracket, HAppend.hAppend, repr, Std.Format.text]]
[Lean.IR.Expr.box.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Option.get,[Lean.KVMap.get, Lean.Option.name, Lean.Option.defValue]]
[Lean.StructureFieldInfo.projFn,[]]
[Lean.Elab.Structural.findRecArg,[Bind.bind, liftM, IO.mkRef, EmptyCollection.emptyCollection, ForIn.forIn, PUnit.unit, Lean.Meta.inferType, Lean.Meta.forEachExpr, Lean.matchConstInduct, Lean.Expr.getAppFn, Pure.pure, Unit.unit, ite, Eq, and, Decidable.decide, GT.gt, Lean.InductiveVal.numIndices, OfNat.ofNat, BEq.beq, HAdd.hAdd, Lean.InductiveVal.numParams, Lean.Expr.getAppNumArgs, Bool.true, Lean.Expr.isFVar, Array.any, Array.size, ST.Ref.modify, Std.RBTree.insert, Lean.Expr.fvarId!, ForInStep.yield, ST.Ref.get, Lean.Elab.Structural.findRecArg.go]]
[instToStringByteSlice,[ToString.mk, Id.run, Bind.bind, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield]]
[Lean.BinderInfo.noConfusion,[noConfusionEnum, Lean.BinderInfo.toCtorIdx]]
[Lean.Lsp.instFromJsonPlainGoalParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.PlainGoalParams.mk, Lean.Lsp.TextDocumentPositionParams.mk]]
[Nat.gcd_dvd_gcd_mul_left_right,[Nat.gcd_dvd_gcd_of_dvd_right, Nat.dvd_mul_left]]
[Lean.Lsp.RpcConnectParams.mk.inj,[]]
[Lean.LocalDecl.index,[Nat]]
[Lean.AttributeImpl.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.AttributeImpl.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.ppCommand,[Bind.bind, Lean.PrettyPrinter.parenthesizeCommand, Lean.PrettyPrinter.formatCommand]]
[Nat.add_sub_add_right,[Eq, HSub.hSub, HAdd.hAdd, Eq.mpr, Eq.refl, OfNat.ofNat, Nat.add_zero, rfl, Nat.add_succ, Nat.succ, Nat.succ_sub_succ, PProd.fst]]
[instToStringProd,[ToString.mk, String, HAppend.hAppend, ToString.toString]]
[Lean.Parser.Tactic.rintroPat.one,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.cat]]
[Mathlib.Tactic.Lint.Linter.errorsFound,[]]
[Lean.Meta.apply,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType, Lean.Meta.inferType, Lean.Meta.getExpectedNumArgsAux, Lean.Meta.MetaM, List, Lean.MVarId, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.getExpectedNumArgs]]
[instOrdUInt8,[Ord.mk, compareOfLessAndEq]]
[Lean.Parser.declareBuiltinParser,[Lean.declareBuiltin]]
[Lean.ImportState.moduleNameSet,[]]
[Lean.Parser.strAux,[Lean.Parser.strAux.parse]]
[Lean.MessageData.instAppendMessageData,[Append.mk, Lean.MessageData.compose]]
[Lean.Parser.fieldIdxFn,[ite, Eq, and, Char.isDigit, bne, Char.ofNat, Bool.true, Lean.Parser.mkNodeToken, Lean.fieldIdxKind, Lean.Parser.ParserState.mkErrorAt, Option.some]]
[Lean.Elab.Tactic.closeMainGoal,[ite, Eq, Bool.true, Bind.bind, Lean.Elab.Tactic.ensureHasNoMVars, Pure.pure, PUnit.unit]]
[Lean.Lsp.ServerCapabilities.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.mem_nil,[Iff.rfl]]
[«term_^^^_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Import.module,[]]
[Lean.Parser.Term.attrKind,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.optional, HOrElse.hOrElse, Lean.Parser.Term.scoped, Lean.Parser.Term.local]]
[Float.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.find_min,[And.right, Subtype.property, Nat.find_x]]
[Lean.Parser.Term.attributes.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.Term.attrInstance.parenthesizer, Bool.false]]
[or,[Unit.unit, Bool, Bool.true]]
[Lean.Lsp.instFileSourceDidOpenTextDocumentParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.DidOpenTextDocumentParams.textDocument]]
[Lean.instBEqLBool,[BEq.mk, BEq.beq, Lean.LBool.toCtorIdx]]
[Lean.Lsp.WaitForDiagnosticsParams.version,[]]
[Lean.Lsp.SaveOptions.noConfusionType,[]]
[Lean.ReducibilityHints.isAbbrev,[Lean.ReducibilityHints.opaque, Unit.unit, Lean.ReducibilityHints.regular, Bool, Bool.true, Bool.false]]
[Id.map_eq,[rfl]]
[Lean.Elab.Term.getPatternsVars,[Bind.bind, StateRefT'.run, Lean.Elab.Term.CollectPatternVars.State.mk, Lean.Elab.Term.TermElabM, Array, Lean.Elab.Term.PatternVar, Pure.pure, Lean.Elab.Term.CollectPatternVars.State.vars]]
[Array.uget,[Array.get, Fin.mk, USize.toNat]]
[Lean.Xml.Parser.XMLdecl,[Bind.bind, Lean.Parsec.skipString, Lean.Xml.Parser.VersionInfo, SeqRight.seqRight, optional, Lean.Xml.Parser.EncodingDecl, Lean.Xml.Parser.SDDecl, Lean.Xml.Parser.S]]
[Nat.sub_one,[rfl]]
[Lean.Expr.ReplaceImpl.replaceUnsafeM,[Lean.Expr.ReplaceImpl.replaceUnsafeM.visit]]
[Lean.Meta.Match.Unify.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Unify.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Mathlib.Tactic.Lint.withSimpLemmaInfos,[Lean.Meta.withReducible, Bind.bind, Lean.Meta.mkSorry, Bool.true, Bool.false, Array.mapM, Lean.Meta.MetaM, Lean.Meta.forallTelescopeReducing, Pure.pure, Lean.Expr.eq?, Option.none, Mathlib.Tactic.Lint.isConditionalHyps, Array.toList, Mathlib.Tactic.Lint.SimpLemmaInfo.mk, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, List.toArray]]
[Fin.mod_eq_val,[Nat.mod_eq_of_lt, Fin.isLt]]
[Lean.instToMessageDataOptionExpr,[Lean.ToMessageData.mk, Unit.unit, Lean.MessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.ToMessageData.toMessageData]]
[Lean.PrettyPrinter.Formatter.error.formatter,[Pure.pure, Unit.unit]]
[OptionM,[OptionT, Id]]
[Lean.Elab.PreDefinition.levelParams,[]]
[UInt8.instSemiringUInt8.proof_3,[congrArg, UInt8.mk, Semiring.nsmul_zero', UInt8.val]]
[Lean.Elab.Term.instMetaEvalTermElabM,[Lean.MetaEval.mk, Lean.MetaEval.eval, Lean.Elab.Term.TermElabM.run', Lean.Elab.Term.Context.mk, arbitrary, Lean.Elab.Term.State.mk, Bool.true]]
[Lean.getProjectionFnInfo?,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Environment.getProjectionFnInfo?]]
[Lean.Meta.mkSizeOfInstances,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, Lean.Meta.isInductivePredicate, ite, Eq, and, Lean.Environment.contains, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Option.get, Lean.Meta.genSizeOf, not, Bool.true, Lean.getConstInfoInduct, Lean.InductiveVal.isUnsafe, Pure.pure, PUnit.unit, Lean.Meta.mkSizeOfFns, Lean.Meta.MetaM, Unit, ForIn.forIn, Unit.unit, ForInStep, Subarray, Lean.Name, Stream.next?, ForInStep.done, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.InductiveVal.toConstantVal, OfNat.ofNat, List.toArray, List.nil, Array.ofSubarray, Lean.Meta.mkAppM, List.cons, Lean.Meta.withLocalDeclD, Lean.Meta.mkLambdaFVars, Lean.mkAppN, Lean.mkConst, HAppend.hAppend, Bool.false, Lean.Meta.mkForallFVars, Lean.addDecl, Lean.Declaration.defnDecl, Lean.DefinitionVal.mk, Lean.ConstantVal.mk, Lean.ConstantVal.levelParams, Lean.ReducibilityHints.abbrev, Lean.DefinitionSafety.safe, Lean.Meta.addInstance, Lean.AttributeKind.global, ForInStep.yield, Lean.Meta.genSizeOfSpec, Lean.getConstInfoCtor, Lean.ConstructorVal.toConstantVal, Lean.Meta.mkNumeral, Lean.Meta.inferType, Lean.Meta.whnf, Lean.Expr.isForall, Lean.Meta.mkAdd, Lean.Meta.mkEq, Lean.InductiveVal.isNested, ReaderT.run, Lean.Meta.SizeOfSpecNested.main, Lean.Meta.SizeOfSpecNested.Context.mk, Lean.Meta.mkEqRefl, Lean.InductiveVal.all]]
[Lean.Parser.Command.postfix.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Std.RBMap.isEmpty,[Subtype.mk, Std.RBNode.node, Bool, Bool.true, Bool.false]]
[List.getLast!.proof_1,[]]
[Lean.Lsp.LocationLink.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.FnBody.case.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, Eq.refl, List.nil, congr, Lean.IR.AltCore.ctor, Lean.IR.AltCore.default, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec]]
[Lean.Meta.getLocalInstances,[Bind.bind, MonadReader.read, Pure.pure, Lean.Meta.Context.localInstances]]
[Lean.Meta.IndPredBelow.Context.typeInfos,[]]
[Lean.Lsp.Trace.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.Trace.toCtorIdx]]
[Lean.Parser.Tactic.measurability,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Function.bijective.of_comp_iff,[and_congr, Function.injective.of_comp_iff', Function.surjective.of_comp_iff, Function.bijective.surjective]]
[Lean.PrettyPrinter.Delaborator.mkAppUnexpanderAttribute,[Lean.KeyedDeclsAttribute.init, Lean.KeyedDeclsAttribute.Def.mk, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.Attribute.Builtin.getId, Lean.resolveGlobalConstNoOverloadCore]]
[List.disjoint_of_disjoint_append_left_left,[And.left, Iff.mp, List.disjoint_append_left]]
[Lean.Elab.Deriving.Repr.mkBodyForInduct.mkAlts,[Bind.bind, ForIn.forIn, Lean.getConstInfoCtor, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, PUnit.unit, ForInStep.yield, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, MProd.mk, liftM, Lean.Core.mkFreshUserName, Lean.Meta.inferType, ite, Eq, Lean.Expr.isAppOf, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Bool.true, Lean.mkIdent, Lean.Elab.Term.TermElabM, Lean.Syntax, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom]]
[Lean.JsonRpc.ResponseError.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.IsLive.visitExpr,[Pure.pure, Lean.IR.HasIndex.visitExpr]]
[Char.le,[LE.le, Char.val]]
[Lean.SCC.State.mk.inj,[And.intro]]
[Lean.TraceState.enabled,[]]
[Lean.Server.FileWorker.WorkerState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.getPPStructureInstanceType,[Lean.KVMap.get, Lean.Option.name, Lean.pp.structureInstanceTypes, Lean.getPPAll]]
[StateCpsT.lift,[Bind.bind]]
[Lean.Meta.addUnificationHint,[Lean.Meta.withNewMCtxDepth, Bind.bind, Lean.getConstInfo, Unit.unit, Lean.Meta.MetaM, Unit, Lean.ConstantInfo.value?, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Meta.lambdaMetaTelescope, Option.none, List.toArray, List.nil, ExceptT, Lean.MessageData, Id, Lean.Meta.UnificationConstraint, Lean.Expr.eq?, Pure.pure, Lean.Meta.UnificationConstraint.mk, MonadExcept.throw, HAppend.hAppend, Lean.indentExpr, Lean.Meta.DiscrTree.mkPath, Lean.Meta.UnificationConstraint.lhs, Lean.Meta.UnificationHint.pattern, List.forM, Lean.Meta.UnificationHint.constraints, Lean.Meta.isDefEq, Lean.Meta.UnificationConstraint.rhs, ite, Eq, Bool.true, PUnit.unit, Lean.ScopedEnvExtension.add, Lean.Meta.unificationHintExtension, Lean.Meta.UnificationHintEntry.mk, Lean.isTracingEnabledFor, Lean.MonadEnv.getEnv, Lean.addTrace, Lean.ScopedEnvExtension.getState]]
[Lean.IR.CtorInfo.mk.inj,[And.intro]]
[Int.rem,[Int, Int.ofNat, HMod.hMod, Nat.succ, Neg.neg]]
[Lean.Meta.simpTargetCore,[Bind.bind, Lean.Meta.getMVarType, Lean.Meta.instantiateMVars, Lean.Meta.simp, ite, Eq, Lean.Expr.isConstOf, Lean.Meta.Simp.Result.expr, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Unit.unit, Lean.Meta.MetaM, Option, Lean.MVarId, Lean.Meta.Simp.Result.proof?, Lean.Meta.mkOfEqTrue, Lean.Meta.assignExprMVar, Lean.mkConst, List.nil, coeM, Lean.Meta.applySimpResultToTarget]]
[Lean.Server.Completion.addToBlackList,[Lean.TagDeclarationExtension.tag, Lean.Server.Completion.completionBlackListExt]]
[Nat.gcd_mul_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.mul_comm, Nat.gcd_mul_left, rfl]]
[Array.findSomeM?,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, ForInStep, MProd, Option, PUnit, Pure.pure, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, MProd.fst]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM,[ReaderT, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context, StateRefT', IO.RealWorld, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State, Lean.Meta.MetaM]]
[Lean.Elab.Term.SyntheticMVarKind.tactic.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.SyntheticMVarKind.tactic, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.DocumentHighlightParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DocumentHighlightParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.StructInst.FieldVal.default.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Nat.toDigitsCore,[List, Char, ite, Eq, OfNat.ofNat, List.cons, PProd.fst]]
[Semiring.nsmul_succ',[]]
[Lean.sanitizeName,[Bind.bind, MonadState.get, modify, Lean.NameSanitizerState.mk, Lean.NameSanitizerState.options, Lean.NameSanitizerState.nameStem2Idx, Lean.NameMap.insert, Lean.NameSanitizerState.userName2Sanitized, Pure.pure]]
[IO.FS.Handle.readToEnd,[IO.FS.Handle.readToEnd.loop]]
[Lean.Elab.Term.SavedContext.declName?,[]]
[Std.PShareCommonT,[StateT, Std.ShareCommon.PState]]
[Lean.EnvironmentHeader.moduleNames,[]]
[And.imp,[And.intro, And.left, And.right]]
[Lean.Level.isZero,[Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Bool, Bool.true, Bool.false]]
[Lean.Elab.Term.Arg.expr.inj,[]]
[Lean.Level.updateIMax!.proof_1,[rfl]]
[Lean.Expr.isEq,[Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat]]
[Lean.IR.FnBody.maxIndex,[Lean.IR.MaxIndex.collectFnBody, OfNat.ofNat]]
[Int.ofNat_mul_negOfNat,[Unit.unit, Eq, HMul.hMul, Int.ofNat, Int.negOfNat, rfl]]
[Lean.Elab.Term.Quotation.ArrayStxBuilder.build,[Lean.Syntax, Lean.Quote.quote]]
[Lean.PrettyPrinter.Parenthesizer.instMonadQuotationParenthesizerM,[Lean.MonadQuotation.mk, Pure.pure, arbitrary]]
[boolToProp,[Coe.mk, Eq, Bool.true]]
[Lean.MonadQuotation.getCurrMacroScope,[]]
[Lean.Parser.Tactic.Conv.pattern,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.Server.FileWorker.Reference.ident,[]]
[Int.add_zero,[Eq, HAdd.hAdd, OfNat.ofNat, rfl]]
[Lean.Meta.generalizeTelescope,[Bind.bind, Array.mapM, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Pure.pure, Lean.Meta.GeneralizeTelescope.Entry.mk, Bool.false, Lean.Meta.GeneralizeTelescope.generalizeTelescopeAux, OfNat.ofNat, List.toArray, List.nil]]
[Lean.Meta.instInhabitedState,[Inhabited.mk, Lean.Meta.State.mk, arbitrary]]
[Lean.Elab.Term.Quotation.ArrayStxBuilder.push,[Lean.Elab.Term.Quotation.ArrayStxBuilder, Sum.inl, Array.push, Sum.inr, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil]]
[or_iff_left_of_imp,[Iff.intro, id, Or.inl]]
[UInt64.instRingUInt64.proof_2,[congrArg, UInt64.mk, Ring.gsmul_zero', UInt64.val]]
[Lean.PrettyPrinter.Delaborator.ParamKind.name,[]]
[DivInvMonoid.gpow_succ',[]]
[Lean.ScopedEnvExtension.ScopedEntries.mk.inj,[]]
[USize.ofNat32.proof_1,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, OfNat.ofNat, HEq.refl, LT.lt, USize.size, usize_size_eq, Nat.lt_trans, of_decide_eq_true, Bool.true]]
[Lean.Parser.tokenWithAntiquotFn,[Id.run, ite, Eq, or, Lean.Parser.ParserState.hasError, BEq.beq, Lean.Parser.ParserContext.quotDepth, OfNat.ofNat, Bool.true, Pure.pure, Bind.bind, PUnit.unit]]
[Lean.Meta.FindOptions.stage1,[]]
[Lean.instInhabitedLevel,[Inhabited.mk, Lean.Level.zero, arbitrary]]
[Lean.Meta.TransparencyMode.lt,[Lean.Meta.TransparencyMode.all, Unit.unit, Lean.Meta.TransparencyMode.default, Lean.Meta.TransparencyMode.reducible, Lean.Meta.TransparencyMode.instances, Bool, Bool.true, Bool.false]]
[instDecidableEqBool,[Unit.unit, Decidable, Eq, Decidable.isTrue, rfl, Decidable.isFalse, instDecidableEqBool.proof_1, instDecidableEqBool.proof_2]]
[Lean.Meta.DefaultInstances.mk.inj,[And.intro]]
[Function.surjective_id,[Exists.intro, rfl]]
[Lean.Meta.UnificationConstraint.lhs,[]]
[unexpandUnit,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Lean.Lsp.PlainTermGoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.lt_ge_by_cases.proof_1,[Iff.mp, not_lt]]
[Quot.recOn,[Quot.rec]]
[Lean.Parser.Tactic.matchHyp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser]]
[Nat.mul_div_le,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, OfNat.ofNat, HEq.refl, LE.le, HMul.hMul, HDiv.hDiv, Nat.eq_zero_or_pos, Eq.mpr, Nat.zero_mul, Nat.zero_le, Nat.mul_comm, propext, Nat.le_div_iff_mul_le, Nat.le_refl]]
[Lean.Parser.Term.parenSpecial.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.tupleTail.parenthesizer, Lean.Parser.Term.typeAscription.parenthesizer]]
[Lean.Server.FileWorker.SemanticTokensState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.FileWorker.SemanticTokensState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Tactic.Ring.horner_mul_horner,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Tactic.Ring.horner, Eq.symm, HAdd.hAdd, OfNat.ofNat, of_eq_true, Eq.trans, congr, congrArg, congrFun, mul_comm, HPow.hPow, mul_add, mul_left_comm, add_mul, mul_assoc, add_zero, eq_self]]
[Lean.Meta.UnificationHint.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Sigma.fst,[]]
[«term¬_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.Command.State.env,[]]
[String.Iterator.noConfusionType,[]]
[Lean.IR.EmitC.Context.modName,[]]
[Lean.instToStringOptions,[inferInstanceAs, ToString, Lean.KVMap]]
[instOfNat,[OfNat.mk, Zero.zero]]
[Lean.IR.Borrow.BorrowInfCtx.decls,[]]
[Lean.Parser.Tactic.guardTags,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[Lean.nameLitKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.ScopedEnvExtension.Descr.toOLeanEntry,[]]
[Lean.JsonRpc.Batch,[Array, Lean.JsonRpc.Message]]
[Lean.Meta.mkHasTypeButIsExpectedMsg,[MonadExcept.tryCatch, Bind.bind, Lean.Meta.inferType, Lean.Meta.addPPExplicitToExposeDiff, Lean.Meta.MetaM, Lean.MessageData, Pure.pure, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.indentExpr]]
[Lean.Elab.Command.instInhabitedCtorView,[Inhabited.mk, Lean.Elab.Command.CtorView.mk, arbitrary]]
[isValidChar,[Or, LT.lt, OfNat.ofNat, And]]
[Lean.Elab.Term.SyntheticMVarDecl.mvarId,[]]
[Lean.Elab.Term.Do.ToTerm.Context.m,[]]
[Lean.registerEnvExtension,[Lean.EnvExtensionInterface.registerExt, Lean.EnvExtensionInterfaceImp]]
[Lean.Expr.proj.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.terminationBy.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.terminationHint.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[String.getOp,[String.get]]
[Lean.IR.ExplicitRC.mustConsume,[and, Lean.IR.ExplicitRC.VarInfo.ref, Lean.IR.ExplicitRC.VarInfo.consume]]
[Lean.Meta.mkImpCongrCtx,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil]]
[coeTC,[CoeTC.coe]]
[Function.curry_uncurry,[rfl]]
[StateRefT'.instMonadFunctorStateRefT',[inferInstanceAs, MonadFunctor, ReaderT, ST.Ref]]
[Lean.IR.CtorInfo.noConfusionType,[]]
[Lean.Server.Watchdog.WorkerState.crashed.inj,[]]
[Lean.Macro.throwErrorAt,[Lean.withRef, Lean.Macro.throwError]]
[Lean.Environment.addAux,[Lean.Environment.mk, Lean.Environment.const2ModIdx, Lean.SMap.insert, Lean.Environment.constants, Lean.ConstantInfo.name, Lean.Environment.extensions, Lean.Environment.header]]
[Lean.Meta.instInhabitedTransparencyMode,[Inhabited.mk, Lean.Meta.TransparencyMode.all]]
[System.FilePath.isAbsolute,[or, List.contains, System.FilePath.pathSeparators, String.front, System.FilePath.toString, and, System.Platform.isWindows, Decidable.decide, GE.ge, String.bsize, OfNat.ofNat, BEq.beq, String.getOp, Char.ofNat]]
[Lean.Lsp.SemanticTokensOptions.full,[]]
[Lean.Elab.Term.CollectPatternVars.Context.args,[]]
[Lean.PrettyPrinter.Delaborator.maybeAddBlockImplicit,[Bind.bind, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPAnalysisBlockImplicit, ite, Eq, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Function.comp.left_id,[rfl]]
[and_or_distrib_right,[Iff.trans, Or.comm, or_and_distrib_left, and_congr]]
[List.eq_or_ne_mem_of_mem,[Classical.em, Eq, Or.inl, Eq.symm, Or.inr, And.intro, Or.resolve_left, Eq.refl]]
[Lean.ResolveName.resolveNamespaceUsingOpenDecls,[Unit.unit, Lean.OpenDecl.simple, List.cons, Lean.OpenDecl.explicit, Option, Lean.Name, Option.none, ite, Eq, Lean.Environment.isNamespace, HAppend.hAppend, Bool.true, Option.some, PProd.fst]]
[Lean.MessageDataContext.mk.inj,[And.intro]]
[Nat.prod_dvd_and_dvd_of_dvd_prod.proof_2,[Eq.refl, Nat.gcd]]
[Lean.Compiler.getCachedSpecialization,[Lean.SMap.find?, Lean.Compiler.SpecState.cache, Lean.SimplePersistentEnvExtension.getState, Lean.Compiler.specExtension]]
[Lean.IR.instToFormatCtorInfo,[Std.ToFormat.mk, Std.Format, Id.run, ite, Eq, or, Decidable.decide, GT.gt, OfNat.ofNat, Bool.true, Bind.bind, Pure.pure, PUnit.unit]]
[Lean.Lsp.ServerCapabilities.textDocumentSync?,[]]
[Lean.MessageData.toString,[Bind.bind, Lean.MessageData.format, Pure.pure, ToString.toString]]
[Lean.Meta.DefEqContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[xor_comm,[of_eq_true, Eq.trans, congrArg, Eq, Or, And, Not, propext, or_comm, eq_self]]
[List.erasep_cons,[rfl]]
[ite_true,[rfl]]
[Lean.Export.State.exprs,[]]
[Lean.Meta.withExistingLocalDecls,[Lean.Meta.mapMetaM, Bind.bind, MonadReader.read, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.localInstances, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth, List.foldlM, Lean.Meta.isClass?, Lean.LocalDecl.type, Unit.unit, Lean.Meta.MetaM, Array, Lean.LocalInstance, Pure.pure, Array.push, Lean.LocalInstance.mk, Lean.LocalDecl.toExpr, ite, Eq, BEq.beq, Array.size, Bool.true, Lean.Meta.resettingSynthInstanceCache, Lean.Meta.Context.lctx]]
[Lean.PrettyPrinter.Formatter.numLitNoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.visitAtom, Lean.numLitKind]]
[Lean.Elab.Term.resolveId?,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Elab.Term.TermElabM, Option, Lean.Expr, Bind.bind, MonadExcept.tryCatch, Lean.Elab.Term.resolveName, List.nil, Option.none, Pure.pure, Lean.throwError, Lean.ToMessageData.toMessageData]]
[IO.Error.userError.inj,[]]
[Std.ShareCommon.mkObjectSet,[Std.mkHashSet, OfNat.ofNat]]
[Fin.checked_mul_spec,[Iff.intro, Decidable.em, LE.le, HMul.hMul, Fin.val, False.elim, Eq.mp, Eq.trans, congrFun, congrArg, Eq, Unit.unit, Bool, Option, Fin, Prod.mk, Iff.mpr, decide_eq_true_iff, Option.none, Option.some, Bool.true, Bool.false, eq_false', Eq.symm, Nat.lt_of_not_le, Eq.refl, of_eq_true, decide_eq_false, Nat.not_le_of_lt, eq_true_of_decide]]
[Lean.Meta.instReduceEvalName,[Lean.Meta.ReduceEval.mk]]
[Lean.Lsp.SemanticTokensRangeParams.noConfusionType,[]]
[Lean.Level.PP.Result.maxNode.inj,[]]
[Lean.IR.IRType.union.inj,[And.intro]]
[ST.Prim.Ref.modifyUnsafe,[Bind.bind, ST.Prim.Ref.take, ST.Prim.Ref.set]]
[instMulNat,[Mul.mk, Nat.mul]]
[Subarray.popFront.proof_1,[Nat.le_of_lt_succ, Nat.add_lt_add_right, OfNat.ofNat]]
[Lean.evalOptPrio,[Unit.unit, Lean.MacroM, Nat, Lean.evalPrio, Pure.pure, OfNat.ofNat]]
[PProd.noConfusionType,[]]
[Std.PersistentHashSet.contains,[Std.PersistentHashMap.contains, Std.PersistentHashSet.set]]
[Lean.instFVarIdSetEmptyCollection,[Std.instEmptyCollectionRBTree, Lean.FVarId, Lean.Name.quickCmp, Lean.FVarId.name]]
[Lean.instInhabitedHeadIndex,[Inhabited.mk, Lean.HeadIndex.fvar, arbitrary]]
[Lean.Lsp.PlainGoalParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.PlainGoalParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[add_left_cancel,[IsAddLeftCancel.add_left_cancel]]
[Std.AssocList.foldlM,[Pure.pure, Bind.bind, PProd.fst]]
[Lean.Elab.Command.CollectAxioms.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.StructInst.Struct.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.StructInst.Struct.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Widget.InteractiveGoals.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.GeneralizeIndicesSubgoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.GeneralizeIndicesSubgoal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.DocumentFilter.pattern?,[]]
[Lean.Parser.Tactic.wlog,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.sepBy1]]
[String.quote,[ite, Eq, String.isEmpty, Bool.true, HAppend.hAppend, String.foldl, Char.quoteCore]]
[Lean.ScopedEnvExtension.StateStack.mk.inj,[And.intro]]
[OptionM.run,[]]
[Lean.Parsec.orElse,[Lean.Parsec.ParseResult, Lean.Parsec.ParseResult.success, ite, Eq, Unit.unit, Lean.Parsec.ParseResult.error]]
[MonadFunctorT.noConfusionType,[]]
[Lean.PrefixTreeNode.insert,[Lean.PrefixTreeNode.insert.loop, Lean.PrefixTreeNode.insert.insertEmpty]]
[Lean.Meta.SynthInstance.Answer.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SynthInstance.Answer.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.fieldSimp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.instFromJsonBool,[Lean.FromJson.mk, Lean.Json.getBool?]]
[Lean.Parser.Term.binderDefault,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser]]
[Substring.posOf,[String.Pos, HSub.hSub, String.posOfAux]]
[Lean.Parser.Term.funBinder.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.PrettyPrinter.Formatter.evalInsideQuot.formatter, Lean.Parser.Term.funBinder.formatter]]
[Lean.Meta.RecursorInfo.majorPos,[]]
[Lean.Parser.Command.macroTailTactic,[HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.identEq, Lean.Name.mkSimple, Lean.Parser.darrow, Lean.Parser.Command.macroRhs, Lean.Parser.Tactic.seq1]]
[stdRange,[Prod.mk, OfNat.ofNat]]
[Lean.Json.instCoeNatJson,[Coe.mk, Lean.Json.num, Lean.JsonNumber.fromNat]]
[Array.forIn.loop.proof_1,[Nat.lt_of_le_of_lt, Nat.sub_le, HSub.hSub, Array.size, OfNat.ofNat, Nat.sub_lt, Nat.zero_lt_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self, of_decide_eq_true, Eq.refl, Bool.true]]
[Std.ShareCommon.ObjectPersistentSet,[Std.PersistentHashSet, Std.ShareCommon.Object]]
[Array.size_pop,[List.length_dropLast, Array.data]]
[Lean.Parser.Term.strictImplicitLeftBracket.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.group.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer]]
[Lean.IR.FnBody.sset.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.sset, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Match.MatchEqnsExtState.noConfusionType,[]]
[Lean.Parser.many1.formatter,[Lean.PrettyPrinter.Formatter.many1NoAntiquot.formatter, Lean.Parser.withAntiquotSpliceAndSuffix.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol.formatter]]
[Lean.Json.instCoeIntJson,[Coe.mk, Lean.Json.num, Lean.JsonNumber.fromInt]]
[Prod.lex_def,[Iff.intro, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Or, Prod.fst, And, Eq, Prod.snd, of_eq_true, Eq.trans, congrFun, congrArg, eq_true, true_or, congr, eq_self, eq_true_of_decide, Bool.true, or_true, Prod.Lex, Prod.Lex.left, Prod.Lex.right]]
[Lean.Server.RequestTask,[Task, Except, Lean.Server.RequestError]]
[Lean.findSysroot?,[Bind.bind, liftM, IO.getEnv, Option.none, IO, System.FilePath, Pure.pure, System.FilePath.mk, PUnit.unit]]
[Lean.Elab.Deriving.Header.argNames,[]]
[Lean.Macro.withFreshMacroScope,[Bind.bind, MonadState.modifyGet, Prod.mk, Lean.Macro.State.macroScope, Lean.Macro.State.mk, HAdd.hAdd, OfNat.ofNat, Lean.Macro.State.traceMsgs, MonadWithReader.withReader, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth, Lean.Macro.Context.ref]]
[Lean.PrettyPrinter.Formatter.setLhsPrec.formatter,[Pure.pure, Unit.unit]]
[Lean.Elab.logErrorAt,[Lean.Elab.logAt, Lean.MessageSeverity.error]]
[Lean.Parser.Tactic.ghostCalc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.binderIdent]]
[Lean.Lsp.instFromJsonInitializedParams,[Lean.FromJson.mk, Pure.pure, Lean.Lsp.InitializedParams.mk]]
[not_exists_of_forall_not,[Iff.mpr, exists_imp_distrib]]
[Lean.Name.isSuffixOf,[Lean.Name.str, Lean.Name.anonymous, Lean.Name.num, Bool, Bool.true, and, BEq.beq, PProd.fst, Bool.false]]
[Lean.Meta.UnificationHintEntry.keys,[]]
[Lean.NamePart.num.injEq,[Eq.propIntro, Eq.refl, Lean.NamePart.num, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.WF.TerminationHintValue.value,[]]
[Lean.Core.Context.maxHeartbeats,[]]
[USize.noConfusionType,[]]
[Lean.TagDeclarationExtension.isTagged,[Unit.unit, Bool, Lean.Environment.getModuleIdxFor?, Array.binSearchContains, Lean.PersistentEnvExtension.getModuleEntries, Lean.Name.quickLt, OfNat.ofNat, HSub.hSub, Array.size, Lean.NameSet.contains, Lean.SimplePersistentEnvExtension.getState]]
[Tactic.Ring.horner_mul_const,[of_eq_true, Eq.trans, congr, congrArg, Eq, add_mul, HMul.hMul, HPow.hPow, congrFun, HAdd.hAdd, mul_right_comm, Eq.symm, eq_self]]
[Lean.Parser.rawIdent,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.identKind, Bool.true, Lean.Parser.rawIdentNoAntiquot]]
[Lean.Elab.addAndCompileNonRec,[Lean.withRef, Lean.Elab.PreDefinition.ref, Bind.bind, liftM, Lean.Elab.abstractNestedProofs, Lean.MonadEnv.getEnv, Lean.addDecl, Lean.Elab.withSaveInfoContext, Lean.mkConstWithLevelParams, Lean.Elab.PreDefinition.declName, Lean.Elab.Term.addTermInfo, Option.none, Lean.Name.anonymous, Bool.true, Lean.Elab.applyAttributesOf, List.toArray, List.cons, List.nil, Lean.AttributeApplicationTime.afterTypeChecking, ite, Eq, and, not, Lean.Elab.DefKind.isTheorem, Lean.Elab.PreDefinition.kind, Lean.Elab.Modifiers.isNoncomputable, Lean.Elab.PreDefinition.modifiers, MonadExcept.tryCatch, Lean.compileDecl, Pure.pure, DoResultPR.pure, PUnit.unit, MonadReader.read, Lean.Elab.Term.Context.isNoncomputableSection, DoResultPR.return, Bool.false, MonadExcept.throw, Lean.Elab.Term.TermElabM, Bool, Unit.unit]]
[Lean.Parser.Term.typeOf.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec]]
[StateCpsT.runK_get,[rfl]]
[Lean.Level.PP.Result.leaf.inj,[]]
[Lean.IR.IsLive.visitVar,[Pure.pure, Lean.IR.HasIndex.visitVar]]
[Lean.Parser.Attr.interactive,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.IR.ExpandResetReuse.mkFastPath,[Bind.bind, MonadReader.read, Lean.IR.ExpandResetReuse.releaseUnreadFields]]
[Lean.Elab.instInhabitedCommandInfo,[Inhabited.mk, Lean.Elab.CommandInfo.mk, arbitrary]]
[Lean.Json.Parser.str,[Lean.Json.Parser.strCore]]
[Setoid.iseqv,[]]
[Lean.Elab.Term.BinderView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.BinderView.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.StructureInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.StructureInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Int.natAbs,[Nat, Nat.succ]]
[Lean.Parser.Term.byTactic.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Tactic.tacticSeq.parenthesizer]]
[List.eraseDups,[List.eraseDupsAux, List.nil]]
[«term#[_,]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false]]
[Classical.strongIndefiniteDescription.proof_2,[absurd]]
[Nat.instShiftRightNat,[ShiftRight.mk, Nat.shiftRight]]
[Lean.ExternAttrData.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ExternAttrData.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.mk.inj,[And.intro]]
[Lean.Expr.updateForall!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateForall, Lean.Expr.forallE, Lean.Expr.updateForall!.proof_1, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Parser.Command.declModifiersT.formatter,[Lean.Parser.Command.declModifiers.formatter, Bool.true]]
[Unit.unit,[PUnit.unit]]
[Lean.Elab.Command.ProjectionInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Std.RBTree.instReprRBTree,[Repr.mk, Repr.addAppParen, HAppend.hAppend, Std.Format.text, repr, Std.RBTree.toList]]
[instInhabitedTrue,[Inhabited.mk, True.intro]]
[Lean.Expr.updateApp!.proof_1,[rfl]]
[Lean.Elab.Deriving.BEq.mkBEqInstanceHandler,[Bind.bind, Lean.isEnumType, Array.getOp, OfNat.ofNat, ite, Eq, and, BEq.beq, Array.size, Bool.true, Lean.Elab.Command.liftTermElabM, Option.none, Lean.Elab.Deriving.mkContext, Pure.pure, Lean.Elab.Deriving.Context.auxFunNames, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Lean.Syntax.atom, Lean.mkIdent, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Lean.Elab.Deriving.mkInstanceCmds, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, PUnit.unit, Array.forM, Lean.Elab.Command.elabCommand, Array.allM, Lean.isInductive, Decidable.decide, GT.gt, Lean.Elab.Deriving.BEq.mkMutualBlock, Bool.false]]
[Lean.Parser.Term.inaccessible.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter]]
[Lean.MessageData.tagged.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.SSet.insert,[Lean.SMap.insert, Unit.unit]]
[Lean.getConstInfoCtor,[Bind.bind, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo, Lean.ConstructorVal, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkConst, List.nil]]
[Nat.gcd_assoc,[Nat.dvd_antisymm, Nat.dvd_gcd, Nat.dvd_trans, Nat.gcd_dvd_left, Nat.gcd, Nat.gcd_dvd_right]]
[List.getD,[Option.getD, List.get?]]
[Lean.IR.JoinPointId.idx,[]]
[Lean.KeyedDeclsAttribute.ExtensionState.table,[]]
[Lean.Elab.Term.registerCustomErrorIfMVar,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Elab.Term.TermElabM, Unit, Lean.Expr.getAppFn, Lean.Elab.Term.registerMVarErrorCustomInfo, Pure.pure, Unit.unit]]
[Sum.noConfusionType,[]]
[Lean.JsonRpc.ErrorCode.serverNotInitialized.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.InfoState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Function.update_comp_eq_of_injective',[Iff.mpr, Function.eq_update_iff, And.intro, Function.update_same, Function.update_noteq, Function.injective.ne]]
[Lean.Elab.DerivingClassView.ref,[]]
[Lean.IR.Alt,[Lean.IR.AltCore, Lean.IR.FnBody]]
[FloatArray.isEmpty,[BEq.beq, FloatArray.size, OfNat.ofNat]]
[Lean.Parser.Tactic.Conv.normNum1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Elab.Term.Do.getDoLetRecVars,[Bind.bind, ForIn.forIn, Lean.Elab.Term.Do.getLetDeclVars, Pure.pure, PUnit.unit, ForInStep.yield]]
[Lean.instToMessageDataLevel,[Lean.ToMessageData.mk, Lean.MessageData.ofLevel]]
[Lean.KVMap.insert,[Lean.KVMap, Lean.KVMap.mk, Lean.KVMap.insertCore]]
[Lean.Compiler.atMostOnce.visitFVar,[Lean.Compiler.atMostOnce.AtMostOnceData.mk, Bool.false, Unit.unit, Bool.true, Lean.Compiler.atMostOnce.AtMostOnceData, BEq.beq, bne]]
[Lean.Elab.Structural.addSmartUnfoldingDef,[Bind.bind, liftM, Lean.Meta.isProp, Lean.Elab.PreDefinition.type, ite, Eq, Bool.true, Pure.pure, Unit.unit, Lean.Elab.Structural.addSmartUnfoldingDefAux, Lean.Elab.addNonRec]]
[Lean.Elab.WF.TerminationHintValue.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.DiscrTree.instBEqKey,[BEq.mk, Lean.Meta.DiscrTree.Key.const, Lean.Meta.DiscrTree.Key.fvar, Lean.Meta.DiscrTree.Key.lit, Lean.Meta.DiscrTree.Key.star, Lean.Meta.DiscrTree.Key.other, Lean.Meta.DiscrTree.Key.arrow, Lean.Meta.DiscrTree.Key.proj, Unit.unit, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Mathlib.ExtendedBinder.«command__Binder_predicate_____=>_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Tactic.assumptionModCast,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Elab.Term.MutualClosure.UsedFVarsMap,[Lean.FVarIdMap, Lean.FVarIdSet]]
[Lean.mkIdentFromRef,[Bind.bind, Lean.MonadRef.getRef, Pure.pure, Lean.mkIdentFrom]]
[Lean.IR.LocalContext.getJPParams,[Option.none, Option.some, Lean.IR.LocalContextEntry.param, Lean.IR.LocalContextEntry.localVar, Option, Array, Lean.IR.Param, Std.RBMap.find?, Lean.IR.JoinPointId.idx]]
[Lean.mkMData,[Lean.Expr.mdata, Lean.Expr.mkData, mixHash, UInt8.toUInt64, Hashable.hash, Lean.Expr.looseBVarRange, Lean.Expr.hasFVar, Lean.Expr.hasExprMVar, Lean.Expr.hasLevelMVar, Lean.Expr.hasLevelParam]]
[Lean.Elab.Term.MVarErrorInfo.kind,[]]
[Lean.Elab.TermInfo.expectedType?,[]]
[Lean.IR.UnreachableBranches.FunctionSummaries,[Lean.SMap, Lean.IR.FunId, Lean.IR.UnreachableBranches.Value]]
[Std.AssocList.findEntry?,[Unit.unit, Option, Prod, Option.none, BEq.beq, Option.some, Prod.mk, PProd.fst]]
[Lean.Meta.forallMetaTelescopeReducing,[List.toArray, List.nil, OfNat.ofNat, Bool.true]]
[Lean.Lsp.RpcConnected.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.isRec,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.isRecCore]]
[Lean.Elab.Command.StructFieldKind.fromParent.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Std.RBMap.findD,[Option.getD, Std.RBMap.find?]]
[Lean.Meta.isTypeCorrect,[MonadExcept.tryCatch, Bind.bind, Lean.Meta.check, Pure.pure, Bool.true, Lean.isTracingEnabledFor, ite, Eq, Lean.addTrace, Lean.Exception.toMessageData, PUnit.unit]]
[Lean.Attribute.erase,[Bind.bind, Lean.MonadEnv.getEnv, Lean.ofExcept, Lean.getAttributeImpl, Lean.AttributeImpl.erase]]
[Lean.KeyedDeclsAttribute.instInhabitedDef,[Inhabited.mk, Lean.KeyedDeclsAttribute.Def.mk, arbitrary]]
[Lean.addMacroScope,[Unit.unit, Lean.Name, Lean.Name.hasMacroScopes, BEq.beq, Lean.MacroScopesView.mainModule, Lean.Name.mkNum, Lean.MacroScopesView.review, Lean.MacroScopesView.mk, Lean.MacroScopesView.name, List.foldl, HAppend.hAppend, Lean.MacroScopesView.imported, Lean.MacroScopesView.scopes, List.cons, List.nil, Lean.Name.mkStr]]
[StateCpsT.runK_bind_set,[rfl]]
[Nat.instNumericNat,[Numeric.mk, id]]
[Lean.Server.instMonadLiftIORequestM,[MonadLift.mk, liftM, IO.toEIO, Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.internalError, ToString.toString]]
[Lean.QuotVal.toConstantVal,[]]
[Lean.Elab.Term.Do.addFreshJP,[Bind.bind, liftM, Lean.Elab.Term.Do.mkFreshJP, modify, Array.push, Pure.pure, Lean.Elab.Term.Do.JPDecl.name]]
[List.append_bind,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, List.bind, List.cons_append, List.cons_bind, HAppend.hAppend, List.append_assoc, eq_self]]
[Std.PersistentHashMap.insertAtCollisionNode,[Std.PersistentHashMap.insertAtCollisionNodeAux, OfNat.ofNat]]
[Lean.Meta.NormNum.instLawfulOfNat_1,[Lean.Meta.NormNum.instLawfulOfNat_1.proof_1]]
[List.length_pos_iff_ne_nil,[Iff.intro, List.ne_nil_of_length_pos, List.length_pos_of_ne_nil]]
[IsMulRightCancel.noConfusionType,[]]
[Lean.MetavarContext.UnivMVarParamResult.mctx,[]]
[Lean.Lsp.instToJsonWaitForDiagnostics,[Lean.ToJson.mk, Lean.Json.mkObj, List.nil]]
[Lean.Elab.ElabInfo.stx,[]]
[Nat.lcm_zero_right,[Nat.lcm_zero_left, Nat.lcm_comm, OfNat.ofNat]]
[Lean.Elab.Structural.RecArgInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Widget.instInhabitedTaggedText,[Inhabited.mk, Lean.Widget.TaggedText.text, arbitrary]]
[Lean.Parser.unicodeSymbolFn,[Lean.Parser.unicodeSymbolFnAux, List.cons, HAppend.hAppend, List.nil]]
[Lean.Parser.ParserState.mkTrailingNode,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk]]
[Lean.PrettyPrinter.Delaborator.SubExpr.expr,[]]
[List.card_union_disjoint,[Eq.mpr, Eq.refl, Eq, List.card, List.union, HAdd.hAdd, List.card_eq_of_equiv, List.union_equiv_append, HAppend.hAppend, List.card_append_disjoint, rfl]]
[Lean.Elab.Term.Quotation.HeadCheck.slice.inj,[And.intro]]
[Lean.Elab.Command.InductiveView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.CtorFieldInfo.scalar.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.CtorFieldInfo.scalar, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.ExtractMonadResult.α,[]]
[Lean.Elab.Term.StructInst.DefaultFields.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.Do.Code.break.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.Do.Code.break, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Syntax.isMissing,[Unit.unit, Lean.Syntax.node, Lean.Syntax.atom, Lean.Syntax.ident, Bool, Bool.true, Bool.false]]
[Lean.instInhabitedEnvironmentHeader,[Inhabited.mk, Lean.EnvironmentHeader.mk, arbitrary]]
[Lean.IR.IRType.struct.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.IRType.struct, Eq.symm, eq_of_heq, HEq.refl]]
[String.Iterator.toEnd,[String.Iterator, String.Iterator.mk, String.bsize]]
[Lean.Server.Watchdog.OpenDocument.mk.inj,[And.intro]]
[Lean.Parser.Command.terminationHintMany.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.lookahead.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1Indent.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.Parser.optional.parenthesizer]]
[List.decidableMem.proof_3,[not_or_intro]]
[Lean.Parser.notFollowedByCategoryToken,[Lean.Parser.Parser.mk, Lean.Parser.notFollowedByCategoryTokenFn]]
[Lean.Elab.Term.Quotation.MatchResult.uncovered.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.PersistentEnvExtension.exportEntriesFn,[]]
[MProd.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, MProd.mk, Eq.symm, eq_of_heq, HEq.refl]]
[ExceptCpsT.runCatch_pure,[rfl]]
[Lean.Position.line,[]]
[Lean.Parser.minPrec,[OfNat.ofNat]]
[Lean.Parser.group.formatter,[Lean.PrettyPrinter.Formatter.node.formatter, Lean.groupKind]]
[Or.assoc,[Iff.intro, Or.imp_right, Or.inl, Or.inr, Or.imp_left]]
[Std.Format.prettyM,[List.cons, Bool.false, Std.Format.FlattenBehavior.allOrNone, Int.ofNat, OfNat.ofNat, List.nil]]
[Lean.Elab.getInfoTrees,[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, Pure.pure, Lean.Elab.InfoState.trees]]
[Lean.Elab.Command.ElabStructResult.projInstances,[]]
[Fin.elim0,[absurd, Nat.not_lt_zero]]
[Lean.Compiler.setImplementedBy,[Lean.ParametricAttribute.setParam, Lean.Compiler.implementedByAttr]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.PostponedEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.PostponedEntry.rhs,[]]
[coeOfDep,[CoeT.mk, coeD]]
[Lean.Elab.Term.CollectPatternVars.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.CollectPatternVars.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Match.Problem.alts,[]]
[Lean.Elab.Term.StructInst.instToStringStruct,[ToString.mk, Function.comp, ToString.toString, Std.ToFormat.format]]
[and_iff_right,[Iff.intro, And.right, And.intro]]
[Lean.DeclarationRanges.noConfusionType,[]]
[Lean.NameGenerator.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.FromJson.noConfusionType,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.hasLevelMVarAtCurrDepth,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Option.isSome, Lean.Expr.findLevelMVar?, BEq.beq, Lean.MetavarContext.findLevelDepth?, Option.some, Lean.MetavarContext.depth]]
[PSigma.mkSkipLeft.proof_1,[PSigma.RevLex.right]]
[Int.decEq.proof_6,[]]
[Lean.Meta.Closure.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.FileWorker.instMonadRpcSession,[Lean.Server.MonadRpcSession.mk, MonadState.modifyGet, Lean.Server.FileWorker.RpcSession.store, Bind.bind, MonadState.get, Pure.pure, Std.PersistentHashMap.find?, Lean.Server.FileWorker.RpcSession.aliveRefs, Lean.Server.FileWorker.RpcSession.release]]
[Lean.Compiler.addSpecializationInfo,[Lean.PersistentEnvExtension.addEntry, Lean.Compiler.specExtension, Lean.Compiler.SpecEntry.info]]
[Array.binSearch,[ite, LT.lt, Array.size, Array.binSearchAux, id, Option.none]]
[Lean.Elab.Tactic.evalWithReducible,[Lean.Meta.withReducible, Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat]]
[USize.instAddSemigroupUSize,[AddSemigroup.mk, USize.instAddSemigroupUSize.proof_1]]
[Lean.PrettyPrinter.CategoryParenthesizer,[Lean.PrettyPrinter.Parenthesizer]]
[Std.PersistentHashSet.isEmpty,[Std.PersistentHashMap.isEmpty, Std.PersistentHashSet.set]]
[Lean.Rat.instCoeIntRat,[Coe.mk]]
[Substring.prevn,[String.Pos, PProd.fst, Substring.prev]]
[Lean.Server.Watchdog.ServerContext.hLog,[]]
[PartialOrder.noConfusionType,[]]
[HOr.hOr,[]]
[Lean.IR.UnreachableBranches.Value.instBEqValue,[BEq.mk, Lean.IR.UnreachableBranches.Value.beq]]
[List.drop_eq_nil_of_le',[Eq, List.drop, List.nil, rfl, Eq.symm, Eq.refl, OfNat.ofNat, HEq.refl]]
[Lean.StructureFieldInfo.binderInfo,[]]
[precArg,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Bool.ff_ne_tt,[]]
[Lean.Parser.Term.let_delayed.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.letDecl.formatter, Lean.Parser.Term.optSemicolon.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Lean.PrettyPrinter.Parenthesizer.identNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken]]
[USize.eq_of_val_eq,[Eq, congrArg, USize.mk]]
[Lean.Meta.NormNum.instLawfulOfNatInt,[Lean.Meta.NormNum.instLawfulOfNatInt.proof_1]]
[Lean.IR.Borrow.ParamMap.Key.decl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.elabPipeCompletion,[Bind.bind, Lean.Elab.Term.elabTerm, Lean.Syntax.getOp, OfNat.ofNat, Option.none, Bool.true, ite, Eq, Lean.Expr.isSorry, Pure.pure, PUnit.unit, Lean.Elab.Term.addDotCompletionInfo]]
[non_contradictory,[Not]]
[Lean.Server.registerLspRequestHandler,[Bind.bind, liftM, IO.initializing, ite, Eq, not, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Pure.pure, PUnit.unit]]
[instAddCommMonoid_1,[AddCommMonoid.mk, instAddCommMonoid_1.proof_1]]
[Lean.Parser.Command.addDeclDoc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol]]
[Lean.IR.Expr.lit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MetavarContext.LevelMVarToParam.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.CongrArgKind.eq.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.SavedState.restore,[Bind.bind, liftM, Lean.Core.restore, Lean.Meta.SavedState.core, modify, Lean.Meta.State.mk, Lean.Meta.State.mctx, Lean.Meta.SavedState.meta, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Modifiers.addAttribute,[Lean.Elab.Modifiers.mk, Lean.Elab.Modifiers.docString?, Lean.Elab.Modifiers.visibility, Lean.Elab.Modifiers.isNoncomputable, Lean.Elab.Modifiers.recKind, Lean.Elab.Modifiers.isUnsafe, Array.push, Lean.Elab.Modifiers.attrs]]
[String.trimRight,[Substring.toString, Substring.trimRight, String.toSubstring]]
[Lean.Meta.AbstractMVars.State.mk.inj,[And.intro]]
[Lean.Parser.Term.noindex.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec]]
[instMonadControlT,[MonadControlT.mk, MonadControlT.stM, MonadControl.stM, MonadControl.liftWith, MonadControlT.liftWith, Function.comp, MonadControl.restoreM, MonadControlT.restoreM]]
[USize.mul,[USize.mk, HMul.hMul, USize.val]]
[Lean.LocalContext.lastDeclM,[Bind.bind, Lean.LocalContext.findDeclRevM?, Function.comp, optional, Unit.unit, Alternative.failure, Pure.pure]]
[Std.Format.joinSep,[List.cons, Std.Format, Std.Format.nil, Std.ToFormat.format, HAppend.hAppend, PProd.fst]]
[Lean.Elab.Level.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.FileWorker.getInteractiveGoals,[Bind.bind, Lean.Server.RequestM.readDoc, Lean.Server.RequestM.withWaitFindSnap, Decidable.decide, GE.ge, Lean.Server.Snapshots.Snapshot.endPos, Pure.pure, Option.none, List.nil, List.cons, Lean.Server.RequestM, Option, Lean.Widget.InteractiveGoals, Lean.Elab.InfoTree.goalsAt?, Lean.Server.DocumentMeta.text, Lean.Server.FileWorker.EditableDocument.meta, Lean.Server.Snapshots.Snapshot.infoTree, Functor.map, List.join, List.mapM, List, Lean.Widget.InteractiveGoal, liftM, Lean.Elab.ContextInfo.runMetaM, Lean.LocalContext.mk, Lean.Meta.withPPInaccessibleNames, Lean.Widget.goalToInteractive, Bool.true, Option.some, Lean.Widget.InteractiveGoals.mk, List.toArray]]
[Decidable.of_not_not,[Decidable.byContradiction, absurd]]
[Lean.Compiler.CSimp.instInhabitedEntry,[Inhabited.mk, Lean.Compiler.CSimp.Entry.mk, arbitrary]]
[List.takeWhile,[Unit.unit, List, List.nil, List.cons, PProd.fst]]
[SubNegMonoid.gsmul_succ',[]]
[ReaderT.instLawfulMonadReaderT.proof_1,[LawfulMonad.mk, ReaderT.ext, Eq.mpr, congr, congrArg, Eq, Eq.trans, ReaderT.run_bind, Pure.pure, Bind.bind, ReaderT.run, funext, ReaderT.run_pure, ReaderT.run_map, LawfulMonad.bind_pure_comp, rfl, of_eq_true, congrFun, LawfulMonad.pure_bind, eq_self, LawfulMonad.bind_assoc]]
[Lean.Parser.optional.formatter,[Lean.PrettyPrinter.Formatter.optionalNoAntiquot.formatter, Lean.Parser.withAntiquotSpliceAndSuffix.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol.formatter]]
[Lean.Meta.Match.Example.val.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Example.val, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.dbgTraceStateFn,[dbgTrace, HAppend.hAppend, ToString.toString, Lean.Parser.ParserState.pos, Lean.Parser.ParserState.errorMsg, Array.extract, Lean.Parser.ParserState.stxStack, Array.size]]
[List.toFloatArray,[FloatArray.empty, List.toFloatArray.loop]]
[Lean.Expr.bindingDomain!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Json.Structured.arr.inj,[]]
[List.map,[Unit.unit, List, List.nil, List.cons, PProd.fst]]
[instToStreamListList,[ToStream.mk]]
[USize.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.version.isRelease,[Lean.version.getIsRelease, Unit.unit]]
[Lean.Syntax.getIdAt,[Lean.Syntax.getId, Lean.Syntax.getArg]]
[Std.PersistentHashMap.Node.ibelow,[And, True]]
[Lean.Meta.DefEqContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.DefEqContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.MonadLog.getRef,[]]
[Nat.succ_pred_eq_of_pos,[Eq.refl, Nat.zero, HEq.refl, Eq, Nat.succ, Nat.pred, rfl]]
[Lean.Elab.Term.LVal.isFieldName,[Lean.Elab.Term.LVal.fieldIdx, Lean.Elab.Term.LVal.getOp, Bool, Bool.true, Bool.false]]
[Lean.IR.UnreachableBranches.Value.bot.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Array.toPersistentArray,[Array.foldl, Std.PersistentArray.push, Std.PersistentArray.empty, OfNat.ofNat, Array.size]]
[Lean.PrefixTreeNode.Node.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrefixTreeNode.Node, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.LocalDecl.applyFVarSubst,[Lean.LocalDecl, Lean.LocalDecl.cdecl, Lean.Meta.FVarSubst.apply, Lean.LocalDecl.ldecl]]
[Lean.MessageData.instCoeSyntaxMessageData,[Coe.mk, Lean.MessageData.ofSyntax]]
[Lean.Parser.FirstTokens.toStr,[Unit.unit, String, ToString.toString, HAppend.hAppend]]
[Lean.Lsp.InitializeResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.InitializeResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[List.eq_or_mem_of_mem_insert,[Iff.mp, List.mem_insert_iff]]
[Lean.MonadMCtx.getMCtx,[]]
[Fin.instInhabitedFinHAdd,[Inhabited.mk, OfNat.ofNat]]
[Lean.Meta.reduceMatcher?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Lean.Meta.ReduceMatcherResult, Lean.Expr.getAppFn, Bind.bind, Lean.Meta.getMatcherInfo?, Option.none, ite, LT.lt, Array.size, HAdd.hAdd, Lean.Meta.Match.MatcherInfo.numAlts, Pure.pure, Lean.Meta.ReduceMatcherResult.partialApp, Lean.getConstInfo, Lean.Meta.inferType, Lean.Meta.forallBoundedTelescope, Option.some, Lean.Meta.getTransparency, Eq, BEq.beq, Lean.Meta.TransparencyMode.reducible, Bool.true, PUnit.unit, Lean.Meta.ReduceMatcherResult.notMatcher]]
[instSubUInt16,[Sub.mk, UInt16.sub]]
[Lean.PersistentEnvExtension.addEntryFn,[]]
[Lean.Expr.FoldConstsImpl.fold.visit,[Bind.bind, Lean.Expr.FoldConstsImpl.visited, ite, Eq, Bool.true, Pure.pure, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.lit, Lean.Expr.FoldConstsImpl.FoldM, Lean.Expr.FoldConstsImpl.fold.visit, MonadState.get, Lean.NameHashSet.contains, Lean.Expr.FoldConstsImpl.State.visitedConsts, modify, Lean.Expr.FoldConstsImpl.State.mk, Lean.Expr.FoldConstsImpl.State.visitedTerms, Lean.NameHashSet.insert]]
[Lean.idBeginEscape,[Char.ofNat]]
[List.reverseAux_eq_append,[of_eq_true, Eq.trans, congrArg, Eq, List.nil_append, eq_self, Eq.mpr, Eq.refl, List.reverseAux, List.cons, HAppend.hAppend, List.nil, List.append_assoc, rfl]]
[Lean.getPPAnalyzeTrustCoe,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.trustCoe, Lean.Option.defValue]]
[Subtype.coe_eta,[Subtype.ext, rfl]]
[Lean.Parser.Term.noindex,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.maxPrec]]
[Lean.Parser.Term.doContinue.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.Parser.Attr.export.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer]]
[Tactic.Ring.horner_add_horner_eq,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Tactic.Ring.horner, Eq.symm, of_eq_true, Eq.trans, congr, congrArg, add_comm, HMul.hMul, HPow.hPow, add_assoc, congrFun, add_mul, eq_self]]
[Mathlib.Tactic.Lint.LintVerbosity.high.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Array.back?,[Array.get?, HSub.hSub, Array.size, OfNat.ofNat]]
[Lean.Meta.injectionCore,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getLocalDecl, Lean.Meta.whnf, Lean.LocalDecl.type, Unit.unit, Lean.Meta.MetaM, Lean.Meta.InjectionResultCore, Lean.Expr.eq?, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing, Lean.Meta.getMVarType, Lean.MonadEnv.getEnv, Option.none, Option.some, Lean.Expr.isConstructorApp?, Lean.Meta.mkNoConfusion, Lean.mkFVar, ite, Eq, bne, Lean.ConstantVal.name, Lean.ConstructorVal.toConstantVal, Bool.true, Lean.Meta.assignExprMVar, Pure.pure, Lean.Meta.InjectionResultCore.solved, Lean.Meta.inferType, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.getMVarTag, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.mkApp, Lean.Meta.tryClear, Lean.Expr.mvarId!, Lean.Meta.getCtorNumPropFields, Lean.Meta.InjectionResultCore.subgoal, HSub.hSub, Lean.ConstructorVal.numFields]]
[Mathlib.Tactic.Conv.convRHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.Conv.convSeq]]
[Nat.mul_one,[Nat.zero_add]]
[instReprList_1,[Repr.mk, Std.Format, List.cons, Std.Format.text, Std.Format.bracketFill, Std.Format.joinSep, HAppend.hAppend, Std.Format.line]]
[Lean.Elab.Deriving.Repr.mkReprHeader,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.Elab.Deriving.mkHeader, OfNat.ofNat, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Prod.mk, Lean.Elab.Deriving.Header.mk, Array.push, Lean.Elab.Deriving.Header.binders, Lean.Elab.Deriving.Header.argNames, Lean.Elab.Deriving.Header.targetNames, Lean.Elab.Deriving.Header.targetType]]
[Lean.PrettyPrinter.Formatter.withOpenDecl.formatter,[]]
[instDecidableArrow.proof_3,[absurd]]
[Lean.Compiler.foldNatPow,[OptionM.run, Bind.bind, Lean.Compiler.getNumLit, ite, LT.lt, Lean.Compiler.natPowThreshold, Pure.pure, Lean.mkRawNatLit, HPow.hPow, Alternative.failure]]
[Lean.IR.Decl.isExtern,[Lean.IR.Decl.fdecl, Bool, Bool.true, Bool.false]]
[Lean.Server.Watchdog.mkLeanServerCapabilities,[Lean.Lsp.ServerCapabilities.mk, Option.some, Lean.Lsp.TextDocumentSyncOptions.mk, Bool.true, Lean.Lsp.TextDocumentSyncKind.incremental, Bool.false, Option.none, Lean.Lsp.CompletionOptions.mk, List.toArray, List.cons, List.nil, Lean.Lsp.SemanticTokensOptions.mk, Lean.Lsp.SemanticTokensLegend.mk, Lean.Lsp.SemanticTokenType.names]]
[Lean.Elab.Term.Do.ToTerm.Context.noConfusionType,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.inspectOutParams,[Bind.bind, liftM, Lean.Meta.inferType, Lean.Expr.getAppFn, OfNat.ofNat, Lean.Expr.getAppArgs, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.inspectOutParams.inspectAux]]
[Lean.Parser.Command.structCtor.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Command.declModifiers.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.inferMod.formatter, Lean.Parser.symbol.formatter]]
[Lean.Environment.constants,[]]
[Lean.Option.noConfusionType,[]]
[Lean.Parser.Command.openDecl.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.openHiding.formatter, Lean.Parser.Command.openRenaming.formatter, Lean.Parser.Command.openOnly.formatter, Lean.Parser.Command.openSimple.formatter, Lean.Parser.Command.openScoped.formatter]]
[sizeOfWFRel,[measure, SizeOf.sizeOf]]
[Lean.PersistentEnvExtensionDescr.noConfusionType,[]]
[Lean.Elab.Term.Quotation.ArrayStxBuilder.append,[Sum.inr, Lean.Syntax.mkCApp, List.toArray, List.cons, Lean.Elab.Term.Quotation.ArrayStxBuilder.build, List.nil]]
[Std.RBTree.toArray,[Std.RBTree.fold, Array.push, List.toArray, List.nil]]
[Lean.Parser.Term.strictImplicitBinder,[Lean.Parser.ppGroup, Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.strictImplicitLeftBracket, Lean.Parser.many1, Lean.Parser.Term.binderIdent, Lean.Parser.Term.binderType, Lean.Parser.Term.strictImplicitRightBracket]]
[Set.union,[setOf, Or, Mem.mem]]
[Lean.Meta.RecursorInfo.univLevelPos,[]]
[Lean.JsonRpc.instBEqRequestID,[BEq.mk, Lean.JsonRpc.RequestID.str, Lean.JsonRpc.RequestID.num, Lean.JsonRpc.RequestID.null, Unit.unit, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.MetavarContext.LevelMVarToParam.Context.paramNamePrefix,[]]
[Lean.Elab.Tactic.evalSplit,[ite, Eq, Lean.Syntax.isNone, Lean.Syntax.getOp, OfNat.ofNat, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.Compiler.atMostOnce.seq,[Lean.Compiler.atMostOnce.AtMostOnceData.mk, Bool.true, Lean.Compiler.atMostOnce.AtMostOnceData, Bool.false]]
[System.FilePath.normalize,[ite, Eq, and, BEq.beq, List.length, System.FilePath.pathSeparators, OfNat.ofNat, not, Bool.true, System.FilePath.mk, String.map, List.contains, System.FilePath.pathSeparator, Char.toLower, System.FilePath.toString]]
[Lean.Meta.DiscrTree.insertCore,[ite, Eq, Array.isEmpty, Bool.true, panicWithPosWithDecl, OfNat.ofNat, Unit.unit, Lean.Meta.DiscrTree, Std.PersistentHashMap.find?, Lean.Meta.DiscrTree.root, Lean.Meta.DiscrTree.mk, Std.PersistentHashMap.insert]]
[Lean.Elab.Term.MVarErrorInfo.mvarId,[]]
[Lean.Syntax.expandInterpolatedStrChunks,[Bind.bind, ForIn.forIn, MProd.mk, Unit.unit, Lean.MacroM, ForInStep, MProd, Nat, Lean.Syntax, Lean.Syntax.isInterpolatedStrLit?, Lean.Syntax.mkStrLit, Lean.SourceInfo.none, Pure.pure]]
[Lean.Meta.instInhabitedInstances,[Inhabited.mk, Lean.Meta.Instances.mk, arbitrary]]
[Quotient.lift₂.proof_2,[Quotient.ind, Setoid.refl]]
[Lean.Parser.many1Unbox,[Lean.Parser.withResultOf, Lean.Parser.many1NoAntiquot, ite, Eq, BEq.beq, Lean.Syntax.getNumArgs, OfNat.ofNat, Bool.true, Lean.Syntax.getArg]]
[Lean.Parser.FirstTokens.tokens.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.FirstTokens.tokens, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.MutualClosure.FixPoint.M,[ReaderT, List, Lean.FVarId, StateM, Lean.Elab.Term.MutualClosure.FixPoint.State]]
[Lean.Parser.Tactic.discharger,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Lean.Meta.Closure.State.nextLevelIdx,[]]
[EStateM.run',[Option, EStateM.run, Option.some, Option.none]]
[Equiv.trans,[Equiv.mk, Function.comp, Equiv.toFun, Equiv.symm, Equiv.trans.proof_1, Equiv.trans.proof_2]]
[StateT.lift,[Bind.bind, Pure.pure, Prod.mk]]
[Lean.Level.zero.injEq,[Eq.propIntro, Eq.refl, Lean.Level.zero, Eq.symm, eq_of_heq, HEq.refl]]
[AndOp.and,[]]
[Lean.Lsp.DiagnosticWith.source?,[]]
[Nat.succ_sub_succ,[Nat.succ_sub_succ_eq_sub]]
[Lean.Server.FileWorker.AsyncElabM,[ExceptT, Lean.Server.FileWorker.ElabTaskError, ReaderT, Lean.Server.FileWorker.WorkerContext, IO]]
[IO.FS.Stream.readJson,[Bind.bind, IO.FS.Stream.read, USize.ofNat, IO.ofExcept, Lean.Json.parse]]
[Lean.Parser.Command.mutual,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.ppLine, Lean.Parser.notSymbol, Lean.Parser.commandParser, Lean.Parser.ppDedent, Lean.Parser.Command.terminationSuffix]]
[Lean.Meta.SimpLemma.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SimpLemma.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.DiscrTree.instHashableKey,[Hashable.mk, Lean.Meta.DiscrTree.Key.hash]]
[Lean.ProjectionFunctionInfo.i,[]]
[Fin.checkedSub,[Option, Fin, Fin.underflowingSub, Option.none, Option.some]]
[Lean.PrettyPrinter.Delaborator.addTermInfo.mkTermInfo,[Bind.bind, Lean.MonadLCtx.getLCtx, Pure.pure, Lean.Elab.Info.ofTermInfo, Lean.Elab.TermInfo.mk, Lean.Elab.ElabInfo.mk, Lean.Name.mkStr, Lean.Name.anonymous, Option.none]]
[ulift.up.injEq,[Eq.propIntro, Eq.refl, ulift.up, Eq.symm, eq_of_heq, HEq.refl]]
[WellFounded.fixFEq.proof_1,[rfl]]
[Lean.MessageLog.append,[Lean.MessageLog.mk, HAppend.hAppend, Lean.MessageLog.msgs]]
[Lean.Parser.sepBy.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.sepByNoAntiquot.parenthesizer, Lean.Parser.sepByElemParser.parenthesizer]]
[opt_param_eq,[optParam_eq]]
[Function.surjective.forall₂,[Iff.trans, Function.surjective.forall, forall_congr']]
[Lean.Meta.SynthInstance.State.result?,[]]
[Lean.Elab.TermInfo.toElabInfo,[]]
[Lean.Lsp.Trace.off.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[IO.AccessRight.read,[]]
[Lean.Meta.ReduceMatcherResult.reduced.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[USize.add_def,[rfl]]
[Thunk.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Nat.mul_mod_left,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HMul.hMul, OfNat.ofNat, Nat.mul_comm, Nat.mul_mod_right, rfl]]
[or_congr_left,[or_congr, Iff.rfl]]
[Nat.lt_of_add_lt_add_left,[Nat.lt_of_le_of_ne, Nat.le_of_add_le_add_left, Nat.le_of_lt, Nat.lt_irrefl, HAdd.hAdd, Eq.mp, Eq.refl, LT.lt]]
[Lean.Server.FileWorker.RefIdent.const.inj,[]]
[Lean.Parser.Command.openRenamingItem,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.unicodeSymbol, Lean.Parser.checkColGt]]
[Lean.Xml.Parser.elementPrefix,[Bind.bind, Lean.Parsec.skipChar, Char.ofNat, Lean.Xml.Parser.Name, Lean.Parsec.many, SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Xml.Parser.Attribute, optional, Pure.pure, Unit.unit, Lean.Xml.Element.Element, Std.RBMap.fromList, Array.toList, Ord.compare]]
[Lean.IR.mkDecl,[Lean.IR.Decl.fdecl, Lean.IR.DeclInfo.mk]]
[Lean.AttributeKind.scoped.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Std.PersistentHashSet.find?,[Unit.unit, Option, Std.PersistentHashMap.findEntry?, Std.PersistentHashSet.set, Option.some, Option.none]]
[FloatArray.get!,[Float, Array.get!]]
[Lean.Meta.Match.withGoalOf,[Lean.Meta.withMVarContext, Lean.Meta.Match.Problem.mvarId]]
[Lean.Elab.Command.withScope,[Bind.bind, MonadState.get, Unit.unit, Lean.Elab.Command.CommandElabM, Lean.Elab.Command.State.scopes, tryFinally, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, List.cons, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState]]
[Nat.le_lt_antisymm,[Nat.lt_irrefl, Nat.lt_of_le_of_lt]]
[Array.data,[]]
[Nat.div_le_of_le_mul,[LE.le, HDiv.hDiv, of_eq_true, Eq.trans, congrFun, congrArg, Nat.div_zero, eq_true, Nat.zero_le]]
[Lean.Macro.Context.maxRecDepth,[]]
[Lean.Parser.Term.letRecDecl.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.docComment.parenthesizer, Lean.Parser.Term.attributes.parenthesizer, Lean.Parser.Term.letDecl.parenthesizer]]
[Lean.JsonRpc.instOrdRequestID,[Ord.mk, Lean.JsonRpc.RequestID.num, Lean.JsonRpc.RequestID.null, Unit.unit, Ordering, Ord.compare, Ordering.lt, Ordering.gt, Ordering.eq]]
[Lean.Meta.InstanceEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.InstanceEntry.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.ApplyNewGoals.noConfusion,[noConfusionEnum, Lean.Meta.ApplyNewGoals.toCtorIdx]]
[Lean.DefinitionSafety.unsafe.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Core.instMonadRefCoreM,[Lean.MonadRef.mk, Bind.bind, MonadReader.read, Pure.pure, Lean.Core.Context.ref, MonadWithReader.withReader, Lean.Core.Context.mk, Lean.Core.Context.options, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats]]
[instNumericFin,[Numeric.mk, Fin.ofNat', Fin.size_positive']]
[Lean.registerBuiltinAttribute,[Bind.bind, ST.Ref.get, Lean.attributeMapRef, ite, Eq, Std.PersistentHashMap.contains, Lean.AttributeImplCore.name, Lean.AttributeImpl.toAttributeImplCore, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Pure.pure, PUnit.unit]]
[List.instEmptyCollectionList,[EmptyCollection.mk, List.nil]]
[UInt64.instSemiringUInt64.proof_5,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, congrFun, HMul.hMul, UInt64.zero_def, UInt64.mul_def, UInt64.mk, OfNat.ofNat, MonoidWithZero.zero_mul, UInt64.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt64]]
[Std.HashSet.isEmpty,[Decidable.decide, Eq, Std.HashSet.size, OfNat.ofNat]]
[Array.foldrMUnsafe,[ite, LE.le, Array.size, LT.lt, USize.ofNat, Pure.pure, Array.foldrMUnsafe.fold]]
[Lean.Server.FileWorker.handlePlainGoal,[Bind.bind, Lean.Server.FileWorker.getInteractiveGoals, Pure.pure, Task.map, Except.map, Option.map, Lean.Lsp.PlainGoal, ite, Eq, Array.isEmpty, Bool.true, Lean.Lsp.PlainGoal.mk, List.toArray, List.nil, Task.Priority.default]]
[Lean.Elab.Term.TermElabM.run',[Functor.map, Prod.fst, Lean.Elab.Term.TermElabM.run]]
[Lean.Elab.Command.mkDefView,[ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Lean.Elab.Command.mkDefViewOfAbbrev, Lean.Elab.Command.mkDefViewOfDef, Lean.Elab.Command.mkDefViewOfTheorem, Lean.Elab.Command.mkDefViewOfConstant, Lean.Elab.Command.mkDefViewOfInstance, Lean.Elab.Command.mkDefViewOfExample, Lean.throwError, Lean.ToMessageData.toMessageData]]
[neg_add_self,[add_left_neg]]
[Lean.Meta.SizeOfSpecNested.Context.localInsts,[]]
[Lean.Exception.noConfusionType,[]]
[Lean.Server.FileWorker.PendingRequestMap,[Std.RBMap, Lean.JsonRpc.RequestID, Task, Except, IO.Error, Unit, Ord.compare]]
[Lean.IR.Index,[Nat]]
[Array.get,[List.get, Array.data, Fin.val, Array.get.proof_1]]
[Lean.Meta.instReprCongrLemmas,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.Meta.CongrLemmas.lemmas]]
[Lean.Parser.sepBy1Info,[Lean.Parser.ParserInfo.mk, Function.comp, Lean.Parser.ParserInfo.collectTokens, Lean.Parser.ParserInfo.collectKinds, Lean.Parser.ParserInfo.firstTokens]]
[Lean.Elab.GoalsAtResult.tacticInfo,[]]
[Lean.LocalContext.findDeclRev?,[Id.run, Lean.LocalContext.findDeclRevM?]]
[Fin.eq_of_val_eq,[Eq.symm, eq_of_heq, Eq.refl, Fin.val, Fin.mk, HEq.refl, Eq, rfl]]
[Lean.PrettyPrinter.Parenthesizer.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Parenthesizer.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[ReaderT.run_read,[rfl]]
[Lean.SSet.toList,[Lean.SSet.fold, List.cons, List.nil]]
[Lean.Meta.Closure.ToProcessElement.noConfusionType,[]]
[Nat.add_mod_left,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, Nat.add_comm, Nat.add_mod_right, rfl]]
[MonadStateOf.get,[]]
[Prod.rprod.proof_1,[Subrelation.wf, WellFoundedRelation.wf, Prod.lex, Prod.RProdSubLex]]
[Lean.Rat.instMulRat,[Mul.mk, Lean.Rat.mul]]
[Lean.Meta.foldPatValue,[Option.none, Lean.Expr, Lean.Meta.isUIntPatLit?, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, List.nil]]
[Nat.prod_dvd_and_dvd_of_dvd_prod.proof_4,[Eq.symm]]
[Lean.Elab.Structural.preprocess,[Lean.Core.transform, Pure.pure, Lean.TransformStep.visit, ite, Eq, Lean.Expr.isHeadBetaTarget, Bool.true, Option.isSome, Lean.Expr.find?, Lean.Expr.isConstOf, Lean.Expr.getAppFn, Bool.false, Lean.Expr.headBeta, Lean.TransformStep.done]]
[Lean.PrettyPrinter.Parenthesizer.suppressInsideQuot.parenthesizer,[]]
[Lean.Compiler.foldUIntMod,[Lean.Compiler.foldBinUInt, Mod.mod]]
[UInt64.instSemiringUInt64.proof_9,[rfl]]
[Lean.IR.NormalizeIds.withJP,[Bind.bind, getModify, HAdd.hAdd, OfNat.ofNat, Lean.IR.JoinPointId.mk, Std.RBMap.insert, Lean.IR.JoinPointId.idx]]
[List.instMemList,[Mem.mk, List.mem]]
[Lean.Elab.TacticInfo.toElabInfo,[]]
[Lean.Elab.Term.getMessageLog,[Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Term.State.messages]]
[Lean.Meta.checkAssignment,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, Lean.Meta.inferType, Lean.Meta.occursCheck, ite, Eq, Bool.true, Pure.pure, ForInStep.yield, ForInStep.done, Option.some, Unit.unit, Lean.Meta.MetaM, Option, Lean.Expr, MProd.fst]]
[Function.extend,[dite, Exists, Eq, Classical.choose]]
[False.elim,[]]
[decide_eq_true,[Eq, Decidable.decide, Bool.true, rfl, absurd]]
[Lean.JsonRpc.instBEqErrorCode,[BEq.mk, BEq.beq, Lean.JsonRpc.ErrorCode.toCtorIdx]]
[Lean.Lsp.DefinitionParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DefinitionParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.isClosedTermName,[Lean.NameSet.contains, Lean.ClosedTermCache.constNames, Lean.EnvExtension.getState, Lean.closedTermCacheExt]]
[instMonadExcept,[MonadExcept.mk, throwThe, tryCatchThe]]
[Std.Format.group.inj,[And.intro]]
[Lean.Parser.Tactic.tacticAdmit,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[CommRing.mul_comm,[]]
[Lean.Elab.addDeclarationRanges,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Unit.unit, Bind.bind, Lean.Elab.getDeclarationRange, Lean.Elab.getDeclarationSelectionRef, Lean.addDeclarationRanges, Lean.DeclarationRanges.mk]]
[Lean.Meta.Match.Problem.mk.inj,[And.intro]]
[Lean.Declaration.forExprM,[Lean.Declaration.foldExprM, Unit.unit]]
[Lean.EnumAttributes.attrs,[]]
[Lean.Parser.strLit,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.strLitKind, Bool.true, Lean.Parser.strLitNoAntiquot]]
[Lean.JsonRpc.instToStringRequestID,[ToString.mk, Unit.unit, String, ToString.toString]]
[Lean.Elab.TermInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.elabTrailingParserMacro,[Lean.Elab.Term.adaptExpander, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Meta.ppGoal,[Bind.bind, Lean.MonadMCtx.getMCtx, Unit.unit, Lean.Meta.MetaM, Std.Format, Lean.MetavarContext.findDecl?, Pure.pure, Std.Format.text, Lean.MonadOptions.getOptions, Lean.Meta.withLCtx, Lean.MetavarDecl.localInstances, Lean.Meta.ToHide.collect, Lean.MetavarDecl.type, Lean.LocalContext.foldlM, Prod, List, Lean.Name, Option, Lean.Expr, ite, Eq, or, and, not, Lean.LocalDecl.isAuxDecl, Std.RBTree.contains, Lean.LocalDecl.fvarId, Bool.true, Prod.mk, List.nil, Option.none, Std.Format.nil, OfNat.ofNat, Lean.Meta.instantiateMVars, Lean.Meta.ppExpr, Lean.Name.str, Lean.Name.num, Lean.MetavarDecl.userName, HAppend.hAppend, Std.ToFormat.format, Lean.Name.eraseMacroScopes, Std.Format.line, Lean.Meta.ppGoal.ppVars, Lean.Meta.ppGoal.pushPending]]
[Lean.KVMap.get,[Option.getD, Lean.KVMap.get?]]
[Lean.Expr.setAppPPExplicitForExposingMVars,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.setPPExplicit, Lean.mkAppN, Bool.true]]
[StateT.run'_eq,[rfl]]
[Lean.KeyedDeclsAttribute.OLeanEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KeyedDeclsAttribute.OLeanEntry.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.bracketedExplicitBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.binderIdent, Lean.ParserDescr.cat, OfNat.ofNat]]
[Lean.Meta.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.KernelException.invalidProj.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.invalidProj, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.instDecidableLt,[inferInstanceAs, Decidable, Eq, Lean.Literal.lt, Bool.true]]
[Lean.PrefixTree.insert,[Subtype.mk, Lean.PrefixTreeNode.insert, Subtype.val, Lean.PrefixTree.insert.proof_1]]
[OptionT.instMonadExceptOfUnitOptionT,[MonadExceptOf.mk, OptionT.fail, OptionT.tryCatch]]
[seq_eq_bind_map,[Eq.mpr, Eq.refl, Eq, Seq.seq, Bind.bind, Functor.map, Eq.symm, LawfulMonad.bind_map, rfl]]
[StateCpsT.runK_bind_modify,[rfl]]
[Prod.swap_swap,[Eq, Prod.swap, rfl]]
[Lean.Elab.elabModifiers,[Unit.unit, Lean.Elab.Modifiers, Lean.Syntax.getOptional?, Bind.bind, Pure.pure, Option.none, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Lean.Syntax.getOp, OfNat.ofNat, Option.some, String.extract, HSub.hSub, String.bsize, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.ofSyntax]]
[Acc.inv,[Acc.inv.proof_1]]
[Lean.PrettyPrinter.Formatter.ite,[ite]]
[Decidable.by_contradiction,[Decidable.byContradiction]]
[Lean.Parser.Term.set_option,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.ppSpace, Lean.Parser.Command.optionValue, Lean.Parser.termParser, OfNat.ofNat]]
[Lean.Parser.ParserState.mkUnexpectedErrorAt,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Array.push, Lean.Syntax.missing, Option.some, Lean.Parser.Error.mk]]
[StateCpsT.run'_eq,[rfl]]
[UInt8.land,[UInt8.mk, Fin.land, UInt8.val]]
[Lean.Meta.CaseValueSubgoal.newH,[]]
[and_congr_right,[Iff.intro, And, And.intro, Iff.mp, Iff.mpr]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.AppMatchState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.instInhabitedLocalDecl,[Inhabited.mk, Lean.LocalDecl.cdecl, arbitrary]]
[Std.RBNode.find,[Option, Option.none, Unit.unit, PProd.fst, PProd.snd, Option.some]]
[Lean.Lsp.MarkupContent.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.MarkupContent.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.GeneralizeTelescope.Entry.noConfusionType,[]]
[IO.Error.alreadyExists.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.alreadyExists, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.EmitC.emitDecl,[MonadExcept.tryCatch, Lean.IR.EmitC.emitDeclAux, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Lean.Elab.Term.LValResolution.projFn.inj,[And.intro]]
[Set.univ,[setOf, True]]
[Nat.add_left_comm,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Eq.symm, Nat.add_assoc, Nat.add_comm, rfl]]
[Lean.Parser.Term.let.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.letDecl.parenthesizer, Lean.Parser.Term.optSemicolon.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Lean.Parser.identFnAux,[Lean.Parser.identFnAux.parse]]
[Lean.LocalContext.getFVarIds,[Std.PersistentArray.foldl, Lean.LocalContext.decls, Unit.unit, Array, Lean.FVarId, Array.push, Lean.LocalDecl.fvarId, List.toArray, List.nil, OfNat.ofNat]]
[Lean.Elab.instInhabitedContextInfo,[Inhabited.mk, Lean.Elab.ContextInfo.mk, arbitrary]]
[Lean.Meta.byCases,[Bind.bind, Lean.Meta.assert, Lean.Name.mkStr, Lean.Name.anonymous, Lean.mkOr, Lean.mkNot, Lean.mkEM, Lean.Meta.intro1, Lean.Meta.MetaM, Prod, Lean.Meta.ByCasesSubgoal, Lean.Meta.cases, List.toArray, List.cons, Lean.Meta.AltVarNames.mk, List.nil, dite, Eq, Array.size, Array.getLit, Eq.symm, of_decide_eq_true, id, Eq.refl, Bool.true, Array.toArrayLit_eq, Pure.pure, Prod.mk, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Meta.byCases.toByCasesSubgoal]]
[Nat.succ_le_succ,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, LE.le, Nat.succ, Nat.le.refl, Nat.le.step, PProd.fst]]
[Lean.Elab.Term.StructInst.FieldVal.term.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.StructInst.FieldVal.term, Eq.symm, eq_of_heq, HEq.refl]]
[List.toPersistentArrayAux,[Std.PersistentArray, PProd.fst, Std.PersistentArray.push]]
[instAddCommGroup.proof_2,[Semiring.zero_add]]
[Nat.pow,[Unit.unit, Nat, OfNat.ofNat, Nat.mul, PProd.fst]]
[Tactic.Ring.HornerExpr.instCoeHornerExprExpr,[Coe.mk, Tactic.Ring.HornerExpr.e]]
[Lean.Elab.Command.expandNotationItemIntoPattern,[ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Lean.Syntax.mkAntiquotNode, Lean.Syntax.getOp, OfNat.ofNat, Option.none, Lean.strLitKind, Lean.Elab.Command.strLitToPattern, Lean.Macro.throwUnsupported]]
[Lean.Parser.Term.doBreak.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.IR.ExplicitBoxing.withJDecl,[MonadWithReader.withReader, Lean.IR.ExplicitBoxing.BoxingContext.mk, Lean.IR.ExplicitBoxing.BoxingContext.f, Lean.IR.LocalContext.addJP, Lean.IR.ExplicitBoxing.BoxingContext.localCtx, Lean.IR.ExplicitBoxing.BoxingContext.resultType, Lean.IR.ExplicitBoxing.BoxingContext.decls, Lean.IR.ExplicitBoxing.BoxingContext.env]]
[Lean.Lsp.PublishDiagnosticsParams.version?,[]]
[Lean.Parser.checkLhsPrec,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.checkLhsPrecFn]]
[Lean.cacheClosedTermName,[Lean.EnvExtension.modifyState, Lean.closedTermCacheExt, Lean.ClosedTermCache.mk, Std.PersistentHashMap.insert, Lean.ClosedTermCache.map, Lean.NameSet.insert, Lean.ClosedTermCache.constNames]]
[IO.Error.unsatisfiedConstraints.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.unsatisfiedConstraints, Eq.symm, eq_of_heq, HEq.refl]]
[FloatArray.foldlM.loop,[dite, LT.lt, Unit.unit, Pure.pure, Bind.bind, FloatArray.get, Fin.mk, FloatArray.foldlM.loop.proof_1, PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[HAppend.noConfusionType,[]]
[Lean.Parser.Tactic.simpResult,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.parser]]
[Lean.Lsp.PublishDiagnosticsParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.BinderView.mk.inj,[And.intro]]
[Lean.IR.Borrow.ownArgs,[Array.forM, Lean.IR.Borrow.ownArg, OfNat.ofNat, Array.size]]
[Lean.Parser.Tactic.rcasesPatMed,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.sepBy1, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.symbol, Bool.false]]
[Quotient.exact,[Quot.inductionOn, Setoid.refl]]
[Lean.Elab.instBEqDefKind,[BEq.mk, BEq.beq, Lean.Elab.DefKind.toCtorIdx]]
[Lean.Parser.withAntiquotFn,[ite, Eq, Lean.Parser.tryAnti, Bool.true, Lean.Parser.orelseFn]]
[Lean.Parser.Tactic.unknown.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.PrettyPrinter.Formatter.errorAtSavedPos.formatter]]
[Lean.Meta.mkFreshExprMVar,[Unit.unit, Lean.Meta.MetaM, Lean.Expr, Bind.bind, Lean.MonadLCtx.getLCtx, Lean.Meta.getLocalInstances, Lean.Meta.mkFreshExprMVarAt, OfNat.ofNat, Lean.Meta.mkFreshLevelMVar, Lean.mkSort, Lean.MetavarKind.natural, Lean.Name.anonymous]]
[Std.ToFormat.noConfusionType,[]]
[Std.RBMap.forIn,[Std.RBNode.forIn, Subtype.val, Prod.mk]]
[Lean.Expr.getAppFnArgs,[Lean.Expr.withApp, Prod.mk, Lean.Expr.constName]]
[Decidable.or_iff_not_and_not,[Eq.mpr, Eq.refl, Iff, Or, Not, And, Eq.symm, propext, not_or_distrib, Decidable.not_not, Iff.rfl]]
[Lean.Meta.AssertAfterResult.subst,[]]
[Lean.PrettyPrinter.Delaborator.reifyName,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Name.anonymous, Lean.Name.str, dite, Eq, Eq.symm, Lean.Name.num, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.natVal, Lean.Expr.mdata, Lean.Expr.proj, Lean.Literal.strVal, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Name, Pure.pure, Bind.bind, PProd.fst, PProd.snd, Lean.Name.mkStr, Lean.Name.mkNum, Alternative.failure]]
[Lean.PrettyPrinter.Formatter.notFollowedByCategoryToken.formatter,[Pure.pure, Unit.unit]]
[Char.isLower,[and, Decidable.decide, GE.ge, Char.val, OfNat.ofNat, LE.le]]
[Lean.Meta.AuxLemmas.noConfusionType,[]]
[EStateM.Result.error.inj,[And.intro]]
[Tactic.Ring.subst_into_add,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, rfl]]
[Lean.isIOUnitRegularInitFn,[Lean.isIOUnitInitFnCore, Lean.regularInitAttr]]
[Lean.Parser.Term.type,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.checkWsBefore, Lean.Parser.checkPrec, Lean.Parser.leadPrec, Lean.Parser.checkColGt, Lean.Parser.levelParser, Lean.Parser.maxPrec]]
[Lean.Meta.IndPredBelow.proveBrecOn.intros,[Bind.bind, Lean.Meta.introNP, Lean.InductiveVal.numParams, Lean.Meta.MetaM, Prod, Lean.MVarId, Lean.Meta.IndPredBelow.BrecOnVariables, Array.size, Lean.Meta.IndPredBelow.Context.motives, Lean.InductiveVal.numIndices, Lean.Meta.intro1P, Pure.pure, Prod.mk, Lean.Meta.IndPredBelow.BrecOnVariables.mk]]
[Lean.Parser.indexed,[Prod, Lean.Parser.ParserState, List, Lean.Syntax.missing, Lean.Name.mkSimple, Unit.unit, Lean.identKind, Std.RBMap.find?, Prod.mk, Option.none, HAppend.hAppend, List.nil]]
[Nat.find_x.proof_2,[Or.elim, lt_or_eq_of_le, Eq.mpr, Eq.refl, Not]]
[USize.le,[LE.le, USize.val]]
[Lean.Meta.InjectionResult.noConfusionType,[]]
[Lean.addAndCompile,[Bind.bind, Lean.addDecl, Lean.compileDecl]]
[Lean.Position.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Position.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Mathlib.Eval.evalExpr,[Lean.withoutModifyingEnv, Bind.bind, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.inferType, Lean.Meta.isDefEq, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.Elab.instInhabitedTermInfo,[Inhabited.mk, Lean.Elab.TermInfo.mk, arbitrary]]
[String.posOf,[String.posOfAux, String.bsize, OfNat.ofNat]]
[StateCpsT.run,[StateCpsT.runK, Pure.pure, Prod.mk]]
[Lean.mkNoConfusionEnum.mkNoConfusionType,[Lean.Meta.withLocalDeclD, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.Meta.mkForallFVars, List.toArray, List.cons, List.nil, Bool.false, Bool.true, Lean.Meta.mkAppM, Lean.Meta.mkLambdaFVars, Lean.addAndCompile, Lean.Declaration.defnDecl, Lean.DefinitionVal.mk, Lean.ConstantVal.mk, Lean.ReducibilityHints.abbrev, Lean.DefinitionSafety.safe]]
[Lean.Syntax.instBEqSyntax,[BEq.mk, Lean.Syntax.structEq]]
[Lean.ExternAttrData.arity?,[]]
[Std.HashMapBucket.update.proof_1,[Eq.mpr, Eq.refl, GT.gt, Array.size, Array.uset, Subtype.val, OfNat.ofNat, Array.size_set, Fin.mk, USize.toNat, Subtype.property]]
[Lean.Widget.exprToInteractive,[Bind.bind, Lean.Widget.formatInfos, Lean.Meta.MetaM, Lean.Widget.CodeWithInfos, Lean.MonadEnv.getEnv, Lean.MonadMCtx.getMCtx, Lean.MonadOptions.getOptions, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, Pure.pure, Lean.Widget.tagExprInfos]]
[Nat.sub_sub,[Eq, HSub.hSub, HAdd.hAdd, Eq.mpr, Eq.refl, OfNat.ofNat, Nat.add_zero, Nat.sub_zero, rfl, Nat.succ, Nat.add_succ, Nat.sub_succ, Nat.pred, PProd.fst]]
[Array.isPrefixOf,[dite, LE.le, Array.size, Array.isPrefixOfAux, OfNat.ofNat, Bool.false]]
[instOfNatFloat,[OfNat.mk, Float.ofNat]]
[ST.Prim.Ref.modify,[Bind.bind, ST.Prim.Ref.get, ST.Prim.Ref.set]]
[Mathlib.Tactic.Conv.traceLHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Lsp.instToJsonTextDocumentSyncKind,[Lean.ToJson.mk, Unit.unit, Lean.Json, OfNat.ofNat]]
[Int.subNatNat_add_add,[Int.subNatNat_elim, Eq, Int.subNatNat, HAdd.hAdd, Eq.mpr, Eq.refl, Int.ofNat, Nat.add_assoc, Nat.add_comm, Eq.symm, Int.subNatNat_add_left, OfNat.ofNat, Int.negSucc, Int.subNatNat_add_right]]
[Std.Range.«term[_:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Core.instMonadTraceCoreM,[Lean.MonadTrace.mk, modify, Lean.Core.State.mk, Lean.Core.State.env, Lean.Core.State.nextMacroScope, Lean.Core.State.ngen, Lean.Core.State.traceState, Bind.bind, MonadState.get, Pure.pure]]
[instCommRingFin,[CommRing.mk, instCommRingFin.proof_1]]
[MonadFunctor.noConfusionType,[]]
[Nat.sub_lt_self,[Nat.sub_lt, Nat.lt_of_lt_of_le]]
[Lean.mkCIdentFrom,[Lean.Syntax.ident, Lean.SourceInfo.fromRef, String.toSubstring, ToString.toString, List.cons, Prod.mk, List.nil]]
[Lean.IR.log,[modify, Lean.IR.CompilerState.mk, Lean.IR.CompilerState.env, Array.push, Lean.IR.CompilerState.log]]
[Lean.Meta.CongrLemmas.get,[Unit.unit, List, Lean.Meta.CongrLemma, Lean.SMap.find?, Lean.Meta.CongrLemmas.lemmas, List.nil]]
[Lean.Elab.Info.pos?,[Lean.Syntax.getPos?, Lean.Elab.Info.stx, Bool.true]]
[Lean.Elab.instMonadMacroAdapter,[Lean.Elab.MonadMacroAdapter.mk, liftM, Lean.Elab.MonadMacroAdapter.getCurrMacroScope, Lean.Elab.MonadMacroAdapter.getNextMacroScope, Lean.Elab.MonadMacroAdapter.setNextMacroScope]]
[Lean.Parser.Term.optExprPrecedence.formatter,[Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec]]
[Lean.Elab.Term.Do.isDoExpr?,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Option.some, Lean.Syntax.getOp, OfNat.ofNat, Option.none]]
[Lean.Parser.Tactic.rcasesPat.tuple,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.rcasesPatLo, Bool.false]]
[Nat.div_le_self,[LE.le, HDiv.hDiv, Eq.mpr, congrFun, congrArg, Nat.div_zero, Nat.zero_le, Nat.div_le_of_le_mul]]
[nonempty_of_exists,[Nonempty, Nonempty.intro]]
[Lean.Expr.ReplaceImpl.replaceUnsafeM.visit,[Bind.bind, MonadState.get, ite, Eq, BEq.beq, ptrAddrUnsafe, Array.uget, Lean.Expr.ReplaceImpl.State.keys, lcProof, Bool.true, Pure.pure, Lean.Expr.ReplaceImpl.State.results, Unit.unit, Lean.Expr.ReplaceImpl.ReplaceM, Lean.Expr, Lean.Expr.ReplaceImpl.cache, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lit, Lean.Expr.ReplaceImpl.replaceUnsafeM.visit, Lean.Expr.updateForallE!, Lean.Expr.updateLambdaE!, Lean.Expr.updateMData!, Lean.Expr.updateLet!, Lean.Expr.updateApp!, Lean.Expr.updateProj!]]
[Lean.Elab.Term.Do.mkFreshJP',[Lean.Elab.Term.Do.mkFreshJP, Array.map, Prod.mk, Bool.true]]
[DoResultPR.return.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Simp.Context.config,[]]
[Lean.Elab.Term.Do.hasExitPoint,[Lean.Elab.Term.Do.hasExitPointPred, Bool.true]]
[Nat.lt_eq,[rfl]]
[Lean.Parser.Term.funSimpleBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.lookahead.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.simpleBinder.parenthesizer]]
[Array.get!,[Array.getD, arbitrary]]
[Lean.matchConstInduct,[Lean.matchConst, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Unit.unit]]
[Sum.inr.injEq,[Eq.propIntro, Eq.refl, Sum.inr, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Simp.instMonadBacktrackSavedStateSimpM,[Lean.MonadBacktrack.mk, liftM, Lean.Meta.saveState, Lean.Meta.SavedState.restore]]
[Lean.Literal.natVal.inj,[]]
[Lean.Parser.Term.doFor.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.Term.doForDecl.formatter, Bool.false, Lean.Parser.Term.doSeq.formatter]]
[Lean.Meta.ParamInfo.isExplicit,[or, BEq.beq, Lean.Meta.ParamInfo.binderInfo, Lean.BinderInfo.default, Lean.BinderInfo.auxDecl]]
[Lean.instReprStructureFieldInfo,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.StructureFieldInfo.fieldName, Std.Format.line, Lean.StructureFieldInfo.projFn, Lean.StructureFieldInfo.subobject?, Lean.StructureFieldInfo.binderInfo, Lean.StructureFieldInfo.inferMod]]
[instXorUInt8,[Xor.mk, UInt8.xor]]
[Lean.Parser.Term.generalizingParam.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.trueVal.formatter, Lean.Parser.Term.falseVal.formatter]]
[Lean.Widget.instFromJsonTaggedText,[Lean.FromJson.mk]]
[Lean.Parser.Term.doSeqIndent,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.many1Indent, Lean.Parser.Term.doSeqItem]]
[Lean.Parser.Command.constant,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.declId, Lean.Parser.Command.declSig, Lean.Parser.optional, Lean.Parser.Command.declValSimple]]
[ExceptCpsT.runK,[]]
[List.length_repeat,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.length_nil, Nat.zero_eq, eq_true_of_decide, Eq.refl, Bool.true, Eq.mpr, congrFun, List.length_cons, List.repeat, Nat.succ, Nat.succ.injEq, List.length]]
[Lean.mkLit,[Lean.Expr.lit, Lean.Expr.mkData, mixHash, OfNat.ofNat, Hashable.hash, Bool.false]]
[Lean.Expr.isBVar,[Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[Tactic.Ring.HornerExpr.ibelow,[True, And]]
[Lean.Elab.Command.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.getMaxHeight,[Lean.Expr.foldConsts, OfNat.ofNat, Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, UInt32, Lean.Environment.find?, Lean.ReducibilityHints.opaque, Lean.ReducibilityHints.abbrev, Lean.DefinitionVal.hints, ite, GT.gt]]
[Lean.Parser.addToken,[Bind.bind, Lean.MonadEnv.getEnv, Functor.discard, Lean.ofExcept, ite, Eq, BEq.beq, Bool.true, MonadExcept.throw, Unit.unit, Except, String, Lean.Parser.TokenTable, Lean.Parser.Trie.find?, Pure.pure, Lean.Parser.Trie.insert, Lean.Parser.ParserExtension.State.tokens, Lean.ScopedEnvExtension.getState, Lean.Parser.parserExtension, Lean.ScopedEnvExtension.add, Lean.Parser.ParserExtension.Entry.token]]
[Nat.mul_lt_mul',[Nat.lt_of_le_of_lt, Nat.mul_le_mul_of_nonneg_right, Nat.mul_lt_mul_of_pos_left]]
[Lean.Parser.Tactic.abstract,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[Lean.PrettyPrinter.Delaborator.unexpandCoe,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPCoercions, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Pure.pure, Lean.PrettyPrinter.Delaborator.isCoe, ite, Eq, not, Bool.true, Alternative.failure, PUnit.unit]]
[Lean.Parser.Command.open,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.withPosition, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.openDecl]]
[WellFounded.recursion,[WellFounded.apply]]
[List.head_eq_of_cons_eq,[]]
[Lean.instFromJsonNat,[Lean.FromJson.mk, Lean.Json.getNat?]]
[Std.AssocList.noConfusionType,[]]
[Std.HashMapImp.reinsertAux.proof_1,[Subtype.property]]
[Lean.Parser.Command.terminationSuffix.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.terminationBy.formatter, Lean.Parser.Command.decreasingBy.formatter]]
[Lean.Elab.Term.PatternElabException.noConfusionType,[]]
[Lean.IR.Checker.checkArg,[Lean.IR.Arg.irrelevant, Lean.IR.Checker.M, Unit, Lean.IR.Checker.checkVar, Pure.pure, Unit.unit]]
[Neg.neg,[]]
[Lean.Lsp.DocumentHighlightKind.text.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Int.subNatNat_add_right,[]]
[exists_eq,[Exists.intro, rfl]]
[Decidable.not_iff_not,[Eq.mpr, Eq.refl, Iff, Not, propext, iff_def, And, iff_def', and_congr, Decidable.not_imp_not]]
[List.Perm.swap',[]]
[Lean.Elab.Term.Do.ToTerm.Kind.nestedSBC.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Std.PersistentArray.size,[]]
[Lean.Meta.AbstractMVarsResult.paramNames,[]]
[Lean.Parser.AliasValue.binary.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.AliasValue.binary, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.LetRecToLift.shortDeclName,[]]
[Int.ofNat.inj,[]]
[Lean.Elab.Term.applyAttributes,[Bind.bind, ForIn.forIn, PUnit.unit, Lean.MonadEnv.getEnv, Lean.Elab.Term.TermElabM, ForInStep, PUnit, Lean.getAttributeImpl, Lean.Elab.Attribute.name, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Pure.pure, ForInStep.yield, Unit.unit, liftM, Lean.AttributeImpl.add, Lean.Elab.Attribute.stx, Lean.Elab.Attribute.kind, ite, Eq, BEq.beq, Lean.AttributeImplCore.applicationTime, Lean.AttributeImpl.toAttributeImplCore, Bool.true, Option.none]]
[Lean.Parser.Tactic.tacticSorry,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Nat.not_lt_of_le,[Nat.not_le_of_gt]]
[Lean.Name.instReprName,[Repr.mk, Lean.Name.reprPrec]]
[Lean.Parser.ppDedent.parenthesizer,[]]
[«term_<_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Bool.or_false,[rfl, Eq.symm, Eq.refl]]
[Lean.Elab.Structural.RecArgInfo.mk.inj,[And.intro]]
[Lean.Parser.Tactic.quotSeq.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.Tactic.seq1.parenthesizer]]
[Lean.Meta.Match.Problem.vars,[]]
[Subarray.anyM,[Array.anyM, Subarray.as, Subarray.start, Subarray.stop]]
[IO.Error.otherError.inj,[And.intro]]
[Lean.Parser.Tactic.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.tacticParser]]
[Lean.Parser.Command.noncomputableSection,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.ident]]
[Nat.sub_eq_zero_iff_le,[Iff.intro, Nat.le_of_sub_eq_zero, Nat.sub_eq_zero_of_le]]
[Lean.Elab.Term.PatternVar.localVar.inj,[]]
[Prod.ext',[Iff.mpr, Prod.ext_iff, And.intro]]
[cast_eq,[rfl]]
[Lean.Parser.Tactic.match.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.generalizingParam.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.Term.matchDiscr.formatter, Bool.false, Lean.Parser.Term.optType.formatter, Lean.Parser.Tactic.matchAlts.formatter]]
[Lean.Elab.whnfReducibleLHS?,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getMVarType', Pure.pure, Lean.Expr.eq?, Option.none, Lean.Meta.MetaM, Option, Lean.MVarId, ite, Eq, bne, Bool.true, Lean.Meta.mkEq, Lean.Meta.replaceTargetDefEq, Option.some, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing]]
[Lean.throwErrorAt,[Lean.withRef, Lean.throwError]]
[Lean.Elab.Term.Quotation.HeadCheck.shape.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Quotation.HeadCheck.shape, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.sortDeclLevelParams,[Unit.unit, Except, String, List, Lean.Name, List.find?, and, not, Array.contains, List.elem, MonadExcept.throw, HAppend.hAppend, ToString.toString, Pure.pure, Array.toList]]
[Lean.Level.PP.Result.maxNode.injEq,[Eq.propIntro, Eq.refl, Lean.Level.PP.Result.maxNode, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.generalizesArg,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat]]
[Lean.Server.FileWorker.EditableDocument.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.FileWorker.EditableDocument.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Do.ToTerm.declToTerm,[Lean.withRef, Lean.MonadQuotation.withFreshMacroScope, ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.mkNode, Lean.mkNullNode, Lean.Syntax.getKind, Unit.unit, Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax, Lean.Elab.Term.Do.isDoExpr?, MonadReader.read, Lean.Elab.Term.Do.ToTerm.Context.m, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, liftM, Lean.Macro.throwErrorAt]]
[Lean.MetavarContext.LevelMVarToParam.Context.alreadyUsedPred,[]]
[Lean.Elab.Term.Do.instInhabitedCode,[Inhabited.mk, Lean.Elab.Term.Do.Code.action, arbitrary]]
[Lean.Elab.Structural.instInhabitedM,[Inhabited.mk, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.Level.PP.Result.max,[Lean.Level.PP.Result.leaf, Lean.Level.PP.Result.num, Lean.Level.PP.Result.offset, Lean.Level.PP.Result.imaxNode, Lean.Level.PP.Result, Lean.Level.PP.Result.maxNode, List.cons, List.nil]]
[Lean.Meta.SynthInstance.TableEntry.waiters,[]]
[Lean.Meta.ByCasesSubgoal.noConfusionType,[]]
[Lean.getPPAnalyzeOmitMax,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.omitMax, Lean.Option.defValue]]
[Lean.Meta.DefaultInstanceEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.DefaultInstanceEntry.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.StructInst.instInhabitedFieldVal,[Inhabited.mk, Lean.Elab.Term.StructInst.FieldVal.term, arbitrary]]
[Lean.Name.isAnonymous,[Unit.unit, Lean.Name.str, Lean.Name.num, Bool, Bool.true, Bool.false]]
[List.mem_cons_eq,[rfl]]
[Lean.Lsp.instFromJsonLocationLink,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, Lean.Lsp.Range, Lean.Lsp.DocumentUri, Pure.pure, Lean.Lsp.LocationLink.mk]]
[Lean.Server.FileWorker.Reference.range,[]]
[Lean.Meta.injection,[Bind.bind, Lean.Meta.injectionCore, Unit.unit, Lean.Meta.MetaM, Lean.Meta.InjectionResult, Pure.pure, Lean.Meta.InjectionResult.solved, Lean.Meta.injectionIntro, Bool.true]]
[Quotient.mk,[Quot.mk, Setoid.r]]
[Function.update_eq_iff,[Iff.trans, Function.funext_iff, Function.forall_update_iff, Eq]]
[instReprBool,[Repr.mk, Std.Format, Std.Format.text]]
[Lean.PrettyPrinter.Parenthesizer.State.mk.inj,[And.intro]]
[Lean.Parser.Command.protected.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.Meta.DecLevelContext.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.DecLevelContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.LBool.toString,[Unit.unit, String]]
[Lean.Compiler.neutralExpr,[Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Lean.IR.Expr.sproj.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[«term_<*_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.ParserExtension.instInhabitedEntry,[Inhabited.mk, Lean.Parser.ParserExtension.Entry.token, arbitrary]]
[unsafeCast,[cast, unsafeCast.proof_1, PUnit]]
[Lean.Lsp.instFromJsonWorkspaceFolder,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, String, Pure.pure, Lean.Lsp.WorkspaceFolder.mk]]
[Lean.Elab.Deriving.Ord.mkMutualBlock,[Bind.bind, ForIn.forIn, Lean.Elab.Deriving.Ord.mkAuxFunction, Pure.pure, PUnit.unit, ForInStep.yield, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil]]
[Lean.Name.hasLtQuick,[LT.mk, Eq, Lean.Name.quickLt, Bool.true]]
[Std.Rbcolor.black.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[instDecidableLt_1,[UInt8.decLt]]
[Lean.PrettyPrinter.Delaborator.delabAppImplicit,[Bind.bind, Lean.PrettyPrinter.Delaborator.getParamKinds, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPExplicit, ite, Eq, Bool.true, Array.any, not, Lean.PrettyPrinter.Delaborator.ParamKind.isRegularExplicit, OfNat.ofNat, Array.size, Alternative.failure, Pure.pure, PUnit.unit]]
[Lean.LazyInitExtension.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.LazyInitExtension.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.KVMap.Value.noConfusionType,[]]
[Lean.PersistentEnvExtension.getState,[Lean.PersistentEnvExtensionState.state, Lean.EnvExtension.getState, Lean.PersistentEnvExtension.toEnvExtension]]
[Lean.KernelException.declTypeMismatch.inj,[And.intro]]
[Lean.Parser.Term.completion.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter]]
[Lean.DataValue.ofString.injEq,[Eq.propIntro, Eq.refl, Lean.DataValue.ofString, Eq.symm, eq_of_heq, HEq.refl]]
[ForIn.forIn,[]]
[Lean.PrettyPrinter.Delaborator.delabProj,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Lean.PrettyPrinter.Delaborator.SubExpr.withProj, Lean.PrettyPrinter.Delaborator.delab, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Server.FileWorker.Reference.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.State.letRecsToLift,[]]
[Lean.Syntax.isAnyAntiquot,[or, Lean.Syntax.isAntiquot, Lean.Syntax.isAntiquotSplice, Lean.Syntax.isAntiquotSuffixSplice, Lean.Syntax.isTokenAntiquot]]
[Lean.Elab.Term.Do.Code.jmp.inj,[And.intro]]
[Lean.Expr.isLambda,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[Monoid.toOne,[]]
[Nat.coprime.symm,[Eq.trans, Nat.gcd_comm]]
[Lean.DeclarationRange.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[MonadReader.read,[]]
[instSubNat,[Sub.mk, Nat.sub]]
[Lean.Parser.ParserExtension.Entry.parser.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserExtension.Entry.parser, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Parenthesizer.identEq.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken]]
[Lean.MessageData.instCoeArrayExprMessageData,[Coe.mk, Lean.MessageData.arrayExpr.toMessageData, OfNat.ofNat, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[Lean.Parser.checkOutsideQuotFn,[ite, Eq, or, not, BEq.beq, Lean.Parser.ParserContext.quotDepth, OfNat.ofNat, Lean.Parser.ParserContext.suppressInsideQuot, Bool.true, Lean.Parser.ParserState.mkUnexpectedError, List.nil]]
[Lean.Lsp.ServerInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.hasDecEq.proof_2,[]]
[Lean.Elab.Deriving.Hashable.mkMatch,[Bind.bind, Lean.Elab.Deriving.mkDiscrs, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.Elab.Deriving.Hashable.mkMatch.mkAlts]]
[Lean.Elab.Level.State.ngen,[]]
[Lean.Lsp.instFromJsonReferenceParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Lean.Lsp.ReferenceContext, Pure.pure, Lean.Lsp.ReferenceParams.mk, Lean.Lsp.TextDocumentPositionParams.mk]]
[instDivFloat,[Div.mk, Float.div]]
[Lean.Lsp.TextDocumentSyncKind.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.TextDocumentSyncKind.toCtorIdx]]
[Lean.Syntax.atom.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.NameSet.contains,[Std.RBMap.contains]]
[UInt8.isLower,[and, Decidable.decide, GE.ge, OfNat.ofNat, LE.le]]
[System.FilePath.components,[String.splitOn, System.FilePath.toString, System.FilePath.normalize, Bool.false, Char.toString, System.FilePath.pathSeparator]]
[Lean.Server.Watchdog.ServerEvent.clientMsg.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt32.instRingUInt32.proof_5,[UInt32.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, UInt32.val, congrFun, HAdd.hAdd, UInt32.neg_def, UInt32.add_def, UInt32.mk, Neg.neg, add_left_neg, UInt32.zero_def, eq_true_of_decide, Eq.refl, Bool.true]]
[Nat.coprime.coprime_mul_right,[Nat.coprime.coprime_dvd_left, Nat.dvd_mul_right]]
[Lean.Elab.Command.ProjectionInfo.inferMod,[]]
[List.erasep_of_forall_not,[rfl, of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.erasep_cons_of_neg, Not, eq_false, Or.inl, eq_true_of_decide, Eq.refl, Bool.true, List.cons, List.forall_mem_of_forall_mem_cons, eq_self]]
[IO.Error.mkUnsatisfiedConstraints,[IO.Error.unsatisfiedConstraints]]
[Std.HashMapBucket,[Subtype, GT.gt, Array.size, OfNat.ofNat]]
[Lean.IR.UniqueIds.M,[StateT, Lean.IR.IndexSet, Id]]
[Std.AssocList.mapVal,[Unit.unit, Std.AssocList, Std.AssocList.nil, Std.AssocList.cons, PProd.fst]]
[Lean.Meta.mkAuxLemma,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.EnvExtension.getState, Lean.Meta.auxLemmasExt, Unit.unit, Lean.Meta.MetaM, Lean.Name, Std.PersistentHashMap.find?, Lean.Meta.AuxLemmas.lemmas, ite, Eq, BEq.beq, Bool.true]]
[StateRefT'.lift,[]]
[Lean.Parser.ParserExtension.OLeanEntry.token.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.ParserExtension.OLeanEntry.token, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.RecKind.partial.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Subarray.as,[]]
[Lean.Parser.ParserState.shrinkStack,[Lean.Parser.ParserState.mk, Array.shrink, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.pos, Lean.Parser.ParserState.cache, Lean.Parser.ParserState.errorMsg]]
[Lean.Parser.Term.letRecDecls,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.sepBy1, Lean.Parser.Term.letRecDecl, Lean.Parser.symbol, Bool.false]]
[Lean.Elab.Term.elabStateRefT,[Bind.bind, Lean.Elab.Term.elabType, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, PUnit.unit]]
[MonadFinally.tryFinally',[]]
[right_commutative,[Eq]]
[Lean.Parser.Command.noncomputable.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.Elab.WF.TerminationStrategy.terminationBy,[]]
[Lean.Expr.getAutoParamTactic?,[ite, Eq, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Bool.true, Option.some, Lean.Expr.appArg!, Option.none]]
[Function.surjective.exists₂,[Iff.trans, Function.surjective.exists, exists_congr]]
[instToStreamSubarraySubarray,[ToStream.mk]]
[Lean.mkProjEx,[Lean.mkProj]]
[Lean.Parser.Tactic.tacticUnhygienic_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Nat.lcm_one_left,[]]
[Lean.ReducibilityHints.regular.inj,[]]
[UInt16.instSemiringUInt16.proof_3,[congrArg, UInt16.mk, Semiring.nsmul_zero', UInt16.val]]
[Lean.Widget.Lean.Widget.InteractiveTermGoal.instToJsonRpcEncodingPacket,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil]]
[Lean.IR.FnBody.case.inj,[And.intro]]
[Lean.Parser.Term.strictImplicitBinder.formatter,[Lean.ppGroup.formatter, Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.strictImplicitLeftBracket.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.Parser.Term.binderType.formatter, Lean.Parser.Term.strictImplicitRightBracket.formatter]]
[UInt32.instRingUInt32.proof_1,[congrArg, UInt32.mk, Ring.sub_eq_add_neg, UInt32.val]]
[Lean.Lsp.PlainGoal.rendered,[]]
[Lean.Elab.MonadMacroAdapter.setNextMacroScope,[]]
[Lean.Meta.GeneralizeArg.mk.inj,[And.intro]]
[Lean.IR.EmitC.emitTailCall,[Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Lean.IR.EmitC.M, Unit, Bind.bind, MonadReader.read, ite, Eq, BEq.beq, Array.size, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw]]
[mul_inv_self,[mul_right_inv]]
[Lean.Meta.NormNum.instLawfulOne.proof_1,[Lean.Meta.NormNum.LawfulOne.mk, rfl]]
[or_comm,[Or.comm]]
[Lean.Meta.InstanceEntry.keys,[]]
[Std.Format.FlattenBehavior.fill.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.IR.AltCore.ctor.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.AltCore.ctor, Eq.symm, eq_of_heq, HEq.refl]]
[Prod.Lex.decidable,[decidable_of_decidable_of_iff, inferInstance, Prod.Lex.decidable.proof_1]]
[stdSplit,[StdGen.mk, Prod, StdGen, Prod.mk]]
[Lean.Message.toString,[Bind.bind, Lean.MessageData.toString, Lean.Message.data, ite, Eq, BEq.beq, Lean.Message.caption, Bool.true, Pure.pure, PUnit.unit]]
[Nat.lt_of_succ_lt_succ,[Nat.le_of_succ_le_succ]]
[Lean.Elab.Term.Do.ToTerm.Kind.isRegular,[Unit.unit, Lean.Elab.Term.Do.ToTerm.Kind.forIn, Lean.Elab.Term.Do.ToTerm.Kind.forInWithReturn, Lean.Elab.Term.Do.ToTerm.Kind.nestedBC, Lean.Elab.Term.Do.ToTerm.Kind.nestedPR, Lean.Elab.Term.Do.ToTerm.Kind.nestedSBC, Lean.Elab.Term.Do.ToTerm.Kind.nestedPRBC, Bool, Bool.true, Bool.false]]
[Std.RBMap.empty,[Std.mkRBMap]]
[And.rotate,[Eq.mpr, congrArg, Iff, And, Eq.trans, propext, and_comm, And.left_comm, Iff.rfl]]
[Lean.Elab.Info.ofMacroExpansionInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.ExprStructMap,[Std.HashMap, Lean.ExprStructEq]]
[Lean.PrettyPrinter.Formatter.incQuotDepth.formatter,[]]
[Lean.Meta.SynthInstance.Context.mk.inj,[And.intro]]
[Lean.IR.instAlphaEqvArrayArg,[Lean.IR.AlphaEqv.mk, Lean.IR.args.alphaEqv]]
[or_self,[propext, Iff.intro, Or.inl]]
[IO.FS.DirEntry.fileName,[]]
[Lean.Elab.pushInfoTree,[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, ite, Eq, Lean.Elab.InfoState.enabled, Bool.true, Lean.Elab.MonadInfoTree.modifyInfoState, Lean.Elab.InfoState.mk, Lean.Elab.InfoState.assignment, Lean.Elab.InfoState.trees, Std.PersistentArray.push, Pure.pure, PUnit.unit]]
[Lean.Syntax.isNatLit?,[Option.none, Option, Nat, Lean.Syntax.isLit?, Lean.Syntax.decodeNatLitVal?, Lean.numLitKind]]
[Lean.Meta.SynthInstance.State.resumeStack,[]]
[Lean.CollectLevelParams.State.visitedLevel,[]]
[instReprUSize,[Repr.mk, repr, USize.toNat]]
[Lean.Parser.quotedCharFn,[Lean.Parser.quotedCharCoreFn, Lean.Parser.isQuotableCharDefault]]
[Array.insertionSort.traverse,[Unit.unit, Array, dite, LT.lt, Array.size, PProd.fst, Array.insertionSort.swapLoop, HAdd.hAdd, OfNat.ofNat]]
[Lean.Xml.Parser.Reference,[HOrElse.hOrElse, Lean.Xml.Parser.EntityRef, Functor.map, Option.some, Lean.Xml.Parser.CharRef]]
[IO.FileRight.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FileRight.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.reduceBinNatPred,[Lean.Meta.withNatValue, Pure.pure, Option.some, Lean.ToExpr.toExpr]]
[Std.RBNode.balance1,[Std.RBNode.leaf, Std.RBNode.node, Std.Rbcolor.black, Std.Rbcolor.red, Std.RBNode]]
[Std.Format.nest.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.Format.nest, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.Ipc.IpcM,[ReaderT, IO.Process.Child, Lean.Lsp.Ipc.ipcStdioConfig, IO]]
[Lean.Elab.Tactic.Conv.evalRewrite,[Bind.bind, liftM, Lean.Elab.Tactic.elabRewriteConfig, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.withRWRulesSeq, Lean.Elab.Term.withSynthesize, Lean.Elab.Tactic.withMainContext, Lean.Elab.Tactic.elabTerm, Option.none, Bool.true, Lean.Elab.Tactic.getMainGoal, Lean.Elab.Tactic.Conv.getLhs, Lean.Meta.rewrite, Lean.Occurrences.all, Lean.Elab.Tactic.Conv.updateLhs, Lean.Meta.RewriteResult.eNew, Lean.Meta.RewriteResult.eqProof, Lean.Elab.Tactic.replaceMainGoal, List.cons, Lean.Meta.RewriteResult.mvarIds, Bool.false]]
[not,[Unit.unit, Bool, Bool.false, Bool.true]]
[Fin.size_positive',[Fin.size_positive, Inhabited.default]]
[Lean.Widget.instInhabitedInfoPopup,[Inhabited.mk, Lean.Widget.InfoPopup.mk, arbitrary]]
[Squash.lift.proof_1,[Subsingleton.elim]]
[Lean.IR.Expr.box.inj,[And.intro]]
[Lean.Meta.Simp.Config.beta,[]]
[Function.surjective.of_comp_iff,[Iff.intro, Function.surjective.of_comp, Function.surjective.comp]]
[Lean.Elab.Term.Context.currMacroScope,[]]
[Array.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[System.FilePath.pathSeparator,[ite, Eq, System.Platform.isWindows, Bool.true, Char.ofNat]]
[Lean.Lsp.ServerCapabilities.completionProvider?,[]]
[Lean.Elab.Term.saveState,[Bind.bind, liftM, Lean.Meta.saveState, MonadState.get, Pure.pure, Lean.Elab.Term.SavedState.mk]]
[Lean.IR.Expr.pap.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MessageLog.forM,[Std.PersistentArray.forM, Lean.MessageLog.msgs]]
[Lean.Meta.Match.Example.ibelow,[True, And]]
[Lean.Elab.Term.Quotation.Precheck.Context.quotLCtx,[]]
[Tactic.Find.«tactic#find_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.Elab.Term.CollectPatternVars.M,[StateRefT', IO.RealWorld, Lean.Elab.Term.CollectPatternVars.State, Lean.Elab.Term.TermElabM]]
[Lean.Elab.Term.CollectPatternVars.Context.explicit,[]]
[Function.partial_inv,[dite, Exists, Eq, Option.some, Classical.choose, Option.none]]
[Classical.em,[]]
[Nat.lt_of_le_of_lt,[Nat.le_trans, Nat.succ_le_succ]]
[Tactic.Find.«command#find_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Std.HashMap.contains,[Bool, Std.HashMapImp.contains]]
[Lean.Meta.SizeOfSpecNested.Context.sizeOfFns,[]]
[Lean.Meta.SavedState.mk.inj,[And.intro]]
[Lean.Elab.DefKind.isExample,[Lean.Elab.DefKind.def, Lean.Elab.DefKind.theorem, Unit.unit, Lean.Elab.DefKind.opaque, Lean.Elab.DefKind.abbrev, Bool, Bool.true, Bool.false]]
[Lean.Parser.Tactic.cancelDenoms,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.sanitizeSyntax,[Bind.bind, MonadState.get, ite, Eq, Lean.getSanitizeNames, Lean.NameSanitizerState.options, Bool.true, Pure.pure]]
[Lean.Parser.Command.whereStructInst.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1Indent.formatter, Lean.Parser.group.formatter, Lean.Parser.Command.whereStructField.formatter, Lean.Parser.optional.formatter]]
[Lean.Parser.Command.libraryNote,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Lean.IR.ExplicitBoxing.mkCast,[Bind.bind, ite, Eq, not, Lean.IR.IRType.isScalar, Bool.true, Pure.pure, Option.none, Lean.IR.IRType.float, Unit.unit, Lean.IR.IRType.uint32, Lean.IR.IRType.uint64, Lean.IR.IRType.usize, Lean.IR.IRType.irrelevant, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.struct, Lean.IR.IRType.union, Lean.IR.ExplicitBoxing.M, Option, Lean.IR.Expr, Lean.IR.ExplicitBoxing.getLocalContext, Lean.IR.LocalContext.getValue, Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Option.some, BEq.beq, Array.size, OfNat.ofNat, MonadReader.read, MonadState.get, Std.AssocList.find?, Lean.IR.ExplicitBoxing.BoxingState.auxDeclCache, modify, Lean.IR.ExplicitBoxing.BoxingState.mk, Lean.IR.ExplicitBoxing.BoxingState.nextIdx, Array.push, Lean.IR.ExplicitBoxing.BoxingState.auxDecls, Std.AssocList.cons, HAdd.hAdd, Lean.IR.ExplicitBoxing.BoxingState.nextAuxId]]
[Lean.Lsp.CancelParams.noConfusionType,[]]
[Lean.Core.instMonadEnvCoreM,[Lean.MonadEnv.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Core.State.env, modify, Lean.Core.State.mk, Lean.Core.State.nextMacroScope, Lean.Core.State.ngen, Lean.Core.State.traceState]]
[Lean.Expr.lam.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.lam, Eq.symm, eq_of_heq, HEq.refl]]
[Std.HashMapImp.insert.proof_1,[Subtype.property]]
[Lean.Meta.instInhabitedInstanceEntry,[Inhabited.mk, Lean.Meta.InstanceEntry.mk, arbitrary]]
[Lean.mkForall,[Lean.Expr.forallE, Lean.Expr.mkDataForBinder, mixHash, UInt8.toUInt64, Hashable.hash, max, Lean.Expr.looseBVarRange, HSub.hSub, OfNat.ofNat, or, Lean.Expr.hasFVar, Lean.Expr.hasExprMVar, Lean.Expr.hasLevelMVar, Lean.Expr.hasLevelParam]]
[Lean.Parser.Term.doReassignArrow,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.notFollowedByRedefinedTermToken, Lean.Parser.withPosition, HOrElse.hOrElse, Lean.Parser.Term.doIdDecl, Lean.Parser.Term.doPatDecl]]
[Lean.Level.PP.Result.below,[PUnit, PProd]]
[Lean.Elab.Term.Do.getPatternVarsEx,[HOrElse.hOrElse, Functor.map, Lean.Elab.Term.getPatternVarNames, Lean.Elab.Term.getPatternVars, Array.map, Lean.Syntax.getId, Lean.Elab.Term.Quotation.getPatternVars]]
[Lean.Widget.instInhabitedEmbedFmt,[Inhabited.mk, arbitrary]]
[Lean.Meta.CaseValueSubgoal.subst,[]]
[Lean.Elab.Deriving.DecEq.mkDecEqCmds,[Bind.bind, Lean.Elab.Deriving.mkContext, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Lean.Elab.Deriving.DecEq.mkAuxFunction, Lean.Elab.Deriving.mkInstanceCmds, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Bool.false, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.Meta.IndPredBelow.proveBrecOn.applyIH,[Bind.bind, Array.findSomeM?, Lean.Meta.IndPredBelow.BrecOnVariables.indHyps, MonadExcept.tryCatch, Lean.Meta.apply, Lean.mkFVar, Pure.pure, Option.some, Option.none, Unit.unit, Lean.Meta.MetaM, List, Lean.MVarId, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MessageData.ofGoal]]
[Lean.Parser.Tactic.ext,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Char.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt64.lor,[UInt64.mk, Fin.lor, UInt64.val]]
[Lean.Meta.instInhabitedCongrLemmas,[Inhabited.mk, Lean.Meta.CongrLemmas.mk, arbitrary]]
[Lean.Parser.Tactic.simpErase,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat]]
[unexpandPSigma,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[Lean.Level.find?,[Lean.Level.find?.visit]]
[Lean.getClosedTermName?,[Std.PersistentHashMap.find?, Lean.ClosedTermCache.map, Lean.EnvExtension.getState, Lean.closedTermCacheExt]]
[USize.instRingUSize,[Ring.mk, USize.instRingUSize.proof_1, USize.mk, Ring.gsmul, USize.val, USize.instRingUSize.proof_2, USize.instRingUSize.proof_3, USize.instRingUSize.proof_4, USize.instRingUSize.proof_5]]
[pow_add,[of_eq_true, Eq.trans, congr, congrArg, Eq, HPow.hPow, HAdd.hAdd, Nat.zero_eq, Nat.add_zero, HMul.hMul, pow_zero, mul_one, eq_self, Eq.mpr, Eq.refl, Nat.succ, Nat.add_succ, pow_succ', Eq.symm, mul_assoc, pow_mul_comm, rfl]]
[Lean.Expr.ReplaceImpl.replaceUnsafe,[StateT.run', Lean.Expr.ReplaceImpl.replaceUnsafeM, Lean.Expr.ReplaceImpl.cacheSize, Lean.Expr.ReplaceImpl.initCache]]
[Lean.Lsp.DocumentSymbolResult.mk.inj,[]]
[Lean.CollectMVars.State.result,[]]
[Lean.Elab.Term.elabCharLit,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Syntax.isCharLit?, Pure.pure, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.mkRawNatLit, Char.toNat, Lean.Elab.throwIllFormedSyntax]]
[Lean.PrettyPrinter.Delaborator.SubExpr.getExpr,[Bind.bind, readThe, Lean.PrettyPrinter.Delaborator.SubExpr, Pure.pure, Lean.PrettyPrinter.Delaborator.SubExpr.expr]]
[ne_of_lt,[absurd, lt_irrefl]]
[Lean.CollectMVars.State.visitedExpr,[]]
[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer,[Bind.bind, Lean.MonadEnv.getEnv, List.nil, Lean.PrettyPrinter.ParenthesizerM, Unit, Lean.KeyedDeclsAttribute.getValues, Lean.PrettyPrinter.categoryParenthesizerAttribute, Lean.PrettyPrinter.Parenthesizer.parenthesizeCategoryCore]]
[Lean.Parser.Command.openSimple.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.many1.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer, Lean.Parser.ident.parenthesizer]]
[Sub.sub,[]]
[Lean.Meta.InjectionResult.subgoal.inj,[And.intro]]
[Lean.Lsp.instToJsonCancelParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.CancelParams.id, List.nil]]
[Lean.Parser.Tactic.change,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.Parser.Tactic.location]]
[Lean.Elab.Command.CtorView.inferMod,[]]
[Lean.Parser.ParserExtension.Entry.category.inj,[And.intro]]
[Lean.Meta.NormNum.instSemiringNat,[inferInstance]]
[Lean.IR.Sorry.State.localSorryMap,[]]
[Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.noConfusionType,[]]
[Subrelation.wf,[Subrelation.wf.proof_1]]
[Lean.KVMap.getNat,[Option.none, Option.some, Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofName, Lean.DataValue.ofInt, Nat, Lean.KVMap.find]]
[Lean.Meta.RecursorInfo.recursorName,[]]
[Lean.Elab.Tactic.evalApplyLikeTactic,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.elabTermForApply, Bool.true, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Bool.false, Lean.Elab.Tactic.replaceMainGoal]]
[Lean.Elab.Tactic.Simp.DischargeWrapper.custom.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Array.size,[List.length, Array.data]]
[Lean.Macro.State.macroScope,[]]
[Lean.Elab.WF.TerminationHint.many.inj,[]]
[Lean.Elab.Term.BinOp.elabBinCalc,[Bind.bind, ForIn.forIn, MProd.mk, Lean.Elab.Term.elabType, Lean.Syntax.getOp, OfNat.ofNat, liftM, ite, LT.lt, Lean.Expr.getAppNumArgs, Pure.pure, Option.none, Option.some, Prod.mk, Lean.Expr.appFn!, Lean.Expr.appArg!, Lean.Elab.Term.TermElabM, ForInStep, MProd, Array, Lean.Expr, GT.gt, Array.size, Array.back, Lean.Meta.isDefEqGuarded, Eq, Bool.true, PUnit.unit, Lean.Meta.inferType, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, panicWithPosWithDecl, Lean.indentExpr, ForInStep.yield, Lean.Meta.instantiateMVars, Array.getOp, Lean.Meta.getLevel, Lean.Meta.mkArrow, Lean.mkSort, Lean.levelZero, Lean.Meta.mkFreshExprMVar, Lean.MetavarKind.natural, Lean.Name.anonymous, Lean.Meta.trySynthInstance, Lean.LOption.none, Lean.LOption.undef, Option.isSome, Lean.Elab.Term.ensureHasType]]
[Lean.IR.ExplicitRC.Context.decls,[]]
[Lean.Elab.CommandInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt16.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[StateT.run_set,[rfl]]
[Lean.Xml.Content.ibelow,[And, True]]
[Thunk.bind,[Thunk.mk, Thunk.get]]
[Lean.Meta.SavedState.core,[]]
[Lean.MetavarKind.natural.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[ofNat_one,[rfl]]
[Lean.IR.IndexRenaming,[Std.RBMap, Lean.IR.Index, Ord.compare]]
[Lean.Meta.mkSimpAttr,[Lean.registerBuiltinAttribute, Lean.AttributeImpl.mk, Lean.AttributeImplCore.mk, Functor.discard, Lean.Meta.MetaM.run, Lean.Meta.Context.mk, Lean.Meta.State.mk, Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.ScopedEnvExtension.getState, Lean.Meta.SimpLemmas.erase, Lean.MonadEnv.modifyEnv, Lean.ScopedEnvExtension.modifyState]]
[Lean.Parser.Term.stateRefT.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.macroArg.parenthesizer, Lean.Parser.Term.macroLastArg.parenthesizer]]
[ByteArray.get!,[UInt8, Array.get!]]
[List.length_cons,[rfl]]
[Lean.IR.EmitC.declareParams,[Array.forM, Lean.IR.EmitC.declareVar, Lean.IR.Param.x, Lean.IR.Param.ty, OfNat.ofNat, Array.size]]
[Subsingleton.helim.proof_1,[heq_of_eq, Subsingleton.elim]]
[Function.comp.assoc,[rfl]]
[Lean.FileMap.utf8PosToLspPos,[Lean.FileMap.leanPosToLspPos, Lean.FileMap.toPosition]]
[Lean.JsonRpc.ErrorCode.contentModified.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Lsp.instFileSourcePlainGoalParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.PlainGoalParams.toTextDocumentPositionParams]]
[CoeDep.noConfusionType,[]]
[Lean.IR.mkCase,[Lean.IR.FnBody.case, Lean.IR.IRType.object]]
[Lean.PrettyPrinter.Delaborator.ParamKind.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.ParamKind.mk, Eq.symm, eq_of_heq, HEq.refl]]
[List.singleton_disjoint,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, forall_congr, implies_congr, propext, List.mem_singleton, Eq.refl, False, forall_eq, Not, Mem.mem, iff_self]]
[Std.Format.MonadPrettyFormat.pushOutput,[]]
[Lean.Position.mk.inj,[And.intro]]
[Lean.Elab.Tactic.deltaLocalDecl,[Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Meta.getLocalDecl, Lean.Meta.deltaExpand, Lean.LocalDecl.type, BEq.beq, ite, Eq, Bool.true, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.LocalDecl.userName, Lean.Syntax.missing, Pure.pure, PUnit.unit]]
[Function.bicompr,[]]
[Lean.PrettyPrinter.Delaborator.topDownAnalyze,[Bind.bind, MonadState.get, Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Elab.Term.setElabConfig, Lean.Meta.Context.config, Lean.Meta.Context.lctx, Lean.Meta.Context.localInstances, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth, tryFinally, MonadExcept.tryCatch, Lean.MonadOptions.getOptions, StateRefT'.run', Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk, Lean.PrettyPrinter.Delaborator.SubExpr.mkRoot, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.mk, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, MonadStateOf.set]]
[Function.update_apply,[]]
[Lean.Server.Watchdog.ServerContext.fileWorkersRef,[]]
[Lean.Elab.Term.LetRecToLift.fvarId,[]]
[Lean.Elab.Term.Quotation.PrecheckM,[ReaderT, Lean.Elab.Term.Quotation.Precheck.Context, Lean.Elab.Term.TermElabM]]
[Lean.Parser.Tactic.rwSearch?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.Parser.Tactic.rwRuleSeq]]
[List.map_eq_mapTR,[funext, of_eq_true, Eq.trans, congrArg, Eq, List.map, List.mapTRAux_eq, List.nil, congrFun, HAppend.hAppend, List.reverse_nil, List.nil_append, eq_self]]
[Mathlib.Tactic.Lint.Linter.isFast,[]]
[Lean.LocalContext.get!,[Unit.unit, Lean.LocalDecl, Lean.LocalContext.find?, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Widget.InteractiveTermGoal.range,[]]
[Lean.PrettyPrinter.Delaborator.delabLetE,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Lean.PrettyPrinter.Delaborator.getUnusedName, Lean.PrettyPrinter.Delaborator.SubExpr.descend, OfNat.ofNat, Lean.PrettyPrinter.Delaborator.delab, Lean.Meta.withLetDecl, orM, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPLetVarTypes, Lean.getPPAnalysisLetVarType, ite, Eq, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Lean.mkIdent, List.nil, panicWithPosWithDecl]]
[Decidable.not_and_iff_or_not,[Iff.intro, Decidable.isFalse, Decidable.isTrue, Or, Not, absurd, And.intro, Or.inr, Or.inl, False]]
[Bool.and_false,[rfl, Eq.symm, Eq.refl]]
[Nat.succ_sub_one,[rfl]]
[Lean.Json.getObjValD,[Option.getD, Except.toOption, Lean.Json.getObjVal?, Lean.Json.null]]
[Lean.Lsp.instFromJsonHover,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.MarkupContent, Option, Lean.Lsp.Range, Pure.pure, Lean.Lsp.Hover.mk]]
[Lean.Elab.Term.ElabAppArgs.State.fType,[]]
[Lean.PrettyPrinter.Delaborator.isIdLike,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[pow_succ,[Eq.mpr, Eq.refl, Eq, HPow.hPow, Nat.succ, HMul.hMul, pow_succ', pow_mul_comm, rfl]]
[Lean.Parser.Term.doAssert.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Function.right_inverse,[Function.left_inverse]]
[Lean.PersistentEnvExtensionDescr.exportEntriesFn,[]]
[MonadExcept.instOrElse,[OrElse.mk, MonadExcept.orElse]]
[AndThen.andThen,[]]
[Lean.PrettyPrinter.Formatter.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.AliasState,[Lean.SMap, Lean.Name, List]]
[Lean.instBEqInternalExceptionId,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Meta.Hypothesis.type,[]]
[Lean.Parser.TokenCacheEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.LeadingIdentBehavior.toCtorIdx,[OfNat.ofNat]]
[Lean.Parser.parserOfStackFnUnsafe,[ite, LT.lt, Array.size, HAdd.hAdd, OfNat.ofNat, Lean.Parser.ParserState.mkUnexpectedError, List.nil, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Parser.ParserState, Array.get!, HSub.hSub, Prod.mk, List.cons, Lean.Parser.ParserContext.resolveName, Eq, and, not, Lean.Parser.ParserState.hasError, bne, Lean.Parser.ParserState.stackSize, Bool.true, HAppend.hAppend, ToString.toString]]
[instLENat,[LE.mk, Nat.le]]
[IO.FS.Stream.Buffer.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FS.Stream.Buffer.mk, Eq.symm, eq_of_heq, HEq.refl]]
[instAndOpUInt64,[AndOp.mk, UInt64.land]]
[Fin.instAndOpFin,[AndOp.mk, Fin.land]]
[Lean.Elab.Term.Quotation.HeadInfo.doMatch,[]]
[Lean.Syntax.TopDown.noConfusionType,[]]
[Lean.StructureDescr.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.StructureDescr.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Do.ToCodeBlock.Context.mutableVars,[]]
[Lean.Parser.Term.haveEqnsDecl.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.haveIdLhs.parenthesizer, Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Bool.false]]
[Lean.Elab.Term.expandWhereDecls,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Unit.unit, Lean.MacroM, Lean.Syntax, OptionM.run, Array.sequenceMap, Lean.Syntax.getArgs, cond, Lean.Syntax.isNone, Lean.Syntax.matchesNull, OfNat.ofNat, Option.none, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.Syntax.SepArray.elemsAndSeps, Lean.Syntax.SepArray.ofElems, Lean.Macro.throwUnsupported]]
[Lean.Lsp.LocationLink.targetUri,[]]
[Lean.Meta.Cases.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Cases.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Int.negSucc.inj,[]]
[Lean.Server.Watchdog.ServerContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.Watchdog.ServerContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.SynthInstance.MkTableKey.State.noConfusionType,[]]
[Std.AssocList.nil.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Widget.MsgEmbed.goal.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[le_max_right,[dite, LT.lt, Eq.mpr, congrArg, LE.le, if_pos, le_of_lt, of_eq_true, Eq.trans, if_neg, eq_true, le_refl]]
[Std.PShareCommonM.run,[Std.PShareCommonT.run]]
[Lean.Elab.toAttributeKind,[ite, Eq, Lean.Syntax.isNone, Lean.Syntax.getOp, OfNat.ofNat, Bool.true, Pure.pure, Lean.AttributeKind.global, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.Macro.getCurrNamespace, Lean.Name.isAnonymous, Lean.MonadRef.getRef, MonadExcept.throw, Lean.Macro.Exception.error, PUnit.unit, Lean.AttributeKind.local]]
[Lean.Parser.ParserState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.syntaxAbbrev,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.docComment, Lean.Parser.symbol, Lean.Parser.ident, Lean.Parser.many1, Lean.Parser.syntaxParser]]
[Function.left_inverse.injective,[rfl]]
[Lean.Parser.syntaxParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous]]
[Fin.instOrOpFin,[OrOp.mk, Fin.lor]]
[Lean.Elab.Structural.RecArgInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Structural.RecArgInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.typeCheck,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Fin.sub,[Fin, Fin.mk, HMod.hMod, HAdd.hAdd, HSub.hSub, Fin.sub.proof_1]]
[IO.Process.StdioConfig.stdin,[]]
[Lean.SSet,[Lean.SMap, Unit]]
[EStateM.instInhabitedResult,[Inhabited.mk, EStateM.Result.error, arbitrary]]
[Lean.FVarId.name,[]]
[UInt8.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd]]
[String.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.app,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.leadPrec, Lean.Parser.maxPrec, Lean.Parser.many1, Lean.Parser.Term.argument]]
[Nat.dvd_lcm_left,[Exists.intro, HDiv.hDiv, Nat.gcd, Eq.mpr, Eq.refl, Eq, Nat.lcm, HMul.hMul, Eq.symm, Nat.mul_div_assoc, Nat.gcd_dvd_right, rfl]]
[Lean.Lsp.DocumentHighlightParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.mkRecOn,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.MonadEnv.modifyEnv, Lean.throwKernelException, Lean.mkRecOnImp]]
[Lean.IR.LogEntry.instToFormatLogEntry,[Std.ToFormat.mk, Lean.IR.LogEntry.fmt]]
[Lean.Meta.ParamInfo.mk.inj,[And.intro]]
[Lean.Elab.Command.StructFieldKind.copiedField.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Server.FileWorker.SemanticTokensContext.mk.inj,[And.intro]]
[StateRefT',[ReaderT, ST.Ref]]
[Lean.getConstInfoInduct,[Bind.bind, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.InductiveVal, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkConst, List.nil]]
[System.Platform.isEmscripten,[System.Platform.getIsEmscripten, Unit.unit]]
[Subarray.instForInSubarray,[ForIn.mk, Subarray.forIn]]
[Lean.Elab.DerivingClassView.noConfusionType,[]]
[Lean.PrettyPrinter.Parenthesizer.visitArgs,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, GT.gt, Array.size, Lean.Syntax.getArgs, OfNat.ofNat, SeqLeft.seqLeft, SeqRight.seqRight, Lean.Syntax.MonadTraverser.goDown, HSub.hSub, Lean.Syntax.MonadTraverser.goUp, Pure.pure, PUnit.unit]]
[Lean.Meta.SizeOfSpecNested.Context.noConfusionType,[]]
[ByteArray.instForInByteArrayUInt8,[ForIn.mk, ByteArray.forIn]]
[List.erasep_nil,[rfl]]
[Lean.SimplePersistentEnvExtension.getEntries,[Prod.fst, Lean.PersistentEnvExtension.getState]]
[Lean.Meta.ElimInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.ElimInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.TransformStep.done.inj,[]]
[Lean.Elab.Command.instMonadCommandElabM,[Monad.mk]]
[Lean.getPPCoercions,[Lean.KVMap.get, Lean.Option.name, Lean.pp.coercions, not, Lean.getPPAll]]
[Lean.Parser.Error.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt8.instSemiringUInt8.proof_13,[UInt8.eq_of_val_eq, Eq.mpr, congrArg, Eq, Fin.ofNat', HAdd.hAdd, OfNat.ofNat, Fin.size_positive', UInt8.val, Eq.trans, UInt8.mk, UInt8.one_def, UInt8.add_def]]
[Bool.and_self,[rfl, Eq.symm, Eq.refl]]
[Std.RBNode.erase,[Std.RBNode.setBlack]]
[Lean.Unhygienic.instMonadQuotationUnhygienic,[Lean.MonadQuotation.mk, Bind.bind, MonadReader.read, Pure.pure, Lean.Unhygienic.Context.scope, Lean.Name.mkStr, Lean.Name.anonymous, MonadState.modifyGet, Prod.mk, HAdd.hAdd, OfNat.ofNat, MonadWithReader.withReader, Lean.Unhygienic.Context.mk, Lean.Unhygienic.Context.ref]]
[Lean.Meta.RecursorInfo.produceMotive,[]]
[Lean.Lsp.SemanticTokenType.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.SemanticTokenType.toCtorIdx]]
[Lean.Meta.evalNat.isNatProjInst,[or, and, BEq.beq, OfNat.ofNat, Lean.Name.mkStr, Lean.Name.anonymous]]
[Char.isAlphanum,[or, Char.isAlpha, Char.isDigit]]
[Lean.Lsp.TypeDefinitionParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.DiagnosticRelatedInformation.message,[]]
[Lean.SearchPath.findWithExt,[Bind.bind, List.findM?, orM, liftM, System.FilePath.isDir, HDiv.hDiv, System.FilePath.mk, System.FilePath.pathExists, System.FilePath.withExtension, Pure.pure, Option.map, Lean.modToFilePath]]
[Lean.Meta.whnfI,[Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.instances, Lean.Meta.whnf]]
[Lean.Meta.Closure.ToProcessElement.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Closure.ToProcessElement.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Subtype.trans,[Setoid.trans]]
[Std.RBMap.erase.proof_1,[Std.RBNode.WellFormed.eraseWff, rfl]]
[Lean.Meta.induction,[Lean.Meta.withMVarContext, Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MessageData.ofGoal, Pure.pure, PUnit.unit]]
[Lean.Elab.Term.ElabAppArgs.State.noConfusionType,[]]
[Lean.getStructureFieldsFlattened,[List.toArray, List.nil]]
[add_neg_self,[add_right_neg]]
[Lean.Elab.Term.Do.homogenize,[Bind.bind, Lean.Elab.Term.Do.extendUpdatedVars, Pure.pure, Prod.mk]]
[Lean.PrettyPrinter.Delaborator.isCoe,[or, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, and, Lean.Expr.isAppOf, Decidable.decide, GE.ge, Lean.Expr.getAppNumArgs]]
[Lean.Parser.Command.openScoped.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.PrettyPrinter.Formatter.checkColGt.formatter, Lean.Parser.ident.formatter]]
[Lean.Expr.constName?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Name, Option.some, Option.none]]
[Lean.Parser.Tactic.rwWithRfl,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Option.getD, Lean.Syntax.getHeadInfo?, List.nil]]
[IO.FS.FileType.file.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Array.anyM.loop.proof_1,[Nat.lt_of_lt_of_le]]
[Lean.InductiveVal.isUnsafeEx,[Lean.InductiveVal.isUnsafe]]
[Lean.Macro.Context.currMacroScope,[]]
[Lean.Lsp.LeanFileProgressParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.LeanFileProgressParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.JsonRpc.Message.response.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonRpc.Message.response, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Simp.main,[Lean.Meta.withConfig, Lean.Meta.Config.mk, Lean.Meta.Config.foApprox, Lean.Meta.Config.ctxApprox, Lean.Meta.Config.quasiPatternApprox, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Simp.Config.etaStruct, Lean.Meta.Simp.Context.config, Lean.Meta.withReducible, StateRefT'.run', Lean.Meta.Simp.simp, Lean.Meta.Simp.State.mk]]
[IO.FS.Stream.readLspNotificationAs,[MonadExcept.tryCatch, Bind.bind, Unit.unit, IO, Nat, List.lookup, String.toNat?, Pure.pure, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, IO.FS.Stream.readNotificationAs]]
[Lean.Name.appendBefore,[Lean.Name.modifyBase, Unit.unit, Lean.Name, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.Name.mkNum]]
[UInt32.isValidChar,[Nat.isValidChar, UInt32.toNat]]
[Lean.Meta.Instances.instanceNames,[]]
[FloatArray.foldlMUnsafe,[ite, LT.lt, LE.le, FloatArray.size, USize.ofNat, Pure.pure, FloatArray.foldlMUnsafe.fold]]
[Nat.min_comm,[Decidable.em, LE.le, Eq.mpr, congr, congrArg, Eq, Eq.trans, ite_congr, eq_true, Eq.refl, ite_true, Nat.le_antisymm, Eq.symm, of_eq_true, eq_false, ite_false, eq_self, not_or_intro, Nat.le_or_le]]
[Lean.Parser.Tactic.renameVar,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.Parser.Tactic.location]]
[Lean.Parser.priorityParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.PrettyPrinter.Formatter.suppressInsideQuot.formatter,[]]
[Lean.Server.FileWorker.CancelToken.noConfusionType,[]]
[Lean.Lsp.DiagnosticCode.int.inj,[]]
[Lean.IR.EmitC.getEnv,[Functor.map, Lean.IR.EmitC.Context.env, MonadReader.read]]
[Equiv.mk.inj,[And.intro]]
[IO.Process.SpawnArgs.mk.inj,[And.intro]]
[instToFormatOption,[Std.ToFormat.mk, Option.format]]
[Lean.IR.ExplicitBoxing.getDecl,[Bind.bind, MonadReader.read, Unit.unit, Lean.IR.ExplicitBoxing.M, Lean.IR.Decl, Lean.IR.findEnvDecl', Lean.IR.ExplicitBoxing.BoxingContext.env, Lean.IR.ExplicitBoxing.BoxingContext.decls, Pure.pure, arbitrary]]
[Lean.Parser.Term.doIfLet.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.doIfLetPure.formatter, Lean.Parser.Term.doIfLetBind.formatter, Bool.false]]
[Lean.Lsp.CompletionList.mk.inj,[And.intro]]
[Lean.Elab.Term.Do.Code.continue.inj,[]]
[IO.bindTask,[EIO.bindTask]]
[Lean.Parser.Tactic.tacticHave_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Function.bicompl,[]]
[IO.FS.Mode.toCtorIdx,[OfNat.ofNat]]
[Lean.Elab.Tactic.rewriteLocalDecl,[Lean.Elab.Term.withSynthesize, Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.elabTerm, Option.none, Bool.true, liftM, Lean.Meta.getLocalDecl, Lean.Elab.Tactic.getMainGoal, Lean.Meta.rewrite, Lean.LocalDecl.type, Lean.Occurrences.all, Lean.Meta.replaceLocalDecl, Lean.Meta.RewriteResult.eNew, Lean.Meta.RewriteResult.eqProof, Lean.Elab.Tactic.replaceMainGoal, List.cons, Lean.Meta.AssertAfterResult.mvarId, Lean.Meta.RewriteResult.mvarIds, Bool.false]]
[Lean.ScopedEnvExtension.StateStack.noConfusionType,[]]
[Lean.Parser.Command.infix.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.Meta.UnificationHints.discrTree,[]]
[Lean.Parser.Term.letIdLhs.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.notFollowedBy.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.simpleBinderWithoutType.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Bool.false, Lean.Parser.Term.optType.parenthesizer]]
[Lean.version.specialDesc,[Lean.version.getSpecialDesc, Unit.unit]]
[Mathlib.Tactic.Lint.lintCore,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, Array.mapM, Array.filterM, Mathlib.Tactic.Lint.shouldBeLinted, Mathlib.Tactic.Lint.NamedLinter.name, OfNat.ofNat, Array.size, liftM, BaseIO.asTask, EIO.toBaseIO, Lean.Core.CoreM.run', Lean.Meta.MetaM.run', Mathlib.Tactic.Lint.Linter.test, Mathlib.Tactic.Lint.NamedLinter.toLinter, Lean.Meta.Context.mk, Lean.Meta.State.mk, Lean.Core.Context.mk, Lean.Core.State.mk, BaseIO, Option, Lean.MessageData, Pure.pure, Option.some, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Exception.toMessageData, Task.Priority.default, Prod.mk, Lean.Core.CoreM, Prod, Mathlib.Tactic.Lint.NamedLinter, Std.HashMap, Lean.Name, ForIn.forIn, ForInStep, Option.none, Task.get, PUnit.unit, ForInStep.yield]]
[Lean.Meta.SimpAll.Entry.fvarId,[]]
[String.isInt,[ite, Eq, String.get, OfNat.ofNat, Char.ofNat, Substring.isNat, Substring.drop, String.toSubstring, String.isNat]]
[Std.PersistentArray.get!,[ite, GE.ge, Std.PersistentArray.tailOff, Array.get!, Std.PersistentArray.tail, HSub.hSub, Std.PersistentArray.getAux, Std.PersistentArray.root, USize.ofNat, Std.PersistentArray.shift]]
[Lean.Syntax.isTokenAntiquot,[Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous]]
[List.append_subset_iff,[Iff.intro, Eq.mpr, congr, congrArg, And, propext, List.subset_def, And.intro, Eq.mp, List.mem_append_left, List.mem_append_right, Subset.subset, HAppend.hAppend, List.append_subset_of_subset_of_subset]]
[Lean.Meta.admit,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType, Lean.Meta.mkSorry, Lean.Meta.assignExprMVar]]
[Lean.LocalDecl.value,[Lean.Expr, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.PrettyPrinter.Parenthesizer.instCoeParenthesizerParenthesizerAliasValue,[Coe.mk, Lean.Parser.AliasValue.const]]
[Lean.JsonRpc.RequestID.num.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.AbstractNestedProofs.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.AbstractNestedProofs.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.doSeqItem.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.ppLine.formatter, Lean.Parser.doElemParser.formatter, Lean.Parser.optional.formatter, Lean.Parser.symbol.formatter]]
[HPow.noConfusionType,[]]
[decidable_of_iff,[decidable_of_decidable_of_iff]]
[List.decidableBexi.proof_2,[Exists.intro, And.intro, List.mem_cons_self]]
[Lean.Elab.Command.ProjectionInfo.declName,[]]
[Lean.mkOr,[Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Lean.Parser.Term.funStrictImplicitBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.lookahead.parenthesizer, Lean.Parser.Term.strictImplicitLeftBracket.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.strictImplicitRightBracket.parenthesizer, Lean.Parser.Term.strictImplicitBinder.parenthesizer, Bool.false]]
[Applicative.toPure,[]]
[Lean.Expr.updateMData!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateMData, Lean.Expr.mdata, Lean.Expr.updateMData!.proof_1, panicWithPosWithDecl, OfNat.ofNat]]
[not.decidable_imp_symm,[Decidable.not_imp_symm]]
[Lean.SMap.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.mul_le_mul_left,[LE.le, HMul.hMul, Nat.le.dest]]
[Lean.getPPInstances,[Lean.KVMap.get, Lean.Option.name, Lean.pp.instances, Lean.Option.defValue]]
[Lean.Elab.Term.ToDepElimPattern.State.noConfusionType,[]]
[Lean.Elab.Term.LValResolution.projFn.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Std.PersistentHashMap.toList,[Std.PersistentHashMap.foldl, List.cons, Prod.mk, List.nil]]
[Lean.Expr.isIte,[Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat]]
[Lean.TraceState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.ellipsis,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Array.mapIdxM.map,[Array, Pure.pure]]
[instSubsingletonStateM.proof_1,[Subsingleton.intro, funext, Eq, Eq.mpr, Eq.refl, Prod.mk, Subsingleton.elim, rfl]]
[Lean.Parser.Command.unsafe.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Nat.allM,[Nat.allM.loop]]
[String.length,[Nat, List.length]]
[Lean.Parser.Command.in,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.Parser.withOpen, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.commandParser]]
[UInt32.instAddCommSemigroupUInt32,[AddCommSemigroup.mk, UInt32.instAddCommSemigroupUInt32.proof_1]]
[Lean.Parser.compileParserDescr,[Lean.Parser.compileParserDescr.visit]]
[Lean.KeyedDeclsAttribute.getValues,[List.map, Lean.KeyedDeclsAttribute.AttributeEntry.value, Lean.KeyedDeclsAttribute.getEntries]]
[Lean.CollectMVars.instInhabitedState,[Inhabited.mk, Lean.CollectMVars.State.mk]]
[PUnit.subsingleton,[rfl, Eq.symm, Eq.refl]]
[Iff.elim_right.proof_1,[Iff.mpr]]
[Lean.Meta.Match.Pattern.inaccessible.inj,[]]
[Lean.IR.UnreachableBranches.Value.instToStringValue,[ToString.mk, Function.comp, Std.Format.pretty, Std.Format.defWidth, Lean.IR.UnreachableBranches.Value.format]]
[GroupWithZero.mul_inv_cancel,[]]
[Lean.IR.ExplicitRC.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.ExplicitRC.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Deriving.Header.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.doLet.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.letDecl.formatter]]
[Lean.Elab.Command.ProjectionInfo.noConfusionType,[]]
[Lean.Expr.FindImpl.State.keys,[]]
[Lean.Elab.Term.Quotation.match_syntax.expand,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Syntax, OptionM.run, Array.sequenceMap, Array.getSepElems, Lean.Syntax.getArgs, Option.some, Option.none, OptionM, Prod, Array, Prod.mk, not, Array.any, Lean.Syntax.isQuot, Array.size, Bind.bind, Lean.Elab.throwUnsupportedSyntax, Pure.pure, PUnit.unit]]
[Lean.Meta.GeneralizeArg.hName?,[]]
[Lean.Lsp.RpcRef.mk.inj,[]]
[Lean.Meta.Cache.whnfAll,[]]
[Option.some.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.EmitC.emitBox,[Bind.bind, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.emitBoxFn, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn]]
[Lean.Elab.CompletionInfo.option.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.CompletionInfo.option, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.commitIfNoErrors?,[Bind.bind, Lean.MonadBacktrack.saveState, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.MessageLog.mk, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState, MonadExcept.tryCatch, MonadState.get, ite, Eq, Lean.MessageLog.hasErrors, Lean.Elab.Term.State.messages, Bool.true, Lean.MonadBacktrack.restoreState, Pure.pure, Option.none, HAppend.hAppend, Lean.Elab.Term.SavedState.elab, Option.some]]
[Lean.Meta.IndPredBelow.mkContext,[Bind.bind, Lean.getConstInfoInduct, Array.mapM, List.toArray, Lean.InductiveVal.all, Array.mapIdxM, Fin.val, Pure.pure, Prod.mk, Lean.InductiveVal.numParams, Array.map, HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.IndPredBelow.Context.mk, Lean.Meta.IndPredBelow.mkContext.motiveName, Lean.Meta.IndPredBelow.mkContext.mkHeader, Lean.Meta.IndPredBelow.mkContext.addMotives, Lean.Meta.IndPredBelow.mkContext.motiveType, Lean.Meta.IndPredBelow.mkContext.mkIndValConst]]
[Lean.Meta.isMatcher,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Meta.isMatcherCore]]
[Lean.Lsp.instInhabitedDiagnosticCode,[Inhabited.mk, Lean.Lsp.DiagnosticCode.int, arbitrary]]
[Lean.Lsp.InitializeParams.noConfusionType,[]]
[withPtrEqDecEq.proof_3,[ofBoolUsing_eq_false]]
[Lean.Compiler.foldNatBinOp,[OptionM.run, Bind.bind, Lean.Compiler.getNumLit, Pure.pure, Lean.mkRawNatLit]]
[Lean.Elab.Tactic.evalSubst,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Tactic.forEachVar, Lean.Meta.subst, Lean.Elab.throwUnsupportedSyntax]]
[Lean.EnumAttributes.setValue,[ite, Eq, Option.isSome, Lean.Environment.getModuleIdxFor?, Bool.true, Except.error, HAppend.hAppend, ToString.toString, Lean.PersistentEnvExtension.name, Lean.EnumAttributes.ext, Lean.NameMap.find?, Lean.PersistentEnvExtension.getState, Except.ok, Lean.PersistentEnvExtension.addEntry, Prod.mk]]
[Lean.JsonNumber.instLTJsonNumber,[Lean.JsonNumber.ltProp]]
[Lean.Environment.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Environment.mk, Eq.symm, eq_of_heq, HEq.refl]]
[List.mem_bind_of_mem,[Iff.mpr, List.mem_bind, Exists.intro, And.intro]]
[Lean.Parser.Term.waitIfTypeMVar.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[instCommMonoid_1.proof_1,[Semiring.mul_one]]
[MonadReaderOf.read,[]]
[Lean.Elab.Info.occursInside?,[OptionM.run, Bind.bind, Lean.Elab.Info.pos?, Lean.Elab.Info.tailPos?, guard, Eq, and, Decidable.decide, LE.le, LT.lt, Bool.true, Pure.pure, HSub.hSub]]
[workOnGoal,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[Lean.Elab.logInfoAt,[Lean.Elab.logAt, Lean.MessageSeverity.information]]
[Lean.JsonRpc.instInhabitedErrorCode,[Inhabited.mk, Lean.JsonRpc.ErrorCode.parseError]]
[Lean.Elab.Command.tmpIndParam,[Lean.mkLevelParam, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Expr.mkDataForBinder,[ite, GT.gt, HSub.hSub, Nat.pow, OfNat.ofNat, panicWithPosWithDecl, Bool.false]]
[instNegFin.proof_1,[Nat.mod_lt, HSub.hSub, Fin.val, lt_of_le_of_lt, Nat.zero_le, Fin.isLt]]
[Lean.Elab.Term.Do.ToTerm.Kind.nestedPR.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.getFieldInfo?,[Option.none, Option, Lean.StructureFieldInfo, Lean.getStructureInfo?, Array.binSearch, Lean.StructureInfo.fieldInfo, Lean.StructureFieldInfo.mk, arbitrary, Bool.false, Lean.StructureFieldInfo.lt, OfNat.ofNat, HSub.hSub, Array.size]]
[Nat.pred,[Unit.unit, Nat, OfNat.ofNat]]
[USize.modn_lt,[LT.lt, USize.toNat, HMod.hMod, Fin.modn_lt]]
[Lean.Elab.Command.ElabHeaderResult.params,[]]
[Lean.Expr.mkData,[ite, GT.gt, HSub.hSub, Nat.pow, OfNat.ofNat, panicWithPosWithDecl, Bool.false, Lean.BinderInfo.default]]
[Lean.IR.Borrow.BorrowInfCtx.paramSet,[]]
[Lean.Lsp.instFromJsonRpcReleaseParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, UInt64, Array, Lean.Lsp.RpcRef, Pure.pure, Lean.Lsp.RpcReleaseParams.mk]]
[Lean.Export.Entry.name.injEq,[Eq.propIntro, Eq.refl, Lean.Export.Entry.name, Eq.symm, eq_of_heq, HEq.refl]]
[instSemiringFin.proof_10,[Eq.mpr, Eq.refl, Eq, HMul.hMul, OfNat.ofNat, instSemiringFin.proof_4, instSemiringFin.proof_5]]
[Array.anyM.proof_1,[Nat.le_refl, Array.size]]
[Lean.Constructor.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.getNondepPropHyps.removeDeps,[Bind.bind, Lean.Meta.instantiateMVars, StateRefT'.run']]
[Lean.OpenDecl.noConfusionType,[]]
[Lean.Elab.Deriving.Repr.mkBodyForStruct,[Bind.bind, Lean.getConstInfoCtor, List.head!, Lean.InductiveVal.ctors, Lean.MonadEnv.getEnv, Pure.pure, Lean.getStructureFields, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Prod.mk, List.nil, ite, Eq, bne, Array.size, HAdd.hAdd, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData, PUnit.unit]]
[Lean.Elab.Term.Do.mkPureUnitAction,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Elab.Term.Do.mkTerminalAction]]
[Lean.Elab.Term.Do.Alt.patterns,[]]
[Lean.Elab.Term.isAuxDiscrName,[and, Lean.Name.hasMacroScopes, BEq.beq, Lean.Name.eraseMacroScopes, Lean.Name.mkStr, Lean.Name.anonymous]]
[String.toAsciiByteArray.loop,[WellFounded.fix, String.toAsciiByteArray.loop.proof_1, dite, Eq, String.atEnd, Bool.true, String.next, String.toAsciiByteArray.loop.proof_2, ByteArray.push, Char.toUInt8]]
[Lean.Elab.Tactic.evalFocus,[Bind.bind, Lean.Elab.Tactic.mkInitialTacticInfo, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.focus, Lean.Elab.withInfoContext, Pure.pure, Unit.unit, Lean.Elab.Tactic.evalTactic]]
[Lean.Syntax.mkScientificLit,[Lean.Syntax.mkLit, Lean.scientificLitKind]]
[Nat.toUInt8,[UInt8.ofNat]]
[Prod.swap_inj,[Function.injective.eq_iff, Prod.swap_injective]]
[Lean.Meta.InfoCacheKey.instHashableInfoCacheKey,[Hashable.mk, UInt64, mixHash, Hashable.hash]]
[Lean.Parser.Command.elab_rules.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.suppressInsideQuot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.docComment.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.optKind.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.Expr.ReplaceImpl.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Group.noConfusionType,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.applyFunBinderHeuristic,[Bind.bind, MonadReader.read, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit, ForIn.forIn, PUnit.unit, Pure.pure, BEq.beq, Array.getOp, Lean.BinderInfo.default, ite, Eq, Bool.true, liftM, Lean.Meta.inferType, Lean.PrettyPrinter.Delaborator.SubExpr.withNaryArg, modify, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.bottomUps, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.higherOrders, Array.set!, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.funBinders, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.provideds, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.namedArgs, ForInStep.yield, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.applyFunBinderHeuristic.core]]
[decide_eq_false_iff_not,[Iff.intro, of_decide_eq_false, decide_eq_false]]
[rfl.proof_1,[Eq.refl]]
[Nat.dvd_lcm_right,[Nat.dvd_lcm_left, Nat.lcm_comm]]
[Lean.Message.pos,[]]
[instStreamSubstringChar,[Stream.mk, ite, LT.lt, Substring.startPos, Substring.stopPos, Option.some, Prod.mk, String.get, Substring.str, Substring.mk, String.next, Option.none]]
[Lean.Parser.mkAntiquot,[Lean.Parser.leadingNode, Lean.Parser.maxPrec, Lean.Parser.atomic, HAndThen.hAndThen, Lean.Parser.setExpected, List.nil, Lean.Parser.symbol, Lean.Parser.manyNoAntiquot, Lean.Parser.checkNoWsBefore, Lean.Parser.antiquotExpr]]
[Lean.Parser.initCacheForInput,[Lean.Parser.ParserCache.mk, Lean.Parser.TokenCacheEntry.mk, HAdd.hAdd, String.bsize, OfNat.ofNat]]
[and.swap,[And, And.intro]]
[ReprTuple.noConfusionType,[]]
[Lean.Parser.setExpected,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.setExpectedFn, Lean.Parser.Parser.fn]]
[Lean.Widget.instToJsonTaggedText,[Lean.ToJson.mk]]
[Lean.Meta.Cache.whnfDefault,[]]
[Lean.PrettyPrinter.Parenthesizer.mkAntiquot.parenthesizer,[Lean.Parser.mkAntiquot.parenthesizer]]
[Lean.Parser.Tactic.fapply',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.Elab.Term.CollectPatternVars.Context.ctorVal?,[]]
[Lean.collectLevelParams,[Lean.CollectLevelParams.main]]
[Lean.Elab.Term.Context.sectionFVars,[]]
[Lean.Lsp.Ipc.writeNotification,[Bind.bind, Lean.Lsp.Ipc.stdin, liftM, IO.FS.Stream.writeLspNotification]]
[Lean.Parser.Term.parenSpecial,[Lean.Parser.optional, HOrElse.hOrElse, Lean.Parser.Term.tupleTail, Lean.Parser.Term.typeAscription]]
[CoeHTCT.noConfusionType,[]]
[Lean.Elab.Frontend.State.mk.inj,[And.intro]]
[Lean.IR.Decl.extern.inj,[And.intro]]
[Lean.instToFormatName,[Std.ToFormat.mk, Std.Format.text, Lean.Name.toString, Bool.true]]
[Lean.IR.UnreachableBranches.Value.instToFormatValue,[Std.ToFormat.mk, Lean.IR.UnreachableBranches.Value.format]]
[Lean.EnvExtensionInterfaceUnsafe.modifyState,[ite, LT.lt, Lean.EnvExtensionInterfaceUnsafe.Ext.idx, Array.size, Lean.Environment.extensions, Lean.Environment.mk, Lean.Environment.const2ModIdx, Lean.Environment.constants, Array.modify, unsafeCast, Lean.Environment.header, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Elab.Structural.registerEqnsInfo,[Lean.MonadEnv.modifyEnv, Lean.MapDeclarationExtension.insert, Lean.Elab.Structural.eqnInfoExt, Lean.Elab.PreDefinition.declName, Lean.Elab.Structural.EqnInfo.mk, Lean.Elab.PreDefinition.levelParams, Lean.Elab.PreDefinition.type, Lean.Elab.PreDefinition.value]]
[Lean.Parser.nonReservedSymbolFnAux,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Syntax.missing, Lean.Syntax.node, Lean.Parser.ParserState, Array.back, Lean.Parser.ParserState.stxStack, BEq.beq, Lean.Parser.ParserState.mkErrorAt, Option.some, Substring.toString, Lean.Parser.ParserState.pushSyntax, Lean.Syntax.atom]]
[Lean.Parsec.ParseResult.success.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Equiv.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Nat.lt.step,[Nat.lt.step.proof_1]]
[Lean.Server.FileWorker.RpcSession.mk.inj,[And.intro]]
[Lean.mkFreshId,[Bind.bind, Lean.MonadNameGenerator.getNGen, Lean.MonadNameGenerator.setNGen, Lean.NameGenerator.next, Pure.pure]]
[Lean.Compiler.objectType,[Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Lean.Parser.Command.terminationHint1.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat]]
[pow_succ',[Monoid.npow_succ']]
[Lean.Parser.Term.doElem.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.doElemParser]]
[Subarray.forM,[Array.forM, Subarray.as, Subarray.start, Subarray.stop]]
[ReaderT.run_seqRight,[Eq.mpr, Eq.refl, Eq, ReaderT.run, SeqRight.seqRight, seqRight_eq_bind, rfl]]
[Nat.gcd_dvd_gcd_mul_right,[Nat.gcd_dvd_gcd_of_dvd_left, Nat.dvd_mul_right]]
[Lean.Elab.TerminationHints.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.CollectPatternVars.Context.ellipsis,[]]
[Lean.IR.Sorry.M,[StateT, Lean.IR.Sorry.State, Lean.IR.CompilerM]]
[Lean.Parser.ParserState.keepPrevError,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Array.shrink]]
[Lean.Parser.Command.mutual.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.Parser.notSymbol.parenthesizer, Lean.Parser.commandParser.parenthesizer, Lean.Parser.ppDedent.parenthesizer, Lean.Parser.Command.terminationSuffix.parenthesizer]]
[Lean.Elab.Term.MVarErrorKind.custom.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.MVarErrorKind.custom, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Visibility.private.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.CaseValuesSubgoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.CaseValuesSubgoal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.section,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.ident]]
[Lean.Meta.isLevelDefEq,[Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.Meta.checkpointDefEq, Lean.Meta.isLevelDefEqAux, Bool.true, Lean.isTracingEnabledFor, ite, Eq, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.Elab.CompletionInfo.noConfusionType,[]]
[«term∅»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Lean.Xml.Parser.EntityValue,[Bind.bind, HOrElse.hOrElse, Lean.Parsec.skipChar, Char.ofNat, SeqLeft.seqLeft, Lean.Parsec.many, Functor.map, Option.some, Lean.Parsec.satisfy, Decidable.decide, And, Ne, SeqRight.seqRight, Lean.Xml.Parser.PEReference, Pure.pure, Option.none, Lean.Xml.Parser.Reference, Array.foldl, String, String.push, OfNat.ofNat, Array.size]]
[Lean.Elab.Attribute.mk.inj,[And.intro]]
[IO.AccessRight.mk.inj,[And.intro]]
[Lean.Xml.instInhabitedContent,[Inhabited.mk, Lean.Xml.Content.Comment, arbitrary]]
[not_not,[Decidable.not_not]]
[Array.instEmptyCollectionArray,[EmptyCollection.mk, Array.empty]]
[instReprAtomUInt8,[ReprAtom.mk]]
[Std.Range.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.RequestContext.srcSearchPath,[]]
[Nat.lt_or_eq_or_le_succ,[Decidable.byCases, Or.inr]]
[Lean.Parser.nodeWithAntiquot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Parser.node]]
[Lean.IR.CtorInfo.usize,[]]
[String.decapitalize,[String.set, OfNat.ofNat, Char.toLower, String.get]]
[Lean.Meta.SynthInstance.Answer.size,[]]
[Array.singleton,[Array.mkArray, OfNat.ofNat]]
[Lean.Lsp.WaitForDiagnosticsParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.WaitForDiagnosticsParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[«term_<*>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[IO.Error.mkResourceVanished,[IO.Error.resourceVanished]]
[IO.FS.withIsolatedStreams,[Bind.bind, liftM, IO.mkRef, IO.FS.Stream.Buffer.mk, IO.withStdin, IO.FS.Stream.ofBuffer, IO.withStdout, IO.withStderr, ST.Ref.get, Pure.pure, Prod.mk]]
[Lean.Elab.Command.StructFieldView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Match.AltLHS.noConfusionType,[]]
[Lean.Meta.mkEqTrue,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil]]
[Lean.ScopedEnvExtension.Descr.noConfusionType,[]]
[Lean.Server.FileWorker.WorkerState.pendingRequests,[]]
[Nat.sub_one_sub_lt,[Eq.mpr, Eq.refl, LT.lt, HSub.hSub, OfNat.ofNat, Nat.sub_sub, Nat.sub_lt, Nat.lt_of_lt_of_le, Nat.zero_lt_succ, HAdd.hAdd, Nat.add_comm]]
[Lean.Elab.Term.ExtractMonadResult.mk.inj,[And.intro]]
[Lean.Elab.Modifiers.attrs,[]]
[Lean.Parser.notSymbol,[Lean.Parser.notFollowedBy, Lean.Parser.symbol]]
[Lean.IR.MapVars.mapExpr,[Lean.IR.Expr.lit, Lean.IR.Expr, Lean.IR.Expr.ctor, Lean.IR.MapVars.mapArgs, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.fap, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr]]
[Lean.Xml.Parser.AttType,[HOrElse.hOrElse, Lean.Xml.Parser.StringType, Lean.Xml.Parser.TokenizedType, Lean.Xml.Parser.EnumeratedType]]
[Sub.noConfusionType,[]]
[Lean.getBoolOption,[Bind.bind, Lean.MonadOptions.getOptions, Pure.pure, Lean.KVMap.getBool]]
[Nat.to_digits_core_length,[of_eq_true, eq_true, Nat.zero_le, False.elim, Nat.lt_irrefl, OfNat.ofNat, Eq.symm, Classical.em, LT.lt, Eq.refl]]
[Lean.IR.FnBody.ret.inj,[]]
[Array.pop,[Array.mk, List.dropLast, Array.data]]
[Lean.Elab.Structural.run,[StateRefT'.run]]
[Lean.Lsp.ClientCapabilities.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Export.instInhabitedState,[Inhabited.mk, Lean.Export.State.mk, arbitrary]]
[Lean.IR.Expr.reset.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.reset, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.letrec,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Nat.mul_div_left,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, Nat.mul_comm, Nat.mul_div_right, rfl]]
[Lean.Elab.CompletionInfo.option.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.ClientInfo.name,[]]
[Lean.Parser.Module.header,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Module.prelude, Lean.Parser.ppLine, Lean.Parser.many, Lean.Parser.Module.import]]
[Nat.mod_eq_of_lt,[]]
[ReaderT.run_monadMap,[rfl]]
[Lean.Meta.casesOnStuckLHS?,[Bind.bind, MonadExcept.tryCatch, Lean.Meta.casesOnStuckLHS, Pure.pure, DoResultPR.pure, PUnit.unit, DoResultPR.return, Option.none, Lean.Meta.MetaM, Option, Array, Lean.MVarId, Option.some]]
[Std.PersistentArray.all,[not, Std.PersistentArray.any]]
[Int.div,[Int, Int.ofNat, HDiv.hDiv, Neg.neg, Nat.succ]]
[Lean.Elab.Frontend.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Frontend.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Delaborator.delabPSigma,[Lean.PrettyPrinter.Delaborator.delabSigmaCore, Bool.false]]
[Lean.Lsp.TypeDefinitionParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.TypeDefinitionParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.StructInst.ExplicitSourceInfo.mk.inj,[And.intro]]
[false_ne_true,[trivial, Eq.symm]]
[Classical.typeDecidable.proof_1,[absurd, Nonempty.intro]]
[Lean.Meta.byCases.toByCasesSubgoal,[Bind.bind, Pure.pure, Lean.Meta.InductionSubgoal.fields, Lean.Meta.CasesSubgoal.toInductionSubgoal, dite, Eq, Array.size, Array.getLit, Eq.symm, of_decide_eq_true, id, Eq.refl, Bool.true, List.toArray, List.cons, Lean.Expr.bvar, List.nil, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Array.toArrayLit_eq, Lean.Meta.MetaM, Lean.Meta.ByCasesSubgoal, Lean.Meta.ByCasesSubgoal.mk, Lean.Meta.InductionSubgoal.mvarId, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.Elab.MonadLog.noConfusionType,[]]
[Lean.Parser.ParserExtension,[Lean.ScopedEnvExtension, Lean.Parser.ParserExtension.OLeanEntry, Lean.Parser.ParserExtension.Entry, Lean.Parser.ParserExtension.State]]
[Lean.Lsp.DidCloseTextDocumentParams.noConfusionType,[]]
[Lean.Meta.MVarRenaming.find!,[Option.get!, Lean.Meta.MVarRenaming.find?]]
[ToString.toString,[]]
[Lean.ReducibilityStatus.irreducible.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Exists.choose,[Classical.choose]]
[Lean.PrettyPrinter.Parenthesizer.Context.cat,[]]
[Lean.Parser.Tactic.convert,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.const]]
[Lean.Meta.Simp.Context.noConfusionType,[]]
[Lean.Parser.Tactic.rewriteSeq,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq, Lean.Parser.Tactic.location]]
[Function.injective_iff_has_left_inverse,[Iff.intro, Function.injective.has_left_inverse, Function.has_left_inverse.injective]]
[Lean.PrettyPrinter.Formatter.identEq.formatter,[Lean.PrettyPrinter.Formatter.rawIdentNoAntiquot.formatter]]
[AddMonoid.nsmul,[]]
[Lean.PrettyPrinter.Delaborator.getUnusedName,[Bind.bind, Lean.MonadLCtx.getLCtx, ite, Eq, not, Lean.LocalContext.usesUserName, Bool.true, Pure.pure, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPSafeShadowing, and, Lean.LocalContext.getUnusedName, Lean.PrettyPrinter.Delaborator.getUnusedName.bodyUsesSuggestion]]
[Lean.Elab.Command.CommandElabM,[Lean.Elab.Command.CommandElabCoreM, Lean.Exception]]
[Lean.Server.Watchdog.handleCancelRequest,[Bind.bind, MonadReader.read, ST.Ref.get, Lean.Server.Watchdog.ServerContext.fileWorkersRef, ForIn.forIn, PUnit.unit, Lean.Server.Watchdog.ServerM, ForInStep, PUnit, Lean.Server.Watchdog.FileWorker.pendingRequestsRef, ite, Eq, Std.RBMap.contains, Lean.Lsp.CancelParams.id, Bool.true, Lean.Server.Watchdog.tryWriteMessage, Lean.JsonRpc.Message.notification, Lean.JsonRpc.Notification.method, Lean.JsonRpc.Notification.mk, Except.toOption, Lean.Json.toStructured?, Lean.JsonRpc.Notification.param, Bool.false, Pure.pure, ForInStep.yield]]
[Lean.IR.UnreachableBranches.Value.ctor.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, Eq.refl, List.nil, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec]]
[Lean.Syntax.getOp,[Lean.Syntax.getArg]]
[Lean.Lsp.Hover.noConfusionType,[]]
[Lean.Parser.interpolatedStr,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.interpolatedStrKind, Bool.true, Lean.Parser.interpolatedStrNoAntiquot]]
[Lean.MetavarContext.MkBinding.State.noConfusionType,[]]
[Lean.Lsp.instToJsonRpcConnectParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.RpcConnectParams.uri, List.nil]]
[Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1]]
[Lean.StructureDescr.noConfusionType,[]]
[Lean.Meta.SavedState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SavedState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[NonScalar.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[max_comm,[eq_max, le_max_right, le_max_left, max_le]]
[Lean.Elab.Command.CtorView.modifiers,[]]
[Lean.DeclarationRange.endCharUtf16,[]]
[Lean.isPrivateName,[Lean.Name.anonymous, Lean.Name.str, Bool, or, BEq.beq, Lean.privateHeader, PProd.fst, Bool.false]]
[Lean.Meta.CheckAssignment.State.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.CheckAssignment.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Thunk.map,[Thunk.mk, Thunk.get]]
[Function.inv_fun_surjective,[Function.left_inverse.surjective, Function.left_inverse_inv_fun]]
[OptionT.run,[]]
[Lean.Meta.CheckAssignment.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.CheckAssignment.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Xml.Parser.StringType,[Lean.Parsec.skipString]]
[Nat.add_sub_add_left,[Eq.mpr, Eq.refl, Eq, HSub.hSub, HAdd.hAdd, Nat.add_comm, Nat.add_sub_add_right, rfl]]
[Quotient.inductionOn₃,[Quotient.ind]]
[Lean.Server.Snapshots.Snapshot.infoTree,[ite, Eq, BEq.beq, Std.PersistentArray.size, Lean.Elab.InfoState.trees, Lean.Elab.Command.State.infoState, Lean.Server.Snapshots.Snapshot.cmdState, OfNat.ofNat, Bool.true, Std.PersistentArray.getOp, panicWithPosWithDecl, HAppend.hAppend]]
[Function.«term↿_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.SSet.empty,[Lean.SMap.empty]]
[Lean.Level.mvar.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Level.mvar, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.mkEqMP,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil]]
[Lean.Parser.Tactic.matchAlts,[Lean.Parser.Term.matchAlts, Lean.Parser.Tactic.matchRhs]]
[Decidable.not_not,[Iff.intro, Decidable.by_contradiction, not_not_intro]]
[Lean.Expr.hashEx,[Hashable.hash]]
[Lean.IR.UnreachableBranches.updateVarAssignment,[Bind.bind, Lean.IR.UnreachableBranches.findVarValue, MonadReader.read, modify, Lean.IR.UnreachableBranches.InterpState.mk, Array.modify, Lean.IR.UnreachableBranches.InterpState.assignments, Lean.IR.UnreachableBranches.InterpContext.currFnIdx, Std.HashMap.insert, Lean.IR.UnreachableBranches.Value.merge, Lean.IR.UnreachableBranches.InterpState.funVals]]
[fixCore2,[bfix2, USize.size]]
[Lean.IR.LitVal.num.inj,[]]
[Lean.Meta.RewriteResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.mkNumeral,[Bind.bind, Lean.Meta.getDecLevel, Lean.Meta.synthInstance, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil, Lean.mkRawNatLit, Option.none, Pure.pure, Lean.mkApp3]]
[Lean.Meta.Closure.instInhabitedToProcessElement,[Inhabited.mk, Lean.Meta.Closure.ToProcessElement.mk, arbitrary]]
[lt_of_not_ge,[lt_of_le_not_le, Or.resolve_right, le_total]]
[Lean.Elab.Deriving.Ord.mkMatch,[Bind.bind, Lean.Elab.Deriving.mkDiscrs, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.Elab.Deriving.Ord.mkMatch.mkAlts]]
[HShiftLeft.hShiftLeft,[]]
[Lean.Expr.natLit!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.strVal, Lean.Expr.mdata, Lean.Expr.proj, Nat, panicWithPosWithDecl, OfNat.ofNat]]
[LawfulMonad.bind_map,[]]
[Lean.LazyInitExtension.fn,[]]
[ulift.up_down,[Eq, ulift.up, ulift.down, rfl]]
[Lean.Parser.parserOfStack,[Lean.Parser.Parser.mk, Lean.Parser.parserOfStackFn, Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.tokens, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Parser.ParserContext.savedPos?, Lean.Parser.ParserContext.forbiddenTk?]]
[Std.RBNode.foldM,[Pure.pure, Bind.bind, PProd.fst, PProd.snd]]
[UInt8.isAlpha,[or, UInt8.isUpper, UInt8.isLower]]
[Lean.Expr.isLet,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[Lean.Elab.Tactic.filterOldMVars,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Array.filter, Decidable.decide, GE.ge, Lean.MetavarDecl.index, Lean.MetavarContext.getDecl, OfNat.ofNat, Array.size]]
[Lean.IR.ExpandResetReuse.CollectProjMap.Collector,[Lean.IR.ExpandResetReuse.ProjMap]]
[Lean.MetavarContext.addLevelMVarDecl,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Std.PersistentHashMap.insert, Lean.MetavarContext.lDepth, Lean.MetavarContext.decls, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment]]
[Lean.Meta.ByCasesSubgoal.fvarId,[]]
[Lean.Lsp.instInhabitedRange,[Inhabited.mk, Lean.Lsp.Range.mk, arbitrary]]
[Iff.symm,[Iff.intro, Iff.mpr, Iff.mp]]
[Mathlib.Tactic.Lint.NamedLinter.declName,[]]
[Lean.Elab.Term.Do.ToTerm.mkNestedTerm,[Lean.Elab.Term.Do.ToTerm.run, Lean.Elab.Term.Do.ToTerm.mkNestedKind]]
[Lean.MessageData.nestD,[Lean.MessageData.nest, OfNat.ofNat]]
[Lean.Elab.Term.MVarErrorInfo.mk.inj,[And.intro]]
[Lean.ImportM.Context.opts,[]]
[Nat.foldM,[Nat.foldM.loop]]
[Lean.Parser.Tactic.trans',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.cat]]
[Lean.Parser.Term.macroArg,[Lean.Parser.termParser, Lean.Parser.maxPrec]]
[List.isSuffixOf,[List.isPrefixOf, List.reverse]]
[imp_congr_left,[Iff.intro, Iff.mpr, Iff.mp]]
[Lean.ExternEntry.adhoc.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.instDecidableEqJsonNumber,[Decidable, Eq, dite, Decidable.isTrue, rfl, Decidable.isFalse]]
[Lean.Elab.Term.LValResolution.projIdx.inj,[And.intro]]
[Lean.Parser.Command.instance,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.attrKind, Lean.Parser.symbol, Lean.Parser.Command.optNamedPrio, Lean.Parser.optional, Lean.Parser.ppSpace, Lean.Parser.Command.declId, Lean.Parser.Command.declSig, Lean.Parser.Command.declVal, Lean.Parser.Command.terminationSuffix]]
[Lean.SSet.size,[Lean.SMap.size]]
[Lean.Lsp.InitializeResult.noConfusionType,[]]
[Lean.JsonRpc.Message.responseError.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonRpc.Message.responseError, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.ScopedEnvExtension.Descr.finalizeImport,[]]
[Set.powerset,[setOf, Subset.subset]]
[Lean.Lsp.MarkupKind.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.MarkupKind.toCtorIdx]]
[Lean.Server.FileWorker.ElabTaskError.ioError.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.ConstructorVal.noConfusionType,[]]
[Lean.Elab.Command.resolveSyntaxKind,[Bind.bind, Lean.MonadResolveName.getCurrNamespace, HOrElse.hOrElse, Lean.Elab.checkSyntaxNodeKindAtNamespaces, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.Meta.Simp.State.cache,[]]
[Lean.HeadIndex.const.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.KVMap.instValueInt,[Lean.KVMap.Value.mk, Lean.DataValue.ofInt, Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofName, Lean.DataValue.ofNat, Option, Int, Option.some, Option.none]]
[Lean.Parser.Command.catBehaviorSymbol.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false]]
[Lean.Lsp.instFileSourceCompletionParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.CompletionParams.toTextDocumentPositionParams]]
[Lean.Lsp.SaveOptions.includeText,[]]
[Function.involutive_iff_iter_2_eq_id,[Iff.symm, Function.funext_iff]]
[Lean.IR.formatFnBody,[Lean.IR.formatFnBody.loop]]
[Lean.Elab.DerivingHandlerNoArgs,[Lean.Elab.Command.CommandElabM, Bool]]
[List.hasDecidableLt.proof_1,[Eq.refl, List.nil, HEq.refl, False]]
[Lean.Elab.Term.MutualClosure.FreeVarMap,[Lean.FVarIdMap, Array, Lean.FVarId]]
[Lean.Widget.tagExprInfos,[Lean.Widget.tagExprInfos.go]]
[String.any,[String.anyAux, String.bsize, OfNat.ofNat]]
[Lean.Elab.Deriving.Repr.mkMutualBlock,[Bind.bind, ForIn.forIn, Lean.Elab.Deriving.Repr.mkAuxFunction, Pure.pure, PUnit.unit, ForInStep.yield, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil]]
[StateCpsT.run',[StateCpsT.runK, Pure.pure]]
[PLift.noConfusionType,[]]
[Lean.groupKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Mathlib.ExtendedBinder.«binderTerm<_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Tactic.mvBisim,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.binderIdent]]
[Lean.IR.AltCore.setBody,[Lean.IR.Alt, Lean.IR.Alt.ctor, Lean.IR.Alt.default]]
[Lean.Parser.ParserModuleContext.openDecls,[]]
[Lean.addBuiltinDeclarationRanges,[ST.Ref.modify, Lean.builtinDeclRanges, Lean.NameMap.insert]]
[Lean.Parser.Tactic.squeezeSimp?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Array.swapAt!,[dite, LT.lt, Array.size, Array.swapAt, Fin.mk]]
[Array.findRev?,[Id.run, Array.findRevM?]]
[Lean.Parser.ParserExtension.OLeanEntry.parser.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserExtension.OLeanEntry.parser, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Tactic.Conv.getLhsRhs,[Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Elab.Tactic.Conv.getLhsRhsCore]]
[Lean.Parser.commandParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous]]
[List.join_nil,[rfl]]
[Lean.Meta.Contradiction.Config.searchFuel,[]]
[Lean.Compiler.SpecArgKind.noConfusion,[noConfusionEnum, Lean.Compiler.SpecArgKind.toCtorIdx]]
[Nat.lt.base.proof_1,[Nat.le_refl, Nat.succ]]
[Applicative.noConfusionType,[]]
[Lean.Widget.CodeToken.mk.inj,[]]
[Lean.Parser.ParserExtension.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Array.toListLitAux.proof_2,[Nat.lt_of_lt_of_eq, Nat.lt_of_lt_of_le, Nat.lt_succ_self]]
[Lean.EnvExtensionInterfaceUnsafe.setState,[dite, LT.lt, Lean.EnvExtensionInterfaceUnsafe.Ext.idx, Array.size, Lean.Environment.extensions, Lean.Environment.mk, Lean.Environment.const2ModIdx, Lean.Environment.constants, Array.set, Fin.mk, unsafeCast, Lean.Environment.header, panicWithPosWithDecl, OfNat.ofNat]]
[decidable_of_decidable_of_iff.proof_1,[Iff.mp, not_iff_not_of_iff]]
[of_iff_true,[Iff.mpr, True.intro]]
[Lean.Rat.instAddRat,[Add.mk, Lean.Rat.add]]
[Lean.Literal.natVal.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Tactic.ElimApp.Result.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.ElimApp.Result.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.ensureBinaryParserAlias,[Functor.discard, Lean.Parser.getBinaryAlias, Lean.Parser.parserAliasesRef]]
[«prio(_)»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[Lean.SCC.Data.lowlink?,[]]
[Lean.Lsp.instToJsonDiagnosticCode,[Lean.ToJson.mk, Lean.Json, Lean.Json.num, Lean.JsonNumber.fromInt, Lean.Json.str]]
[Lean.IR.CollectMaps.collectDecl,[Lean.IR.Decl.extern, Lean.IR.CollectMaps.Collector, Function.comp, Lean.IR.CollectMaps.collectParams, Lean.IR.CollectMaps.collectFnBody, id]]
[IO.RealWorld,[Unit]]
[Lean.Lsp.FileSource.fileSource,[]]
[FloatArray.uget,[Float, Array.uget]]
[Lean.mkBRecOn,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.MonadEnv.modifyEnv, Lean.throwKernelException, Lean.mkBRecOnImp]]
[Lean.Parser.Tactic.unknown.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.errorAtSavedPos.parenthesizer]]
[Lean.Meta.RecursorUnivLevelPos.motive.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Sum.inhabitedLeft,[Inhabited.mk, Sum.inl, arbitrary]]
[Mathlib.Tactic.Lint.«command#list_linters»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Lean.Parser.withOpenDecl,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.withOpenDeclFn, Lean.Parser.Parser.fn]]
[Lean.MetavarContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MetavarContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[List.nodup,[List.pairwise, Ne]]
[bind_pure,[]]
[Lean.Widget.InteractiveHypothesis.isInstance,[]]
[Lean.AddMessageContext.noConfusionType,[]]
[Lean.instMonadRecDepthStateRefT',[inferInstanceAs, Lean.MonadRecDepth, ReaderT, ST.Ref]]
[Lean.Meta.zetaReduce,[Bind.bind, Lean.MonadLCtx.getLCtx, liftM, Lean.Core.transform, Pure.pure, Lean.TransformStep.done]]
[ST.Ref.take,[liftM, ST.Prim.Ref.take]]
[«term_⁻¹»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[iff_mpr_iff_true_intro,[rfl]]
[coeD,[CoeDep.coe]]
[Lean.CollectFVars.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.NamePart.noConfusionType,[]]
[Lean.MetavarContext.findUserName?,[Std.PersistentHashMap.find?, Lean.MetavarContext.userNames]]
[Lean.LocalContext.addDecl,[Lean.LocalContext, Lean.LocalContext.mk, Std.PersistentHashMap.insert, Lean.LocalDecl.fvarId, Std.PersistentArray.push, Option.some]]
[Lean.IR.Decl.pushProj,[Lean.IR.Decl.extern, Lean.IR.Decl, Lean.IR.Decl.normalizeIds, Lean.IR.Decl.updateBody!, Lean.IR.FnBody.pushProj]]
[Lean.IR.Borrow.getCurrFn,[Bind.bind, MonadReader.read, Pure.pure, Lean.IR.Borrow.BorrowInfCtx.currFn]]
[Lean.getTraces,[Bind.bind, Lean.MonadTrace.getTraceState, Pure.pure, Lean.TraceState.traces]]
[Std.Format.line.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[And.right_comm,[Eq.mpr, congr, congrArg, Iff, Eq.trans, propext, and_comm, And, And.left_comm, Iff.rfl]]
[USize.instSemiringUSize.proof_12,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HMul.hMul, USize.add_def, USize.mul_def, USize.mk, HAdd.hAdd, USize.val, USize.eq_of_val_eq, Semiring.add_mul]]
[Lean.MessageData.paren,[Lean.MessageData.bracket]]
[Std.PShareCommonT.run,[StateT.run', Std.ShareCommon.PersistentState.empty]]
[unexpandExists,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, MonadExcept.throw, Unit.unit]]
[Lean.Parser.FirstTokens.epsilon.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Tactic.apply,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.Parser.longestMatchFnAux,[Lean.Parser.longestMatchFnAux.parse]]
[IO.Error.mkAlreadyExistsFile,[Function.comp, IO.Error.alreadyExists, Option.some]]
[Fin.checked_sub_spec,[Iff.intro, Decidable.em, LT.lt, Fin.val, False.elim, Eq.mp, Eq.trans, congrFun, congrArg, Eq, Unit.unit, Bool, Option, Fin, Prod.mk, Iff.mpr, decide_eq_true_iff, HSub.hSub, Option.none, Option.some, Bool.true, Bool.false, eq_false', Eq.symm, Nat.le_of_not_lt, Eq.refl, of_eq_true, decide_eq_false, Nat.not_lt_of_le, eq_true_of_decide]]
[Lean.Lsp.Position.mk.inj,[And.intro]]
[Lean.Meta.MatcherApp.alts,[]]
[Nat.zero_add,[Unit.unit, Eq, HAdd.hAdd, OfNat.ofNat, rfl, congrArg, Nat.succ, PProd.fst]]
[Lean.Elab.Structural.RecArgInfo.ys,[]]
[Lean.IR.Borrow.ParamMap.Key.jp.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Borrow.ParamMap.Key.jp, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Simp.DefaultMethods.methods,[Lean.Meta.Simp.Methods.mk, Lean.Meta.Simp.DefaultMethods.pre, Lean.Meta.Simp.DefaultMethods.post, Lean.Meta.Simp.DefaultMethods.discharge?]]
[Std.PersistentHashMap.mod2Shift,[USize.land, HSub.hSub, USize.shiftLeft, OfNat.ofNat]]
[Lean.Parser.suppressInsideQuotFn,[Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.prec, Lean.Parser.ParserContext.tokens, Lean.Parser.ParserContext.quotDepth, Bool.true, Lean.Parser.ParserContext.savedPos?, Lean.Parser.ParserContext.forbiddenTk?]]
[Lean.Elab.Info.ofTermInfo.inj,[]]
[Lean.Elab.FieldInfo.mk.inj,[And.intro]]
[Lean.Parser.rawIdent.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.identKind, Bool.true, Lean.PrettyPrinter.Formatter.rawIdentNoAntiquot.formatter]]
[Lean.Parser.checkTailWs,[Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Bool, Lean.Syntax.getTailInfo, Decidable.decide, GT.gt, Substring.stopPos, Substring.startPos, Bool.false]]
[Lean.Elab.WF.packMutual,[ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Pure.pure, Array.getOp, Bind.bind, PUnit.unit]]
[Lean.Elab.DefViewElabHeader.type,[]]
[Lean.Elab.Term.SavedContext.noConfusionType,[]]
[GroupWithZero.toMonoidWithZero,[MonoidWithZero.mk, GroupWithZero.zero_mul, GroupWithZero.mul_zero]]
[Lean.Lsp.TextDocumentPositionParams.noConfusionType,[]]
[«term_<$>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.moduleNameOfFileName,[Bind.bind, IO.FS.realPath, Unit.unit, IO, Lean.Name, Pure.pure, IO.currentDir]]
[Mathlib.Tactic.Lint.LintVerbosity.ofNat_toCtorIdx,[Eq.refl, Mathlib.Tactic.Lint.LintVerbosity.low, Mathlib.Tactic.Lint.LintVerbosity.medium, Mathlib.Tactic.Lint.LintVerbosity.high]]
[Lean.Lsp.instToJsonDiagnosticTag,[Lean.ToJson.mk, Unit.unit, Lean.Json, Lean.Json.num, Lean.JsonNumber.fromNat, OfNat.ofNat]]
[Lean.Lsp.instToJsonLineRange,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.LineRange.start, List.nil, Lean.Lsp.LineRange.end]]
[right_identity,[Eq]]
[Lean.ReducibilityStatus.noConfusionType,[noConfusionTypeEnum, Lean.ReducibilityStatus.toCtorIdx]]
[Lean.Name.mkNum,[Lean.Name.num, mixHash, Hashable.hash, dite, LT.lt, UInt64.size, UInt64.ofNatCore, OfNat.ofNat, Lean.Name.mkNum.proof_1]]
[Lean.Widget.instInhabitedInteractiveHypothesis,[Inhabited.mk, Lean.Widget.InteractiveHypothesis.mk, arbitrary]]
[Lean.ClassState.switch,[Lean.ClassState.mk, Lean.SMap.switch, Lean.ClassState.hasOutParam]]
[Decidable.not_imp_not,[Iff.intro, Decidable.by_contradiction, mt]]
[Lean.Lsp.instFromJsonSaveOptions,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Bool, Pure.pure, Lean.Lsp.SaveOptions.mk]]
[Lean.Lsp.PublishDiagnosticsParams.diagnostics,[]]
[neg_neg,[neg_eq_of_add_eq_zero, add_left_neg]]
[Lean.Elab.DefView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.DefView.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Option.format,[Unit.unit, Std.Format, Std.Format.text, HAppend.hAppend, Std.ToFormat.format]]
[Lean.Parser.Tactic.renameI,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[mul_inv_cancel_right,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Inv.inv, mul_assoc, mul_right_inv, OfNat.ofNat, mul_one, rfl]]
[Lean.ConstructorVal.isUnsafeEx,[Lean.ConstructorVal.isUnsafe]]
[List.cons_subset_cons,[Or.elim, List.eq_or_mem_of_mem_cons, Or.inl, Or.inr]]
[List.repeat,[Unit.unit, List, List.nil, List.cons, PProd.fst]]
[Lean.Parser.Command.printAxioms.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.ident.parenthesizer]]
[Lean.Elab.Frontend.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[hexDigitRepr,[String.singleton, Nat.digitChar]]
[IO.FS.Stream.writeLspResponseError,[IO.FS.Stream.writeLspMessage, Lean.JsonRpc.Message.responseError, Lean.JsonRpc.ResponseError.id, Lean.JsonRpc.ResponseError.code, Lean.JsonRpc.ResponseError.message, Option.none]]
[Lean.Expr.withAppAux,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, PProd.fst, Array.set!, HSub.hSub, OfNat.ofNat]]
[DoResultPR.pure.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.UnexpandM,[EStateM, Unit]]
[Lean.Parser.Command.deriving.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.derivingClasses.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.ident.formatter, Bool.false]]
[Lean.Elab.Term.instInhabitedState,[Inhabited.mk, Lean.Elab.Term.State.mk, arbitrary]]
[Lean.Parser.ParserState.replaceLongest,[Lean.Parser.ParserState.keepLatest]]
[Lean.Syntax.setAtomVal,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.atom]]
[Lean.Parser.ParserCache.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Std.mkHashSetImp.proof_1,[Eq.mpr, Eq.refl, GT.gt, Array.size, Array.mkArray, ite, Eq, OfNat.ofNat, List.nil, Array.size_mkArray, of_decide_eq_true, Bool.true, Eq.symm, Nat.zero_lt_succ]]
[Lean.Elab.Term.Do.Code.joinpoint.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Code.joinpoint, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.addDefaultInstanceEntry,[Unit.unit, Lean.Meta.DefaultInstances, Lean.NameMap.find?, Lean.Meta.DefaultInstances.defaultInstances, Lean.Meta.DefaultInstanceEntry.className, Lean.Meta.DefaultInstances.mk, Lean.NameMap.insert, List.cons, Prod.mk, Lean.Meta.DefaultInstanceEntry.instanceName, Lean.Meta.DefaultInstanceEntry.priority, Lean.Meta.DefaultInstances.priorities, List.nil]]
[Lean.Meta.Closure.MkValueTypeClosureResult.mk.inj,[And.intro]]
[Lean.MetavarContext.levelMVarToParam,[Lean.MetavarContext.UnivMVarParamResult, Lean.MetavarContext.UnivMVarParamResult.mk, Lean.MetavarContext.LevelMVarToParam.State.mctx, Lean.MetavarContext.LevelMVarToParam.State.paramNames, Lean.MetavarContext.LevelMVarToParam.State.nextParamIdx]]
[CommSemiring.noConfusionType,[]]
[Lean.ExportM,[StateT, Lean.Export.State, Lean.Core.CoreM]]
[Lean.PrettyPrinter.Delaborator.delabLam,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.PrettyPrinter.Delaborator.SubExpr.withBindingDomain, Lean.PrettyPrinter.Delaborator.delab, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPFunBinderTypes, Lean.getPPExplicit, Pure.pure, Array.any, Lean.PrettyPrinter.Delaborator.hasIdent, Lean.Syntax.getId, OfNat.ofNat, Array.size, ite, Eq, not, Bool.true, Unit.unit, Lean.BinderInfo.auxDecl, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Lean.Expr.binderInfo, GT.gt, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Array.get!, Array.append, List.nil, Array.eraseIdx, Array.back, Lean.Syntax.atom, panicWithPosWithDecl]]
[WellFounded.fix_eq,[WellFounded.fixFEq, WellFounded.apply]]
[ST.Ref.ptrEq,[liftM, ST.Prim.Ref.ptrEq]]
[Lean.Syntax.isStrLit?,[Option.none, Option, String, Lean.Syntax.isLit?, Lean.strLitKind, Lean.Syntax.decodeStrLit]]
[Std.RBNode.any,[Unit.unit, Bool, Bool.false, or, PProd.fst, PProd.snd]]
[Nat.le_antisymm,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Eq, rfl, absurd, Nat.lt_of_le_of_lt, Nat.lt_irrefl]]
[Lean.Syntax.decodeQuotedChar,[OptionM.run, ite, Eq, BEq.beq, Char.ofNat, Bool.true, Pure.pure, Prod.mk, Bind.bind, and, Decidable.decide, LE.le, Option.some, HSub.hSub, Char.toNat, HAdd.hAdd, OfNat.ofNat, Option.none, OptionM, Prod, Char, String.Pos, HMul.hMul]]
[Lean.Parser.nonReservedSymbolFn,[Lean.Parser.nonReservedSymbolFnAux, HAppend.hAppend]]
[Lean.matchConst,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.Environment.find?]]
[instSemiringFin.proof_8,[Eq.mpr, congr, congrArg, Eq, Fin.nsmuls_eq, Nat.succ, HAdd.hAdd, Eq.trans, Fin.mk, HMod.hMod, HMul.hMul, Fin.val, Nat.mod_lt, Fin.size_positive', Fin.add_def, Fin.mk.injEq, Fin.size_positive, Nat.add_mod_mod, Nat.succ_mul, Nat.add_comm]]
[Lean.Elab.Term.throwInvalidNamedArg,[Lean.withRef, Lean.Elab.Term.NamedArg.ref, Unit.unit, Lean.Elab.Term.TermElabM, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.Term.NamedArg.name]]
[Lean.Elab.Term.Do.CodeBlock.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.CodeBlock.mk, Eq.symm, eq_of_heq, HEq.refl]]
[IO.FS.Stream.readLspResponseAs,[MonadExcept.tryCatch, Bind.bind, Unit.unit, IO, Nat, List.lookup, String.toNat?, Pure.pure, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, IO.FS.Stream.readResponseAs]]
[List.leftpad,[HAppend.hAppend, List.repeat, HSub.hSub, List.length]]
[Lean.Parser.ParserContext.tokens,[]]
[Lean.Elab.Term.Do.JPDecl.mk.inj,[And.intro]]
[Fin.coeToNat,[Coe.mk, Fin.val]]
[Lean.Meta.simpLocalDecl,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getLocalDecl, Lean.Meta.instantiateMVars, Lean.LocalDecl.type, Lean.Meta.simpStep, Lean.mkFVar, Unit.unit, Lean.Meta.MetaM, Option, Prod, Lean.FVarId, Lean.MVarId, Pure.pure, Option.none, ite, Eq, bne, Bool.true, Lean.Meta.assert, Lean.LocalDecl.userName, Lean.Meta.tryClear, Lean.LocalDecl.fvarId, Lean.Meta.intro1P, Option.some, Prod.mk]]
[Lean.MessageData.instCoeLevelMessageData,[Coe.mk, Lean.MessageData.ofLevel]]
[Lean.Meta.Closure.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Closure.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.CollectPatternVars.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.instInhabitedException,[Inhabited.mk, Lean.Exception.error, arbitrary]]
[Lean.Meta.intro1Core,[Bind.bind, Lean.Meta.introNCore, OfNat.ofNat, List.nil, Bool.false, Lean.Meta.MetaM, Prod, Lean.FVarId, Lean.MVarId, Pure.pure, Prod.mk, Array.get!]]
[UInt64.instSemiringUInt64.proof_8,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt64.one_def, UInt64.mul_def, UInt64.mk, OfNat.ofNat, mul_one, UInt64.val, UInt64.mk_val_eq, eq_self, propext, forall_const, UInt64]]
[Lean.Meta.isExprMVarAssigned,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.isExprAssigned]]
[UInt8.one_def,[rfl]]
[Lean.instBEqLocalInstance,[BEq.mk, BEq.beq, Lean.LocalInstance.fvar]]
[bfix4,[PProd.fst]]
[Subtype.instSetoidSubtype,[Setoid.mk, HasEquiv.Equiv, Subtype.equivalence]]
[Lean.IR.EmitC.getModName,[Functor.map, Lean.IR.EmitC.Context.modName, MonadReader.read]]
[List.mem_cons_self,[Or.inl, rfl]]
[Equiv.refl.proof_1,[rfl]]
[Lean.mkLevelParamEx,[Lean.mkLevelParam]]
[Lean.Parser.withResultOf,[Lean.Parser.Parser.mk, Lean.Parser.withResultOfInfo, Lean.Parser.Parser.info, Lean.Parser.withResultOfFn, Lean.Parser.Parser.fn]]
[Lean.instToExprString,[Lean.ToExpr.mk, Lean.mkStrLit, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Lean.Elab.Command.ElabHeaderResult.view,[]]
[Lean.Elab.Command.elabAuxDef,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Option.some, Lean.Elab.throwUnsupportedSyntax]]
[Nat.le_of_mod_lt,[Decidable.byContradiction]]
[System.FilePath.instDivFilePath,[Div.mk, System.FilePath.join]]
[Lean.instInhabitedKVMap,[Inhabited.mk, Lean.KVMap.mk, arbitrary]]
[Lean.Parser.isValidSyntaxNodeKind,[Std.PersistentHashMap.contains]]
[Lean.Parser.Attr.toAdditiveIgnoreArgs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[mkStdGen,[StdGen.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Elab.Term.NamedArg.mk.inj,[And.intro]]
[Lean.Meta.SynthInstance.MkTableKey.State.mk.inj,[And.intro]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.noConfusionType,[]]
[Lean.Meta.Match.MkMatcherInput.mk.inj,[And.intro]]
[Lean.KernelException.other.injEq,[Eq.propIntro, Eq.refl, Lean.KernelException.other, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.EmitC.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Expr.mdataExpr!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Lean.Expr, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Meta.instInhabitedCaseValueSubgoal,[Inhabited.mk, Lean.Meta.CaseValueSubgoal.mk, arbitrary]]
[Lean.Lsp.DiagnosticWith.fullRange,[]]
[Lean.Elab.Term.Do.ToTerm.mkJoinPoint,[Lean.withRef, Lean.MonadQuotation.withFreshMacroScope, Bind.bind, Array.mapM, Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax, ite, Eq, Bool.true, Lean.mkIdentFromRef, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadReader.read, Array.append, Array.map, Array.zip, Lean.Elab.Term.Do.ToTerm.Context.m]]
[Lean.Level.updateSucc!.proof_1,[rfl]]
[Lean.Widget.GetInteractiveDiagnosticsParams.lineRange?,[]]
[Lean.Lsp.instFromJsonDidOpenTextDocumentParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentItem, Pure.pure, Lean.Lsp.DidOpenTextDocumentParams.mk]]
[instToFormatArray,[Std.ToFormat.mk, HAppend.hAppend, Std.Format.text, Std.ToFormat.format, Array.toList]]
[Lean.Meta.map1MetaM,[controlAt, Lean.Meta.MetaM, MonadControlT.stM]]
[Lean.defaultMaxRecDepth,[OfNat.ofNat]]
[Std.PersistentArray.noConfusionType,[]]
[decide_false_eq_false,[Eq, Decidable.decide, False, Bool.false, rfl, False.elim]]
[Lean.Parsec.attempt,[Lean.Parsec.ParseResult, Lean.Parsec.ParseResult.success, Lean.Parsec.ParseResult.error]]
[List.product,[List.bind, List.map, Prod.mk]]
[Lean.termEval_prio_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[SizeOfRef,[Measure, SizeOf.sizeOf]]
[Lean.Elab.Tactic.closeUsingOrAdmit,[Bind.bind, Lean.Elab.Tactic.getUnsolvedGoals, List.nil, Lean.Elab.Tactic.TacticM, Unit, MonadExcept.tryCatch, Lean.Elab.Tactic.focusAndDone, Lean.Elab.logException, liftM, Lean.Elab.admitGoal, Lean.Elab.Tactic.setGoals, Lean.Elab.Tactic.throwNoGoalsToBeSolved]]
[Lean.Compiler.NumScalarTypeInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MetavarContext.incDepth,[Lean.MetavarContext.mk, HAdd.hAdd, Lean.MetavarContext.depth, OfNat.ofNat, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Lean.MetavarContext.decls, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment]]
[Lean.AttributeImplCore.applicationTime,[]]
[Lean.Parser.registerAliasCore,[Bind.bind, liftM, IO.initializing, ite, Eq, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, coe]]
[Lean.IR.instBEqArg,[BEq.mk, Lean.IR.Arg.beq]]
[Lean.Elab.Command.CommandElabCoreM,[ReaderT, Lean.Elab.Command.Context, StateRefT', IO.RealWorld, Lean.Elab.Command.State, EIO]]
[Lean.PrettyPrinter.Formatter.decQuotDepth.formatter,[]]
[ByteArray.isEmpty,[BEq.beq, ByteArray.size, OfNat.ofNat]]
[Lean.Parser.Term.funSimpleBinder.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.lookahead.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.simpleBinder.formatter]]
[Lean.PersistentEnvExtension.noConfusionType,[]]
[Set.insertUnexpander,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesIdent, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, Unit.unit]]
[Char.toString,[String.singleton]]
[Lean.explicitBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.bracketedExplicitBinders, Lean.unbracketedExplicitBinders]]
[left_comm,[]]
[Lean.Elab.PreDefinition.type,[]]
[MProd.snd,[]]
[add_right_cancel_iff,[Iff.intro, add_right_cancel, rfl]]
[Lean.Syntax.getHeadInfo,[Unit.unit, Lean.SourceInfo, Lean.Syntax.getHeadInfo?, Lean.SourceInfo.none]]
[Lean.Elab.Term.Do.Alt.noConfusionType,[]]
[max_eq_right,[Eq.mpr, Eq.refl, Eq, max, Eq.symm, max_comm, max_eq_left]]
[iff_false_intro,[Iff.intro, False.elim]]
[Subtype.instDecidableEqSubtype.proof_1,[rfl]]
[Lean.Level.Data.hasMVar,[BEq.beq, UInt64.land, UInt64.shiftRight, OfNat.ofNat]]
[Lean.Lsp.Trace.hasToJson,[Lean.ToJson.mk, Unit.unit, Lean.Json, Lean.Json.str]]
[USize.mod,[USize.mk, HMod.hMod, USize.val]]
[StateT.map,[Bind.bind, Prod, Pure.pure, Prod.mk]]
[Classical.epsilon,[Subtype.val, Classical.strongIndefiniteDescription]]
[Lean.EnvironmentHeader.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.EnvironmentHeader.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Prod.mk.inj_left,[And.right, Prod.mk.inj]]
[Lean.Expr.updateForall!.proof_1,[rfl]]
[Lean.Lsp.instInhabitedDiagnosticSeverity,[Inhabited.mk, Lean.Lsp.DiagnosticSeverity.error]]
[Nat.gcd_eq_zero_iff,[Iff.intro, And.intro, Nat.eq_zero_of_gcd_eq_zero_left, Nat.eq_zero_of_gcd_eq_zero_right, Eq.mpr, Eq.refl, Eq, Nat.gcd, OfNat.ofNat, And.left, And.right, Nat.gcd_zero_right]]
[Lean.Parser.Tactic.Conv.convErw_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq]]
[Lean.Lsp.WorkDoneProgressBegin.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.WorkDoneProgressBegin.mk, Eq.symm, eq_of_heq, HEq.refl]]
[List.getLast!,[Unit.unit, panicWithPosWithDecl, OfNat.ofNat, List.getLast, List.cons, List.getLast!.proof_1]]
[instInhabitedPNonScalar,[Inhabited.mk, PNonScalar.mk, arbitrary]]
[Lean.expandExplicitBindersAux,[Array.size, Lean.expandExplicitBindersAux.loop]]
[Lean.unifConstraintElem,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.unifConstraint, Lean.ParserDescr.unary, Lean.ParserDescr.symbol]]
[Subtype.eta,[rfl, Eq.symm, Eq.refl]]
[Lean.Parser.Command.whereStructInst.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1Indent.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.Command.whereStructField.parenthesizer, Lean.Parser.optional.parenthesizer]]
[instOrdBool,[Ord.mk, Bool.false, Unit.unit, Bool.true, Ordering, Ordering.lt, Ordering.gt, Ordering.eq]]
[MonadLift.monadLift,[]]
[Lean.ParserDescr.noConfusionType,[]]
[Lean.Meta.caseValue,[Bind.bind, Lean.Meta.withMVarContext, Lean.Meta.getMVarTag, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType, Lean.Meta.mkEq, Lean.mkFVar, Lean.Meta.foldPatValue, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.mkAppOptM, List.toArray, List.cons, Option.none, Option.some, List.nil, Lean.Meta.assignExprMVar, Lean.Meta.intro1P, Lean.Expr.mvarId!, Lean.Meta.MetaM, Prod, Lean.Meta.CaseValueSubgoal, Lean.Meta.substCore, Bool.false, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, List.map, Lean.FVarId.name, Lean.Meta.FVarSubst.domain, Pure.pure, PUnit.unit, Prod.mk, Lean.Meta.FVarSubst.mk, Lean.Meta.appendTagSuffix, Lean.Meta.CaseValueSubgoal.mvarId, Prod.fst, Prod.snd]]
[USize.instRingUSize.proof_5,[USize.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, USize.val, congrFun, HAdd.hAdd, USize.neg_def, USize.add_def, USize.mk, Neg.neg, add_left_neg, USize.zero_def, eq_self, OfNat.ofNat]]
[Lean.getExportNameFor,[Lean.ParametricAttribute.getParam, Lean.exportAttr]]
[Lean.IR.NormalizeIds.M,[ReaderT, Lean.IR.IndexRenaming, Id]]
[Subtype.coe_mk,[rfl]]
[Lean.Meta.SimpLemmas.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SimpLemmas.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.termReturn,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, Lean.Parser.withPosition, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.checkLineEq, Lean.Parser.termParser, OfNat.ofNat]]
[UInt8.lt,[LT.lt, UInt8.val]]
[Lean.Meta.getStructureName,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Lean.Name, Lean.Expr.getAppFn, Bind.bind, Lean.MonadEnv.getEnv, ite, Eq, Lean.isStructure, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.Occurrences.contains,[Bool, Bool.true, List.contains, not]]
[Lean.IR.EmitC.leanMainFn,[]]
[Lean.Meta.Cases.Context.majorTypeIndices,[]]
[Lean.Lsp.instToJsonInitializeParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Lsp.InitializeParams.processId?, Lean.Lsp.InitializeParams.clientInfo?, Lean.Lsp.InitializeParams.rootUri?, Lean.Lsp.InitializeParams.initializationOptions?, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.InitializeParams.capabilities, List.nil, Lean.Lsp.InitializeParams.trace, Lean.Lsp.InitializeParams.workspaceFolders?]]
[Lean.Parser.Tactic.nativeDecide,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.nonReservedSymbol, Bool.false]]
[Lean.KeyedDeclsAttribute.ext,[]]
[Lean.Meta.SynthInstance.SynthM,[ReaderT, Lean.Meta.SynthInstance.Context, StateRefT', IO.RealWorld, Lean.Meta.SynthInstance.State, Lean.Meta.MetaM]]
[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.toPos,[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.curr]]
[Tactic.LibrarySearch.«termLibrarySearch%»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Lean.Elab.Term.getDeclName?,[Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Term.Context.declName?]]
[String.splitOn,[ite, Eq, BEq.beq, Bool.true, List.cons, List.nil, String.splitOnAux, OfNat.ofNat]]
[Lean.IR.ExplicitBoxing.BoxingContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.andthenInfo,[Lean.Parser.ParserInfo.mk, Function.comp, Lean.Parser.ParserInfo.collectTokens, Lean.Parser.ParserInfo.collectKinds, Lean.Parser.FirstTokens.seq, Lean.Parser.ParserInfo.firstTokens]]
[Lean.Elab.Tactic.evalAssumption,[Lean.Elab.Tactic.liftMetaTactic, Bind.bind, Lean.Meta.assumption, Pure.pure, List.nil]]
[Lean.instReprMVarId,[Repr.mk, Repr.reprPrec, Lean.MVarId.name]]
[Lean.Syntax.isLit?,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Option, String, ite, Eq, and, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Syntax.node, Array.get!, Option.some, Option.none]]
[WellFounded.apply,[WellFounded.apply.proof_1]]
[Lean.Parsec.digit,[Lean.Parsec.attempt, Bind.bind, Lean.Parsec.anyChar, ite, And, LE.le, Char.ofNat, Pure.pure, Lean.Parsec.fail, ToString.toString]]
[List.length',[Unit.unit, Nat, OfNat.ofNat, Nat.succ, PProd.fst]]
[Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer,[]]
[Nat.add_left_cancel_iff,[Iff.intro, Nat.add_left_cancel, Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Eq, HAdd.hAdd, rfl]]
[Lean.Meta.FVarSubst.empty,[Lean.Meta.FVarSubst.mk]]
[Hashable.noConfusionType,[]]
[Lean.Parser.isQuotableCharForStrInterpolant,[or, BEq.beq, Char.ofNat, Lean.Parser.isQuotableCharDefault]]
[Std.Format.MonadPrettyFormat.startTag,[]]
[Lean.Meta.SimpLemmas.addDeclToUnfold,[Lean.Meta.SimpLemmas.mk, Lean.Meta.SimpLemmas.pre, Lean.Meta.SimpLemmas.post, Lean.Meta.SimpLemmas.lemmaNames, Std.PersistentHashSet.insert, Lean.Meta.SimpLemmas.toUnfold, Lean.Meta.SimpLemmas.erased]]
[Lean.termThrowError__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[Lean.Elab.CompletionInfo.id.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.pow_le_pow_of_le_right,[LE.le, HPow.hPow, Nat.succ, Nat.lt_or_eq_or_le_succ, Nat.le_refl, Eq.symm]]
[Lean.Parser.Tactic.decide,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.nonReservedSymbol, Bool.false]]
[Lean.Lsp.DocumentSymbolAux.noConfusionType,[]]
[Lean.Parser.checkLineEqFn,[Unit.unit, Lean.Parser.ParserState, Lean.Parser.ParserContext.savedPos?, ite, Eq, BEq.beq, Lean.Position.line, Bool.true, Lean.Parser.ParserState.mkError]]
[Lean.IR.CollectMaps.collectParams,[Array.foldl, Lean.IR.CollectMaps.collectVar, Lean.IR.Param.x, Lean.IR.Param.ty, OfNat.ofNat, Array.size]]
[MonadLiftT.noConfusionType,[]]
[ReaderT.adapt,[]]
[Lean.Parser.Tactic.truncCases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.binderIdent]]
[cond,[Unit.unit]]
[Lean.Lsp.PlainGoalParams.toTextDocumentPositionParams,[]]
[Nat.sub_lt_sub_left,[Eq.refl, Nat.zero, HEq.refl, LT.lt, HSub.hSub, Eq.mpr, HAdd.hAdd, OfNat.ofNat, Nat.add_sub_add_right, Nat.lt_succ_of_le, Nat.sub_le, PProd.fst, Nat.lt_of_succ_lt_succ]]
[Lean.Elab.Term.registerSyntheticMVar,[modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, List.cons, Lean.Elab.Term.SyntheticMVarDecl.mk, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState]]
[Lean.IR.AltCore.body,[Lean.IR.FnBody]]
[Lean.Elab.Level.Context.ref,[]]
[Lean.Occurrences.pos.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Setoid.symm,[Equivalence.symm, Setoid.iseqv]]
[Lean.Meta.mkFreshLevelMVar,[Bind.bind, Lean.mkFreshMVarId, Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.addLevelMVarDecl, Pure.pure, Lean.mkLevelMVar]]
[Lean.Lsp.TextDocumentRegistrationOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.Formatter.pushTokenCore,[ite, Eq, BEq.beq, Substring.dropRightWhile, String.toSubstring, Char.ofNat, Bool.true, Lean.PrettyPrinter.Formatter.push, Std.Format.text, Bind.bind, Lean.PrettyPrinter.Formatter.pushLine, String.trimRight]]
[instHShiftLeft,[HShiftLeft.mk, ShiftLeft.shiftLeft]]
[Lean.Parser.Tactic.tidy,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.Command.elabEnd,[Bind.bind, Lean.Elab.Command.getScopes, ite, LT.lt, List.length, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, List.drop, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, ForIn.forIn, PUnit.unit, Lean.popScope, Pure.pure, ForInStep.yield, MonadState.get, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.Json.CompressWorkItem.arrayElem.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Simp.SimpLetCase.nondepDepVar.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Tactic.evalIntros,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Lean.Elab.Tactic.liftMetaTactic, Bind.bind, Lean.Meta.intros, Lean.Meta.MetaM, List, Lean.MVarId, Pure.pure, List.cons, List.nil, Lean.Meta.introN, Array.size, Array.toList, Array.map, Lean.Elab.Tactic.getNameOfIdent', Bool.false, Lean.Elab.throwUnsupportedSyntax]]
[IO.FS.SystemTime.nsec,[]]
[Nat.mul_sub_right_distrib,[Eq, HMul.hMul, HSub.hSub, of_eq_true, Eq.trans, congr, congrArg, congrFun, Nat.sub_zero, Nat.zero_mul, eq_self, Eq.mpr, Eq.refl, HAdd.hAdd, OfNat.ofNat, Nat.sub_succ, Nat.pred, Nat.mul_pred_left, PProd.fst, Nat.succ_mul, Nat.sub_sub, rfl]]
[Lean.instInhabitedLocalContext,[Inhabited.mk, Lean.LocalContext.mk, arbitrary]]
[Lean.Meta.UnificationHintEntry.mk.inj,[And.intro]]
[Lean.Lsp.PublishDiagnosticsParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.PublishDiagnosticsParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Command.StructFieldView.rawName,[]]
[Quot.liftOn,[Quot.lift]]
[Lean.Parser.Term.strictImplicitLeftBracket,[HOrElse.hOrElse, Lean.Parser.atomic, Lean.Parser.group, HAndThen.hAndThen, Lean.Parser.symbol]]
[Nat.le_of_mul_le_mul_left,[Iff.mp, not_lt, Iff.mpr, not_le, Nat.mul_lt_mul_of_pos_left]]
[Lean.Meta.withLetDecl,[Lean.Meta.map1MetaM, Bind.bind, Lean.mkFreshFVarId, MonadReader.read, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.localInstances, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth, Lean.Meta.isClass?, Unit.unit, Lean.Meta.MetaM, Lean.Meta.withNewLocalInstance]]
[Lean.JsonNumber.toString,[dite, Eq, Eq.symm, String, Int.repr, HAppend.hAppend, ToString.toString]]
[Lean.Meta.CongrLemma.noConfusionType,[]]
[Lean.Lsp.CancelParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.mkAppB,[Lean.mkApp]]
[and_true,[propext, Iff.intro, And.left, And.intro, trivial]]
[Lean.Expr.updateLambda,[Lean.mkLambda, Lean.Expr.bindingName!]]
[Nat.sub_induction,[PProd.fst]]
[Lean.Meta.instInhabitedCache,[Inhabited.mk, Lean.Meta.Cache.mk, arbitrary]]
[UInt64.instSemiringUInt64.proof_12,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HMul.hMul, UInt64.add_def, UInt64.mul_def, UInt64.mk, HAdd.hAdd, UInt64.val, UInt64.eq_of_val_eq, Semiring.add_mul]]
[false_of_true_iff_false,[Iff.mp, trivial]]
[Lean.Parser.Tactic.inductionAlts,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlt]]
[Lean.Meta.Match.Pattern.ctor.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.refl, List.nil, Eq.trans, Eq.symm, List.cons.sizeOf_spec]]
[Task.Priority.dedicated,[OfNat.ofNat]]
[Lean.Declaration.quotDecl.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Tactic.ElimApp.Result.noConfusionType,[]]
[Lean.Parser.instBEqLeadingIdentBehavior,[BEq.mk, BEq.beq, Lean.Parser.LeadingIdentBehavior.toCtorIdx]]
[List.decidableBexi.proof_3,[False]]
[Lean.Elab.Term.StructInst.findField?,[List.find?, List.nil, List.cons, Lean.Elab.Term.StructInst.FieldLHS.fieldName, Lean.Elab.Term.StructInst.FieldLHS.fieldIndex, Lean.Elab.Term.StructInst.FieldLHS.modifyOp, Bool, Lean.Elab.Term.StructInst.Field.lhs, BEq.beq, Bool.false]]
[Lean.Widget.Lean.Widget.CodeToken.instToJsonRpcEncodingPacket,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil]]
[Lean.Elab.Term.Do.elabDo,[Bind.bind, Lean.Elab.Term.tryPostponeIfNoneOrMVar, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Elab.Term.ExtractMonadResult, Lean.throwError, Lean.ToMessageData.toMessageData, liftM, Pure.pure, HAppend.hAppend, Lean.indentExpr, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, List.nil, Lean.Meta.inferType, Lean.Elab.Term.elabTerm, Option.some, Bool.true, Lean.Meta.assignExprMVar, Lean.Expr.mvarId!, Lean.Elab.Term.ExtractMonadResult.m, Lean.Elab.Term.Do.ToCodeBlock.run, Lean.Elab.liftMacroM, Lean.Elab.Term.Do.ToTerm.run, Lean.Elab.Term.Do.CodeBlock.code, Lean.Elab.Term.Do.ToTerm.Kind.regular, Lean.isTracingEnabledFor, ite, Eq, Lean.addTrace, Lean.MessageData.ofSyntax, PUnit.unit]]
[Lean.KernelException.typeExpected.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.typeExpected, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.DiscrTree.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.DiscrTree.mk, Eq.symm, eq_of_heq, HEq.refl]]
[instToStringString,[ToString.mk]]
[Lean.IR.instToStringFnBody,[ToString.mk, Std.Format.pretty, Std.ToFormat.format, Std.Format.defWidth]]
[Lean.Parser.Tactic.continuity!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.ElimEmptyInductive.instMonadBacktrackSavedStateM,[Lean.MonadBacktrack.mk, liftM, Lean.Meta.saveState, Lean.Meta.SavedState.restore]]
[Lean.Parser.Parser.info,[]]
[String.toFileMap,[Lean.FileMap.ofString]]
[Lean.Meta.Contradiction.Config.noConfusionType,[]]
[PSigma.lexNdep,[PSigma.Lex]]
[Lean.Meta.ApplyNewGoals.all.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.EnvExtensionInterface.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.EnvExtensionInterface.mk, Eq.symm, eq_of_heq, HEq.refl, Lean.Environment, IO, Inhabited]]
[Lean.IR.Checker.CheckerContext.noConfusionType,[]]
[Lean.Elab.Term.mkTermInfo,[Bind.bind, Unit.unit, Lean.Elab.Term.TermElabM, Sum, Lean.Elab.Info, Lean.MVarId, Pure.pure, Sum.inr, Lean.MonadLCtx.getLCtx, Sum.inl, Lean.Elab.Info.ofTermInfo, Lean.Elab.TermInfo.mk, Lean.Elab.ElabInfo.mk, Option.getD]]
[Lean.Meta.Simp.Step.visit.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Simp.Step.visit, Eq.symm, eq_of_heq, HEq.refl]]
[Inhabited.default,[]]
[Lean.IR.instToFormatExpr,[Std.ToFormat.mk, Std.Format, HAppend.hAppend, Std.ToFormat.format, Lean.IR.formatArray, Std.Format.text, ite, Eq, Bool.true]]
[Std.HashSet.toList,[Std.HashSet.fold, List.cons, List.nil]]
[Lean.ConstructorVal.isUnsafe,[]]
[Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer,[Pure.pure, Unit.unit]]
[Std.Format.indentD,[Std.Format.nestD, HAppend.hAppend, Std.Format.line]]
[UInt8.ofNat,[UInt8.mk, Fin.ofNat]]
[Lean.Syntax.isEscapedAntiquot,[not, Array.isEmpty, Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Meta.isUIntPatLit?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Prod, Lean.Name, Lean.Expr, ite, and, Array.contains, List.toArray, List.cons, Lean.Name.mkStr, List.nil, Lean.Meta.isFinPatLit, Bool.true, Option.some, Prod.mk, Lean.Expr.appArg!, Option.none]]
[ReaderT.instMonadReaderT,[Monad.mk]]
[Lean.Parser.Term.funBinder.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.PrettyPrinter.Parenthesizer.evalInsideQuot.parenthesizer, Lean.Parser.Term.funBinder.parenthesizer]]
[Mathlib.Tactic.Lint.LintVerbosity.ofNat,[cond, Nat.ble, Nat.beq, Mathlib.Tactic.Lint.LintVerbosity.medium, Mathlib.Tactic.Lint.LintVerbosity.high, Mathlib.Tactic.Lint.LintVerbosity.low]]
[Lean.Parser.Tactic.Conv.«convEnter[__]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.ParserDescr.const, Lean.Parser.Tactic.Conv.enterArg]]
[Int.neg,[Int, Int.negOfNat, Int.ofNat, Nat.succ]]
[Lean.Lsp.DidOpenTextDocumentParams.textDocument,[]]
[Lean.Meta.CaseValueSubgoal.noConfusionType,[]]
[Lean.Parser.Tactic.applyWith,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[Lean.Meta.TransparencyMode.noConfusionType,[noConfusionTypeEnum, Lean.Meta.TransparencyMode.toCtorIdx]]
[Lean.Elab.Term.LetRecDeclView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LetRecDeclView.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.markSmartUnfoldingMatch,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Expr.FoldConstsImpl.FoldM,[StateM, Lean.Expr.FoldConstsImpl.State]]
[Lean.Parser.checkLinebreakBefore,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.checkLinebreakBeforeFn]]
[Lean.Parser.Syntax.paren.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.syntaxParser.formatter]]
[Lean.Elab.Term.LValResolution.noConfusionType,[]]
[Lean.Meta.Match.Example.noConfusionType,[]]
[Array.instToStringArray,[ToString.mk, HAppend.hAppend, ToString.toString, Array.toList]]
[instReprExcept,[Repr.mk, Std.Format, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg]]
[Std.PersistentArrayNode.node.inj,[]]
[List.maximum?,[Unit.unit, Option, Option.none, Option.some, List.foldl, max]]
[Lean.Server.FileWorker.RpcSession.aliveRefs,[]]
[String.Iterator.prevn,[String.Iterator, PProd.fst, String.Iterator.prev]]
[Lean.getExternEntryForAux,[Unit.unit, Option, Lean.ExternEntry, Option.none, ite, Eq, BEq.beq, Lean.ExternEntry.backend, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Option.some, PProd.fst]]
[Prod.eq_iff_fst_eq_snd_eq,[Iff, Eq, And, Prod.fst, Prod.snd, of_eq_true, Eq.trans, congrFun, congrArg, Prod.mk.injEq, iff_self]]
[Std.AssocList.instEmptyCollectionAssocList,[EmptyCollection.mk, Std.AssocList.empty]]
[Fin.addOverflows?,[Decidable.decide, LE.le, HAdd.hAdd, Fin.val]]
[Int.instInhabitedInt,[Inhabited.mk, Int.ofNat, OfNat.ofNat]]
[Lean.MetavarContext.MkBinding.State.mk.inj,[And.intro]]
[Lean.Elab.Term.LetRecDeclView.shortDeclName,[]]
[Subarray.foldlM,[Array.foldlM, Subarray.as, Subarray.start, Subarray.stop]]
[Lean.instInhabitedInternalExceptionId,[Inhabited.mk, Lean.InternalExceptionId.mk, arbitrary]]
[Lean.Declaration.defnDecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt8.lor,[UInt8.mk, Fin.lor, UInt8.val]]
[Lean.Elab.Term.ToDepElimPattern.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.repr,[List.asString, Nat.toDigits, OfNat.ofNat]]
[IO.Error.fopenErrorToString,[Unit.unit, String, HAppend.hAppend, String.modify, OfNat.ofNat, Char.toLower, ToString.toString]]
[List.zipWith,[List.nil, List.cons, List, PProd.fst]]
[LawfulApplicative.pure_seq,[]]
[Lean.IR.Expr.ap.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.ap, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.ExpandResetReuse.mkProjMap,[Lean.IR.Decl.extern, Lean.IR.ExpandResetReuse.ProjMap, Lean.IR.ExpandResetReuse.CollectProjMap.collectFnBody, EmptyCollection.emptyCollection]]
[Std.AssocList.replace,[Unit.unit, Std.AssocList, Std.AssocList.nil, BEq.beq, Std.AssocList.cons, PProd.fst]]
[Lean.Elab.Tactic.ElabSimpArgsResult.ctx,[]]
[Array.extLit,[Array.ext, Eq.trans, Eq.symm]]
[Lean.Parser.Term.doExpr,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.notFollowedByRedefinedTermToken, Lean.Parser.termParser, Lean.Parser.notFollowedBy, HOrElse.hOrElse, Lean.Parser.symbol]]
[List.cons.inj,[And.intro]]
[Lean.registerLazyInitExtension,[Bind.bind, Lean.registerEnvExtension, Pure.pure, Option.none, Lean.LazyInitExtension.mk]]
[Lean.Meta.cleanup.collectUsed,[Bind.bind, liftM, Lean.Meta.getMVarType', Lean.Meta.cleanup.addUsedFVars, Lean.Meta.cleanup.collectProps, MonadState.get, Pure.pure, Prod.snd]]
[UInt16.lt,[LT.lt, UInt16.val]]
[Lean.Meta.mkCongr,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Meta.mkCongrArg, Lean.Expr.appArg!, Lean.Meta.mkCongrFun, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Option.none, Option.some, Prod.mk, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.eq?, Lean.Expr.arrow?, Lean.Meta.getLevel, Pure.pure, Lean.mkApp8, Lean.mkConst, List.cons, List.nil, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr]]
[Lean.Elab.Term.FunBinders.State.localInsts,[]]
[Lean.Parser.Tactic.filterUpwards,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const]]
[Std.Format.MonadPrettyFormat.noConfusionType,[]]
[Quot.indep,[PSigma.mk, Quot.mk]]
[String.dropRightWhile,[Substring.toString, Substring.dropRightWhile, String.toSubstring]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withLetBody,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.withLetDecl, Lean.PrettyPrinter.Delaborator.SubExpr.descend, OfNat.ofNat, panicWithPosWithDecl]]
[let_value_eq,[rfl]]
[Lean.Elab.Term.Do.ToCodeBlock.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.ToCodeBlock.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Parenthesizer.lookahead.parenthesizer,[Pure.pure, Unit.unit]]
[Lean.Server.FileWorker.noHighlightKinds,[List.toArray, List.cons, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Lean.Parser.Command.openRenaming.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.ident.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.Command.openRenamingItem.formatter, Bool.false]]
[Lean.Parser.Tactic.replace',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser]]
[Lean.Parser.Term.letRecDecls.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.sepBy1.formatter, Lean.Parser.Term.letRecDecl.formatter, Lean.Parser.symbol.formatter, Bool.false]]
[Lean.Parser.ParserExtension.instInhabitedOLeanEntry,[Inhabited.mk, Lean.Parser.ParserExtension.OLeanEntry.token, arbitrary]]
[and_iff_right_iff_imp,[Iff.intro, And.left, Iff.mpr, and_iff_right_of_imp]]
[Lean.Xml.Parser.PubidLiteral,[HOrElse.hOrElse, SeqLeft.seqLeft, SeqRight.seqRight, Lean.Parsec.pchar, Char.ofNat, Lean.Parsec.manyChars, Lean.Xml.Parser.PubidChar, Lean.Parsec.attempt, Bind.bind, ite, Eq, Lean.Parsec.fail, Pure.pure]]
[Lean.Parser.darrow,[Lean.Parser.symbol]]
[Tactic.Ring.Cache.univ,[]]
[Lean.Server.Watchdog.handleEdits,[Bind.bind, ST.Ref.modifyGet, Lean.Server.Watchdog.FileWorker.groupedEditsRef, Prod.mk, Option.none, Lean.Server.Watchdog.ServerM, Unit, Pure.pure, Lean.Lsp.VersionedTextDocumentIdentifier.version?, ite, LE.le, Lean.Server.DocumentMeta.version, Lean.Server.Watchdog.OpenDocument.meta, liftM, IO.throwServerError, PUnit.unit]]
[Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1]]
[Lean.Elab.getBetterRef,[Unit.unit, Lean.Syntax, Lean.Syntax.getPos?, Bool.false, List.find?, bne, Lean.Elab.MacroStackElem.before, Option.none]]
[Lean.Meta.isDefEqOffset,[Bind.bind, Lean.Meta.getConfig, ite, Eq, not, Lean.Meta.Config.offsetCnstrs, Bool.true, Pure.pure, Lean.LBool.undef, Unit.unit, Lean.Meta.MetaM, Lean.LBool, BEq.beq, LT.lt, OfNat.ofNat, Lean.Meta.evalNat, Option.none, Bool, Bool.false, Lean.mkNatLit, Lean.Meta.mkAdd, HSub.hSub, GE.ge, Lean.LBool.false, Bool.toLBool]]
[Lean.Elab.Term.Do.insertVars,[Array.foldl, Lean.NameSet.insert, OfNat.ofNat, Array.size]]
[Lean.Elab.Term.StructInst.DefaultFields.M,[ReaderT, Lean.Elab.Term.StructInst.DefaultFields.Context, StateRefT', IO.RealWorld, Lean.Elab.Term.StructInst.DefaultFields.State, Lean.Elab.Term.TermElabM]]
[Lean.IR.Arg.alphaEqv,[Lean.IR.Arg.var, Lean.IR.Arg.irrelevant, Unit.unit, Bool, Lean.IR.AlphaEqv.aeqv, Bool.true, Bool.false]]
[IO.Process.Stdio.piped.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Expr.ReplaceImpl.State.results,[]]
[Lean.Parser.categoryParserFnImpl,[Unit.unit, Lean.Parser.ParserState, Lean.Parser.getCategory, Lean.Parser.prattParser, Lean.Parser.ParserCategory.tables, Lean.Parser.ParserCategory.behavior, Lean.Parser.Parser.fn, Lean.Parser.mkCategoryAntiquotParser, Lean.Parser.ParserState.mkUnexpectedError, HAppend.hAppend, ToString.toString, List.nil]]
[Lean.Json.getInt?,[Lean.Json.null, Lean.Json.bool, dite, Eq, Eq.symm, Lean.Json.num, Lean.JsonNumber.mk, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Except, String, Int, Pure.pure, MonadExcept.throw]]
[Lean.Elab.Term.LetRecToLift.lctx,[]]
[Function.involutive.ite_not,[Eq.mpr, Eq.refl, Eq, ite, Not, apply_ite, ite_not, rfl]]
[Lean.Elab.Frontend.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Frontend.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.getStructureLikeNumFields,[Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, dite, Eq, Lean.ConstantInfo.inductInfo, Lean.InductiveVal.mk, Lean.ConstantVal.mk, List.nil, List.cons, Bool.true, Eq.symm, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Nat, Lean.Environment.find?, OfNat.ofNat]]
[gsmul_rec,[nsmul_rec, Neg.neg, Nat.succ]]
[Lean.Meta.withAssignableSyntheticOpaque,[Lean.Meta.withConfig, Lean.Meta.Config.mk, Lean.Meta.Config.foApprox, Lean.Meta.Config.ctxApprox, Lean.Meta.Config.quasiPatternApprox, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Bool.true, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct]]
[Std.HashMapImp.buckets,[]]
[Lean.Elab.Command.Scope.mk.inj,[And.intro]]
[Nat.dvd_antisymm,[dite, Eq, Nat.zero, Eq.symm, Nat.succ, Nat.eq_zero_of_zero_dvd, Nat.le_antisymm, Nat.le_of_dvd, Nat.succ_pos]]
[Lean.Elab.Term.elabBinRelCore.toBoolIfNecessary,[ite, Eq, Bool.true, Bind.bind, liftM, Lean.Meta.inferType, Lean.Meta.withNewMCtxDepth, Lean.Meta.isDefEq, Lean.mkSort, Lean.levelZero, Lean.Elab.Term.ensureHasType, Option.some, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Option.none, Pure.pure, PUnit.unit]]
[Lean.Elab.Tactic.Location.targets.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Std.Range.start,[]]
[Int.eq_x_or_neg,[Exists.intro, Int.natAbs, Int.natAbs_eq]]
[Lean.Parser.manyIndent.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.many.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGe.parenthesizer]]
[Lean.IR.Borrow.ParamMap.Key.decl.inj,[]]
[Lean.instInhabitedEnvExtensionInterface,[Inhabited.mk, Lean.EnvExtensionInterface.mk, id, Pure.pure, List.toArray, List.nil]]
[Lean.Widget.InteractiveGoal.noConfusionType,[]]
[String.toLower,[String.map, Char.toLower]]
[Lean.Lsp.DeclarationParams.mk.inj,[]]
[Or.comm,[Iff.intro, Or.symm]]
[Lean.Parser.hexNumberFn,[Lean.Parser.mkNodeToken, Lean.numLitKind]]
[Lean.Elab.TacticInfo.format,[Bind.bind, Lean.Elab.ContextInfo.ppGoals, Lean.Elab.TacticInfo.goalsBefore, Lean.Elab.TacticInfo.goalsAfter, Pure.pure, HAppend.hAppend, Std.ToFormat.format, ite, Eq, Lean.Name.isAnonymous, Lean.Elab.ElabInfo.elaborator, Bool.true, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Std.Format, Lean.Elab.ElabInfo.stx, Lean.Elab.TacticInfo.toElabInfo]]
[«stx_,+»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Lean.Level.mkNaryMax,[Unit.unit, List.cons, Lean.Level, Lean.levelZero, Lean.mkLevelMax', PProd.fst]]
[instOrdInt,[Ord.mk, compareOfLessAndEq]]
[Lean.Expr.FindImpl.visited.proof_2,[lcProof]]
[Lean.LBool.true.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Command.setupTacticParser,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Nat.coprime_one_left,[Nat.gcd_one_left]]
[OptionT.fail,[OptionT.mk, Pure.pure, Option.none]]
[Lean.Elab.Command.instMonadRecDepthCommandElabM,[Lean.MonadRecDepth.mk, MonadWithReader.withReader, Lean.Elab.Command.Context.mk, Lean.Elab.Command.Context.fileName, Lean.Elab.Command.Context.fileMap, Lean.Elab.Command.Context.cmdPos, Lean.Elab.Command.Context.macroStack, Lean.Elab.Command.Context.currMacroScope, Lean.Elab.Command.Context.ref, Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Command.Context.currRecDepth, MonadState.get, Lean.Elab.Command.State.maxRecDepth]]
[Prod.swap_right_inverse,[Prod.swap_swap]]
[Lean.Meta.ToHide.moveToHiddeProp,[modify, Lean.Meta.ToHide.State.mk, Std.RBTree.insert, Lean.Meta.ToHide.State.hiddenInaccessibleProp, Std.RBTree.erase, Lean.Meta.ToHide.State.hiddenInaccessible, Bool.true]]
[Lean.Level.updateMax,[Lean.mkLevelMax']]
[HEq.subst,[HEq.ndrecOn]]
[UInt64.instSemiringUInt64.proof_7,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt64.one_def, UInt64.mul_def, UInt64.mk, OfNat.ofNat, one_mul, UInt64.val, UInt64.mk_val_eq, eq_self, propext, forall_const, UInt64]]
[Lean.PrettyPrinter.Parenthesizer.State.trailCat,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.hasMVarAtCurrDepth,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Option.isSome, Lean.Expr.findMVar?, Option.none, Bool, Lean.MetavarContext.findDecl?, BEq.beq, Lean.MetavarDecl.depth, Lean.MetavarContext.depth, Bool.false]]
[Lean.Meta.mkMul,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getDecLevel, Lean.Meta.synthInstance, Lean.mkApp3, Lean.mkConst, List.cons, List.nil, Option.none, Pure.pure, Lean.mkApp6, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Core.State.env,[]]
[Lean.Elab.Term.Do.ToCodeBlock.doReturnToCode,[Lean.withRef, Bind.bind, Lean.Elab.Term.Do.ToCodeBlock.ensureEOS, ite, Eq, Lean.Syntax.isNone, Bool.true, Lean.Elab.liftMacroM, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Elab.Command.StructFieldInfo.value?,[]]
[Lean.Lsp.instFromJsonServerCapabilities,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, Lean.Lsp.TextDocumentSyncOptions, Lean.Lsp.CompletionOptions, Bool, Lean.Lsp.SemanticTokensOptions, Pure.pure, Lean.Lsp.ServerCapabilities.mk]]
[instAddUInt32,[Add.mk, UInt32.add]]
[Lean.Parser.Term.noindex.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec]]
[Lean.Meta.CheckAssignment.State.mk.inj,[]]
[Lean.Meta.Match.Alt.noConfusionType,[]]
[Lean.Elab.Term.expandMatchAltsWhereDecls,[Array.size, List.toArray, List.nil, Lean.Elab.Term.expandMatchAltsWhereDecls.loop]]
[Lean.IR.findDecl,[Bind.bind, MonadState.get, Pure.pure, Lean.IR.findEnvDecl, Lean.IR.CompilerState.env]]
[Lean.Widget.MsgToInteractive.indent,[]]
[Lean.Expr.isConstructorApp,[Option.isSome, Lean.Expr.isConstructorApp?]]
[Lean.Parser.Command.declaration.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Command.declModifiers.parenthesizer, Bool.false, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.abbrev.parenthesizer, Lean.Parser.Command.def.parenthesizer, Lean.Parser.Command.theorem.parenthesizer, Lean.Parser.Command.constant.parenthesizer, Lean.Parser.Command.instance.parenthesizer, Lean.Parser.Command.axiom.parenthesizer, Lean.Parser.Command.example.parenthesizer, Lean.Parser.Command.inductive.parenthesizer, Lean.Parser.Command.classInductive.parenthesizer, Lean.Parser.Command.structure.parenthesizer]]
[Lean.Parser.Term.doDbgTrace.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.interpolatedStr.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[List.getLast?.proof_1,[]]
[Lean.IR.EmitC.emitSSet,[Unit.unit, Lean.IR.IRType.usize, Lean.IR.IRType.irrelevant, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.struct, Lean.IR.IRType.union, Lean.IR.EmitC.M, Unit, Bind.bind, Lean.IR.EmitC.emit, MonadExcept.throw]]
[Nat.mul_lt_mul_of_pos_right,[Nat.mul_lt_mul_of_pos_left, Nat.mul_comm]]
[Array.extract,[Array.ofSubarray, Array.toSubarray]]
[System.Platform.numBits_eq,[Subtype.property, System.Platform.getNumBits, Unit.unit]]
[Nat.le_of_dvd,[LE.le, Eq.mpr, Eq.refl, HMul.hMul, False.elim, Eq.mp, Eq.trans, congrArg, LT.lt, OfNat.ofNat, Nat.mul_zero, eq_false_of_decide, Bool.false, Nat.succ, Nat.mul_one]]
[Lean.trace,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, Unit.unit, Pure.pure, PUnit.unit]]
[Or.elim,[]]
[Lean.MessageData.bracket,[Lean.MessageData.group, Lean.MessageData.nest, String.length, HAppend.hAppend, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[Lean.Meta.ParamInfo.binderInfo,[]]
[Lean.Meta.TransparencyMode.all.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.withMDataOptions,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, MonadReader.read, Lean.PrettyPrinter.Delaborator.SubExpr.getPos, ForIn.forIn, ForInStep, Lean.PrettyPrinter.Delaborator.OptionsPerPos, ite, Eq, Lean.Name.isPrefixOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, MonadWithReader.withReader, Lean.PrettyPrinter.Delaborator.Context.mk, Lean.PrettyPrinter.Delaborator.Context.defaultOptions, Lean.PrettyPrinter.Delaborator.Context.currNamespace, Lean.PrettyPrinter.Delaborator.Context.openDecls, Lean.PrettyPrinter.Delaborator.Context.inPattern, Lean.PrettyPrinter.Delaborator.Context.subExpr, Lean.PrettyPrinter.Delaborator.SubExpr.withMDataExpr]]
[Lean.Macro.instInhabitedMethodsRef,[Inhabited.mk, Lean.Macro.mkMethods, arbitrary]]
[Nat.dvd_mod_iff,[Eq.mp, Eq.refl, Iff, Dvd.dvd, HMod.hMod, HAdd.hAdd, HMul.hMul, HDiv.hDiv, Nat.mod_add_div]]
[Lean.PrettyPrinter.ppTerm,[Bind.bind, Lean.MonadOptions.getOptions, Lean.PrettyPrinter.parenthesizeTerm, Lean.PrettyPrinter.formatTerm]]
[Function.right_inverse.id,[funext]]
[Std.PersistentHashMap.Node.collision.inj,[And.intro]]
[Nat.mul_pos,[]]
[Lean.Elab.Term.LValResolution.localRec.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LValResolution.localRec, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Widget.Lean.Widget.MsgToInteractive.instToJsonRpcEncodingPacket,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil]]
[Lean.EnvExtensionInterface.ext,[]]
[Lean.Elab.Term.StructInst.FieldVal.nested.inj,[]]
[Lean.Meta.Cache.funInfo,[]]
[Lean.Server.Snapshots.instInhabitedSnapshot,[Inhabited.mk, Lean.Server.Snapshots.Snapshot.mk, arbitrary]]
[Lean.Elab.InfoTree.hole.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[OrOp.noConfusionType,[]]
[Lean.OptionDecl.noConfusionType,[]]
[Lean.Meta.CongrArgKind.cast.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[le_of_eq,[le_refl]]
[Lean.Meta.SynthInstance.tryResolveCore,[Bind.bind, Lean.Meta.instantiateMVars, Lean.Meta.hasAssignableMVar, ite, Eq, not, Bool.true, Lean.MonadMCtx.getMCtx, Pure.pure, Option.some, Prod.mk, List.nil, PUnit.unit]]
[Lean.Lsp.DocumentHighlight.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.DocumentHighlight.mk, Eq.symm, eq_of_heq, HEq.refl]]
[iff_iff_eq,[Iff.intro, propext, iff_of_eq]]
[Std.PersistentHashMap.getOp,[Std.PersistentHashMap.find?]]
[Lean.Parser.Term.prop,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Lean.Meta.Config.foApprox,[]]
[Bool.toUInt64,[ite, Eq, Bool.true, OfNat.ofNat]]
[Lean.Expr.isProj,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Bool, Bool.true, Bool.false]]
[UInt64.sub_def,[rfl]]
[Lean.Parser.FirstTokens.noConfusionType,[]]
[ByteSlice.forIn.loop,[WellFounded.fix, Nat.Up.WF, dite, LT.lt, Bind.bind, ByteArray.get!, Pure.pure, HAdd.hAdd, OfNat.ofNat, Nat.Up.next]]
[IO.Error.invalidArgument.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.invalidArgument, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.pred_lt_pred,[Eq.refl, Nat.zero, HEq.refl, LT.lt, Nat.pred, False.elim, rfl, Nat.lt_of_succ_lt_succ]]
[Nat.lt_of_lt_of_le,[Nat.le_trans]]
[Lean.Lsp.PlainGoal.goals,[]]
[Lean.Server.FileWorker.GoToKind.noConfusion,[noConfusionEnum, Lean.Server.FileWorker.GoToKind.toCtorIdx]]
[Lean.Elab.ContextInfo.toPPContext,[Lean.PPContext.mk, Lean.Elab.ContextInfo.env, Lean.Elab.ContextInfo.mctx, Lean.Elab.ContextInfo.options, Lean.Elab.ContextInfo.currNamespace, Lean.Elab.ContextInfo.openDecls]]
[Lean.Parser.Command.macroTailTactic.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.identEq.parenthesizer, Lean.Name.mkSimple, Lean.Parser.darrow.parenthesizer, Lean.Parser.Command.macroRhs.parenthesizer, Lean.Parser.Tactic.seq1.parenthesizer]]
[Lean.Parser.Command.openOnly,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.ident, Lean.Parser.symbol, Lean.Parser.many1]]
[Lean.Meta.SynthInstance.Answer.mk.inj,[And.intro]]
[Lean.Widget.goalToInteractive.ppVars,[ite, Eq, Std.RBTree.contains, Lean.LocalDecl.fvarId, Bool.true, Bind.bind, Lean.Widget.goalToInteractive.pushPending, Lean.Meta.instantiateMVars, Lean.LocalDecl.type, Lean.Widget.addInteractiveHypothesis, List.toArray, List.nil, Option.none, Pure.pure, Prod.mk, Lean.Meta.MetaM, Prod, Array, Lean.Name, Option, Lean.Expr, Lean.Widget.InteractiveHypothesis, or, BEq.beq, Option.some, Array.push, List.cons]]
[Nat.exists_eq_succ_of_ne_zero,[Exists.intro, Nat.pred, Or.resolve_left, Nat.eq_zero_or_eq_succ_pred]]
[List.mem_singleton_self,[List.mem_cons_self, List.nil]]
[Lean.Parser.antiquotNestedExpr.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.symbolNoAntiquot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.decQuotDepth.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Lean.Parser.Command.declId.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Bool.false]]
[Lean.Meta.UnificationConstraint.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.matchConstCtor,[Lean.matchConst, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo, Unit.unit]]
[Lean.Meta.Match.Unify.Context.mk.inj,[]]
[Nat.eq_zero_of_nonpos,[Unit.unit, Eq, OfNat.ofNat, rfl, absurd, Nat.zero_lt_succ]]
[String.foldl,[String.foldlAux, String.bsize, OfNat.ofNat]]
[Lean.PrefixTree.find?,[Lean.PrefixTreeNode.find?, Subtype.val]]
[Lean.IR.mkIf,[Lean.IR.FnBody.case, Lean.Name.mkStr, Lean.Name.anonymous, Lean.IR.IRType.uint8, List.toArray, List.cons, Lean.IR.Alt.ctor, Lean.IR.CtorInfo.mk, OfNat.ofNat, List.nil]]
[stdNext,[Prod, Nat, StdGen, Prod.mk, Int.toNat, StdGen.mk]]
[Subrelation,[]]
[Lean.Meta.isListLevelDefEqAux,[Unit.unit, List.nil, List.cons, Lean.Meta.MetaM, Bool, Pure.pure, Bool.true, andM, Lean.Meta.isLevelDefEqAux, PProd.fst, Bool.false]]
[Lean.Widget.TaggedText.stripTags,[List.toArray, List.cons, List.nil, Lean.Widget.TaggedText.stripTags.go]]
[Array.findIdxM?,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, ite, Eq, Bool.true, Pure.pure, ForInStep.done, Option.some, PUnit.unit, Unit.unit, Option, Nat, MProd.fst]]
[Lean.Parser.Term.falseVal.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.nonReservedSymbol.formatter, Bool.false]]
[Lean.Meta.ReduceMatcherResult.stuck.inj,[]]
[Nat.le_succ_of_pred_le,[Unit.unit, LE.le, Nat.succ, Nat.zero_le, Nat.succ_le_succ]]
[Lean.belowSuffix,[]]
[Lean.HeadIndex.fvar.inj,[]]
[Lean.Parser.Term.matchAlts.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.ppDedent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.many1Indent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.Parser.Term.matchAlt.parenthesizer]]
[IO.Process.StdioConfig.mk.inj,[And.intro]]
[Lean.Lsp.Position.line,[]]
[UInt16.xor,[UInt16.mk, Fin.xor, UInt16.val]]
[min_self,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, if_t_t, LE.le, eq_self]]
[Set.diff,[setOf, And, Mem.mem, Not]]
[Lean.Compiler.isEagerLambdaLiftingName,[Lean.Name.anonymous, Bool, or, String.isPrefixOf, PProd.fst, Bool.false]]
[Lean.Lsp.TextDocumentIdentifier.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.TextDocumentIdentifier.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PPFns.noConfusionType,[]]
[Lean.Parser.Term.explicitBinder.parenthesizer,[Lean.Parser.ppGroup.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.Parser.Term.binderType.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.binderTactic.parenthesizer, Lean.Parser.Term.binderDefault.parenthesizer]]
[Lean.Lsp.DocumentFilter.language?,[]]
[Lean.Compiler.SpecializeAttributeKind.noConfusion,[noConfusionEnum, Lean.Compiler.SpecializeAttributeKind.toCtorIdx]]
[Lean.Compiler.foldNatSucc,[OptionM.run, Bind.bind, Lean.Compiler.getNumLit, Pure.pure, Lean.mkRawNatLit, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.IndPredBelow.proveBrecOn.induction,[Bind.bind, Array.mapIdxM, Lean.Meta.IndPredBelow.Context.motives, Lean.Meta.MetaM, Lean.Expr, Lean.Meta.instantiateForall, Lean.Meta.forallTelescopeReducing, Lean.Meta.mkLambdaFVars, Lean.mkAppN, Lean.mkConst, Array.getOp, Lean.Meta.IndPredBelow.Context.belowNames, Fin.val, HAppend.hAppend, Bool.false, Bool.true, Lean.getConstInfo, Lean.mkRecName, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Pure.pure, Lean.ConstantInfo.name, Lean.Meta.apply]]
[StateT.run_pure,[rfl]]
[Lean.BinderInfo.default.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.PrettyPrinter.Parenthesizer.tactic.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.maybeParenthesize, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false, Lean.Unhygienic.run, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.PrettyPrinter.Parenthesizer.parenthesizeCategoryCore]]
[Subtype.coind_bijective,[And.intro, Subtype.coind_injective, And.left, Subtype.coind_surjective, And.right]]
[Lean.Elab.Term.Do.getLetIdDeclVar,[Lean.Syntax.getId, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.ProjectionFunctionInfo.fromClass,[]]
[Lean.Lsp.TextDocumentEdit.noConfusionType,[]]
[Lean.Parser.Tactic.rsimp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Elab.Term.PatternVar.localVar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.open,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.openDecl, Lean.Parser.withOpenDecl, Lean.Parser.termParser, OfNat.ofNat]]
[Lean.Parser.Tactic.Conv.ring,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[List.countp,[Unit.unit, Nat, OfNat.ofNat, ite, Nat.succ, PProd.fst]]
[Lean.Elab.Tactic.evalInduction,[Lean.Elab.Tactic.focus, Bind.bind, Lean.Elab.Tactic.withMainContext, Array.mapM, Lean.Elab.Tactic.elabTerm, Option.none, Bool.false, Lean.Syntax.getSepArgs, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, Array.all, Lean.Expr.isFVar, Array.size, Bool.true, Pure.pure, Lean.Elab.Tactic.liftMetaTacticAux, Lean.Meta.generalize, Array.map, Lean.Meta.GeneralizeArg.mk, Lean.Meta.MetaM, Prod, Array, Lean.Expr, List, Lean.MVarId, Prod.mk, Lean.mkFVar, List.cons, List.nil, Lean.Syntax.isNone, BEq.beq, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.withRef, Lean.Elab.resolveGlobalConstNoOverloadWithInfo, liftM, Lean.Meta.getElimInfo, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.getMainGoal, Lean.MonadMCtx.getMCtx, Lean.Elab.Tactic.getUnsolvedGoals, Lean.MonadRef.getRef, Lean.Elab.Tactic.mkTacticInfo, Lean.Meta.getMVarTag, Lean.Meta.withMVarContext, Lean.Meta.addImplicitTargets, List.toArray, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.Meta.mkGeneralizationForbiddenSet, EmptyCollection.emptyCollection, Lean.Meta.getFVarSetToGeneralize, ForIn.forIn, Std.RBTree.contains, Lean.indentExpr, Lean.Meta.sortFVarIds, Std.RBTree.toArray, Lean.Meta.revert, Nat, Lean.Elab.Tactic.ElimApp.mkElimApp, Lean.Meta.inferType, Array.getOp, Lean.Meta.ElimInfo.motivePos, Lean.Elab.Tactic.ElimApp.setMotiveArg, Lean.Expr.mvarId!, Lean.Meta.assignExprMVar, Lean.Elab.Tactic.ElimApp.Result.elimApp, Lean.Elab.Tactic.ElimApp.evalAlts, Lean.Elab.Tactic.ElimApp.Result.alts, Lean.Elab.Tactic.appendGoals, Array.toList, Lean.Elab.Tactic.ElimApp.Result.others, Lean.Elab.Tactic.evalInduction.checkTargets]]
[Lean.KVMap.empty,[Lean.KVMap.mk]]
[associative,[Eq]]
[Lean.Meta.CaseValuesSubgoal.subst,[]]
[Lean.addMainModuleDoc,[Lean.PersistentEnvExtension.addEntry]]
[Lean.Server.Watchdog.GroupedEdits.mk.inj,[And.intro]]
[Lean.Parser.Command.print.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.strLit.parenthesizer]]
[Lean.SimplePersistentEnvExtensionDescr.name,[]]
[IO.FS.FileType.noConfusion,[noConfusionEnum, IO.FS.FileType.toCtorIdx]]
[Lean.Meta.compatibleCtors,[Bind.bind, Lean.getConstInfoCtor, ite, Eq, bne, Lean.ConstructorVal.induct, Bool.true, Pure.pure, Bool.false, Lean.Meta.forallMetaTelescope, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, Lean.MetavarKind.natural, Lean.Meta.MetaM, Bool, Lean.Meta.isDefEq]]
[Lean.instToJsonList,[Lean.ToJson.mk, Lean.ToJson.toJson, List.toArray]]
[Lean.Server.instRpcEncoding,[Lean.Server.RpcEncoding.mk, Pure.pure]]
[Lean.KVMap.instToStringKVMap,[ToString.mk, ToString.toString, Lean.KVMap.entries]]
[Lean.Syntax.hasArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Bool, Decidable.decide, GT.gt, Array.size, OfNat.ofNat, Bool.false]]
[Lean.KernelException.exprTypeMismatch.inj,[And.intro]]
[Array.binSearchContains,[ite, LT.lt, Array.size, Array.binSearchAux, Option.isSome, Bool.false]]
[Lean.Elab.Tactic.evalUnknown,[Bind.bind, Lean.Elab.Tactic.getGoals, Lean.Elab.addCompletionInfo, Lean.Elab.CompletionInfo.tactic]]
[GroupWithZero.toZero,[]]
[Lean.Parser.Attr.macro.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer]]
[Lean.Lsp.instToJsonStaticRegistrationOptions,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Lsp.StaticRegistrationOptions.id?, List.nil]]
[Lean.Elab.Deriving.instBinderF,[Lean.Parser.Term.instBinder]]
[Lean.Elab.Term.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.NameHashSet.contains,[Std.HashSet.contains]]
[FloatArray.data,[]]
[Nat.sub,[Nat, Nat.pred, PProd.fst]]
[Lean.Json.getBool?,[Lean.Json.null, Lean.Json.num, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Except, String, Bool, Pure.pure, MonadExcept.throw]]
[Id.pure_eq,[rfl]]
[Lean.Elab.Deriving.Ord.mkOrdHeader,[Lean.Elab.Deriving.mkHeader, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat]]
[Lean.Meta.mkArrayLit,[Bind.bind, Lean.Meta.getDecLevel, Lean.Meta.mkListLit, Pure.pure, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil]]
[add_zero,[AddMonoid.add_zero]]
[Nat.not_le_of_gt,[False, Nat.lt_or_ge, absurd, Nat.lt_trans, Nat.lt_irrefl]]
[Lean.Elab.Level.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Level.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[PProd.snd,[]]
[Lean.Elab.Tactic.evalSimp,[Bind.bind, Lean.Elab.Tactic.withMainContext, Lean.Elab.Tactic.mkSimpContext, Bool.false, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.Simp.DischargeWrapper.with, Lean.Elab.Tactic.simpLocation, Lean.Elab.Tactic.expandOptLocation, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Meta.SynthInstance.TableEntry.answers,[]]
[Lean.TagAttribute.noConfusionType,[]]
[Lean.Meta.tryUnificationHints.tryCandidate,[Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.checkpointDefEq, Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.ParserDescr.ibelow,[True, And]]
[Nat.one_ne_zero,[]]
[non_contradictory_em,[]]
[Alternative.failure,[]]
[Lean.closureMaxArgs,[Lean.closureMaxArgsFn, Unit.unit]]
[Nat.mul_self_sub_mul_self_eq,[Eq.mpr, Eq.refl, Eq, HSub.hSub, HMul.hMul, HAdd.hAdd, Nat.mul_sub_left_distrib, Nat.right_distrib, Nat.mul_comm, Nat.add_comm, Nat.add_sub_add_left, rfl]]
[Lean.IR.EmitC.throwUnknownVar,[MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Lean.Elab.Tactic.instOrElseTacticM,[OrElse.mk, Lean.Elab.Tactic.orElse]]
[Lean.Parser.Level.imax.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.levelParser.parenthesizer, Lean.Parser.maxPrec]]
[Lean.Elab.Level.instMonadNameGeneratorLevelElabM,[Lean.MonadNameGenerator.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Level.State.ngen, modify, Lean.Elab.Level.State.mk, Lean.Elab.Level.State.mctx, Lean.Elab.Level.State.levelNames]]
[HShiftRight.hShiftRight,[]]
[CommGroup.mul_comm,[]]
[UInt8.instRingUInt8.proof_1,[congrArg, UInt8.mk, Ring.sub_eq_add_neg, UInt8.val]]
[Lean.Meta.checkpointDefEq,[Bind.bind, Lean.MonadBacktrack.saveState, Lean.Meta.getResetPostponed, MonadExcept.tryCatch, ite, Eq, Bool.true, Lean.Meta.processPostponed, Bool.false, Lean.Meta.getPostponed, Lean.Meta.setPostponed, HAppend.hAppend, Pure.pure, DoResultPR.return, PUnit.unit, Lean.Meta.SavedState.restore, MonadExcept.throw, DoResultPR.pure, Lean.Meta.MetaM, Bool]]
[instHShiftRight,[HShiftRight.mk, ShiftRight.shiftRight]]
[zero_add,[AddMonoid.zero_add]]
[Lean.Meta.Closure.State.newLocalDeclsForMVars,[]]
[Lean.Elab.Command.StructView.ref,[]]
[String.decEq.proof_2,[absurd]]
[nsmul_rec,[OfNat.ofNat, HAdd.hAdd, PProd.fst]]
[Lean.Parser.Term.ensureTypeOf,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.maxPrec, Lean.Parser.strLit]]
[Lean.IR.ExplicitRC.getDecl,[Unit.unit, Lean.IR.Decl, Lean.IR.findEnvDecl', Lean.IR.ExplicitRC.Context.env, Lean.IR.ExplicitRC.Context.decls, panicWithPosWithDecl, OfNat.ofNat]]
[Nat.lt_of_succ_le,[]]
[Lean.Meta.expandCoe,[Lean.Meta.withReducibleAndInstances, Bind.bind, Lean.Meta.transform, Pure.pure, Lean.TransformStep.done, Lean.Meta.expandCoe.step]]
[Lean.SCC.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.SCC.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[UInt32.instRingUInt32,[Ring.mk, UInt32.instRingUInt32.proof_1, UInt32.mk, Ring.gsmul, UInt32.val, UInt32.instRingUInt32.proof_2, UInt32.instRingUInt32.proof_3, UInt32.instRingUInt32.proof_4, UInt32.instRingUInt32.proof_5]]
[IO.FS.DirEntry.path,[HDiv.hDiv, IO.FS.DirEntry.root, System.FilePath.mk, IO.FS.DirEntry.fileName]]
[Std.HashMap.find?,[Option, Std.HashMapImp.find?]]
[Lean.MessageDataContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.one_mul,[Nat.mul_one, Nat.mul_comm, OfNat.ofNat]]
[Lean.Meta.Cases.Context.mk.inj,[And.intro]]
[String.push,[String, String.mk, HAppend.hAppend, List.cons, List.nil]]
[instToStringInt,[ToString.mk, String, ToString.toString, HAppend.hAppend, Nat.succ]]
[Nat.eq_zero_of_add_eq_zero_right,[Eq, OfNat.ofNat, of_eq_true, Eq.trans, implies_congr, congrFun, congrArg, Nat.zero_add, eq_true_of_decide, Eq.refl, Bool.true, implies_true, False.elim, Nat.succ_ne_zero, HAdd.hAdd, Eq.mp, Nat.succ, Nat.succ_add, Nat.add_one]]
[Lean.OptionDecl.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.allGoals,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Lean.Lsp.SaveOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.DeclInfo.noConfusionType,[]]
[Lean.Elab.Term.Do.JPDecl.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instNonempty.proof_1,[Nonempty.intro, arbitrary]]
[Lean.Parser.Term.basicFun.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.many1.formatter, Lean.ppSpace.formatter, Lean.Parser.Term.funBinder.formatter, Lean.Parser.darrow.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Bool.false]]
[Lean.Meta.throwTacticEx,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MessageData.ofGoal]]
[instDecidableEqList,[List.hasDecEq]]
[Lean.PrettyPrinter.Formatter.categoryParserOfStack.formatter,[Bind.bind, MonadState.get, Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Syntax.getId]]
[Std.PersistentArray.mapM,[Bind.bind, Std.PersistentArray.mapMAux, Std.PersistentArray.root, Array.mapM, Std.PersistentArray.tail, Pure.pure, Std.PersistentArray.mk, Std.PersistentArray.size, Std.PersistentArray.shift, Std.PersistentArray.tailOff]]
[Nat.sub_mul_mod,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HSub.hSub, HMul.hMul, Nat.zero, Nat.mul_zero, OfNat.ofNat, Nat.sub_zero, rfl]]
[Lean.Parser.Command.commentBody.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken]]
[Lean.IR.EmitC.hasMainFn,[Bind.bind, Lean.IR.EmitC.getEnv, Pure.pure, List.any, BEq.beq, Lean.IR.Decl.name, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.PrettyPrinter.Formatter.State.stack,[]]
[Lean.IR.LiveVars.updateJPLiveVarMap,[Std.RBMap.insert]]
[Subtype.restrict_injective,[Function.injective.comp, Subtype.coe_injective]]
[Function.uncurry,[Prod.fst, Prod.snd]]
[Lean.Meta.unfoldDefinition,[Bind.bind, Lean.Meta.unfoldDefinition?, Option.none, Lean.Meta.MetaM, Lean.Expr, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr]]
[Lean.instHashableFVarId,[Hashable.mk, UInt64, mixHash, OfNat.ofNat, Hashable.hash]]
[Lean.Lsp.InitializationOptions.noConfusionType,[]]
[Lean.Parser.ParserState.mk.inj,[And.intro]]
[List.length_concat,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, List.length_cons, List.concat, Nat.succ, congrFun, HAdd.hAdd, OfNat.ofNat, eq_self, List.length]]
[Lean.Meta.Closure.collectExpr,[Bind.bind, Lean.Meta.Closure.preprocess, Lean.Meta.Closure.visitExpr, Lean.Meta.Closure.collectExprAux]]
[Lean.Server.Watchdog.ServerContext.hOut,[]]
[Lean.Json.mkObj,[Lean.Json.obj, Id.run, Bind.bind, ForIn.forIn, Id, ForInStep, Std.RBNode, String, Lean.Json, Pure.pure, PUnit.unit, ForInStep.yield]]
[Lean.Elab.Term.LetRecDeclView.mvar,[]]
[Except.noConfusionType,[]]
[Lean.Elab.DerivingHandler,[Lean.Elab.Command.CommandElabM, Bool]]
[Lean.Meta.Cases.Context.casesOnVal,[]]
[Lean.OptionDecl.mk.inj,[And.intro]]
[Lean.Meta.toCtorIfLit,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.mkApp, Lean.mkRawNatLit, HSub.hSub, Lean.ToExpr.toExpr, String.toList]]
[«term_>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Term.notFollowedByRedefinedTermToken.formatter,[Lean.PrettyPrinter.Formatter.notFollowedBy.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.symbol.formatter]]
[Lean.Parser.Command.set_option,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident, Lean.Parser.ppSpace, Lean.Parser.Command.optionValue]]
[Lean.Compiler.getSpecializationInfo,[Lean.SMap.find?, Lean.Compiler.SpecState.specInfo, Lean.SimplePersistentEnvExtension.getState, Lean.Compiler.specExtension]]
[Lean.PrettyPrinter.Formatter.charLitNoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.visitAtom, Lean.charLitKind]]
[UInt32.instSemiringUInt32.proof_1,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt32.zero_def, UInt32.add_def, UInt32.mk, OfNat.ofNat, add_zero, UInt32.val, UInt32.mk_val_eq, eq_self, propext, forall_const, UInt32]]
[Lean.Meta.Closure.Context.noConfusionType,[]]
[Lean.Widget.TaggedText.prettyTagged,[Prod.snd, Std.Format.prettyM]]
[Lean.Elab.Term.Do.DoIfView.cond,[]]
[Lean.Parser.antiquotExpr.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.identNoAntiquot.formatter, Lean.Parser.antiquotNestedExpr.formatter]]
[Lean.InternalExceptionId.idx,[]]
[Nat.add_mul_mod_self_left,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, HMul.hMul, Nat.zero, Nat.mul_zero, OfNat.ofNat, Nat.add_zero, rfl, Nat.succ, Nat.mul_succ, Eq.symm, Nat.add_assoc, Nat.add_mod_right]]
[Lean.PrettyPrinter.Parenthesizer.checkInsideQuot.parenthesizer,[Pure.pure, Unit.unit]]
[Lean.Meta.instantiateLambda,[OfNat.ofNat]]
[fix,[fixCore1, arbitrary]]
[Mathlib.Tactic.Lint.NamedLinter.noConfusionType,[]]
[Lean.KVMap.findD,[Option.getD, Lean.KVMap.find]]
[Lean.getPPFunBinderTypes,[Lean.KVMap.get, Lean.Option.name, Lean.pp.funBinderTypes, Lean.getPPAll]]
[Lean.instInhabitedBinderInfo,[Inhabited.mk, Lean.BinderInfo.default]]
[Lean.Unhygienic.Context.scope,[]]
[Lean.AttributeKind.noConfusion,[noConfusionEnum, Lean.AttributeKind.toCtorIdx]]
[Pow.noConfusionType,[]]
[Lean.Meta.MVarRenaming.isEmpty,[Std.RBMap.isEmpty, Lean.Meta.MVarRenaming.map]]
[UInt8.isAlphanum,[or, UInt8.isAlpha, UInt8.isDigit]]
[Lean.Elab.process,[Bind.bind, Lean.Elab.IO.processCommands, Lean.Parser.ModuleParserState.mk, Lean.Elab.Command.mkState, Lean.MessageLog.mk, Pure.pure, Prod.mk, Lean.Elab.Command.State.env, Lean.Elab.Frontend.State.commandState, Lean.Elab.Command.State.messages]]
[Lean.PrettyPrinter.Delaborator.delabLetFun,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.withAppArg, Lean.PrettyPrinter.Delaborator.delab, Lean.PrettyPrinter.Delaborator.SubExpr.withAppFn, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Lean.PrettyPrinter.Delaborator.getUnusedName, Lean.PrettyPrinter.Delaborator.SubExpr.withBindingBody, orM, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPLetVarTypes, Lean.getPPAnalysisLetVarType, ite, Eq, Bool.true, Lean.PrettyPrinter.Delaborator.SubExpr.withBindingDomain, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Lean.mkIdent, List.nil, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.NamingContext.mk.inj,[And.intro]]
[left_cancelative,[Eq]]
[Lean.Parser.attrParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous]]
[Function.bijective_iff_has_inverse,[Iff.intro, Exists.intro, Function.surj_inv, And.right, And.intro, Function.left_inverse_surj_inv, Function.right_inverse_surj_inv, Function.bijective, Function.left_inverse.injective, Function.right_inverse.surjective]]
[Tactic.Cache.get,[Bind.bind, Pure.pure, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, liftM, EIO.asTask, StateRefT'.run, Prod.fst, Task.Priority.default]]
[Lean.registerSimpleScopedEnvExtension,[Lean.registerScopedEnvExtension, Lean.ScopedEnvExtension.Descr.mk, Lean.SimpleScopedEnvExtension.Descr.name, Pure.pure, Lean.SimpleScopedEnvExtension.Descr.initial, id, Lean.SimpleScopedEnvExtension.Descr.addEntry, Lean.SimpleScopedEnvExtension.Descr.finalizeImport]]
[Lean.IR.CollectMaps.Collector,[Prod, Lean.IR.VarTypeMap, Lean.IR.JPParamsMap]]
[Lean.Elab.Term.SyntheticMVarDecl.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.mem_cons_of_mem,[Or.inr]]
[UInt8.decEq.proof_2,[absurd]]
[Lean.Parser.Tactic.Conv.delta,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Lean.Core.Context.options,[]]
[Lean.ConstructorVal.cidx,[]]
[Lean.FileMap.positions,[]]
[Lean.Rat.den,[]]
[Lean.Expr.app.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.app, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.decLevel?,[Bind.bind, Lean.MonadMCtx.getMCtx, ReaderT.run, Lean.Meta.DecLevelContext.mk, Unit.unit, Lean.Meta.MetaM, Option, Lean.Level, Pure.pure, Option.some, modify, Lean.Meta.State.mk, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed, Option.none]]
[Std.HashSet.fold,[Std.HashSetImp.fold]]
[Lean.Meta.CheckAssignment.Context.mvarDecl,[]]
[Lean.Elab.ExpandDeclIdResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[IsAddRightCancel.add_right_cancel,[]]
[Int.mul_one,[Eq.mpr, Eq.refl, Eq, HMul.hMul, OfNat.ofNat, Int.mul_comm, Int.one_mul, rfl]]
[Std.ShareCommon.PersistentState,[PointedType.type, Std.ShareCommon.PersistentStatePointed]]
[Lean.Elab.Term.elabCDotFunctionAlias?.expandCDotArg?,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Lean.Elab.Term.expandCDot?]]
[System.FilePath.pathSeparators,[ite, Eq, System.Platform.isWindows, Bool.true, List.cons, Char.ofNat, List.nil]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withType,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, liftM, Lean.Meta.inferType, Lean.PrettyPrinter.Delaborator.SubExpr.descend, HSub.hSub, Lean.PrettyPrinter.Delaborator.SubExpr.maxChildren, OfNat.ofNat]]
[Lean.IR.instHashableJoinPointId,[Hashable.mk, Hashable.hash, Lean.IR.JoinPointId.idx]]
[Mathlib.Tactic.Conv.find,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq]]
[Lean.Meta.getMVarType,[Bind.bind, Lean.Meta.getMVarDecl, Pure.pure, Lean.MetavarDecl.type]]
[Lean.IR.Borrow.InitParamMap.initBorrowIfNotExported,[ite, Eq, Bool.true, Lean.IR.Borrow.InitParamMap.initBorrow]]
[instLTProd,[LT.mk, Or, LT.lt, Prod.fst, And, Eq, Prod.snd]]
[Lean.Meta.Simp.isOfNatNatLit,[and, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.Expr.isNatLit, Lean.Expr.appArg!, Lean.Expr.appFn!]]
[Lean.PrettyPrinter.Delaborator.ParamKind.isRegularExplicit,[and, Lean.BinderInfo.isExplicit, Lean.PrettyPrinter.Delaborator.ParamKind.bInfo, not, Lean.PrettyPrinter.Delaborator.ParamKind.isAutoParam, Option.isNone, Lean.PrettyPrinter.Delaborator.ParamKind.defVal]]
[Char.isUpper,[and, Decidable.decide, GE.ge, Char.val, OfNat.ofNat, LE.le]]
[Lean.Lsp.instToJsonTextEdit,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextEdit.range, List.nil, Lean.Lsp.TextEdit.newText]]
[Lean.Elab.Term.FunBinders.State.noConfusionType,[]]
[String.instReprRange,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, String.Range.start, Std.Format.line, String.Range.stop]]
[Lean.ConstantInfo.inductInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Expr.hasAnyFVar,[Lean.Expr.hasAnyFVar.visit]]
[Lean.Elab.Command.termValue_proj_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.getPPProofs,[Lean.KVMap.get, Lean.Option.name, Lean.pp.proofs, Lean.getPPAll]]
[Lean.Meta.Simp.Result.proof?,[]]
[Lean.Meta.instAddMessageContextMetaM,[Lean.AddMessageContext.mk, Lean.addMessageContextFull]]
[Lean.IR.CtorInfo.isRef,[or, Decidable.decide, GT.gt, Lean.IR.CtorInfo.size, OfNat.ofNat, Lean.IR.CtorInfo.usize, Lean.IR.CtorInfo.ssize]]
[Lean.IR.instAlphaEqvArg,[Lean.IR.AlphaEqv.mk, Lean.IR.Arg.alphaEqv]]
[Lean.Parser.Term.panic.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Lean.Expr.isApp,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[Lean.Parser.Term.simpleBinderWithoutType.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.pushNone.parenthesizer, Bool.true]]
[Lean.Lsp.ClientCapabilities.hasToJson,[Lean.ToJson.mk, Lean.Json.mkObj, List.nil]]
[Lean.withIncRecDepth,[Bind.bind, Lean.MonadRecDepth.getRecDepth, Lean.MonadRecDepth.getMaxRecDepth, ite, Eq, BEq.beq, Bool.true, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.maxRecDepthErrorMessage, Pure.pure, PUnit.unit]]
[Lean.Elab.Term.StructInst.instToFormatFieldStruct,[Std.ToFormat.mk, Lean.Elab.Term.StructInst.formatField, Lean.Elab.Term.StructInst.formatStruct]]
[Lean.Meta.intro1P,[Lean.Meta.intro1Core, Bool.true]]
[Lean.Meta.Simp.withParent,[withTheReader, Lean.Meta.Simp.Context, Lean.Meta.Simp.Context.mk, Lean.Meta.Simp.Context.config, Lean.Meta.Simp.Context.simpLemmas, Lean.Meta.Simp.Context.congrLemmas, Option.some, Lean.Meta.Simp.Context.dischargeDepth]]
[Lean.Meta.injectionIntro,[List.toArray, List.nil, Lean.Meta.injectionIntro.go]]
[Substring.toNat?,[ite, Eq, Substring.isNat, Bool.true, Option.some, Substring.foldl, HAdd.hAdd, HMul.hMul, OfNat.ofNat, HSub.hSub, Char.toNat, Char.ofNat, Option.none]]
[Lean.Export.instInhabitedEntry,[Inhabited.mk, Lean.Export.Entry.name, arbitrary]]
[Lean.Lsp.instFromJsonCommand,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, String, Option, Array, Lean.Json, Pure.pure, Lean.Lsp.Command.mk]]
[Lean.Meta.Match.Extension.getMatcherInfo?,[Lean.SMap.find?, Lean.Meta.Match.Extension.State.map, Lean.SimplePersistentEnvExtension.getState, Lean.Meta.Match.Extension.extension]]
[PSigma.lexAccessible.proof_1,[Acc.intro, PSigma.mk, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, WellFounded.apply]]
[Lean.Meta.transform,[Lean.MonadCacheT.run, Lean.Meta.transform.visit]]
[Lean.instHashableName,[Hashable.mk, Lean.Name.hash]]
[Lean.Widget.InteractiveGoals.goals,[]]
[Lean.IR.AltCore.default.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instLawfulMonadStateRefT',[instLawfulMonadStateRefT'.proof_1]]
[Lean.Elab.Term.CollectPatternVars.State.found,[]]
[Lean.Lsp.ProgressParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Equiv.leftInv,[]]
[Lean.IR.Borrow.BorrowInfState.paramMap,[]]
[Lean.DataValue.noConfusionType,[]]
[AddCommMonoid.add_comm,[]]
[Lean.Parser.Command.macro_rules.formatter,[Lean.PrettyPrinter.Formatter.suppressInsideQuot.formatter, Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.docComment.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.optKind.formatter, Lean.Parser.Term.matchAlts.formatter, Lean.Parser.termParser.formatter]]
[Lean.Parser.Attr.protectProj,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[Lean.LazyInitExtension.get,[Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.EnvExtension.getState, Lean.LazyInitExtension.ext, Pure.pure, Lean.LazyInitExtension.fn, Lean.MonadEnv.modifyEnv, Lean.EnvExtension.setState, Option.some]]
[Array.modifyM.proof_1,[Eq.symm, Array.size_set, Fin.mk, arbitrary]]
[Lean.Parser.Attr.class.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.Server.FileWorker.ElabTaskError.eof.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.CongrTheorem.type,[]]
[Lean.Parser.Tactic.simpPost,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol]]
[Lean.Elab.Command.expandMixfix.withAttrKindGlobal,[Bind.bind, Pure.pure, Lean.Syntax.setArg, OfNat.ofNat]]
[Lean.Syntax.TopDown.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.mkInjectiveTheoremNameFor,[HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous]]
[System.SearchPath,[List, System.FilePath]]
[Set.singleton,[setOf, Eq]]
[IO.Process.Child.mk.inj,[And.intro]]
[IO.Error.noConfusionType,[]]
[Lean.SimpleScopedEnvExtension.Descr.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.SimpleScopedEnvExtension.Descr.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.Ipc.readResponseAs,[Bind.bind, Lean.Lsp.Ipc.stdout, liftM, IO.FS.Stream.readLspResponseAs]]
[DoResultPR.noConfusionType,[]]
[Lean.Parser.Tactic.simpIntro,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg]]
[Lean.Lsp.CompletionParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.le_of_lt_succ,[Nat.le_of_succ_le_succ]]
[Nat.div_lt_self,[]]
[Lean.Parser.Term.nomatch.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Lean.ScopedEnvExtension.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ScopedEnvExtension.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.local.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.Server.Watchdog.FileWorker.commTask,[]]
[Lean.Parser.Term.termFor,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.sepBy1, Lean.Parser.Term.doForDecl, Bool.false, Lean.Parser.Term.doSeq]]
[Nat.anyAux,[Unit.unit, Bool, Bool.false, or, HSub.hSub, Nat.succ, PProd.fst]]
[Lean.Meta.getGlobalInstancesIndex,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Meta.Instances.discrTree, Lean.ScopedEnvExtension.getState, Lean.Meta.instanceExtension]]
[Lean.Meta.SizeOfSpecNested.throwFailed,[Bind.bind, MonadReader.read, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.SizeOfSpecNested.Context.ctorName]]
[Lean.Parser.scientificLit.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.scientificLitKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.scientificLitNoAntiquot.parenthesizer]]
[Nat.zero_div,[Eq.trans, Nat.div_eq, OfNat.ofNat, if_neg, Nat.not_le_of_gt]]
[Lean.Elab.Tactic.elabRewriteConfig,[ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, Lean.Meta.Rewrite.Config.mk, Lean.withoutModifyingState, Lean.Meta.withLCtx, Lean.LocalContext.mk, EmptyCollection.emptyCollection, Lean.Elab.Term.withSynthesize, Bind.bind, Lean.Elab.Term.elabTermEnsuringType, Lean.Syntax.getOp, OfNat.ofNat, Option.some, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Option.none, liftM, Lean.Meta.instantiateMVars, Bool.false]]
[Nat.pred_succ,[rfl]]
[Lean.SimplePersistentEnvExtension.instInhabitedSimplePersistentEnvExtension,[inferInstanceAs, Inhabited, Lean.PersistentEnvExtension, Prod, List]]
[Tactic.Ring.State.mk.inj,[And.intro]]
[IO.Error.unsatisfiedConstraints.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Structural.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.SavedState.elab,[]]
[Lean.ParametricAttributeImpl.noConfusionType,[]]
[Lean.Elab.WF.TerminationHintValue.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.WF.TerminationHintValue.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.Decl.simpCase,[Lean.IR.Decl.extern, Lean.IR.Decl, Lean.IR.Decl.updateBody!, Lean.IR.FnBody.simpCase]]
[Lean.Server.instMonadRpcSession,[Lean.Server.MonadRpcSession.mk, liftM, Lean.Server.MonadRpcSession.rpcStoreRef, Lean.Server.MonadRpcSession.rpcGetRef, Lean.Server.MonadRpcSession.rpcReleaseRef]]
[List.hasDecidableLt,[Unit.unit, Decidable, LT.lt, Decidable.isFalse, List.hasDecidableLt.proof_1, Decidable.isTrue, List.lt.nil, List.hasDecidableLt.proof_2, List.cons, List.lt.head, List.hasDecidableLt.proof_3, PProd.fst, List.lt.tail, List.hasDecidableLt.proof_4]]
[Lean.Parser.Level.addLit.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.numLit.parenthesizer]]
[UInt8.mul_def,[rfl]]
[Array.get.proof_1,[Fin.isLt]]
[Lean.Xml.Content.noConfusionType,[]]
[Lean.Parser.Level.imax.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.nonReservedSymbol.formatter, Lean.Parser.many1.formatter, Lean.ppSpace.formatter, Lean.Parser.levelParser.formatter, Lean.Parser.maxPrec]]
[Lean.Meta.modifyTarget,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType, Lean.Meta.change, Bool.false]]
[tacticFunext__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Lean.Parser.ParserAttributeHook.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.ParserAttributeHook.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.VersionedTextDocumentIdentifier.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.notFollowedByRedefinedTermToken.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.notFollowedBy.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.symbol.parenthesizer]]
[Lean.Meta.ElimAltInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt64.instSemigroupUInt64,[Semigroup.mk, UInt64.instSemigroupUInt64.proof_1]]
[Lean.Elab.Command.withMacroExpansion,[MonadWithReader.withReader, Lean.Elab.Command.Context.mk, Lean.Elab.Command.Context.fileName, Lean.Elab.Command.Context.fileMap, Lean.Elab.Command.Context.currRecDepth, Lean.Elab.Command.Context.cmdPos, List.cons, Lean.Elab.MacroStackElem.mk, Lean.Elab.Command.Context.macroStack, Lean.Elab.Command.Context.currMacroScope, Lean.Elab.Command.Context.ref]]
[Prod.lexAccessible,[Prod.lexAccessible.proof_1]]
[Fin.one_def,[]]
[Lean.MetavarContext.LevelMVarToParam.M,[ReaderT, Lean.MetavarContext.LevelMVarToParam.Context, StateM, Lean.MetavarContext.LevelMVarToParam.State]]
[Lean.Elab.Term.SyntheticMVarKind.coe.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instReprUInt16,[Repr.mk, repr, UInt16.toNat]]
[Std.PersistentArray.map,[Id.run, Std.PersistentArray.mapM]]
[Lean.Parser.ppHardSpace.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.skip.parenthesizer]]
[Lean.AttributeApplicationTime.noConfusionType,[noConfusionTypeEnum, Lean.AttributeApplicationTime.toCtorIdx]]
[«termΣ_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
[instMonadReaderOfReaderT,[MonadReaderOf.mk, ReaderT.read]]
[Lean.IR.EmitC.emitJmp,[Bind.bind, Lean.IR.EmitC.getJPParams, ite, Eq, BEq.beq, Array.size, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw]]
[Lean.ExternEntry.noConfusionType,[]]
[Lean.Elab.Frontend.getCommandState,[Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Frontend.State.commandState]]
[Lean.Meta.ToHide.hasInaccessibleNameDep,[Bind.bind, MonadState.get, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.findLocalDeclDependsOn, or, Std.RBTree.contains, Lean.Meta.ToHide.State.hiddenInaccessible, Lean.Meta.ToHide.State.hiddenInaccessibleProp]]
[Nat.lt_of_not_le,[Or.resolve_right, Nat.lt_or_ge]]
[Lean.Parser.Tactic.suggest,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg]]
[Fin.mod_eq_of_lt,[Fin.eq_of_val_eq, Eq.mpr, congrFun, congrArg, Eq, Fin.val, Fin.mod_def, Eq.refl, HMod.hMod, Nat.mod_eq_of_lt, Fin.isLt, rfl]]
[Nat.eq_of_beq_eq_true,[Eq, rfl]]
[Setoid.noConfusionType,[]]
[Lean.Parser.ParserExtension.OLeanEntry.kind.inj,[]]
[Lean.Widget.Lean.Widget.InteractiveTermGoal.instFromJsonRpcEncodingPacket,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Array, Lean.Widget.TaggedText, Lean.Lsp.Range, Pure.pure]]
[Lean.Meta.Match.assignGoalOf,[Lean.Meta.Match.withGoalOf, Lean.Meta.assignExprMVar, Lean.Meta.Match.Problem.mvarId]]
[Lean.Elab.Term.Do.Code.reassign.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Code.reassign, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.AttributeApplicationTime.toCtorIdx,[OfNat.ofNat]]
[Lean.Elab.instInhabitedModifiers,[Inhabited.mk, Lean.Elab.Modifiers.mk, arbitrary]]
[Lean.Parser.Tactic.simpAll,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma]]
[Lean.IR.Borrow.BorrowInfState.owned,[]]
[Lean.Lsp.RpcConnectParams.uri,[]]
[Lean.Elab.Command.getLevelNames,[Bind.bind, Lean.Elab.Command.getScope, Pure.pure, Lean.Elab.Command.Scope.levelNames]]
[Lean.Elab.Term.StructInst.Field.expr?,[]]
[le_of_eq_or_lt,[LE.le, le_of_eq, le_of_lt]]
[Lean.Parser.Term.trueVal,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.nonReservedSymbol, Bool.false]]
[Lean.Elab.Term.expandHave,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Lean.Syntax.isNone, Unit.unit, Option.none, Option.some, Lean.Macro.throwUnsupported]]
[Fin.instHModFinNatFin,[HMod.mk, Fin.modn]]
[Lean.Environment.displayStats,[Bind.bind, ST.Ref.get, Lean.persistentEnvExtensionsRef, IO.println, HAppend.hAppend, ToString.toString, Lean.EnvironmentHeader.imports, Lean.Environment.header, Array.size, Lean.EnvironmentHeader.regions, Array.filter, Lean.CompactedRegion.isMemoryMapped, OfNat.ofNat, Lean.SMap.size, Lean.Environment.constants, Prod.fst, Lean.SMap.stageSizes, Prod.snd, Lean.SMap.numBuckets, Lean.EnvironmentHeader.trustLevel, Lean.Environment.extensions, Array.forM, Lean.PersistentEnvExtension.name]]
[Lean.Meta.Config.ignoreLevelMVarDepth,[]]
[Nat.add_right_comm,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Nat.add_assoc, Nat.add_comm, Eq.symm, rfl]]
[Std.RBMap.insert.proof_1,[Std.RBNode.WellFormed.insertWff, rfl]]
[Prod.mk.inj_iff,[Iff.intro, Prod.mk.inj, Eq.mpr, Eq.refl, Eq, Prod.mk, And.left, And.right, rfl]]
[Lean.Elab.Term.elabTermEnsuringType,[Bind.bind, Lean.Elab.Term.elabTerm, Lean.withRef, Lean.Elab.Term.ensureHasType]]
[List.reverse,[List.reverseAux, List.nil]]
[Lean.Parser.Term.leading_parser.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.optExprPrecedence.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Std.Format.FlattenBehavior.allOrNone.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.DecLevelContext.noConfusionType,[]]
[Lean.Meta.Simp.Context.parent?,[]]
[IO.Process.StdioConfig.stderr,[]]
[Lean.Parser.Tactic.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.tacticParser.parenthesizer]]
[IO.AsyncList.ofList,[List.foldr, IO.AsyncList.cons, IO.AsyncList.nil]]
[outParam,[]]
[Lean.Parser.Term.haveIdDecl.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Term.haveIdLhs.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Bool.false]]
[Lean.mkCIdentFromRef,[Bind.bind, Lean.MonadRef.getRef, Pure.pure, Lean.mkCIdentFrom]]
[Lean.Lsp.instFromJsonRpcRef,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, USize, Pure.pure, Lean.Lsp.RpcRef.mk]]
[UInt32.instNegUInt32,[Neg.mk, UInt32.mk, Neg.neg, UInt32.val]]
[Lean.ImportState.noConfusionType,[]]
[Prod.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Prod.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.instToMessageDataName,[Lean.ToMessageData.mk, Lean.MessageData.ofName]]
[Lean.Parser.addLeadingParser,[Unit.unit, Except, String, Lean.Parser.ParserCategories, Lean.Parser.getCategory, Lean.Parser.throwUnknownParserCategory, Lean.Parser.FirstTokens.epsilon, Lean.Parser.FirstTokens.unknown, Lean.Parser.ParserInfo.firstTokens, Lean.Parser.Parser.info, Pure.pure, Std.PersistentHashMap.insert, Lean.Parser.ParserCategory.mk, Lean.Parser.ParserCategory.behavior]]
[Lean.Expr.updateLambda!.proof_1,[rfl]]
[Lean.Elab.Term.Quotation.precheckApp,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Term.Quotation.precheck, ForIn.forIn, PUnit.unit, Pure.pure, ForInStep.yield, Lean.Elab.throwUnsupportedSyntax]]
[Array.mkEmpty,[Array.mk, List.nil]]
[Lean.Parser.sepBy.formatter,[Lean.PrettyPrinter.Formatter.sepByNoAntiquot.formatter, Lean.Parser.sepByElemParser.formatter]]
[le_or_lt,[Or.symm, lt_or_le]]
[List.length_set,[rfl, Eq.symm, of_eq_true, Eq.trans, congr, congrArg, Eq, List.length_cons, List.set, Nat.succ, eq_self, List.length, Eq.refl]]
[Lean.Json.opt,[Unit.unit, List, Prod, String, Lean.Json, List.nil, List.cons, Prod.mk, Lean.ToJson.toJson]]
[Lean.Parser.Term.doReturn,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, Lean.Parser.withPosition, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.checkLineEq, Lean.Parser.termParser, OfNat.ofNat]]
[Lean.Meta.testHelper,[Bind.bind, ite, Eq, Bool.true, Pure.pure, Lean.Meta.whnf]]
[Command.initializeSimpsProjections?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const, Command.simpsProj]]
[min_eq_right_of_lt,[min_eq_right, le_of_lt]]
[Lean.Syntax.SepArray.getElems,[Array.getSepElems, Lean.Syntax.SepArray.elemsAndSeps]]
[Float.noConfusionType,[]]
[Lean.Syntax.matchesIdent,[and, Lean.Syntax.isIdent, BEq.beq, Lean.Syntax.getId]]
[Lean.IR.Expr.reuse.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.reuse, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.basicFun.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.Term.funBinder.parenthesizer, Lean.Parser.darrow.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Bool.false]]
[Lean.Server.FileWorker.EditableDocument.cancelTk,[]]
[Lean.PrettyPrinter.Delaborator.ParamKind.mk.inj,[And.intro]]
[Lean.Parser.nodeFn,[Lean.Parser.ParserState.mkNode]]
[String.mkIterator,[String.Iterator.mk, OfNat.ofNat]]
[Lean.IR.Borrow.ownArgsUsingParams,[Nat.forM, Array.size, ite, Eq, Lean.IR.Param.borrow, Bool.true, Pure.pure, PUnit.unit, Lean.IR.Borrow.ownArg]]
[Lean.Elab.Tactic.ElimApp.State.fType,[]]
[Lean.Parser.Tactic.exact,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[List.pairwise_cons,[Iff.intro]]
[Lean.Meta.MatcherApp.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.instAlternativeMetaM,[Alternative.mk, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Meta.orElse]]
[Lean.Parser.InputContext.fileMap,[]]
[Lean.Elab.Term.StructInst.instInhabitedSource,[Inhabited.mk, Lean.Elab.Term.StructInst.Source.none]]
[Semiring.add_mul,[]]
[Std.PersistentArray.append,[ite, Eq, Std.PersistentArray.isEmpty, Bool.true, Std.PersistentArray.foldl, Std.PersistentArray.push, OfNat.ofNat]]
[instReprSubtype,[Repr.mk, Repr.reprPrec, Subtype.val]]
[Nat.add_one,[rfl]]
[Lean.Elab.Deriving.DecEq.mkMatch.mkAlts,[Bind.bind, ForIn.forIn, Lean.getConstInfoCtor, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, PUnit.unit, ForInStep.yield, ite, Eq, BEq.beq, Bool.true, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, liftM, Lean.Core.betaReduce, MProd.mk, Lean.Elab.Term.TermElabM, Lean.Syntax, Lean.Expr.containsFVar, Lean.Expr.fvarId!, Lean.Core.mkFreshUserName, Lean.Meta.inferType, Lean.mkIdent, Array.append, Lean.Elab.Deriving.DecEq.mkMatch.mkSameCtorRhs, Array.toList, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.Meta.compatibleCtors, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Array.push]]
[IO.Process.Child.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Process.Child.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.getBuiltinSearchPath,[Bind.bind, Lean.getLibDir, Pure.pure, List.cons, List.nil]]
[IO.FS.Stream.read,[]]
[Lean.Parser.withAntiquotSuffixSpliceFn,[Id.run, ite, Eq, or, Lean.Parser.ParserState.hasError, BEq.beq, Lean.Parser.ParserContext.quotDepth, OfNat.ofNat, not, Lean.Syntax.isAntiquot, Array.back, Lean.Parser.ParserState.stxStack, Bool.true, Pure.pure, Bind.bind, PUnit.unit]]
[Lean.Parser.sepBy1.formatter,[Lean.PrettyPrinter.Formatter.sepBy1NoAntiquot.formatter, Lean.Parser.sepByElemParser.formatter]]
[Lean.Meta.InfoCacheKey.transparency,[]]
[Lean.MessageSeverity.information.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[OptionT.instMonadExceptOfOptionT,[MonadExceptOf.mk, OptionT.mk, throwThe, tryCatchThe]]
[Lean.getPathToBaseStructure?,[Lean.getPathToBaseStructureAux, List.nil]]
[Lean.IR.Sorry.visitExpr,[Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, ExceptT, Lean.Name, Lean.IR.Sorry.M, Unit, Pure.pure, Unit.unit, Lean.IR.Sorry.visitExpr.getSorryDepFor?]]
[Lean.Lsp.instToJsonDocumentHighlightKind,[Lean.ToJson.mk, Unit.unit, Lean.Json, OfNat.ofNat]]
[Lean.Elab.Command.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.sub_eq_zero_of_le,[Exists.elim, Nat.le.dest, Eq.mpr, Eq.refl, Eq, HSub.hSub, OfNat.ofNat, Eq.symm, HAdd.hAdd, Nat.sub_self_add, rfl]]
[lt_trichotomy,[Or.elim, le_total, Decidable.lt_or_eq_of_le, Or.inl, Or.inr, Eq.symm]]
[Lean.Meta.SortLocalDecls.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SortLocalDecls.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[String.Range.start,[]]
[Lean.Meta.ToHide.M,[ReaderT, Lean.Meta.ToHide.Context, StateRefT', IO.RealWorld, Lean.Meta.ToHide.State, Lean.Meta.MetaM]]
[Lean.Elab.Tactic.evalCase,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Bind.bind, Lean.Elab.Tactic.getUnsolvedGoals, Lean.Syntax.isIdent, List.findM?, liftM, Lean.Meta.getMVarDecl, Pure.pure, Lean.Name.isSuffixOf, Lean.MetavarDecl.userName, Unit.unit, Lean.Elab.Tactic.TacticM, Option, Lean.MVarId, Option.some, Lean.Name.isPrefixOf, Option.none, Unit, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Elab.Tactic.getMainGoal, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Meta.setMVarType,[Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.setMVarType]]
[Lean.Lsp.LocationLink.targetSelectionRange,[]]
[Lean.Meta.Simp.Config.maxDischargeDepth,[]]
[USize.mod_def,[rfl]]
[Nat.add_self_ne_one,[Eq.refl, OfNat.ofNat, HEq.refl, False]]
[Lean.Meta.Match.isCurrVarInductive,[Unit.unit, Lean.Meta.MetaM, Bool, Lean.Meta.Match.Problem.vars, Pure.pure, Bool.false, Lean.Meta.Match.withGoalOf, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.InductiveVal, Lean.Expr.getAppFn, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Option.some, Option.none, Option.isSome]]
[Lean.Meta.inferTypeImp,[Lean.withIncRecDepth, Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.default, Lean.Meta.inferTypeImp.infer]]
[Lean.PrettyPrinter.Formatter.State.stxTrav,[]]
[Lean.Elab.Term.StructInst.CtorHeaderResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.HoverParams.mk.inj,[]]
[Lean.Tactic.normNum,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.Parser.Tactic.location]]
[Lean.Meta.DiscrTree.Key.const.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Level.Context.autoBoundImplicit,[]]
[Lean.Export.instCoeExprEntry,[Coe.mk, Lean.Export.Entry.expr]]
[Nat.add_mul,[Nat.right_distrib]]
[«term_/_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[String.startsWith,[BEq.beq, Substring.take, String.toSubstring, String.length]]
[Lean.Parser.Term.letIdDecl,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.Term.letIdLhs, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat, Bool.false]]
[Lean.PrettyPrinter.Delaborator.Context.openDecls,[]]
[Lean.Parser.Tactic.config,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, OfNat.ofNat]]
[termDepIfThenElse,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Lean.MetaEval.eval,[]]
[Lean.Expr.const?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Prod, Lean.Name, List, Lean.Level, Option.some, Prod.mk, Option.none]]
[FloatArray.mkEmpty,[FloatArray.mk, List.toArray, List.nil]]
[Lean.Meta.Match.MatcherResult.mk.inj,[And.intro]]
[Char.noConfusionType,[]]
[Lean.PPContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PPContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.MonadCache.findCached?,[]]
[Lean.Meta.savingCache,[Lean.Meta.mapMetaM, Bind.bind, MonadState.get, tryFinally, modify, Lean.Meta.State.mk, Lean.Meta.State.mctx, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed]]
[Lean.Meta.AbstractNestedProofs.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Compiler.foldCharOfNat,[OptionM.run, Bind.bind, guard, Eq, not, Bool.true, Lean.Compiler.getNumLit, ite, isValidChar, Nat.toUInt32, Pure.pure, Lean.Compiler.mkUInt32Lit, OfNat.ofNat]]
[UInt16.toNat,[Fin.val, UInt16.val]]
[Lean.Meta.instInhabitedAbstractMVarsResult,[Inhabited.mk, Lean.Meta.AbstractMVarsResult.mk, arbitrary]]
[Lean.Parser.Command.exit.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.Elab.Term.StructInst.Struct.ibelow,[And, True]]
[false_and,[propext, Iff.intro, And.left, False.elim]]
[Lean.Meta.SplitIf.getSimpContext,[Lean.LazyInitExtension.get, Lean.Meta.SplitIf.ext]]
[Lean.Elab.Tactic.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.toParserDescr.processNullaryOrCat,[Bind.bind, Lean.Elab.Term.toParserDescr.resolveParserName, Lean.Syntax.getOp, OfNat.ofNat, Unit.unit, List.cons, Prod.mk, Bool.false, Bool.true, Lean.Elab.Term.ToParserDescrM, Lean.Syntax, Lean.Elab.Term.toParserDescr.ensureNoPrec, Pure.pure, Lean.mkIdentFrom, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, List.nil, Lean.Quote.quote, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, List.map, Prod.fst, Lean.MonadEnv.getEnv, ite, Eq, Lean.Parser.isParserCategory, Lean.Elab.Term.toParserDescr.processParserCategory, liftM, Lean.Parser.isParserAlias, Lean.Parser.ensureConstantParserAlias]]
[Lean.Parser.Term.doHave.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.haveDecl.parenthesizer]]
[Lean.Elab.Term.Quotation.HeadCheck.slice.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Quotation.HeadCheck.slice, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.MonadCacheT.instMonadControlMonadCacheT,[inferInstanceAs, MonadControl, StateRefT', Std.HashMap]]
[Lean.Parser.notSymbol.formatter,[Lean.PrettyPrinter.Formatter.notFollowedBy.formatter, Lean.Parser.symbol.formatter]]
[Lean.Server.FileWorker.handleRequest,[Bind.bind, MonadReader.read, MonadState.get, ite, Eq, BEq.beq, Bool.true, MonadExcept.tryCatch, Lean.Server.FileWorker.parseParams, Lean.Lsp.RpcConnectParams, Lean.Server.FileWorker.handleRpcConnect, liftM, IO.FS.Stream.writeLspResponse, Lean.Server.FileWorker.WorkerContext.hOut, Lean.JsonRpc.Response.mk, IO.FS.Stream.writeLspResponseError, Lean.JsonRpc.ResponseError.mk, Lean.JsonRpc.ErrorCode.internalError, ToString.toString, Pure.pure, PUnit.unit]]
[Lean.Parser.isExitCommand,[Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.AliasEntry,[Prod, Lean.Name]]
[Std.Range.forIn.loop,[ite, GE.ge, Std.Range.stop, Pure.pure, Unit.unit, Bind.bind, PProd.fst, HAdd.hAdd, Std.Range.step]]
[Lean.Elab.WF.TerminationHintValue.ref,[]]
[Mathlib.Tactic.Ext.tacticExtOrSkip__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Nat.allM.loop,[Unit.unit, Bool, Pure.pure, Bool.true, Bind.bind, HSub.hSub, OfNat.ofNat, PProd.fst, Bool.false]]
[Lean.Literal.strVal.injEq,[Eq.propIntro, Eq.refl, Lean.Literal.strVal, Eq.symm, eq_of_heq, HEq.refl]]
[IO.Process.Stdio.toCtorIdx,[OfNat.ofNat]]
[Nat.sub_le_sub_right_iff,[Iff.intro, Nat.le_of_le_of_sub_le_sub_right, Nat.sub_le_sub_right]]
[Lean.Macro.resolveNamespace?,[Bind.bind, Lean.Macro.getMethods, Lean.Macro.Methods.resolveNamespace?]]
[Lean.instForInOptionsProdNameDataValue,[inferInstanceAs, ForIn, Lean.KVMap, Prod, Lean.Name, Lean.DataValue]]
[Nat.mod_add_mod,[]]
[UInt32.div,[UInt32.mk, HDiv.hDiv, UInt32.val]]
[Lean.Lsp.DidOpenTextDocumentParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DidOpenTextDocumentParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.instInhabitedCompletionItem,[Inhabited.mk, Lean.Lsp.CompletionItem.mk, arbitrary]]
[ByteArray.foldl,[Id.run, ByteArray.foldlM]]
[Array.size_swap,[]]
[Lean.Meta.reduceEval,[Lean.Meta.withAtLeastTransparency, Lean.Meta.TransparencyMode.default, Lean.Meta.ReduceEval.reduceEval]]
[Lean.Expr.bvar.inj,[And.intro]]
[Lean.Meta.mkCongrLemma.onlyMVarsAt,[Option.isNone, Lean.Expr.find?, and, Lean.Expr.isMVar, not, Std.RBTree.contains, Lean.Expr.mvarId!]]
[Lean.Server.FileWorker.getInteractiveTermGoal,[Bind.bind, Lean.Server.RequestM.readDoc, Lean.Server.RequestM.withWaitFindSnap, Decidable.decide, GT.gt, Lean.Server.Snapshots.Snapshot.endPos, Pure.pure, Option.none, Option.some, Prod.mk, Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofTermInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.Info.ofCompletionInfo, Lean.Server.RequestM, Option, Lean.Widget.InteractiveTermGoal, Lean.Elab.InfoTree.termGoalAt?, Lean.Server.Snapshots.Snapshot.infoTree, liftM, Lean.Elab.ContextInfo.runMetaM, Lean.Elab.Info.lctx, Lean.Meta.inferType, Lean.Elab.TermInfo.expr, Lean.Meta.instantiateMVars, Option.getD, Lean.Elab.TermInfo.expectedType?, Lean.Meta.mkFreshExprMVar, Lean.MetavarKind.natural, Lean.Name.anonymous, Lean.Meta.withPPInaccessibleNames, Lean.Widget.goalToInteractive, Lean.Expr.mvarId!, Bool.true, Lean.Widget.InteractiveTermGoal.mk, Lean.Widget.InteractiveGoal.hyps, Lean.Widget.InteractiveGoal.type]]
[Mathlib.Tactic.Lint.getDeclsInMathlib,[Bind.bind, Mathlib.Tactic.Lint.getDeclsInCurrModule, Lean.MonadEnv.getEnv, ForIn.forIn, Lean.Core.CoreM, ForInStep, Array, Lean.Name, ite, Eq, Array.getOp, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield]]
[Lean.Meta.Match.State.used,[]]
[Lean.Meta.Match.MkMatcherInput.noConfusionType,[]]
[Lean.Level.PP.toResult,[Lean.Level.PP.Result, Lean.Level.PP.Result.num, OfNat.ofNat, Lean.Level.PP.Result.succ, PProd.fst, Lean.Level.PP.Result.max, PProd.snd, Lean.Level.PP.Result.imax, Lean.Level.PP.Result.leaf]]
[Nat.add_succ,[rfl]]
[instToStringULift,[ToString.mk, ToString.toString, ULift.down]]
[Lean.Parser.addBuiltinLeadingParser,[Lean.Parser.addBuiltinParser, Bool.true]]
[Lean.IR.Expr.proj.inj,[And.intro]]
[Lean.IR.Arg.hasFreeVar,[Lean.IR.HasIndex.visitArg, Lean.IR.VarId.idx]]
[Lean.Core.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.firstM,[Unit.unit, Alternative.failure, HOrElse.hOrElse, PProd.fst]]
[List.below,[PUnit, PProd]]
[Lean.ConstructorVal.toConstantVal,[]]
[Lean.instMonadWithOptions,[Lean.MonadWithOptions.mk, MonadFunctorT.monadMap, Lean.MonadWithOptions.withOptions]]
[Lean.Parser.Command.notation.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optPrecedence.parenthesizer, Lean.Parser.Command.optNamedName.parenthesizer, Lean.Parser.Command.optNamedPrio.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.Command.notationItem.parenthesizer, Lean.Parser.darrow.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Substring.beq,[and, BEq.beq, Substring.bsize, String.substrEq, Substring.str, Substring.startPos]]
[Lean.Parser.SyntaxNodeKindSet.insert,[Std.PersistentHashMap.insert, Unit.unit]]
[IO.Error.mkOtherError,[IO.Error.otherError]]
[exists_eq_right_right,[Iff.intro, And, And.intro, Exists, Eq, Exists.intro, rfl]]
[Lean.Elab.Deriving.Header.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Deriving.Header.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Command.expandMutualPreamble,[Unit.unit, Lean.MacroM, Lean.Syntax, OfNat.ofNat, Lean.Syntax.getArgs, Lean.Syntax.getOp, Lean.Macro.throwUnsupported, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.mkNullNode, HAppend.hAppend]]
[Lean.Parser.Term.stx.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.syntaxParser]]
[Lean.Parser.Tactic.set,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instAddCommSemigroupFin,[AddCommSemigroup.mk, instAddCommSemigroupFin.proof_1]]
[Lean.LocalContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.LocalContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PersistentEnvExtension.mk.inj,[And.intro]]
[IO.FS.Mode.write.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Term.Arg.noConfusionType,[]]
[Lean.IR.LocalContextEntry.localVar.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.LocalContextEntry.localVar, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.many1.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.many1NoAntiquot.parenthesizer, Lean.Parser.withAntiquotSpliceAndSuffix.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol.parenthesizer]]
[Lean.Meta.Match.MatchEqns.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Level.PP.Result.num.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Expr.FindImpl.State.noConfusionType,[]]
[and_or_distrib_left,[Iff.intro, Or, And, Or.imp, And.intro, And.imp_right, Or.inl, Or.inr]]
[«term_∩_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.Match.MatcherInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.MatcherInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.withDepElimPatterns,[Bind.bind, StateRefT'.run, Array.mapM, Lean.Elab.Term.ToDepElimPattern.main, Lean.Elab.Term.ToDepElimPattern.State.mk, Lean.Elab.Term.TermElabM, liftM, Lean.Meta.instantiateLocalDeclMVars, Lean.Elab.Term.ToDepElimPattern.State.localDecls, Lean.MonadLCtx.getLCtx, withTheReader, Lean.Meta.Context, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.localInstances, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth]]
[Lean.Meta.Match.InjectionAnyResult.subgoal.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.InjectionAnyResult.subgoal, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.CompletionItem.mk.inj,[And.intro]]
[Lean.Macro.expandMacro?,[Bind.bind, Lean.Macro.getMethods, Lean.Macro.Methods.expandMacro?]]
[Lean.Elab.applyAttributesOf,[Bind.bind, ForIn.forIn, PUnit.unit, Lean.Elab.Term.applyAttributesAt, Lean.Elab.PreDefinition.declName, Lean.Elab.Modifiers.attrs, Lean.Elab.PreDefinition.modifiers, Pure.pure, ForInStep.yield]]
[Lean.Server.publishProgressAtPos,[Lean.Server.publishProgress, List.toArray, List.cons, Lean.Lsp.LeanFileProgressProcessingInfo.mk, Lean.Lsp.Range.mk, Lean.FileMap.utf8PosToLspPos, Lean.Server.DocumentMeta.text, String.bsize, Lean.FileMap.source, List.nil]]
[Int.instNegInt,[Neg.mk, Int.neg]]
[Lean.OpaqueVal.mk.inj,[And.intro]]
[Lean.IR.CtorInfo.size,[]]
[Lean.Parser.errorFn,[Lean.Parser.ParserState.mkUnexpectedError, List.nil]]
[IO.FS.Stream.writeResponseError,[IO.FS.Stream.writeMessage, Lean.JsonRpc.Message.responseError, Lean.JsonRpc.ResponseError.id, Lean.JsonRpc.ResponseError.code, Lean.JsonRpc.ResponseError.message, Option.none]]
[instDecidableDite,[Decidable, dite]]
[Lean.Parser.Command.terminationSuffix,[HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.terminationBy, Lean.Parser.Command.decreasingBy]]
[Nat.mul_sub_left_distrib,[Eq.mpr, Eq.refl, Eq, HMul.hMul, HSub.hSub, Nat.mul_comm, Nat.mul_sub_right_distrib, rfl]]
[Lean.Meta.IndPredBelow.Variables.params,[]]
[Nat.instDvdNat,[Dvd.mk, Exists, Eq, HMul.hMul]]
[Lean.Elab.Tactic.mkSimpContext,[ite, Eq, and, not, Lean.Syntax.isNone, Lean.Syntax.getOp, OfNat.ofNat, Bool.true, Bind.bind, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.Parser.TokenCacheEntry.mk.inj,[And.intro]]
[Lean.Core.instMonadCoreM,[Monad.mk]]
[Lean.Parsec.satisfy,[Lean.Parsec.attempt, Bind.bind, Lean.Parsec.anyChar, ite, Eq, Bool.true, Pure.pure, Lean.Parsec.fail]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isTrivialBottomUp,[Bind.bind, Lean.MonadOptions.getOptions, Pure.pure, or, Lean.Expr.isFVar, Lean.Expr.isConst, Lean.Expr.isMVar, Lean.Expr.isNatLit, Lean.Expr.isStringLit, Lean.Expr.isSort, and, Lean.getPPAnalyzeTrustOfNat, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.getPPAnalyzeTrustOfScientific]]
[List.length'_eq_length,[Unit.unit, Eq, List.length', List.length, rfl, of_eq_true, Eq.trans, congr, congrArg, Nat.succ, PProd.fst, List.length_cons, eq_self]]
[String.Iterator.hasPrev,[Bool, Decidable.decide, GT.gt, OfNat.ofNat]]
[right_distributive,[Eq]]
[instAndOpUInt32,[AndOp.mk, UInt32.land]]
[Lean.PrettyPrinter.Delaborator.instOrElseDelabM,[OrElse.mk, Lean.PrettyPrinter.Delaborator.orElse]]
[Lean.Parser.sepBy1NoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.sepBy1Info, Lean.Parser.Parser.info, Lean.Parser.sepBy1Fn, Lean.Parser.Parser.fn]]
[Lean.ResolveName.resolveNamespace?,[Unit.unit, Option, Lean.Name, Lean.ResolveName.resolveNamespaceUsingScope, Option.some, Lean.ResolveName.resolveNamespaceUsingOpenDecls, Option.none]]
[IO.Error.mkUnsupportedOperation,[IO.Error.unsupportedOperation]]
[Lean.MessageData.ofName.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.toUSize,[USize.ofNat]]
[Function.curry,[Prod.mk]]
[Lean.ClassState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Expr.containsFVar,[Lean.Expr.hasAnyFVar, BEq.beq]]
[Lean.Export.runExportM,[StateT.run', arbitrary]]
[StateT.run_seq,[]]
[Lean.MetavarContext.instantiateLCtxMVars,[Lean.LocalContext.foldl, Prod, Lean.LocalContext, Lean.MetavarContext, Prod.mk, Lean.LocalContext.mkLocalDecl, Lean.LocalContext.mkLetDecl, Lean.LocalContext.mk, OfNat.ofNat]]
[Nat.lt_of_add_lt_add_right,[Nat.lt_of_add_lt_add_left, Eq.mpr, Eq.refl, LT.lt, HAdd.hAdd, Nat.add_comm]]
[Lean.Meta.Closure.Context.zeta,[]]
[Lean.KeyedDeclsAttribute.noConfusionType,[]]
[Lean.Elab.Term.instToStringSyntheticMVarKind,[ToString.mk, Unit.unit, String]]
[Lean.Meta.UnificationHintEntry.val,[]]
[Fin.val_eq_of_eq,[rfl]]
[Lean.Elab.Term.elabArrow,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Term.elabType, Lean.MonadQuotation.addMacroScope, Pure.pure, Lean.mkForall, Lean.BinderInfo.default, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Compiler.mkEagerLambdaLiftingName,[Lean.Name.mkStr, HAppend.hAppend, ToString.toString]]
[UInt32.instRingUInt32.proof_3,[congrArg, UInt32.mk, Ring.gsmul_succ', UInt32.val]]
[Lean.Meta.ReduceMatcherResult.noConfusionType,[]]
[Lean.Parser.Command.optNamedPrio.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.Command.namedPrio.parenthesizer]]
[mul_pow,[of_eq_true, Eq.trans, congr, congrArg, Eq, HPow.hPow, HMul.hMul, Nat.zero_eq, pow_zero, mul_one, OfNat.ofNat, eq_self, congrFun, mul_comm, Nat.succ, pow_succ', mul_assoc]]
[Lean.Parser.Term.termBeforeDo,[Lean.Parser.withForbidden, Lean.Parser.termParser, OfNat.ofNat]]
[UInt16.instSemiringUInt16.proof_4,[congrArg, UInt16.mk, AddMonoid.nsmul_succ', UInt16.val]]
[Lean.SourceInfo.fromRef,[Option.none, Option.some, Lean.SourceInfo, Lean.Syntax.getPos?, Bool.false, Lean.Syntax.getTailPos?, Lean.SourceInfo.synthetic, Lean.SourceInfo.none]]
[instDecidableEqProd.proof_2,[absurd]]
[Lean.Lsp.TextDocumentEdit.mk.inj,[And.intro]]
[Decidable.imp_or_distrib,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, Decidable.imp_iff_not_or, Or.left_comm, Or, or_comm, Not, or_self, iff_self]]
[Char.val,[]]
[instHMul,[HMul.mk, Mul.mul]]
[Lean.IR.NormalizeIds.withVar,[Bind.bind, getModify, HAdd.hAdd, OfNat.ofNat, Lean.IR.VarId.mk, Std.RBMap.insert, Lean.IR.VarId.idx]]
[ExceptT.run_bind_lift,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Bind.bind, map_eq_pure_bind, Except.ok, Except, Pure.pure, Except.error, LawfulMonad.bind_assoc, funext, LawfulMonad.pure_bind, eq_self]]
[Lean.IR.Alt.default,[Lean.IR.AltCore.default]]
[Lean.DataValue.ofString.inj,[]]
[List.decidableBall.proof_1,[False.elim, Iff.mp, List.mem_nil]]
[Lean.Parser.Tactic.tacticSeq.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Tactic.tacticSeqBracketed.parenthesizer, Lean.Parser.Tactic.tacticSeq1Indented.parenthesizer, Bool.false]]
[Lean.Lsp.CompletionOptions.noConfusionType,[]]
[Lean.PrettyPrinter.Formatter.checkKind,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, bne, Lean.Syntax.getKind, Bool.true, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.Elab.CompletionInfo.option.inj,[]]
[Nat.beq,[Unit.unit, Bool, Bool.true, Bool.false, PProd.fst]]
[Lean.Meta.Simp.Methods.post,[]]
[not_iff_comm,[Decidable.not_iff_comm]]
[Lean.PrettyPrinter.Formatter.many1Unbox.formatter,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.nullKind, Bool.true, Lean.PrettyPrinter.Formatter.manyNoAntiquot.formatter]]
[Lean.Elab.Term.StructInst.Struct.below,[PProd, PUnit]]
[of_not_not,[by_contra]]
[FloatArray.forIn.loop.proof_1,[Nat.lt_of_le_of_lt, Nat.sub_le, HSub.hSub, FloatArray.size, OfNat.ofNat, Nat.sub_lt, Nat.zero_lt_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self, of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Parser.Term.inaccessible,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser]]
[Lean.Expr.replaceFVarId,[Lean.Expr.replaceFVar, Lean.mkFVar]]
[ByteSliceT.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Tactic.Ring.horner_add_horner_lt,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Tactic.Ring.horner, Eq.symm, OfNat.ofNat, of_eq_true, Eq.trans, congr, congrArg, add_comm, HMul.hMul, HPow.hPow, add_assoc, congrFun, add_zero, add_mul, mul_assoc, pow_add, eq_self]]
[Lean.Elab.Tactic.evalInjection,[Bind.bind, Lean.Elab.Tactic.elabAsFVar, Lean.Syntax.getOp, OfNat.ofNat, Option.none, Lean.Elab.Tactic.liftMetaTactic, Lean.Meta.injection, Unit.unit, Lean.Meta.MetaM, List, Lean.MVarId, ite, Eq, List.isEmpty, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Syntax.missing, List.nil, List.cons]]
[Lean.Meta.MVarRenaming.apply,[ite, Eq, not, Lean.Expr.hasMVar, Bool.true, Std.RBMap.isEmpty, Lean.Meta.MVarRenaming.map, Lean.Expr.replace, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Expr, Unit.unit, Std.RBMap.find?, Option.some, Lean.mkMVar, Option.none]]
[Std.RBMap.fold,[Std.RBNode.fold]]
[Lean.Environment.mk.inj,[And.intro]]
[Lean.Parser.Attr.macro,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident]]
[Lean.IR.instToFormatParam,[Std.ToFormat.mk, Std.Format, HAppend.hAppend, Std.Format.text, Std.ToFormat.format, ite, Eq, Bool.true]]
[Lean.IR.LitVal.num.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.gcd_dvd_gcd_of_dvd_right,[Nat.dvd_gcd, Nat.gcd_dvd_left, Nat.dvd_trans, Nat.gcd_dvd_right]]
[Lean.Parser.mkEmptySubstringAt,[Substring.mk]]
[Id.hasBind,[inferInstance]]
[Lean.Lsp.DeclarationParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DeclarationParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[namedPattern,[]]
[Lean.Parser.Term.structInstField.parenthesizer,[Lean.Parser.ppGroup.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.structInstLVal.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.Elab.Term.Do.ToCodeBlock.checkLetArrowRHS,[ite, Eq, or, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.Expr.hasLevelMVar,[Lean.Expr.Data.hasLevelMVar, Lean.Expr.data]]
[Lean.Elab.Term.SyntheticMVarKind.coe.inj,[And.intro]]
[Lean.Server.RequestError.code,[]]
[Lean.Syntax.MonadTraverser.st,[]]
[Std.Format.group.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Function.injective.comp,[]]
[Lean.Expr.FoldConstsImpl.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt16.instSemiringUInt16.proof_1,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt16.zero_def, UInt16.add_def, UInt16.mk, OfNat.ofNat, add_zero, UInt16.val, UInt16.mk_val_eq, eq_self, propext, forall_const, UInt16]]
[Function.injective2.right,[And.right]]
[Lean.Meta.mkInjectiveEqTheoremNameFor,[HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous]]
[String.Iterator.forward,[String.Iterator, PProd.fst, String.Iterator.next]]
[Lean.IR.CtorLayout.noConfusionType,[]]
[Nat.lt_succ_self,[Nat.lt.base]]
[Lean.Meta.DiscrTree.Key.arrow.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Nat.add_one_ne_zero,[Nat.succ_ne_zero]]
[Lean.NamePart.str.inj,[]]
[Lean.MessageData.ofFormat.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.structFields.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.manyIndent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGe.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.structExplicitBinder.parenthesizer, Lean.Parser.Command.structImplicitBinder.parenthesizer, Lean.Parser.Command.structInstBinder.parenthesizer, Lean.Parser.Command.structSimpleBinder.parenthesizer]]
[inv_mul_self,[mul_left_inv]]
[Lean.Elab.Command.expandMacro,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Option.some, Lean.Macro.throwUnsupported]]
[Lean.Meta.Match.InjectionAnyResult.failed.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.PrettyPrinter.Formatter.withMaybeTag,[Option.none, Lean.PrettyPrinter.Formatter, Bind.bind, Lean.PrettyPrinter.Formatter.concat, modify, Lean.PrettyPrinter.Formatter.State.mk, Lean.PrettyPrinter.Formatter.State.stxTrav, Lean.PrettyPrinter.Formatter.State.leadWord, Array.modify, Lean.PrettyPrinter.Formatter.State.stack, HSub.hSub, Array.size, OfNat.ofNat, Std.Format.tag]]
[IO.FS.Stream.writeResponseErrorWithData,[IO.FS.Stream.writeMessage, Lean.JsonRpc.Message.responseError, Lean.JsonRpc.ResponseError.id, Lean.JsonRpc.ResponseError.code, Lean.JsonRpc.ResponseError.message, Option.map, Lean.ToJson.toJson, Lean.JsonRpc.ResponseError.data?]]
[Lean.MessageSeverity.noConfusion,[noConfusionEnum, Lean.MessageSeverity.toCtorIdx]]
[Quotient.inductionOn₂,[Quotient.ind]]
[USize.instNegUSize,[Neg.mk, USize.mk, Neg.neg, USize.val]]
[Lean.NameTrie.foldM,[Lean.NameTrie.foldMatchingM, Lean.Name.anonymous]]
[Lean.Elab.Command.instMonadOptionsCommandElabM,[Lean.MonadOptions.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Command.Scope.opts, List.head!, Lean.Elab.Command.State.scopes]]
[Lean.Parser.Command.macroTailCommand.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.identEq.formatter, Lean.Name.mkSimple, Lean.Parser.darrow.formatter, Lean.Parser.Command.macroRhs.formatter, Lean.PrettyPrinter.Formatter.many1Unbox.formatter, Lean.Parser.commandParser.formatter, OfNat.ofNat]]
[Lean.KVMap.findCore,[Option, Lean.DataValue, Option.none, ite, Eq, BEq.beq, Bool.true, Option.some, PProd.fst]]
[Lean.IR.EmitC.overwriteParam,[Nat.any, Prod.anyI, Lean.IR.EmitC.paramEqArg, Array.getOp, Prod.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Expr.hasFVarEx,[Lean.Expr.hasFVar]]
[Lean.Meta.addSimpLemma,[Bind.bind, Lean.getConstInfo, Lean.Meta.withReducible, Lean.Meta.inferType, Lean.Meta.isProp, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Meta.forallTelescopeReducing, not, Lean.Expr.isEq, or, ForIn.forIn, Lean.Meta.MetaM, ForInStep, Array, Lean.Meta.SimpLemma, Lean.Meta.mkAuxLemma, Lean.ConstantInfo.levelParams, Lean.Meta.instantiateMVars, Lean.Meta.withNewMCtxDepth, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.whnfR, Unit.unit, Lean.Expr.eq?, Lean.Meta.DiscrTree.mkPath, Prod.mk, Lean.mkConst, List.map, Lean.mkLevelParam, List.toArray, List.nil, Option.some, ForInStep.yield, List.cons, Lean.ScopedEnvExtension.add, Lean.Meta.SimpEntry.lemma]]
[Lean.Lsp.WorkspaceFolder.mk.inj,[And.intro]]
[Lean.Level.getOffset,[Lean.Level.getOffsetAux, OfNat.ofNat]]
[Lean.Meta.instInhabitedCaseValuesSubgoal,[Inhabited.mk, Lean.Meta.CaseValuesSubgoal.mk, arbitrary]]
[Lean.Elab.WF.TerminationHint.one.inj,[]]
[Lean.Elab.PreDefinition.mk.inj,[And.intro]]
[«term_≥_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.isIdRest,[or, Char.isAlphanum, Decidable.decide, Eq, Char.ofNat, BEq.beq, Lean.isLetterLike, Lean.isSubScriptAlnum]]
[Lean.Elab.Term.Do.convertTerminalActionIntoJmp,[Lean.Elab.Term.Do.convertTerminalActionIntoJmp.loop]]
[Lean.IR.Expr.proj.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.IndPredBelow.mkCtorType.replaceTempVars,[Lean.Expr.replaceFVars, Lean.Meta.IndPredBelow.Variables.indVal, Array.map, Lean.mkConst, Lean.Meta.IndPredBelow.Context.belowNames]]
[Lean.Server.DocumentMeta.mk.inj,[And.intro]]
[Sdiff.noConfusionType,[]]
[Lean.Meta.SimpLemmas.erase,[ite, Eq, or, Lean.Meta.SimpLemmas.isLemma, Lean.Meta.SimpLemmas.isDeclToUnfold, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.instDecidableEqModuleIdx,[instDecidableEqNat]]
[Monoid.toSemigroup,[]]
[Std.RBTree.min,[Unit.unit, Option, Std.RBMap.min, Option.some, Option.none]]
[Lean.Meta.Match.Unify.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.nameLitNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.nameLitFn]]
[Lean.Elab.InfoTree.context.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.InfoTree.context, Eq.symm, eq_of_heq, HEq.refl]]
[Std.Format.appendEx,[Std.Format.append]]
[Lean.charLitKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.instInhabitedModuleIdx,[inferInstanceAs, Inhabited, Nat]]
[Lean.Parser.ppLine.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.skip.parenthesizer]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.namedArgs,[]]
[Lean.Meta.substEqs,[Bind.bind, Lean.Meta.casesRec, Lean.Meta.instantiateMVars, Lean.LocalDecl.type, Pure.pure, or, Lean.Expr.isEq, Lean.Expr.isHEq, Lean.Meta.exactlyOne, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[Lean.Elab.Command.shouldInferResultUniverse,[Bind.bind, liftM, Lean.Meta.instantiateLevelMVars, ite, Eq, Lean.Level.hasMVar, Bool.true, Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Elab.Term.TermElabM, Bool, Lean.Level.getLevelOffset, Lean.Elab.Term.assignLevelMVar, Lean.Elab.Command.tmpIndParam, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkSort, Bool.false]]
[Nat.toFloat,[Float.ofNat]]
[Lean.Lsp.TextDocumentContentChangeEvent.fullChange.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.TextDocumentContentChangeEvent.fullChange, Eq.symm, eq_of_heq, HEq.refl]]
[Fin.checkedAdd,[Option, Fin, Fin.overflowingAdd, Option.none, Option.some]]
[Lean.Elab.runTactic,[Bind.bind, modifyThe, Lean.Meta.State, Lean.Meta.State.mk, Lean.MetavarContext.instantiateMVarDeclMVars, Lean.Meta.State.mctx, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed, Lean.Elab.Term.TermElabM.run]]
[plift.up.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.FileWorker.EditableDocument.noConfusionType,[]]
[Lean.Elab.Tactic.evalSkip,[Pure.pure, Unit.unit]]
[Lean.Meta.FVarSubst.any,[Std.AssocList.any, Lean.Meta.FVarSubst.map]]
[Lean.Parser.unicodeSymbolFnAux,[Lean.Parser.satisfySymbolFn, or, BEq.beq]]
[Std.Range.step,[]]
[Lean.Elab.ElabInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[String.utf8ByteSize,[Nat, PProd.fst, HAdd.hAdd, String.csize, OfNat.ofNat]]
[Lean.IR.addParamRename,[ite, Eq, and, BEq.beq, Lean.IR.Param.ty, Decidable.decide, Lean.IR.Param.borrow, Bool.true, Option.some, Lean.IR.addVarRename, Lean.IR.VarId.idx, Lean.IR.Param.x, Option.none]]
[Lean.Elab.Term.ExtractMonadResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.ExtractMonadResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Std.PersistentArray.toList,[List.reverse, Std.PersistentArray.foldl, List.cons, List.nil, OfNat.ofNat]]
[Lean.IR.LogEntry.step.inj,[And.intro]]
[Lean.Parser.Tactic.unfoldCases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser]]
[FloatArray.foldl,[Id.run, FloatArray.foldlM]]
[Lean.Elab.Command.StructFieldView.noConfusionType,[]]
[Lean.Parser.maxPrec,[OfNat.ofNat]]
[Task.bind,[Task.pure, Task.get]]
[Lean.IR.LitVal.str.injEq,[Eq.propIntro, Eq.refl, Lean.IR.LitVal.str, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.app.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.leadPrec, Lean.Parser.maxPrec, Lean.Parser.many1.formatter, Lean.Parser.Term.argument.formatter]]
[UInt64.instSemiringUInt64.proof_2,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt64.zero_def, UInt64.add_def, UInt64.mk, OfNat.ofNat, zero_add, UInt64.val, UInt64.mk_val_eq, eq_self, propext, forall_const, UInt64]]
[Lean.Parser.manyFn,[Lean.Parser.ParserState.mkNode, Lean.nullKind]]
[Lean.Elab.Info.tailPos?,[Lean.Syntax.getTailPos?, Lean.Elab.Info.stx, Bool.true]]
[Lean.Elab.Tactic.evalRotateRight,[Bind.bind, Lean.Elab.Tactic.getGoals, Lean.Elab.Tactic.setGoals, List.rotateRight]]
[Lean.Parser.Term.let_fun,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, HOrElse.hOrElse, Lean.Parser.symbol, Lean.Parser.Term.letDecl, Lean.Parser.Term.optSemicolon, Lean.Parser.termParser, OfNat.ofNat]]
[Lean.Parser.Term.macroLastArg,[HOrElse.hOrElse, Lean.Parser.Term.macroDollarArg, Lean.Parser.Term.macroArg]]
[UInt8.toUInt32,[Nat.toUInt32, UInt8.toNat]]
[Lean.Lsp.SemanticTokensLegend.tokenTypes,[]]
[Lean.Elab.WF.TerminationHint.many.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.WF.TerminationHint.many, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.precheckedQuot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.quot.formatter]]
[monadFunctorRefl,[MonadFunctorT.mk]]
[Lean.Parser.Command.syntax.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.docComment.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optPrecedence.parenthesizer, Lean.Parser.Command.optNamedName.parenthesizer, Lean.Parser.Command.optNamedPrio.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.syntaxParser.parenthesizer, Lean.Parser.argPrec, Lean.Parser.ident.parenthesizer]]
[Tactic.Ring.horner_atom,[of_eq_true, Eq.trans, congrArg, Eq, congrFun, HAdd.hAdd, HMul.hMul, OfNat.ofNat, pow_one, one_mul, add_zero, eq_self]]
[Lean.Elab.Command.Scope.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.PlainTermGoal.goal,[]]
[IO.Error.resourceExhausted.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Semigroup.toMul,[]]
[Lean.instBEqMessageSeverity,[BEq.mk, BEq.beq, Lean.MessageSeverity.toCtorIdx]]
[rfl,[rfl.proof_1]]
[ByteArray.mk.inj,[]]
[Int.add_left_comm,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Eq.symm, Int.add_assoc, Int.add_comm, rfl]]
[Lean.Core.Context.maxRecDepth,[]]
[instInhabitedEST,[inferInstanceAs, Inhabited, EStateM]]
[Lean.Elab.Term.StructInst.Source.noConfusionType,[]]
[Lean.Parser.Command.ctor,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.declModifiers, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.Command.inferMod, Lean.Parser.Command.optDeclSig]]
[Nat.gcd_mul_dvd_mul_gcd,[Dvd.dvd, Nat.gcd, HMul.hMul, Nat.prod_dvd_and_dvd_of_dvd_prod, Nat.gcd_dvd_right]]
[HAndThen.hAndThen,[]]
[Lean.Meta.throwIncorrectNumberOfLevels,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkConst]]
[Lean.Elab.DefView.binders,[]]
[Lean.NameTrie.insert,[Lean.PrefixTree.insert, List.nil, List, Lean.NamePart, PProd.fst, List.cons, Lean.NamePart.str, Lean.NamePart.num]]
[List.decidableBexi.proof_4,[Exists, And, Mem.mem, List.cons]]
[Lean.Lsp.DiagnosticSeverity.warning.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Std.RBMap.fromList,[List.foldl, Std.RBMap.insert, Prod.fst, Prod.snd, Std.mkRBMap]]
[Lean.Parser.withForbidden,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.Parser.fn, Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.prec, Lean.Parser.ParserContext.tokens, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Parser.ParserContext.savedPos?, Option.some]]
[Lean.Meta.DefEqContext.noConfusionType,[]]
[Nat.dvd_mul_left,[Exists.intro, Nat.mul_comm]]
[Lean.Elab.Term.elabMutualDef.go,[Bind.bind, Lean.Elab.Term.getLevelNames, ForIn.forIn, Lean.withRef, Lean.Elab.DefView.ref, Lean.MonadResolveName.getCurrNamespace, Lean.Elab.expandDeclId, Lean.Elab.DefView.declId, Lean.Elab.DefView.modifiers, Lean.Elab.Term.TermElabM, Lean.Elab.DefViewElabHeader, Lean.Elab.addDeclarationRanges, Lean.Elab.Term.applyAttributesAt, Lean.Elab.Modifiers.attrs, Lean.AttributeApplicationTime.beforeElaboration, Lean.Elab.Term.withDeclName, Lean.Elab.Term.withAutoBoundImplicit, Lean.Elab.Term.withLevelNames, Lean.Elab.Term.elabBindersEx, Lean.Syntax.getArgs, Lean.Elab.DefView.binders, Unit.unit, Lean.Elab.DefView.type?, Lean.Elab.Term.elabType, Lean.Elab.Term.registerCustomErrorIfMVar, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Pure.pure, PUnit.unit, ForInStep.yield, StateRefT'.run', OfNat.ofNat, Array.mapM, liftM, Lean.Meta.instantiateMVars, Lean.Elab.DefViewElabHeader.type, Lean.Elab.DefViewElabHeader.mk, Lean.Elab.DefViewElabHeader.ref, Lean.Elab.DefViewElabHeader.modifiers, Lean.Elab.DefViewElabHeader.kind, Lean.Elab.DefViewElabHeader.shortDeclName, Lean.Elab.DefViewElabHeader.declName, Lean.Elab.DefViewElabHeader.levelNames, Lean.Elab.DefViewElabHeader.binderIds, Lean.Elab.DefViewElabHeader.numParams, Lean.Elab.DefViewElabHeader.valueStx, MProd.mk, StateRefT', IO.RealWorld, Nat, ForInStep, MProd, Array, Subarray, Stream.next?, ForInStep.done, List.toArray, List.nil, Lean.Elab.liftMacroM, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Term.expandWhereDeclsOpt, Lean.Syntax.getOp, Lean.Elab.Term.expandMatchAltsWhereDecls, Lean.MacroM, Lean.Syntax, OptionM.run, Array.sequenceMap, cond, Lean.Syntax.isNone, Lean.Syntax.matchesNull, Option.none, Lean.Macro.throwErrorAt, Lean.Elab.Term.expandLetEqnsDecl, Lean.Macro.throwUnsupported, Option.some, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, List.cons, Lean.Syntax.atom, Array.append, Array.map, Lean.Syntax.isMissing, Lean.Meta.forallBoundedTelescope, Lean.Elab.Term.addTermInfo, Array.getOp, HAdd.hAdd, HSub.hSub, Array.size, Lean.Elab.Term.elabTermEnsuringType, Lean.Meta.mkLambdaFVars, Bool.false, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Lean.Elab.Term.getLetRecsToLift, List.mapM, Lean.Elab.Term.LetRecToLift.type, Lean.Elab.Term.LetRecToLift.val, Lean.Elab.Term.LetRecToLift.mk, Lean.Elab.Term.LetRecToLift.ref, Lean.Elab.Term.LetRecToLift.fvarId, Lean.Elab.Term.LetRecToLift.attrs, Lean.Elab.Term.LetRecToLift.shortDeclName, Lean.Elab.Term.LetRecToLift.declName, Lean.Elab.Term.LetRecToLift.lctx, Lean.Elab.Term.LetRecToLift.localInstances, Lean.Elab.Term.LetRecToLift.mvarId, List.forM, PUnit, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.FVarId, Lean.Meta.findLocalDecl?, Lean.Name, Lean.LocalDecl.userName, List.findSome?, BEq.beq, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.throwErrorAt, HAppend.hAppend, StateRefT'.run, Array.forM, Lean.Meta.collectUsedFVars, Lean.CollectFVars.State.mk, Prod, Lean.LocalContext, Lean.LocalInstances, Lean.Expr, Lean.Meta.removeUnused, Lean.Meta.withLCtx, Lean.Elab.Term.MutualClosure.main, Lean.isTracingEnabledFor, Lean.addTrace, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.type, Lean.Elab.PreDefinition.value, Lean.Elab.levelMVarToParamPreDecls, Lean.Elab.instantiateMVarsAtPreDecls, Lean.Elab.fixLevelParams, Lean.Elab.addPreDefinitions, Lean.Elab.Term.elabMutualDef.processDeriving]]
[List.mem_of_mem_remove,[And.left, Eq.mp, Eq.refl, Mem.mem, List.remove, propext, List.mem_remove_iff]]
[Lean.Server.FileWorker.handleCompletion,[Bind.bind, Lean.Server.RequestM.readDoc, Lean.Server.RequestM.withWaitFindSnap, Decidable.decide, GE.ge, HAdd.hAdd, Lean.Server.Snapshots.Snapshot.endPos, OfNat.ofNat, Pure.pure, Lean.Lsp.CompletionList.mk, Bool.true, List.toArray, List.nil, liftM, Lean.Server.Completion.find?, Lean.Server.DocumentMeta.text, Lean.Server.FileWorker.EditableDocument.meta, Lean.Server.Snapshots.Snapshot.infoTree, Option.none, Lean.Server.RequestM, Lean.Lsp.CompletionList, PUnit.unit]]
[Lean.Elab.Term.Do.ToTerm.Context.kind,[]]
[Lean.Elab.Command.StructFieldInfo.kind,[]]
[Lean.Expr.below,[PUnit, PProd]]
[Lean.Meta.Simp.ConfigCtx.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Simp.ConfigCtx.mk, Eq.symm, eq_of_heq, HEq.refl]]
[let_value_heq,[Eq.mpr, Eq.refl, HEq, HEq.rfl]]
[Lean.unreachIsNodeIdent.proof_1,[Eq.refl, Lean.Syntax.ident, HEq.refl, False]]
[ByteArray.forIn,[ByteArray.size, Nat.le_refl, ByteArray.forIn.loop]]
[Fin.shiftLeft,[Fin, Fin.mk, HMod.hMod, HShiftLeft.hShiftLeft, Fin.shiftLeft.proof_1]]
[«term_≤_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.Closure.MkValueTypeClosureResult.noConfusionType,[]]
[Nat.gcd_mul_left_left,[Nat.dvd_antisymm, Nat.gcd_dvd_right, HMul.hMul, Nat.dvd_gcd, Nat.dvd_mul_left, Nat.dvd_refl]]
[List.foldlM,[Pure.pure, Bind.bind, PProd.fst]]
[Lean.instInhabitedEnvironment,[Inhabited.mk, Lean.Environment.mk, arbitrary]]
[Lean.AddErrorMessageContext.noConfusionType,[]]
[MonadControl.restoreM,[]]
[Nat.mul_div_mul,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, Eq.symm, Nat.div_div_eq_div_mul, Nat.mul_div_cancel_left, rfl]]
[Lean.IR.FnBody.inc.inj,[And.intro]]
[Lean.Parser.Command.open_locale,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[Nat.anyM,[Nat.anyM.loop]]
[Lean.JsonRpc.Request.id,[]]
[Lean.Server.FileWorker.Reference.noConfusionType,[]]
[List.bex_cons,[Iff.intro, Or, Exists, And, Mem.mem, Eq.mp, propext, List.mem_cons_iff, Or.inl, Eq.refl, Eq.symm, Or.inr, Exists.intro, And.intro, Or.elim, List.mem_cons_self, List.cons, List.mem_cons_of_mem]]
[Lean.JsonRpc.ErrorCode.invalidRequest.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Term.termFor.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.Term.doForDecl.formatter, Bool.false, Lean.Parser.Term.doSeq.formatter]]
[Lean.Parser.Tactic.specialize,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.rhss,[]]
[Lean.mkLevelMaxEx,[Lean.mkLevelMax]]
[Lean.Lsp.instFromJsonCancelParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.JsonRpc.RequestID, Pure.pure, Lean.Lsp.CancelParams.mk]]
[Lean.Meta.Closure.ToProcessElement.mk.inj,[And.intro]]
[iff_iff_not_or_and_or_not,[Decidable.iff_iff_not_or_and_or_not]]
[self_eq_add_right,[Eq.mpr, Eq.refl, Iff, Eq, HAdd.hAdd, OfNat.ofNat, Eq.symm, propext, add_left_cancel_iff, add_zero, eq_comm, Iff.rfl]]
[Lean.ExprStructEq.instBEqExprStructEq,[BEq.mk, Lean.ExprStructEq.beq]]
[Function.update_noteq,[dif_neg]]
[Lean.Parser.ParserExtension.State.categories,[]]
[Lean.Expr.natLit?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.strVal, Lean.Expr.mdata, Lean.Expr.proj, Option, Nat, Option.some, Option.none]]
[ge_trans,[le_trans]]
[Lean.Server.Watchdog.findFileWorker?,[Bind.bind, MonadReader.read, ST.Ref.get, Lean.Server.Watchdog.ServerContext.fileWorkersRef, Pure.pure, Std.RBMap.find?]]
[Lean.Parser.Term.termUnless.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withForbidden.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer]]
[Lean.Parser.Term.subst.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.termParser.parenthesizer, Bool.false]]
[Lean.MessageData.nest.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MessageData.nest, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.Conv.rhs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Lsp.CompletionParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.CompletionParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[PSum.inl.inj,[]]
[Lean.PrettyPrinter.Parenthesizer.withoutInfo.parenthesizer,[]]
[List.length_eq_one,[Iff.intro, Exists, Eq, List.cons, List.nil, Exists.intro, rfl, Eq.mp, Eq.trans, congrFun, congrArg, List.length_cons, Nat.succ, OfNat.ofNat, Nat.succ.injEq, HAdd.hAdd, List.length, Eq.mpr, Eq.refl, of_eq_true, List.length_singleton, eq_true_of_decide, Bool.true]]
[Std.RBNode.min,[Unit.unit, Std.RBNode.node, Option, Sigma, Option.none, Option.some, Sigma.mk, PProd.fst]]
[Lean.PersistentExprSet,[Std.PHashSet, Lean.Expr]]
[Lean.Meta.Closure.ToProcessElement.newFVarId,[]]
[UInt8.isDigit,[and, Decidable.decide, GE.ge, OfNat.ofNat, LE.le]]
[Lean.LocalDecl.noConfusionType,[]]
[Lean.Meta.Context.config,[]]
[Lean.PrettyPrinter.Delaborator.orElse,[Lean.catchInternalId, Lean.PrettyPrinter.Delaborator.delabFailureId, Unit.unit]]
[Lean.Expr.proj.inj,[And.intro]]
[Lean.Parser.many1Fn,[Lean.Parser.ParserState.mkNode, Lean.nullKind]]
[instMonadWithReader,[MonadWithReader.mk, withTheReader]]
[Lean.FileMap.source,[]]
[Lean.Meta.isDefEqBindingDomain,[OfNat.ofNat, Lean.Meta.isDefEqBindingDomain.loop]]
[Lean.BinderInfo.toCtorIdx,[OfNat.ofNat]]
[Lean.Parser.Tactic.ring!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[List.noConfusionType,[]]
[exists_imp_distrib,[Iff.intro, Exists.intro]]
[exists₂_congr,[exists_congr]]
[floatDecLe,[Float.decLe]]
[Lean.LocalContext.contains,[Std.PersistentHashMap.contains, Lean.LocalContext.fvarIdToDecl]]
[Lean.Parser.Term.syntheticHole,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, HOrElse.hOrElse, Lean.Parser.Term.ident, Lean.Parser.Term.hole]]
[Lean.Elab.Term.ppGoal,[liftM, Lean.Meta.ppGoal]]
[Tactic.Ring.mkAppCS,[Bind.bind, MonadReader.read, Pure.pure, Lean.mkAppN, Lean.mkConst, List.cons, Tactic.Ring.Cache.univ, List.nil, HAppend.hAppend, List.toArray, Tactic.Ring.Cache.α, Tactic.Ring.Cache.cs]]
[Lean.Lsp.instToJsonReferenceContext,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.ReferenceContext.includeDeclaration, List.nil]]
[Lean.Parser.Command.declModifiersF,[Lean.Parser.Command.declModifiers, Bool.false]]
[Std.PersistentHashMap.mkCollisionNode.proof_1,[rfl]]
[Nat.mul_succ,[rfl]]
[System.FilePath.isCaseInsensitive,[or, System.Platform.isWindows, System.Platform.isOSX]]
[congr_arg,[congrArg]]
[DivInvMonoid.gpow_zero',[]]
[Nat.instXorNat,[Xor.mk, Nat.xor]]
[Lean.Elab.Term.Do.Code.action.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.find,[Bind.bind, liftM, Lean.Meta.findCore, ForIn.forIn, Lean.Meta.ppExpr, Lean.ConstantInfo.type, Pure.pure, PUnit.unit, ForInStep.yield]]
[Lean.Elab.Term.ExtractMonadResult.m,[]]
[Lean.Meta.SynthInstance.SubgoalsResult.mk.inj,[And.intro]]
[Lean.getAttributeImpl,[Unit.unit, Except, String, Lean.AttributeImpl, Std.PersistentHashMap.find?, Pure.pure, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Inhabited.noConfusionType,[]]
[Quotient.recOnSubsingleton₂.proof_2,[]]
[Lean.Parser.Term.letMVar,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.termParser]]
[and_iff_right_of_imp,[Iff.intro, And.right, And.intro]]
[Lean.instToExprName,[Lean.ToExpr.mk, Lean.Name.toExprAux, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[instHashableUSize,[Hashable.mk, USize.toUInt64]]
[Lean.Elab.Command.InductiveView.mk.inj,[And.intro]]
[Fin.mod.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[Nat.gcd_zero_left,[rfl]]
[Lean.Meta.setPostponed,[modify, Lean.Meta.State.mk, Lean.Meta.State.mctx, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds]]
[Lean.KeyedDeclsAttribute.ExtensionState.declNames,[]]
[instReprId_1,[inferInstanceAs, Repr]]
[Tactic.DeclCache.mk,[Bind.bind, Tactic.Cache.mk, Lean.MonadOptions.getOptions, Lean.profileitM, Lean.Exception, Pure.pure, Lean.MonadEnv.getEnv, ForIn.forIn, Lean.Meta.MetaM, ForInStep, PUnit.unit, ForInStep.yield, Prod.mk]]
[Lean.KVMap.set,[Lean.KVMap.insert, Lean.KVMap.Value.toDataValue]]
[EStateM.dummyRestore,[]]
[Lean.DelayedMetavarAssignment.mk.inj,[And.intro]]
[Lean.Lsp.instFromJsonInitializeParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.ClientCapabilities, Pure.pure, Lean.Lsp.InitializeParams.mk, Except.toOption]]
[Lean.Xml.Parser.markupDecl,[HOrElse.hOrElse, Lean.Xml.Parser.elementDecl, Lean.Xml.Parser.AttlistDecl, Lean.Xml.Parser.EntityDecl, Lean.Xml.Parser.NotationDecl, Lean.Xml.Parser.PI, SeqRight.seqRight, Lean.Xml.Parser.Comment, Pure.pure, Unit.unit]]
[Lean.Meta.UnificationConstraint.rhs,[]]
[Lean.Parser.attrParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.PrettyPrinter.Parenthesizer.errorAtSavedPos.parenthesizer,[Pure.pure, Unit.unit]]
[Nat.xor,[Nat.bitwise, bne]]
[Subtype.equiv_iff,[Iff.rfl]]
[Lean.Server.FileWorker.WorkerContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[NonScalar.val,[]]
[Lean.Parser.ParserCache.tokenCache,[]]
[Lean.Lsp.PlainTermGoal.mk.inj,[And.intro]]
[Lean.Occurrences.neg.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[imp_intro,[]]
[Lean.Parser.Term.proj,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, HOrElse.hOrElse, Lean.Parser.fieldIdx, Lean.Parser.Term.ident]]
[Lean.Elab.WF.TerminationStrategy.noConfusionType,[]]
[Add.noConfusionType,[]]
[Lean.ConstantInfo.inductInfo.injEq,[Eq.propIntro, Eq.refl, Lean.ConstantInfo.inductInfo, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Expr.approxDepth,[Lean.Expr.Data.approxDepth, Lean.Expr.data]]
[Lean.RecursorVal.numParams,[]]
[Lean.Elab.pushInfoLeaf,[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, ite, Eq, Lean.Elab.InfoState.enabled, Bool.true, Lean.Elab.pushInfoTree, Lean.Elab.InfoTree.node, Std.PersistentArray.mk, Pure.pure, PUnit.unit]]
[Lean.IR.EmitC.emitLit,[Bind.bind, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.M, Unit, Lean.IR.EmitC.emitNumLit, Lean.IR.EmitC.emitLn, Lean.IR.EmitC.emit, Lean.IR.EmitC.quoteString]]
[instHModUInt8NatUInt8,[HMod.mk, UInt8.modn]]
[Lean.IR.Sorry.visitDecl,[Lean.IR.Decl.extern, Lean.IR.Sorry.M, Unit, Bind.bind, MonadState.get, Unit.unit, Lean.NameMap.find?, Lean.IR.Sorry.State.localSorryMap, Pure.pure, ExceptT.run, Lean.IR.Sorry.visitFndBody, modify, Lean.IR.Sorry.State.mk, Lean.NameMap.insert, Bool.true]]
[Std.HashMapImp.mk.inj,[And.intro]]
[Lean.QuotVal.mk.inj,[And.intro]]
[Lean.Parser.Term.termReturn.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkLineEq.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Nat.lor,[Nat.bitwise, or]]
[Std.HashMapImp.contains,[Bool, Std.AssocList.contains, Array.uget, Subtype.val]]
[List.not_mem_append,[mt, Iff.mp, List.mem_append, Iff.mpr, not_or, Mem.mem, And.intro]]
[Lean.Elab.Command.CollectAxioms.State.visited,[]]
[Squash,[Quot, True]]
[Lean.Lsp.PlainTermGoalParams.toTextDocumentPositionParams,[]]
[Lean.Elab.Term.StructInst.FieldVal.nested.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.StructInst.FieldVal.nested, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Compiler.instInhabitedSpecState,[Inhabited.mk, Lean.Compiler.SpecState.mk, arbitrary]]
[Lean.IR.ExpandResetReuse.mkSlowPath,[Array.foldl, Unit.unit, Lean.IR.FnBody, Lean.IR.FnBody.inc, OfNat.ofNat, Bool.true, Bool.false, Array.size]]
[instSubsingletonForall.proof_1,[Subsingleton.intro, funext, Subsingleton.elim]]
[Lean.Lsp.instToJsonPlainGoal,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.PlainGoal.rendered, List.nil, Lean.Lsp.PlainGoal.goals]]
[Lean.instFromJsonJson,[Lean.FromJson.mk, Except.ok]]
[Std.HashSet.toArray,[Std.HashSet.fold, Array.push, List.toArray, List.nil]]
[Int.quot,[Int, Int.ofNat, HDiv.hDiv, Neg.neg, Nat.succ]]
[Nat.sub_self,[Unit.unit, Eq, HSub.hSub, OfNat.ofNat, Eq.mpr, Eq.refl, Nat.sub_zero, rfl, Nat.succ, Nat.succ_sub_succ, PProd.fst]]
[Lean.Parser.Tactic.unfold1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.Parser.Tactic.location]]
[Lean.Parser.Term.doMatch.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.generalizingParam.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.Term.matchDiscr.formatter, Bool.false, Lean.Parser.Term.optType.formatter, Lean.Parser.Term.doMatchAlts.formatter]]
[List.instSubsetList,[Subset.mk, List.subset]]
[Lean.MetavarContext.MkBinding.abstractRange,[Bind.bind, Lean.MetavarContext.MkBinding.elimMVarDeps, Pure.pure, Lean.Expr.abstractRange]]
[Lean.Meta.DiscrTree.Trie.node.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.DiscrTree.Trie.node, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.OpenDecl.simple.inj,[And.intro]]
[IO.FS.Stream.chainLeft,[IO.FS.Stream.mk, IO.FS.Stream.isEof, SeqRight.seqRight, IO.FS.Stream.flush, IO.FS.Stream.read, Bind.bind, IO.FS.Stream.write, ite, Eq, Bool.true, Pure.pure, PUnit.unit, IO.FS.Stream.getLine, IO.FS.Stream.putStr]]
[EStateM.instMonadExceptOfEStateM,[MonadExceptOf.mk, EStateM.throw, EStateM.tryCatch]]
[Lean.Elab.DefKind.abbrev.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.CongrTheorem.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.CongrTheorem.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Name.escapePart,[ite, Eq, and, Decidable.decide, GT.gt, String.length, OfNat.ofNat, Lean.isIdFirst, String.getOp, Substring.all, Substring.drop, String.toSubstring, Lean.isIdRest, Bool.true, Option.some, String.any, Lean.isIdEndEscape, Option.none, HAppend.hAppend, Char.toString, Lean.idBeginEscape, Lean.idEndEscape]]
[Lean.«doElemTrace[__]__»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[Lean.Parser.instInhabitedParserInfo,[Inhabited.mk, Lean.Parser.ParserInfo.mk, arbitrary]]
[Lean.Parser.Tactic.nthRwLHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Nat.succ.inj,[]]
[unsafeIO,[unsafeEIO]]
[Function.update_comm,[funext, Decidable.em, Eq, Eq.mpr, Eq.refl, dite, Eq.symm, dif_pos, Eq.trans, dif_neg, rfl]]
[Std.RBMap.max,[Option, Prod, Unit.unit, Std.RBNode.max, Option.some, Prod.mk, Option.none]]
[Lean.TraceElem.ref,[]]
[Lean.Parser.instBEqError,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[List.mem_map_of_mem,[Mem.mem, List.map, List.nil, Eq.refl, Eq.mpr, List.cons, Or.inl, rfl, Eq.symm, Or.inr]]
[Array.anyM,[dite, LE.le, Array.size, Array.anyM.proof_1]]
[Lean.Xml.Content.Comment.injEq,[Eq.propIntro, Eq.refl, Lean.Xml.Content.Comment, Eq.symm, eq_of_heq, HEq.refl]]
[Prod.map_comp_map,[funext, of_eq_true, Eq.trans, congr, congrArg, Eq, Function.comp_apply, Prod.map, prod_map, Prod.mk, Prod.fst, Prod.snd, Function.comp, eq_self]]
[Lean.Name.quickCmp,[Ordering.lt, Unit.unit, Ordering.gt, Ordering, Ord.compare, Lean.Name.hash, Lean.Name.quickCmpAux]]
[Lean.IR.instAlphaEqvExpr,[Lean.IR.AlphaEqv.mk, Lean.IR.Expr.alphaEqv]]
[Array.eraseIdx',[Array.eraseIdxSzAux, HAdd.hAdd, Fin.val, OfNat.ofNat, Array.eraseIdx'.proof_1]]
[Lean.Parser.Tactic.rcases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.casesTarget, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[Lean.instReprDeclarationRanges,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.DeclarationRanges.range, Std.Format.line, Lean.DeclarationRanges.selectionRange]]
[Array.binInsertM,[ite, Eq, Array.isEmpty, Bool.true, Bind.bind, Unit.unit, Pure.pure, Array.push, Array.get!, OfNat.ofNat, Array.insertAt, not, Array.modifyM, Array.back, HSub.hSub, Array.size]]
[Lean.Parser.Syntax.unary.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.syntaxParser.formatter]]
[Lean.unreachIsNodeIdent,[False.elim, Lean.unreachIsNodeIdent.proof_1]]
[List.decidableBexi,[Unit.unit, Decidable, Exists, And, Mem.mem, Decidable.isFalse, List.decidableBexi.proof_1, List.cons, Decidable.isTrue, List.decidableBexi.proof_2, PProd.fst, List.decidableBexi.proof_3, List.decidableBexi.proof_4]]
[Lean.Lsp.PublishDiagnosticsParams.noConfusionType,[]]
[Lean.Elab.Info.stx,[Lean.Syntax, Lean.Elab.ElabInfo.stx, Lean.Elab.TacticInfo.toElabInfo, Lean.Elab.TermInfo.toElabInfo, Lean.Elab.CommandInfo.toElabInfo, Lean.Elab.MacroExpansionInfo.stx, Lean.Elab.FieldInfo.stx, Lean.Elab.CompletionInfo.stx]]
[instComplementUInt16,[Complement.mk, UInt16.complement]]
[Lean.Lsp.Trace.messages.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[«term_<&&>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.AxiomVal.isUnsafe,[]]
[Lean.Parser.Command.check_failure,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser]]
[Lean.Meta.SimpLemmas.mk.inj,[And.intro]]
[Set.singletonUnexpander,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesIdent, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[AddGroup.add_left_neg,[]]
[Lean.PrettyPrinter.Parenthesizer.manyNoAntiquot.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.PrettyPrinter.Parenthesizer.visitArgs, Nat.forM, Array.size, Lean.Syntax.getArgs]]
[List.foldl,[PProd.fst]]
[Lean.ConstantInfo.ctorInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[ByteSliceT.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, ByteSliceT.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Export.Entry.defn.injEq,[Eq.propIntro, Eq.refl, Lean.Export.Entry.defn, Eq.symm, eq_of_heq, HEq.refl]]
[«term_∈_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.RecursorInfo.numIndices,[List.length, Lean.Meta.RecursorInfo.indicesPos]]
[Lean.addBuiltinDocString,[ST.Ref.modify, Lean.NameMap.insert]]
[Lean.Parser.Tactic.simpa!?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser]]
[Lean.MetavarContext.hasAssignedLevelMVar,[Bool, and, Lean.Level.hasMVar, PProd.fst, or, PProd.snd, Lean.MetavarContext.isLevelAssigned, Bool.false]]
[Lean.Parser.Tactic.assumption,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Parser.Attr.export,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident]]
[Lean.Parser.incQuotDepth,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.addQuotDepthFn, OfNat.ofNat, Lean.Parser.Parser.fn]]
[Lean.CollectLevelParams.State.collect,[Lean.collectLevelParams]]
[Lean.Xml.Parser.CharData,[SeqRight.seqRight, Lean.Parsec.notFollowedBy, Lean.Parsec.skipString, Lean.Parsec.manyChars, Lean.Parsec.satisfy, Decidable.decide, And, Ne, Char.ofNat]]
[AddCommGroup.toAddGroup,[]]
[Lean.IR.ExplicitBoxing.mkBoxedVersion,[StateT.run', Lean.IR.ExplicitBoxing.mkBoxedVersionAux, OfNat.ofNat]]
[Lean.ScopedEnvExtension.Entry.global.injEq,[Eq.propIntro, Eq.refl, Lean.ScopedEnvExtension.Entry.global, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Server.DocumentMeta.uri,[]]
[Nat.lt_add_of_pos_right,[Nat.add_lt_add_left]]
[Array.appendCore,[Array.size, OfNat.ofNat, Array.appendCore.loop]]
[Lean.Meta.ElimAltInfo.numFields,[]]
[Lean.Meta.simpStep,[Bind.bind, Lean.Meta.simp, ite, Eq, Lean.Expr.isConstOf, Lean.Meta.Simp.Result.expr, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Unit.unit, Lean.Meta.MetaM, Option, Prod, Lean.Expr, Lean.Meta.Simp.Result.proof?, Lean.Meta.getMVarType, Lean.Meta.mkEqMP, Lean.Meta.mkFalseElim, Lean.Meta.assignExprMVar, Pure.pure, Option.some, Prod.mk, bne, Lean.Meta.mkExpectedTypeHint]]
[Lean.hasInitAttr,[Option.isSome, Lean.getInitFnNameFor?]]
[Lean.JsonRpc.ResponseError.mk.inj,[And.intro]]
[Lean.Parser.Tactic.Conv.ringExp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Elab.Tactic.evalParen,[Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat]]
[Prod.fst,[]]
[IO.Error.resourceVanished.inj,[And.intro]]
[Lean.Elab.Term.PatternVar.anonymousVar.inj,[]]
[instSubsingletonEmpty.proof_1,[Subsingleton.intro, Empty.elim]]
[Array.range,[Nat.fold, flip, Array.push, List.toArray, List.nil]]
[instDecidableEq,[Decidable, Eq, Decidable.isTrue, propext, Decidable.isFalse, instDecidableEq.proof_1]]
[PointedType.val,[]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withProj,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.PrettyPrinter.Delaborator.SubExpr.descend, OfNat.ofNat, panicWithPosWithDecl]]
[Lean.version.minor,[Unit.unit]]
[Lean.MonadEnv.getEnv,[]]
[IO.Process.Child.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.ExpandResetReuse.CollectProjMap.collectVDecl,[Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.fap, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Lean.IR.ExpandResetReuse.ProjMap, Std.HashMap.insert]]
[Lean.Parser.instAndThenParser,[AndThen.mk, Lean.Parser.andthen, Unit.unit]]
[Lean.IR.UnreachableBranches.instToFormatValue,[Std.ToFormat.mk, Lean.IR.UnreachableBranches.Value.toFormat]]
[Lean.RecursorVal.isUnsafeEx,[Lean.RecursorVal.isUnsafe]]
[Lean.Parser.Attr.recursor.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.numLit.parenthesizer]]
[Lean.IR.LocalContextEntry.param.injEq,[Eq.propIntro, Eq.refl, Lean.IR.LocalContextEntry.param, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.derivingClasses.formatter,[Lean.Parser.sepBy1.formatter, Lean.Parser.group.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.structInst.formatter, Bool.false]]
[Lean.IR.HasIndex.visitArgs,[Array.any, Lean.IR.HasIndex.visitArg, OfNat.ofNat, Array.size]]
[Std.AssocList.isEmpty,[Unit.unit, Std.AssocList.cons, Bool, Bool.true, Bool.false]]
[instSemiringFin.proof_14,[of_eq_true, Eq.trans, congrArg, Eq, Fin.mk, HMod.hMod, HAdd.hAdd, OfNat.ofNat, Nat.mod_lt, Fin.size_positive', Fin.add_def, Fin.mk.injEq, Fin.val, Fin.size_positive, congrFun, Fin.one_def, Nat.add_mod_mod, Nat.mod_add_mod, eq_self]]
[Lean.Meta.isTypeFormer,[Bind.bind, Lean.Meta.inferType, Lean.Meta.isTypeFormerType]]
[Lean.MessageData.instCoeOptionExprMessageData,[Coe.mk, Unit.unit, Lean.MessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.MessageData.ofExpr]]
[Lean.Elab.Term.MutualClosure.FixPoint.State.mk.inj,[And.intro]]
[Lean.Lsp.ReferenceContext.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.ReferenceContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.ppSpace.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.skip.parenthesizer]]
[Fin.add.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[Std.RBMap.maxDepth,[Std.RBNode.depth, Nat.max, Subtype.val]]
[Std.PersistentHashMap.mkCollisionNode,[Std.PersistentHashMap.Node.collision, Std.PersistentHashMap.mkCollisionNode.proof_1]]
[Lean.Parser.isParserAlias,[Bind.bind, Lean.Parser.getAlias, Lean.Parser.parserAliasesRef, Option.none, IO, Bool, Pure.pure, Bool.true, Bool.false]]
[StateT.modifyGet,[Pure.pure]]
[List.insert,[ite, Mem.mem, List.cons]]
[Except.map_id,[funext, Eq.mpr, congr, congrArg, Eq, Except, Except.error, Except.ok, id_eq, rfl, Eq.symm, Eq.refl]]
[Lean.Environment.getModuleIdxFor?,[Std.HashMap.find?, Lean.Environment.const2ModIdx]]
[IO.Process.SpawnArgs.toStdioConfig,[]]
[Lean.Level.updateSucc!,[Lean.Level.zero, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Level, Lean.Level.updateSucc, Lean.Level.succ, Lean.Level.updateSucc!.proof_1, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Parser.Tactic.refineStruct,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.Parser.instInhabitedError,[Inhabited.mk, Lean.Parser.Error.mk, arbitrary]]
[Lean.Elab.Structural.RecArgInfo.fixedParams,[]]
[Lean.KernelException.unknownConstant.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.ReducibilityStatus.noConfusion,[noConfusionEnum, Lean.ReducibilityStatus.toCtorIdx]]
[Lean.Parsec.fail,[Lean.Parsec.ParseResult.error]]
[Lean.Elab.Tactic.getCurrMacroScope,[Bind.bind, readThe, Lean.Elab.Term.Context, Pure.pure, Lean.Elab.Term.Context.currMacroScope]]
[UInt8.mk_val_eq,[Eq, UInt8.mk, UInt8.val, rfl]]
[Lean.MessageLog.noConfusionType,[]]
[List.rotateLeft,[ite, LE.le, OfNat.ofNat, HAppend.hAppend]]
[Lean.checkTraceOption,[ite, Eq, Lean.KVMap.isEmpty, Bool.true, Bool.false, Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Bool, or, Lean.KVMap.getBool, and, not, Lean.KVMap.contains, PProd.fst, HAppend.hAppend, Lean.Name.mkStr]]
[Equiv.to_fun_as_coe,[rfl]]
[Lean.MacroM,[ReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State]]
[Lean.Parser.Command.theorem,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.declId, Lean.Parser.Command.declSig, Lean.Parser.Command.declVal, Lean.Parser.Command.terminationSuffix]]
[Lean.Import.runtimeOnly,[]]
[And.symm,[And, And.intro]]
[Lean.Elab.Deriving.Hashable.mkHashableHandler,[Bind.bind, Array.allM, Lean.isInductive, OfNat.ofNat, Array.size, ite, Eq, and, Decidable.decide, GT.gt, Bool.true, Lean.Elab.Command.liftTermElabM, Option.none, Lean.Elab.Deriving.mkContext, Array.getOp, Lean.Elab.Deriving.Hashable.mkHashFuncs, Lean.Elab.Deriving.mkInstanceCmds, Lean.Name.mkStr, Lean.Name.anonymous, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Array.forM, Lean.Elab.Command.elabCommand, Bool.false]]
[Semigroup.mul_assoc,[]]
[Lean.LocalDecl.cdecl.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.LocalDecl.cdecl, Eq.symm, eq_of_heq, HEq.refl]]
[«term_+_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.PersistentEnvExtensionDescr.statsFn,[]]
[Lean.Meta.synthAppInstances,[Nat.forM, Array.size, ite, Eq, Lean.BinderInfo.isInstImplicit, Array.getOp, Bool.true, Bind.bind, Lean.Meta.inferType, Lean.Meta.synthInstance, Option.none, Lean.Meta.isDefEq, Pure.pure, PUnit.unit, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing]]
[ExceptCpsT.instMonadExceptOfExceptCpsT,[MonadExceptOf.mk]]
[Lean.ExternEntry.adhoc.inj,[]]
[Lean.mkDefaultFnOfProjFn,[HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Meta.instInhabitedUnificationHints,[Inhabited.mk, Lean.Meta.UnificationHints.mk, arbitrary]]
[optional,[HOrElse.hOrElse, Functor.map, Option.some, Pure.pure, Option.none]]
[Lean.Elab.Term.StructInst.Struct.mk.inj,[And.intro]]
[Lean.IR.instBEqJoinPointId,[BEq.mk, BEq.beq, Lean.IR.JoinPointId.idx]]
[Lean.Expr.bindingName!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Name, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Parser.Tactic.rcasesPatLo,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.Parser.Tactic.rcasesPatMed, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat]]
[Lean.MetavarContext.eraseDelayed,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Lean.MetavarContext.decls, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Std.PersistentHashMap.erase, Lean.MetavarContext.dAssignment]]
[Lean.Elab.Tactic.tagUntaggedGoals,[Bind.bind, Lean.MonadMCtx.getMCtx, ForIn.forIn, ite, Eq, Lean.MetavarContext.isAnonymousMVar, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, Lean.MonadMCtx.modifyMCtx, Id.run, MProd.mk, BEq.beq, OfNat.ofNat, Id, Lean.MetavarContext]]
[IO.FS.DirEntry.mk.inj,[And.intro]]
[Std.HashMap.fold,[Std.HashMapImp.fold]]
[Lean.Meta.checkApp,[Bind.bind, Lean.Meta.inferType, Lean.Meta.whnf, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Unit, Lean.Meta.isDefEq, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.throwAppTypeMismatch, Lean.MessageData.ofFormat, Std.Format.nil, Lean.Meta.throwFunctionExpected, Lean.mkApp]]
[Lean.Elab.PreDefinition.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.PreDefinition.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.MetavarContext.mkBinding,[Lean.MetavarContext.MkBinding.mkBinding, Bool.false]]
[Std.ShareCommonT,[StateT, Std.ShareCommon.State]]
[Lean.Elab.DefView.modifiers,[]]
[Lean.ConstantInfo.defnInfo.injEq,[Eq.propIntro, Eq.refl, Lean.ConstantInfo.defnInfo, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.stx.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.syntaxParser.formatter]]
[ite_id,[rfl, Eq.symm, Eq.refl]]
[Lean.Server.Watchdog.FileWorker.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.DocumentSymbolAux.detail?,[]]
[Lean.Meta.ParamInfo.isInstImplicit,[BEq.beq, Lean.Meta.ParamInfo.binderInfo, Lean.BinderInfo.instImplicit]]
[bfix1,[PProd.fst]]
[Lean.JsonNumber.instCoeNatJsonNumber,[Coe.mk, Lean.JsonNumber.fromNat]]
[Lean.Elab.ContextInfo.ppSyntax,[Lean.ppTerm, Lean.Elab.ContextInfo.toPPContext]]
[IO.Error.resourceExhausted.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.resourceExhausted, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Server.FileWorker.RpcSession.new,[Bind.bind, Functor.map, ByteArray.toUInt64LE!, IO.getRandomBytes, OfNat.ofNat, liftM, IO.monoMsNow, Pure.pure, Prod.mk]]
[Lean.IR.getDecls,[Lean.SimplePersistentEnvExtension.getEntries, Lean.IR.declMapExt]]
[Lean.Meta.Hypothesis.mk.inj,[And.intro]]
[noConfusionEnum.proof_1,[Eq.symm, if_pos]]
[Lean.Meta.ToHide.State.noConfusionType,[]]
[List.mapTRAux,[List, List.reverse, PProd.fst, List.cons]]
[Lean.Elab.tryContradiction,[Bind.bind, MonadExcept.tryCatch, Lean.Meta.contradiction, Lean.Meta.Contradiction.Config.mk, Bool.true, Pure.pure, Bool.false]]
[Function.update_injective,[]]
[Lean.Elab.Term.Do.ToCodeBlock.Catch.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.ToCodeBlock.Catch.mk, Eq.symm, eq_of_heq, HEq.refl]]
[UInt32.size,[OfNat.ofNat]]
[Option.instFunctorOption,[Functor.mk, Option.map]]
[List.hasDecEq.proof_1,[rfl]]
[Lean.mkTagDeclarationExtension,[Lean.registerSimplePersistentEnvExtension, Lean.SimplePersistentEnvExtensionDescr.mk, Lean.NameSet.insert, EmptyCollection.emptyCollection, Array.qsort, List.toArray, Lean.Name.quickLt, OfNat.ofNat, HSub.hSub, Array.size]]
[Lean.Parser.withoutInfo,[Lean.Parser.Parser.mk, Lean.Parser.Parser.fn]]
[instDecidableLt_4,[USize.decLt]]
[Lean.Lsp.PlainGoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.PlainGoal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.ppTerm,[ite, Eq, Lean.Option.get, Lean.PPContext.opts, Lean.pp.raw, Bool.true, Pure.pure, Unit.unit, MonadExcept.tryCatch, Lean.PPFns.ppTerm, Lean.EnvExtension.getState, Lean.ppExt, Lean.PPContext.env, Lean.pp.rawOnError, HAppend.hAppend, Std.ToFormat.format, Std.Format.line]]
[Lean.Name.below,[PUnit, PProd]]
[Std.HashMapImp.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.HashMapImp.mk, Eq.symm, eq_of_heq, HEq.refl]]
[USize.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd]]
[IO.FS.Metadata.noConfusionType,[]]
[Lean.IR.LocalContextEntry.joinPoint.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[tacticRepeat'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser]]
[Lean.IR.mkUProjExpr,[Lean.IR.Expr.uproj]]
[Lean.MetavarContext.findDecl?,[Std.PersistentHashMap.find?, Lean.MetavarContext.decls]]
[List.Perm.refl,[Unit.unit, List.Perm, List.Perm.nil, List.Perm.cons, PProd.fst]]
[Lean.Parser.Command.namedName.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.ident.formatter]]
[Lean.Meta.NormNum.LawfulOfNat.noConfusionType,[]]
[Nat.lcm,[HDiv.hDiv, HMul.hMul, Nat.gcd]]
[Lean.MonadStateCacheT.instMonadLiftMonadStateCacheT,[inferInstanceAs, MonadLift, StateT, Std.HashMap]]
[Lean.Expr.app.inj,[And.intro]]
[Lean.SimpleScopedEnvExtension.Descr.initial,[]]
[Lean.IR.IRType.below,[PUnit, PProd]]
[String.leftpad_prefix,[String.isPrefix, String.repeat, HSub.hSub, String.length, String.leftpad, of_eq_true, eq_true, List.leftpad_prefix]]
[Lean.mkApp9,[Lean.mkApp5, Lean.mkApp4]]
[Lean.Meta.Cases.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.IndPredBelow.Variables.motives,[]]
[IO.Error.hardwareFault.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.hardwareFault, Eq.symm, eq_of_heq, HEq.refl]]
[String.leftpad_suffix,[String.isSuffix, String.leftpad, of_eq_true, eq_true, List.leftpad_suffix]]
[Lean.Elab.Tactic.Conv.getLhsRhsCore,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getMVarType, Lean.Meta.matchEq?, Option.none, Lean.Meta.MetaM, Prod, Lean.Expr, Pure.pure, Prod.mk, Lean.throwError, Lean.ToMessageData.toMessageData]]
[List.erasep_cons_of_pos,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.erasep_cons, ite_congr, eq_true, Eq.refl, List.cons, List.erasep, ite_true, eq_self]]
[Lean.Elab.checkIfShadowingStructureField,[Lean.Name.anonymous, Lean.Name.num, Unit, Bind.bind, Lean.MonadEnv.getEnv, ite, Eq, Lean.isStructure, Bool.true, ForIn.forIn, PUnit.unit, BEq.beq, HAppend.hAppend, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, ForInStep.yield, Unit.unit]]
[Lean.Elab.Term.toParserDescr,[Bind.bind, Lean.MonadEnv.getEnv, StateRefT'.run, Lean.Elab.Term.ToParserDescrContext.mk, Bool.true, Option.none, Lean.Elab.Term.toParserDescr.process, Lean.Elab.Term.toParserDescr.processSeq, Lean.Elab.Term.toParserDescr.resolveParserName, Lean.Elab.Term.toParserDescr.ensureNoPrec, Lean.Elab.Term.toParserDescr.processParserCategory, Lean.Elab.Term.toParserDescr.processNullaryOrCat, Lean.Elab.Term.toParserDescr.processUnary, Lean.Elab.Term.toParserDescr.processBinary, Lean.Elab.Term.toParserDescr.processSepBy, Lean.Elab.Term.toParserDescr.processSepBy1, Lean.Elab.Term.toParserDescr.isValidAtom, Lean.Elab.Term.toParserDescr.processAtom, Lean.Elab.Term.toParserDescr.processNonReserved]]
[Nat.mod_two_eq_zero_or_one,[Or, Eq, OfNat.ofNat, HMod.hMod, Nat.mod_lt, of_eq_true, eq_true_of_decide, Eq.refl, Bool.true, Or.inl, rfl, Or.inr, absurd, Nat.not_lt_zero, Nat.lt_of_succ_lt_succ]]
[Std.RBTree.empty,[Std.RBMap.empty]]
[Int.instModInt,[Mod.mk, Int.mod]]
[Lean.LocalDecl.isAuxDecl,[Lean.BinderInfo.isAuxDecl, Lean.LocalDecl.binderInfo]]
[Lean.IR.Checker.checkObjVar,[Lean.IR.Checker.checkVarType, Lean.IR.IRType.isObj]]
[Lean.Lsp.ServerCapabilities.definitionProvider,[]]
[Lean.Elab.WF.TerminationHint.one.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.WF.TerminationHint.one, Eq.symm, eq_of_heq, HEq.refl]]
[Std.PersistentHashMap.branching,[USize.ofNat, HPow.hPow, OfNat.ofNat, USize.toNat, Std.PersistentHashMap.shift]]
[Lean.Meta.mkSizeOfFn,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Nat.mul_lt_mul_of_pos_left,[Nat.lt_of_lt_of_le, Nat.add_lt_add_left, Nat.mul, Nat.mul_le_mul_left, Nat.succ_le_of_lt, Nat.mul_succ]]
[UInt64.instSemiringUInt64.proof_11,[Eq.mpr, congr, congrArg, Eq, Eq.trans, HMul.hMul, UInt64.add_def, UInt64.mul_def, UInt64.mk, HAdd.hAdd, UInt64.val, UInt64.eq_of_val_eq, Semiring.mul_add]]
[Lean.Parser.nonReservedSymbol.formatter,[Lean.PrettyPrinter.Formatter.tokenWithAntiquot.formatter, Lean.PrettyPrinter.Formatter.nonReservedSymbolNoAntiquot.formatter]]
[Lean.mkNullNode,[Lean.mkNode, Lean.nullKind]]
[Lean.AxiomVal.toConstantVal,[]]
[IO.Error.mkNoFileOrDirectory,[IO.Error.noFileOrDirectory]]
[Lean.Lsp.RpcReleaseParams.mk.inj,[And.intro]]
[Lean.Meta.ElimInfo.mk.inj,[And.intro]]
[Lean.KeyedDeclsAttribute.AttributeEntry.toOLeanEntry,[]]
[instSubUInt8,[Sub.mk, UInt8.sub]]
[Lean.IR.EmitC.emitInitFn,[Bind.bind, Lean.IR.EmitC.getEnv, Lean.IR.EmitC.getModName, Array.forM, Lean.IR.EmitC.emitLn, HAppend.hAppend, Lean.mkModuleInitializationFunctionName, Lean.Import.module, Lean.Environment.imports, OfNat.ofNat, Array.size, Lean.IR.EmitC.emitLns, List.cons, List.nil, List.forM, List.reverse, Lean.IR.EmitC.emitDeclInit]]
[Lean.Parser.Module.module.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Module.header.formatter, Lean.Parser.many.formatter, Lean.Parser.commandParser.formatter, Lean.ppLine.formatter]]
[Lean.Parser.ParserState.restore,[Lean.Parser.ParserState.mk, Array.shrink, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.cache, Option.none]]
[Lean.KVMap.isEmpty,[Bool, List.isEmpty]]
[Lean.Meta.splitAnd,[Lean.Meta.saturate, Lean.observing?, Lean.Meta.apply, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Lean.Lsp.TextDocumentPositionParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.constructor,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType', Lean.matchConstInduct, Lean.Expr.getAppFn, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, MonadExcept.tryCatch, Lean.Meta.apply, Lean.mkConst, Pure.pure, DoResultPR.return, Unit.unit, DoResultPR.pure, Lean.Meta.MetaM, ForInStep, MProd, Option, List, Lean.MVarId, PUnit, ForInStep.yield, ForInStep.done, Option.some, MProd.fst]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.evalConst,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, Lean.ofExcept, Lean.Environment.evalConst]]
[Lean.Elab.Tactic.AuxMatchTermState.noConfusionType,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[variables,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[iff_true_intro,[Iff.intro, True.intro]]
[Nat.coprime.gcd_right,[Nat.coprime.coprime_dvd_right, Nat.gcd_dvd_right]]
[Lean.Elab.Term.expandMacrosInPatterns,[Array.mapM, Bind.bind, Lean.expandMacros, Lean.Elab.Term.MatchAltView.patterns, Pure.pure, Lean.Elab.Term.MatchAltView.mk, Lean.Elab.Term.MatchAltView.ref, Lean.Elab.Term.MatchAltView.rhs]]
[Lean.Xml.Parser.S,[Lean.Parsec.many1Chars, HOrElse.hOrElse, Lean.Parsec.pchar, Char.ofNat, Lean.Xml.Parser.endl]]
[Lean.Elab.Term.expandMatchAltsIntoMatch,[Lean.withRef, Lean.MacroM, Lean.Syntax, ite, Eq, Bool.true, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.MonadQuotation.withFreshMacroScope, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, PProd.fst, Array.push, Array.size]]
[Lean.Meta.Split.simpMatch.pre,[Bind.bind, Lean.Meta.matchMatcherApp?, Option.none, Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step, liftM, Lean.Meta.reduceRecMatcher?, Unit.unit, Pure.pure, Lean.Meta.Simp.Step.done, Lean.Meta.Simp.Result.mk, Lean.Meta.Match.getEquationsFor, Lean.Meta.MatcherApp.matcherName, ForIn.forIn, MProd.mk, PUnit.unit, Lean.Meta.withReducible, Lean.Meta.Simp.tryLemma?, Lean.Meta.SimpLemma.mk, Lean.mkConst, List.nil, Option.some, Lean.Meta.SplitIf.discharge?, Bool.false, ForInStep, MProd, Option, PUnit, ForInStep.yield, ForInStep.done, MProd.fst, Lean.Meta.Simp.Step.visit]]
[Lean.Meta.InjectionResult.subgoal.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.InjectionResult.subgoal, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Delaborator.isType2Type,[Bind.bind, Lean.Meta.inferType, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Bool, Pure.pure, Bool.true, Bool.false]]
[Lean.Meta.mkLetValCongr,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil]]
[Lean.Meta.assertHypotheses,[ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Prod.mk, List.toArray, List.nil, Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarTag, Lean.Meta.getMVarType, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.assignExprMVar, Lean.Meta.introNP, Lean.Expr.mvarId!, Array.size]]
[Lean.Server.Watchdog.updateFileWorkers,[Bind.bind, MonadReader.read, ST.Ref.modify, Lean.Server.Watchdog.ServerContext.fileWorkersRef, Std.RBMap.insert, Lean.Server.DocumentMeta.uri, Lean.Server.Watchdog.OpenDocument.meta, Lean.Server.Watchdog.FileWorker.doc]]
[Function.extend_comp,[funext, Function.extend_apply]]
[Lean.Meta.Match.Pattern.var.inj,[]]
[Bool.false_or,[rfl, Eq.symm, Eq.refl]]
[Lean.Meta.throwIsDefEqStuck,[MonadExcept.throw, Lean.Exception.internal, Lean.Meta.isDefEqStuckExceptionId, Lean.KVMap.mk]]
[Lean.Parser.Term.doContinue,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[unexpandSorryAx,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[instToStreamArraySubarray,[ToStream.mk, Array.toSubarray, OfNat.ofNat, Array.size]]
[Lean.MessageData.ofGoal.inj,[]]
[PSigma.lexNdepWf.proof_1,[WellFounded.intro, Acc, PSigma.lexNdep, PSigma.lexAccessible, WellFounded.apply]]
[Lean.Elab.Command.ElabHeaderResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.ElabHeaderResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[IO.mapTask,[EIO.mapTask]]
[Lean.IR.Borrow.ParamMap.fmt,[HAppend.hAppend, Std.Format.text, Std.Format.nest, OfNat.ofNat]]
[Lean.Elab.Command.expandNotationItemIntoSyntaxItem,[ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Lean.mkNode, List.toArray, List.cons, Lean.mkIdentFrom, Lean.Syntax.getOp, OfNat.ofNat, List.nil, Lean.strLitKind, Lean.Macro.throwUnsupported]]
[let_body_eq,[Eq.mpr, Eq.refl, Eq, rfl]]
[coeBase,[CoeTC.mk, coeB]]
[Lean.MacroScopesView.noConfusionType,[]]
[Nat.foldRevM.loop,[Pure.pure, Bind.bind, PProd.fst]]
[FloatArray.get,[Float, Array.get]]
[Lean.Expr.forallE.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.forallE, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.DataValue.ofName.injEq,[Eq.propIntro, Eq.refl, Lean.DataValue.ofName, Eq.symm, eq_of_heq, HEq.refl]]
[instMulUSize,[Mul.mk, USize.mul]]
[unexpandProdMk,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, Unit.unit]]
[Lean.instToStringImport,[ToString.mk, HAppend.hAppend, ToString.toString, Lean.Import.module, ite, Eq, Lean.Import.runtimeOnly, Bool.true]]
[Lean.Lsp.TextDocumentContentChangeEvent.fullChange.inj,[]]
[Lean.Lsp.LineRange.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.LineRange.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.addQuotDepthFn,[Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.prec, Lean.Parser.ParserContext.tokens, Int.toNat, HAdd.hAdd, Int.ofNat, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Parser.ParserContext.savedPos?, Lean.Parser.ParserContext.forbiddenTk?]]
[Lean.PrettyPrinter.Formatter.visitArgs,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, GT.gt, Array.size, Lean.Syntax.getArgs, OfNat.ofNat, SeqLeft.seqLeft, SeqRight.seqRight, Lean.Syntax.MonadTraverser.goDown, HSub.hSub, Lean.Syntax.MonadTraverser.goUp, Pure.pure, PUnit.unit]]
[Int.add_comm,[Eq, HAdd.hAdd, of_eq_true, Eq.trans, congr, congrArg, Int.ofNat_add_ofNat, Int.ofNat, Nat.add_comm, eq_self, rfl, Int.negSucc_ofNat_add_negSucc_ofNat, Int.negSucc, Nat.succ]]
[Lean.Json.instCoeBoolJson,[Coe.mk, Lean.Json.bool]]
[instMulUInt64,[Mul.mk, UInt64.mul]]
[Lean.mkMVar,[Lean.Expr.mvar, Lean.Expr.mkData, mixHash, OfNat.ofNat, Hashable.hash, Bool.false, Bool.true]]
[Lean.Parser.Syntax.binary.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.syntaxParser.formatter]]
[Iff.elim_right,[Iff.elim_right.proof_1]]
[le_trans,[Preorder.le_trans]]
[Lean.Parser.Command.mixfixKind,[HOrElse.hOrElse, Lean.Parser.Command.prefix, Lean.Parser.Command.infix, Lean.Parser.Command.infixl, Lean.Parser.Command.infixr, Lean.Parser.Command.postfix]]
[Lean.Server.FileWorker.RpcSession.noConfusionType,[]]
[«termExists_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
[UInt16.instNumericUInt16,[Numeric.mk, UInt16.mk, Numeric.ofNat]]
[FloatSpec.le,[]]
[Lean.Elab.Command.StructFieldInfo.name,[]]
[Lean.Syntax.isNodeOf,[and, Lean.Syntax.isOfKind, BEq.beq, Lean.Syntax.getNumArgs]]
[IO.Process.run,[Bind.bind, IO.Process.output, ite, Eq, bne, IO.Process.Output.exitCode, OfNat.ofNat, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, IO.Process.SpawnArgs.cmd, ToString.toString, Pure.pure, PUnit.unit]]
[Lean.Meta.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.NameSSet,[Lean.SSet, Lean.Name]]
[Lean.DataValue.ofNat.inj,[]]
[List.filter,[List.filterAux, List.nil]]
[instReprList,[Repr.mk, Std.Format, List.cons, Std.Format.text, Std.Format.bracket, Std.Format.joinSep, HAppend.hAppend, Std.Format.line]]
[Lean.MData.empty,[Lean.KVMap.mk]]
[Lean.IR.IRType.struct.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, Eq.refl, List.nil, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec]]
[Lean.Meta.saveAndResetSynthInstanceCache,[Bind.bind, MonadState.get, Lean.Meta.modifyCache, Lean.Meta.Cache.mk, Lean.Meta.Cache.inferType, Lean.Meta.Cache.funInfo, Std.PersistentHashMap.mk, Lean.Meta.Cache.whnfDefault, Lean.Meta.Cache.whnfAll, Lean.Meta.Cache.defEqDefault, Lean.Meta.Cache.defEqAll, Pure.pure]]
[Lean.PersistentEnvExtension.name,[]]
[neg_eq_of_add_eq_zero,[left_neg_eq_right_neg, neg_add_self]]
[Lean.Elab.Tactic.elabSetOption,[Bind.bind, Lean.Elab.elabSetOption, Lean.Syntax.getOp, OfNat.ofNat, withTheReader, Lean.Core.Context, Lean.Core.Context.mk, Lean.Core.Context.currRecDepth, Lean.Option.get, Lean.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats, Lean.Elab.Tactic.evalTactic]]
[Lean.IR.EmitC.emitSet,[Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitArg, Lean.IR.EmitC.emitLn]]
[Lean.KVMap.instValueBool,[Lean.KVMap.Value.mk, Lean.DataValue.ofBool, Lean.DataValue.ofString, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Option, Bool, Option.some, Option.none]]
[Lean.MessageData.instCoeFormatMessageData,[Coe.mk, Lean.MessageData.ofFormat]]
[Lean.Meta.MatcherApp.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.MatcherApp.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.DataValue.ofBool.injEq,[Eq.propIntro, Eq.refl, Lean.DataValue.ofBool, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Compiler.InlineAttributeKind.noinline.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Subtype.eq,[Eq.symm, eq_of_heq, Eq.refl, Subtype.val, Subtype.mk, HEq.refl, Eq, rfl]]
[Lean.Meta.abstractRange,[Lean.Meta.liftMkBindingM, Lean.MetavarContext.abstractRange]]
[Lean.TraceElem.noConfusionType,[]]
[Lean.AttributeExtensionOLeanEntry.decl.inj,[]]
[Lean.Elab.ElabInfo.elaborator,[]]
[Lean.Elab.Level.LevelElabM,[ReaderT, Lean.Elab.Level.Context, EStateM, Lean.Exception, Lean.Elab.Level.State]]
[Lean.Syntax.asNode.proof_1,[Lean.IsNode.mk, Lean.SourceInfo.none, Lean.nullKind, List.toArray, List.nil]]
[Lean.Syntax.Traverser.parents,[]]
[Lean.IR.Checker.checkScalarType,[Lean.IR.Checker.checkType, Lean.IR.IRType.isScalar]]
[List.decidableMem.proof_1,[Or.inl]]
[Lean.Meta.GeneralizeIndicesSubgoal.indicesFVarIds,[]]
[Lean.Meta.Cache.mk.inj,[And.intro]]
[Lean.Elab.Term.Quotation.HeadInfo.check,[]]
[«term_≠_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.Term.PatternVarDecl.anonymousVar.inj,[And.intro]]
[Lean.Parser.Command.mixfix,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.attrKind, Lean.Parser.Command.mixfixKind, Lean.Parser.precedence, Lean.Parser.Command.optNamedName, Lean.Parser.Command.optNamedPrio, Lean.Parser.ppSpace, Lean.Parser.strLit, Lean.Parser.darrow, Lean.Parser.termParser]]
[ULift.noConfusionType,[]]
[Lean.IR.FnBody.jdecl.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.jdecl, Eq.symm, eq_of_heq, HEq.refl]]
[Option.all,[Unit.unit, Bool, Bool.true]]
[IO.Process.SpawnArgs.env,[]]
[Std.AssocList.below,[PUnit, PProd]]
[Lean.Parser.TokenMap,[Std.RBMap, Lean.Name, List, Lean.Name.quickCmp]]
[Lean.Elab.Command.printPrefix,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Lean.ImportState.regions,[]]
[Lean.Lsp.TextEdit.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Json.Structured.obj.injEq,[Eq.propIntro, Eq.refl, Lean.Json.Structured.obj, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Modifiers.noConfusionType,[]]
[Lean.Meta.UnificationHint.noConfusionType,[]]
[Lean.Syntax.foldArgsM,[Array.foldlM, flip, Lean.Syntax.getArgs, OfNat.ofNat, Array.size]]
[List.ne_and_not_mem_of_not_mem_cons,[And.intro, List.ne_of_not_mem_cons, List.not_mem_of_not_mem_cons]]
[System.Platform.isOSX,[System.Platform.getIsOSX, Unit.unit]]
[eq_or_lt_of_not_lt,[dite, Eq, Or.inl, Or.inr, lt_of_not_ge, lt_of_le_of_ne]]
[Lean.Parser.Term.macroDollarArg,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser]]
[Lean.MetavarContext.userNames,[]]
[Lean.IR.IRType.uint8.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[UInt64.eq_of_val_eq,[Eq, congrArg, UInt64.mk]]
[Lean.Option.defValue,[]]
[Lean.Server.Watchdog.ServerContext.hIn,[]]
[Lean.Elab.OpenDecl.State.mk.inj,[And.intro]]
[Quot.liftIndepPr1,[Quot.ind, rfl]]
[Lean.JsonRpc.instToJsonErrorCode,[Lean.ToJson.mk, Unit.unit, Lean.Json, Lean.Json.num, Lean.JsonNumber.fromInt, Neg.neg, OfNat.ofNat]]
[Lean.DefinitionVal.mk.inj,[And.intro]]
[Lean.Meta.mkLt,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil]]
[USize.size_positive,[usize_size_gt_zero]]
[Lean.PrettyPrinter.Formatter.throwBacktrack,[MonadExcept.throw, Lean.Exception.internal, Lean.PrettyPrinter.backtrackExceptionId, Lean.KVMap.mk]]
[Lean.Elab.WF.TerminationHint.erase,[Unit.unit, Lean.Elab.WF.TerminationHint, Lean.Elab.WF.TerminationHint.none, Id.run, Bind.bind, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, ite, Eq, Lean.NameMap.contains, Bool.true, Std.RBMap.isEmpty, Pure.pure, ForInStep.done, Option.some, Lean.Elab.WF.TerminationHint.many, ForInStep.yield, Id, MProd.fst]]
[Lean.Elab.Command.failIfSucceeds,[Bind.bind, tryFinally, MonadExcept.tryCatch, Lean.Elab.Command.hasNoErrorMessages, Lean.Exception.error, Lean.Elab.Command.CommandElabM, Bool, Lean.Elab.logException, Pure.pure, Bool.false, liftM, Lean.InternalExceptionId.getName, Lean.Elab.logError, Lean.MessageData.ofName]]
[Lean.Elab.Command.StructCtorView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.StructCtorView.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.DocumentSymbol.noConfusionType,[]]
[Lean.Parser.ParserInfo.collectKinds,[]]
[Lean.Elab.TermInfo.runMetaM,[Lean.Elab.ContextInfo.runMetaM, Lean.Elab.TermInfo.lctx]]
[List.length_eq_lenghtTR,[funext, of_eq_true, Eq.trans, congrArg, Eq, List.length, Eq.symm, List.length_add_eq_lengthTRAux, OfNat.ofNat, Nat.add_zero, eq_self]]
[Lean.Lsp.instToJsonDiagnosticRelatedInformation,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.DiagnosticRelatedInformation.location, List.nil, Lean.Lsp.DiagnosticRelatedInformation.message]]
[Lean.Unhygienic.Context.mk.inj,[And.intro]]
[Lean.Parser.Trie.instEmptyCollectionTrie,[EmptyCollection.mk, Lean.Parser.Trie.empty]]
[Decidable.not_not_iff,[Iff.intro, Decidable.of_not_not, not_not_intro]]
[Lean.Meta.SynthInstance.GeneratorNode.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SynthInstance.GeneratorNode.mk, Eq.symm, eq_of_heq, HEq.refl]]
[or_iff_right_iff_imp,[Eq.mpr, Eq.refl, Iff, Or, propext, or_comm, or_iff_left_iff_imp, Iff.rfl]]
[Std.RBTree.foldM,[Std.RBMap.foldM]]
[Lean.Level.param.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Level.param, Eq.symm, eq_of_heq, HEq.refl]]
[UInt64.decEq.proof_1,[rfl]]
[Lean.Parser.many1Indent.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGe.parenthesizer]]
[Lean.Parser.Term.doNested,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.doSeq]]
[Lean.Meta.NormNum.LawfulZero.noConfusionType,[]]
[Lean.Syntax.MonadTraverser.goDown,[modify, Lean.Syntax.Traverser.down]]
[Monoid.npow_succ',[]]
[Lean.ExprStructEq.beq,[Bool, Lean.Expr.equal]]
[Lean.Parser.Command.mutual.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.ppLine.formatter, Lean.Parser.notSymbol.formatter, Lean.Parser.commandParser.formatter, Lean.ppDedent.formatter, Lean.Parser.Command.terminationSuffix.formatter]]
[Lean.getAliases,[Unit.unit, List, Lean.Name, Lean.SMap.find?, Lean.SimplePersistentEnvExtension.getState, Lean.aliasExtension, List.nil]]
[Lean.Elab.Term.Arg.expr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.DiagnosticSeverity.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.DiagnosticSeverity.toCtorIdx]]
[Lean.IR.Expr.isShared.inj,[]]
[Nat.min_eq_left,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, ite_congr, eq_true, Eq.refl, ite_true, eq_self]]
[Lean.Parser.Command.partial.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Mathlib.Tactic.Conv.convTry_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.Conv.convSeq]]
[Std.HashMapImp.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.structInstFieldAbbrev.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.notFollowedBy.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.symbol.parenthesizer]]
[decEq,[]]
[UInt8.mod,[UInt8.mk, HMod.hMod, UInt8.val]]
[Lean.Meta.Simp.postDefault,[Lean.Meta.Simp.tryRewriteCtorEq, Lean.Meta.Simp.tryRewriteUsingDecide, Lean.Meta.Simp.rewritePost]]
[Function.comp_apply,[rfl]]
[Lean.Elab.ExpandDeclIdResult.noConfusionType,[]]
[FloatArray.forInUnsafe.loop,[ite, LT.lt, Bind.bind, Pure.pure, FloatArray.forInUnsafe.loop, HAdd.hAdd, OfNat.ofNat]]
[Std.HashSetImp.expand.proof_1,[Nat.mul_pos, Subtype.property, of_decide_eq_true, Eq.refl, Bool.true]]
[Fin.add_def,[Eq, HAdd.hAdd, Fin.mk, HMod.hMod, Fin.val, Nat.mod_lt, Fin.size_positive, rfl]]
[Lean.Expr.FoldConstsImpl.State.visitedConsts,[]]
[Lean.ExprStructEq.val,[]]
[Lean.Meta.deltaLocalDecl,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getLocalDecl, Lean.Meta.getMVarType, liftM, Lean.Meta.deltaExpand, Lean.Meta.changeLocalDecl, Bool.false]]
[Lean.Meta.Rewrite.Config.mk.inj,[And.intro]]
[String.codepointPosToUtf16PosFrom,[Nat, PProd.fst, String.next, HAdd.hAdd, UInt32.toNat, Char.utf16Size, String.get, OfNat.ofNat]]
[Lean.Expr.FoldConstsImpl.cacheSize,[OfNat.ofNat]]
[Lean.IR.FnBody.set.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.hasDecEq.proof_3,[]]
[Lean.Meta.mkAbsurd,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getLevel, Pure.pure, Lean.mkApp4, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil]]
[Lean.Lsp.DocumentSymbolResult.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DocumentSymbolResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.structureTk.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.ScopedEnvExtension.exportEntriesFn,[Array.reverse, List.toArray, Lean.ScopedEnvExtension.StateStack.newEntries]]
[Lean.Elab.Tactic.Context.elaborator,[]]
[Lean.resolveGlobalConstCore,[Bind.bind, Lean.resolveGlobalName, ite, Eq, List.isEmpty, Bool.true, Lean.throwUnknownConstant, Pure.pure, PUnit.unit]]
[Lean.MetavarContext.hasAssignedMVar,[Bool, List.any, Lean.MetavarContext.hasAssignedLevelMVar, or, and, Lean.Expr.hasMVar, PProd.fst, PProd.snd, Bool.false, Lean.MetavarContext.isExprAssigned, Lean.MetavarContext.isDelayedAssigned]]
[Lean.Lsp.DocumentHighlightKind.write.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Std.Format.nest.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.StructInst.Source.implicit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.DelayedMetavarAssignment.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.DelayedMetavarAssignment.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.Checker.CheckerContext.env,[]]
[Lean.Lsp.ProgressParams.noConfusionType,[]]
[Lean.Xml.Parser.quote,[HOrElse.hOrElse, SeqLeft.seqLeft, SeqRight.seqRight, Lean.Parsec.skipChar, Char.ofNat]]
[Lean.Expr.constructorApp?,[OptionM.run, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.strVal, Lean.Expr.mdata, Lean.Expr.proj, OptionM, Prod, Lean.ConstructorVal, Array, Lean.Expr, ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Bind.bind, Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo, Option, Lean.Environment.find?, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Prod.mk, List.toArray, List.nil, List.cons, Lean.mkNatLit, HSub.hSub, Lean.Expr.getAppFn, HAdd.hAdd, Lean.ConstructorVal.numParams, Lean.ConstructorVal.numFields, Lean.Expr.getAppNumArgs, Lean.Expr.getAppArgs]]
[Lean.Compiler.findBinFoldFn,[List.lookup, Lean.Compiler.binFoldFns]]
[Lean.CollectLevelParams.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.CollectLevelParams.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Command.ProjectionInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.ProjectionInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[List.filterRevM,[List.filterAuxM, List.reverse, List.nil]]
[Nat.add_mod_mod,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, Nat.add_comm, Nat.mod_add_mod, rfl]]
[Lean.ExprStructEq.mk.inj,[]]
[MonadFunctor.monadMap,[]]
[Lean.Elab.DefViewElabHeader.numParams,[]]
[Lean.Elab.ContextInfo.openDecls,[]]
[UInt16.instSemiringUInt16.proof_6,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, HMul.hMul, UInt16.zero_def, UInt16.mul_def, UInt16.mk, OfNat.ofNat, MonoidWithZero.mul_zero, UInt16.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt16]]
[UInt64.div,[UInt64.mk, HDiv.hDiv, UInt64.val]]
[Lean.ExternEntry.inline.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ExternEntry.inline, Eq.symm, eq_of_heq, HEq.refl]]
[List.length_eq_zero,[Iff.intro, List.eq_nil_of_length_eq_zero, Eq.mpr, Eq.refl, Eq, List.length, OfNat.ofNat, rfl]]
[Lean.Compiler.atMostOnce.skip,[id]]
[Lean.Compiler.SpecializeAttributeKind.toCtorIdx,[OfNat.ofNat]]
[Lean.Meta.kabstract.visit,[ite, Eq, Lean.Expr.hasLooseBVars, Bool.true, Unit.unit, or, bne, Lean.Expr.toHeadIndex, Lean.Expr.headNumArgs, Bind.bind, liftM, Lean.Meta.isDefEq, MonadState.get, MonadStateOf.set, HAdd.hAdd, OfNat.ofNat, Lean.Occurrences.contains, Pure.pure, Lean.mkBVar]]
[Lean.PrettyPrinter.Delaborator.instMonadReaderOfSubExprDelabM,[MonadReaderOf.mk, Functor.map, Lean.PrettyPrinter.Delaborator.Context.subExpr, MonadReader.read]]
[Lean.Declaration.axiomDecl.injEq,[Eq.propIntro, Eq.refl, Lean.Declaration.axiomDecl, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.nodeWithAntiquot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.PrettyPrinter.Formatter.node.formatter]]
[Lean.Elab.Command.StructView.scopeVars,[]]
[Lean.Xml.Element.Element.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Xml.Element.Element, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.le_of_add_le_add_right,[Eq.mpr, Eq.refl, LE.le, Nat.add_comm, Nat.le_of_add_le_add_left]]
[Lean.getOptionDecl,[Bind.bind, Lean.getOptionDecls, Pure.pure, Lean.NameMap.find?, Option.none, IO, Lean.OptionDecl, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString]]
[Lean.Level.addOffset,[Lean.Level.addOffsetAux]]
[Lean.Meta.IndPredBelow.mkBelowMatcher.toInaccessible,[Lean.Meta.Match.Pattern.ctor, Lean.Meta.Match.Pattern.val, Lean.Meta.Match.Pattern.arrayLit, Lean.Meta.Match.Pattern.as, Lean.Meta.MetaM, Lean.Meta.Match.Pattern, Pure.pure, Lean.Meta.Match.Pattern.inaccessible, Lean.Meta.Match.Pattern.var, Bind.bind, Lean.Meta.Match.Pattern.toExpr, Bool.false]]
[Lean.Lsp.TextDocumentChangeRegistrationOptions.mk.inj,[And.intro]]
[StateT.instMonadFunctorStateT,[MonadFunctor.mk, Prod]]
[Lean.Elab.Term.Do.extendUpdatedVarsAux,[Lean.Elab.Term.Do.extendUpdatedVarsAux.update]]
[System.FilePath.extSeparator,[Char.ofNat]]
[IO.AsyncList.asyncTail.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.trans, Eq.refl, SizeOf.sizeOf, Except.error, Except.ok, Eq.symm, Task.pure.sizeOf_spec]]
[ReaderT.pure,[Pure.pure]]
[Lean.Parser.Trie.instInhabitedTrie,[Inhabited.mk, Lean.Parser.Trie.Node, Option.none, Std.RBNode.leaf]]
[MonadExcept.throw,[]]
[Lean.Parser.Attr.mono,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.mono.side]]
[exists_eq_right_right',[Iff.intro, And, And.intro, Eq.symm, Exists, Eq, Exists.intro, rfl]]
[Lean.Export.Alloc.next,[]]
[Lean.Elab.Term.Do.ToCodeBlock.Catch.x,[]]
[Lean.instToExprArray,[Lean.ToExpr.mk, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.levelZero, List.nil, Lean.ToExpr.toExpr, Array.toList, Lean.mkApp]]
[Lean.Elab.Tactic.logUnassignedAndAbort,[Bind.bind, liftM, Lean.Elab.Term.logUnassignedUsingErrorInfos, Option.none, ite, Eq, Bool.true, Lean.Elab.throwAbortTactic, Pure.pure, PUnit.unit]]
[Mathlib.Tactic.Lint.instDecidableEqLintVerbosity.proof_2,[absurd, Eq.refl, Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx]]
[String.str,[String.push]]
[List.iota,[Unit.unit, Nat.succ, List, Nat, List.nil, List.cons, PProd.fst]]
[Lean.Lsp.LeanFileProgressProcessingInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.DiscrTree.Key.hash,[Unit.unit, UInt64, mixHash, OfNat.ofNat, Hashable.hash]]
[Fin.underflowingSub,[Prod.mk, Decidable.decide, LT.lt, Fin.val, HSub.hSub]]
[add_add_add_comm,[of_eq_true, Eq.trans, congr, congrArg, Eq, add_left_comm, HAdd.hAdd, add_assoc, eq_self]]
[Lean.mkSortEx,[Lean.mkSort]]
[Lean.Parser.Command.namedName.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.ident.parenthesizer]]
[Lean.mkLetFunAnnotation,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Elab.Tactic.adaptExpander,[Bind.bind, Lean.Elab.Tactic.withMacroExpansion, Lean.Elab.Tactic.evalTactic]]
[Lean.Meta.SimpLemma.noConfusionType,[]]
[Lean.Level.instHashableLevel,[Hashable.mk, Lean.Level.hash]]
[Lean.IR.mkJDecl,[Lean.IR.FnBody.jdecl]]
[Lean.runEval,[IO.FS.withIsolatedStreams, liftM, EIO.toBaseIO, Lean.Eval.eval, Bool.false]]
[Lean.Parser.Term.letrec.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.Term.letRecDecls.parenthesizer, Lean.Parser.Term.optSemicolon.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[IO.FS.Stream.writeRequest,[IO.FS.Stream.writeMessage, Lean.JsonRpc.Message.request, Lean.JsonRpc.Request.id, Lean.JsonRpc.Request.method, Except.toOption, Lean.Json.toStructured?, Lean.JsonRpc.Request.param]]
[Lean.Meta.Split.findSplit?.isCandidate,[Id.run, ite, Eq, or, Lean.Expr.isIte, Lean.Expr.isDIte, Bool.true, not, Lean.Expr.hasLooseBVars, Lean.Expr.getArg!, OfNat.ofNat, Option.none, Id, Bool, Lean.Meta.isMatcherAppCore?, Bind.bind, ForIn.forIn, MProd.mk, PUnit.unit, Array.getOp, Pure.pure, ForInStep.done, Option.some, Bool.false, ForInStep.yield, Unit.unit, MProd.fst]]
[Lean.InductiveVal.isRec,[]]
[Lean.Meta.throwUnknownFVar,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkFVar]]
[Lean.Level.ofNat,[Unit.unit, Lean.Level, Lean.levelZero, Lean.mkLevelSucc, PProd.fst]]
[UInt64.decEq,[Decidable, Eq, dite, Decidable.isTrue, UInt64.decEq.proof_1, Decidable.isFalse, UInt64.decEq.proof_2]]
[Lean.Elab.Tactic.elabSimpConfig,[ite, Eq, Bool.true, Bind.bind, Lean.Elab.Tactic.elabSimpConfigCtxCore, Pure.pure, Lean.Meta.Simp.ConfigCtx.toConfig, Lean.Elab.Tactic.elabSimpConfigCore]]
[Lean.Parser.Tactic.constructor,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Meta.IndPredBelow.mkInductiveType,[Bind.bind, List.mapM, Lean.Meta.IndPredBelow.mkConstructor, Fin.val, Lean.InductiveVal.ctors, Pure.pure, Lean.InductiveType.mk, Array.getOp, Lean.Meta.IndPredBelow.Context.belowNames, Lean.Meta.IndPredBelow.Context.headers]]
[«term_<->_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[let_val_congr,[rfl]]
[Lean.PrettyPrinter.Parenthesizer.node.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, bne, Lean.Syntax.getKind, Bool.true, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.IR.IRType.isObj,[Lean.IR.IRType.float, Lean.IR.IRType.uint8, Lean.IR.IRType.uint16, Lean.IR.IRType.uint32, Lean.IR.IRType.uint64, Lean.IR.IRType.usize, Lean.IR.IRType.irrelevant, Unit.unit, Lean.IR.IRType.struct, Lean.IR.IRType.union, Bool, Bool.true, Bool.false]]
[Lean.Widget.MsgEmbed.expr.injEq,[Eq.propIntro, Eq.refl, Lean.Widget.MsgEmbed.expr, Eq.symm, eq_of_heq, HEq.refl]]
[gpow_rec,[npow_rec, Inv.inv, Nat.succ]]
[Lean.IR.ExplicitRC.VarInfo.mk.inj,[And.intro]]
[MonadExcept.tryCatch,[]]
[Lean.Meta.isMonad?,[MonadExcept.tryCatch, Bind.bind, Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Lean.Meta.trySynthInstance, Option.none, Lean.LOption.none, Lean.LOption.undef, Lean.Meta.MetaM, Option, Lean.Expr, Pure.pure, Option.some]]
[Lean.Meta.getPostponed,[Bind.bind, MonadState.get, Pure.pure, Lean.Meta.State.postponed]]
[Lean.PrefixTreeNode.below,[PProd, PUnit]]
[Lean.Parser.Term.suffices.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.sufficesDecl.parenthesizer, Lean.Parser.Term.optSemicolon.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Lean.Meta.Cases.Context.noConfusionType,[]]
[UInt64.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd]]
[Lean.Server.MonadRpcSession.rpcStoreRef,[]]
[Lean.Meta.SynthInstance.Waiter.consumerNode.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Command.StructFieldKind.toCtorIdx,[OfNat.ofNat]]
[Std.HashSetImp.contains.proof_1,[Subtype.property]]
[instInhabitedArrow,[Inhabited.mk, arbitrary]]
[Lean.Elab.Term.LValResolution.const.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.simpleBinderWithoutType.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.PrettyPrinter.Formatter.pushNone.formatter, Bool.true]]
[Lean.Parser.Tactic.matchRhs,[HOrElse.hOrElse, Lean.Parser.Term.hole, Lean.Parser.Term.syntheticHole, Lean.Parser.Tactic.tacticSeq]]
[Lean.instBEqLiteral,[BEq.mk, Lean.Literal.natVal, Lean.Literal.strVal, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Parser.Error.noConfusionType,[]]
[Lean.instBEqFVarId,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[instToStringId_1,[inferInstanceAs, ToString]]
[Lean.instFromJsonProd,[Lean.FromJson.mk, Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.str, dite, Eq, Array.size, Array.getLit, Eq.symm, of_decide_eq_true, id, Eq.refl, Bool.true, Array.toArrayLit_eq, Lean.Json.arr, Lean.Json.obj, Except, String, Prod, Bind.bind, Lean.FromJson.fromJson?, Pure.pure, Prod.mk, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Lean.Parser.Tactic.sliceRHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq]]
[Lean.PrettyPrinter.Parenthesizer.tokenWithAntiquot.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, Lean.Syntax.isTokenAntiquot, Bool.true, Lean.PrettyPrinter.Parenthesizer.visitArgs]]
[Lean.Expr.ReplaceLevelImpl.replaceUnsafeM.visit,[Bind.bind, MonadState.get, ite, Eq, BEq.beq, ptrAddrUnsafe, Array.uget, Lean.Expr.ReplaceLevelImpl.State.keys, lcProof, Bool.true, Pure.pure, Lean.Expr.ReplaceLevelImpl.State.results, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.lit, Lean.Expr.ReplaceLevelImpl.ReplaceM, Lean.Expr, Lean.Expr.ReplaceLevelImpl.replaceUnsafeM.visit, Lean.Expr.ReplaceLevelImpl.cache, Lean.Expr.updateForallE!, Lean.Expr.updateLambdaE!, Lean.Expr.updateMData!, Lean.Expr.updateLet!, Lean.Expr.updateApp!, Lean.Expr.updateProj!, Lean.Expr.updateSort!, Lean.Level.replace, Lean.Expr.updateConst!, List.map]]
[Lean.Elab.Tactic.renameInaccessibles,[ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Bind.bind, liftM, Lean.Meta.getMVarDecl, ForIn.forIn, MProd.mk, Unit.unit, Lean.Elab.Tactic.TacticM, ForInStep, MProd, Lean.NameSet, Lean.LocalContext, Array, Lean.Syntax, Lean.LocalContext.getAt?, ForInStep.yield, or, Lean.Name.hasMacroScopes, Lean.LocalDecl.userName, Lean.NameSet.contains, Lean.Syntax.isIdent, PUnit.unit, Lean.MVarId, Lean.Elab.logError, Lean.ToMessageData.toMessageData]]
[Lean.Parser.Tactic.contrapose!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol]]
[Lean.PrettyPrinter.Parenthesizer.eoi.parenthesizer,[Pure.pure, Unit.unit]]
[Char.utf8Size.proof_5,[of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Meta.Simp.M,[ReaderT, Lean.Meta.Simp.Methods, Lean.Meta.Simp.SimpM]]
[Nat.mul_div_assoc,[Eq, HDiv.hDiv, HMul.hMul, Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, OfNat.ofNat, Nat.div_zero, Nat.mul_zero, rfl]]
[Lean.ppHardSpace.formatter,[Lean.PrettyPrinter.Formatter.push, Std.Format.text]]
[Lean.Compiler.boolFoldFns,[List.cons, Prod.mk, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Compiler.foldStrictOr, Lean.Compiler.foldStrictAnd, List.nil]]
[Lean.LocalContext.getUnusedName,[ite, Eq, Lean.LocalContext.usesUserName, Bool.true, Prod.fst, OfNat.ofNat]]
[List.forall_mem_nil,[Eq.refl]]
[Lean.Elab.Term.SyntheticMVarKind.postponed.inj,[]]
[List.spanAux,[Prod, List, Prod.mk, List.reverse, List.nil, Unit.unit, PProd.fst, List.cons]]
[Lean.Syntax.isInterpolatedStrLit?,[Unit.unit, Option, String, Lean.Syntax.isLit?, Lean.interpolatedStrLitKind, Option.none, OfNat.ofNat]]
[Array.binInsert,[Id.run, Array.binInsertM]]
[Lean.Compiler.SpecEntry.info.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.type.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.checkWsBefore.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.PrettyPrinter.Formatter.checkColGt.formatter, Lean.Parser.levelParser.formatter, Lean.Parser.maxPrec]]
[List.exists_erase_eq,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Exists, And, Not, Mem.mem, Eq, HAppend.hAppend, List.cons, List.erase, List.exists_of_erasep, rfl, Eq.mpr, List.erase_eq_erasep, Exists.intro, And.intro]]
[instToStringUInt8,[ToString.mk, ToString.toString, UInt8.toNat]]
[Std.ShareCommon.State.shareCommon,[Prod.mk]]
[Lean.Parser.Command.macroTailCommand,[HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.identEq, Lean.Name.mkSimple, Lean.Parser.darrow, Lean.Parser.Command.macroRhs, Lean.Parser.many1Unbox, Lean.Parser.commandParser, OfNat.ofNat]]
[Int.subNatNat_of_le,[Int.subNatNat_of_sub_eq_zero, Nat.sub_eq_zero_of_le]]
[Lean.Server.publishProgressDone,[Lean.Server.publishProgress, List.toArray, List.nil]]
[Lean.MetavarContext.addExprMVarDecl,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, HAdd.hAdd, Lean.MetavarContext.mvarCounter, OfNat.ofNat, Lean.MetavarContext.lDepth, Std.PersistentHashMap.insert, Lean.MetavarContext.decls, Lean.MetavarDecl.mk, ite, Eq, Lean.Name.isAnonymous, Bool.true, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment]]
[Mathlib.Tactic.Lint.simpNF,[Mathlib.Tactic.Lint.Linter.mk, Bind.bind, Mathlib.Tactic.Lint.isSimpLemma, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Option.none, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[instAddCommSemigroup,[AddCommSemigroup.mk, AddCommMonoid.add_comm]]
[Lean.Parser.Command.classTk.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.Elab.Term.LetRecView.mk.inj,[And.intro]]
[Lean.Compiler.atMostOnce.AtMostOnceData.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Compiler.atMostOnce.AtMostOnceData.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.forall.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.unicodeSymbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.simpleBinder.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Bool.false, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Nat.min_le_left,[Decidable.em, LE.le, Eq.mpr, congrFun, congrArg, Eq.trans, ite_congr, eq_true, Eq.refl, ite_true, Nat.le_refl, Eq.symm, eq_false, ite_false, Nat.le_of_not_le]]
[Array.modifyOp,[Array.modify]]
[IO.FS.Stream.writeLspMessage,[Bind.bind, IO.FS.Stream.putStr, HAppend.hAppend, IO.FS.Stream.flush]]
[Lean.Meta.getConst?,[Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.Meta.MetaM, Option, Lean.ConstantInfo, Lean.Environment.find?, Lean.Meta.getTheoremInfo, MonadReader.read, Lean.Meta.TransparencyMode.reducible, Lean.Meta.TransparencyMode.instances, Lean.Meta.Config.transparency, Lean.Meta.Context.config, Pure.pure, Option.some, Lean.isReducible, Lean.ConstantInfo.name, ite, Eq, Bool.true, and, BEq.beq, Lean.Meta.isGlobalInstance, Option.none, Lean.throwUnknownConstant]]
[Lean.Lsp.Ipc.stdout,[Bind.bind, MonadReader.read, Pure.pure, IO.FS.Stream.ofHandle, IO.Process.Child.stdout]]
[Lean.Rat.instLERat,[LE.mk, Not, LT.lt]]
[Nat.coprime_mul_iff_left,[Iff.intro, And.intro, Nat.coprime.coprime_mul_right, Nat.coprime.coprime_mul_left, Nat.coprime, HMul.hMul, Eq.mpr, Eq.refl, propext, Nat.coprime_iff_gcd_eq_one, Eq, Nat.gcd, OfNat.ofNat, Nat.coprime.gcd_mul_left_cancel]]
[SeqRight.noConfusionType,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.annotateBool,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getPos, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.annotateBoolAt]]
[Lean.MetavarKind.isSyntheticOpaque,[Lean.MetavarKind.natural, Lean.MetavarKind.synthetic, Unit.unit, Bool, Bool.true, Bool.false]]
[Nat.le_of_not_le,[Or.resolve_left, Nat.le_or_le]]
[Lean.Level.succ.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Level.succ, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Formatter.trailingNode.formatter,[Bind.bind, Lean.PrettyPrinter.Formatter.checkKind, Lean.PrettyPrinter.Formatter.visitArgs, Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Compiler.SpecEntry.cache.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Compiler.SpecEntry.cache, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.instBEqRange,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Parser.manyNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.noFirstTokenInfo, Lean.Parser.Parser.info, Lean.Parser.manyFn, Lean.Parser.Parser.fn]]
[iff_iff_and_or_not_and_not,[Decidable.iff_iff_and_or_not_and_not]]
[Lean.Elab.Term.SavedState.noConfusionType,[]]
[Lean.binderIdent,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[Quot.rec,[Quot.liftIndepPr1, PSigma.snd, Quot.lift, Quot.indep, Quot.indepCoherent]]
[Lean.Elab.addAsAxiom,[Lean.withRef, Lean.Elab.PreDefinition.ref, Lean.addDecl, Lean.Declaration.axiomDecl, Lean.AxiomVal.mk, Lean.ConstantVal.mk, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.levelParams, Lean.Elab.PreDefinition.type, Lean.Elab.Modifiers.isUnsafe, Lean.Elab.PreDefinition.modifiers]]
[Option.mapM,[Option.none, Option, Bind.bind, Pure.pure, Option.some]]
[Lean.Parser.Command.alias,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.unary]]
[Substring.toIterator,[String.Iterator, String.Iterator.mk]]
[Lean.Lsp.InitializeResult.capabilities,[]]
[List.instLTList,[LT.mk, List.lt]]
[Lean.Elab.Command.elabGenInjectiveTheorems,[Bind.bind, Lean.resolveGlobalConstNoOverload, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Command.liftTermElabM, Option.none, liftM, Lean.Meta.mkInjectiveTheorems]]
[Lean.Level.isMax,[Lean.Level.zero, Lean.Level.succ, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Bool, Bool.true, Bool.false]]
[Lean.IR.CollectMaps.collectJP,[Prod, Lean.IR.VarTypeMap, Lean.IR.JPParamsMap, Prod.mk, Std.HashMap.insert]]
[List.intercalate,[List.join, List.intersperse]]
[Function.is_partial_inv_left,[Iff.mpr, rfl]]
[List.hasDecEq,[Unit.unit, Decidable, Eq, Decidable.isTrue, List.hasDecEq.proof_1, Decidable.isFalse, List.hasDecEq.proof_2, List.hasDecEq.proof_3, List.cons, decEq, PProd.fst, List.hasDecEq.proof_4, List.hasDecEq.proof_5, List.hasDecEq.proof_6]]
[Lean.Parser.Term.binrel_no_prop.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.ppSpace.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec]]
[Prod.fst_swap,[rfl]]
[Lean.MetavarContext.mkForall,[Bind.bind, Lean.MetavarContext.mkBinding, Bool.false, Lean.MetavarContext.MkBindingM, Lean.Expr, Pure.pure]]
[Lean.Lsp.CompletionOptions.triggerCharacters?,[]]
[dec_em',[Or.swap, dec_em]]
[Lean.Elab.CommandInfo.noConfusionType,[]]
[Lean.instFromJsonList,[Lean.FromJson.mk, Except.map, Array.toList, Lean.FromJson.fromJson?]]
[Lean.Parser.Term.letPatDecl,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.termParser, OfNat.ofNat, Lean.Parser.pushNone, Lean.Parser.Term.optType, Lean.Parser.symbol, Bool.false]]
[String.toAsciiByteArray.loop.proof_2,[And.intro, Nat.lt_add_of_pos_right, String.csize_pos, String.get, Nat.lt_of_not_le, mt, decide_eq_true]]
[Lean.Parser.Command.def.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.Command.optDeclSig.parenthesizer, Lean.Parser.Command.declVal.parenthesizer, Lean.Parser.Command.optDefDeriving.parenthesizer, Lean.Parser.Command.terminationSuffix.parenthesizer]]
[Classical.axiomOfChoice,[Exists.intro, Classical.choose, Classical.choose_spec]]
[Lean.Elab.Term.elabArrayRef,[Bind.bind, List.nil, Bool.false, List.toArray, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.Elab.Term.TermElabM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Pure.pure, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError]]
[Lean.Syntax.mkCApp,[Lean.Syntax.mkApp, Lean.mkCIdent]]
[Lean.Lsp.SemanticTokensOptions.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.SemanticTokensOptions.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Match.Pattern.as.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Except.toBool,[Bool, Bool.true, Bool.false]]
[Nat.dvd_add_iff_left,[Eq.mpr, Eq.refl, Iff, Dvd.dvd, HAdd.hAdd, Nat.add_comm, Nat.dvd_add_iff_right]]
[UInt64.instSemigroupUInt64.proof_1,[congrArg, UInt64.mk, Semigroup.mul_assoc, UInt64.val]]
[Lean.Parsec.peek?,[ite, Eq, String.Iterator.hasNext, Bool.true, Lean.Parsec.ParseResult.success, Option.some, String.Iterator.curr, Option.none]]
[Lean.Meta.SynthInstance.GeneratorNode.currInstanceIdx,[]]
[Lean.ClosedTermCache.mk.inj,[And.intro]]
[Lean.DataValue.ofString.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.TransparencyMode.instances.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Tactic.tacticSuffices_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Lean.IR.Expr.unbox.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.RpcRef.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.RpcRef.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.mkSimpExt,[Lean.registerSimpleScopedEnvExtension, Lean.SimpleScopedEnvExtension.Descr.mk, Lean.Meta.SimpLemmas, Lean.Meta.addSimpLemmaEntry, Lean.Meta.SimpLemmas.addDeclToUnfold, Lean.Meta.SimpLemmas.mk]]
[Lean.Elab.InfoTree.foldInfo,[Option.none, Lean.Elab.InfoTree.foldInfo.go]]
[Set.insert,[setOf, Or, Eq, Mem.mem]]
[Lean.ConstantInfo.ctorInfo.inj,[]]
[Std.RBTree.seteq,[and, Std.RBTree.subset]]
[Lean.Elab.Term.expandMatchAltsWhereDecls.loop,[Unit.unit, Lean.MacroM, Lean.Syntax, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, ite, Eq, Lean.Syntax.isNone, Bool.true, Lean.Elab.Term.expandWhereDeclsOpt, Lean.MonadQuotation.withFreshMacroScope, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, PProd.fst, Array.push]]
[Lean.Elab.Structural.EqnInfo.mk.inj,[And.intro]]
[instMonadStateOf,[MonadStateOf.mk, liftM, MonadStateOf.get, MonadStateOf.set, MonadLiftT.monadLift, MonadState.modifyGet]]
[Lean.Parser.Term.doDbgTrace,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, HOrElse.hOrElse, Lean.Parser.interpolatedStr, Lean.Parser.termParser, OfNat.ofNat]]
[Lean.Elab.Term.MutualClosure.ClosureState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.MutualClosure.ClosureState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[List.mem_insert_self,[Iff.mpr, List.mem_insert_iff, Or.inl, rfl]]
[Array.contains,[Array.any, BEq.beq, OfNat.ofNat, Array.size]]
[Lean.Expr.getAppArgs,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Array, Lean.Expr, PProd.fst, Array.set!, HSub.hSub, OfNat.ofNat, Array.mkArray]]
[Lean.Elab.Command.ElabStructResult.noConfusionType,[]]
[Lean.mkLevelIMax,[Lean.Level.imax, Lean.Level.mkData, mixHash, OfNat.ofNat, Hashable.hash, HAdd.hAdd, Nat.max, Lean.Level.depth, or, Lean.Level.hasMVar, Lean.Level.hasParam]]
[Lean.Parser.Tactic.Conv.simp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpStar, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma]]
[Lean.IR.AltCore.default.injEq,[Eq.propIntro, Eq.refl, Lean.IR.AltCore.default, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.MessageLog.instAppendMessageLog,[Append.mk, Lean.MessageLog.append]]
[Div.div,[]]
[Lean.PrettyPrinter.Formatter.optionalNoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.visitArgs]]
[Lean.Elab.Term.Do.Code.seq.inj,[And.intro]]
[Lean.Level.succ.inj,[And.intro]]
[Lean.Parser.checkPrec,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.checkPrecFn]]
[UInt16.mod_def,[rfl]]
[Std.Format.instCoeStringFormat,[Coe.mk, Std.Format.text]]
[Lean.Meta.mkEq,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getLevel, Pure.pure, Lean.mkApp3, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil]]
[Lean.Elab.Term.Context.noConfusionType,[]]
[Lean.Meta.SynthInstance.ConsumerNode.mctx,[]]
[Lean.Parser.Term.letMVar.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[IO.sleep,[dbgSleep, EStateM.Result.ok, Unit.unit]]
[«term_<&>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Function.Equiv,[Eq]]
[Lean.Meta.SynthInstance.Context.maxHeartbeats,[]]
[instCoeTail,[CoeTail.mk, coeFun]]
[Lean.Elab.Term.Quotation.HeadInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[USize.ofNatCore,[USize.mk, Fin.mk]]
[Lean.Compiler.CSimp.Entry.toDeclName,[]]
[Function.const_comp,[rfl]]
[Function.eq_update_iff,[Iff.trans, Function.funext_iff, Function.forall_update_iff, Eq]]
[Lean.Elab.Command.withFreshMacroScope,[Bind.bind, MonadState.modifyGet, Prod.mk, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, HAdd.hAdd, OfNat.ofNat, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, MonadWithReader.withReader, Lean.Elab.Command.Context.mk, Lean.Elab.Command.Context.fileName, Lean.Elab.Command.Context.fileMap, Lean.Elab.Command.Context.currRecDepth, Lean.Elab.Command.Context.cmdPos, Lean.Elab.Command.Context.macroStack, Lean.Elab.Command.Context.ref]]
[Lean.Elab.Term.PatternVarDecl.noConfusionType,[]]
[Lean.Elab.Tactic.evalSimpAll,[Bind.bind, Lean.Elab.Tactic.mkSimpContext, Bool.true, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Meta.simpAll, Unit.unit, Lean.Elab.Tactic.replaceMainGoal, List.nil, List.cons]]
[Lean.getPPAnalyzeTrustSubst,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.trustSubst, Lean.Option.defValue]]
[Lean.Meta.AbstractMVars.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.instInhabitedEnumAttributes,[Inhabited.mk, Lean.EnumAttributes.mk, arbitrary]]
[Lean.Lsp.instFileSourceRpcCallParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.RpcCallParams.toTextDocumentPositionParams]]
[Lean.Lsp.TextDocumentRegistrationOptions.documentSelector?,[]]
[Lean.addDocString,[Lean.MonadEnv.modifyEnv, Lean.MapDeclarationExtension.insert]]
[Lean.ImportState.mk.inj,[And.intro]]
[Subtype.val_injective,[Subtype.coe_injective]]
[Std.Format.MonadPrettyFormat.currColumn,[]]
[Lean.Expr.bvarIdx!,[Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Nat, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Lsp.WorkDoneProgressReport.percentage?,[]]
[List.erase_of_not_mem,[rfl, Eq.mpr, Eq.refl, Eq, List.erase, List.cons, List.erase_cons, ite, if_neg, Ne.symm, And.left, Eq.mp, Not, Or, Mem.mem, propext, not_or, List.mem_cons, And.right]]
[Lean.IR.EmitC.emitMarkPersistent,[ite, Eq, Lean.IR.IRType.isObj, Lean.IR.Decl.resultType, Bool.true, Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitCName, Lean.IR.EmitC.emitLn, Pure.pure, PUnit.unit]]
[instMonadReader,[MonadReader.mk, readThe]]
[Lean.IR.mkLiveVarSet,[Std.RBTree.insert, Std.RBTree.empty]]
[Lean.Elab.Term.observing,[Bind.bind, Lean.MonadBacktrack.saveState, MonadExcept.tryCatch, Lean.Elab.Term.SavedState.restore, Bool.true, Pure.pure, EStateM.Result.ok, Lean.Exception.error, Lean.Exception.internal, Lean.Elab.Term.TermElabM, Lean.Elab.Term.TermElabResult, EStateM.Result.error, ite, Eq, BEq.beq, Lean.Elab.postponeExceptionId, PUnit.unit]]
[Lean.Parser.Term.leading_parser,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.optExprPrecedence, Lean.Parser.termParser, OfNat.ofNat]]
[IO.Error.inappropriateType.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.inappropriateType, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Server.Watchdog.ServerEvent.clientMsg.injEq,[Eq.propIntro, Eq.refl, Lean.Server.Watchdog.ServerEvent.clientMsg, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.FileMap.toPosition,[Lean.Position, ite, Eq, and, Decidable.decide, GE.ge, Array.size, OfNat.ofNat, LE.le, Array.back, Bool.true, HSub.hSub, Lean.FileMap.toPosition.loop, Lean.FileMap.toPosition.toColumn, Array.isEmpty, Lean.Position.mk]]
[Lean.RecursorVal.getInduct,[Lean.Name.getPrefix, Lean.ConstantVal.name, Lean.RecursorVal.toConstantVal]]
[Lean.Elab.Term.Do.Code.continue.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[observing,[MonadExcept.tryCatch, Bind.bind, Pure.pure, Except.ok, Except.error]]
[Lean.Meta.MVarRenaming.find?,[Std.RBMap.find?, Lean.Meta.MVarRenaming.map]]
[IO.AccessRight.flags,[UInt32.lor]]
[Lean.EnvExtension.getState,[Lean.EnvExtensionInterface.getState, Lean.EnvExtensionInterfaceImp]]
[Lean.Elab.Term.throwTypeMismatchError,[Unit.unit, Lean.Elab.Term.TermElabM, Bind.bind, Lean.Elab.Term.mkTypeMismatchError, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, liftM, Lean.Meta.throwAppTypeMismatch, Lean.MessageData.ofFormat]]
[Std.instInhabitedRBTree,[Inhabited.mk, Std.RBMap.empty]]
[Lean.IR.UnreachableBranches.Value.widening,[Lean.IR.UnreachableBranches.Value.truncate, Lean.IR.UnreachableBranches.Value.merge, EmptyCollection.emptyCollection]]
[Coe.coe,[]]
[addParenHeuristic,[ite, Eq, or, String.isPrefixOf, Bool.true, not, String.any, Char.isWhitespace, HAppend.hAppend]]
[Lean.instInhabitedKeyedDeclsAttribute,[Inhabited.mk, Lean.KeyedDeclsAttribute.mk, arbitrary]]
[Lean.IR.modifyEnv,[modify, Lean.IR.CompilerState.mk, Lean.IR.CompilerState.env, Lean.IR.CompilerState.log]]
[Lean.Elab.Command.instAddMessageContextCommandElabM,[Lean.AddMessageContext.mk, Lean.addMessageContextPartial]]
[Lean.IR.ExplicitBoxing.BoxingContext.localCtx,[]]
[List.instForMList,[ForM.mk, List.forM]]
[Lean.MetavarContext.decls,[]]
[ExceptCpsT.instMonadLiftExceptCpsT,[MonadLift.mk, ExceptCpsT.lift]]
[plift.up.inj,[]]
[instXorUInt32,[Xor.mk, UInt32.xor]]
[Lean.Server.Snapshots.Snapshot.interactiveDiags,[]]
[Lean.IR.FnBody.set.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.set, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.EnvironmentHeader.noConfusionType,[]]
[Lean.Server.instInhabitedWithRpcRef,[Inhabited.mk, Lean.Server.WithRpcRef.mk, arbitrary]]
[Lean.Json.instCoeArrayJsonStructured,[Coe.mk, Lean.Json.Structured.arr]]
[Lean.Meta.SimpAll.State.modified,[]]
[Lean.Name.instReprSyntax,[Repr.mk]]
[Lean.Elab.Term.CollectPatternVars.instInhabitedContext,[Inhabited.mk, Lean.Elab.Term.CollectPatternVars.Context.mk, arbitrary]]
[Lean.Parser.Tactic.Conv.convSeqBracketed,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat, OfNat.ofNat]]
[Nat.mul_mod_right,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HMul.hMul, OfNat.ofNat, Eq.symm, Nat.zero_add, HAdd.hAdd, Nat.add_mul_mod_self_left, Nat.zero_mod, rfl]]
[Lean.Elab.Term.toParserDescr.processParserCategory,[Bind.bind, MonadReader.read, ite, Eq, and, Lean.Elab.Term.ToParserDescrContext.first, BEq.beq, Lean.Elab.Term.ToParserDescrContext.catName, Bool.true, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.KeyedDeclsAttribute.ExtensionState.erase,[ite, Eq, Std.PersistentHashSet.contains, Lean.KeyedDeclsAttribute.ExtensionState.declNames, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Std.PersistentHashMap.forM,[Std.PersistentHashMap.foldlM, PUnit.unit]]
[UInt8.instSemiringUInt8.proof_2,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt8.zero_def, UInt8.add_def, UInt8.mk, OfNat.ofNat, zero_add, UInt8.val, UInt8.mk_val_eq, eq_self, propext, forall_const, UInt8]]
[Lean.KernelException.declHasMVars.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.axiom,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.declId, Lean.Parser.Command.declSig]]
[Lean.Lsp.TextDocumentContentChangeEvent.rangeChange.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.TextDocumentContentChangeEvent.rangeChange, Eq.symm, eq_of_heq, HEq.refl]]
[Std.mkRBMap,[Subtype.mk, Std.RBNode.leaf, Std.mkRBMap.proof_1]]
[Lean.DeclarationRanges.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.DeclarationRanges.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Option.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Option.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Xml.Parser.Misc,[HOrElse.hOrElse, SeqRight.seqRight, Lean.Xml.Parser.Comment, Pure.pure, Unit.unit, Lean.Xml.Parser.PI, Lean.Xml.Parser.S]]
[decidableEq_of_decidableLe.proof_1,[le_refl]]
[Lean.Parser.Attr.simple.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.priorityParser.parenthesizer]]
[Lean.Expr.isNatLit,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.strVal, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[Lean.PrettyPrinter.Delaborator.SubExpr.getPos,[Bind.bind, readThe, Lean.PrettyPrinter.Delaborator.SubExpr, Pure.pure, Lean.PrettyPrinter.Delaborator.SubExpr.pos]]
[Lean.Meta.SynthInstance.GeneratorNode.key,[]]
[Lean.Literal.lt,[Lean.Literal.strVal, Lean.Literal.natVal, Bool, Bool.true, Decidable.decide, LT.lt, Bool.false]]
[Int.instCommRingInt.proof_3,[Eq.mpr, Eq.refl, Eq, HPow.hPow, Nat.succ, HMul.hMul, Int.mul_comm, rfl]]
[Lean.IR.CollectUsedDecls.collectDecl,[Lean.IR.CollectUsedDecls.M, Lean.NameSet, SeqRight.seqRight, Lean.IR.CollectUsedDecls.collectInitDecl, Lean.IR.CollectUsedDecls.collectFnBody, MonadState.get]]
[Lean.Elab.Term.Do.ToTerm.returnToTerm,[Bind.bind, MonadReader.read, Lean.Elab.Term.Do.ToTerm.mkUVarTuple, Unit.unit, Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax, Lean.Elab.Term.Do.ToTerm.Context.kind, ite, Eq, Array.isEmpty, Lean.Elab.Term.Do.ToTerm.Context.uvars, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom, panicWithPosWithDecl, OfNat.ofNat]]
[instDecidableFalse,[Decidable.isFalse, not_false]]
[Lean.Elab.Term.Do.ToCodeBlock.Context.ref,[]]
[Lean.LBool.neg,[Unit.unit, Lean.LBool, Lean.LBool.false, Lean.LBool.true, Lean.LBool.undef]]
[Nat.sub_eq_sub_min,[dite, GE.ge, Eq.mpr, Eq.refl, Eq, HSub.hSub, min, min_eq_right, rfl, Nat.sub_eq_zero_of_le, le_of_not_ge, OfNat.ofNat, min_eq_left, Nat.sub_self]]
[Lean.Expr.isAppOfArity,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, dite, Eq, Eq.symm, Lean.Expr.const, Lean.Expr.app, Nat.zero, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, BEq.beq, PProd.fst, Bool.false]]
[Lean.Macro.Methods.resolveNamespace?,[]]
[Lean.Elab.Term.instMonadQuotationTermElabM,[Lean.MonadQuotation.mk, Lean.Elab.Term.getCurrMacroScope, Lean.Elab.Term.getMainModule, Lean.Elab.Term.withFreshMacroScope]]
[Lean.Elab.Attribute.stx,[]]
[Lean.JsonNumber.instCoeIntJsonNumber,[Coe.mk, Lean.JsonNumber.fromInt]]
[Lean.Lsp.instBEqDiagnosticSeverity,[BEq.mk, BEq.beq, Lean.Lsp.DiagnosticSeverity.toCtorIdx]]
[Int.toNat_sub,[rfl]]
[Lean.IR.EmitC.emitFnDecls,[Bind.bind, Lean.IR.EmitC.getEnv, List.forM, Lean.IR.EmitC.getDecl, Unit.unit, Lean.IR.EmitC.M, PUnit, Lean.getExternNameFor, Lean.Name.mkStr, Lean.Name.anonymous, Lean.IR.Decl.name, Lean.IR.EmitC.emitExternDeclAux, Lean.IR.EmitC.emitFnDecl, not, Lean.NameSet.contains]]
[Lean.Meta.InfoCacheKey.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.InfoCacheKey.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Context.autoBoundImplicits,[]]
[Lean.SCC.Data.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Prod.snd_surjective,[Nonempty.elim, Exists.intro, Prod.mk, rfl]]
[Lean.Elab.Command.ElabStructResult.mk.inj,[And.intro]]
[Lean.Macro.getMethodsImp,[Bind.bind, MonadReader.read, Pure.pure, unsafeCast, Lean.Macro.Context.methods]]
[Lean.Elab.Command.CommandElab,[Lean.Elab.Command.CommandElabM, Unit]]
[instHasEquiv,[HasEquiv.mk, Setoid.r]]
[Lean.Parser.Level.max.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.levelParser.parenthesizer, Lean.Parser.maxPrec]]
[String.instAppendString,[Append.mk, String.append]]
[Lean.Compiler.mkUInt32Lit,[Lean.Compiler.mkUIntLit, Lean.Compiler.NumScalarTypeInfo.mk, OfNat.ofNat]]
[Lean.Level.PP.Result.succ,[Lean.Level.PP.Result.leaf, Lean.Level.PP.Result.maxNode, Lean.Level.PP.Result.imaxNode, Lean.Level.PP.Result, Lean.Level.PP.Result.offset, HAdd.hAdd, OfNat.ofNat, Lean.Level.PP.Result.num]]
[Lean.mkAppRange,[]]
[instSemiringFin.proof_12,[rfl]]
[Lean.ToExpr.noConfusionType,[]]
[Lean.Compiler.instInhabitedInlineAttributeKind,[Inhabited.mk, Lean.Compiler.InlineAttributeKind.inline]]
[Lean.Meta.Match.Alt.mk.inj,[And.intro]]
[Lean.Meta.Context.defEqCtx?,[]]
[Prod.snd_eq_iff,[Iff, Eq, Prod.snd, Prod.mk, Prod.fst, of_eq_true, Eq.trans, congrArg, Prod.mk.injEq, congrFun, And, eq_self, true_and, iff_self]]
[true_ne_false,[ne_false_of_self, trivial]]
[PartialOrder.le_antisymm,[]]
[Lean.Xml.Content.Element.inj,[]]
[Lean.StructureFieldInfo.inferMod,[]]
[Lean.EnvExtensionEntry,[PointedType.type, Lean.EnvExtensionEntrySpec]]
[Lean.EnvExtensionInterface.registerExt,[]]
[ByteArray.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Core.CoreM.run,[StateRefT'.run]]
[Lean.Elab.Term.instToStringMVarErrorKind,[ToString.mk, Unit.unit, String]]
[Option.eq_of_eq_some,[Eq, rfl, Iff.mpr, Iff.mp, congrArg, Option.some]]
[Lean.Parser.Term.doHave.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.haveDecl.formatter]]
[Option.instOrElseOption,[OrElse.mk, Option.orElse]]
[Lean.Parser.Command.visibility,[HOrElse.hOrElse, Lean.Parser.Command.private, Lean.Parser.Command.protected]]
[Lean.Level.instBEqLevel,[BEq.mk, Lean.Level.beq]]
[Lean.Elab.parseImports,[Bind.bind, Lean.Parser.parseHeader, IO, Prod, List, Lean.Import, Lean.Position, Lean.MessageLog, Pure.pure, Prod.mk, Lean.Elab.headerToImports, Lean.FileMap.toPosition, Lean.Parser.InputContext.fileMap, Lean.Parser.ModuleParserState.pos]]
[Int.repr,[String, Nat.repr, HAppend.hAppend, Nat.succ]]
[Lean.Server.FileWorker.logSnapContent,[IO.eprintln, HAppend.hAppend, ToString.toString, Lean.Server.Snapshots.Snapshot.beginPos, Lean.Server.Snapshots.Snapshot.endPos, String.extract, Lean.FileMap.source, HSub.hSub, OfNat.ofNat]]
[Lean.Elab.Command.elabNonComputableSection,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Unit.unit, Lean.Name.num, Lean.Elab.Command.CommandElabM, Unit, Pure.pure, Bind.bind, PProd.fst, Lean.MonadResolveName.getCurrNamespace, modify, Lean.Elab.Command.State.mk, Lean.Environment.registerNamespace, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, List.cons, Lean.Elab.Command.Scope.mk, Lean.Elab.Command.Scope.opts, Lean.Elab.Command.Scope.openDecls, Lean.Elab.Command.Scope.levelNames, Lean.Elab.Command.Scope.varDecls, Lean.Elab.Command.Scope.varUIds, or, Lean.Elab.Command.Scope.isNoncomputable, List.head!, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Lean.pushScope, Lean.activateScoped, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData, Bool.false, Lean.Syntax.getId, Lean.Elab.throwUnsupportedSyntax]]
[Function.inv_fun_on_mem,[And.left, Function.inv_fun_on_pos]]
[Lean.Elab.Term.StructInst.Field.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Command.instInhabitedStructFieldKind,[Inhabited.mk, Lean.Elab.Command.StructFieldKind.newField]]
[Lean.Elab.CommandInfo.format,[Pure.pure, HAppend.hAppend, Std.ToFormat.format, ite, Eq, Lean.Name.isAnonymous, Lean.Elab.ElabInfo.elaborator, Bool.true, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Std.Format, Lean.Elab.ElabInfo.stx, Lean.Elab.CommandInfo.toElabInfo]]
[Lean.Elab.Term.Arg.stx.inj,[]]
[Lean.markAuxRecursor,[Lean.TagDeclarationExtension.tag, Lean.auxRecExt]]
[eq_of_heq,[]]
[MonadFunctorT.monadMap,[]]
[Lean.Parser.Command.example.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declSig.formatter, Lean.Parser.Command.declVal.formatter]]
[Lean.Parser.Tactic.seq1.formatter,[Lean.PrettyPrinter.Formatter.node.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.sepBy1.formatter, Lean.Parser.tacticParser.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter, Bool.true]]
[Lean.Parser.Command.check_failure.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Set.instUnionSet,[Union.mk, Set.union]]
[StateT.run_modifyGet,[of_eq_true, eq_self, Pure.pure]]
[Lean.IR.ExplicitRC.VarInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.ExplicitRC.VarInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Int.natAbs_eq,[Or, Eq, Int.ofNat, Int.natAbs, Neg.neg, Or.inl, rfl, Or.inr]]
[Lean.Parser.isLitKind,[or, BEq.beq, Lean.strLitKind, Lean.numLitKind, Lean.charLitKind, Lean.nameLitKind, Lean.scientificLitKind]]
[Lean.Parser.Tactic.wittTruncateFunTac,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[CoeTC.noConfusionType,[]]
[Lean.Elab.Term.elabForIn.throwFailure,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr]]
[StateT.instMonadLiftStateT,[MonadLift.mk, StateT.lift]]
[Lean.Server.RequestM,[ReaderT, Lean.Server.RequestContext, EIO, Lean.Server.RequestError]]
[Std.PersistentArray.foldl,[Id.run, Std.PersistentArray.foldlM]]
[Lean.Meta.mkAppM,[Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.withNewMCtxDepth, Bind.bind, Lean.getConstInfo, List.mapM, Lean.Meta.mkFreshLevelMVar, Lean.ConstantInfo.levelParams, Pure.pure, Prod.mk, Lean.Meta.MetaM, Lean.Expr, OfNat.ofNat, List.toArray, List.nil, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, PUnit.unit]]
[Lean.Meta.withNewMCtxDepth,[Lean.Meta.mapMetaM, Bind.bind, MonadState.get, modify, Lean.Meta.State.mk, Lean.MetavarContext.incDepth, Lean.Meta.State.mctx, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Std.PersistentArray.mk, tryFinally, Lean.Meta.State.postponed]]
[Lean.SimplePersistentEnvExtensionDescr.addEntryFn,[]]
[Lean.Elab.Term.MutualClosure.getKindForLetRecs,[ite, Eq, Array.any, Lean.Elab.DefKind.isTheorem, Lean.Elab.DefViewElabHeader.kind, OfNat.ofNat, Array.size, Bool.true, Lean.Elab.DefKind.theorem, Lean.Elab.DefKind.def]]
[seqRight_eq_bind,[Eq.mpr, Eq.refl, Eq, SeqRight.seqRight, Bind.bind, LawfulApplicative.seqRight_eq, of_eq_true, Eq.trans, congrFun, congrArg, Seq.seq, map_eq_pure_bind, id, seq_eq_bind_map, Pure.pure, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, id_eq, bind_pure, eq_self]]
[Lean.IR.FnBody.unreachable.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Term.arrow,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.unicodeSymbol, Lean.Parser.termParser]]
[Lean.Name.eqStr,[Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Bool, BEq.beq, Bool.false]]
[congrFun,[rfl]]
[coeTail,[CoeTail.coe]]
[Lean.Parser.Syntax.addPrio,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Expr.setOption,[Lean.mkMData, Lean.KVMap.set, Lean.MData.empty]]
[Lean.instToMessageDataFormat,[Lean.ToMessageData.mk, Lean.MessageData.ofFormat]]
[Lean.Elab.Term.elabTypeStx,[Bind.bind, ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, Lean.levelZero, Lean.Elab.Term.elabLevel, Lean.Syntax.getOp, OfNat.ofNat, Lean.mkSort, Lean.mkLevelSucc]]
[EIO.bindTask,[BaseIO.bindTask, EIO.catchExceptions, Pure.pure, Task.pure, Except.error]]
[Lean.Lsp.instFromJsonDidCloseTextDocumentParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Pure.pure, Lean.Lsp.DidCloseTextDocumentParams.mk]]
[Lean.Lsp.RpcKeepAliveParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.RpcKeepAliveParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.ExplicitBoxing.getJPParams,[Bind.bind, Lean.IR.ExplicitBoxing.getLocalContext, Unit.unit, Lean.IR.ExplicitBoxing.M, Array, Lean.IR.Param, Lean.IR.LocalContext.getJPParams, Pure.pure, List.toArray, List.nil]]
[Lean.Expr.mvarId!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.MVarId, panicWithPosWithDecl, OfNat.ofNat]]
[not_false,[id]]
[Lean.KeyedDeclsAttribute.Def.mk.inj,[And.intro]]
[Lean.mkStateFromImportedEntries,[Array.foldl, OfNat.ofNat, Array.size]]
[Lean.IR.FnBody.setBody,[Lean.IR.FnBody.case, Lean.IR.FnBody.ret, Lean.IR.FnBody.jmp, Lean.IR.FnBody.unreachable, Lean.IR.FnBody, Lean.IR.FnBody.vdecl, Lean.IR.FnBody.jdecl, Lean.IR.FnBody.set, Lean.IR.FnBody.uset, Lean.IR.FnBody.sset, Lean.IR.FnBody.setTag, Lean.IR.FnBody.inc, Lean.IR.FnBody.dec, Lean.IR.FnBody.del, Lean.IR.FnBody.mdata]]
[SubNegMonoid.toSub,[]]
[Lean.RecursorVal.numIndices,[]]
[Lean.Parser.Tactic.Conv.simpMatch,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Elab.Term.StructInst.Source.implicit.inj,[]]
[List.all,[List.foldr, and, Bool.true]]
[Lean.ScopedEnvExtension.StateStack.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ScopedEnvExtension.StateStack.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.instBEqRat,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Server.instRpcEncodingOptionOption,[Lean.Server.RpcEncoding.mk, Unit.unit, Option, Pure.pure, Option.none, Functor.map, Option.some, Lean.Server.RpcEncoding.rpcEncode, ExceptT, String, Lean.Server.RpcEncoding.rpcDecode]]
[Int.distrib_left,[Eq, HMul.hMul, HAdd.hAdd, of_eq_true, Eq.trans, congr, congrArg, Int.ofNat, Int.ofNat_add_ofNat, Int.ofNat_mul_ofNat, Nat.left_distrib, eq_self, Eq.mpr, Int.ofNat_add_negSucc_ofNat, Int.ofNat_mul_subNatNat, Nat.succ, Int.ofNat_mul_negSucc_ofNat, Int.negOfNat_eq_subNatNat_zero, Eq.refl, Int.subNatNat, OfNat.ofNat, Eq.symm, Int.subNatNat_add, rfl, Int.negSucc_ofNat_add_ofNat, Int.add_comm, Int.negSucc_ofNat_add_negSucc_ofNat, Int.negOfNat_add, Int.negOfNat, Nat.succ_add, Int.negSucc, Int.negSucc_ofNat_ofNat, Nat.mul_comm, Nat.right_distrib, Int.negSucc_ofNat_mul_subNatNat, Int.mul_negSucc_ofNat_negSucc_ofNat, Int.ofNat.injEq]]
[Lean.Lsp.instToJsonLocation,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.Location.uri, List.nil, Lean.Lsp.Location.range]]
[Lean.Expr.mvar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.ExpandResetReuse.isSelfUSet,[Option.none, Option.some, Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.sproj, Lean.IR.Expr.fap, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Bool, Std.HashMap.find?, Lean.IR.ExpandResetReuse.Context.projMap, and, BEq.beq, Bool.false]]
[Lean.Parser.Term.binop_lazy.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec]]
[if_ctx_simp_congr_prop,[if_ctx_congr_prop]]
[Lean.Server.MonadRpcSession.rpcGetRef,[]]
[Lean.Parser.Tactic.tacticHave'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Lean.Level.normLt,[Lean.Level.normLtAux, OfNat.ofNat]]
[Lean.Parser.Term.waitIfTypeContainsMVar.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.termParser.formatter]]
[Lean.Meta.MatcherApp.matcherLevels,[]]
[Lean.Parser.Tactic.squeezeSimp!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[String.Range.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.AbstractNestedProofs.State.mk.inj,[]]
[not_and_of_not_right,[mt, And.right]]
[Lean.Json.Parser.natNumDigits,[Bind.bind, Lean.Json.Parser.lookahead, And, LE.le, Char.ofNat, Lean.Json.Parser.natCore, OfNat.ofNat]]
[Lean.Parser.termParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Elab.DefView.kind,[]]
[Lean.Elab.Tactic.Location.targets.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.Location.targets, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Command.commandStop_at_first_error_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[Std.PersistentHashMap.Entry.ref.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.MetaM.toIO,[Bind.bind, Lean.Core.CoreM.toIO, Lean.Meta.MetaM.run, IO, Prod, Lean.Core.State, Lean.Meta.State, Pure.pure, Prod.mk]]
[Lean.Elab.Tactic.ElimApp.Result.alts,[]]
[Lean.PrettyPrinter.delabCore,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Std.ToFormat.format, Pure.pure, PUnit.unit]]
[Lean.IR.Expr.ctor.inj,[And.intro]]
[IO.FileRight.flags,[UInt32.lor]]
[Lean.Meta.Match.counterExampleToMessageData,[Lean.Meta.Match.examplesToMessageData]]
[String.endsWith,[BEq.beq, Substring.takeRight, String.toSubstring, String.length]]
[Lean.Expr.updateForall,[Lean.mkForall, Lean.Expr.bindingName!]]
[Lean.Expr.occurs,[Option.isSome, Lean.Expr.find?, BEq.beq]]
[Lean.Server.Watchdog.FileWorker.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.Watchdog.FileWorker.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Tactic.MkSimpContextResult.noConfusionType,[]]
[String.Iterator.i,[]]
[Lean.Widget.InteractiveDiagnostic.instRpcEncodingInteractiveDiagnosticRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Lean.Lsp.DiagnosticWith.message, Pure.pure, Lean.Lsp.DiagnosticWith.mk, Lean.Lsp.DiagnosticWith.range, Lean.Lsp.DiagnosticWith.fullRange, Lean.Lsp.DiagnosticWith.severity?, Lean.Lsp.DiagnosticWith.code?, Lean.Lsp.DiagnosticWith.source?, Lean.Lsp.DiagnosticWith.tags?, Lean.Lsp.DiagnosticWith.relatedInformation?, Lean.Server.RpcEncoding.rpcDecode]]
[Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer,[Pure.pure, Unit.unit]]
[Lean.Elab.Term.elabEnsureExpectedType,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Syntax.isStrLit?, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.throwIllFormedSyntax, Lean.Elab.Term.elabTermEnsuringType, Bool.true, Option.some]]
[Lean.Server.instRpcEncodingArrayArray,[Lean.Server.RpcEncoding.mk, Array.mapM, Lean.Server.RpcEncoding.rpcEncode, Lean.Server.RpcEncoding.rpcDecode]]
[Lean.Meta.SimpAll.Entry.userName,[]]
[Lean.Meta.mkEqRefl,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getLevel, Pure.pure, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil]]
[Std.ShareCommon.ObjectPersistentMap.find?,[Std.PersistentHashMap.find?]]
[Lean.Parser.Command.synth.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.Name.noConfusionType,[]]
[Lean.Meta.Config.isDefEqStuckEx,[]]
[Lean.Parser.Tactic.Conv.rewrite,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq]]
[Lean.Elab.Term.Do.CodeBlock.mk.inj,[And.intro]]
[Lean.Meta.Match.MatcherInfo.numAlts,[Array.size, Lean.Meta.Match.MatcherInfo.altNumParams]]
[String.csize_pos,[Char.utf8Size_pos]]
[Lean.Xml.Content.Character.inj,[]]
[Lean.PrettyPrinter.Delaborator.ParamKind.defVal,[]]
[Char.repr,[Char.quote]]
[Array.findIdx?.loop.proof_1,[absurd, Eq.mp, Eq.refl, LT.lt, Array.size, Eq, HAdd.hAdd, OfNat.ofNat, Nat.zero_add, Nat.lt_irrefl]]
[Lean.Position.column,[]]
[Lean.Meta.DiscrTree.instInhabitedKey,[Inhabited.mk, Lean.Meta.DiscrTree.Key.const, arbitrary]]
[Lean.Widget.InteractiveHypothesis.val?,[]]
[List.erasep_cons_of_neg,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.erasep_cons, ite_congr, eq_false, Eq.refl, List.cons, List.erasep, ite_false, eq_self]]
[instDecidableLe_5,[LinearOrder.decidable_le]]
[Lean.ConstMap,[Lean.SMap, Lean.Name, Lean.ConstantInfo]]
[Std.RBMap.max!,[Unit.unit, Prod, Std.RBMap.max, panicWithPosWithDecl, OfNat.ofNat]]
[UInt64.instSemiringUInt64,[Semiring.mk, UInt64.instSemiringUInt64.proof_1, UInt64.instSemiringUInt64.proof_2, UInt64.mk, Semiring.nsmul, UInt64.val, UInt64.instSemiringUInt64.proof_3, UInt64.instSemiringUInt64.proof_4, UInt64.instSemiringUInt64.proof_5, UInt64.instSemiringUInt64.proof_6, UInt64.instSemiringUInt64.proof_7, UInt64.instSemiringUInt64.proof_8, UInt64.instSemiringUInt64.proof_9, UInt64.instSemiringUInt64.proof_10, UInt64.instSemiringUInt64.proof_11, UInt64.instSemiringUInt64.proof_12, UInt64.instSemiringUInt64.proof_13]]
[Lean.Lsp.instToJsonDocumentSymbolParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.DocumentSymbolParams.textDocument, List.nil]]
[Lean.Parser.Tactic.rintro,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[Lean.Elab.OpenDecl.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.OpenDecl.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[LT.lt,[]]
[not_forall_of_exists_not,[False]]
[Lean.Parser.ParserExtension.OLeanEntry.noConfusionType,[]]
[HOrElse.hOrElse,[]]
[Std.RBNode.setRed,[Std.RBNode.leaf, Std.RBNode, Std.RBNode.node, Std.Rbcolor.red]]
[set.separates_points,[Exists, And, Mem.mem, Ne]]
[Lean.PPContext.runCoreM,[Functor.map, Prod.fst, Lean.Core.CoreM.toIO, Lean.Core.Context.mk, Lean.PPContext.opts, Lean.PPContext.currNamespace, Lean.PPContext.openDecls, Lean.Core.State.mk, Lean.PPContext.env, Lean.NameGenerator.mk, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.instDecidableEqDeclarationRange,[Decidable, Eq, dite, Decidable.isTrue, rfl, Decidable.isFalse]]
[Std.AssocList.mapKey,[Unit.unit, Std.AssocList, Std.AssocList.nil, Std.AssocList.cons, PProd.fst]]
[instCommMonoid_1.proof_2,[Semiring.one_mul]]
[Lean.Elab.Term.LetRecView.noConfusionType,[]]
[Lean.Expr.lam.inj,[And.intro]]
[Lean.Occurrences.all.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[RandomGen.split,[]]
[Std.HashSet.instInhabitedHashSet,[Inhabited.mk, Std.mkHashSet, OfNat.ofNat]]
[Lean.Meta.ParamInfo.noConfusionType,[]]
[Lean.JsonRpc.RequestID.null.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[List.getLast.proof_2,[]]
[Lean.Elab.Term.SyntheticMVarKind.noConfusionType,[]]
[Lean.Meta.Match.Unify.State.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Unify.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Formatter.Context.mk.inj,[And.intro]]
[Lean.Meta.SynthInstance.Answer.result,[]]
[Lean.Parser.precedenceParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Elab.Command.StructView.declName,[]]
[Lean.bignumFromJson?,[Bind.bind, Lean.Json.getStr?, Pure.pure, Lean.Syntax.decodeNatLitVal?, Option.none, Except, String, Nat, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Lean.IR.ExplicitRC.addInc,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Lean.IR.FnBody.inc, Lean.IR.ExplicitRC.VarInfo.persistent]]
[Lean.mkApp8,[Lean.mkApp4]]
[Lean.Expr.updateForallE!.proof_1,[rfl]]
[Lean.Elab.logAt,[ite, Eq, and, BEq.beq, Lean.MessageSeverity.error, Lean.MessageData.hasSyntheticSorry, Bool.true, Pure.pure, PUnit.unit, Bind.bind, Lean.Elab.MonadLog.getRef, Lean.MonadFileMap.getFileMap, Lean.AddMessageContext.addMessageContext, Lean.Elab.MonadLog.getFileName, Lean.Elab.MonadLog.logMessage, Lean.Message.mk, Lean.FileMap.toPosition, Option.some]]
[instMonadLiftBaseIOEIO,[MonadLift.mk, BaseIO.toEIO]]
[Lean.Parser.Tactic.librarySearch!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser]]
[Lean.Parsec.expectedEndOfInput,[]]
[Lean.Declaration.opaqueDecl.inj,[]]
[Subarray.forInUnsafe.loop,[ite, LT.lt, Bind.bind, Pure.pure, Subarray.forInUnsafe.loop, HAdd.hAdd, OfNat.ofNat]]
[or_of_or_of_imp_of_imp,[Or.imp]]
[Lean.Elab.mkMacroAttributeUnsafe,[Lean.Elab.mkElabAttribute, Lean.Macro, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Syntax.setArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.node]]
[UInt8.size_positive,[of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Parser.tryAnti,[Id.run, ite, Eq, BEq.beq, Lean.Parser.ParserContext.quotDepth, OfNat.ofNat, Bool.true, Pure.pure, Bool.false, Bind.bind, PUnit.unit]]
[Lean.Meta.Match.processInaccessibleAsCtor,[Bind.bind, Lean.MonadEnv.getEnv, List.nil, Lean.Meta.Match.Pattern.inaccessible, List.cons, Lean.Meta.Match.Pattern.var, Lean.Meta.Match.Pattern.ctor, Lean.Meta.Match.Pattern.val, Lean.Meta.Match.Pattern.arrayLit, Lean.Meta.Match.Pattern.as, Lean.Meta.MetaM, Option, Lean.Meta.Match.Alt, Lean.Meta.Match.Alt.patterns, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.instToMessageDataArray,[Lean.ToMessageData.mk, Lean.ToMessageData.toMessageData, Array.toList]]
[Lean.resolveGlobalConstNoOverload,[Bind.bind, Lean.resolveGlobalConst, List.nil, List.cons, Lean.Name, Pure.pure, Lean.throwErrorAt, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, HAppend.hAppend, ToString.toString, List.map, Lean.mkConst]]
[Lean.Parser.Tactic.choose,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.ReducibilityHints.opaque.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.LocalContext.setBinderInfo,[Lean.LocalContext.modifyLocalDecl, Lean.LocalDecl.setBinderInfo]]
[UInt32.mk_val_eq,[Eq, UInt32.mk, UInt32.val, rfl]]
[Lean.Meta.Match.Example.var.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Example.var, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.annotateNamedArg,[Bind.bind, liftM, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.annotateBool, Lean.Name.mkStr, Lean.Name.anonymous, modify, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.bottomUps, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.higherOrders, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.funBinders, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.provideds, Array.push, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.namedArgs]]
[Lean.Meta.Cases.Context.nminors,[]]
[Lean.Parser.instInhabitedFirstTokens,[Inhabited.mk, Lean.Parser.FirstTokens.epsilon]]
[Lean.Declaration.mutualDefnDecl.injEq,[Eq.propIntro, Eq.refl, Lean.Declaration.mutualDefnDecl, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Tactic.evalGeneralize,[Lean.Elab.Tactic.withMainContext, Bind.bind, Array.mapM, Lean.Elab.Tactic.elabTerm, Lean.Syntax.getOp, OfNat.ofNat, Option.none, Bool.false, Pure.pure, Lean.Meta.GeneralizeArg.mk, Option.some, Lean.Syntax.getId, Lean.Syntax.getSepArgs, Lean.Elab.Tactic.liftMetaTactic, Lean.Meta.generalize, Lean.Meta.MetaM, List, Lean.MVarId, List.cons, List.nil]]
[Lean.Lsp.SemanticTokensRangeParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.elabMatch.elabMatchDefault,[Bind.bind, ite, Eq, Lean.Syntax.isNone, Bool.true, Array.allM, Functor.map, Option.isSome, Lean.Elab.Term.isAtomicDiscr?, Lean.Syntax.getOp, OfNat.ofNat, Array.size, Pure.pure, Option.none, Array.toList, List.toArray, List.nil, EmptyCollection.emptyCollection, Option.some, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Syntax, Lean.Syntax.setArg, Lean.Expr.isFVar, PProd.fst, Array.push, Std.RBTree.insert, Lean.Expr.fvarId!, Lean.Expr, Lean.Elab.Term.withMacroExpansion, Lean.Elab.Term.elabTerm, and, not, Array.any, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, PUnit.unit]]
[IO.Process.Output.mk.inj,[And.intro]]
[Std.PersistentHashMap.Stats.numNull,[]]
[Lean.Meta.Cache.inferType,[]]
[Nat.gcd_pos_of_pos_left,[Nat.pos_of_dvd_of_pos, Nat.gcd_dvd_left]]
[«term_∧_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.DefKind.theorem.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Lsp.InitializeParams.workspaceFolders?,[]]
[Lean.Meta.instInhabitedConstantInfo,[Inhabited.mk, Lean.ConstantInfo.axiomInfo, arbitrary]]
[Lean.Meta.SimpLemma.mk.inj,[And.intro]]
[id_map',[LawfulFunctor.id_map]]
[Lean.Meta.DefEqContext.mk.inj,[And.intro]]
[Lean.Meta.instReduceEvalNat,[Lean.Meta.ReduceEval.mk, Bind.bind, Lean.Meta.whnf, Lean.Meta.evalNat, Option.none, Lean.Meta.MetaM, Nat, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr]]
[List.head,[absurd, Eq.refl, List.nil]]
[UInt32.decLt,[Decidable, LT.lt, inferInstanceAs]]
[Lean.ClassState.addEntry,[Lean.ClassState.mk, Lean.SMap.insert, Lean.ClassState.hasOutParam, Lean.ClassEntry.name, Lean.ClassEntry.hasOutParam]]
[OrElse.noConfusionType,[]]
[Lean.IR.ExpandResetReuse.Context.projMap,[]]
[IO.Error.resourceExhausted.inj,[And.intro]]
[Nat.ibelow,[True, And]]
[Lean.MetavarContext.abstractRange,[Lean.MetavarContext.MkBinding.abstractRange, Bool.false]]
[max_eq_left_of_lt,[max_eq_left, le_of_lt]]
[Lean.Elab.Term.ElabAppArgs.State.namedArgs,[]]
[Lean.Parser.Term.paren.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ppDedent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withoutPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withoutForbidden.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.Term.parenSpecial.parenthesizer]]
[Std.PersistentArrayNode.leaf.inj,[]]
[Lean.Meta.Match.instInhabitedMatchEqns,[Inhabited.mk, Lean.Meta.Match.MatchEqns.mk, arbitrary]]
[Lean.Parser.Command.namespace,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident]]
[Lean.Elab.Term.expandWhereDeclsOpt,[ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, Lean.Elab.Term.expandWhereDecls, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Parser.Term.doIf.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.doIfCond.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer, Lean.Parser.many.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGe.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.Term.elseIf.parenthesizer, Lean.Parser.optional.parenthesizer]]
[IO.Process.SpawnArgs.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.AttributeExtensionOLeanEntry.noConfusionType,[]]
[Lean.Meta.CongrArgKind.noConfusionType,[noConfusionTypeEnum, Lean.Meta.CongrArgKind.toCtorIdx]]
[Std.Format.tag.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Syntax.instToStringSyntax,[ToString.mk, Function.comp, ToString.toString, Std.ToFormat.format]]
[Lean.Server.Watchdog.WorkerEvent.ioError.injEq,[Eq.propIntro, Eq.refl, Lean.Server.Watchdog.WorkerEvent.ioError, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.SSet.instInhabitedSSet,[inferInstanceAs, Inhabited, Lean.SMap, Unit]]
[Lean.Rat.instDecidableLt,[inferInstanceAs, Decidable, Eq, Lean.Rat.lt, Bool.true]]
[Int.sub_eq_add_neg,[rfl]]
[Tactic.Ring.RingM.run,[Bind.bind, Lean.Meta.getLevel, Lean.Level.zero, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Meta.MetaM, Lean.Meta.synthInstance, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil, Option.none, StateRefT'.run', Tactic.Ring.Cache.mk, Tactic.Ring.State.mk, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Array.ext',[Eq.symm, eq_of_heq, Eq.refl, Array.data, Array.mk, HEq.refl, Eq, rfl]]
[Lean.PrettyPrinter.Parenthesizer.scientificLit.parenthesizer,[Lean.Parser.Term.scientific.parenthesizer]]
[Std.mkRBMap.proof_1,[Std.RBNode.WellFormed.leafWff]]
[Lean.Meta.Simp.Result.expr,[]]
[Lean.IR.instToStringVarId,[ToString.mk, HAppend.hAppend, ToString.toString, Lean.IR.VarId.idx]]
[Lean.Import.noConfusionType,[]]
[Lean.IR.Checker.checkScalarVar,[Lean.IR.Checker.checkVarType, Lean.IR.IRType.isScalar]]
[Decidable.not_imp,[Iff.intro, And.intro, Decidable.of_not_imp, not_of_not_imp, not_imp_of_and_not]]
[Lean.Meta.getZetaFVarIds,[Bind.bind, MonadState.get, Pure.pure, Lean.Meta.State.zetaFVarIds]]
[Lean.PrettyPrinter.Delaborator.Context.currNamespace,[]]
[Lean.Meta.UnificationConstraint.mk.inj,[And.intro]]
[List.mem_filter,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, propext, List.mem_filterAux, List.nil, Or, And, Mem.mem, Eq, Bool.true, List.mem_nil_iff, or_false, iff_self]]
[Lean.Meta.IndPredBelow.Variables.innerType,[]]
[instCoeNatInt,[Coe.mk, Int.ofNat]]
[Lean.IR.EmitC.emitPartialApp,[Bind.bind, Lean.IR.EmitC.getDecl, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitCName, Array.size, Lean.IR.EmitC.emitLn, Nat.forM, Lean.IR.EmitC.emitArg]]
[Nat.succ_ne_self,[False, absurd, Nat.succ_ne_zero, OfNat.ofNat, PProd.fst, id]]
[instDecidableEqQuotient.proof_1,[instSubsingletonDecidable, Eq, Quotient.mk]]
[Lean.Elab.Term.elabApp,[Lean.Elab.Term.withoutPostponingUniverseConstraints, Bind.bind, Lean.Elab.Term.expandApp, Bool.false, Lean.Elab.Term.TermElabM, Lean.Expr, List.nil, List.toArray, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Pure.pure, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError]]
[Lean.Parser.Tactic.Conv.for,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.const, Lean.ParserDescr.parser]]
[Ordering.lt.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.getConstInfo,[Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.ConstantInfo, Lean.Environment.find?, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkConst, List.nil]]
[Lean.Elab.addAndCompileUnsafe,[Lean.withRef, Lean.Elab.PreDefinition.ref, Array.getOp, OfNat.ofNat, Bind.bind, Lean.addDecl, Lean.Elab.withSaveInfoContext, ForIn.forIn, PUnit.unit, Lean.mkConstWithLevelParams, Lean.Elab.PreDefinition.declName, Lean.Elab.Term.addTermInfo, Option.none, Lean.Name.anonymous, Bool.true, Pure.pure, ForInStep.yield, Lean.Elab.applyAttributesOf, Lean.AttributeApplicationTime.afterTypeChecking, MonadExcept.tryCatch, Lean.compileDecl, DoResultPR.pure, MonadReader.read, ite, Eq, Lean.Elab.Term.Context.isNoncomputableSection, DoResultPR.return, Bool.false, MonadExcept.throw, Lean.Elab.Term.TermElabM, Bool, Unit.unit]]
[List.cons.injEq,[Eq.propIntro, And.intro, Eq.refl, List.cons, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Tactic.Conv.evalNestedConv,[Lean.Elab.Tactic.Conv.evalConvSeqBracketed, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Parser.Tactic.applyRules,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.ParserDescr.parser, Lean.ParserDescr.const]]
[Nat.gt_of_not_le,[GT.gt, Nat.lt_or_ge, absurd]]
[Lean.Server.FileWorker.CancelToken.check,[Bind.bind, ST.Ref.get, Lean.Server.FileWorker.CancelToken.ref, ite, Eq, Bool.true, MonadExcept.throw, Lean.Server.FileWorker.ElabTaskError.aborted, Pure.pure, PUnit.unit]]
[Lean.Elab.Tactic.evalRewriteSeq,[Bind.bind, liftM, Lean.Elab.Tactic.elabRewriteConfig, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.withRWRulesSeq, Lean.Elab.Tactic.withLocation, Lean.Elab.Tactic.rewriteLocalDecl, Lean.Elab.Tactic.rewriteTarget, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing]]
[Lean.IR.EmitC.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.EmitC.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Simp.instBEqConfig,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Parser.Term.haveDecl.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.haveIdDecl.parenthesizer, Lean.Parser.Term.letPatDecl.parenthesizer, Lean.Parser.Term.haveEqnsDecl.parenthesizer, Bool.false]]
[Lean.IR.IRType.isIrrelevant,[Lean.IR.IRType.float, Lean.IR.IRType.uint8, Lean.IR.IRType.uint16, Lean.IR.IRType.uint32, Lean.IR.IRType.uint64, Lean.IR.IRType.usize, Unit.unit, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.struct, Lean.IR.IRType.union, Bool, Bool.true, Bool.false]]
[Lean.Parser.mkAntiquotSplice.formatter,[Lean.Parser.leadingNode.formatter, Lean.Parser.maxPrec, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.setExpected.formatter, List.nil, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.manyNoAntiquot.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.PrettyPrinter.Formatter.node.formatter, Lean.nullKind]]
[Lean.Syntax.Traverser.down,[ite, LT.lt, Lean.Syntax.getNumArgs, Lean.Syntax.Traverser.cur, Lean.Syntax.Traverser.mk, Lean.Syntax.getArg, Array.push, Lean.Syntax.Traverser.parents, Lean.Syntax.setArg, arbitrary, Lean.Syntax.Traverser.idxs, Lean.Syntax.missing]]
[Lean.Elab.Deriving.DecEq.mkDecEqInstanceHandler,[ite, Eq, bne, Array.size, OfNat.ofNat, Bool.true, Pure.pure, Bool.false, Bind.bind, Lean.isEnumType, Array.getOp, Lean.Elab.Deriving.DecEq.mkDecEqEnum, Lean.Elab.Deriving.DecEq.mkDecEq]]
[Nat.zero_eq,[rfl]]
[Lean.Meta.mkHEqRefl,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getLevel, Pure.pure, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil]]
[Lean.Elab.Term.throwMVarError,[Bind.bind, MonadState.get, ite, Eq, Lean.MessageLog.hasErrors, Lean.Elab.Term.State.messages, Bool.true, Lean.Elab.throwAbortTerm, Lean.throwError]]
[List.reverse_cons,[Eq.mpr, Eq.refl, Eq, List.reverseAux, List.cons, List.nil, HAppend.hAppend, Eq.symm, List.reverseAux_eq_append, rfl]]
[Lean.Meta.IndPredBelow.Variables.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.IndPredBelow.Variables.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Fin.isLt,[]]
[Array.mapMUnsafe,[unsafeCast, OfNat.ofNat, Array.mapMUnsafe.map]]
[Lean.Expr.updateFn,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateApp!, PProd.fst]]
[Lean.Elab.Visibility.noConfusion,[noConfusionEnum, Lean.Elab.Visibility.toCtorIdx]]
[Lean.PrettyPrinter.Parenthesizer.addPrecCheck,[modify, Lean.PrettyPrinter.Parenthesizer.State.mk, Lean.PrettyPrinter.Parenthesizer.State.stxTrav, Option.some, Nat.min, Option.getD, Lean.PrettyPrinter.Parenthesizer.State.contPrec, Lean.PrettyPrinter.Parenthesizer.State.contCat, Lean.PrettyPrinter.Parenthesizer.State.minPrec, Lean.PrettyPrinter.Parenthesizer.State.trailPrec, Lean.PrettyPrinter.Parenthesizer.State.trailCat, Lean.PrettyPrinter.Parenthesizer.State.visitedToken]]
[Lean.Meta.mkEqFalse,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil]]
[of_decide_eq_false,[Not, absurd, ne_false_of_eq_true, decide_eq_true]]
[Lean.IR.ExplicitRC.VarInfo.noConfusionType,[]]
[instInhabitedProd,[Inhabited.mk, Prod.mk, arbitrary]]
[Lean.Syntax.MonadTraverser.setCur,[modify, Lean.Syntax.Traverser.setCur]]
[String.instInhabitedRange,[Inhabited.mk, String.Range.mk, arbitrary]]
[Lean.getBuiltinInitFnNameFor?,[Lean.getInitFnNameForCore?, Lean.builtinInitAttr]]
[Tactic.Ring.HornerExpr.isZero,[Tactic.Ring.HornerExpr.xadd, Bool, Decidable.decide, Eq, OfNat.ofNat, Bool.false]]
[add_left_inj,[Iff.intro, add_right_cancel, rfl]]
[Subtype.mk.inj,[]]
[Lean.binductionOnSuffix,[]]
[Lean.Meta.reduceUnaryNatOp,[Lean.Meta.withNatValue, Pure.pure, Option.some, Lean.mkRawNatLit]]
[Lean.Lsp.MarkupContent.mk.inj,[And.intro]]
[Lean.getReducibilityStatus,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.getReducibilityStatusImp]]
[Pow.pow,[]]
[instDecidableEq.proof_1,[Iff.rfl]]
[Lean.Elab.DerivingClassView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.remove_eq_of_not_mem,[Eq, List.remove, of_eq_true, eq_self, List.nil]]
[Lean.IR.AlphaEqv.aeqv,[]]
[Lean.Parser.SyntaxNodeKindSet,[Std.PersistentHashMap, Lean.SyntaxNodeKind, Unit]]
[Lean.MetavarDecl.mk.inj,[And.intro]]
[Lean.Parser.Term.attrInstance.parenthesizer,[Lean.Parser.ppGroup.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.attrParser.parenthesizer]]
[Lean.LOption.some.injEq,[Eq.propIntro, Eq.refl, Lean.LOption.some, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Compiler.SpecEntry.info.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Compiler.SpecEntry.info, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.withoutForbidden,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.Parser.fn, Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.prec, Lean.Parser.ParserContext.tokens, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Parser.ParserContext.savedPos?, Option.none]]
[List.subset.refl,[]]
[fixCore6,[bfix6, USize.size]]
[Lean.Meta.NormNum.LawfulOfNat.isNat_ofNat,[]]
[Subarray.h₂,[]]
[Std.RBNode.revFold,[PProd.fst, PProd.snd]]
[Array.ext,[congrArg, Array.mk, Eq.symm, Eq.refl, Array.ext.extAux]]
[Nat.not_le_of_not_ble_eq_true,[absurd, Nat.ble_eq_true_of_le]]
[Lean.BinderInfo.instImplicit.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Server.Watchdog.GroupedEdits.signalTask,[]]
[Lean.LeanPaths.mk.inj,[And.intro]]
[Lean.Widget.instInhabitedMsgEmbed,[Inhabited.mk, Lean.Widget.MsgEmbed.expr, arbitrary]]
[Lean.instInhabitedStructureDescr,[Inhabited.mk, Lean.StructureDescr.mk, arbitrary]]
[false_implies,[propext, Iff.intro, trivial, absurd, of_decide_eq_false, Eq.refl, Decidable.decide, False]]
[Lean.Elab.TermInfo.mk.inj,[And.intro]]
[Lean.Elab.Tactic.ensureHasNoMVars,[Bind.bind, liftM, Lean.Meta.instantiateMVars, Lean.Meta.getMVars, Functor.discard, Lean.Elab.Term.logUnassignedUsingErrorInfos, Option.none, ite, Eq, Lean.Expr.hasExprMVar, Bool.true, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Pure.pure, PUnit.unit]]
[Lean.Declaration.inductDecl.inj,[And.intro]]
[not_iff_false_intro,[iff_false_intro, not_not_intro]]
[StateRefT'.instMonadStateRefT',[inferInstanceAs, Monad, ReaderT, ST.Ref]]
[Lean.Parser.Command.catBehaviorBoth.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.nonReservedSymbol.formatter, Bool.false]]
[Lean.Elab.Term.StructInst.FieldVal.noConfusionType,[]]
[Lean.Meta.ppExpr,[Bind.bind, readThe, Lean.Core.Context, Lean.MonadEnv.getEnv, Lean.MonadMCtx.getMCtx, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, liftM, Lean.ppExpr, Lean.PPContext.mk, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls]]
[Lean.Parser.Command.constant.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.Command.declSig.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.declValSimple.parenthesizer]]
[Group.toDivInvMonoid,[]]
[Lean.Expr.isHEq,[Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat]]
[Std.PersistentArray.tooBig,[HDiv.hDiv, USize.size, OfNat.ofNat]]
[Lean.Elab.Command.elabSection,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Unit.unit, Lean.Name.num, Lean.Elab.Command.CommandElabM, Unit, Pure.pure, Bind.bind, PProd.fst, Lean.MonadResolveName.getCurrNamespace, modify, Lean.Elab.Command.State.mk, Lean.Environment.registerNamespace, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, List.cons, Lean.Elab.Command.Scope.mk, Lean.Elab.Command.Scope.opts, Lean.Elab.Command.Scope.openDecls, Lean.Elab.Command.Scope.levelNames, Lean.Elab.Command.Scope.varDecls, Lean.Elab.Command.Scope.varUIds, or, Lean.Elab.Command.Scope.isNoncomputable, List.head!, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Lean.pushScope, Lean.activateScoped, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData, Bool.false, Lean.Syntax.getId, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Parser.Tactic.normNum1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Nat.ofNat_eq_Nat,[rfl]]
[Lean.ParserCompiler.Context.mk.inj,[And.intro]]
[Lean.IR.ExplicitBoxing.BoxingState.nextIdx,[]]
[Lean.Meta.findCore.check,[ite, Eq, or, Lean.Meta.FindOptions.checkPrivate, not, Lean.isPrivateName, Bool.true, Bind.bind, Pure.pure, Array.push]]
[Lean.Meta.CongrArgKind.noConfusion,[noConfusionEnum, Lean.Meta.CongrArgKind.toCtorIdx]]
[Lean.Meta.GetEqnsFn,[Lean.Meta.MetaM, Option, Array, Lean.Name]]
[Lean.Parser.Tactic.applyAssumption,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Elab.Command.Context.currRecDepth,[]]
[Lean.Elab.Tactic.evalMatch,[Bind.bind, Lean.Elab.Tactic.getMainTag, Lean.Elab.liftMacroM, StateT.run, Array.mapM, Pure.pure, Lean.Elab.Tactic.AuxMatchTermState.mk, Lean.MacroM, Prod, Lean.Syntax, Array, Prod.mk, Lean.Elab.Tactic.AuxMatchTermState.cases, Lean.Elab.Tactic.TacticM, Unit, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Elab.Tactic.withMacroExpansion, Lean.Elab.Tactic.evalTactic]]
[Lean.Meta.Match.Example.ctor.inj,[And.intro]]
[Quot.inductionOn,[Quot.ind]]
[Nat.log2.proof_1,[]]
[mul_right_comm,[Eq.mpr, Eq.refl, Eq, HMul.hMul, mul_assoc, mul_comm, rfl]]
[String.drop,[Substring.toString, Substring.drop, String.toSubstring]]
[Lean.MetavarContext.findLevelDepth?,[Std.PersistentHashMap.find?, Lean.MetavarContext.lDepth]]
[Lean.IR.logDecls,[Bind.bind, MonadReader.read, ite, Eq, Option.none, Option.some, Lean.DataValue.ofString, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Bool, Lean.KVMap.find, Lean.KVMap.getBool, Lean.IR.tracePrefixOptionName, Bool.false, Bool.true, Lean.IR.log, Lean.IR.LogEntry.step, Pure.pure, PUnit.unit, HAppend.hAppend]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.StructInst.expandStructInstExpectedType,[ite, Eq, Lean.Syntax.isNone, Bool.true, Lean.Macro.throwUnsupported, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Lean.IR.ExpandResetReuse.expand,[Lean.IR.ExpandResetReuse.M, Lean.IR.FnBody, Bind.bind, Lean.IR.ExpandResetReuse.mkFastPath, List.toArray, List.nil, Lean.IR.ExpandResetReuse.mkFresh, Pure.pure, Lean.IR.reshape]]
[Lean.Elab.Term.Quotation.withNewLocals,[MonadWithReader.withReader, Lean.Elab.Term.Quotation.Precheck.Context.mk, Array.foldl, Lean.NameSet.insert, Lean.Elab.Term.Quotation.Precheck.Context.quotLCtx, OfNat.ofNat, Array.size]]
[Lean.Expr.inferImplicit,[dite, Eq, Lean.Expr.bvar, Eq.symm, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.mkForall]]
[Lean.Elab.Deriving.mkImplicitBinders,[Array.mapM, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Lean.mkIdent, List.nil]]
[USize.decEq.proof_1,[rfl]]
[Lean.Compiler.foldBinUInt,[OptionM.run, Bind.bind, Lean.Compiler.getNumLit, Lean.Compiler.getInfoFromVal, Pure.pure, Lean.Compiler.mkUIntLit]]
[Lean.Meta.GeneralizeTelescope.Entry.mk.inj,[And.intro]]
[Lean.Server.FileWorker.RefIdent.const.injEq,[Eq.propIntro, Eq.refl, Lean.Server.FileWorker.RefIdent.const, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Server.FileWorker.instInhabitedCancelToken,[Inhabited.mk, Lean.Server.FileWorker.CancelToken.mk, arbitrary]]
[Lean.Parser.Tactic.transport,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[Lean.Meta.getConstNoEx?,[Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.Meta.MetaM, Option, Lean.ConstantInfo, Lean.Environment.find?, Lean.Meta.getTheoremInfo, MonadReader.read, Lean.Meta.TransparencyMode.reducible, Lean.Meta.TransparencyMode.instances, Lean.Meta.Config.transparency, Lean.Meta.Context.config, Pure.pure, Option.some, Lean.isReducible, Lean.ConstantInfo.name, ite, Eq, Bool.true, and, BEq.beq, Lean.Meta.isGlobalInstance, Option.none]]
[Lean.Name.mkStr,[Lean.Name.str, mixHash, Hashable.hash]]
[UInt32.shiftRight,[UInt32.mk, HShiftRight.hShiftRight, UInt32.val, UInt32.modn, OfNat.ofNat]]
[Lean.Meta.Config.ctxApprox,[]]
[Lean.Parser.priorityParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Meta.Match.Pattern.ctor.inj,[And.intro]]
[List.forIn_cons,[rfl]]
[Lean.Elab.Term.LetRecView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.AbstractNestedProofs.Context.noConfusionType,[]]
[Lean.Lsp.Range.noConfusionType,[]]
[System.FilePath.mk.inj,[]]
[Lean.Declaration.noConfusionType,[]]
[let_eq,[]]
[Std.RBNode.all,[Unit.unit, Bool, Bool.true, and, PProd.fst, PProd.snd]]
[Lean.Meta.IndPredBelow.mkCtorType.addMotives,[Bind.bind, Array.mapM, Lean.Meta.MetaM, Prod, Lean.Name, Lean.BinderInfo, Lean.Expr, Pure.pure, Prod.mk, Lean.BinderInfo.implicit, Lean.Meta.instantiateForall, Lean.Meta.IndPredBelow.Variables.params, Lean.Meta.IndPredBelow.Context.motives, Lean.Meta.withLocalDecls, Lean.Meta.IndPredBelow.mkCtorType.modifyBinders, Lean.Meta.IndPredBelow.Variables.mk, HAppend.hAppend, Lean.Meta.IndPredBelow.Variables.target, Lean.Meta.IndPredBelow.Variables.indVal, Lean.Meta.IndPredBelow.Variables.args, Lean.Meta.IndPredBelow.Variables.innerType, OfNat.ofNat]]
[add_right_inj,[Iff.intro, add_left_cancel, congrArg, HAdd.hAdd]]
[Lean.EnvExtensionInterface.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[USize.instInhabitedFinSize,[Inhabited.mk, Fin.ofNat', OfNat.ofNat, USize.size_positive]]
[reprStr,[Std.Format.pretty, Repr.reprPrec, OfNat.ofNat, Std.Format.defWidth]]
[Nat.add_div_left,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HAdd.hAdd, Nat.succ, Nat.add_comm, Nat.add_div_right, rfl]]
[Lean.Parser.Tactic.Conv.reduce,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Meta.isClass?,[MonadExcept.tryCatch, Bind.bind, Unit.unit, Lean.Meta.MetaM, Option, Lean.Name, Pure.pure, Option.none, Option.some]]
[Lean.Expr.ReplaceLevelImpl.replaceUnsafe,[StateT.run', Lean.Expr.ReplaceLevelImpl.replaceUnsafeM, Lean.Expr.ReplaceLevelImpl.cacheSize, Lean.Expr.ReplaceLevelImpl.initCache]]
[Nat.case_strong_induction_on,[Nat.strong_induction_on, Unit.unit, Nat.lt_succ_of_le]]
[Lean.Elab.Term.MutualClosure.FixPoint.State.noConfusionType,[]]
[Lean.Parser.Term.instBinder,[Lean.Parser.ppGroup, Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.optIdent, Lean.Parser.termParser]]
[Lean.Elab.CompletionInfo.tactic.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Parser.mk.inj,[And.intro]]
[Lean.IR.CtorFieldInfo.usize.injEq,[Eq.propIntro, Eq.refl, Lean.IR.CtorFieldInfo.usize, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.instFromJsonArray,[Lean.FromJson.mk, Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Lean.Json.obj, Except, String, Array, Array.mapM, Lean.FromJson.fromJson?, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Lean.Server.FileWorker.parseParams,[Lean.Server.FileWorker.WorkerM, Lean.FromJson.fromJson?, Pure.pure, liftM, IO.throwServerError, HAppend.hAppend, ToString.toString, Lean.Json.compress]]
[decidableEq_of_decidableLe,[Decidable, Eq, dite, LE.le, Decidable.isTrue, le_antisymm, Decidable.isFalse, decidableEq_of_decidableLe.proof_1, decidableEq_of_decidableLe.proof_2]]
[instLEFin,[LE.mk, LE.le, Fin.val]]
[Lean.Parser.Term.bracketedBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.none, Bool.false, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.explicitBinder.parenthesizer, Lean.Parser.Term.strictImplicitBinder.parenthesizer, Lean.Parser.Term.implicitBinder.parenthesizer, Lean.Parser.Term.instBinder.parenthesizer]]
[Lean.mkIdentFrom,[Lean.Syntax.ident, Lean.SourceInfo.fromRef, String.toSubstring, ToString.toString, List.nil]]
[Lean.Parser.Command.structInstBinder,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.Command.declModifiers, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.Command.inferMod, Lean.Parser.Command.declSig]]
[Lean.Parser.Tactic.anyGoals,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Lean.Parser.Tactic.Conv.convLeft,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Elab.Tactic.ElimApp.State.mk.inj,[And.intro]]
[compareOfLessAndEq,[ite, LT.lt, Ordering.lt, Eq, Ordering.eq, Ordering.gt]]
[Lean.Lsp.TextDocumentSyncOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.mkCategoryParenthesizerAttribute,[Lean.KeyedDeclsAttribute.init, Lean.KeyedDeclsAttribute.Def.mk, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.MonadEnv.getEnv, Lean.Attribute.Builtin.getId, ite, Eq, Lean.Parser.isParserCategory, Bool.true, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, ToString.toString]]
[term!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.mkInaccessible,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Server.FileWorker.handleDocumentSymbol,[Bind.bind, Lean.Server.RequestM.readDoc, Lean.Server.RequestM.asTask, liftM, IO.AsyncList.updateFinishedPrefix, Lean.Server.FileWorker.EditableDocument.cmdSnaps, Lean.Server.RequestM, Lean.Lsp.DocumentSymbolResult, Option.none, Unit.unit, Option.some, Lean.Server.FileWorker.ElabTaskError.eof, MonadExcept.throw, Lean.Server.RequestError.fileChanged, Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.internalError, ToString.toString, Pure.pure, Lean.Server.FileWorker.handleDocumentSymbol.toDocumentSymbols, Lean.Server.FileWorker.handleDocumentSymbol.sectionLikeToDocumentSymbols]]
[Lean.Parser.Tactic.toExpr',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Std.RBNode.isRed,[Std.RBNode.leaf, Std.RBNode.node, Std.Rbcolor.black, Bool, Bool.true, Bool.false]]
[Lean.IR.FnBody.uset.inj,[And.intro]]
[Function.extend_apply,[Eq.mpr, congrFun, congrArg, Eq, Eq.trans, Function.extend_def, dite_congr, eq_true, exists_apply_eq_apply, Eq.refl, Classical.choose, Eq.mpr_prop, dif_pos, of_eq_true, True, congr_arg, Classical.choose_spec]]
[Std.Range.«term[_:_:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.LocalDecl.userName,[Lean.Name]]
[String.intercalate.go,[Unit.unit, String, PProd.fst, HAppend.hAppend]]
[Lean.Parser.categoryParser,[Lean.Parser.Parser.mk, Lean.Parser.categoryParserFn, Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.tokens, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Parser.ParserContext.savedPos?, Lean.Parser.ParserContext.forbiddenTk?]]
[Lean.PrettyPrinter.Parenthesizer.instCoeArrowParenthesizerParenthesizerParenthesizerAliasValue,[Coe.mk, Lean.Parser.AliasValue.unary]]
[List.card_le_card_cons,[Decidable.em, Mem.mem, of_eq_true, Eq.trans, congrArg, LE.le, List.card, List.card_cons_of_mem, eq_true, Nat.le_refl, Eq.symm, List.card_cons_of_not_mem, Not, eq_false, eq_true_of_decide, Eq.refl, Bool.true, Nat.le_succ]]
[Semiring.mul_zero,[]]
[EStateM.get,[EStateM.Result.ok]]
[IO.Error.otherError.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.otherError, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.instToJsonPlainGoalParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.PlainGoalParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position]]
[Lean.Meta.ByCasesSubgoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[eq_rec_heq,[eqRec_heq]]
[Function.update_same,[dif_pos, rfl]]
[Lean.MonadOptions.noConfusionType,[]]
[String.front,[String.get, OfNat.ofNat]]
[Lean.Parser.Tactic.clearAuxDecl,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[instSubsingleton.proof_1,[Subsingleton.intro, proofIrrel]]
[Lean.Parser.Tactic.dsimpResult,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.parser]]
[Nat.find_x.proof_3,[absurd, Nat.not_lt_zero]]
[Lean.Elab.Tactic.evalAllGoals,[Bind.bind, Lean.Elab.Tactic.getGoals, ForIn.forIn, liftM, Lean.Meta.isExprMVarAssigned, ite, Eq, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Elab.Tactic.setGoals, List.cons, List.nil, MonadExcept.tryCatch, Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.getUnsolvedGoals, MProd.mk, Lean.Elab.logException, MProd.fst, Array.toList]]
[coeDecidableEq,[inferInstanceAs, Decidable, Eq, Bool.true]]
[Lean.Expr.hasLooseBVarInExplicitDomain,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, or, and, Lean.BinderInfo.isExplicit, Lean.Expr.Data.binderInfo, Lean.Expr.hasLooseBVar, PProd.fst, PProd.snd, HAdd.hAdd, OfNat.ofNat]]
[Lean.Xml.Parser.EncName,[Bind.bind, Lean.Parsec.asciiLetter, Lean.Parsec.manyCharsCore, HOrElse.hOrElse, Lean.Parsec.digit, Lean.Parsec.pchar, Char.ofNat, Char.toString]]
[Lean.Elab.DefViewElabHeader.shortDeclName,[]]
[Lean.Compiler.SpecArgKind.other.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[List.exists_of_mem_bind,[Iff.mp, List.mem_bind]]
[Lean.Elab.Term.Do.ToCodeBlock.checkReassignable,[Bind.bind, MonadReader.read, ForIn.forIn, PUnit.unit, ite, Eq, Lean.NameSet.contains, Lean.Elab.Term.Do.ToCodeBlock.Context.mutableVars, Bool.true, Pure.pure, ForInStep.yield]]
[Lean.Elab.Term.StructInst.Source.explicit.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.StructInst.Source.explicit, Eq.symm, eq_of_heq, HEq.refl]]
[instMonadExceptOfExcept,[MonadExceptOf.mk, Except.error, Except.tryCatch]]
[eq_self_iff_true,[iff_true_intro, rfl]]
[Lean.Meta.CheckAssignment.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.let_tmp.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.letDecl.formatter, Lean.Parser.Term.optSemicolon.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Lean.Parser.Attr.recursor.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.numLit.formatter]]
[System.FilePath.isDir,[Bind.bind, EIO.toBaseIO, System.FilePath.metadata, BaseIO, Bool, Pure.pure, BEq.beq, IO.FS.Metadata.type, IO.FS.FileType.dir, Bool.false]]
[IO.Error.mkNoSuchThingFile,[Function.comp, IO.Error.noSuchThing, Option.some]]
[IO.Process.SpawnArgs.cwd,[]]
[Lean.Parser.Error.unexpected,[]]
[Function.right_inverse.left_inverse,[]]
[Lean.Elab.MacroStackElem.mk.inj,[And.intro]]
[Lean.DelayedMetavarAssignment.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.many.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.manyNoAntiquot.parenthesizer, Lean.Parser.withAntiquotSpliceAndSuffix.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol.parenthesizer]]
[IO.FS.Stream.writeLspResponse,[IO.FS.Stream.writeLspMessage, Lean.JsonRpc.Message.response, Lean.JsonRpc.Response.id, Lean.ToJson.toJson, Lean.JsonRpc.Response.result]]
[Tactic.Cache.mk,[liftM, IO.mkRef, Sum.inl]]
[Std.HashSetImp.reinsertAux.proof_1,[Subtype.property]]
[Lean.Meta.findCore,[ite, Eq, not, Lean.Meta.FindOptions.stage1, Bool.true, Bind.bind, Pure.pure, List.toArray, List.nil, Lean.MonadEnv.getEnv, Std.HashMap.foldM, Lean.SMap.map₁, Lean.Environment.constants, Lean.Meta.findCore.check]]
[Lean.Elab.Tactic.simpLocation,[Unit.unit, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.getFVarIds, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Meta.getNondepPropHyps, Bool.true, Lean.Elab.Tactic.simpLocation.go]]
[Lean.NameGenerator.namePrefix,[]]
[Lean.Expr.appFn!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Elab.Term.assignLevelMVar,[modifyThe, Lean.Meta.State, Lean.Meta.State.mk, Lean.MetavarContext.assignLevel, Lean.Meta.State.mctx, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed]]
[IO.Process.Output.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.isAuxRecursor,[or, Lean.TagDeclarationExtension.isTagged, Lean.auxRecExt, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Meta.NormNum.eval,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getLevel, Lean.Level.zero, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Meta.MetaM, Prod, Lean.Expr, Lean.Meta.synthInstance, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil, Option.none, Lean.Meta.NormNum.evalIsNat, Lean.mkApp2, Lean.mkApp4, Pure.pure, Prod.mk, Lean.mkApp3, Lean.mkApp7, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.Lsp.DocumentHighlightResult,[Array, Lean.Lsp.DocumentHighlight]]
[«term_×_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Lsp.DiagnosticWith.code?,[]]
[Lean.Elab.MacroExpansionInfo.lctx,[]]
[Lean.Lsp.InitializedParams.noConfusion,[noConfusionEnum, Lean.Lsp.InitializedParams.toCtorIdx]]
[Lean.PrettyPrinter.Delaborator.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MVarId.name,[]]
[Lean.InductiveVal.toConstantVal,[]]
[Lean.Elab.Term.StructInst.FieldLHS.modifyOp.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Json.parseTagged,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Except, String, Array, Lean.Json, Lean.Json.getStr?, Except.ok, List.toArray, List.nil, MonadExcept.throw, HAppend.hAppend, ToString.toString, Except.error, Lean.Json.getObjVal?, Unit.unit, Bind.bind, ForIn.forIn, Lean.Name.getString!, Pure.pure, PUnit.unit, ForInStep.yield, List.cons, Lean.Json.getArr?, Array.size]]
[Lean.Elab.Structural.RecArgInfo.indicesPos,[]]
[Std.PersistentArray.forM,[SeqRight.seqRight, Std.PersistentArray.forMAux, Std.PersistentArray.root, Array.forM, Std.PersistentArray.tail, OfNat.ofNat, Array.size]]
[Lean.IR.Arg.var.injEq,[Eq.propIntro, Eq.refl, Lean.IR.Arg.var, Eq.symm, eq_of_heq, HEq.refl]]
[Int.coe_nat_inj,[Int.ofNat.inj]]
[Lean.mkSimpleThunkType,[Lean.mkForall, Lean.Name.anonymous, Lean.BinderInfo.default, Lean.mkConst, Lean.Name.mkStr, List.nil]]
[Lean.Meta.AuxLemmas.mk.inj,[And.intro]]
[instDecidableEqSum.proof_5,[]]
[Lean.Elab.elabSetOption.setOption,[Bind.bind, Lean.MonadRef.getRef, liftM, IO.toEIO, Lean.Exception.error, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, IO.Error.toString, Lean.getOptionDecl, ite, Eq, Lean.DataValue.sameCtor, Lean.OptionDecl.defValue, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.IR.FnBody.setTag.inj,[And.intro]]
[Lean.Parser.Term.explicitUniv,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.checkStackTop, Lean.Parser.Term.isIdent, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, Lean.Parser.sepBy1, Lean.Parser.levelParser, Bool.false]]
[Lean.Declaration.defnDecl.inj,[]]
[Lean.Parser.Syntax.paren,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.syntaxParser]]
[UInt8.val,[]]
[Lean.Compiler.SpecializeAttributeKind.noConfusionType,[noConfusionTypeEnum, Lean.Compiler.SpecializeAttributeKind.toCtorIdx]]
[Lean.Elab.Deriving.BEq.mkMatch,[Bind.bind, Lean.Elab.Deriving.mkDiscrs, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.Elab.Deriving.BEq.mkMatch.mkElseAlt, Lean.Elab.Deriving.BEq.mkMatch.mkAlts]]
[inline,[]]
[Lean.ConstantInfo.opaqueInfo.inj,[]]
[Lean.KernelException.declHasFVars.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Int.instCommRingInt.proof_1,[]]
[Lean.LOption.some.inj,[]]
[Nat.gcd.proof_1,[WellFoundedRelation.wf, measure, id]]
[Lean.Parser.Command.extends.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.termParser.parenthesizer, Bool.false]]
[Std.PersistentHashMap.Entry.entry.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.PersistentHashMap.Entry.entry, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Error.instToStringError,[ToString.mk, Lean.Parser.Error.toString]]
[Lean.Compiler.NumScalarTypeInfo.size,[]]
[Array.mk.injEq,[Eq.propIntro, Eq.refl, Array.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.openHiding,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.ident, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.checkColGt]]
[Lean.Level.mvar.inj,[And.intro]]
[List.exists_of_erasep,[Exists, And, Not, Eq, List.nil, HAppend.hAppend, List.cons, List.erasep, Eq.refl, Classical.em, Exists.intro, And.intro, List.forall_mem_nil, of_eq_true, Eq.trans, congr, congrArg, List.nil_append, eq_self, List.erasep_cons_of_pos, eq_true, eq_true_of_decide, Bool.true, Eq.symm, False.elim, Eq.mp, Iff.mpr, List.forall_mem_cons, Eq.mpr, List.cons_append, rfl, List.erasep_cons_of_neg, eq_false]]
[Nat.pow_zero,[rfl]]
[«term_||_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Lsp.DiagnosticSeverity.hint.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Syntax.binary.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.syntaxParser.parenthesizer]]
[instLEUInt8,[LE.mk, UInt8.le]]
[EStateM.Result.ok.injEq,[Eq.propIntro, And.intro, Eq.refl, EStateM.Result.ok, Eq.symm, eq_of_heq, HEq.refl]]
[Pure.pure,[]]
[Lean.Parser.ParserCache.noConfusionType,[]]
[Lean.Elab.Term.Do.mkMatch,[Bind.bind, Array.mapM, Lean.Elab.Term.Do.extendUpdatedVars, Lean.Elab.Term.Do.Alt.rhs, Pure.pure, Lean.Elab.Term.Do.Alt.mk, Lean.Elab.Term.Do.Alt.ref, Lean.Elab.Term.Do.Alt.vars, Lean.Elab.Term.Do.Alt.patterns, Lean.Elab.Term.Do.CodeBlock.code, Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.match]]
[Lean.MetavarContext.LevelMVarToParam.State.cache,[]]
[Lean.Meta.Config.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Config.mk, Eq.symm, eq_of_heq, HEq.refl]]
[precLead,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[EStateM.Backtrackable.noConfusionType,[]]
[Lean.Parser.Term.pipeCompletion.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.minPrec, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.Meta.tryClear,[HOrElse.hOrElse, Lean.Meta.clear, Pure.pure]]
[Lean.IR.FnBody.hasFreeVar,[Lean.IR.HasIndex.visitFnBody, Lean.IR.VarId.idx]]
[Lean.IR.LocalContext.getJPBody,[Option.none, Option.some, Lean.IR.LocalContextEntry.param, Lean.IR.LocalContextEntry.localVar, Option, Lean.IR.FnBody, Std.RBMap.find?, Lean.IR.JoinPointId.idx]]
[Lean.Server.FileWorker.SemanticTokensContext.text,[]]
[Decidable.not_iff,[Iff, Not, of_eq_true, Eq.trans, congr, congrArg, eq_true, iff_true, iff_self, eq_false, iff_false, propext, not_not]]
[Lean.Options,[Lean.KVMap]]
[Lean.Elab.Term.Context.implicitLambda,[]]
[emptyWf,[WellFoundedRelation.mk, emptyRelation, emptyWf.proof_1]]
[Lean.RecursorVal.toConstantVal,[]]
[mul_left_cancel,[IsMulLeftCancel.mul_left_cancel]]
[Nat.lt.step.proof_1,[Nat.le_step]]
[Lean.Meta.SynthInstance.State.generatorStack,[]]
[Lean.Lsp.DiagnosticRelatedInformation.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.PreDefinition.value,[]]
[System.Platform.getNumBits.proof_1,[Or.inr, rfl]]
[Std.HashSetImp.insert.proof_1,[Subtype.property]]
[Lean.Elab.Term.CollectPatternVars.Context.newArgs,[]]
[Lean.IR.Borrow.BorrowInfCtx.mk.inj,[And.intro]]
[Lean.Expr.ReplaceLevelImpl.cache.proof_2,[lcProof]]
[PSigma.noConfusionType,[]]
[Lean.Parser.Term.optType,[Lean.Parser.optional, Lean.Parser.Term.typeSpec]]
[Lean.NameMap.instInhabitedNameMap,[Inhabited.mk, EmptyCollection.emptyCollection]]
[Lean.Parser.Term.termFor.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.Term.doForDecl.parenthesizer, Bool.false, Lean.Parser.Term.doSeq.parenthesizer]]
[Lean.MessageData.group.injEq,[Eq.propIntro, Eq.refl, Lean.MessageData.group, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.TokenCacheEntry.startPos,[]]
[Neg.noConfusionType,[]]
[Lean.Parser.Command.eraseAttr,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.rawIdent]]
[Lean.Elab.Tactic.getMainDecl,[Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Meta.getMVarDecl]]
[Lean.Server.Watchdog.OpenDocument.meta,[]]
[Lean.Parser.optional.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.optionalNoAntiquot.parenthesizer, Lean.Parser.withAntiquotSpliceAndSuffix.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol.parenthesizer]]
[Lean.KVMap.setString,[Lean.KVMap.insert, Lean.DataValue.ofString]]
[GT.gt,[LT.lt]]
[Std.PersistentArray.Stats.depth,[]]
[Lean.Elab.Term.Do.ToCodeBlock.Catch.noConfusionType,[]]
[List.toPersistentArray,[List.toPersistentArrayAux, Std.PersistentArray.mk]]
[Lean.Elab.Tactic.simpLocation.go,[Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Meta.simpGoal, Unit.unit, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.replaceMainGoal, List.nil, List.cons]]
[ByteArray.findIdx?,[ByteArray.findIdx?.loop]]
[instInhabitedUInt32,[Inhabited.mk, UInt32.ofNatCore, OfNat.ofNat, instInhabitedUInt32.proof_1]]
[List.mem_reverse,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, propext, List.mem_reverseAux, List.nil, Or, Mem.mem, List.mem_nil_iff, or_false, iff_self]]
[Lean.IR.addVarRename,[ite, Eq, BEq.beq, Bool.true, Std.RBMap.insert]]
[Lean.Meta.Match.MatchEqnsExtState.mk.inj,[]]
[Lean.Elab.mkInhabitedInstanceHandler,[Bind.bind, Array.allM, Lean.isInductive, OfNat.ofNat, Array.size, ite, Eq, Bool.true, Array.forM, Lean.getConstInfoInduct, orM, Bool.false, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Ordering.toCtorIdx,[OfNat.ofNat]]
[Lean.Compiler.preUIntBinFoldFns,[List.cons, Prod.mk, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Compiler.foldUIntAdd, Lean.Compiler.foldUIntMul, Lean.Compiler.foldUIntDiv, Lean.Compiler.foldUIntMod, Lean.Compiler.foldUIntSub, List.nil]]
[Quot.indepCoherent,[PSigma.eta, Quot.sound]]
[Std.PersistentArrayNode.isNode,[Bool, Bool.true, Bool.false]]
[Subtype.map_id,[funext, Eq, Subtype.map, id, rfl]]
[Lean.expandExternPattern,[Lean.expandExternPatternAux, String.length, String.mkIterator]]
[HEq.ndrec,[]]
[System.instDecidableEqFilePath,[Decidable, Eq, dite, Decidable.isTrue, rfl, Decidable.isFalse]]
[Lean.IR.CompilerState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.CompilerState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Delaborator.unexpandStructureInstance,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPStructureInstances, Bind.bind, Lean.MonadEnv.getEnv, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Pure.pure, Lean.Expr.isConstructorApp?, Option.none, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, guard, Eq, Lean.isStructure, Lean.ConstructorVal.induct, Bool.true, BEq.beq, Array.size, Lean.Syntax.getNumArgs, Lean.Syntax.getOp, OfNat.ofNat, ForIn.forIn, Lean.PrettyPrinter.Delaborator.SubExpr.nextExtraPos, Lean.PrettyPrinter.Delaborator.addFieldInfo, HAppend.hAppend, Array.getOp, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Lean.Syntax.atom, PUnit.unit, ForInStep.yield, Lean.PrettyPrinter.Delaborator.SubExpr.withType, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPStructureInstanceType, ite, Lean.PrettyPrinter.Delaborator.delab, Function.comp, Option.some, Array.isEmpty, Array.append, Unit.unit, Array, Array.empty, Array.push, Array.map, Alternative.failure]]
[Lean.Meta.Match.AltLHS.patterns,[]]
[Trans.trans,[]]
[Lean.Parser.ParserState.noConfusionType,[]]
[Except.toOption,[Option, Option.some, Option.none]]
[Lean.Meta.SynthInstance.MkTableKey.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.le.dest,[Exists, Eq, HAdd.hAdd, Exists.intro, OfNat.ofNat, rfl, Nat.succ, Eq.symm, Nat.add_comm, absurd, Nat.not_succ_le_zero]]
[Lean.Server.FileWorker.handleSemanticTokens,[Bind.bind, Lean.Server.RequestM.readDoc, liftM, IO.AsyncList.waitAll, Decidable.decide, LT.lt, Lean.Server.Snapshots.Snapshot.beginPos, Lean.Server.FileWorker.EditableDocument.cmdSnaps, Lean.Server.RequestM.mapTask, Lean.Server.RequestM, Lean.Lsp.SemanticTokens, StateT.run', ForIn.forIn, PUnit.unit, ite, LE.le, Lean.Server.Snapshots.Snapshot.endPos, Pure.pure, ForInStep.yield, MonadState.get, Lean.Lsp.SemanticTokens.mk, Lean.Server.FileWorker.SemanticTokensState.data, Lean.Server.FileWorker.SemanticTokensState.mk, List.toArray, List.nil, Lean.Lsp.Position.mk, OfNat.ofNat, Lean.Server.FileWorker.handleSemanticTokens.go, Lean.Server.FileWorker.handleSemanticTokens.highlightId, Lean.Server.FileWorker.handleSemanticTokens.highlightKeyword, Lean.Server.FileWorker.handleSemanticTokens.addToken]]
[Lean.Meta.mkListLit,[Bind.bind, Lean.Meta.getDecLevel, Unit.unit, List.cons, Lean.Meta.MetaM, Lean.Expr, Pure.pure, Lean.mkApp, PProd.fst]]
[Lean.Lsp.VersionedTextDocumentIdentifier.uri,[]]
[Lean.IR.Decl.params,[Array, Lean.IR.Param]]
[Substring.trimLeft,[Substring.dropWhile, Char.isWhitespace]]
[Lean.Lsp.instFromJsonTextDocumentEdit,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.VersionedTextDocumentIdentifier, Lean.Lsp.TextEditBatch, Pure.pure, Lean.Lsp.TextDocumentEdit.mk]]
[IO.Error.mkResourceBusy,[IO.Error.resourceBusy]]
[Lean.Export.Alloc.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Tactic.evalRefine',[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Tactic.refineCore, Lean.Elab.throwUnsupportedSyntax]]
[Classical.exists_true_of_nonempty,[Exists, True, Exists.intro, trivial]]
[Lean.Meta.DefaultInstances.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.DefaultInstances.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Function.right_inverse_surj_inv,[Function.surj_inv_eq]]
[Lean.Meta.getTransparency,[Bind.bind, Lean.Meta.getConfig, Pure.pure, Lean.Meta.Config.transparency]]
[Lean.IR.mkSSet,[Lean.IR.FnBody.sset]]
[Lean.Meta.DiscrTree.noConfusionType,[]]
[Lean.Parser.Term.doIfLetPure,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser]]
[Lean.Meta.SynthInstance.MkTableKey.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SynthInstance.MkTableKey.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.doSeq.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.doSeqBracketed.formatter, Lean.Parser.Term.doSeqIndent.formatter]]
[List.erase_cons_head,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.erase_cons, ite_congr, eq_self, Eq.refl, List.cons, List.erase, ite_true]]
[String.Range.stop,[]]
[ofNat_zero,[rfl]]
[Lean.Parser.withPosition,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.Parser.fn, Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.prec, Lean.Parser.ParserContext.tokens, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Option.some, Lean.Parser.ParserState.pos, Lean.Parser.ParserContext.forbiddenTk?]]
[LinearOrder.noConfusionType,[]]
[Lean.instReprRat,[Repr.mk, ite, Eq, BEq.beq, Lean.Rat.den, OfNat.ofNat, Bool.true, repr, Lean.Rat.num, Std.Format.text, HAppend.hAppend, ToString.toString]]
[Array.anyMUnsafe.any,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bool.false, Bind.bind, Array.uget, lcProof, Array.anyMUnsafe.any, HAdd.hAdd, OfNat.ofNat]]
[Lean.IR.Expr.lit.inj,[]]
[Mathlib.Tactic.Conv.convRunConv_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Lean.Parser.sepBy1,[Lean.Parser.sepBy1NoAntiquot, Lean.Parser.sepByElemParser]]
[Lean.Parser.checkLhsPrecFn,[ite, GE.ge, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.mkUnexpectedError, List.nil]]
[Tactic.Ring.HornerExpr.below,[PUnit, PProd]]
[ByteSliceT.mk.inj,[And.intro]]
[Lean.PrettyPrinter.Formatter.sepByNoAntiquot.formatter,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.PrettyPrinter.Formatter.visitArgs, List.forM, List.reverse, List.range, Array.size, Lean.Syntax.getArgs, ite, Eq, BEq.beq, HMod.hMod, OfNat.ofNat, Bool.true]]
[Function.apply_update,[Decidable.em, Eq, of_eq_true, Eq.trans, congr, congrArg, Function.update_same, eq_self, Eq.symm, Function.update_noteq, ne_eq, Not, eq_false, eq_true_of_decide, Eq.refl, Bool.true]]
[Lean.Parser.Term.Command.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.commandParser.parenthesizer]]
[HMul.noConfusionType,[]]
[not_lt_of_ge,[not_le_of_gt]]
[Lean.Meta.reduceBinNatOp,[Lean.Meta.withNatValue, Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.Elab.Term.NamedArg.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[AddMonoid.noConfusionType,[]]
[dite_congr,[Decidable.em, Eq.mpr, Eq.refl, Eq, dite, dif_pos, Eq.symm, dif_neg]]
[Lean.Parser.Term.doIf,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.withPosition, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.doIfCond, Lean.Parser.Term.doSeq, Lean.Parser.many, Lean.Parser.checkColGe, Lean.Parser.group, Lean.Parser.Term.elseIf, Lean.Parser.optional]]
[Lean.Expr.sort.inj,[And.intro]]
[Lean.PrettyPrinter.Delaborator.unresolveNameGlobal.unresolveNameCore,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, Unit.unit, Lean.PrettyPrinter.Delaborator.DelabM, ForInStep, MProd, Option, Lean.Name, List, Pure.pure, ForInStep.done, Option.some, PUnit.unit, MProd.fst]]
[Lean.Meta.isMatchValue,[or, Lean.Expr.isNatLit, Lean.Expr.isCharLit, Lean.Expr.isStringLit, Lean.Meta.isFinPatLit, Lean.Meta.isUIntPatLit]]
[Lean.Elab.Tactic.evalChoice,[Lean.Elab.Tactic.evalChoiceAux, Lean.Syntax.getArgs, OfNat.ofNat]]
[Zero.zero,[]]
[gt_trans,[lt_trans]]
[Lean.ScopedEnvExtension.instInhabitedScopedEntries,[Inhabited.mk, Lean.ScopedEnvExtension.ScopedEntries.mk, arbitrary]]
[Lean.Meta.SynthInstance.MkTableKey.State.nextIdx,[]]
[Lean.Parser.AliasValue.noConfusionType,[]]
[UInt16.instSemigroupUInt16,[Semigroup.mk, UInt16.instSemigroupUInt16.proof_1]]
[exists_eq_right,[Iff.trans, exists_congr, And.comm, exists_eq_left]]
[Lean.Elab.Term.elabSubst,[Bind.bind, Lean.Elab.Term.tryPostponeIfHasMVars, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Lean.Elab.Term.elabTerm, Option.none, liftM, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Lean.Meta.matchEq?, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Meta.kabstract, Lean.Occurrences.all, Lean.Expr.hasLooseBVars, Pure.pure, PUnit.unit, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Elab.Level.State.mk.inj,[And.intro]]
[Lean.Server.FileWorker.WorkerContext.mk.inj,[And.intro]]
[Lean.Meta.MetaM.run',[Functor.map, Prod.fst, Lean.Meta.MetaM.run]]
[Lean.MetavarContext.setMVarKind,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Std.PersistentHashMap.insert, Lean.MetavarContext.decls, Lean.MetavarDecl.mk, Lean.MetavarDecl.userName, Lean.MetavarDecl.lctx, Lean.MetavarDecl.type, Lean.MetavarDecl.depth, Lean.MetavarDecl.localInstances, Lean.MetavarDecl.numScopeArgs, Lean.MetavarDecl.index, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment]]
[Lean.Lsp.instToJsonMarkupKind,[Lean.ToJson.mk, Unit.unit, Lean.Json, Lean.Json.str]]
[Lean.Core.CoreM,[ReaderT, Lean.Core.Context, StateRefT', IO.RealWorld, Lean.Core.State, EIO, Lean.Exception]]
[Lean.instInhabitedDeclaration,[Inhabited.mk, Lean.Declaration.axiomDecl, arbitrary]]
[Lean.Meta.Simp.Result.mk.inj,[And.intro]]
[Lean.IR.Expr.fap.inj,[And.intro]]
[Lean.Parser.Tactic.squeezeSimpa,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser]]
[Lean.Elab.Term.Do.ToTerm.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.ToTerm.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.SynthInstance.findEntry?,[Bind.bind, MonadState.get, Pure.pure, Std.HashMap.find?, Lean.Meta.SynthInstance.State.tableEntries]]
[Lean.Export.Entry.level.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MetavarDecl.noConfusionType,[]]
[Lean.Meta.ApplyNewGoals.nonDependentOnly.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.IR.getDecl,[Bind.bind, Lean.IR.findDecl, Option.none, Lean.IR.CompilerM, Lean.IR.Decl, Pure.pure, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Lean.Elab.Tactic.orElse,[MonadExcept.tryCatch, Unit.unit]]
[Function.right_inverse_iff_comp,[Iff.intro, Function.right_inverse.comp_eq_id, congr_fun]]
[MonadState.get,[]]
[Lean.PrettyPrinter.mkCombinatorFormatterAttribute,[Lean.ParserCompiler.registerCombinatorAttribute, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Elab.Term.StructInst.FieldVal.toSyntax,[Lean.Elab.Term.StructInst.FieldVal.nested, Lean.Elab.Term.StructInst.FieldVal.default, Lean.Syntax, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.StructureInfo.lt,[Lean.Name.quickLt, Lean.StructureInfo.structName]]
[Mathlib.Tactic.Lint.constToSimpDeclMap,[Id.run, Bind.bind, ForIn.forIn, Option.none, Id, ForInStep, Std.HashMap, Lean.Name, Lean.Meta.SimpLemma.name?, Lean.Expr.constName?, Lean.Expr.getAppFn, Lean.Meta.SimpLemma.proof, Pure.pure, PUnit.unit, ForInStep.yield]]
[Lean.InductiveType.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.InductiveType.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.letRecDecl,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.docComment, Lean.Parser.Term.attributes, Lean.Parser.Term.letDecl]]
[Lean.instInhabitedLBool,[Inhabited.mk, Lean.LBool.false]]
[Nat.zero_lt_one,[Nat.zero_lt_succ, OfNat.ofNat]]
[Lean.Meta.generalizeTargetsEq,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.forallTelescopeReducing, ite, Eq, BEq.beq, Array.size, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.MetaM, Lean.MVarId, Lean.Meta.getMVarTag, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.assignExprMVar, Lean.mkAppN, Lean.Expr.mvarId!]]
[forall_const,[Iff.intro, Nonempty.elim]]
[Lean.Parser.Tactic.set_option.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.Command.optionValue.parenthesizer, Lean.Parser.Tactic.tacticSeq.parenthesizer]]
[IO.Process.SpawnArgs.noConfusionType,[]]
[Lean.Meta.ppGoal.ppVars,[ite, Eq, Std.RBTree.contains, Lean.LocalDecl.fvarId, Bool.true, Bind.bind, Lean.Meta.ppGoal.pushPending, Lean.Meta.instantiateMVars, Lean.LocalDecl.type, Lean.Meta.ppExpr, Pure.pure, Prod.mk, List.nil, Option.none, Lean.Meta.MetaM, Prod, List, Lean.Name, Option, Lean.Expr, Std.Format, or, BEq.beq, Option.some, List.cons]]
[Lean.Parser.Term.structInstArrayRef.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter]]
[LawfulApplicative.toLawfulFunctor,[]]
[Lean.Parser.Command.resolve_name,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident]]
[Lean.Elab.InfoTree.node.inj,[And.intro]]
[Lean.Meta.UnificationConstraint.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.UnificationConstraint.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.WF.mkUnaryArg,[OfNat.ofNat, Lean.Elab.WF.mkUnaryArg.go]]
[Lean.Meta.SynthInstance.Answer.resultType,[]]
[Lean.Parser.ParserState.setPos,[Lean.Parser.ParserState.mk, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.cache, Lean.Parser.ParserState.errorMsg]]
[Lean.Compiler.getBoolLit,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Name.anonymous, Lean.Name.str, dite, Eq, Eq.symm, Lean.Name.num, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Bool, Option.some, Bool.true, Bool.false, Option.none]]
[Int.add_assoc,[Int.ofNat, Int.negSucc, Eq, HAdd.hAdd, Int.add_assoc_aux1, Eq.mpr, Eq.refl, Int.add_comm, Eq.symm, rfl, Int.add_assoc_aux2, of_eq_true, Eq.trans, congr, congrArg, congrFun, Int.negSucc_ofNat_add_negSucc_ofNat, Nat.succ, Nat.add_comm, Nat.add_succ, Nat.add_left_comm, eq_self]]
[Lean.Widget.instInhabitedInteractiveTermGoal,[Inhabited.mk, Lean.Widget.InteractiveTermGoal.mk, arbitrary]]
[gt_irrefl,[lt_irrefl]]
[FloatArray.foldlM.proof_1,[Nat.le_refl, FloatArray.size]]
[Lean.ScopedEnvExtension.ScopedEntries.insert,[Unit.unit, Lean.ScopedEnvExtension.ScopedEntries, Lean.SMap.find?, Lean.ScopedEnvExtension.ScopedEntries.map, Lean.ScopedEnvExtension.ScopedEntries.mk, Lean.SMap.insert, Std.PersistentArray.push, Std.PersistentArray.mk]]
[Lean.Elab.Tactic.Conv.evalConv,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Elab.Term.getFVarLocalDecl!,[Bind.bind, Lean.MonadLCtx.getLCtx, Unit.unit, Lean.Elab.Term.TermElabM, Lean.LocalDecl, Lean.LocalContext.find?, Lean.Expr.fvarId!, Pure.pure, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Elab.Term.elabLetDeclAux,[Bind.bind, Lean.Elab.Term.elabBinders, Lean.Elab.Term.elabType, Lean.Elab.Term.registerCustomErrorIfMVar, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, ite, Eq, Bool.true, liftM, Lean.Meta.mkForallFVars, Bool.false, Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.natural, Lean.Name.anonymous, Pure.pure, Prod.mk, Array.size, Lean.Elab.Term.elabTermEnsuringType, Option.none, Lean.Meta.mkLambdaFVars, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Syntax.getId, PUnit.unit]]
[Lean.BinderInfo.auxDecl.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.PrettyPrinter.ppExprLegacy,[Functor.map, Prod.fst, Lean.Core.CoreM.toIO, Lean.Meta.MetaM.run', Lean.PrettyPrinter.ppExpr, Lean.Name.anonymous, List.nil, Lean.Meta.Context.mk, Lean.Meta.State.mk, Lean.Core.Context.mk, Lean.Core.State.mk]]
[Lean.Elab.instInhabitedInfo,[Inhabited.mk, Lean.Elab.Info.ofTacticInfo, arbitrary]]
[UInt32.instInhabitedFinSize,[Inhabited.mk, Fin.ofNat', OfNat.ofNat, UInt32.size_positive]]
[Lean.Elab.Info.ofCompletionInfo.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Info.ofCompletionInfo, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.mkHEqTrans,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Option.none, Option.some, Prod.mk, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.heq?, Lean.Meta.getLevel, Lean.mkApp8, Lean.mkConst, List.cons, List.nil, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr]]
[List.subset_append_of_subset_right,[List.subset.trans, List.subset_append_right]]
[Lean.Parser.topLevelCommandParserFn,[Lean.Parser.Parser.fn, Lean.Parser.commandParser, OfNat.ofNat]]
[Lean.Server.MonadRpcSession.noConfusionType,[]]
[Lean.IR.formatFnBodyHead,[Unit.unit, Std.Format, HAppend.hAppend, Std.Format.text, Std.ToFormat.format, Lean.IR.formatParams, ite, Eq, bne, OfNat.ofNat, Bool.true, Std.Format.sbracket, Lean.IR.formatArray]]
[Lean.Meta.Match.Pattern.ctor.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.Pattern.ctor, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.LeanFileProgressParams.processing,[]]
[Lean.Elab.Command.InductiveView.derivingClasses,[]]
[Lean.Macro.Context.currRecDepth,[]]
[Lean.Parser.Term.optType.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.Parser.Term.typeSpec.parenthesizer]]
[Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.mkApp3,[Lean.mkApp, Lean.mkAppB]]
[Std.PersistentHashSet.size,[Std.PersistentHashMap.size, Std.PersistentHashSet.set]]
[Lean.Level.noConfusionType,[]]
[Attr.simps?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.const]]
[Lean.Meta.DefaultInstances.noConfusionType,[]]
[UInt16.toUInt64,[Nat.toUInt64, UInt16.toNat]]
[Nat.mul_left_comm,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Eq.symm, Nat.mul_assoc, Nat.mul_comm, rfl]]
[Lean.IR.Decl.getInfo,[Lean.IR.Decl.extern, Lean.IR.DeclInfo, Lean.IR.DeclInfo.mk]]
[Fin.mod_lt,[LT.lt, HMod.hMod]]
[UInt32.zero_def,[rfl]]
[Mathlib.ExtendedBinder.«binderTerm≥_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Term.leading_parser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.optExprPrecedence.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Lean.Meta.Simp.instInhabitedStep,[Inhabited.mk, Lean.Meta.Simp.Step.visit, arbitrary]]
[Lean.TagAttribute.attr,[]]
[Lean.Meta.SynthInstance.consume,[Unit.unit, Lean.Meta.SynthInstance.SynthM, Unit, Lean.Meta.SynthInstance.ConsumerNode.subgoals, Lean.Meta.SynthInstance.addAnswer, Bind.bind, Lean.Meta.SynthInstance.mkTableKeyFor, Lean.Meta.SynthInstance.ConsumerNode.mctx, Lean.Meta.SynthInstance.findEntry?, liftM, Lean.Meta.withMCtx, Lean.Meta.inferType, Lean.Meta.instantiateMVars, ite, Eq, not, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, or, Lean.Expr.hasLooseBVar, OfNat.ofNat, PProd.fst, PProd.snd, Bool.false, Bool.true, Pure.pure, Option.none, Lean.Meta.forallTelescope, Array.foldrM, Lean.Expr.containsFVar, Lean.Expr.fvarId!, List.cons, List.anyM, List.nil, Array.size, Lean.Meta.mkForallFVars, Lean.Meta.withLocalDeclD, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.mkLambdaFVars, Lean.mkAppN, List.toArray, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, PUnit.unit, Lean.Meta.SynthInstance.newSubgoal, Lean.Meta.SynthInstance.mkTableKey, Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.natural, Lean.MonadMCtx.getMCtx, Prod.mk, Lean.Meta.SynthInstance.Waiter.consumerNode, Lean.Meta.SynthInstance.ConsumerNode.mk, Lean.Meta.SynthInstance.ConsumerNode.mvar, Lean.Meta.SynthInstance.ConsumerNode.key, Lean.Meta.SynthInstance.ConsumerNode.size, Array.mapM, Lean.Meta.AbstractMVarsResult.expr, Lean.Meta.SynthInstance.Answer.result, Lean.Meta.SynthInstance.Answer.mk, Lean.Meta.AbstractMVarsResult.mk, Lean.Meta.AbstractMVarsResult.paramNames, Lean.Meta.AbstractMVarsResult.numMVars, Lean.Meta.SynthInstance.Answer.size, Lean.Meta.SynthInstance.TableEntry.answers, modify, Lean.Meta.SynthInstance.State.mk, Lean.Meta.SynthInstance.State.result?, Lean.Meta.SynthInstance.State.generatorStack, Array.foldl, Array.push, Lean.Meta.SynthInstance.State.resumeStack, Std.HashMap.insert, Lean.Meta.SynthInstance.State.tableEntries, Lean.Meta.SynthInstance.TableEntry.mk, Lean.Meta.SynthInstance.TableEntry.waiters]]
[Array.size_set,[List.length_set, Array.data, Fin.val]]
[Lean.Parser.Tactic.ring1!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Meta.AbstractMVars.State.paramNames,[]]
[Lean.Elab.DerivingClassView.className,[]]
[Lean.Elab.Term.liftLevelM,[Bind.bind, MonadReader.read, Lean.MonadMCtx.getMCtx, Lean.MonadNameGenerator.getNGen, Lean.MonadOptions.getOptions, Lean.MonadRef.getRef, Lean.Elab.Term.getLevelNames, Lean.Elab.Term.TermElabM, EStateM.run, Lean.Elab.Level.State.mk, liftM, Lean.Meta.setMCtx, Lean.Elab.Level.State.mctx, Lean.MonadNameGenerator.setNGen, Lean.Elab.Level.State.ngen, Lean.Elab.Term.setLevelNames, Lean.Elab.Level.State.levelNames, Pure.pure, MonadExcept.throw]]
[Lean.Elab.Term.StructInst.DefaultFields.mkDefaultValue?,[Lean.withRef, Lean.Elab.Term.StructInst.Struct.ref, Bind.bind, liftM, Lean.Meta.mkFreshLevelMVarsFor, Lean.Elab.Term.StructInst.DefaultFields.mkDefaultValueAux?, Lean.ConstantInfo.instantiateValueLevelParams]]
[Array.forIn.loop.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self]]
[Lean.Elab.Term.Do.getDoLetArrowVars,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, List.toArray, List.cons, Lean.Elab.Term.Do.getDoIdDeclVar, List.nil, Lean.Elab.Term.Do.getDoPatDeclVars, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.Parser.unicodeSymbolInfo,[Lean.Parser.ParserInfo.mk, List.cons, Lean.Parser.FirstTokens.tokens, List.nil]]
[Fin.mk.injEq,[Eq.propIntro, Eq.refl, Fin.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.AbstractNestedProofs.State.nextIdx,[]]
[Array.mapSepElemsM,[OfNat.ofNat, List.toArray, List.nil]]
[proof_irrel_heq,[]]
[withPtrEqDecEq,[Decidable, Eq, Eq.refl, Decidable.isTrue, withPtrEqDecEq.proof_2, Decidable.isFalse, withPtrEqDecEq.proof_3]]
[Lean.Parser.Tactic.Conv.lhs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Lsp.instBEqPosition,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Function.has_uncurry_base,[Function.has_uncurry.mk, id]]
[Lean.Elab.Term.LetIdDeclView.value,[]]
[Lean.MetavarContext.MkBinding.State.mctx,[]]
[Function.has_uncurry.uncurry,[]]
[Lean.MessageData.ofSyntax.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.macroArg.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.syntaxParser.parenthesizer, Lean.Parser.argPrec]]
[IO.FS.Metadata.modified,[]]
[Lean.Parser.Command.namedPrio.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.priorityParser.parenthesizer]]
[instInhabitedNonScalar,[Inhabited.mk, NonScalar.mk, arbitrary]]
[Lean.Lsp.instFileSourceTextDocumentIdentifier,[Lean.Lsp.FileSource.mk, Lean.Lsp.TextDocumentIdentifier.uri]]
[String.length_repeat,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.length_repeat, eq_self]]
[List.filterMapM.loop,[List, Pure.pure, Bind.bind, Unit.unit, PProd.fst, List.cons]]
[Lean.PrettyPrinter.Parenthesizer.error.parenthesizer,[Pure.pure, Unit.unit]]
[CommRing.noConfusionType,[]]
[String.Iterator.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instDecidableEqUInt32,[UInt32.decEq]]
[Lean.PrettyPrinter.Delaborator.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[as_true,[ite, True, False]]
[Equiv.instInhabitedEquiv,[Inhabited.mk, Equiv.refl]]
[Lean.Elab.WF.TerminationHint.ensureIsEmpty,[Lean.Elab.WF.TerminationHint.none, Lean.MacroM, Unit, Lean.Macro.throwErrorAt, Lean.Elab.WF.TerminationHintValue.ref, Std.RBMap.forM, Pure.pure, Unit.unit]]
[Lean.Expr.app1?,[ite, Eq, Lean.Expr.isAppOfArity, OfNat.ofNat, Bool.true, Option.some, Lean.Expr.appArg!, Option.none]]
[Lean.Parser.Tactic.done,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Std.PHashMap,[Std.PersistentHashMap]]
[Lean.Meta.ElimInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.NormNum.instLawfulOne,[Lean.Meta.NormNum.instLawfulOne.proof_1]]
[Lean.Elab.mkElabAttribute,[Lean.KeyedDeclsAttribute.init, Lean.KeyedDeclsAttribute.Def.mk, HAppend.hAppend, Lean.Elab.syntaxNodeKindOfAttrParam, ite, Eq, Bool.true, Bind.bind, Lean.MonadEnv.getEnv, liftM, Lean.findDocString?, Option.none, Lean.AttrM, Unit, Lean.declareBuiltin, Lean.Name.mkStr, Lean.Name.anonymous, Lean.mkAppN, Lean.mkConst, List.nil, List.toArray, List.cons, Lean.ToExpr.toExpr, Pure.pure, PUnit.unit]]
[Lean.Meta.Match.Pattern.as.inj,[And.intro]]
[IO.Error.unsupportedOperation.inj,[And.intro]]
[List.or,[List.any, id]]
[Lean.instInhabitedRecursorVal,[Inhabited.mk, Lean.RecursorVal.mk, arbitrary]]
[List.erase,[List, List.nil, Unit.unit, BEq.beq, List.cons, PProd.fst]]
[Lean.Meta.SynthInstance.mkTableKey,[StateT.run', Lean.Meta.SynthInstance.MkTableKey.normExpr, Lean.Meta.SynthInstance.MkTableKey.State.mk]]
[Lean.Expr.const.inj,[And.intro]]
[Lean.Widget.TaggedText.tag.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.InitializeResult.mk.inj,[And.intro]]
[Lean.Lsp.instToJsonReferenceParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.ReferenceParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position, Lean.Lsp.ReferenceParams.context]]
[ByteSliceT.noConfusionType,[]]
[Lean.ScopedEnvExtension.Descr.mkInitial,[]]
[instToStringExcept,[ToString.mk, String, HAppend.hAppend, ToString.toString]]
[Lean.Parser.Tactic.Conv.applyCongr,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Lean.Elab.runFrontend,[Bind.bind, Lean.Parser.parseHeader, IO, Prod, Lean.Environment, Bool, Lean.Elab.processHeader, Lean.Elab.IO.processCommands, Lean.Elab.Command.mkState, ForIn.forIn, PUnit.unit, Lean.Message.toString, Lean.Elab.getPrintMessageEndPos, IO.print, Pure.pure, ForInStep.yield, Prod.mk, Lean.Elab.Command.State.env, Lean.Elab.Frontend.State.commandState, not, Lean.MessageLog.hasErrors, Lean.Elab.Command.State.messages]]
[Lean.Rat.neg,[Neg.neg, Lean.Rat.num, Lean.Rat.den]]
[Lean.Elab.Tactic.Tactic,[Lean.Elab.Tactic.TacticM, Unit]]
[Lean.Parser.Tactic.haveField,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.IR.ExplicitBoxing.castArgIfNeeded,[Lean.IR.Arg.irrelevant, Lean.IR.ExplicitBoxing.M, Lean.IR.FnBody, Lean.IR.ExplicitBoxing.castVarIfNeeded, Lean.IR.Arg.var]]
[Lean.Elab.registerBuiltinDerivingHandler,[Lean.Elab.registerBuiltinDerivingHandlerWithArgs]]
[Std.PersistentHashMap.mk.inj,[And.intro]]
[Lean.Compiler.atMostOnce.AtMostOnceData.mk.inj,[And.intro]]
[Decidable.ne_or_eq,[dec_em', Eq]]
[Lean.Parser.Term.dbgTrace,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, Lean.Parser.symbol, HOrElse.hOrElse, Lean.Parser.interpolatedStr, Lean.Parser.termParser, OfNat.ofNat, Lean.Parser.Term.optSemicolon]]
[Lean.Meta.SimpAll.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SimpAll.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.NamePart.num.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.DocumentSymbol.below,[PProd, PUnit]]
[Lean.Elab.expandMacroImpl?,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, MonadExcept.tryCatch, Lean.MonadQuotation.withFreshMacroScope, Lean.KeyedDeclsAttribute.AttributeEntry.value, Pure.pure, DoResultPR.return, Prod.mk, Lean.KeyedDeclsAttribute.OLeanEntry.declName, Lean.KeyedDeclsAttribute.AttributeEntry.toOLeanEntry, Except.ok, Lean.Macro.Exception.error, Unit.unit, Lean.MacroM, DoResultPR, Unit, Prod, Lean.Name, Except, Lean.Macro.Exception, Lean.Syntax, PUnit, DoResultPR.pure, Except.error, ForInStep, MProd, Option, ForInStep.yield, ForInStep.done, Option.some, MProd.fst]]
[instDivUSize,[Div.mk, USize.div]]
[Lean.Elab.Tactic.withCaseRef,[Lean.withRef, Lean.mkNullNode, List.toArray, List.cons, List.nil]]
[Function.injective.ne_iff',[Function.injective.ne_iff]]
[IO.AsyncList.unfoldAsync,[Bind.bind, Functor.map, Task.map, Except, Except.error, Coe.coe, Task.Priority.default, liftM, IO.asTask, Pure.pure, IO.AsyncList.asyncTail, IO.AsyncList.unfoldAsync.step]]
[Lean.Server.Watchdog.FileWorker.mk.inj,[And.intro]]
[UInt64.instNumericUInt64,[Numeric.mk, UInt64.mk, Numeric.ofNat]]
[ByteArray.get,[UInt8, Array.get]]
[Std.AssocList.forIn,[Std.AssocList.forIn.loop]]
[Lean.Meta.Match.AltLHS.fvarDecls,[]]
[Lean.Elab.Tactic.ElimApp.Context.elimInfo,[]]
[WellFounded.apply.proof_1,[]]
[Lean.Parser.Tactic.left,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.InductiveVal.isUnsafe,[]]
[Lean.Elab.Tactic.elabCasesTargets,[Lean.Elab.Tactic.withMainContext, Bind.bind, Array.mapM, Lean.Elab.Tactic.elabTerm, Lean.Syntax.getOp, OfNat.ofNat, Option.none, Bool.false, Pure.pure, Lean.Meta.GeneralizeArg.mk, ite, Eq, Array.all, and, Lean.Expr.isFVar, Lean.Meta.GeneralizeArg.expr, Option.isNone, Lean.Meta.GeneralizeArg.hName?, Array.size, Bool.true, Array.map, Lean.Elab.Tactic.liftMetaTacticAux, Lean.Meta.generalize, Lean.Meta.MetaM, Prod, Array, Lean.Expr, List, Lean.MVarId, Prod.mk, Lean.mkFVar, Subarray.toArray, Array.toSubarray, List.cons, List.nil]]
[Std.Format.instInhabitedSpaceResult,[Inhabited.mk, arbitrary]]
[Lean.removeRoot,[Lean.Name.replacePrefix, Lean.rootNamespace, Lean.Name.anonymous]]
[Lean.SimpleScopedEnvExtension.Descr.name,[]]
[Lean.PrettyPrinter.Parenthesizer.charLitNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken]]
[Lean.OpaqueVal.noConfusionType,[]]
[Lean.IR.IsLive.M,[StateM, Lean.IR.LocalContext]]
[Lean.MetavarContext.occursCheck,[ite, Eq, not, Lean.Expr.hasExprMVar, Bool.true, Bool, EStateM.run, EmptyCollection.emptyCollection, Bool.false, Lean.MetavarContext.occursCheck.visitMVar, Lean.MetavarContext.occursCheck.visit]]
[Lean.Expr.lit.inj,[And.intro]]
[Lean.Elab.Command.StructFieldInfo.mk.inj,[And.intro]]
[Lean.Meta.mkNoConfusion,[Bind.bind, Lean.Meta.inferType, Lean.Meta.whnf, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.eq?, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Name.mkStr, Lean.Name.anonymous, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr, Lean.matchConstInduct, Lean.Expr.getAppFn, Lean.Meta.getLevel, Pure.pure, Lean.mkAppN, Lean.mkConst, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, List.cons, Lean.Expr.getAppArgs, List.toArray, List.nil]]
[Lean.Level.instQuoteLevel,[Lean.Quote.mk, Lean.Level.quote, OfNat.ofNat]]
[String.next,[HAdd.hAdd, String.csize]]
[«stx_*»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Tactic.Ring.horner_add_const,[of_eq_true, Eq.trans, congr, congrArg, Eq, add_assoc, HMul.hMul, HPow.hPow, HAdd.hAdd, Eq.symm, eq_self]]
[Lean.Parser.Command.optDeclSig.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.simpleBinderWithoutType.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Bool.false, Lean.Parser.Term.optType.parenthesizer]]
[Lean.Parsec.asciiLetter,[Lean.Parsec.attempt, Bind.bind, Lean.Parsec.anyChar, ite, Or, And, LE.le, Char.ofNat, Pure.pure, Lean.Parsec.fail, ToString.toString]]
[Lean.Meta.getFVarSetToGeneralize,[Bind.bind, Lean.MonadLCtx.getLCtx, ForIn.forIn, MProd.mk, ite, Eq, Std.RBTree.contains, Lean.LocalDecl.fvarId, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, or, Lean.LocalDecl.isAuxDecl, Lean.BinderInfo.isInstImplicit, Lean.LocalDecl.binderInfo, Lean.MonadMCtx.getMCtx, Lean.MetavarContext.findLocalDeclDependsOn, Lean.Meta.MetaM, Lean.FVarIdSet]]
[ByteArray.copySlice,[ByteArray.mk, HAppend.hAppend, Array.extract, ByteArray.data, OfNat.ofNat, HAdd.hAdd, Array.size]]
[Lean.IR.EmitC.emit,[modify, HAppend.hAppend, ToString.toString]]
[Lean.Lsp.Command.arguments?,[]]
[Nat.gcd_dvd_gcd_of_dvd_left,[Nat.dvd_gcd, Nat.dvd_trans, Nat.gcd_dvd_left, Nat.gcd_dvd_right]]
[Lean.Elab.Frontend.State.commands,[]]
[Lean.Meta.TransparencyMode.default.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Term.LValResolution.getOp.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LValResolution.getOp, Eq.symm, eq_of_heq, HEq.refl]]
[Mathlib.ExtendedBinder.binderPred.quot,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[Lean.Server.FileWorker.RefIdent.fvar.inj,[]]
[Mathlib.Tactic.Lint.checkAllSimpLemmaInfos,[Bind.bind, Mathlib.Tactic.Lint.withSimpLemmaInfos, Option.mapM, Lean.addMessageContextFull, ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Option.none, Option.some, Lean.MessageData.joinSep, Array.toList, Lean.MessageData.ofFormat, Std.Format.line]]
[Lean.Elab.Term.ElabAppArgs.State.explicit,[]]
[Lean.Elab.MonadLog.toMonadFileMap,[]]
[Lean.Parser.Command.builtin_initialize,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.visibility, Lean.Parser.symbol, Lean.Parser.atomic, Lean.Parser.ident, Lean.Parser.Term.typeSpec, Lean.Parser.Term.leftArrow, Lean.Parser.Term.doSeq]]
[Lean.Meta.SortLocalDecls.Context.mk.inj,[]]
[Lean.Meta.Match.MkMatcherInput.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.MkMatcherInput.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.optEllipsis.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.optional.parenthesizer, Lean.Parser.symbol.parenthesizer]]
[Lean.Elab.Info.noConfusionType,[]]
[Std.Format.fill,[Std.Format.group, Std.Format.FlattenBehavior.fill]]
[Lean.Elab.Command.InductiveView.type?,[]]
[Lean.LocalDecl.value?,[Option, Lean.Expr, Option.none, Option.some]]
[Lean.Syntax.getArg,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Array.getD]]
[Lean.Lsp.RpcConnectParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.RpcConnectParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.unelide,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Std.Format.pretty',[Std.Format.pretty, Lean.Option.get, Std.Format.format.width]]
[Lean.Xml.Parser.SDDecl,[SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Parsec.skipString, Lean.Xml.Parser.Eq, Lean.Xml.Parser.quote, HOrElse.hOrElse, Lean.Parsec.pstring]]
[instDecidableXor.proof_4,[False]]
[Nat.foldRev,[Nat.foldRev.loop]]
[Lean.Parser.Term.macroLastArg.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.macroDollarArg.parenthesizer, Lean.Parser.Term.macroArg.parenthesizer]]
[Lean.Lsp.InitializedParams.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.InitializedParams.toCtorIdx]]
[Lean.Meta.Match.AltLHS.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Syntax.MonadTraverser.noConfusionType,[]]
[Lean.IR.updateSorryDep,[Bind.bind, StateT.run, Lean.IR.Sorry.collect, Lean.IR.Sorry.State.mk, Lean.IR.CompilerM, Array, Lean.IR.Decl, Pure.pure, Array.map, Lean.IR.Decl.extern, Option.none, Lean.NameMap.find?, Lean.IR.Sorry.State.localSorryMap, Lean.IR.Decl.fdecl, Lean.IR.DeclInfo.mk, Option.some]]
[Lean.Elab.Tactic.ElabSimpArgsResult.noConfusionType,[]]
[Lean.Lsp.instFromJsonInitializeResult,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.ServerCapabilities, Option, Lean.Lsp.ServerInfo, Pure.pure, Lean.Lsp.InitializeResult.mk]]
[Id.finally,[MonadFinally.mk, Pure.pure, Prod.mk]]
[Lean.NameGenerator.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.NameGenerator.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Std.instInhabitedAssocList,[Inhabited.mk, Std.AssocList.nil]]
[Lean.Meta.Hypothesis.noConfusionType,[]]
[Lean.findDocString?,[Bind.bind, ST.Ref.get, Pure.pure, Option.orElse, Lean.NameMap.find?, Lean.MapDeclarationExtension.find?]]
[Lean.instToJsonNat,[Lean.ToJson.mk, Lean.Json.num, Lean.JsonNumber.fromNat]]
[Lean.Elab.Command.StructCtorView.modifiers,[]]
[Lean.Server.Watchdog.terminateFileWorker,[Bind.bind, Lean.Server.Watchdog.findFileWorker!, MonadExcept.tryCatch, liftM, IO.FS.Stream.writeLspMessage, Lean.Server.Watchdog.FileWorker.stdin, Lean.JsonRpc.Message.notification, Option.none, Pure.pure, DoResultPR.pure, PUnit.unit, DoResultPR.return, Lean.Server.Watchdog.ServerM, Unit]]
[instShiftRightUInt32,[ShiftRight.mk, UInt32.shiftRight]]
[Lean.Compiler.uintFoldToNatFns,[List.foldl, List.cons, Prod.mk, Lean.Compiler.NumScalarTypeInfo.toNatFn, Lean.Compiler.foldToNat, List.nil, Lean.Compiler.numScalarTypes]]
[Lean.MessageData.nest.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.KeyedDeclsAttribute.defn,[]]
[Lean.Meta.ApplyNewGoals.nonDependentFirst.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Std.HashSetImp.find?,[Option, List.find?, BEq.beq, Array.uget, Subtype.val]]
[Nat.nat_repr_len_aux,[Eq.mpr, implies_congr, congrArg, LT.lt, Nat.pow_succ, Eq.refl, HDiv.hDiv, HPow.hPow, Iff.mpr, Nat.div_lt_iff_lt_mul]]
[Lean.IR.Log.toString,[Std.Format.pretty, Lean.IR.Log.format, Std.Format.defWidth]]
[Std.PersistentArray.empty,[Std.PersistentArray.mk]]
[Lean.MetavarContext.UnivMVarParamResult.nextParamIdx,[]]
[Lean.Parser.Tactic.rotateLeft,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[Lean.IR.CompilerState.mk.inj,[And.intro]]
[Lean.Parser.Term.char.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.charLit.formatter]]
[Lean.Parser.Term.ident.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.ident.parenthesizer]]
[Lean.Elab.Term.StructInst.CtorHeaderResult.ctorFnType,[]]
[instLTFloat,[LT.mk, Float.lt]]
[Mathlib.Prelude.Rename.addNameAlignment,[Lean.MonadEnv.modifyEnv, Lean.PersistentEnvExtension.addEntry, Mathlib.Prelude.Rename.renameExtension, Prod.mk]]
[guardTargetStrict,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.Term.NamedArg.ref,[]]
[Int.instHPowIntNatInt,[HPow.mk, Int.pow]]
[Lean.Elab.Term.Quotation.HeadCheck.other.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.Quotation.HeadCheck.other, Eq.symm, eq_of_heq, HEq.refl]]
[tacticCalc_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, calcStep]]
[Lean.Environment.hasUnsafe,[Option.isSome]]
[Lean.Parser.Term.doUnless,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.withForbidden, Lean.Parser.termParser, Lean.Parser.Term.doSeq]]
[UInt8.toUInt64,[Nat.toUInt64, UInt8.toNat]]
[Lean.MonadQuotation.toMonadRef,[]]
[Lean.Meta.abstractNestedProofs,[StateRefT'.run', Lean.MonadCacheT.run, ReaderT.run, Lean.Meta.AbstractNestedProofs.visit, Lean.Meta.AbstractNestedProofs.Context.mk, Lean.Meta.AbstractNestedProofs.State.mk, OfNat.ofNat]]
[IO.withStderr,[Bind.bind, liftM, IO.setStderr, tryFinally, Functor.discard]]
[Lean.Meta.Match.Alt.toMessageData,[Lean.Meta.withExistingLocalDecls, Lean.Meta.Match.Alt.fvarDecls, Lean.AddMessageContext.addMessageContext]]
[Lean.Parser.Tactic.generalizeHyp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.Parser.Tactic.location]]
[Lean.Lsp.instToJsonCompletionList,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.CompletionList.isIncomplete, List.nil, Lean.Lsp.CompletionList.items]]
[Lean.Lsp.CompletionParams.noConfusionType,[]]
[Lean.Meta.Simp.post,[Bind.bind, MonadReader.read, liftM, Lean.Meta.Simp.Methods.post]]
[Lean.Elab.Term.MVarErrorInfo.logError.appendExtra,[Unit.unit, Lean.MessageData, HAppend.hAppend]]
[Lean.Meta.CaseValuesSubgoal.newHs,[]]
[Lean.Parser.Term.typeSpec.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[UInt8.decLt,[Decidable, LT.lt, inferInstanceAs]]
[Lean.Parser.Command.whereStructField.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.Term.letDecl.formatter]]
[Lean.Parser.ParserModuleContext.env,[]]
[Lean.annotation?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Option, Lean.Expr, ite, Eq, and, BEq.beq, Lean.KVMap.size, OfNat.ofNat, Lean.KVMap.getBool, Bool.false, Bool.true, Option.some, Option.none]]
[Lean.Server.Watchdog.initAndRunWatchdog,[Bind.bind, IO.appPath, liftM, IO.getEnv, Option.none, IO, Unit, Pure.pure, PUnit.unit]]
[Std.PShareCommonT.monadShareCommon,[Std.MonadShareCommon.mk, Std.PShareCommonT.withShareCommon]]
[Decidable.iff_iff_not_or_and_or_not,[Eq.mpr, Eq.refl, Iff, And, Or, Not, propext, iff_iff_implies_and_implies, congr, congrArg, Eq.trans, Decidable.imp_iff_not_or, or_comm, congrFun, Iff.rfl]]
[Lean.IR.ExplicitRC.getVarInfo,[Unit.unit, Lean.IR.ExplicitRC.VarInfo, Std.RBMap.find?, Lean.IR.ExplicitRC.Context.varMap, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Meta.GeneralizeArg.noConfusionType,[]]
[IO.asTask,[EIO.asTask]]
[Lean.Elab.Frontend.setParserState,[modify, Lean.Elab.Frontend.State.mk, Lean.Elab.Frontend.State.commandState, Lean.Elab.Frontend.State.cmdPos, Lean.Elab.Frontend.State.commands]]
[Lean.Parser.instInhabitedParserFn,[Inhabited.mk]]
[eq_false,[propext, Iff.intro, absurd, False.elim]]
[Lean.JsonRpc.instCoeRequestMessage,[Coe.mk, Lean.JsonRpc.Message.request, Lean.JsonRpc.Request.id, Lean.JsonRpc.Request.method, Except.toOption, Lean.Json.toStructured?, Lean.JsonRpc.Request.param]]
[Lean.KernelException.declHasMVars.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.declHasMVars, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.withTransparency,[Lean.Meta.mapMetaM, Lean.Meta.withConfig, Lean.Meta.Config.mk, Lean.Meta.Config.foApprox, Lean.Meta.Config.ctxApprox, Lean.Meta.Config.quasiPatternApprox, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct]]
[Lean.Parser.checkPrecFn,[ite, LE.le, Lean.Parser.ParserContext.prec, Lean.Parser.ParserState.mkUnexpectedError, List.nil]]
[Lean.Elab.Term.Do.hasBreakContinue,[Lean.Elab.Term.Do.hasExitPointPred, Lean.Elab.Term.Do.Code.decl, Lean.Elab.Term.Do.Code.reassign, Lean.Elab.Term.Do.Code.joinpoint, Lean.Elab.Term.Do.Code.seq, Lean.Elab.Term.Do.Code.action, Lean.Elab.Term.Do.Code.return, Lean.Elab.Term.Do.Code.ite, Lean.Elab.Term.Do.Code.match, Lean.Elab.Term.Do.Code.jmp, Bool, Bool.true, Bool.false]]
[Lean.MessageData.ofSyntax.injEq,[Eq.propIntro, Eq.refl, Lean.MessageData.ofSyntax, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.getExternConstArityExport,[MonadExcept.tryCatch, Bind.bind, Lean.Core.CoreM.toIO, Lean.getExternConstArity, Lean.Core.Context.mk, Lean.Core.State.mk, IO, Option, Nat, Pure.pure, Option.none]]
[Lean.Meta.Instances.erased,[]]
[Lean.Elab.Term.elabNoindex,[Bind.bind, Lean.Elab.Term.elabTerm, Lean.Syntax.getOp, OfNat.ofNat, Bool.true, Pure.pure, Lean.Meta.DiscrTree.mkNoindexAnnotation]]
[Lean.PPContext.env,[]]
[Lean.Parser.Tactic.tacticSeq,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HOrElse.hOrElse, Lean.Parser.Tactic.tacticSeqBracketed, Lean.Parser.Tactic.tacticSeq1Indented, Bool.false]]
[Std.RBNode.forIn,[Bind.bind, Pure.pure, Std.RBNode.forIn.visit]]
[Lean.Parser.Term.letIdDecl.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Term.letIdLhs.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Bool.false]]
[Lean.IR.ExplicitBoxing.BoxingContext.env,[]]
[iff_congr,[Iff.intro, Iff.trans, Iff.symm]]
[Lean.ScopedEnvExtension.modifyState,[List.nil, Lean.Environment, Lean.ScopedEnvExtension.StateStack.stateStack, Lean.PersistentEnvExtension.setState, Lean.ScopedEnvExtension.ext, Lean.ScopedEnvExtension.StateStack.mk, List.cons, Lean.ScopedEnvExtension.State.mk, Lean.ScopedEnvExtension.State.state, Lean.ScopedEnvExtension.State.activeScopes, Lean.ScopedEnvExtension.StateStack.scopedEntries, Lean.ScopedEnvExtension.StateStack.newEntries]]
[toLBoolM,[Bind.bind, Pure.pure, Bool.toLBool]]
[Fin.ne_of_val_ne,[absurd, Fin.val_eq_of_eq]]
[Lean.IR.ExplicitBoxing.BoxingState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.ExplicitBoxing.BoxingState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[heq_of_eqRec_eq,[heq_of_eq]]
[Prod.mk.inj_right,[And.left, Prod.mk.inj]]
[System.FilePath.mk.injEq,[Eq.propIntro, Eq.refl, System.FilePath.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Do.ToTerm.Context.mk.inj,[And.intro]]
[ByteSliceT.arr,[]]
[Lean.Elab.Term.elabLetMVar,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.MonadMCtx.getMCtx, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.MetavarContext.findUserName?, Lean.Syntax.getId, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.Term.elabTerm, Option.none, liftM, Lean.Meta.inferType, Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.syntheticOpaque, Lean.Meta.assignExprMVar, Lean.Expr.mvarId!, Pure.pure, Lean.Elab.Term.mkSaveInfoAnnotation, Lean.Elab.throwUnsupportedSyntax]]
[List.subset_def,[Iff.rfl]]
[EStateM.bind,[EStateM.Result, EStateM.Result.error]]
[termℤ,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Lean.IR.ExpandResetReuse.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.IR.ExpandResetReuse.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Array.mapMUnsafe.map,[ite, LT.lt, Bind.bind, unsafeCast, Array.mapMUnsafe.map, HAdd.hAdd, OfNat.ofNat, Array.uset, lcProof, Pure.pure]]
[Lean.Meta.instInhabitedSavedState,[Inhabited.mk, Lean.Meta.SavedState.mk, arbitrary]]
[Lean.Meta.RecursorInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Expr.ReplaceLevelImpl.State.results,[]]
[Lean.EnvExtensionInterface.getState,[]]
[Lean.NameTrie,[Lean.PrefixTree, Lean.NamePart, Lean.NamePart.cmp]]
[Lean.Parser.Command.instance.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.optNamedPrio.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.Command.declSig.parenthesizer, Lean.Parser.Command.declVal.parenthesizer, Lean.Parser.Command.terminationSuffix.parenthesizer]]
[Lean.Parser.Term.doPatDecl,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.termParser, Lean.Parser.Term.leftArrow, Lean.Parser.doElemParser, Lean.Parser.optional, Lean.Parser.checkColGt, Lean.Parser.symbol]]
[Lean.Elab.Tactic.elabTermForApply,[ite, Eq, Lean.Syntax.isIdent, Bool.true, Bind.bind, liftM, Lean.Elab.Term.resolveId?, Option.none, Lean.Elab.Tactic.TacticM, Lean.Expr, Pure.pure, Unit.unit, PUnit.unit]]
[Lean.Position.instToExprPosition,[Lean.ToExpr.mk, Lean.mkAppN, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, List.toArray, List.cons, Lean.ToExpr.toExpr, Lean.Position.line, Lean.Position.column]]
[Lean.MessageSeverity.noConfusionType,[noConfusionTypeEnum, Lean.MessageSeverity.toCtorIdx]]
[instCommMonoid,[CommMonoid.mk, CommGroup.mul_comm]]
[Array.forIn.loop,[Pure.pure]]
[String.takeWhile,[Substring.toString, Substring.takeWhile, String.toSubstring]]
[Lean.Elab.DefViewElabHeader.valueStx,[]]
[Lean.NameHashSet.empty,[Std.HashSet.empty]]
[Lean.Meta.Match.Pattern.toExpr,[Lean.Meta.Match.Pattern.toExpr.visit]]
[Lean.Elab.Term.elabInaccessible,[Bind.bind, Lean.Elab.Term.elabTerm, Lean.Syntax.getOp, OfNat.ofNat, Bool.true, Pure.pure, Lean.mkInaccessible]]
[Lean.PrettyPrinter.Delaborator.SubExpr.pos,[]]
[Lean.Meta.RecursorInfo.firstIndexPos,[HSub.hSub, Lean.Meta.RecursorInfo.majorPos, Lean.Meta.RecursorInfo.numIndices]]
[command_Lemma___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[Lean.LBool.instToStringLBool,[ToString.mk, Lean.LBool.toString]]
[coeB,[Coe.coe]]
[IO.Process.Stdio.noConfusionType,[noConfusionTypeEnum, IO.Process.Stdio.toCtorIdx]]
[UInt64.instSemiringUInt64.proof_13,[UInt64.eq_of_val_eq, Eq.mpr, congrArg, Eq, Fin.ofNat', HAdd.hAdd, OfNat.ofNat, Fin.size_positive', UInt64.val, Eq.trans, UInt64.mk, UInt64.one_def, UInt64.add_def]]
[WellFoundedRelation.rel,[]]
[Lean.Expr.ReplaceLevelImpl.initCache.proof_1,[lcProof]]
[Lean.Parser.Command.def,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.declId, Lean.Parser.Command.optDeclSig, Lean.Parser.Command.declVal, Lean.Parser.Command.optDefDeriving, Lean.Parser.Command.terminationSuffix]]
[Lean.Parser.Tactic.continuity!?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.mkCongrLemma,[Lean.Meta.withReducible, Bind.bind, Lean.mkConstWithLevelParams, Lean.Meta.inferType, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.MetaM, Lean.Meta.CongrLemma, Unit.unit, Lean.Expr.eq?, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Expr.withApp, ite, Eq, and, Lean.Expr.isConst, BEq.beq, Lean.Expr.constName!, Array.size, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.mkCongrLemma.onlyMVarsAt]]
[Lean.Parser.Term.doCatchMatch,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.doMatchAlts]]
[Lean.Parser.Command.abbrev,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.declId, Lean.Parser.Command.optDeclSig, Lean.Parser.Command.declVal]]
[Lean.instToJsonUSize,[Lean.ToJson.mk, Lean.bignumToJson, USize.toNat]]
[String.trimLeft,[Substring.toString, Substring.trimLeft, String.toSubstring]]
[if_pos,[Eq, ite, rfl, absurd]]
[Lean.Meta.FindOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.DefViewElabHeader.binderIds,[]]
[Std.PersistentArray.Stats.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.PersistentArray.Stats.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.CongrArgKind.fixed.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Tactic.Find.tacticFind,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[ulift.up.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.classInductive,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.group, Lean.Parser.symbol, Lean.Parser.Command.declId, Lean.Parser.Command.optDeclSig, Lean.Parser.optional, HOrElse.hOrElse, Lean.Parser.many, Lean.Parser.Command.ctor, Lean.Parser.Command.optDeriving]]
[List.equiv,[Iff, Mem.mem]]
[instSubUSize,[Sub.mk, USize.sub]]
[Mathlib.Tactic.Lint.isAutoDecl,[ite, Eq, Lean.Name.hasMacroScopes, Bool.true, Pure.pure, Bind.bind, PUnit.unit]]
[Lean.Parser.Command.visibility.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.private.formatter, Lean.Parser.Command.protected.formatter]]
[Subtype.instDecidableEqSubtype.proof_2,[absurd]]
[Lean.PrettyPrinter.Parenthesizer.withForbidden.parenthesizer,[]]
[Function.partial_inv_left,[Function.is_partial_inv_left, Function.partial_inv_of_injective]]
[Substring.dropRightWhile,[Substring, Substring.mk]]
[Lean.Elab.Term.Do.getLetDeclVars,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, List.toArray, List.cons, Lean.Elab.Term.Do.getLetIdDeclVar, List.nil, Lean.Elab.Term.Do.getLetPatDeclVars, Lean.Elab.Term.Do.getLetEqnsDeclVar, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Fin.ofNat',[Fin.mk, HMod.hMod, Nat.mod_lt]]
[Lean.Lsp.ProgressParams.mk.inj,[And.intro]]
[Lean.Constructor.mk.inj,[And.intro]]
[Lean.Elab.Command.elabVariable,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Command.runTermElabM, Option.none, Lean.Elab.Term.withAutoBoundImplicit, Lean.Elab.Term.elabBinders, Pure.pure, Unit.unit, ForIn.forIn, PUnit.unit, Lean.Elab.Command.CommandElabM, Bool, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Prod.mk, Array.map, Lean.Syntax.getId, Bool.false, Lean.Elab.Command.getScope, MProd.mk, ForInStep, MProd, Array, Lean.Syntax, Lean.Syntax.isNone, List.toArray, List.cons, List.nil, BEq.beq, Array.any, Array.contains, Array.size, Lean.throwError, Lean.ToMessageData.toMessageData, Option.isSome, ForInStep.yield, Lean.Elab.Command.modifyScope, Lean.Elab.Command.Scope.mk, Lean.Elab.Command.Scope.header, Lean.Elab.Command.Scope.opts, Lean.Elab.Command.Scope.currNamespace, Lean.Elab.Command.Scope.openDecls, Lean.Elab.Command.Scope.levelNames, Lean.Elab.Command.Scope.varUIds, Lean.Elab.Command.Scope.isNoncomputable, Array.mapM, Function.comp, Lean.MonadQuotation.withFreshMacroScope, Lean.MonadQuotation.addMacroScope, Lean.Elab.Command.getBracketedBinderIds, Array.push, Lean.Elab.Command.Scope.varDecls, HAppend.hAppend, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Parser.FirstTokens.seq,[Lean.Parser.FirstTokens.unknown, Lean.Parser.FirstTokens.tokens, Lean.Parser.FirstTokens.optTokens, Lean.Parser.FirstTokens.epsilon, Lean.Parser.FirstTokens, HAppend.hAppend]]
[Lean.IR.CtorFieldInfo.object.inj,[]]
[Lean.DeclarationRange.charUtf16,[]]
[Lean.Elab.logDbgTrace,[Lean.Elab.trace, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Meta.Simp.Context.congrLemmas,[]]
[Lean.Elab.Structural.ensureNoRecFn,[ite, Eq, Option.isSome, Lean.Expr.find?, Lean.Expr.isConstOf, Bool.true, Bind.bind, Lean.Meta.forEachExpr, Lean.Expr.isAppOf, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Pure.pure, PUnit.unit]]
[Lean.Parser.Command.declId,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.symbol, Lean.Parser.sepBy1, Bool.false]]
[Lean.Elab.Term.Do.ToTerm.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.GeneralizeArg.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.MVarRenaming.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.MVarRenaming.mk, Eq.symm, eq_of_heq, HEq.refl]]
[le_not_le_of_lt,[And, LE.le, Not, Iff.mp, lt_iff_le_not_le]]
[Lean.Server.Watchdog.ServerContext.editDelay,[]]
[instDecidableEqSum.proof_6,[]]
[List.disjoint_nil_right,[Eq.mpr, Eq.refl, List.disjoint, List.nil, propext, List.disjoint_comm, List.disjoint_nil_left]]
[Lean.Meta.SimpAll.M,[StateRefT', IO.RealWorld, Lean.Meta.SimpAll.State, Lean.Meta.MetaM]]
[Lean.Elab.Command.StructView.mk.inj,[And.intro]]
[List.disjoint_of_disjoint_append_left_right,[And.right, Iff.mp, List.disjoint_append_left]]
[IO.FS.Metadata.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FS.Metadata.mk, Eq.symm, eq_of_heq, HEq.refl]]
[instMonadExceptOfEST,[inferInstanceAs, MonadExceptOf, EStateM]]
[Lean.Elab.resolveGlobalConstWithInfos,[Bind.bind, Lean.resolveGlobalConst, Lean.Elab.MonadInfoTree.getInfoState, ite, Eq, Lean.Elab.InfoState.enabled, Bool.true, ForIn.forIn, PUnit.unit, Lean.mkConstWithLevelParams, Lean.Elab.pushInfoLeaf, Lean.Elab.Info.ofTermInfo, Lean.Elab.TermInfo.mk, Lean.Elab.ElabInfo.mk, Lean.Name.anonymous, Lean.LocalContext.empty, Pure.pure, ForInStep.yield]]
[Lean.ProjectionFunctionInfo.noConfusionType,[]]
[Lean.Parsec.peek!,[Bind.bind, Lean.Parsec.peek?, Option.none, Lean.Parsec, Char, Pure.pure, Lean.Parsec.fail, Lean.Parsec.unexpectedEndOfInput]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.mk.inj,[And.intro]]
[Lean.IR.Borrow.ownArg,[Lean.IR.Arg.irrelevant, Lean.IR.Borrow.M, Unit, Lean.IR.Borrow.ownVar, Pure.pure, Unit.unit]]
[ByteSlice.getOp,[ByteArray.get!, ByteSlice.arr, HAdd.hAdd, ByteSlice.off]]
[Lean.PersistentEnvExtensionDescr.addImportedFn,[]]
[Lean.Compiler.SpecState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.numberFnAux,[ite, Eq, String.atEnd, Bool.true, Lean.Parser.ParserState.mkEOIError, List.nil, BEq.beq, Char.ofNat, or, Lean.Parser.binNumberFn, Lean.Parser.ParserState.next, Lean.Parser.octalNumberFn, Lean.Parser.hexNumberFn, Lean.Parser.decimalNumberFn, Lean.Parser.ParserState.setPos, Char.isDigit, Lean.Parser.ParserState.mkError]]
[Lean.MonadStateCacheT.instMonadRefMonadStateCacheT,[inferInstanceAs, Lean.MonadRef, StateT, Std.HashMap]]
[Lean.ParametricAttributeImpl.toAttributeImplCore,[]]
[Lean.Parser.Term.attrKind.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.scoped.parenthesizer, Lean.Parser.Term.local.parenthesizer]]
[List.union,[List.foldr, List.insert]]
[Lean.Syntax.unsetTrailing,[Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Lean.Syntax, Lean.Syntax.getTailInfo, Lean.Syntax.setTailInfo, Lean.SourceInfo.original, String.toSubstring]]
[Mathlib.Prelude.Rename.RenameMap.insertPair,[Mathlib.Prelude.Rename.RenameMap, Std.HashMap.insert]]
[instSizeOf,[SizeOf.mk, default.sizeOf]]
[Std.Format.tag.inj,[And.intro]]
[Lean.Elab.Structural.State.mk.inj,[]]
[Lean.IR.Checker.M,[ReaderT, Lean.IR.Checker.CheckerContext, ExceptT, String, StateT, Lean.IR.Checker.CheckerState, Id]]
[Lean.Server.RequestContext.rpcSessions,[]]
[Lean.Export.instOfStateExpr,[Lean.Export.OfState.mk, Lean.Export.State.exprs, Lean.Export.State.mk, Lean.Export.State.names, Lean.Export.State.levels, Lean.Export.State.defs, Lean.Export.State.stk]]
[Lean.Meta.SynthInstance.SubgoalsResult.subgoals,[]]
[Lean.Elab.ElabInfo.mk.inj,[And.intro]]
[Lean.MonadOptions.getOptions,[]]
[Nat.sub_eq_iff_eq_add,[Iff.intro, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Eq.symm, HSub.hSub, Nat.sub_add_cancel, rfl, Nat.add_sub_cancel]]
[Lean.IR.formatArray,[Array.foldl, HAppend.hAppend, Std.Format.text, Std.ToFormat.format, Std.Format.nil, OfNat.ofNat, Array.size]]
[Lean.PrettyPrinter.Formatter.charLit.formatter,[Lean.Parser.Term.char.formatter]]
[String.length_eq_list_length,[of_eq_true, eq_self, List.length]]
[Lean.ParserCompiler.Context.combinatorAttr,[]]
[Array.allDiff,[OfNat.ofNat]]
[Lean.Json.Structured.obj.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[StateRefT'.get,[ST.Ref.get]]
[Lean.Expr.ReplaceImpl.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.ReplaceImpl.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.EmitC.emitUnbox,[Bind.bind, Lean.IR.EmitC.emitLhs, Unit.unit, Lean.IR.IRType.uint8, Lean.IR.IRType.uint16, Lean.IR.IRType.irrelevant, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.struct, Lean.IR.IRType.union, Lean.IR.EmitC.M, Unit, Lean.IR.EmitC.emit]]
[Lean.Meta.ToHide.State.modified,[]]
[«term↑_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.Term.elabPanic,[Bind.bind, Lean.Elab.getRefPosition, Lean.MonadEnv.getEnv, Lean.Elab.Term.getDeclName?, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Quote.quote, ToString.toString, Lean.Environment.mainModule, Lean.Position.line, Lean.Position.column]]
[Lean.instToJsonJsonNumber,[Lean.ToJson.mk, Lean.Json.num]]
[Lean.Meta.SimpLemmas.addConst,[Bind.bind, Lean.getConstInfo, Lean.Meta.withReducible, Lean.Meta.inferType, Lean.Meta.isProp, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Meta.forallTelescopeReducing, not, Lean.Expr.isEq, or, ForIn.forIn, Lean.Meta.MetaM, ForInStep, Array, Lean.Meta.SimpLemma, Lean.Meta.mkAuxLemma, Lean.ConstantInfo.levelParams, Lean.Meta.instantiateMVars, Lean.Meta.withNewMCtxDepth, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.whnfR, Unit.unit, Lean.Expr.eq?, Lean.Meta.DiscrTree.mkPath, Prod.mk, Lean.mkConst, List.map, Lean.mkLevelParam, List.toArray, List.nil, Option.some, ForInStep.yield, List.cons, Array.foldl, Lean.Meta.addSimpLemmaEntry, OfNat.ofNat, Array.size]]
[Nat.succ_add,[Eq, HAdd.hAdd, Nat.succ, rfl, congrArg, PProd.fst]]
[Lean.JsonRpc.instLTRequestID,[LT.mk, Eq, Lean.JsonRpc.RequestID.str, Lean.JsonRpc.RequestID.num, Lean.JsonRpc.RequestID.null, Bool, Decidable.decide, LT.lt, Bool.true, Bool.false]]
[Int.sign_mul_natAbs,[Unit.unit, Eq, HMul.hMul, Int.sign, Int.ofNat, Int.natAbs, Int.one_mul, HAdd.hAdd, OfNat.ofNat, rfl, Eq.symm, Int.neg_eq_neg_one_mul, Int.negSucc]]
[Int.mul_zero,[Eq, HMul.hMul, OfNat.ofNat, rfl]]
[Lean.MonadHashMapCacheAdapter.instMonadCache,[Lean.MonadCache.mk, Lean.MonadHashMapCacheAdapter.findCached?, Lean.MonadHashMapCacheAdapter.cache]]
[Lean.Elab.Term.StructInst.DefaultFields.getFieldValue?,[List.findSome?, ite, Eq, BEq.beq, Lean.Elab.Term.StructInst.DefaultFields.getFieldName, Bool.true, Lean.Elab.Term.StructInst.Field.expr?, Option.none, Lean.Elab.Term.StructInst.Struct.fields]]
[Lean.getAliasState,[Lean.SimplePersistentEnvExtension.getState, Lean.aliasExtension]]
[Std.PersistentHashSet.set,[]]
[Lean.IR.instToFormatDecl,[Std.ToFormat.mk, Lean.IR.formatDecl, OfNat.ofNat]]
[Lean.Meta.InjectionResult.subgoal.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.CancelParams.id,[]]
[Lean.MacroScopesView.name,[]]
[or.right_comm,[Eq.mpr, Eq.refl, Iff, Or, propext, or_assoc, or_comm, Iff.rfl]]
[Lean.Elab.Term.PatternElabException.mk.inj,[And.intro]]
[LT.noConfusionType,[]]
[List.disjoint_cons_left,[Iff.trans, List.disjoint_append_left, of_eq_true, Eq.trans, congrFun, congrArg, Iff, And, propext, List.singleton_disjoint, List.disjoint, Not, Mem.mem, iff_self]]
[Lean.IR.EmitC.emitFnDecl,[Bind.bind, Lean.IR.EmitC.toCName, Lean.IR.Decl.name, Lean.IR.EmitC.emitFnDeclAux]]
[Lean.Elab.Term.StructInst.CtorHeaderResult.instMVars,[]]
[Nat.mul_sub_div,[]]
[USize.instSemiringUSize.proof_13,[USize.eq_of_val_eq, Eq.mpr, congrArg, Eq, Fin.ofNat', HAdd.hAdd, OfNat.ofNat, Fin.size_positive', USize.val, Eq.trans, USize.mk, USize.one_def, USize.add_def]]
[Lean.fieldIdxKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Parser.tokenFn,[ite, Eq, String.atEnd, Bool.true, Lean.Parser.ParserState.mkEOIError, BEq.beq, Lean.Parser.TokenCacheEntry.startPos, Lean.Parser.ParserState.setPos, Lean.Parser.TokenCacheEntry.stopPos, Lean.Parser.ParserState.mk, Option.some, Lean.Parser.ParserState, Array.size, OfNat.ofNat, Lean.Parser.ParserCache.mk, Lean.Parser.TokenCacheEntry.mk, Option.none]]
[Lean.Elab.Command.elabDeclaration,[Unit.unit, Lean.Elab.Command.CommandElabM, Unit, Lean.Elab.Command.expandDeclNamespace?, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Elab.Command.withMacroExpansion, Lean.Elab.Command.elabCommand, Lean.Elab.elabModifiers, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, BEq.beq, Bool.true, Lean.Elab.Command.elabAxiom, Lean.Elab.Command.elabInductive, Lean.Elab.Command.elabClassInductive, Lean.Elab.Command.elabStructure, Lean.Elab.Command.isDefLike, Lean.Elab.Command.elabMutualDef, Lean.Elab.Command.getTerminationHints, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Std.HashMap.toArray,[Std.HashMap.fold, Array.push, Prod.mk, List.toArray, List.nil]]
[Lean.ExprStructEq.instToStringExprStructEq,[ToString.mk, ToString.toString, Lean.ExprStructEq.val]]
[Subtype.existsOfSubtype,[Subtype.existsOfSubtype.proof_1]]
[Nat.succ_sub,[Exists.elim, Nat.le.dest, Eq.mpr, Eq.refl, Eq, HSub.hSub, Nat.succ, Eq.symm, HAdd.hAdd, Nat.add_sub_cancel_left, Nat.add_succ, rfl]]
[Lean.MessageData.node.inj,[]]
[Lean.Meta.smartUnfoldingReduce?,[OptionT.run, Lean.Meta.smartUnfoldingReduce?.go, Lean.Meta.smartUnfoldingReduce?.goMatch]]
[Lean.Meta.Simp.Config.singlePass,[]]
[Lean.Elab.Term.instInhabitedSavedState,[Inhabited.mk, Lean.Elab.Term.SavedState.mk, arbitrary]]
[AndOp.noConfusionType,[]]
[Lean.Elab.Tactic.MkSimpContextResult.dischargeWrapper,[]]
[Lean.PrettyPrinter.Parenthesizer.strLit.parenthesizer,[Lean.Parser.Term.str.parenthesizer]]
[Lean.Elab.Command.State.nextMacroScope,[]]
[Lean.Syntax.instForInTopDownSyntax,[ForIn.mk, Bind.bind, Inhabited.mk, Pure.pure, Lean.Syntax.instForInTopDownSyntax.loop]]
[Lean.IR.UnreachableBranches.Value.noConfusionType,[]]
[Lean.Name.quickLt,[BEq.beq, Lean.Name.quickCmp, Ordering.lt]]
[Lean.Meta.ElimAltInfo.name,[]]
[Std.HashSetImp.erase,[Std.HashSetImp, ite, Eq, List.contains, Bool.true, Std.HashSetImp.mk, HSub.hSub, OfNat.ofNat, Std.HashSetBucket.update, List.erase]]
[Array.findIdx?.loop.proof_2,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, OfNat.ofNat, Array.size, Eq.symm, Nat.add_comm, Nat.add_assoc, rfl]]
[Lean.Expr.isAutoParam,[Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat]]
[Lean.Meta.instBEqInstanceEntry,[BEq.mk, BEq.beq, Lean.Meta.InstanceEntry.val]]
[Lean.Elab.CompletionInfo.format,[Lean.Elab.CompletionInfo.namespaceId, Lean.Elab.CompletionInfo.option, Lean.Elab.CompletionInfo.endSection, Lean.Elab.CompletionInfo.tactic, IO, Std.Format, Bind.bind, Lean.Elab.TermInfo.format, Pure.pure, HAppend.hAppend, Std.ToFormat.format, Lean.Elab.ContextInfo.runMetaM, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Lean.Elab.CompletionInfo.stx]]
[Lean.IR.UnreachableBranches.instToStringValue,[ToString.mk, ToString.toString, Std.ToFormat.format]]
[Lean.Server.Watchdog.ServerContext.mk.inj,[And.intro]]
[Lean.Parser.Command.macroRhs.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.termParser.formatter]]
[Std.AssocList.forIn.loop,[Pure.pure, Bind.bind, Prod.mk, PProd.fst]]
[Lean.JsonNumber.shiftl,[Lean.JsonNumber, Lean.JsonNumber.mk, HMul.hMul, Int.ofNat, HPow.hPow, OfNat.ofNat, HSub.hSub]]
[Lean.commitWhenSome?,[Bind.bind, Lean.MonadBacktrack.saveState, MonadExcept.tryCatch, Unit.unit, Option, Pure.pure, Option.some, Lean.MonadBacktrack.restoreState, Option.none, MonadExcept.throw]]
[Lean.Elab.Command.instInhabitedScope,[Inhabited.mk, Lean.Elab.Command.Scope.mk, arbitrary]]
[Lean.Meta.SimpEntry.lemma.inj,[]]
[Lean.IR.EmitC.emitProj,[Bind.bind, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn]]
[Lean.Meta.Closure.State.exprFVarArgs,[]]
[Char.toLower,[ite, And, GE.ge, OfNat.ofNat, LE.le, Char.ofNat, HAdd.hAdd]]
[Lean.Parser.Command.restateAxiom,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.unary]]
[Lean.Elab.TermInfo.isBinder,[]]
[Lean.JsonRpc.Notification.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.instDivNat,[Div.mk, Nat.div]]
[Lean.Parser.Module.import.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.ident.formatter]]
[Lean.Meta.IndPredBelow.Context.motives,[]]
[Lean.Elab.Term.Arg.expr.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.Arg.expr, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Compiler.CSimp.Entry.noConfusionType,[]]
[Lean.Server.FileWorker.SemanticTokensState.data,[]]
[not_and_self,[False]]
[Lean.IR.LocalContextEntry.joinPoint.inj,[And.intro]]
[Lean.Elab.Info.ofCommandInfo.inj,[]]
[instCommSemigroup,[CommSemigroup.mk, CommMonoid.mul_comm]]
[Lean.MonadStateCacheT.instMonadMonadStateCacheT,[inferInstanceAs, Monad, StateT, Std.HashMap]]
[Lean.IR.Borrow.instToStringParamMap,[ToString.mk, Std.Format.pretty, Std.ToFormat.format, Std.Format.defWidth]]
[Lean.Level.below,[PUnit, PProd]]
[Lean.Xml.Parser.Comment,[SeqLeft.seqLeft, SeqRight.seqRight, Lean.Parsec.skipString, Functor.map, Array.foldl, String.append, OfNat.ofNat, Array.size, Lean.Parsec.many, HOrElse.hOrElse, Bind.bind, Lean.Parsec.pchar, Char.ofNat, Pure.pure, HAppend.hAppend, Char.toString]]
[Lean.Expr.isOptParam,[Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat]]
[decidable_eq_inr_neg,[Eq, Decidable.isFalse, absurd, Eq.refl, proof_irrel]]
[Lean.Elab.Term.MatchAltView.rhs,[]]
[Lean.Xml.Parser.EntityDecl,[HOrElse.hOrElse, Lean.Xml.Parser.GEDecl, Lean.Xml.Parser.PEDecl]]
[Lean.DefinitionSafety.toCtorIdx,[OfNat.ofNat]]
[iff_self_and,[Eq.mpr, Eq.refl, Iff, And, propext, Iff.comm, and_iff_left_iff_imp, Iff.rfl]]
[decPropToBool,[CoeDep.mk, Decidable.decide]]
[getModify,[MonadState.modifyGet, Prod.mk]]
[Lean.Parser.Tactic.«tacticHave'__:=_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Lsp.instToJsonDocumentSelector,[Lean.ToJson.mk, Lean.ToJson.toJson]]
[Lean.Elab.Term.StructInst.throwFailedToElabField,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.Lsp.TextDocumentSyncOptions.change,[]]
[Mathlib.Tactic.Lint.NamedLinter.toLinter,[]]
[Lean.Server.FileWorker.workerMain,[Bind.bind, liftM, IO.getStdin, IO.getStdout, IO.getStderr, MonadExcept.tryCatch, Functor.map, Function.comp, UInt64.toNat, ByteArray.toUInt64LE!, IO.getRandomBytes, OfNat.ofNat, IO.setRandSeed, Lean.Server.FileWorker.initAndRunWorker, IO.FS.Stream.flush, IO.Process.exit, UInt32.toUInt8, Pure.pure, DoResultPR.pure, PUnit.unit, IO.FS.Stream.putStrLn, HAppend.hAppend, ToString.toString, DoResultPR.return, IO, UInt32]]
[Lean.Parser.Tactic.contradiction,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.NameTrie.forM,[Lean.NameTrie.forMatchingM, Lean.Name.anonymous]]
[Lean.Server.FileWorker.ElabTaskError.aborted.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Lsp.DidChangeTextDocumentParams.contentChanges,[]]
[bfix2,[PProd.fst]]
[Lean.JsonRpc.Message.notification.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[PointedType.type,[]]
[Lean.Elab.MacroExpansionInfo.mk.inj,[And.intro]]
[Lean.Export.Entry.defn.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MonadError.noConfusionType,[]]
[Lean.Parser.Syntax.addPrec,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parsec.instMonadParsec,[Monad.mk]]
[Lean.SMap.noConfusionType,[]]
[Lean.Elab.Term.LetRecView.decls,[]]
[Lean.Parser.Attr.instance.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.priorityParser.parenthesizer]]
[Lean.Lsp.DocumentFilter.noConfusionType,[]]
[Lean.Name.hashEx,[Lean.Name.hash]]
[Lean.IR.LitVal.num.injEq,[Eq.propIntro, Eq.refl, Lean.IR.LitVal.num, Eq.symm, eq_of_heq, HEq.refl]]
[ByteArray.uget,[UInt8, Array.uget]]
[Lean.Elab.Term.Do.ToTerm.Kind.toCtorIdx,[OfNat.ofNat]]
[Lean.MetavarKind.synthetic.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Lsp.DocumentHighlight.mk.inj,[And.intro]]
[Lean.IR.instToStringIRType,[ToString.mk, Function.comp, ToString.toString, Std.ToFormat.format]]
[Lean.Widget.InfoPopup.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Widget.InfoPopup.mk, Eq.symm, eq_of_heq, HEq.refl]]
[CoeTail.noConfusionType,[]]
[Lean.Parser.syntaxParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous]]
[Setoid.r,[]]
[Lean.Elab.Term.Do.mkIte,[Bind.bind, Lean.Elab.Term.Do.homogenize, Lean.Elab.Term.TermElabM, Lean.Elab.Term.Do.CodeBlock, Pure.pure, Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.ite, Lean.Elab.Term.Do.CodeBlock.code, Lean.Elab.Term.Do.CodeBlock.uvars]]
[Bool.or_self,[rfl, Eq.symm, Eq.refl]]
[Decidable.le_iff_lt_or_eq,[Iff.intro, Decidable.lt_or_eq_of_le, le_of_lt_or_eq]]
[Lean.IR.isTailCallTo,[Lean.IR.FnBody.vdecl, Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.fap, Lean.IR.FnBody.jdecl, Lean.IR.FnBody.set, Lean.IR.FnBody.setTag, Lean.IR.FnBody.uset, Lean.IR.FnBody.sset, Lean.IR.FnBody.inc, Lean.IR.FnBody.dec, Lean.IR.FnBody.del, Lean.IR.FnBody.mdata, Lean.IR.FnBody.case, Lean.IR.FnBody.ret, Lean.IR.Arg.irrelevant, Lean.IR.FnBody.jmp, Lean.IR.FnBody.unreachable, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Bool, and, BEq.beq, Bool.false]]
[instHashableInt,[Hashable.mk, UInt64, UInt64.ofNat, HMul.hMul, OfNat.ofNat, HAdd.hAdd]]
[Lean.Parser.Term.forInMacro.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec]]
[Lean.Declaration.inductDecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instSubsingletonDecidable,[instSubsingletonDecidable.proof_1]]
[Lean.instEvalIO,[Lean.Eval.mk, Bind.bind, Unit.unit, Lean.Eval.eval, Bool.true]]
[Lean.Elab.Deriving.DecEq.mkMatch,[Bind.bind, Lean.Elab.Deriving.mkDiscrs, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.Elab.Deriving.DecEq.mkMatch.mkSameCtorRhs, Lean.Elab.Deriving.DecEq.mkMatch.mkAlts]]
[ExceptT.ext,[id]]
[Lean.Elab.Term.ToParserDescrContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.explicitUniv.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkStackTop.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.levelParser.parenthesizer, Bool.false]]
[Lean.Parser.Term.doReturn.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.checkLineEq.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Lean.Parser.Term.matchDiscr,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.atomic, Lean.Parser.Term.ident, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, Lean.Parser.termParser]]
[as_false,[ite, False, True]]
[ofNat_eq_ofNat,[rfl]]
[ExceptCpsT.instMonadExceptCpsT,[Monad.mk]]
[pow_mul,[of_eq_true, Eq.trans, congr, congrArg, Eq, HPow.hPow, HMul.hMul, Nat.zero_eq, Nat.mul_zero, pow_zero, eq_self, OfNat.ofNat, Eq.mpr, Eq.refl, Nat.succ, Nat.mul_succ, HAdd.hAdd, pow_add, pow_succ', pow_mul_comm, rfl]]
[Equiv.refl,[Equiv.mk, id, Equiv.refl.proof_1, Equiv.refl.proof_2]]
[Lean.Syntax.asNode,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.SyntaxNode, Subtype.mk, Lean.Syntax.node, Lean.IsNode.mk, Lean.mkNullNode, List.toArray, List.nil, Lean.Syntax.asNode.proof_1]]
[Lean.Parser.Term.binrel_no_prop.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec]]
[Lean.Parser.Command.declaration.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Command.declModifiers.formatter, Bool.false, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.abbrev.formatter, Lean.Parser.Command.def.formatter, Lean.Parser.Command.theorem.formatter, Lean.Parser.Command.constant.formatter, Lean.Parser.Command.instance.formatter, Lean.Parser.Command.axiom.formatter, Lean.Parser.Command.example.formatter, Lean.Parser.Command.inductive.formatter, Lean.Parser.Command.classInductive.formatter, Lean.Parser.Command.structure.formatter]]
[Lean.IR.Borrow.mkInitParamMap,[StateT.run', SeqRight.seqRight, Lean.IR.Borrow.InitParamMap.visitDecls, MonadState.get, EmptyCollection.emptyCollection]]
[Lean.throwError,[Bind.bind, Lean.MonadRef.getRef, Lean.AddErrorMessageContext.add, MonadExcept.throw, Lean.Exception.error]]
[Lean.Meta.SimpEntry.lemma.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.set_option,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident, Lean.Parser.ppSpace, Lean.Parser.Command.optionValue, Lean.Parser.Tactic.tacticSeq]]
[Lean.Meta.CongrTheorem.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.EmitC.getJPParams,[Bind.bind, MonadReader.read, Unit.unit, Lean.IR.EmitC.M, Array, Lean.IR.Param, Std.HashMap.find?, Lean.IR.EmitC.Context.jpMap, Pure.pure, MonadExcept.throw]]
[Lean.Server.Watchdog.watchdogMain,[Bind.bind, liftM, IO.getStdin, IO.getStdout, IO.getStderr, MonadExcept.tryCatch, Lean.Server.Watchdog.initAndRunWatchdog, Pure.pure, OfNat.ofNat, IO.FS.Stream.putStrLn, HAppend.hAppend, ToString.toString]]
[Lean.IR.IRType.usize.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.Cache.defEqDefault,[]]
[Lean.Parser.Term.depArrow.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Lean.Parser.unicodeSymbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.StructureFieldInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.StructureFieldInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.NameHashSet.instInhabitedNameHashSet,[Inhabited.mk, EmptyCollection.emptyCollection]]
[UInt16.mod,[UInt16.mk, HMod.hMod, UInt16.val]]
[Lean.Lsp.SemanticTokens.data,[]]
[Lean.instReprMetavarKind,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone]]
[Lean.Meta.Simp.Context.mk.inj,[And.intro]]
[Lean.PrettyPrinter.Formatter.errorAtSavedPos.formatter,[Pure.pure, Unit.unit]]
[Lean.DelayedMetavarAssignment.noConfusionType,[]]
[Lean.Elab.Term.Do.ToTerm.breakToTerm,[Bind.bind, MonadReader.read, Lean.Elab.Term.Do.ToTerm.mkUVarTuple, Unit.unit, Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax, Lean.Elab.Term.Do.ToTerm.Context.kind, panicWithPosWithDecl, OfNat.ofNat, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom]]
[Lean.Lsp.DocumentSymbolParams.textDocument,[]]
[Semiring.nsmul,[]]
[Option.isNone,[Unit.unit, Bool, Bool.false, Bool.true]]
[Semiring.noConfusionType,[]]
[Lean.Parser.Tactic.eraseAuxDiscrs,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.maxPrec, Lean.Parser.symbol]]
[Lean.Server.FileWorker.handleRpcRelease,[Bind.bind, MonadState.get, Option.none, Lean.Server.FileWorker.WorkerM, Unit, Std.RBMap.find?, Lean.Server.FileWorker.WorkerState.rpcSessions, Lean.Lsp.RpcReleaseParams.sessionId, ST.Ref.get, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield, liftM, Lean.Server.FileWorker.RpcSession.keptAlive, ST.Ref.set]]
[Mathlib.Tactic.Lint.formatLinterResults,[Bind.bind, Array.filterMapM, Lean.Core.CoreM, Option, Lean.MessageData, ite, Eq, not, Std.HashMap.isEmpty, Bool.true, Mathlib.Tactic.Lint.groupedByFilename, Mathlib.Tactic.Lint.printWarnings, Mathlib.Tactic.Lint.LintVerbosity.high, Pure.pure, Option.some, HAppend.hAppend, Lean.ToMessageData.toMessageData, Mathlib.Tactic.Lint.Linter.noErrorsFound, Mathlib.Tactic.Lint.NamedLinter.toLinter, Option.none, OfNat.ofNat, Array.size, Array.filterM, Mathlib.Tactic.Lint.isAutoDecl]]
[Lean.Parser.Command.notation,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.attrKind, Lean.Parser.symbol, Lean.Parser.optPrecedence, Lean.Parser.Command.optNamedName, Lean.Parser.Command.optNamedPrio, Lean.Parser.many, Lean.Parser.Command.notationItem, Lean.Parser.darrow, Lean.Parser.termParser]]
[Lean.BinderInfo.toUInt64,[Unit.unit, UInt64, OfNat.ofNat]]
[Setoid.trans,[Equivalence.trans, Setoid.iseqv]]
[Lean.Elab.Term.SavedContext.openDecls,[]]
[instAndOpUInt16,[AndOp.mk, UInt16.land]]
[Lean.Lsp.SemanticTokensRangeParams.range,[]]
[Lean.getPPSafeShadowing,[Lean.KVMap.get, Lean.Option.name, Lean.pp.safeShadowing, Lean.Option.defValue]]
[Lean.Meta.instMonadLCtxMetaM,[Lean.MonadLCtx.mk, Bind.bind, MonadReader.read, Pure.pure, Lean.Meta.Context.lctx]]
[Lean.JsonRpc.ErrorCode.methodNotFound.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[List.toByteArray,[ByteArray.empty, List.toByteArray.loop]]
[UInt64.val_eq_of_lt,[Fin.val_eq_of_lt]]
[Lean.Parser.Tactic.elementwise!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const]]
[Lean.Elab.Command.runLinters,[Bind.bind, ST.Ref.get, Lean.Elab.Command.lintersRef, ite, Eq, Array.isEmpty, Bool.true, Pure.pure, PUnit.unit, ForIn.forIn, MonadState.get, tryFinally, MonadExcept.tryCatch, Lean.Elab.logException, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, ForInStep.yield]]
[Lean.DataValue.sameCtor,[Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Bool, Bool.true, Bool.false]]
[Lean.Lsp.SemanticTokenType.toCtorIdx,[OfNat.ofNat]]
[Lean.Parser.ParserCache.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.ParserCache.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.ModuleParserState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.mkIdent,[Lean.Syntax.ident, List.nil]]
[Lean.Elab.Term.mkAuxName,[Bind.bind, MonadReader.read, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Name, Lean.Elab.Term.Context.declName?, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.mkAuxName, HAppend.hAppend, OfNat.ofNat]]
[Mathlib.Tactic.Lint.instReprLintVerbosity,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone]]
[Lean.Parser.Command.structure.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.structureTk.parenthesizer, Lean.Parser.Command.classTk.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Bool.false, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.extends.parenthesizer, Lean.Parser.Term.optType.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.structCtor.parenthesizer, Lean.Parser.Command.structFields.parenthesizer, Lean.Parser.Command.optDeriving.parenthesizer]]
[Lean.Elab.Term.withSynthesize,[MonadFunctorT.monadMap, Bind.bind, MonadState.get, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, List.nil, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState, tryFinally, Lean.Elab.Term.synthesizeSyntheticMVars, Bool.false, ite, Eq, and, Bool.true, Pure.pure, PUnit.unit, HAppend.hAppend, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.TermElabM]]
[Lean.Declaration.axiomDecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.LetRecToLift.mvarId,[]]
[Lean.Lsp.ServerCapabilities.referencesProvider,[]]
[reprArg,[Repr.reprPrec, OfNat.ofNat]]
[Lean.Parser.Tactic.hGeneralize!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.binderIdent, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser]]
[USize.instSemiringUSize.proof_11,[Eq.mpr, congr, congrArg, Eq, Eq.trans, HMul.hMul, USize.add_def, USize.mul_def, USize.mk, HAdd.hAdd, USize.val, USize.eq_of_val_eq, Semiring.mul_add]]
[Lean.Lsp.TextDocumentContentChangeEvent.rangeChange.inj,[And.intro]]
[Lean.IR.Expr.hasFreeVar,[Lean.IR.HasIndex.visitExpr, Lean.IR.VarId.idx]]
[Lean.Lsp.instToJsonSemanticTokensLegend,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.SemanticTokensLegend.tokenTypes, List.nil, Lean.Lsp.SemanticTokensLegend.tokenModifiers]]
[Lean.RecursorVal.k,[]]
[USize.sub_def,[rfl]]
[Lean.Elab.Command.«termDelta%_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.Term.TermElabResult,[EStateM.Result, Lean.Exception, Lean.Elab.Term.SavedState]]
[Lean.Parser.Term.doCatch,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.Term.binderIdent, Lean.Parser.optional, Lean.Parser.termParser, Lean.Parser.darrow, Lean.Parser.Term.doSeq]]
[Lean.Parser.Command.structure,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, HOrElse.hOrElse, Lean.Parser.Command.structureTk, Lean.Parser.Command.classTk, Lean.Parser.Command.declId, Lean.Parser.many, Lean.Parser.ppSpace, Lean.Parser.Term.bracketedBinder, Bool.false, Lean.Parser.optional, Lean.Parser.Command.extends, Lean.Parser.Term.optType, Lean.Parser.symbol, Lean.Parser.Command.structCtor, Lean.Parser.Command.structFields, Lean.Parser.Command.optDeriving]]
[CoeSort.noConfusionType,[]]
[Lean.Elab.Term.LVal.getOp.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LVal.getOp, Eq.symm, eq_of_heq, HEq.refl]]
[instReprUnit,[Repr.mk, Std.Format.text]]
[Lean.Elab.Term.elabEnsureTypeOf,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Syntax.isStrLit?, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.throwIllFormedSyntax, Bind.bind, Lean.Elab.Term.elabTerm, Option.none, Bool.true, liftM, Lean.Meta.inferType, Lean.Elab.Term.elabTermEnsuringType, Option.some]]
[Lean.Message.severity,[]]
[IO.Error.inappropriateType.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.export.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.many1.parenthesizer]]
[Lean.Elab.Tactic.expandOptLocation,[ite, Eq, Lean.Syntax.isNone, Bool.true, Lean.Elab.Tactic.Location.targets, List.toArray, List.nil, Lean.Elab.Tactic.expandLocation, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Parser.Tactic.Conv.convArgs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Int.neg_zero,[rfl]]
[Lean.Elab.DerivingClassView.applyHandlers,[Lean.withRef, Lean.Elab.DerivingClassView.ref, Lean.Elab.applyDerivingHandlers, Lean.Elab.DerivingClassView.className, Lean.Elab.DerivingClassView.args?]]
[Lean.Parser.Tactic.tacticTrivial,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Elab.Info.ofCommandInfo.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Info.ofCommandInfo, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.EnvironmentHeader.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.GoalsAtResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.GoalsAtResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.optSemicolon,[Lean.Parser.ppDedent, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.symbol, Lean.Parser.ppLine]]
[Setoid.refl,[Equivalence.refl, Setoid.iseqv]]
[Lean.Lsp.DeclarationParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.Delaborator.delabSigma,[Lean.PrettyPrinter.Delaborator.delabSigmaCore, Bool.true]]
[decidable_of_decidable_of_eq,[decidable_of_decidable_of_iff, Eq.to_iff]]
[Lean.Parsec.pure,[Lean.Parsec.ParseResult.success]]
[Lean.Expr.ReplaceLevelImpl.cache,[Bind.bind, modify, Lean.Expr.ReplaceLevelImpl.State.mk, Array.uset, Lean.Expr.ReplaceLevelImpl.State.keys, Lean.Expr.ReplaceLevelImpl.cache.proof_1, Lean.Expr.ReplaceLevelImpl.State.results, Lean.Expr.ReplaceLevelImpl.cache.proof_2, Pure.pure]]
[Lean.Meta.DiscrTree.Trie.noConfusionType,[]]
[Lean.Parser.throwUnknownParserCategory,[MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Subrelation.accessible.proof_1,[Acc.intro]]
[instBEqOption,[BEq.mk, Unit.unit, Option.none, Option.some, Bool, Bool.true, and, BEq.beq, Bool.false]]
[Iff.comm,[Iff.intro, Iff.symm]]
[Lean.Meta.FunInfoCache,[Std.PersistentHashMap, Lean.Meta.InfoCacheKey, Lean.Meta.FunInfo]]
[implies.trans,[]]
[System.SearchPath.separator,[ite, Eq, System.Platform.isWindows, Bool.true, Char.ofNat]]
[Lean.Parser.optPrecedence,[Lean.Parser.optional, Lean.Parser.atomic, Lean.Parser.precedence]]
[Std.RBTree.insert,[Std.RBMap.insert, Unit.unit]]
[Lean.Meta.CaseValuesSubgoal.mvarId,[]]
[imp_and_distrib,[Iff.intro, And.intro, And.left, And.right]]
[List.mem_erase_of_ne,[Eq.mpr, Eq.refl, Iff, Mem.mem, List.erase, List.erase_eq_erasep, List.mem_erasep_of_neg, Ne.symm]]
[Lean.Lsp.CancelParams.mk.inj,[]]
[Lean.addProjectionFnInfo,[Lean.MapDeclarationExtension.insert, Lean.projectionFnInfoExt, Lean.ProjectionFunctionInfo.mk]]
[Lean.IR.mmodifyJPs,[Array.mapM, Lean.IR.FnBody.vdecl, Lean.IR.FnBody.set, Lean.IR.FnBody.setTag, Lean.IR.FnBody.uset, Lean.IR.FnBody.sset, Lean.IR.FnBody.inc, Lean.IR.FnBody.dec, Lean.IR.FnBody.del, Lean.IR.FnBody.mdata, Lean.IR.FnBody.case, Lean.IR.FnBody.ret, Lean.IR.FnBody.jmp, Lean.IR.FnBody.unreachable, Lean.IR.FnBody, Bind.bind, Pure.pure, Lean.IR.FnBody.jdecl]]
[Lean.Parser.Command.decreasingBy.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.terminationHint.formatter, Lean.Parser.Tactic.tacticSeq.formatter]]
[Lean.IR.EmitC.Context.env,[]]
[Lean.Elab.Tactic.evalInjections,[Lean.Elab.Tactic.liftMetaTactic, Bind.bind, Lean.Meta.injections, OfNat.ofNat, Unit.unit, Lean.Meta.MetaM, List, Lean.MVarId, Pure.pure, List.nil, List.cons]]
[IO.Process.output,[Bind.bind, IO.Process.spawn, IO.Process.SpawnArgs.mk, IO.Process.StdioConfig.mk, IO.Process.StdioConfig.stdin, IO.Process.SpawnArgs.toStdioConfig, IO.Process.Stdio.piped, IO.Process.SpawnArgs.cmd, IO.Process.SpawnArgs.args, IO.Process.SpawnArgs.cwd, IO.Process.SpawnArgs.env, liftM, IO.asTask, IO.FS.Handle.readToEnd, IO.Process.Child.stdout, Task.Priority.dedicated, IO.Process.Child.stderr, IO.Process.Child.wait, IO.ofExcept, Task.get, Pure.pure, IO.Process.Output.mk]]
[Nat.«term_^[_]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.LocalInstance.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.ParserInfo.mk.inj,[And.intro]]
[Lean.IR.Decl.extern.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.Context.mk.inj,[And.intro]]
[Lean.Parser.ParserState.next,[Lean.Parser.ParserState.mk, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.lhsPrec, String.next, Lean.Parser.ParserState.cache, Lean.Parser.ParserState.errorMsg]]
[Lean.Xml.Parser.SystemLiteral,[HOrElse.hOrElse, SeqLeft.seqLeft, SeqRight.seqRight, Lean.Parsec.pchar, Char.ofNat, Lean.Parsec.manyChars, Lean.Parsec.satisfy, Decidable.decide, Ne, Pure.pure]]
[Lean.Lsp.Trace.toCtorIdx,[OfNat.ofNat]]
[ExistsUnique.intro,[Exists.intro, And.intro]]
[Lean.LeanPaths.srcPath,[]]
[Lean.Expr.Data.hasExprMVar,[BEq.beq, UInt64.land, UInt64.shiftRight, OfNat.ofNat]]
[Nat.gcd_succ,[rfl]]
[Lean.Expr.natAdd?,[Lean.Expr.app2?, Lean.Name.mkStr, Lean.Name.anonymous]]
[Fin.instOfNatFinHAdd,[OfNat.mk, Fin.ofNat]]
[forall₂_congr,[forall_congr']]
[Exists.choose_spec,[Classical.choose_spec]]
[Lean.Elab.Term.instMonadMacroAdapterTermElabM,[Lean.Elab.MonadMacroAdapter.mk, Lean.MonadQuotation.getCurrMacroScope, Bind.bind, getThe, Lean.Core.State, Pure.pure, Lean.Core.State.nextMacroScope, modifyThe, Lean.Core.State.mk, Lean.Core.State.env, Lean.Core.State.ngen, Lean.Core.State.traceState]]
[Lean.Lsp.instToJsonDefinitionParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.DefinitionParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position]]
[Lean.SMap.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.SMap.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Int.negOfNat_eq_subNatNat_zero,[Unit.unit, Eq, Int.negOfNat, Int.subNatNat, OfNat.ofNat, rfl]]
[Lean.Parser.Priority.numPrio,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.numLit]]
[Lean.Parser.Level.max,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.nonReservedSymbol, Lean.Parser.many1, Lean.Parser.ppSpace, Lean.Parser.levelParser, Lean.Parser.maxPrec]]
[Lean.Meta.Simp.Methods.mk.inj,[And.intro]]
[Lean.Elab.Command.elabAxiom,[Lean.Elab.Command.CommandElabM, Unit, Bind.bind, Lean.Elab.Command.getLevelNames, Lean.Elab.Command.expandDeclId, Lean.Elab.addDeclarationRanges, Lean.Elab.Command.runTermElabM, Option.some, Lean.Elab.Term.withLevelNames, Lean.Elab.Term.elabBinders, Lean.Syntax.getArgs, Lean.Elab.Term.applyAttributesAt, Lean.Elab.Modifiers.attrs, Lean.AttributeApplicationTime.beforeElaboration, Lean.Elab.Term.elabType, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Bool.false, liftM, Lean.Meta.instantiateMVars, Lean.Meta.mkForallFVars, Bool.true, Lean.Elab.Term.levelMVarToParam, OfNat.ofNat, Lean.Elab.Term.TermElabM, Lean.Elab.sortDeclLevelParams, Lean.throwErrorAt, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Elab.Term.ensureNoUnassignedMVars, Lean.addDecl, Lean.Elab.withSaveInfoContext, Lean.mkConstWithLevelParams, Lean.Elab.Term.addTermInfo, Option.none, Lean.Name.anonymous, Lean.AttributeApplicationTime.afterTypeChecking, Lean.MonadEnv.getEnv, ite, Eq, Lean.isExtern, Lean.compileDecl, Pure.pure, PUnit.unit]]
[Lean.SyntaxNode.getIdAt,[Lean.Syntax.getId, Lean.SyntaxNode.getArg]]
[Subtype.exists,[Iff.intro, Exists, Subtype.mk, Exists.intro]]
[Lean.LevelSet,[Std.HashSet, Lean.Level]]
[Lean.PrettyPrinter.Delaborator.unexpandRegularApp,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Pure.pure, Lean.PrettyPrinter.Delaborator.unfoldMDatas, Lean.Expr.getAppFn, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Lean.MonadEnv.getEnv, Lean.KeyedDeclsAttribute.getValues, Lean.PrettyPrinter.Delaborator.appUnexpanderAttribute, List.firstM, EStateM.Result.error, EStateM.run, Unit.unit, Alternative.failure, panicWithPosWithDecl, OfNat.ofNat]]
[List.intersperse,[Unit.unit, List.cons, List, List.nil, PProd.fst]]
[Lean.Elab.Command.Scope.header,[]]
[Lean.Expr.getForallBody,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, PProd.fst, PProd.snd]]
[Lean.Meta.SynthInstance.MkTableKey.State.emap,[]]
[Lean.Meta.Match.Problem.noConfusionType,[]]
[Lean.Lsp.TextDocumentEdit.edits,[]]
[Lean.Meta.SortLocalDecls.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Simp.Config.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Simp.Config.mk, Eq.symm, eq_of_heq, HEq.refl]]
[FloatArray.instEmptyCollectionFloatArray,[EmptyCollection.mk, FloatArray.empty]]
[Int.subNatNat_eq_coe,[Int.subNatNat_elim, Eq, HSub.hSub, Int.ofNat, Eq.mpr, congrArg, Eq.trans, congrFun, Int.ofNat_add, Int.sub_eq_add_neg, Int.add_assoc, Neg.neg, Int.add_left_comm, HAdd.hAdd, Int.add_right_neg, rfl, congr, Int.negSucc_ofNat_coe, OfNat.ofNat, Int.neg_add, Eq.symm, Eq.refl, Int.ofNat_sub, Nat.le_refl, Nat.sub_self, Int.ofNat_zero, Int.zero_add]]
[Mathlib.Tactic.Lint.getAllDecls,[Bind.bind, Mathlib.Tactic.Lint.getDeclsInCurrModule, Lean.MonadEnv.getEnv, Pure.pure, HAppend.hAppend, Array.map, Prod.fst, Std.HashMap.toArray, Lean.SMap.map₁, Lean.Environment.constants]]
[Nat.add_sub_of_le,[Eq, HAdd.hAdd, HSub.hSub, Eq.mpr, Eq.refl, Eq.symm, Nat.add_sub_cancel_left, rfl]]
[Lean.Parser.Tactic.Conv.nestedTacticCore,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Prod.RProdSubLex,[Prod.RProdSubLex.proof_1]]
[Lean.Server.FileWorker.handleNotification,[dite, Eq, Unit.unit, Eq.symm, Lean.Server.FileWorker.WorkerM, Unit, Lean.Lsp.DidChangeTextDocumentParams, Lean.Lsp.instFromJsonDidChangeTextDocumentParams, Lean.Server.FileWorker.handleDidChange, Lean.Lsp.CancelParams, Lean.Lsp.instFromJsonCancelParams, Lean.Server.FileWorker.handleCancelRequest, Lean.Lsp.RpcReleaseParams, Lean.Lsp.instFromJsonRpcReleaseParams, Lean.Server.FileWorker.handleRpcRelease, Lean.Lsp.RpcKeepAliveParams, Lean.Lsp.instFromJsonRpcKeepAliveParams, Lean.Server.FileWorker.handleRpcKeepAlive, liftM, IO.throwServerError, HAppend.hAppend, ToString.toString]]
[Lean.Elab.Term.Do.DoIfView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Expr.withAppRev,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, PProd.fst, Array.push, Array.mkEmpty, Lean.Expr.getAppNumArgs]]
[Lean.Parser.Term.termBeforeDo.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withForbidden.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Lean.Elab.Term.MVarErrorKind.custom.inj,[]]
[Lean.Elab.elabDeclAttrs,[Lean.Elab.elabAttrs, Lean.Syntax.getSepArgs, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Parser.Tactic.tidy?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Lsp.TextDocumentIdentifier.uri,[]]
[Tactic.Ring.Cache.cs,[]]
[Lean.Parser.Term.namedArgument,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.termParser]]
[Lean.IR.findEnvDecl',[Unit.unit, Option, Lean.IR.Decl, Array.find?, BEq.beq, Lean.IR.Decl.name, Option.some, Lean.SMap.find?, Lean.SimplePersistentEnvExtension.getState, Lean.IR.declMapExt]]
[Lean.Meta.injections,[Lean.Meta.withMVarContext, Bind.bind, Lean.MonadLCtx.getLCtx, Array.toList, Lean.Meta.injections.go]]
[Lean.Parser.Term.waitIfTypeContainsMVar.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.Server.FileWorker.SemanticTokensContext.snap,[]]
[instCommMonoid_1.proof_3,[Semiring.npow_zero']]
[Lean.Parser.Tactic.tauto!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Term.dbgTrace.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.interpolatedStr.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Lean.Parser.Term.optSemicolon.parenthesizer]]
[Lean.Meta.mkHEqSymm,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.heq?, Lean.Meta.getLevel, Lean.mkApp5, Lean.mkConst, List.cons, List.nil, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr]]
[Lean.Level.PP.Result.imaxNode.inj,[]]
[Lean.Elab.Term.StructInst.Struct.mk.sizeOf_spec,[congrFun, congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.refl, List.nil, Eq.trans, congr, Lean.Elab.Term.StructInst.FieldVal.term, Lean.Elab.Term.StructInst.FieldVal.nested, Lean.Elab.Term.StructInst.FieldVal.default, Eq.symm, Lean.Elab.Term.StructInst.Field.mk.sizeOf_spec, List.cons.sizeOf_spec]]
[Std.PersistentArray.Stats.mk.inj,[And.intro]]
[Lean.DefinitionSafety.safe.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[modifyThe,[MonadStateOf.modifyGet, Prod.mk, PUnit.unit]]
[Lean.Xml.Parser.EncodingDecl,[Bind.bind, SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Parsec.skipString, Lean.Xml.Parser.Eq, Lean.Xml.Parser.quote, Lean.Xml.Parser.EncName]]
[Lean.Parser.Tactic.expandRwSeq,[Lean.Parser.Tactic.rwWithRfl, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Meta.FVarIdToLemmaId,[Lean.FVarIdMap, Lean.Name]]
[Lean.IR.mkParam,[Lean.IR.Param.mk]]
[USize.instRingUSize.proof_3,[congrArg, USize.mk, Ring.gsmul_succ', USize.val]]
[Lean.Lsp.DocumentSymbolResult.syms,[]]
[Lean.QuotVal.kind,[]]
[Lean.Parser.Command.declSig.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.simpleBinderWithoutType.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Bool.false, Lean.Parser.Term.typeSpec.parenthesizer]]
[Lean.getPPStructureInstances,[Lean.KVMap.get, Lean.Option.name, Lean.pp.structureInstances, not, Lean.getPPAll]]
[Int.instOfNatInt,[OfNat.mk, Int.ofNat]]
[Lean.Lsp.instFileSourceHoverParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.HoverParams.toTextDocumentPositionParams]]
[String.Iterator.curr,[Char, String.get]]
[Lean.Meta.mkLevelErrorMessage,[Unit.unit, Lean.Meta.MetaM, Lean.MessageData, Lean.Meta.PostponedEntry.ctx?, Pure.pure, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.Meta.PostponedEntry.lhs, Lean.Meta.PostponedEntry.rhs, Lean.Meta.withLCtx, Lean.Meta.DefEqContext.lctx, Lean.Meta.DefEqContext.localInstances, Bind.bind, Lean.Meta.instantiateMVars, Lean.Meta.DefEqContext.lhs, Lean.Meta.DefEqContext.rhs, MonadExcept.tryCatch, Lean.Meta.inferType, Lean.AddMessageContext.addMessageContext, Lean.MessageData.ofExpr]]
[Lean.Lsp.DocumentSymbolAux.range,[]]
[Lean.EnvExtension,[Lean.EnvExtensionInterface.ext, Lean.EnvExtensionInterfaceImp]]
[Lean.Parser.Command.abbrev.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.Command.optDeclSig.formatter, Lean.Parser.Command.declVal.formatter]]
[List.mem_nil_iff,[Iff.rfl]]
[Function.comp_const_right,[rfl]]
[Lean.Meta.SynthInstance.State.mk.inj,[And.intro]]
[Lean.Parser.Term.matchAltsWhereDecls.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.whereDecls.parenthesizer]]
[Lean.MonadHashMapCacheAdapter.getCache,[]]
[Lean.PrettyPrinter.runForNodeKind,[Bind.bind, Lean.MonadEnv.getEnv, List.nil, Lean.Core.CoreM, Lean.KeyedDeclsAttribute.getValues, Pure.pure, Lean.getConstInfo, ite, Eq, or, Lean.Expr.isConstOf, Lean.ConstantInfo.type, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.evalConst, Lean.ParserDescr, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.KeyedDeclsAttribute.Def.name, Lean.KeyedDeclsAttribute.defn]]
[Lean.IR.Expr.sproj.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.sproj, Eq.symm, eq_of_heq, HEq.refl]]
[instDecidableLe_3,[UInt64.decLe]]
[Lean.Core.instMonadLiftIOCoreM,[MonadLift.mk, Lean.Core.liftIOCore]]
[Nat.decidable_dvd.proof_1,[Iff.symm, Nat.dvd_iff_mod_eq_zero]]
[Lean.Parser.PrattParsingTables.mk.inj,[And.intro]]
[Lean.Elab.Term.Do.mkJmp,[Bind.bind, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.liftMacroM, Lean.mkIdentFrom, Lean.Elab.Term.Do.addFreshJP, Pure.pure, Lean.Elab.Term.Do.Code.jmp]]
[Lean.Compiler.SpecArgKind.fixedNeutral.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Nat.coprime_zero_left,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, Eq, Nat.gcd_zero_left, OfNat.ofNat, iff_self]]
[Lean.Meta.AbstractNestedProofs.State.noConfusionType,[]]
[Except.ok.injEq,[Eq.propIntro, Eq.refl, Except.ok, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.BinderInfo.isStrictImplicit,[Lean.BinderInfo.default, Lean.BinderInfo.implicit, Unit.unit, Lean.BinderInfo.instImplicit, Lean.BinderInfo.auxDecl, Bool, Bool.true, Bool.false]]
[Lean.Elab.Command.CollectAxioms.State.mk.inj,[And.intro]]
[Lean.AttributeImpl.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Match.Pattern.ibelow,[True, And]]
[Lean.Meta.Match.Example.arrayLit.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Example.arrayLit, Eq.symm, eq_of_heq, HEq.refl]]
[heq_of_heq_of_eq,[HEq.trans, heq_of_eq]]
[Lean.PrettyPrinter.Delaborator.delabFVar,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, MonadExcept.tryCatch, liftM, Lean.Meta.getLocalDecl, Lean.PrettyPrinter.Delaborator.maybeAddBlockImplicit, Lean.mkIdent, Lean.LocalDecl.userName, Lean.FVarId.name, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.ScopedEnvExtension.Entry.global.inj,[]]
[Lean.Declaration.foldExprM,[Unit.unit, Pure.pure, Bind.bind, List.foldlM, Lean.ConstantVal.type, Lean.DefinitionVal.toConstantVal, Lean.DefinitionVal.value, Lean.InductiveType.type, Lean.Constructor.type, Lean.InductiveType.ctors]]
[Lean.IR.Checker.markJP,[Lean.IR.Checker.markIndex, Lean.IR.JoinPointId.idx]]
[Lean.ClassEntry.hasOutParam,[]]
[Lean.Lsp.MarkupContent.noConfusionType,[]]
[Lean.Parser.Command.resolve_name.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter]]
[Lean.Xml.Content.Comment.inj,[]]
[Lean.Level.hasParamEx,[Lean.Level.hasParam]]
[Lean.Elab.Term.Do.Code.return.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.explicitBoxing,[Bind.bind, Lean.IR.getEnv, Pure.pure, Lean.IR.ExplicitBoxing.run]]
[Nat.mul_assoc,[Eq, HMul.hMul, rfl]]
[Lean.Lsp.TextDocumentChangeRegistrationOptions.noConfusionType,[]]
[Lean.Parser.Tactic.casesType!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser]]
[Lean.Exception.internal.inj,[And.intro]]
[Std.PersistentHashMap.Stats.maxDepth,[]]
[Lean.Meta.Simp.Step.result,[Lean.Meta.Simp.Result]]
[coeSortToCoeTail,[CoeTail.mk, CoeSort.coe]]
[Semiring.nsmul_zero',[]]
[Or.imp_left,[Or.imp, id]]
[Lean.Parser.Tactic.async,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser]]
[Lean.MessageData.nest.inj,[And.intro]]
[Function.inv_fun_on_pos,[]]
[strictAnd,[and]]
[Nat.lt_add_of_pos_left,[Eq.mpr, Eq.refl, LT.lt, HAdd.hAdd, Nat.add_comm, Nat.lt_add_of_pos_right]]
[UInt32.instSemiringUInt32.proof_8,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt32.one_def, UInt32.mul_def, UInt32.mk, OfNat.ofNat, mul_one, UInt32.val, UInt32.mk_val_eq, eq_self, propext, forall_const, UInt32]]
[Lean.LocalDecl.ldecl.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.LocalDecl.ldecl, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Tactic.Conv.mkConvGoalFor,[Bind.bind, Lean.Meta.inferType, Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.natural, Lean.Name.anonymous, Lean.Meta.mkEq, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Pure.pure, Prod.mk]]
[Lean.Lsp.Location.noConfusionType,[]]
[instReprSubstring,[Repr.mk, Std.Format.text, HAppend.hAppend, String.quote, Substring.toString]]
[Lean.Lsp.SemanticTokensOptions.range,[]]
[«term_∪_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.throwTypeExcepted,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr]]
[Nat.lt_trans,[Nat.le_trans, Nat.le_step]]
[Lean.Elab.Tactic.ElimApp.State.noConfusionType,[]]
[USize.instAddCommSemigroupUSize.proof_1,[congrArg, USize.mk, AddCommSemigroup.add_comm, USize.val]]
[Lean.Elab.Tactic.Conv.getLhs,[Bind.bind, Lean.Elab.Tactic.Conv.getLhsRhs, Pure.pure, Prod.fst]]
[Lean.Parser.Term.doSeqBracketed.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withoutPosition.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.doSeqItem.parenthesizer, Lean.Parser.ppLine.parenthesizer]]
[Preorder.le_trans,[]]
[List.leftpad_length,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.length_append, List.repeat, HSub.hSub, List.length, HAdd.hAdd, List.length_repeat, Nat.sub_add_eq_max, max, eq_self]]
[Function.injective.dite,[]]
[Lean.PrettyPrinter.Delaborator.delabMData,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Option.none, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Lean.inaccessible?, Lean.PrettyPrinter.Delaborator.SubExpr.withMDataExpr, Lean.PrettyPrinter.Delaborator.delab, MonadReader.read, ite, Eq, Lean.PrettyPrinter.Delaborator.Context.inPattern, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.MonadOptions.getOptions, and, Lean.isLetFun, Lean.getPPNotation, Lean.PrettyPrinter.Delaborator.delabLetFun, Lean.isLHSGoal?, Lean.PrettyPrinter.Delaborator.SubExpr.withAppFn, Lean.PrettyPrinter.Delaborator.SubExpr.withAppArg, Lean.PrettyPrinter.Delaborator.withMDataOptions]]
[Lean.Server.Watchdog.ServerEvent.workerEvent.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.Watchdog.ServerEvent.workerEvent, Eq.symm, eq_of_heq, HEq.refl]]
[cast_proof_irrel,[rfl]]
[Lean.Widget.MsgToInteractive.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Widget.MsgToInteractive.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Mathlib.Tactic.Lint.heuristicallyExtractSimpLemmas,[Mathlib.Tactic.Lint.heuristicallyExtractSimpLemmasCore, Mathlib.Tactic.Lint.constToSimpDeclMap]]
[Equiv.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Equiv.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.TermInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.TermInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Function.left_inverse.comp_eq_id,[funext]]
[Lean.Macro.withIncRecDepth,[Bind.bind, MonadReader.read, Unit.unit, Lean.MacroM, BEq.beq, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth, MonadExcept.throw, Lean.Macro.Exception.error, Lean.maxRecDepthErrorMessage, MonadWithReader.withReader, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope, HAdd.hAdd, OfNat.ofNat, Lean.Macro.Context.ref]]
[UInt8.instRingUInt8.proof_4,[congrArg, UInt8.mk, SubNegMonoid.gsmul_neg', UInt8.val]]
[Std.Format.instAppendFormat,[Append.mk, Std.Format.append]]
[Lean.Meta.modifyPostponed,[modify, Lean.Meta.State.mk, Lean.Meta.State.mctx, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed]]
[UInt32.instSemigroupUInt32,[Semigroup.mk, UInt32.instSemigroupUInt32.proof_1]]
[Lean.Elab.Term.isSaveInfoAnnotation?,[Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Elab.Frontend.getInputContext,[Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Frontend.Context.inputCtx]]
[Lean.Elab.Term.elabLetTmpDecl,[Lean.Elab.Term.elabLetDeclCore, Bool.true, Bool.false]]
[Lean.Meta.MatcherApp.uElimPos?,[]]
[LinearOrder.toPartialOrder,[]]
[Lean.Elab.Term.LValResolution.getOp.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.mkApp7,[Lean.mkApp3, Lean.mkApp4]]
[Lean.Elab.mkFreshInstanceName,[Lean.Name.appendIndexAfter, HAppend.hAppend, Lean.Environment.mainModule, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.IR.reshapeWithoutDead,[Lean.IR.FnBody.freeIndices, Lean.IR.reshapeWithoutDead.reshape]]
[Lean.Elab.DefViewElabHeader.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Function.uncurry_apply_pair,[rfl]]
[Lean.Parser.Tactic.rintroPat.quot,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[UInt64.shiftLeft,[UInt64.mk, HShiftLeft.hShiftLeft, UInt64.val, UInt64.modn, OfNat.ofNat]]
[Lean.isPrivateNameFromImportedModule,[Option.none, Bool, Lean.privateToUserName?, bne, Lean.mkPrivateName, Bool.false]]
[IO.Error.mkPermissionDeniedFile,[Function.comp, IO.Error.permissionDenied, Option.some]]
[String.mapTokens,[Function.comp, String.intercalate, String.singleton, List.map, String.split, Decidable.decide, Eq]]
[Lean.Elab.instToFormatAttribute,[Std.ToFormat.mk, Std.Format.bracket, HAppend.hAppend, Std.ToFormat.format, Lean.Elab.Attribute.name, ToString.toString, Lean.Elab.Attribute.stx]]
[Lean.Server.FileWorker.handleHover,[Bind.bind, Lean.Server.RequestM.readDoc, Lean.Server.RequestM.withWaitFindSnap, Decidable.decide, GT.gt, Lean.Server.Snapshots.Snapshot.endPos, Pure.pure, Option.none, Lean.Server.RequestM, Option, Lean.Lsp.Hover, Lean.Elab.InfoTree.hoverableInfoAt?, Lean.Server.Snapshots.Snapshot.infoTree, liftM, Lean.Elab.Info.fmtHover?, Option.some, ToString.toString, Option.get!, Lean.Elab.Info.pos?, Lean.Elab.Info.tailPos?, PUnit.unit]]
[Lean.getPPAnalyzeExplicitHoles,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.explicitHoles, Lean.Option.defValue]]
[Ne,[Not, Eq]]
[Lean.Meta.SynthInstance.wakeUp,[Unit.unit, Lean.Meta.SynthInstance.SynthM, Unit, ite, Eq, BEq.beq, Lean.Meta.AbstractMVarsResult.numMVars, Lean.Meta.SynthInstance.Answer.result, OfNat.ofNat, Bool.true, modify, Lean.Meta.SynthInstance.State.mk, Option.some, Lean.Meta.SynthInstance.State.generatorStack, Lean.Meta.SynthInstance.State.resumeStack, Lean.Meta.SynthInstance.State.tableEntries, Bind.bind, liftM, Lean.Meta.openAbstractMVarsResult, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Meta.SynthInstance.State.result?, Array.push, Prod.mk]]
[Lean.Lsp.SemanticTokensParams.mk.inj,[]]
[Function.curry_apply,[rfl]]
[String.replace,[OfNat.ofNat, String.replace.loop]]
[Lean.LocalDecl.cdecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.tryUnify,[MonadExcept.tryCatch, Bind.bind, liftM, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isDefEqAssigning, ite, Eq, not, Bool.true, modify, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.mk, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.annotations, Array.push, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.postponed, Prod.mk, Pure.pure, PUnit.unit]]
[Lean.Meta.modifyInferTypeCache,[Lean.Meta.modifyCache, Lean.Meta.Cache, Lean.Meta.Cache.mk]]
[Lean.Elab.Term.collectPatternVars,[Bind.bind, StateRefT'.run, Lean.Elab.Term.CollectPatternVars.main, Lean.Elab.Term.CollectPatternVars.State.mk, Lean.Elab.Term.TermElabM, Prod, Array, Lean.Elab.Term.PatternVar, Lean.Elab.Term.MatchAltView, Pure.pure, Prod.mk, Lean.Elab.Term.CollectPatternVars.State.vars]]
[Lean.Meta.IndPredBelow.BrecOnVariables.noConfusionType,[]]
[Lean.Lsp.instToJsonTextDocumentRegistrationOptions,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Lsp.TextDocumentRegistrationOptions.documentSelector?, List.nil]]
[Lean.resolveGlobalConst,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Syntax.ident, List, Lean.Name, ite, Eq, List.isEmpty, Bool.true, Lean.withRef, Lean.resolveGlobalConstCore, Pure.pure, Lean.throwErrorAt, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, ToString.toString]]
[Lean.Parser.Term.paren,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ppDedent, Lean.Parser.withoutPosition, Lean.Parser.withoutForbidden, Lean.Parser.optional, Lean.Parser.termParser, Lean.Parser.Term.parenSpecial]]
[Lean.Parser.Tactic.simp',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.Parser.Term.matchAlts,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.ppDedent, Lean.Parser.withPosition, Lean.Parser.many1Indent, HAndThen.hAndThen, Lean.Parser.ppLine, Lean.Parser.Term.matchAlt]]
[instIsAddLeftCancel,[IsAddLeftCancel.mk, instIsAddLeftCancel.proof_1]]
[Lean.IR.FreeIndices.Collector,[Lean.IR.IndexSet]]
[Array.mapIdxM,[Array.size, OfNat.ofNat, rfl, Array.mkEmpty, Array.mapIdxM.map]]
[Lean.Syntax.foldArgs,[Id.run, Lean.Syntax.foldArgsM]]
[Lean.ReducibilityHints.abbrev.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Command.State.maxRecDepth,[]]
[Lean.Meta.FVarSubst.insert,[ite, Eq, Lean.Meta.FVarSubst.contains, Bool.true, Lean.Meta.FVarSubst.mk, Std.AssocList.insert]]
[IO.FileRight.group,[]]
[Lean.DataValue.ofNat.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt64.noConfusionType,[]]
[Lean.Parser.categoryParserFn,[Lean.EnvExtension.getState, Lean.Parser.categoryParserFnExtension, Lean.Parser.ParserModuleContext.env, Lean.Parser.ParserContext.toParserModuleContext]]
[Lean.Parser.Term.assert.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Lean.Parser.Term.optSemicolon.parenthesizer]]
[Lean.Elab.Command.expandDeclNamespace?,[ite, Eq, not, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Option.none, or, BEq.beq, Unit.unit, Option, Prod, Lean.Name, Lean.Syntax, Lean.Elab.Command.expandDeclIdNamespace?, Lean.Syntax.getOp, OfNat.ofNat, Option.some, Prod.mk, Lean.Syntax.setArg, Lean.Syntax.isNone]]
[Lean.Lsp.WaitForDiagnosticsParams.uri,[]]
[Lean.Elab.Command.ElabStructResult.defaultAuxDecls,[]]
[Lean.IR.Borrow.collectDecl,[Lean.IR.Decl.extern, Lean.IR.Borrow.M, Unit, MonadWithReader.withReader, Lean.IR.Borrow.BorrowInfCtx.mk, Lean.IR.Borrow.BorrowInfCtx.env, Lean.IR.Borrow.BorrowInfCtx.decls, Lean.IR.Borrow.BorrowInfCtx.paramSet, Bind.bind, Lean.IR.Borrow.collectFnBody, Lean.IR.Borrow.updateParamMap, Lean.IR.Borrow.ParamMap.Key.decl, Pure.pure, Unit.unit]]
[Lean.Elab.Term.Do.ToCodeBlock.checkNotShadowingMutable,[Bind.bind, MonadReader.read, ForIn.forIn, PUnit.unit, ite, Eq, Lean.NameSet.contains, Lean.Elab.Term.Do.ToCodeBlock.Context.mutableVars, Bool.true, Pure.pure, ForInStep.yield]]
[Nat.find_min',[Iff.mp, not_lt, Nat.find_min]]
[of_eq_true,[trivial, Eq.symm]]
[Lean.Xml.Parser.CDStart,[Lean.Parsec.skipString]]
[Lean.Expr.updateMData,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Lean.Expr, Lean.mkMData]]
[Lean.Elab.Command.mkState,[Lean.Elab.Command.State.mk, List.cons, Lean.Elab.Command.Scope.mk, List.nil, Lean.Option.get, Lean.maxRecDepth]]
[Lean.Widget.GetInteractiveDiagnosticsParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.macroTailDefault,[HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.ident, Lean.Parser.darrow, Lean.Parser.Command.macroRhs, Lean.Parser.categoryParserOfStack, OfNat.ofNat]]
[Lean.Expr.FindImpl.initCache,[Lean.Expr.FindImpl.State.mk, Array.mkArray, USize.toNat, Lean.Expr.FindImpl.cacheSize, cast, Lean.Expr.FindImpl.initCache.proof_1, Unit.unit]]
[Lean.Position.noConfusionType,[]]
[Lean.Parser.Term.matchDiscr.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.evalInsideQuot, Lean.Parser.Term.matchDiscr]]
[IO.instMonadLiftSTRealWorldBaseIO,[MonadLift.mk, id]]
[Lean.Meta.mkAppM',[Bind.bind, Lean.Meta.inferType, Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.withNewMCtxDepth, OfNat.ofNat, List.toArray, List.nil, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.Meta.NormNum.instLawfulOfNat_2.proof_1,[Lean.Meta.NormNum.LawfulOfNat.mk, rfl]]
[Array.erase,[Unit.unit, Array, Array.indexOf?, Array.feraseIdx]]
[Lean.Elab.Term.elabLeadingParserMacro,[Lean.Elab.Term.adaptExpander, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.Elab.Term.getDeclName?, Option.none, Lean.Elab.Term.TermElabM, Lean.Syntax, Lean.MacroScopesView.mk, Lean.Name.num, Lean.extractMacroScopes, BEq.beq, List.nil, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Quote.quote, Lean.Parser.maxPrec, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Meta.reduceProjOf?,[ite, Eq, not, Lean.Expr.isApp, Bool.true, Pure.pure, Option.none, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Option, Lean.Expr, Lean.Expr.getAppFn, Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.Environment.getProjectionStructureName?, Lean.Meta.unfoldDefinition?]]
[Tactic.Ring.pow_succ_eq,[Eq.mpr, Eq.refl, Eq, HPow.hPow, HAdd.hAdd, OfNat.ofNat, Eq.symm, HMul.hMul, pow_succ, rfl]]
[Lean.MessageData.ofGoal.injEq,[Eq.propIntro, Eq.refl, Lean.MessageData.ofGoal, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.TheoremVal.value,[]]
[MProd.mk.inj,[And.intro]]
[Lean.Parser.getAlias,[Bind.bind, ST.Ref.get, Pure.pure, Lean.NameMap.find?]]
[Lean.Elab.Term.instMonadInfoTreeTermElabM,[Lean.Elab.MonadInfoTree.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Term.State.infoState, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift]]
[Lean.Meta.IndPredBelow.Variables.args,[]]
[Lean.Literal.strVal.inj,[]]
[Array.mapIdxM.map.proof_1,[Eq.mpr, Eq.refl, LT.lt, Array.size, Eq.symm, HAdd.hAdd, OfNat.ofNat, Nat.add_assoc, Nat.add_comm, Nat.le_add_right, Nat.succ]]
[Lean.Elab.Term.Quotation.ArrayStxBuilder,[Sum, Array, Lean.Syntax]]
[Lean.Server.Snapshots.Snapshot.env,[Lean.Elab.Command.State.env, Lean.Server.Snapshots.Snapshot.cmdState]]
[Lean.Elab.Modifiers.recKind,[]]
[Lean.Elab.Term.MutualClosure.FixPoint.State.usedFVarsMap,[]]
[Lean.MonadQuotation.noConfusionType,[]]
[LawfulFunctor.map_const,[]]
[Lean.Export.exportDef.insert,[modify, Lean.Export.State.mk, Lean.Export.State.names, Lean.Export.State.levels, Lean.Export.State.exprs, Std.HashSet.insert, Lean.Export.State.defs, Lean.Export.State.stk]]
[Lean.LocalDecl.toExpr,[Lean.mkFVar, Lean.LocalDecl.fvarId]]
[Lean.Elab.Term.elabTermAndSynthesize,[Lean.withRef, Bind.bind, Lean.Elab.Term.withSynthesize, Lean.Elab.Term.elabTerm, Bool.true, Bool.false, liftM, Lean.Meta.instantiateMVars]]
[instAddCommGroup,[AddCommGroup.mk, instAddCommGroup.proof_5]]
[Lean.MetavarContext.mk.inj,[And.intro]]
[Lean.Parser.Command.theorem.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.Command.declSig.formatter, Lean.Parser.Command.declVal.formatter, Lean.Parser.Command.terminationSuffix.formatter]]
[Lean.Meta.Split.simpMatch,[Bind.bind, Lean.Meta.getCongrLemmas, Pure.pure, Lean.Meta.Simp.Context.mk, Lean.Meta.Simp.Config.mk, Bool.false, Lean.Meta.SimpLemmas.mk, Lean.Meta.Simp.main, Lean.Meta.Simp.Methods.mk, Lean.Meta.Split.simpMatch.pre]]
[Lean.Elab.Tactic.expandLocation,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Tactic.Location.wildcard, Lean.Elab.Tactic.Location.targets, Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat, not, Lean.Syntax.isNone]]
[StateCpsT.instMonadStateOfStateCpsT,[MonadStateOf.mk, PUnit.unit]]
[Float.mk.inj,[]]
[UInt64.instAddCommSemigroupUInt64.proof_1,[congrArg, UInt64.mk, AddCommSemigroup.add_comm, UInt64.val]]
[Lean.Meta.Match.Pattern.arrayLit.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.Pattern.arrayLit, Eq.symm, eq_of_heq, HEq.refl]]
[String.toInt!,[Unit.unit, Int, String.toInt?, panic]]
[Nat.le_succ,[Nat.le.step, Nat.le.refl]]
[UInt16.val,[]]
[Lean.Lsp.WorkDoneProgressEnd.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.decide!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Meta.FindOptions.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.FindOptions.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.trace,[Bind.bind, Lean.MonadOptions.getOptions, ite, Eq, Lean.checkTraceOption, Bool.true, Lean.Elab.logTrace, Unit.unit, Pure.pure, PUnit.unit]]
[Lean.Elab.Tactic.evalNativeDecide,[Lean.Elab.Tactic.closeMainGoalUsing, Bind.bind, liftM, Lean.Meta.instantiateMVars, ite, Eq, Lean.Expr.hasFVar, Bool.true, Lean.Meta.zetaReduce, Pure.pure, PUnit.unit, Lean.Meta.mkDecide, Lean.Elab.Term.mkAuxName, Lean.addDecl, Lean.compileDecl, Lean.Name.mkStr, Lean.Name.anonymous, Lean.mkConst, List.nil, Lean.Meta.mkEqRefl, Lean.ToExpr.toExpr, Lean.mkApp3]]
[Lean.Elab.Term.Do.Code.decl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.mod_one,[]]
[Array.set,[Array.mk, List.set, Array.data, Fin.val]]
[Decidable.predToBool,[CoeDep.mk, Decidable.decide]]
[Lean.modToFilePath.go,[Unit.unit, System.FilePath, HDiv.hDiv, PProd.fst, System.FilePath.mk, panicWithPosWithDecl, OfNat.ofNat]]
[Nat.foldM.loop,[Pure.pure, Bind.bind, HSub.hSub, OfNat.ofNat, PProd.fst]]
[String.mangle,[String, ite, Eq, or, Char.isAlpha, Char.isDigit, Bool.true, PProd.fst, String.Iterator.next, String.push, Char.ofNat, HAppend.hAppend, LT.lt, Char.toNat, OfNat.ofNat, String.length, String.mkIterator]]
[Lean.Meta.CheckAssignment.Context.rhs,[]]
[Lean.PrettyPrinter.Parenthesizer.State.minPrec,[]]
[Lean.Parser.Term.doLetRec,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.group, Lean.Parser.symbol, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.Term.letRecDecls]]
[Lean.Xml.Attributes,[Std.RBMap, String, Ord.compare]]
[Lean.instMonadCacheExceptT,[Lean.MonadCache.mk, ExceptT.lift, Lean.MonadCache.findCached?, Lean.MonadCache.cache]]
[Lean.Meta.RewriteResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.RewriteResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.addDeclarationRanges,[Lean.MonadEnv.modifyEnv, Lean.MapDeclarationExtension.insert, Lean.declRangeExt]]
[Lean.Parser.ParserContext.noConfusionType,[]]
[Lean.Elab.mkUnusedBaseName,[Bind.bind, Lean.Macro.getCurrNamespace, Lean.Macro.hasDecl, HAppend.hAppend, ite, Eq, Bool.true, OfNat.ofNat, Lean.Elab.mkUnusedBaseName.loop, Pure.pure]]
[Lean.Rat.lt,[ite, Eq, and, Decidable.decide, LT.lt, Lean.Rat.num, OfNat.ofNat, GE.ge, Bool.true, BEq.beq, GT.gt, LE.le, Bool.false, HMul.hMul, Int.ofNat, Lean.Rat.den]]
[Lean.AttributeImplBuilder,[Except, String, Lean.AttributeImpl]]
[Lean.Level.updateMax!.proof_1,[rfl]]
[Lean.PrettyPrinter.Parenthesizer.level.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.maybeParenthesize, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false, Lean.Unhygienic.run, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.PrettyPrinter.Parenthesizer.parenthesizeCategoryCore]]
[List.eraseRepsAux,[List, List.reverse, List.cons, Unit.unit, BEq.beq, PProd.fst]]
[CommSemigroup.mul_comm,[]]
[ExceptT.seq_eq,[rfl]]
[Lean.ScopedEnvExtension.activateScoped,[List.nil, Lean.Environment, Lean.ScopedEnvExtension.StateStack.stateStack, ite, Eq, Lean.NameSet.contains, Lean.ScopedEnvExtension.State.activeScopes, Bool.true, Lean.PersistentEnvExtension.setState, Lean.ScopedEnvExtension.ext, Lean.ScopedEnvExtension.StateStack.mk, List.cons, Lean.ScopedEnvExtension.StateStack.scopedEntries, Lean.ScopedEnvExtension.StateStack.newEntries]]
[UInt64.instSemiringUInt64.proof_6,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, HMul.hMul, UInt64.zero_def, UInt64.mul_def, UInt64.mk, OfNat.ofNat, MonoidWithZero.mul_zero, UInt64.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt64]]
[Lean.Elab.Tactic.replaceMainGoal,[Bind.bind, Lean.Elab.Tactic.getGoals, List.nil, Lean.Elab.Tactic.TacticM, Unit, modify, Lean.Elab.Tactic.State.mk, HAppend.hAppend, Lean.Elab.Tactic.throwNoGoalsToBeSolved]]
[Lean.Environment.imports,[Lean.EnvironmentHeader.imports, Lean.Environment.header]]
[Lean.Server.Watchdog.FileWorker.errorPendingRequests,[Bind.bind, ST.Ref.modifyGet, Lean.Server.Watchdog.FileWorker.pendingRequestsRef, Prod.mk, Std.RBMap.empty, ForIn.forIn, PUnit.unit, IO, ForInStep, PUnit, IO.FS.Stream.writeLspResponseError, Lean.JsonRpc.ResponseError.mk, Pure.pure, ForInStep.yield]]
[Lean.Meta.Closure.pushToProcess,[modify, Lean.Meta.Closure.State.mk, Lean.Meta.Closure.State.visitedLevel, Lean.Meta.Closure.State.visitedExpr, Lean.Meta.Closure.State.levelParams, Lean.Meta.Closure.State.nextLevelIdx, Lean.Meta.Closure.State.levelArgs, Lean.Meta.Closure.State.newLocalDecls, Lean.Meta.Closure.State.newLocalDeclsForMVars, Lean.Meta.Closure.State.newLetDecls, Lean.Meta.Closure.State.nextExprIdx, Lean.Meta.Closure.State.exprMVarArgs, Lean.Meta.Closure.State.exprFVarArgs, Array.push, Lean.Meta.Closure.State.toProcess]]
[List.reverse_append,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.reverse, List.nil_append, HAppend.hAppend, List.reverse_nil, List.append_nil, eq_self, Eq.mpr, List.cons_append, List.reverse_cons, congrFun, List.cons, List.nil, Eq.refl, List.append_assoc, rfl]]
[Lean.Parsec.anyChar,[ite, Eq, String.Iterator.hasNext, Bool.true, Lean.Parsec.ParseResult.success, String.Iterator.next, String.Iterator.curr, Lean.Parsec.ParseResult.error, Lean.Parsec.unexpectedEndOfInput]]
[Lean.Meta.UnificationHint.mk.inj,[And.intro]]
[List.cons_ne_nil,[Eq.refl, List.nil, HEq.refl]]
[Lean.IR.Borrow.OwnedSet,[Std.HashMap, Lean.IR.Borrow.OwnedSet.Key, Unit]]
[controlAt,[Bind.bind, MonadControlT.liftWith, MonadControlT.restoreM]]
[Lean.Meta.Simp.Config.etaStruct,[]]
[Lean.Parser.Term.whereDecls.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1Indent.formatter, Lean.Parser.group.formatter, Lean.Parser.Term.letRecDecl.formatter, Lean.Parser.optional.formatter]]
[Lean.Meta.simpIfTarget,[Bind.bind, Lean.Meta.SplitIf.getSimpContext, Lean.Meta.simpTarget, Option.some, Lean.Meta.SplitIf.discharge?, Option.none, Lean.Meta.MetaM, Lean.MVarId, Pure.pure, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Elab.Command.CtorView.ref,[]]
[Lean.Meta.AbstractMVars.State.ngen,[]]
[Lean.MetavarDecl.type,[]]
[Lean.Elab.Term.elabFunBinders,[ite, Eq, Array.isEmpty, Bool.true, List.toArray, List.nil, Bind.bind, Lean.MonadLCtx.getLCtx, liftM, Lean.Meta.getLocalInstances, Lean.Elab.Term.FunBinders.elabFunBindersAux, OfNat.ofNat, Lean.Elab.Term.FunBinders.State.mk, Lean.Meta.resettingSynthInstanceCacheWhen, Decidable.decide, GT.gt, Array.size, Lean.Elab.Term.FunBinders.State.localInsts, Lean.Meta.withLCtx, Lean.Elab.Term.FunBinders.State.lctx, Lean.Elab.Term.FunBinders.State.fvars, Lean.Elab.Term.FunBinders.State.expectedType?]]
[Std.AssocList.cons.inj,[And.intro]]
[Lean.instInhabitedLiteral,[Inhabited.mk, Lean.Literal.natVal, arbitrary]]
[Lean.Parser.Tactic.fsplit,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Expr.updateApp,[Lean.mkApp]]
[Float.le,[FloatSpec.le, floatSpec, Float.val]]
[Lean.Parser.Command.constant.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.Command.declSig.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.declValSimple.formatter]]
[Lean.Compiler.foldStrictOr,[Option.none, Option.some, Bool.false, Bool.true, Option, Lean.Expr]]
[Lean.KVMap.size,[List.length, Lean.KVMap.entries]]
[UInt32.instSemigroupUInt32.proof_1,[congrArg, UInt32.mk, Semigroup.mul_assoc, UInt32.val]]
[instMonadStateOfStateT,[MonadStateOf.mk, StateT.get, StateT.set, StateT.modifyGet]]
[Std.Format.bracketFill,[Std.Format.fill, Std.Format.nest, Int.ofNat, String.length, HAppend.hAppend, Std.Format.text]]
[Lean.Elab.Term.elabExplicitUniv,[Bind.bind, List.nil, Bool.false, List.toArray, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.Elab.Term.TermElabM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Pure.pure, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError]]
[Lean.Elab.Tactic.evalContradiction,[Lean.Elab.Tactic.liftMetaTactic, Bind.bind, Lean.Meta.contradiction, Lean.Meta.Contradiction.Config.mk, Pure.pure, List.nil]]
[Lean.Elab.Term.Do.ToTerm.continueToTerm,[Bind.bind, MonadReader.read, Lean.Elab.Term.Do.ToTerm.mkUVarTuple, Unit.unit, Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax, Lean.Elab.Term.Do.ToTerm.Context.kind, panicWithPosWithDecl, OfNat.ofNat, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom]]
[Lean.IR.LocalContextEntry.param.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.PatternVar.anonymousVar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Std.Format.FlattenBehavior.noConfusionType,[noConfusionTypeEnum, Std.Format.FlattenBehavior.toCtorIdx]]
[Lean.Parser.Term.trueVal.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.nonReservedSymbol.formatter, Bool.false]]
[Lean.IR.mkNumExpr,[Lean.IR.Expr.lit, Lean.IR.LitVal.num]]
[Lean.Parser.Error.merge,[Lean.Parser.Error, Lean.Parser.Error.mk, ite, Eq, BEq.beq, Bool.true, Lean.Parser.Error.unexpected, HAppend.hAppend, Lean.Parser.Error.expected]]
[Lean.mkLevelSucc,[Lean.Level.succ, Lean.Level.mkData, mixHash, OfNat.ofNat, Hashable.hash, HAdd.hAdd, Lean.Level.depth, Lean.Level.hasMVar, Lean.Level.hasParam]]
[Lean.PrettyPrinter.Formatter.checkColGt.formatter,[Pure.pure, Unit.unit]]
[Lean.Lsp.RpcReleaseParams.uri,[]]
[Lean.IR.Expr.reuse.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Json.num.inj,[]]
[Int.instCommRingInt.proof_4,[rfl]]
[Lean.Lsp.TextDocumentChangeRegistrationOptions.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.TextDocumentChangeRegistrationOptions.mk, Eq.symm, eq_of_heq, HEq.refl]]
[instCoeTailNat,[CoeTail.mk, Numeric.ofNat]]
[Lean.Server.FileWorker.handleCancelRequest,[Lean.Server.FileWorker.updatePendingRequests, Std.RBMap.erase, Lean.Lsp.CancelParams.id]]
[Lean.Parser.Command.declModifiersT.parenthesizer,[Lean.Parser.Command.declModifiers.parenthesizer, Bool.true]]
[Lean.Parser.Syntax.nonReserved.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.strLit.parenthesizer]]
[Nat.le_eq,[rfl]]
[Lean.Meta.trySubst,[Bind.bind, Lean.observing?, Lean.Meta.subst, Unit.unit, Lean.Meta.MetaM, Lean.MVarId, Pure.pure]]
[Std.shareCommonM,[Std.withShareCommon]]
[Lean.Server.FileWorker.SemanticTokensContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.FileWorker.SemanticTokensContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Command.expandInitCmd,[ite, Eq, Lean.Syntax.isNone, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.Macro.throwError, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, BEq.beq, Lean.Syntax.getKind, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Lsp.instBEqRpcRef,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Nat.coprime_zero_right,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, Eq, Nat.gcd_zero_right, OfNat.ofNat, iff_self]]
[FloatArray.toList,[OfNat.ofNat, List.nil, FloatArray.toList.loop]]
[Lean.KVMap.entries,[]]
[Lean.Expr.notNot?,[Unit.unit, Option, Lean.Expr, Lean.Expr.not?, Option.none]]
[Lean.Syntax.SepArray.ofElemsUsingRef,[Bind.bind, Lean.MonadRef.getRef, Pure.pure, Lean.Syntax.SepArray.mk, Lean.mkSepArray, Lean.mkAtomFrom]]
[Mathlib.Prelude.Rename.align,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Lean.PrettyPrinter.Parenthesizer.State.visitedToken,[]]
[Lean.Parser.Term.let_delayed.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.letDecl.parenthesizer, Lean.Parser.Term.optSemicolon.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Lean.instHashableBinderInfo,[Hashable.mk, Lean.BinderInfo.hash]]
[Array.filterSepElems,[Id.run, Array.filterSepElemsM]]
[Lean.MetavarContext.MkBinding.elimMVarDeps,[ite, Eq, not, Lean.Expr.hasMVar, Bool.true, Pure.pure, Bind.bind, MonadState.modifyGet, Prod.mk, Lean.MetavarContext.MkBinding.State.cache, Lean.MetavarContext.MkBinding.State.mk, Lean.MetavarContext.MkBinding.State.mctx, Lean.MetavarContext.MkBinding.State.ngen, EmptyCollection.emptyCollection, modify]]
[Option.map,[Option.bind, Function.comp, Option.some]]
[Lean.IR.findEnvDecl,[Lean.SMap.find?, Lean.SimplePersistentEnvExtension.getState, Lean.IR.declMapExt]]
[Lean.LocalContext.mk.inj,[And.intro]]
[Lean.Name.toExprAux,[Unit.unit, Lean.Expr, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.mkAppB, PProd.fst, Lean.ToExpr.toExpr]]
[Lean.Meta.isMatcherAppCore,[Option.isSome, Lean.Meta.isMatcherAppCore?]]
[Lean.enableInitializersExecution,[ST.Ref.set, Bool.true]]
[Char.quote,[HAppend.hAppend, Char.quoteCore]]
[Lean.Lsp.ReferenceContext.mk.inj,[]]
[Array.foldlM.loop.proof_1,[Nat.lt_of_lt_of_le]]
[unexpandListNil,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Lean.Elab.Command.withExpectedType,[Bind.bind, Lean.Elab.Term.tryPostponeIfNoneOrMVar, Pure.pure, Option.none, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.Meta.CongrLemmas.mk.inj,[]]
[Lean.PrettyPrinter.Parenthesizer.withOpen.parenthesizer,[]]
[Lean.CollectLevelParams.instInhabitedState,[Inhabited.mk, Lean.CollectLevelParams.State.mk]]
[Lean.Elab.Term.Do.Code.return.inj,[And.intro]]
[Lean.Meta.mkOfNatLit,[Lean.mkApp3, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil]]
[Array.noConfusionType,[]]
[Lean.ScopedEnvExtension.mkInitial,[Bind.bind, Lean.ScopedEnvExtension.Descr.mkInitial, Pure.pure, Lean.ScopedEnvExtension.StateStack.mk, List.cons, Lean.ScopedEnvExtension.State.mk, List.nil]]
[IO.eprintln,[IO.eprint, String.push, ToString.toString, Char.ofNat]]
[Classical.inhabited_of_nonempty,[Inhabited.mk, Classical.choice]]
[Char.ofNat.proof_1,[of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.SMap.stageSizes,[Prod.mk, Std.HashMap.size, Lean.SMap.map₁, Std.PersistentHashMap.size, Lean.SMap.map₂]]
[UInt32.lor,[UInt32.mk, Fin.lor, UInt32.val]]
[Lean.Lsp.instToJsonServerInfo,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.ServerInfo.name, List.nil, Lean.Json.opt, Lean.Lsp.ServerInfo.version?]]
[Lean.DefinitionVal.getSafetyEx,[Lean.DefinitionVal.safety]]
[Lean.Lsp.instFileSourceDocumentHighlightParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.DocumentHighlightParams.toTextDocumentPositionParams]]
[precMin1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[USize.instAddCommSemigroupUSize,[AddCommSemigroup.mk, USize.instAddCommSemigroupUSize.proof_1]]
[Lean.Meta.SynthInstance.ConsumerNode.key,[]]
[Std.RBNode.forIn.visit,[ForInStep, Pure.pure, ForInStep.yield, Bind.bind, PProd.fst, ForInStep.done, PProd.snd]]
[Lean.Elab.Term.MutualClosure.LetRecClosure.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.MutualClosure.LetRecClosure.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Delaborator.SubExpr.instInhabitedHoleIterator,[Inhabited.mk, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.mk, arbitrary]]
[Lean.Lsp.instToJsonSemanticTokensRangeParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.SemanticTokensRangeParams.textDocument, List.nil, Lean.Lsp.SemanticTokensRangeParams.range]]
[Lean.Parser.Term.ensureTypeOf.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec, Lean.Parser.strLit.formatter]]
[Lean.Parser.Term.doLet,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.Term.letDecl]]
[Lean.Meta.Match.MatcherInfo.numDiscrs,[]]
[Lean.Parser.Tactic.subst,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Lean.IR.Checker.withParams,[Bind.bind, MonadReader.read, Array.foldlM, Lean.IR.Checker.markVar, Lean.IR.Param.x, Pure.pure, Lean.IR.LocalContext.addParam, Lean.IR.Checker.CheckerContext.localCtx, OfNat.ofNat, Array.size, MonadWithReader.withReader, Lean.IR.Checker.CheckerContext.mk, Lean.IR.Checker.CheckerContext.env, Lean.IR.Checker.CheckerContext.decls]]
[List.length_erase_of_mem,[Eq.mpr, Eq.refl, Eq, List.length, List.erase, Nat.pred, List.erase_eq_erasep, List.length_erasep_of_mem, rfl]]
[Lean.Parser.Term.binderType,[ite, Eq, Bool.true, Lean.Parser.node, Lean.nullKind, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat, Lean.Parser.optional]]
[Nat.ble_self_eq_true,[Unit.unit, Eq, Nat.ble, Bool.true, rfl, PProd.fst]]
[Lean.Elab.Command.termEta_helper_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.mkLevelMVar,[Lean.Level.mvar, Lean.Level.mkData, mixHash, OfNat.ofNat, Hashable.hash, Bool.true, Bool.false]]
[Lean.instInhabitedTraceElem,[Inhabited.mk, Lean.TraceElem.mk, arbitrary]]
[Lean.MetavarDecl.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MetavarDecl.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Set.compl,[setOf, Not, Mem.mem]]
[Lean.Parser.Command.infixr,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Lean.Json.renderString,[HAppend.hAppend, Lean.Json.escape]]
[Lean.Elab.CompletionInfo.stx,[Lean.Syntax, Lean.Elab.ElabInfo.stx, Lean.Elab.TermInfo.toElabInfo]]
[Lean.Meta.SynthInstance.SubgoalsResult.instVal,[]]
[List.getLast,[absurd, List.getLast.proof_1, PProd.fst, List.getLast.proof_2]]
[Lean.Parser.strLitFn,[ite, Eq, and, not, Lean.Parser.ParserState.hasError, Lean.Syntax.isOfKind, Array.back, Lean.Parser.ParserState.stxStack, Lean.strLitKind, Bool.true, Lean.Parser.ParserState.mkErrorAt, Option.some]]
[Lean.Elab.Term.mkCoe,[Bind.bind, liftM, Lean.Meta.getLevel, Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.synthetic, Lean.Name.anonymous, MonadExcept.tryCatch, Lean.Elab.Term.withoutMacroStackAtErr, Lean.Elab.Term.synthesizeCoeInstMVarCore, ite, Eq, Bool.true, Lean.Meta.expandCoe, Lean.MetavarKind.syntheticOpaque, Lean.Elab.Term.registerSyntheticMVarWithCurrRef, Lean.Expr.mvarId!, Lean.Elab.Term.SyntheticMVarKind.coe, Pure.pure, Lean.Exception.internal, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Elab.Term.throwTypeMismatchError, Option.none]]
[Lean.Lsp.DiagnosticWith.mk.inj,[And.intro]]
[Lean.Parser.AliasValue.unary.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.AliasValue.unary, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Server.Watchdog.OpenDocument.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.isLetRecAuxMVar,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, MonadState.get, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkMVar, List.map, Lean.Elab.Term.LetRecToLift.mvarId, Lean.Elab.Term.State.letRecsToLift, Pure.pure, PUnit.unit]]
[Lean.NamePart.str.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Match.Example.var.inj,[]]
[Lean.Elab.Tactic.evalSeq1,[Bind.bind, ForIn.forIn, PUnit.unit, ite, Eq, BEq.beq, HMod.hMod, OfNat.ofNat, Bool.true, Lean.Elab.Tactic.evalTactic, Array.getOp, Pure.pure, ForInStep.yield, Lean.Elab.Tactic.saveTacticInfoForToken]]
[Lean.Parser.Syntax.cat.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optPrecedence.parenthesizer]]
[Lean.Json.CompressWorkItem.arrayElem.inj,[]]
[Lean.Parser.parseCommand,[Lean.Parser.parseCommand.parse]]
[Lean.Parser.Tactic.mfldSetTac,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Nat.mul_le_mul_of_nonneg_right,[Decidable.em, LE.le, Eq.mpr, congrArg, HMul.hMul, congrFun, Nat.le_antisymm, Nat.le_refl, Eq.symm, OfNat.ofNat, of_eq_true, Eq.trans, congr, Nat.zero_le, Nat.mul_zero, eq_true_of_decide, Eq.refl, Bool.true, Nat.le_of_lt, Nat.mul_lt_mul_of_pos_right, Iff.mp, not_le]]
[Lean.Environment.mainModule,[Lean.EnvironmentHeader.mainModule, Lean.Environment.header]]
[Std.PersistentHashMap.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.FindOptions.checkPrivate,[]]
[Prod.map_fst,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Prod.fst, prod_map, eq_self]]
[Lean.Syntax.Traverser.setCur,[Lean.Syntax.Traverser.mk, Lean.Syntax.Traverser.parents, Lean.Syntax.Traverser.idxs]]
[Lean.FileMap.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.FileMap.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.withoutAutoBoundImplicit,[MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.Context.declName?, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.currMacroScope, Lean.Elab.Term.Context.mayPostpone, Lean.Elab.Term.Context.errToSorry, Bool.false, Std.PersistentArray.mk, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection]]
[Lean.Lsp.DiagnosticCode.string.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.instMonadBacktrackSavedStateTermElabM,[Lean.MonadBacktrack.mk, Lean.Elab.Term.saveState, Lean.Elab.Term.SavedState.restore, Bool.false]]
[Lean.IR.Expr.isShared.injEq,[Eq.propIntro, Eq.refl, Lean.IR.Expr.isShared, Eq.symm, eq_of_heq, HEq.refl]]
[Mathlib.Tactic.Lint.groupedByFilename,[Bind.bind, ForIn.forIn, Lean.Core.CoreM, ForInStep, Std.HashMap, Lean.Name, Lean.MessageData, Lean.findModuleOf?, Lean.MonadEnv.getEnv, Pure.pure, PUnit.unit, ForInStep.yield, List.mapM, Mathlib.Tactic.Lint.printWarnings, HAppend.hAppend, Lean.ToMessageData.toMessageData, Array.toList, Lean.MessageData.joinSep, Lean.MessageData.ofFormat, Std.Format.line]]
[Acc.inv.proof_1,[]]
[Lean.Parser.mkAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.maxPrec, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.setExpected.parenthesizer, List.nil, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.manyNoAntiquot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.antiquotExpr.parenthesizer, Lean.PrettyPrinter.Parenthesizer.ite, Eq, Bool.true, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.PrettyPrinter.Parenthesizer.checkNoImmediateColon.parenthesizer, Lean.PrettyPrinter.Parenthesizer.pushNone.parenthesizer]]
[or_and_distrib_right,[Iff.trans, And.comm, and_or_distrib_left, or_congr]]
[Lean.Parser.Tactic.suffices',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser]]
[Lean.MonadQuotation.withFreshMacroScope,[]]
[Lean.Compiler.NumScalarTypeInfo.nbits,[]]
[Lean.Server.FileWorker.SemanticTokensContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Classical.choose_spec,[Subtype.property, Classical.indefiniteDescription]]
[Lean.Parser.decimalNumberFn.parseOptExp,[ite, Eq, or, BEq.beq, Char.ofNat, Bool.true, Char.isDigit, Lean.Parser.takeWhileFn, Lean.Parser.ParserState.setPos]]
[Subtype.map_injective,[Subtype.coind_injective, Subtype.map.proof_1, Function.injective.comp, Subtype.coe_injective]]
[Classical.epsilon_spec_aux,[Subtype.property, Classical.strongIndefiniteDescription]]
[UInt32.instAddCommSemigroupUInt32.proof_1,[congrArg, UInt32.mk, AddCommSemigroup.add_comm, UInt32.val]]
[Lean.Xml.Element.below,[PProd, PUnit]]
[Lean.Syntax.isOfKind,[BEq.beq, Lean.Syntax.getKind]]
[not_and_distrib,[Decidable.not_and_distrib]]
[Lean.Compiler.numScalarTypes,[List.cons, Lean.Compiler.NumScalarTypeInfo.mk, OfNat.ofNat, System.Platform.numBits, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Lean.Level.imax.inj,[And.intro]]
[Lean.Parser.Command.optNamedName,[Lean.Parser.optional, Lean.Parser.Command.namedName]]
[Lean.Elab.Term.elabWaitIfContainsMVar,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, liftM, Lean.MonadMCtx.getMCtx, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.MetavarContext.findUserName?, Lean.Syntax.getId, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.instantiateMVars, Lean.mkMVar, Lean.Expr.hasExprMVar, Lean.Elab.Term.tryPostpone, Pure.pure, PUnit.unit, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Parser.Command.decreasingBy,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.terminationHint, Lean.Parser.Tactic.tacticSeq]]
[Lean.Xml.Parser.NotationType,[Bind.bind, Lean.Parsec.skipString, SeqLeft.seqLeft, SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Parsec.skipChar, Char.ofNat, optional, Lean.Xml.Parser.Name, Lean.Parsec.many]]
[Lean.Name.getString!,[Lean.Name.anonymous, Lean.Name.num, String, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Widget.instInhabitedCodeToken,[Inhabited.mk, Lean.Widget.CodeToken.mk, arbitrary]]
[Lean.Parser.Term.doHave,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.haveDecl]]
[Lean.instFromJsonOption,[Lean.FromJson.mk, Unit.unit, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Except, String, Option, Except.ok, Option.none, Functor.map, Option.some, Lean.FromJson.fromJson?]]
[EStateM.Result.ok.inj,[And.intro]]
[Lean.Widget.instInhabitedInfoWithCtx,[Inhabited.mk, Lean.Widget.InfoWithCtx.mk, arbitrary]]
[Lean.Lsp.SemanticTokenType.keyword.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.FVarSubst.mk.inj,[]]
[Lean.Elab.Term.getPatternVarNames,[Array.filterMap, Lean.Elab.Term.PatternVar.anonymousVar, Option, Lean.Name, Option.some, Option.none, OfNat.ofNat, Array.size]]
[Lean.Elab.Term.hasNoImplicitLambdaAnnotation,[Option.isSome, Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous]]
[MonoidWithZero.mul_zero,[]]
[Lean.IR.LocalContext.getValue,[Option.none, Option.some, Lean.IR.LocalContextEntry.param, Lean.IR.LocalContextEntry.joinPoint, Option, Lean.IR.Expr, Std.RBMap.find?, Lean.IR.VarId.idx]]
[Function.surjective.comp,[Exists.elim, Exists.intro]]
[Lean.Parser.Syntax.unary.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.syntaxParser.parenthesizer]]
[Lean.IR.ensureHasDefault,[ite, Eq, Array.any, Lean.IR.Alt.isDefault, OfNat.ofNat, Array.size, Bool.true, LT.lt, Array.push, Lean.IR.Alt.default, Lean.IR.AltCore.body]]
[Lean.Parser.Level.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.levelParser.parenthesizer]]
[Lean.Option.register,[Bind.bind, Lean.registerOption, Lean.OptionDecl.mk, Lean.KVMap.Value.toDataValue, Lean.Option.Decl.defValue, Lean.Option.Decl.group, Lean.Option.Decl.descr, Pure.pure, Lean.Option.mk]]
[eq_comm,[Iff.intro, Eq.symm]]
[Lean.Elab.Term.ElabAppArgs.eraseNamedArgCore,[List.filter, bne, Lean.Elab.Term.NamedArg.name]]
[Lean.Parsec.ParseResult.error.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.expandOptDocComment?,[Unit.unit, Option, String, Lean.Syntax.getOptional?, Pure.pure, Option.none, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Lean.Syntax.getOp, OfNat.ofNat, Option.some, String.extract, HSub.hSub, String.bsize, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.ofSyntax]]
[Lean.Parser.Term.binderType.formatter,[Lean.PrettyPrinter.Formatter.ite, Eq, Bool.true, Lean.PrettyPrinter.Formatter.node.formatter, Lean.nullKind, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Lean.Parser.optional.formatter]]
[Int.lt,[LE.le, HAdd.hAdd, OfNat.ofNat]]
[Nat.lt,[Nat.le, Nat.succ]]
[Std.HashSet.foldM,[Std.HashSetImp.foldM]]
[Lean.pushScope,[Bind.bind, ST.Ref.get, Lean.scopedEnvExtensionsRef, ForIn.forIn, PUnit.unit, Lean.MonadEnv.modifyEnv, Lean.ScopedEnvExtension.pushScope, Pure.pure, ForInStep.yield]]
[String.congr_append,[Eq, HAppend.hAppend, String.mk, String.data, rfl]]
[Lean.Parser.Command.check.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Function.left_inverse_surj_inv,[Function.right_inverse_of_injective_of_left_inverse, And.left, Function.right_inverse_surj_inv, And.right]]
[Lean.Meta.CheckAssignment.Context.mk.inj,[And.intro]]
[«term_*_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[or_assoc,[Or.assoc]]
[Lean.Lsp.SemanticTokensOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Tactic.Simp.DischargeWrapper.with,[Unit.unit, Lean.Elab.Tactic.TacticM, Option.none, Bind.bind, getThe, Lean.Elab.Term.State, ST.Ref.set, tryFinally, Option.some, ST.Ref.get, MonadStateOf.set]]
[Lean.Parser.Term.funSimpleBinder,[HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.lookahead, Lean.Parser.many1, Lean.Parser.Term.binderIdent, Lean.Parser.symbol, Lean.Parser.Term.simpleBinder]]
[Lean.Lsp.VersionedTextDocumentIdentifier.version?,[]]
[Lean.Elab.Term.expandTermFor,[Lean.withRef, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Lean.Parser.Command.openDecl.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.openHiding.parenthesizer, Lean.Parser.Command.openRenaming.parenthesizer, Lean.Parser.Command.openOnly.parenthesizer, Lean.Parser.Command.openSimple.parenthesizer, Lean.Parser.Command.openScoped.parenthesizer]]
[Lean.Elab.Term.SavedContext.macroStack,[]]
[Lean.Parser.InputContext.fileName,[]]
[Lean.Expr.app.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MessageData.format,[Lean.MessageData.formatAux, Lean.NamingContext.mk, Lean.Name.anonymous, List.nil, Option.none]]
[Lean.Meta.DiscrTree.Key.fvar.inj,[And.intro]]
[DoResultPRBC.pure.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.UniqueIds.checkId,[MonadState.modifyGet]]
[Lean.Parser.Term.num.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.numLit.parenthesizer]]
[id.def,[rfl]]
[Lean.Elab.Tactic.getMainModule,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Environment.mainModule]]
[Lean.KeyedDeclsAttribute.AttributeEntry.value,[]]
[IO.Error.toString,[Unit.unit, String, IO.Error.fopenErrorToString, Option.some, IO.Error.otherErrorToString, Option.none]]
[Lean.Meta.Match.Example.val.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.IndPredBelow.Context.headers,[]]
[or_congr,[Iff.intro, Or.imp, Iff.mp, Iff.mpr]]
[Lean.mkCIdent,[Lean.mkCIdentFrom, Lean.Syntax.missing]]
[LawfulApplicative.seq_pure,[]]
[Std.PersistentHashMap.Entry.ref.injEq,[Eq.propIntro, Eq.refl, Std.PersistentHashMap.Entry.ref, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.realPathNormalized,[Bind.bind, IO.FS.realPath, Pure.pure, System.FilePath.normalize, System.FilePath.isCaseInsensitive]]
[Lean.Meta.Simp.Context.simpLemmas,[]]
[And.left_comm,[Eq.mpr, Eq.refl, Iff, And, Eq.symm, propext, and_assoc, And.comm, Iff.rfl]]
[Lean.Elab.Command.liftEIO,[liftM]]
[instPowFloatFloat,[Pow.mk, Float.pow]]
[Nat.lt.base,[Nat.lt.base.proof_1]]
[Lean.Lsp.DocumentFilter.scheme?,[]]
[Numeric.noConfusionType,[]]
[and_iff_left,[Iff.intro, And.left, And.intro]]
[mul_assoc,[Semigroup.mul_assoc]]
[Lean.Expr.forEach',[Lean.MonadCacheT.run, Lean.ForEachExpr.visit]]
[Lean.Expr.FindImpl.State.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Expr.FindImpl.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Int.negSucc_ofNat_coe',[Eq.mpr, Eq.refl, Eq, Int.negSucc, HSub.hSub, Neg.neg, Int.ofNat, OfNat.ofNat, Int.sub_eq_add_neg, HAdd.hAdd, Eq.symm, Int.neg_add, rfl]]
[Lean.Meta.IndPredBelow.mkContext.addMotives,[Array.foldrM, Lean.Meta.MetaM, Lean.Expr, Lean.Meta.forallTelescopeReducing, Bind.bind, Lean.Meta.instantiateForall, Array.ofSubarray, Array.toSubarray, OfNat.ofNat, Lean.Meta.withLocalDecl, Lean.BinderInfo.implicit, Lean.Meta.mkForallFVars, Array.insertAt, Bool.false, Bool.true, Array.size]]
[Functor.noConfusionType,[]]
[Lean.Parser.mkCategoryAntiquotParser,[Lean.Parser.mkAntiquot, Lean.Name.toString, Bool.true, Option.none]]
[UInt32.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Export.instInhabitedAlloc,[Inhabited.mk, Lean.Export.Alloc.mk, arbitrary]]
[Array.mapM,[Array.foldlM, Bind.bind, Pure.pure, Array.push, Array.mkEmpty, Array.size, OfNat.ofNat]]
[Lean.findOLean,[Bind.bind, ST.Ref.get, Lean.searchPathRef, Lean.SearchPath.findWithExt, Option.none, IO, System.FilePath, Pure.pure, IO.currentDir, PUnit.unit, Lean.findOLean.maybeThisOne]]
[Lean.Meta.splitIfLocalDecl?,[Lean.commitWhenSome?, Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.inferType, Lean.mkFVar, Lean.Meta.SplitIf.splitIfAt?, Option.none, Lean.Meta.MetaM, Option, Prod, Lean.MVarId, Lean.Meta.simpIfLocalDecl, Lean.Meta.ByCasesSubgoal.mvarId, ite, Eq, and, BEq.beq, Bool.true, Pure.pure, Option.some, Prod.mk]]
[Subsingleton.helim,[Subsingleton.helim.proof_1]]
[Lean.Elab.Term.adaptExpander,[Bind.bind, Lean.Elab.Term.withMacroExpansion, Lean.Elab.Term.elabTerm, Bool.true]]
[Lean.Parser.Command.infix.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.Elab.InfoState.trees,[]]
[IO.AsyncList.below,[PProd, PUnit]]
[Lean.Elab.Structural.structuralRecursion,[ite, Eq, bne, Array.size, OfNat.ofNat, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData, Bind.bind, liftM, Lean.Elab.Structural.run, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.value, Pure.pure, PUnit.unit, Array.getOp, Lean.Elab.Structural.State.mk, Lean.Elab.Term.TermElabM, Unit, Array.forM, Lean.Elab.Structural.State.addMatchers, Lean.Meta.mapError, Lean.Elab.addNonRec, Lean.indentD, Lean.Elab.addAndCompilePartialRec, Lean.Elab.Structural.addSmartUnfoldingDef, Lean.Elab.Structural.registerEqnsInfo]]
[Lean.Widget.GetInteractiveDiagnosticsParams.noConfusionType,[]]
[introv,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[Lean.Attribute.Builtin.ensureNoArgs,[ite, Eq, and, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.isNone, Lean.Syntax.getOp, OfNat.ofNat, Bool.true, Pure.pure, Unit.unit, Lean.Syntax.node, Lean.Syntax.atom, Lean.Syntax.ident, Lean.AttrM, Unit, Lean.throwErrorAt, Lean.ToMessageData.toMessageData]]
[Lean.SimpleScopedEnvExtension.Descr.finalizeImport,[]]
[Lean.Meta.Simp.defaultMaxSteps,[OfNat.ofNat]]
[Lean.getPPAnalysisNamedArg,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false]]
[Lean.Elab.Term.LetRecDeclView.binderIds,[]]
[Lean.Lsp.instFromJsonDeclarationParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.DeclarationParams.mk, Lean.Lsp.TextDocumentPositionParams.mk]]
[Lean.Parser.Term.binop_lazy,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.ppSpace, Lean.Parser.termParser, Lean.Parser.maxPrec]]
[Std.Format.text.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.FieldInfo.stx,[]]
[Lean.Meta.SimpAll.Entry.mk.inj,[And.intro]]
[Lean.Elab.Term.PatternElabException.ex,[]]
[Lean.IR.UnreachableBranches.elimDead,[Lean.IR.Decl.extern, Lean.IR.Decl, Lean.IR.Decl.updateBody!, Lean.IR.UnreachableBranches.elimDeadAux]]
[Lean.Server.FileWorker.GoToKind.toCtorIdx,[OfNat.ofNat]]
[Lean.IR.EmitC.emitLhs,[Bind.bind, Lean.IR.EmitC.emit]]
[Substring.splitOn,[ite, Eq, BEq.beq, Bool.true, List.cons, List.nil, OfNat.ofNat, Substring.splitOn.loop]]
[Lean.Elab.Term.StructInst.DefaultFields.isRoundDone,[Bind.bind, MonadState.get, MonadReader.read, Pure.pure, and, Lean.Elab.Term.StructInst.DefaultFields.State.progress, Decidable.decide, GT.gt, Lean.Elab.Term.StructInst.DefaultFields.Context.maxDistance, OfNat.ofNat]]
[Fin.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Syntax.MonadTraverser.goRight,[modify, Lean.Syntax.Traverser.right]]
[Lean.Widget.MsgToInteractive.mk.inj,[And.intro]]
[Lean.Parser.Tactic.elide,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Mathlib.Prelude.Rename.elabLookup3,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.Elab.Command.CommandElabM, Unit, Std.HashMap.find?, Mathlib.Prelude.Rename.getRenameMap, Lean.Elab.logInfoAt, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, HAppend.hAppend, ToString.toString, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Elab.Tactic.Conv.evalSimpMatch,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.Conv.getLhs, liftM, Lean.Meta.Split.simpMatch, Lean.Elab.Tactic.Conv.applySimpResult]]
[Lean.Compiler.cacheSpecialization,[Lean.PersistentEnvExtension.addEntry, Lean.Compiler.specExtension, Lean.Compiler.SpecEntry.cache]]
[Classical.decidableInhabited,[Inhabited.mk, inferInstance]]
[Function.surjective.forall,[Iff.intro]]
[Nat.gcd_self,[of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.gcd, Nat.zero_eq, Nat.gcd_zero_right, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true, Eq.symm, congrFun, Nat.gcd_succ, Nat.succ, Nat.mod_self, Nat.gcd_zero_left, eq_self]]
[Lean.Meta.CheckAssignmentQuick.check,[Lean.Meta.CheckAssignmentQuick.check.visit]]
[Lean.Parser.Term.sorry.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Std.HashMap.instInhabitedHashMap,[Inhabited.mk, Std.mkHashMap, OfNat.ofNat]]
[Lean.Parser.instInhabitedLeadingIdentBehavior,[Inhabited.mk, Lean.Parser.LeadingIdentBehavior.default]]
[Lean.IR.DeclInfo.mk.inj,[]]
[Std.PersistentHashMap.Entry.ref.inj,[]]
[Lean.Elab.Info.ofCommandInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Tactic.Conv.evalNestedTactic,[Bind.bind, Lean.Elab.Tactic.getMainTarget, Option.none, Lean.Elab.Tactic.TacticM, Unit, Lean.isLHSGoal?, Lean.Elab.Tactic.liftMetaTactic1, coeM, Lean.Meta.replaceTargetDefEq, Lean.Expr.mdataExpr!, Pure.pure, PUnit.unit]]
[IO.Error.mkIllegalOperation,[IO.Error.illegalOperation]]
[Lean.Elab.Command.InductiveView.shortDeclName,[]]
[Lean.Parser.Tactic.squeezeSimp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.Elab.Command.aux_def,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[SeqRight.seqRight,[]]
[Lean.Meta.changeLocalDecl,[Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.revert, List.toArray, List.cons, List.nil, Bool.true, Lean.Meta.MetaM, Lean.MVarId, Lean.Meta.withMVarContext, Lean.Meta.getMVarType, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.mkForall, Lean.Expr.Data.binderInfo, Lean.mkLet, Bool.false, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing]]
[Lean.Occurrences.pos.injEq,[Eq.propIntro, Eq.refl, Lean.Occurrences.pos, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Command.StructFieldView.mk.inj,[And.intro]]
[Lean.RecursorVal.numMinors,[]]
[Nat.div_eq_of_lt_le,[]]
[Std.PersistentHashMap.shift,[OfNat.ofNat]]
[Lean.MessageData.instCoeNameMessageData,[Coe.mk, Lean.MessageData.ofName]]
[ByteArray.mkEmpty,[ByteArray.mk, List.toArray, List.nil]]
[Std.PersistentHashSet.empty,[Std.PersistentHashSet.mk, Std.PersistentHashMap.empty]]
[Lean.Parser.suppressInsideQuot,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.suppressInsideQuotFn, Lean.Parser.Parser.fn]]
[Decidable.or_iff_not_imp_right,[Iff.trans, Or.comm, Decidable.or_iff_not_imp_left]]
[Mathlib.Tactic.Lint.instDecidableEqLintVerbosity,[dite, Eq, Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx, Decidable.isTrue, Mathlib.Tactic.Lint.instDecidableEqLintVerbosity.proof_1, Decidable.isFalse, Mathlib.Tactic.Lint.instDecidableEqLintVerbosity.proof_2]]
[Lean.Parser.Term.macroDollarArg.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.Server.Completion.M,[OptionT, StateRefT', IO.RealWorld, Lean.Server.Completion.State, Lean.Meta.MetaM]]
[Lean.JsonRpc.Request.mk.inj,[And.intro]]
[Lean.Parser.Tactic.nestedTactic.parenthesizer,[Lean.Parser.Tactic.tacticSeqBracketed.parenthesizer]]
[Nat.gcd_eq_left,[Nat.dvd_antisymm, Nat.gcd_dvd_left, Nat.dvd_gcd, Nat.dvd_refl]]
[Lean.Name.components,[List.reverse, Lean.Name.components']]
[Lean.Level.dec,[Option, Lean.Level, Option.none, Option.some, OptionM.run, Bind.bind, PProd.fst, PProd.snd, Pure.pure, Lean.mkLevelMax]]
[Lean.Lsp.DocumentFilter.mk.inj,[And.intro]]
[Nat.add_le_add_right,[Eq.mpr, Eq.refl, LE.le, HAdd.hAdd, Nat.add_comm, Nat.add_le_add_left]]
[Lean.Lsp.instFromJsonClientInfo,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, String, Option, Pure.pure, Lean.Lsp.ClientInfo.mk]]
[Lean.IR.ExplicitBoxing.BoxingContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.ExplicitBoxing.BoxingContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.JsonRpc.instInhabitedNotification,[Inhabited.mk, Lean.JsonRpc.Notification.mk, arbitrary]]
[evalGuardHyp,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Lean.Elab.throwUnsupportedSyntax]]
[AddCommMonoid.noConfusionType,[]]
[Lean.IR.ExplicitBoxing.getEnv,[Functor.map, Lean.IR.ExplicitBoxing.BoxingContext.env, MonadReader.read]]
[Lean.NameTrie.find?,[Lean.PrefixTree.find?, List.nil, List, Lean.NamePart, PProd.fst, List.cons, Lean.NamePart.str, Lean.NamePart.num]]
[DivInvMonoid.gpow_neg',[]]
[Lean.IR.instBEqCtorInfo,[BEq.mk, Lean.IR.CtorInfo.beq]]
[Lean.Meta.withLocalDeclsD,[Lean.Meta.withLocalDecls, Array.map, Prod, Lean.Name, Lean.BinderInfo, Lean.Expr, Prod.mk, Lean.BinderInfo.default]]
[Option.isSome,[Unit.unit, Bool, Bool.true, Bool.false]]
[Nat.succ_mul_succ_eq,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Nat.succ, HAdd.hAdd, OfNat.ofNat, Nat.mul_succ, Nat.succ_mul, Nat.add_right_comm, rfl]]
[MonadControl.liftWith,[]]
[Lean.Lsp.instFileSourceDocumentSymbolParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.DocumentSymbolParams.textDocument]]
[UInt32.xor,[UInt32.mk, Fin.xor, UInt32.val]]
[Lean.IR.updateLiveVars,[Lean.IR.LiveVars.collectExpr]]
[Lean.Meta.RecursorInfo.motivePos,[Lean.Meta.RecursorInfo.numParams]]
[Lean.Syntax.MonadTraverser.getIdx,[Bind.bind, MonadState.get, Pure.pure, Option.getD, Array.back?, Lean.Syntax.Traverser.idxs, OfNat.ofNat]]
[Lean.ExternAttrData.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.instInhabitedReducibilityHints,[Inhabited.mk, Lean.ReducibilityHints.opaque]]
[Lean.MessageDataContext.env,[]]
[Lean.Server.Watchdog.shutdown,[Bind.bind, MonadReader.read, ST.Ref.get, Lean.Server.Watchdog.ServerContext.fileWorkersRef, ForIn.forIn, PUnit.unit, Lean.Server.Watchdog.ServerM, ForInStep, PUnit, Lean.Server.Watchdog.terminateFileWorker, Pure.pure, ForInStep.yield, Functor.discard, liftM, IO.wait, Lean.Server.Watchdog.FileWorker.commTask]]
[Lean.Lsp.instToJsonCompletionOptions,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Lsp.CompletionOptions.triggerCharacters?, Lean.Lsp.CompletionOptions.allCommitCharacters?, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.CompletionOptions.resolveProvider, List.nil]]
[Lean.MessageData.ofGoal.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.addBuiltinParser,[Bind.bind, ST.Ref.get, Lean.Parser.builtinParserCategoriesRef, IO.ofExcept, Lean.Parser.addParser, ST.Ref.set, ST.Ref.modify, Lean.Parser.builtinSyntaxNodeKindSetRef, Lean.Parser.ParserInfo.collectKinds, Lean.Parser.Parser.info, ST.Ref.swap, Lean.Parser.builtinTokenTable, EmptyCollection.emptyCollection, IO, Unit, Lean.Parser.addParserTokens, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString]]
[Std.PersistentHashMap.find!,[Unit.unit, Std.PersistentHashMap.find?, panicWithPosWithDecl, OfNat.ofNat]]
[List.nil_append,[rfl]]
[Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.Do.ToTerm.matchNestedTermResult,[Bind.bind, Array.mapM, Lean.mkIdentFromRef, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Array.getOp, Array.foldrM, Array.back, Array.extract, HSub.hSub, Unit.unit, Lean.MacroM, List, Lean.Syntax, Array.isEmpty, Functor.map, panicWithPosWithDecl]]
[Lean.Xml.Parser.VersionNum,[SeqLeft.seqLeft, Lean.Parsec.skipString, Lean.Parsec.many1, Lean.Parsec.digit]]
[Lean.instInhabitedStructureState,[Inhabited.mk, arbitrary]]
[Lean.Server.Watchdog.OpenDocument.noConfusionType,[]]
[Lean.Parser.Command.private.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Function.left_inverse_iff_comp,[Iff.intro, Function.left_inverse.comp_eq_id, congr_fun]]
[Lean.Elab.Term.Do.DoIfView.mk.inj,[And.intro]]
[Lean.Expr.isConst,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[Lean.Elab.Term.LVal.fieldName.inj,[And.intro]]
[Lean.getModuleDoc?,[Option.map, Lean.PersistentEnvExtension.getModuleEntries, Lean.Environment.getModuleIdx?]]
[Classical.byContradiction,[Decidable.byContradiction]]
[PLift.down,[]]
[UInt32.modn,[UInt32.mk, HMod.hMod, UInt32.val]]
[Std.ShareCommon.Object.ptrEq,[BEq.beq, ptrAddrUnsafe]]
[Lean.Lsp.WorkspaceFolder.uri,[]]
[IO.FS.Stream.readLspRequestAs,[MonadExcept.tryCatch, Bind.bind, Unit.unit, IO, Nat, List.lookup, String.toNat?, Pure.pure, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, IO.FS.Stream.readRequestAs]]
[Lean.Meta.InductionSubgoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.InductionSubgoal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.applyResult,[Lean.Elab.Term.TermElabM, Bind.bind, Lean.Elab.Term.SavedState.restore, Bool.true, Pure.pure, MonadExcept.throw]]
[Array.getD,[dite, LT.lt, Array.size, Array.get, Fin.mk]]
[Std.HashSet.contains,[Bool, Std.HashSetImp.contains]]
[Lean.Parser.Term.doIfCond.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.none, Bool.false, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.doIfLet.parenthesizer, Lean.Parser.Term.doIfProp.parenthesizer]]
[Lean.Lsp.instToJsonPlainTermGoal,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.PlainTermGoal.goal, List.nil, Lean.Lsp.PlainTermGoal.range]]
[Lean.Lsp.DiagnosticWith.range,[]]
[OfScientific.ofScientific,[]]
[Lean.Parser.Tactic.symm',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Std.PersistentArray.Stats.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.Do.isMutableLet,[and, or, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, not, Lean.Syntax.isNone, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Compiler.SpecEntry.noConfusionType,[]]
[Substring.all,[not, Substring.any]]
[Lean.Elab.Term.Do.getDoPatDeclVars,[Lean.Elab.Term.Do.getPatternVarsEx]]
[Lean.Elab.Term.CollectPatternVars.Context.namedArgs,[]]
[Lean.Meta.AbstractMVars.State.lmap,[]]
[Lean.Compiler.isOfNat,[List.any, Lean.Compiler.numScalarTypes, BEq.beq, Lean.Compiler.NumScalarTypeInfo.ofNatFn]]
[Lean.JsonRpc.Message.notification.inj,[And.intro]]
[Lean.mkProj,[Lean.Expr.proj, Lean.Expr.mkData, mixHash, UInt8.toUInt64, Hashable.hash, Lean.Expr.looseBVarRange, Lean.Expr.hasFVar, Lean.Expr.hasExprMVar, Lean.Expr.hasLevelMVar, Lean.Expr.hasLevelParam]]
[Lean.Lsp.instInhabitedDiagnosticTag,[Inhabited.mk, Lean.Lsp.DiagnosticTag.unnecessary]]
[Lean.PrettyPrinter.Formatter.ident.formatter,[Lean.Parser.Term.ident.formatter]]
[Lean.Elab.Command.Scope.varUIds,[]]
[Lean.Meta.lambdaMetaTelescope,[List.toArray, List.nil, OfNat.ofNat, Lean.Meta.lambdaMetaTelescope.process]]
[Lean.MessageData.tagged.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MessageData.tagged, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.axiom.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.Command.declSig.parenthesizer]]
[Lean.Parser.scientificLit,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.scientificLitKind, Bool.true, Lean.Parser.scientificLitNoAntiquot]]
[Lean.Compiler.mkLcProof,[Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Lean.Lsp.DocumentHighlightParams.noConfusionType,[]]
[Lean.IR.AltCore.default.inj,[]]
[Set.«term{_|_}_1»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Mathlib.ExtendedBinder.extBinders]]
[Lean.Elab.Term.levelMVarToParam,[Bind.bind, Lean.MonadMCtx.getMCtx, Lean.Elab.Term.getLevelNames, liftM, Lean.Meta.setMCtx, Lean.MetavarContext.UnivMVarParamResult.mctx, Pure.pure, Prod.mk, Lean.MetavarContext.UnivMVarParamResult.expr, Lean.MetavarContext.UnivMVarParamResult.nextParamIdx]]
[Lean.ParametricAttributeImpl.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ParametricAttributeImpl.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.MVarRenaming.mk.inj,[]]
[Lean.Parser.Term.str.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.strLit.parenthesizer]]
[Lean.Lsp.instFromJsonDiagnosticCode,[Lean.FromJson.mk, Lean.Json.null, Lean.Json.bool, dite, Eq, Eq.symm, Lean.Json.num, Lean.JsonNumber.mk, Lean.Json.arr, Lean.Json.obj, Except, String, Lean.Lsp.DiagnosticCode, Pure.pure, Lean.Lsp.DiagnosticCode.int, Lean.Lsp.DiagnosticCode.string, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Lean.Xml.Content.Comment.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.instMonadResolveName,[Lean.MonadResolveName.mk, liftM, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls]]
[Lean.Meta.mkAppOptM,[Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.withNewMCtxDepth, Bind.bind, Lean.getConstInfo, List.mapM, Lean.Meta.mkFreshLevelMVar, Lean.ConstantInfo.levelParams, Pure.pure, Prod.mk, Lean.Meta.MetaM, Lean.Expr, OfNat.ofNat, List.toArray, List.nil]]
[Lean.Meta.instOrElseMetaM,[OrElse.mk, Lean.Meta.orElse]]
[Lean.Elab.Term.expandTermUnless,[Lean.withRef, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Lean.Meta.CaseArraySizesSubgoal.diseqs,[]]
[ST.Ref.noConfusionType,[]]
[Lean.StructureFieldInfo.fieldName,[]]
[Lean.LocalInstance.className,[]]
[FloatArray.foldlMUnsafe.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bind.bind, FloatArray.uget, lcProof, FloatArray.foldlMUnsafe.fold, HAdd.hAdd, OfNat.ofNat]]
[IO.FS.Mode.readWrite.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.SynthInstance.instInhabitedConsumerNode,[Inhabited.mk, Lean.Meta.SynthInstance.ConsumerNode.mk, arbitrary]]
[Lean.getPPExplicit,[Lean.KVMap.get, Lean.Option.name, Lean.pp.explicit, Lean.getPPAll]]
[Lean.PrettyPrinter.Parenthesizer.symbolNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken]]
[Lean.Elab.Term.throwErrorIfErrors,[Bind.bind, MonadState.get, ite, Eq, Lean.MessageLog.hasErrors, Lean.Elab.Term.State.messages, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Nat.coprime.coprime_div_left,[Nat.coprime, HDiv.hDiv, Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, Nat.eq_zero_of_zero_dvd, Eq.mp, Dvd.dvd, congrFun, congrArg, Nat.zero_div, HMul.hMul, Nat.mul_div_cancel_left, Nat.coprime.coprime_mul_left]]
[Lean.ScopedEnvExtension.Entry.scoped.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ScopedEnvExtension.Entry.scoped, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.NameTrie.foldMatchingM,[Lean.PrefixTree.foldMatchingM, List.nil, List, Lean.NamePart, PProd.fst, List.cons, Lean.NamePart.str, Lean.NamePart.num]]
[Lean.Meta.withMCtx,[Lean.Meta.mapMetaM, Bind.bind, Lean.MonadMCtx.getMCtx, Lean.Meta.setMCtx, tryFinally]]
[UInt32.instNumericUInt32,[Numeric.mk, UInt32.mk, Numeric.ofNat]]
[Lean.Level.isMaxIMax,[Lean.Level.zero, Lean.Level.succ, Lean.Level.param, Lean.Level.mvar, Bool, Bool.true, Bool.false]]
[Lean.Parser.Command.optDeclSig,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.many, Lean.Parser.ppSpace, HOrElse.hOrElse, Lean.Parser.Term.simpleBinderWithoutType, Lean.Parser.Term.bracketedBinder, Bool.false, Lean.Parser.Term.optType]]
[Lean.Elab.Term.Context.mayPostpone,[]]
[Lean.KeyedDeclsAttribute.AttributeEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.DiscrTree.Key.fvar.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.DiscrTree.Key.fvar, Eq.symm, eq_of_heq, HEq.refl]]
[IO.toEIO,[EStateM.adaptExcept]]
[Tactic.DeclCache.get,[Bind.bind, Tactic.Cache.get, Prod.fst, Lean.MonadEnv.getEnv, ForIn.forIn, Lean.Meta.MetaM, ForInStep, Prod.snd, Pure.pure, PUnit.unit, ForInStep.yield]]
[Lean.instInhabitedMessage,[Inhabited.mk, Lean.Message.mk, arbitrary]]
[Lean.Elab.Term.elabForall,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Term.elabBinders, Bind.bind, Lean.Elab.Term.elabType, liftM, Lean.Meta.mkForallFVars, Bool.false, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Elab.Term.ElabAppArgs.synthesizeAppInstMVars,[Bind.bind, MonadState.get, modify, Lean.Elab.Term.ElabAppArgs.State.mk, Lean.Elab.Term.ElabAppArgs.State.explicit, Lean.Elab.Term.ElabAppArgs.State.f, Lean.Elab.Term.ElabAppArgs.State.fType, Lean.Elab.Term.ElabAppArgs.State.args, Lean.Elab.Term.ElabAppArgs.State.namedArgs, Lean.Elab.Term.ElabAppArgs.State.ellipsis, Lean.Elab.Term.ElabAppArgs.State.expectedType?, Lean.Elab.Term.ElabAppArgs.State.etaArgs, Lean.Elab.Term.ElabAppArgs.State.toSetErrorCtx, List.toArray, List.nil, Lean.Elab.Term.ElabAppArgs.State.propagateExpected, liftM, Lean.Elab.Term.synthesizeAppInstMVars]]
[Lean.Widget.InfoPopup.type,[]]
[instMonadExceptOfEIO,[inferInstanceAs, MonadExceptOf, EStateM, IO.RealWorld]]
[Lean.Meta.CongrArgKind.fixedNoParam.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[CommGroup.noConfusionType,[]]
[Nat.noConfusionType,[]]
[Lean.JsonRpc.RequestID.str.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.UnreachableBranches.Assignment,[Std.HashMap, Lean.IR.VarId, Lean.IR.UnreachableBranches.Value]]
[Lean.Lsp.Command.mk.inj,[And.intro]]
[noConfusionTypeEnum,[ite, Eq]]
[Lean.LocalDecl.hasExprMVar,[Bool, Lean.Expr.hasExprMVar, or]]
[Lean.Elab.Term.Quotation.HeadCheck.shape.inj,[And.intro]]
[Lean.Widget.TaggedText.text.inj,[]]
[Lean.Parser.Command.elabTail.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.darrow.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.declareBuiltin,[Bind.bind, Lean.MonadEnv.getEnv, Lean.Core.CoreM, Unit, Lean.Environment.addAndCompile, Lean.KVMap.mk, liftM, Lean.MessageData.toString, Lean.KernelException.toMessageData, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, IO.ofExcept, Lean.setBuiltinInitAttr, Lean.Name.anonymous, Lean.setEnv]]
[Decidable.not_imp_self,[]]
[Iff.trans,[Iff.intro, Iff.mp, Iff.mpr]]
[Lean.Parser.Trie.Node.inj,[And.intro]]
[Lean.Parser.ParserState.toErrorMsg,[Unit.unit, String, Lean.Parser.ParserState.errorMsg, Lean.mkErrorStringWithPos, Lean.Parser.InputContext.fileName, Lean.Parser.ParserContext.toInputContext, ToString.toString, Option.none]]
[Applicative.toSeq,[]]
[Lean.ClassEntry.lt,[Lean.Name.quickLt, Lean.ClassEntry.name]]
[Lean.PrettyPrinter.Formatter.withOpen.formatter,[]]
[Lean.Meta.SizeOfSpecNested.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instMulUInt8,[Mul.mk, UInt8.mul]]
[Lean.KernelException.declHasMVars.inj,[And.intro]]
[Lean.IR.LogEntry.message.inj,[]]
[UInt8.instRingUInt8.proof_3,[congrArg, UInt8.mk, Ring.gsmul_succ', UInt8.val]]
[Lean.ParserCompiler.CombinatorAttribute.setDeclFor,[Lean.PersistentEnvExtension.addEntry, Lean.ParserCompiler.CombinatorAttribute.ext, Prod.mk]]
[Lean.SimplePersistentEnvExtensionDescr.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[guard,[ite, Pure.pure, Unit.unit, Alternative.failure]]
[Lean.Parser.Term.doSeq.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.doSeqBracketed.parenthesizer, Lean.Parser.Term.doSeqIndent.parenthesizer]]
[Lean.Compiler.atMostOnce.AtMostOnceData.noConfusionType,[]]
[Lean.unreachIsNodeAtom,[False.elim, Lean.unreachIsNodeAtom.proof_1]]
[Lean.LOption.some.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.Watchdog.ServerEvent.clientError.inj,[]]
[List.mem,[Unit.unit, False, Or, Eq, PProd.fst]]
[Lean.Elab.Frontend.updateCmdPos,[modify, Lean.Elab.Frontend.State.mk, Lean.Elab.Frontend.State.commandState, Lean.Elab.Frontend.State.parserState, Lean.Parser.ModuleParserState.pos, Lean.Elab.Frontend.State.commands]]
[String.prev,[String.Pos, ite, Eq, OfNat.ofNat, PProd.fst]]
[Lean.Parser.Term.quotedName.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.nameLit.parenthesizer]]
[Lean.isPrivateNameExport,[Lean.isPrivateName]]
[Lean.Parser.Command.mixfixKind.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.prefix.parenthesizer, Lean.Parser.Command.infix.parenthesizer, Lean.Parser.Command.infixl.parenthesizer, Lean.Parser.Command.infixr.parenthesizer, Lean.Parser.Command.postfix.parenthesizer]]
[PSigma.lexNdepWf,[PSigma.lexNdepWf.proof_1]]
[Lean.NameSet.empty,[Std.mkRBTree, Lean.Name, Lean.Name.quickCmp]]
[Lean.Meta.Simp.ConfigCtx.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.instEmptyCollectionFVarIdMap,[inferInstanceAs, EmptyCollection, Std.RBMap, Lean.FVarId, Lean.Name.quickCmp, Lean.FVarId.name]]
[Lean.Lsp.WorkDoneProgressReport.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Tactic.Ring.horner_const_mul,[of_eq_true, Eq.trans, congr, congrArg, Eq, mul_add, HMul.hMul, HPow.hPow, HAdd.hAdd, congrFun, Eq.symm, mul_assoc, eq_self]]
[Lean.Lsp.CompletionList.isIncomplete,[]]
[ST.Ref.set,[liftM, ST.Prim.Ref.set]]
[Lean.TransformStep.visit.injEq,[Eq.propIntro, Eq.refl, Lean.TransformStep.visit, Eq.symm, eq_of_heq, HEq.refl]]
[IO.Error.mkResourceExhausted,[IO.Error.resourceExhausted, Option.none]]
[Lean.IR.CompilerState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Expr.isMData,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[Lean.Parser.PrattParsingTables.leadingTable,[]]
[ReaderT.bind,[Bind.bind]]
[instIsAddLeftCancel.proof_1,[Eq.mpr, Eq.refl, Eq, Eq.symm, neg_add_cancel_left, HAdd.hAdd, Neg.neg, rfl]]
[if_congr_prop,[if_ctx_congr_prop]]
[Lean.Level.format,[Lean.Level.PP.Result.format, Lean.Level.PP.toResult, Bool.true]]
[Lean.Lsp.instFromJsonDiagnosticTag,[Lean.FromJson.mk, Except.error, dite, Eq, Unit.unit, Eq.symm, Except.ok, Except, String, Lean.Lsp.DiagnosticTag, Lean.Json.getNat?, Pure.pure, Lean.Lsp.DiagnosticTag.unnecessary, Lean.Lsp.DiagnosticTag.deprecated, MonadExcept.throw]]
[Lean.IR.ExpandResetReuse.main,[Lean.IR.Decl.extern, Lean.IR.Decl, Lean.IR.Decl.updateBody!]]
[byContra,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[instDecidableAnd.proof_2,[And.left]]
[Lean.Elab.Command.StructView.parents,[]]
[Lean.Widget.instInhabitedMsgToInteractive,[Inhabited.mk, Lean.Widget.MsgToInteractive.mk, arbitrary]]
[Std.PersistentArray.isEmpty,[BEq.beq, Std.PersistentArray.size, OfNat.ofNat]]
[Lean.Elab.Term.saveContext,[Bind.bind, MonadReader.read, Lean.MonadOptions.getOptions, Lean.MonadResolveName.getOpenDecls, Pure.pure, Lean.Elab.Term.SavedContext.mk, Lean.Elab.Term.Context.declName?, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.errToSorry]]
[coeOfTC,[CoeHTCT.mk, coeTC]]
[Lean.ParserCompiler.Context.categoryAttr,[]]
[Lean.Elab.Deriving.Ord.mkAuxFunction,[Bind.bind, Pure.pure, Array.getOp, Lean.Elab.Deriving.Context.auxFunNames, Lean.Elab.Deriving.Context.typeInfos, Lean.Elab.Deriving.Ord.mkOrdHeader, Lean.Elab.Deriving.Ord.mkMatch, ite, Eq, or, Lean.Elab.Deriving.Context.usePartial, Lean.InductiveVal.isRec, Bool.true, Lean.Elab.Deriving.mkLocalInstanceLetDecls, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.Deriving.Header.argNames, Lean.Elab.Deriving.mkLet, PUnit.unit]]
[Lean.Xml.Parser.EnumeratedType,[HOrElse.hOrElse, Lean.Xml.Parser.NotationType, Lean.Xml.Parser.Enumeration]]
[Lean.Elab.addMacroStack,[Bind.bind, Lean.MonadOptions.getOptions, ite, Eq, not, Lean.Option.get, Lean.Elab.pp.macroStack, Bool.true, Pure.pure, Unit.unit, List.cons, Lean.MessageData, List.foldl, HAppend.hAppend, Lean.MessageData.ofFormat, Std.Format.line, Function.comp, Std.ToFormat.format, Lean.indentD, Lean.MessageData.ofSyntax, Lean.Elab.MacroStackElem.before]]
[Lean.Compiler.CSimp.replaceConstants,[Lean.Expr.replace, ite, Eq, Lean.Expr.isConst, Bool.true, Unit.unit, Option, Lean.Expr, Lean.SMap.find?, Lean.Expr.constName!, Option.some, Lean.mkConst, Lean.Expr.constLevels!, Option.none]]
[Int.sub_nat_self,[Unit.unit, Eq, Int.subNatNat, OfNat.ofNat, rfl, Eq.mpr, Eq.refl, Nat.succ, Int.subNatNat_of_sub_eq_zero, HSub.hSub, Nat.sub_self, Int.ofNat, Int.ofNat_zero]]
[left_inv_eq_right_inv,[Eq.mpr, Eq.refl, Eq, Eq.symm, one_mul, HMul.hMul, OfNat.ofNat, mul_assoc, mul_one, rfl]]
[List.mem_of_mem_erasep,[List.erasep_subset]]
[Lean.registerInitAttrUnsafe,[Lean.registerParametricAttribute, Lean.ParametricAttributeImpl.mk, Lean.AttributeImplCore.mk, Bind.bind, Lean.getConstInfo, Lean.Attribute.Builtin.getIdent?, Unit.unit, Lean.AttrM, Lean.Name, Lean.resolveGlobalConstNoOverload, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Expr, Option.some, Option.none, Lean.ConstantInfo.type, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, ite, BEq.beq, Bool.true, Pure.pure, Bool, Bool.false, MonadReader.read, liftM, Lean.isInitializerExecutionEnabled, and, ForIn.forIn, PUnit.unit, Lean.ImportM, ForInStep, PUnit, Lean.Name.isAnonymous, IO.ofExcept, Lean.Environment.evalConst, IO, Unit, Lean.ImportM.Context.env, Lean.ImportM.Context.opts, ForInStep.yield, Lean.runInit]]
[Lean.mkSepArray,[Id.run, Bind.bind, ForIn.forIn, MProd.mk, ite, GT.gt, OfNat.ofNat, Pure.pure, PUnit.unit, Id, Array, Lean.Syntax]]
[Lean.Meta.RecursorInfo.numParams,[List.length, Lean.Meta.RecursorInfo.paramsPos]]
[UInt32.val_eq_of_eq,[Eq, UInt32.val, congrArg]]
[Lean.Syntax.forArgsM,[Lean.Syntax.foldArgsM, Unit.unit]]
[Lean.SMap.numBuckets,[Std.HashMap.numBuckets, Lean.SMap.map₁]]
[Lean.Compiler.foldNatAdd,[Lean.Compiler.foldNatBinOp, Add.add]]
[Squash.lift,[Quot.lift, Squash.lift.proof_1]]
[Lean.IR.Borrow.BorrowInfState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.liftMethod.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.minPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.leftArrow.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Lean.Parser.Tactic.Conv.convApply_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.Server.Snapshots.Snapshot.mk.inj,[And.intro]]
[Char.instDecidableLt,[UInt32.decLt, Char.val]]
[IO.Error.userError.injEq,[Eq.propIntro, Eq.refl, IO.Error.userError, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.ParserExtension.State.mk.inj,[And.intro]]
[Lean.Meta.SimpAll.State.mvarId,[]]
[Lean.Parser.Command.classTk,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Lean.Parser.Attr.recursor,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.numLit]]
[Lean.Widget.MsgEmbed.lazyTrace.inj,[And.intro]]
[Lean.MetavarContext.instantiateMVarDeclMVars,[Lean.MetavarContext, Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Std.PersistentHashMap.insert, Lean.MetavarContext.decls, Lean.MetavarDecl.mk, Lean.MetavarDecl.userName, Lean.MetavarDecl.depth, Lean.MetavarDecl.localInstances, Lean.MetavarDecl.kind, Lean.MetavarDecl.numScopeArgs, Lean.MetavarDecl.index, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment]]
[Lean.Parser.Tactic.nthRw,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.Lsp.DiagnosticTag.deprecated.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[GroupWithZero.noConfusionType,[]]
[Lean.Parsec,[Lean.Parsec.ParseResult]]
[Lean.Meta.getParamNames,[Bind.bind, Lean.getConstInfo, Lean.Meta.forallTelescopeReducing, Lean.ConstantInfo.type, Array.mapM, Lean.Meta.getLocalDecl, Lean.Expr.fvarId!, Pure.pure, Lean.LocalDecl.userName]]
[Lean.Lsp.DocumentFilter.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.DocumentFilter.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Deriving.Repr.mkBody,[Bind.bind, Lean.MonadEnv.getEnv, ite, Eq, Lean.isStructure, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Bool.true, Lean.Elab.Deriving.Repr.mkBodyForStruct, Lean.Elab.Deriving.Repr.mkBodyForInduct]]
[control,[controlAt]]
[Lean.Lsp.SemanticTokens.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.ExpandResetReuse.M,[ReaderT, Lean.IR.ExpandResetReuse.Context, StateM, Nat]]
[Lean.Json.bool.inj,[]]
[ByteArray.instEmptyCollectionByteArray,[EmptyCollection.mk, ByteArray.empty]]
[Lean.Meta.whnfR,[Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.reducible, Lean.Meta.whnf]]
[Lean.Parser.ParserAttributeHook.postAdd,[]]
[Lean.Elab.Term.Context.isNoncomputableSection,[]]
[AddMonoid.toAddSemigroup,[]]
[Std.PersistentHashMap.div2Shift,[USize.shiftRight]]
[List.instForInList,[ForIn.mk, List.forIn]]
[Lean.instInhabitedDeclarationRanges,[Inhabited.mk, Lean.DeclarationRanges.mk, arbitrary]]
[Lean.ScopedEnvExtension.Entry.noConfusionType,[]]
[Fin.xor,[Fin, Fin.mk, HMod.hMod, Nat.xor, Fin.xor.proof_1]]
[StateT.get,[Pure.pure, Prod.mk]]
[Lean.Literal.typeEx,[Lean.Literal.type]]
[Lean.Elab.elabAttrs,[Bind.bind, ForIn.forIn, Lean.Elab.elabAttr, Pure.pure, PUnit.unit, ForInStep.yield]]
[Lean.Elab.Command.mkDefViewOfInstance,[Bind.bind, Lean.Elab.liftMacroM, Lean.Elab.toAttributeKind, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.expandOptNamedPrio, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Lean.Quote.quote, List.nil, Lean.Elab.Command.CommandElabM, Lean.Elab.DefView, Unit.unit, Lean.Syntax.getOptional?, Lean.Elab.Command.MkInstanceName.main, Lean.mkNode, Lean.mkIdentFrom, Lean.mkNullNode]]
[Nat.lcm_assoc,[Nat.dvd_antisymm, Nat.lcm_dvd, Nat.dvd_lcm_left, Nat.lcm, Nat.dvd_trans, Nat.dvd_lcm_right]]
[Lean.Elab.Tactic.Conv.applySimpResult,[ite, Eq, Option.isNone, Lean.Meta.Simp.Result.proof?, Bool.true, Lean.Elab.Tactic.Conv.changeLhs, Lean.Meta.Simp.Result.expr, Bind.bind, liftM, Lean.Meta.Simp.Result.getProof, Lean.Elab.Tactic.Conv.updateLhs]]
[Lean.PrettyPrinter.Parenthesizer.unicodeSymbolNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken]]
[Lean.PrettyPrinter.Formatter.checkOutsideQuot.formatter,[Pure.pure, Unit.unit]]
[Lean.Meta.IndPredBelow.getBelowIndices,[Bind.bind, Lean.getConstInfoCtor, Lean.Name.updatePrefix, HAppend.hAppend, Lean.ConstructorVal.induct, Lean.Name.mkStr, Lean.Name.anonymous, Lean.getConstInfoInduct, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, List.toArray, List.nil, OfNat.ofNat, Lean.Meta.IndPredBelow.getBelowIndices.loop]]
[Lean.Xml.instToStringElement,[ToString.mk]]
[List.insert_of_mem,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, if_pos, List, List.cons, eq_self]]
[Lean.mkNoConfusion,[Bind.bind, Lean.isEnumType, ite, Eq, Bool.true, Lean.mkNoConfusionEnum, Lean.mkNoConfusionCore]]
[IO.FS.Stream.writeMessage,[IO.FS.Stream.writeJson, Lean.ToJson.toJson]]
[Lean.NameSSet.contains,[Lean.SSet.contains]]
[Lean.Meta.renameMVar,[Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.renameMVar]]
[instAddCommMonoid,[AddCommMonoid.mk, AddCommGroup.add_comm]]
[Lean.Parser.FirstTokens.instToStringFirstTokens,[ToString.mk, Lean.Parser.FirstTokens.toStr]]
[Lean.Parser.Tactic.applyModCast,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.Elab.WF.TerminationHint.many.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.DiscrTree.Key.lit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.subset_cons,[Or.inr]]
[List.length_replicate,[List.nil, List.length_replicate.aux]]
[Array.reduceOption,[Array.filterMap, id, OfNat.ofNat, Array.size]]
[Lean.Lsp.DeclarationParams.toTextDocumentPositionParams,[]]
[Lean.MetavarContext.elimMVarDeps,[Lean.MetavarContext.MkBinding.elimMVarDeps]]
[Lean.Lsp.PlainTermGoal.noConfusionType,[]]
[Lean.Meta.getMVarsNoDelayed,[Bind.bind, Lean.Meta.getMVars, Array.filterM, Functor.map, not, Lean.Meta.isDelayedAssigned, OfNat.ofNat, Array.size]]
[Lean.Lsp.DocumentSymbolResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.ParserCategory.mk.inj,[And.intro]]
[Lean.PrettyPrinter.Delaborator.delabDIte,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPNotation, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, guard, Eq, BEq.beq, Lean.Expr.getAppNumArgs, OfNat.ofNat, Bool.true, Lean.PrettyPrinter.Delaborator.SubExpr.withAppFn, Lean.PrettyPrinter.Delaborator.SubExpr.withAppArg, Lean.PrettyPrinter.Delaborator.delab, Option.none, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Option.some, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Lean.mkIdent, List.nil, Lean.PrettyPrinter.Delaborator.delabDIte.delabBranch]]
[Lean.Meta.mkFunExt,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil]]
[Lean.KeyedDeclsAttribute.AttributeEntry.noConfusionType,[]]
[Lean.Expr.FindImpl.visited,[Bind.bind, MonadState.get, ite, Eq, BEq.beq, ptrAddrUnsafe, Bool.true, Pure.pure, modify, Lean.Expr.FindImpl.State.mk, Array.uset, Lean.Expr.FindImpl.State.keys, Lean.Expr.FindImpl.visited.proof_2, Bool.false]]
[List.mem_of_ne_of_mem,[Or.elim, List.eq_or_mem_of_mem_cons, absurd]]
[Lean.Meta.replaceLocalDeclDefEq,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getMVarDecl, ite, Eq, BEq.beq, Lean.MetavarDecl.type, Bool.true, Pure.pure, Lean.MonadLCtx.getLCtx, Lean.Meta.getLocalInstances, Lean.Meta.mkFreshExprMVarAt, Lean.MetavarDecl.kind, Lean.MetavarDecl.userName, OfNat.ofNat, Lean.Meta.assignExprMVar, Lean.Expr.mvarId!]]
[UInt8.le,[LE.le, UInt8.val]]
[Std.HashSetBucket.update.proof_1,[Eq.mpr, Eq.refl, GT.gt, Array.size, Array.uset, Subtype.val, OfNat.ofNat, Array.size_set, Fin.mk, USize.toNat, Subtype.property]]
[String.nextUntil,[String.nextWhile, not]]
[Set.term𝒫_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.IR.JoinPointId.mk.inj,[]]
[Lean.Meta.SortLocalDecls.State.visited,[]]
[mul_comm,[CommSemigroup.mul_comm]]
[Lean.Elab.GoalsAtResult.noConfusionType,[]]
[Lean.instFromJsonJsonNumber,[Lean.FromJson.mk, Lean.Json.getNum?]]
[UInt64.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Level.PP.Result.offset.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PersistentEnvExtensionDescr.mkInitial,[]]
[Nat.discriminate,[Eq.refl]]
[ByteArray.instAppendByteArray,[Append.mk, ByteArray.append]]
[Lean.Meta.Simp.ConfigCtx.toConfig,[]]
[UInt32.instCommRingUInt32,[CommRing.mk, UInt32.instCommRingUInt32.proof_1]]
[TC.accessible,[TC.accessible.proof_1]]
[Lean.NameSSet.instEmptyCollectionNameSSet,[EmptyCollection.mk, Lean.NameSSet.empty]]
[Lean.Parser.Syntax.sepBy1,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.syntaxParser, Lean.Parser.strLit, Lean.Parser.optional, Lean.Parser.nonReservedSymbol, Bool.false]]
[instOrdFin,[Ord.mk, Ord.compare, Fin.val]]
[Int.ofNat_mul_negSucc_ofNat,[rfl]]
[HEq.trans,[HEq.subst]]
[Lean.Parser.Tactic.padicIndexSimp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[«prec(_)»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[Lean.Macro.instInhabitedState,[Inhabited.mk, Lean.Macro.State.mk, arbitrary]]
[Lean.Meta.Match.MkMatcherInput.numDiscrs,[]]
[Int.natMod,[Int.toNat, HMod.hMod]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isFunLike,[Bind.bind, Lean.Meta.inferType, Lean.Meta.forallTelescopeReducing, Pure.pure, Decidable.decide, GT.gt, Array.size, OfNat.ofNat]]
[Lean.Meta.SimpLemma.levelParams,[]]
[Lean.Elab.Term.MkInstResult.outParams,[]]
[ReaderT,[]]
[type_eq_of_heq.proof_1,[HEq.ndrecOn, Eq.refl]]
[Lean.Meta.Hypothesis.userName,[]]
[Lean.ScopedEnvExtension.State.mk.inj,[And.intro]]
[Lean.Meta.FVarSubst.isEmpty,[Std.AssocList.isEmpty, Lean.Meta.FVarSubst.map]]
[dec_em,[Decidable.em]]
[Lean.Elab.Command.StructFieldView.modifiers,[]]
[Lean.InductiveVal.isRecEx,[Lean.InductiveVal.isRec]]
[not_of_eq_false,[]]
[Set.sUnion,[setOf, Exists, And, Mem.mem]]
[Lean.Elab.Term.Do.ToTerm.instInhabitedKind,[Inhabited.mk, Lean.Elab.Term.Do.ToTerm.Kind.regular]]
[Lean.Elab.Command.CtorView.noConfusionType,[]]
[Lean.MessageData.instCoeListExprMessageData,[Coe.mk, Lean.MessageData.ofList, List.map, Lean.MessageData.ofExpr]]
[min_le_left,[dite, LE.le, of_eq_true, Eq.trans, congrFun, congrArg, if_pos, eq_true, le_refl, Eq.mpr, if_neg, le_of_not_le]]
[Lean.Message.caption,[]]
[Lean.Widget.CodeToken.info,[]]
[Lean.Elab.Frontend.Context.inputCtx,[]]
[Lean.Meta.ToHide.fixpointStep,[Bind.bind, MonadReader.read, Lean.Meta.ToHide.visitVisibleExpr, Lean.Meta.ToHide.Context.goalTarget, Lean.MonadLCtx.getLCtx, Lean.LocalContext.forM, MonadState.get, ite, Eq, Std.RBTree.contains, Lean.Meta.ToHide.State.hiddenInaccessible, Bool.true, Lean.Meta.ToHide.hasVisibleDep, Lean.Meta.ToHide.unmark, Pure.pure, PUnit.unit, Lean.LocalDecl.type, Option.none, Lean.Meta.ToHide.M, PUnit, Lean.LocalDecl.value?, Unit.unit]]
[Lean.InternalExceptionId.noConfusionType,[]]
[Lean.Widget.InteractiveTermGoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Widget.InteractiveTermGoal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.FnBody.uset.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.uset, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Quotation.precheckParen,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Pure.pure, Unit.unit, Bind.bind, Lean.Elab.Term.Quotation.precheck, Array.forM, Lean.Syntax.SepArray.getElems, Array.size, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Elab.Term.expandParen,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, List.cons, Prod.mk, List.nil, Lean.Elab.Term.expandCDot?, Unit.unit, Lean.MacroM, Lean.Syntax, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, Lean.Syntax.atom, Lean.Macro.throwUnsupported, Lean.Elab.Term.mkPairs, HAppend.hAppend, Lean.Syntax.SepArray.getElems, Option.getD, and, not, Lean.Syntax.isMissing, Lean.Syntax.getOp, MonadExcept.throw, Lean.Macro.Exception.error]]
[UInt32.val_eq_of_lt,[Fin.val_eq_of_lt]]
[not_iff_not_of_iff,[Iff.intro, Iff.elim_right, Iff.elim_left]]
[Lean.Lsp.SemanticTokensLegend.noConfusionType,[]]
[Lean.instInhabitedMVarId,[Inhabited.mk, Lean.MVarId.mk, arbitrary]]
[Lean.Parser.Command.structImplicitBinder,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.Command.declModifiers, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.Command.inferMod, Lean.Parser.Command.declSig]]
[Lean.Meta.postprocessAppMVars,[Bind.bind, Lean.Meta.synthAppInstances, Lean.Meta.appendParentTag]]
[Lean.Meta.CongrLemmas.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.FileWorker.RefIdent.fvar.injEq,[Eq.propIntro, Eq.refl, Lean.Server.FileWorker.RefIdent.fvar, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.mkNameMap,[Std.mkRBMap, Lean.Name, Lean.Name.quickCmp]]
[Lean.Lsp.SemanticTokenType.noConfusion,[noConfusionEnum, Lean.Lsp.SemanticTokenType.toCtorIdx]]
[Lean.Parser.Term.namedArgument.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.termParser.formatter]]
[Lean.LocalContext.foldlM,[Std.PersistentArray.foldlM, Lean.LocalContext.decls, Unit.unit, Pure.pure]]
[Lean.Parser.Term.strictImplicitLeftBracket.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.group.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter]]
[Nat.eq_zero_of_add_eq_zero,[And.intro, Nat.eq_zero_of_add_eq_zero_right, Nat.eq_zero_of_add_eq_zero_left]]
[Std.Format.append.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.BinderView.noConfusionType,[]]
[Option.orElse,[Option, Option.some, Unit.unit]]
[Lean.Meta.SimpLemmas.add.getName?,[Unit.unit, Lean.Meta.MetaM, Option, Lean.Name, Pure.pure, ite, Eq, Lean.Expr.isConst, Bool.true, Option.some, Lean.Expr.constName!, Lean.Expr.isFVar, Bind.bind, Lean.Meta.getFVarLocalDecl, Lean.LocalDecl.userName, Option.none]]
[Lean.Elab.Tactic.getMainGoal,[Bind.bind, Lean.Elab.Tactic.getGoals, Lean.Elab.Tactic.getMainGoal.loop]]
[Lean.Elab.Command.instMonadMacroAdapterCommandElabM,[Lean.Elab.MonadMacroAdapter.mk, Lean.MonadQuotation.getCurrMacroScope, Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Command.State.nextMacroScope, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState]]
[dif_eq_if,[Eq, dite, ite, rfl]]
[Lean.TagAttribute.ext,[]]
[Lean.Syntax.instCoeArraySyntaxSepArray,[Coe.mk, Lean.Syntax.SepArray.ofElems]]
[System.FilePath.exeExtension,[ite, Eq, System.Platform.isWindows, Bool.true]]
[Lean.Meta.Match.withMkMatcherInput,[Bind.bind, Lean.Meta.getMatcherInfo?, Option.none, Lean.Meta.MetaM, Lean.getConstInfo, Lean.Meta.forallBoundedTelescope, Lean.ConstantInfo.type, Option.some, Lean.Meta.Match.MatcherInfo.arity, Lean.mkConstWithLevelParams, Lean.ConstantInfo.name, Lean.Meta.matchMatcherApp?, Lean.Meta.Match.getMkMatcherInputInContext, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.Lsp.SemanticTokensOptions.noConfusionType,[]]
[Lean.List.toExprAux,[Unit.unit, Lean.Expr, Lean.mkApp2, Lean.ToExpr.toExpr, PProd.fst]]
[Lean.Elab.Command.checkValidFieldModifier,[ite, Eq, Lean.Elab.Modifiers.isNoncomputable, Bool.true, Bind.bind, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.MessageData.isNil,[Unit.unit, Lean.MessageData.ofFormat, Std.Format.line, Std.Format.text, Std.Format.nest, Std.Format.append, Std.Format.group, Std.Format.tag, Lean.MessageData.ofSyntax, Lean.MessageData.ofExpr, Lean.MessageData.ofLevel, Lean.MessageData.ofName, Lean.MessageData.ofGoal, Lean.MessageData.withContext, Lean.MessageData.withNamingContext, Lean.MessageData.nest, Lean.MessageData.group, Lean.MessageData.compose, Lean.MessageData.tagged, Lean.MessageData.node, Bool, Bool.true, Bool.false]]
[Lean.Core.Context.currRecDepth,[]]
[Lean.Elab.Term.withDeclName,[MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Option.some, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.currMacroScope, Lean.Elab.Term.Context.mayPostpone, Lean.Elab.Term.Context.errToSorry, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.Term.Context.autoBoundImplicits, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection]]
[Inter.noConfusionType,[]]
[Lean.Parser.Term.doIf.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.doIfCond.formatter, Lean.Parser.Term.doSeq.formatter, Lean.Parser.many.formatter, Lean.PrettyPrinter.Formatter.checkColGe.formatter, Lean.Parser.group.formatter, Lean.Parser.Term.elseIf.formatter, Lean.Parser.optional.formatter]]
[Lean.Meta.Match.Pattern.inaccessible.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.ToHide.visitVisibleExpr,[Bind.bind, liftM, Lean.Meta.instantiateMVars, Lean.MonadCacheT.run, Lean.Meta.ToHide.visitVisibleExpr.visit]]
[Nat.lcm_one_right,[Nat.lcm_one_left, Nat.lcm_comm, OfNat.ofNat]]
[Array.data_toArray,[Eq, List.toArray, Array.data, Array.ext', List.toArray_data]]
[Lean.Server.Watchdog.ServerEvent.clientMsg.inj,[]]
[Lean.Elab.Term.MutualClosure.LetRecClosure.closed,[]]
[Lean.Meta.Match.Alt.ref,[]]
[Lean.LocalContext.instForInLocalContextLocalDecl,[ForIn.mk, Std.PersistentArray.forIn, Lean.LocalContext.decls, Unit.unit, ForInStep, Pure.pure, ForInStep.yield]]
[Lean.Json.obj.injEq,[Eq.propIntro, Eq.refl, Lean.Json.obj, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.LetRecDeclView.ref,[]]
[Lean.Elab.Command.elabModuleDoc,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Lean.Elab.Command.CommandElabM, Unit, Lean.Syntax.getOp, OfNat.ofNat, Lean.MonadEnv.modifyEnv, Lean.addMainModuleDoc, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.ofSyntax]]
[Lean.Level.ctorToNat,[Nat, OfNat.ofNat]]
[Lean.IR.Borrow.BorrowInfCtx.env,[]]
[DivInvMonoid.toMonoid,[]]
[Lean.Parsec.instInhabitedParsec,[Inhabited.mk, Lean.Parsec.ParseResult.error]]
[Lean.Meta.decLevel,[Bind.bind, Lean.Meta.decLevel?, Unit.unit, Lean.Meta.MetaM, Lean.Level, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[ne_or_eq,[em', Eq]]
[Lean.PrettyPrinter.Delaborator.instMonadWithReaderOfSubExprDelabM,[MonadWithReaderOf.mk, Lean.PrettyPrinter.Delaborator.Context.mk, Lean.PrettyPrinter.Delaborator.Context.defaultOptions, Lean.PrettyPrinter.Delaborator.Context.optionsPerPos, Lean.PrettyPrinter.Delaborator.Context.currNamespace, Lean.PrettyPrinter.Delaborator.Context.openDecls, Lean.PrettyPrinter.Delaborator.Context.inPattern, Lean.PrettyPrinter.Delaborator.Context.subExpr]]
[Lean.Lsp.InitializationOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.ToExpr.toTypeExpr,[]]
[Lean.Expr.FoldConstsImpl.State.mk.inj,[And.intro]]
[Lean.Parser.Tactic.simpLemma,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.Parser.Tactic.simpPre, Lean.Parser.Tactic.simpPost, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat]]
[Lean.Syntax.noConfusionType,[]]
[instComplementUInt8,[Complement.mk, UInt8.complement]]
[Lean.instBEqData,[BEq.mk, BEq.beq]]
[EStateM.orElse',[EStateM.Result.ok, EStateM.Result, EStateM.Backtrackable.restore, EStateM.Result.error, ite, Eq, Bool.true]]
[Lean.Compiler.UnFoldFn,[Option, Lean.Expr]]
[Lean.Elab.Tactic.evalAlt,[Lean.Elab.Tactic.withCaseRef, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, Lean.Elab.Tactic.isHoleRHS, Bool.true, Bind.bind, Lean.Meta.withMVarContext, Lean.withRef, liftM, Lean.Meta.getMVarDecl, Lean.Elab.Tactic.elabTermEnsuringType, Option.some, Lean.MetavarDecl.type, Bool.false, Lean.Meta.assignExprMVar, Lean.Meta.getMVarsNoDelayed, Lean.Elab.Tactic.tagUntaggedGoals, Lean.MetavarDecl.userName, Lean.Name.mkStr, Lean.Name.anonymous, Array.toList, Pure.pure, HAppend.hAppend, Lean.Elab.Tactic.setGoals, List.cons, List.nil, Lean.Elab.Tactic.closeUsingOrAdmit, Lean.Elab.Tactic.withTacticInfoContext, Lean.Elab.Tactic.evalTactic]]
[Array.any,[Id.run, Array.anyM]]
[Lean.Server.RpcEncoding.noConfusionType,[]]
[Lean.Elab.Tactic.State.goals,[]]
[ExceptCpsT.runCatch,[Pure.pure]]
[Lean.Elab.Term.checkLeftRec,[Bind.bind, MonadReader.read, ite, Eq, and, Lean.Elab.Term.ToParserDescrContext.first, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, PUnit.unit, Bool.false]]
[Lean.Elab.Term.Quotation.Precheck.Context.mk.inj,[]]
[Lean.Elab.Term.Do.Code.decl.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Code.decl, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.instFromJsonMarkupKind,[Lean.FromJson.mk, Lean.Json.null, Lean.Json.bool, Lean.Json.num, dite, Eq, Unit.unit, Eq.symm, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Except, String, Lean.Lsp.MarkupKind, Except.ok, Lean.Lsp.MarkupKind.plaintext, Lean.Lsp.MarkupKind.markdown, MonadExcept.throw]]
[Lean.MonadRef.mkInfoFromRefPos,[Bind.bind, Lean.MonadRef.getRef, Pure.pure, Lean.SourceInfo.fromRef]]
[Lean.Meta.forallMetaBoundedTelescope,[List.toArray, List.nil, OfNat.ofNat, Bool.true, Option.some]]
[Lean.instCoeStringDataValue,[Coe.mk, Lean.DataValue.ofString]]
[Lean.ConstantInfo.ctorInfo.injEq,[Eq.propIntro, Eq.refl, Lean.ConstantInfo.ctorInfo, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.NormalizeIds.normArgs,[Array.map, Lean.IR.NormalizeIds.normArg]]
[Lean.Meta.FVarSubst.contains,[Std.AssocList.contains, Lean.Meta.FVarSubst.map]]
[Lean.Parser.Term.doIfCond.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.none, Bool.false, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.doIfLet.formatter, Lean.Parser.Term.doIfProp.formatter]]
[Lean.LazyInitExtension.ext,[]]
[Lean.Elab.Term.elabCDotFunctionAlias?,[Bind.bind, Lean.Elab.liftMacroM, Option.none, Lean.Elab.Term.TermElabM, Option, Lean.Expr, Lean.expandMacros, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, BEq.beq, MonadExcept.tryCatch, Lean.Elab.Term.resolveId?, Bool.false, Pure.pure, DoResultPR.pure, PUnit.unit, DoResultPR.return, List.toArray, List.cons, List.nil, Lean.Elab.Term.elabCDotFunctionAlias?.expandCDotArg?]]
[Lean.getExternAttrData,[Lean.ParametricAttribute.getParam, Lean.externAttr]]
[Lean.Level.quote,[Lean.Level.PP.Result.quote, Lean.Level.PP.toResult]]
[Lean.Elab.Term.Do.ToTerm.Context.uvars,[]]
[Lean.AttributeExtensionState.map,[]]
[Lean.Meta.saturate,[Bind.bind, StateRefT'.run, List.toArray, List.nil, Lean.Meta.MetaM, List, Lean.MVarId, Pure.pure, Array.toList, Lean.Meta.saturate.go]]
[UInt32.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd]]
[Lean.MetavarContext.LevelMVarToParam.instMonadCacheExprStructEqExprM,[Lean.MonadCache.mk, Bind.bind, MonadState.get, Pure.pure, Std.HashMap.find?, Lean.MetavarContext.LevelMVarToParam.State.cache, modify, Lean.MetavarContext.LevelMVarToParam.State.mk, Lean.MetavarContext.LevelMVarToParam.State.mctx, Lean.MetavarContext.LevelMVarToParam.State.paramNames, Lean.MetavarContext.LevelMVarToParam.State.nextParamIdx, Std.HashMap.insert]]
[Lean.JsonRpc.ResponseError.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonRpc.ResponseError.mk, Eq.symm, eq_of_heq, HEq.refl]]
[USize.size,[HPow.hPow, OfNat.ofNat, System.Platform.numBits]]
[Lean.Parser.Tactic.pushCast,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[max_left_comm,[left_comm, max, max_comm, max_assoc]]
[Lean.Parser.Command.resolve_name.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer]]
[List.filterM,[Bind.bind, List.filterAuxM, List.nil, Pure.pure, List.reverse]]
[Lean.ResolveName.resolveNamespaceUsingScope,[Unit.unit, Lean.Name.str, Lean.Name.num, Option, Lean.Name, ite, Eq, Lean.Environment.isNamespace, Bool.true, Option.some, Option.none, HAppend.hAppend, PProd.fst, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Lsp.DiagnosticCode.string.inj,[]]
[IO.AsyncList.asyncTail.inj,[]]
[Lean.Syntax.identComponents,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, List, Lean.Syntax, ite, Eq, BEq.beq, List.length, Bool.true, List.map, Lean.Syntax.ident, List.nil, List.zip, panicWithPosWithDecl, OfNat.ofNat, HAppend.hAppend, String.toSubstring, Lean.Name.toString, Lean.Syntax.identComponents.nameComps]]
[Array.toSubarray,[dite, LE.le, Array.size, Subarray.mk, Nat.le_refl, Array.toSubarray.proof_1]]
[Lean.Parser.ParserState.pos,[]]
[Lean.Parser.Term.num,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.numLit]]
[Lean.Json.getArr?,[Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Lean.Json.obj, Except, String, Array, Lean.Json, Pure.pure, MonadExcept.throw]]
[Quotient.recOnSubsingleton,[Quot.recOnSubsingleton]]
[«term[_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false]]
[Lean.Meta.isDefEqStringLit,[ite, Eq, and, Lean.Expr.isStringLit, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Meta.toCtorIfLit, Pure.pure, Lean.LBool.undef]]
[Lean.Server.Watchdog.WorkerEvent.crashed.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[USize.instSemiringUSize.proof_8,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, USize.one_def, USize.mul_def, USize.mk, OfNat.ofNat, mul_one, USize.val, USize.mk_val_eq, eq_self, propext, forall_const, USize]]
[Lean.Elab.Tactic.Simp.DischargeWrapper.custom.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.Simp.DischargeWrapper.custom, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.addDecl,[Lean.IR.modifyEnv, Lean.PersistentEnvExtension.addEntry, Lean.IR.declMapExt]]
[MonoidWithZero.zero_mul,[]]
[le_of_not_ge,[Or.resolve_left, le_total]]
[Lean.Exception.getRef,[Lean.Syntax, Lean.Syntax.missing]]
[Lean.Meta.FVarSubst.apply,[ite, Eq, Std.AssocList.isEmpty, Lean.Meta.FVarSubst.map, Bool.true, not, Lean.Expr.hasFVar, Lean.Expr.replace, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Expr, Unit.unit, Std.AssocList.find?, Option.some, Option.none]]
[Lean.NameSet.instForInNameSetName,[inferInstanceAs, ForIn, Std.RBTree, Lean.Name, Lean.Name.quickCmp]]
[Lean.Meta.SimpEntry.toUnfold.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.structInstFieldAbbrev.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.ident.formatter, Lean.PrettyPrinter.Formatter.notFollowedBy.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.symbol.formatter]]
[Lean.instInhabitedQuotVal,[Inhabited.mk, Lean.QuotVal.mk, arbitrary]]
[Lean.KVMap.getString,[Option.none, Option.some, Lean.DataValue.ofBool, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, String, Lean.KVMap.find]]
[MonadControlT.noConfusionType,[]]
[Lean.Lsp.RpcCallParams.sessionId,[]]
[Lean.registerAttributeOfBuilder,[Bind.bind, Lean.mkAttributeImplOfBuilder, ite, Eq, Lean.isAttribute, Lean.AttributeImplCore.name, Lean.AttributeImpl.toAttributeImplCore, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Pure.pure, Lean.PersistentEnvExtension.addEntry, Lean.attributeExtension, Prod.mk, Lean.AttributeExtensionOLeanEntry.builder]]
[Lean.Json.compress,[List.cons, Lean.Json.CompressWorkItem.json, List.nil, Lean.Json.compress.go]]
[Lean.Elab.Tactic.Conv.evalSimp,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.mkSimpContext, Bool.false, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.Conv.getLhs, Lean.Elab.Tactic.Simp.DischargeWrapper.with, liftM, Lean.Meta.simp, Lean.Elab.Tactic.Conv.applySimpResult]]
[HAdd.noConfusionType,[]]
[Lean.Meta.AbstractNestedProofs.M,[ReaderT, Lean.Meta.AbstractNestedProofs.Context, Lean.MonadCacheT, Lean.ExprStructEq, Lean.Expr, StateRefT', IO.RealWorld, Lean.Meta.AbstractNestedProofs.State, Lean.Meta.MetaM]]
[Lean.IR.Borrow.BorrowInfCtx.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Borrow.BorrowInfCtx.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.UnreachableBranches.InterpState.mk.inj,[And.intro]]
[UInt64.add_def,[rfl]]
[Lean.instQuoteName,[Lean.Quote.mk, Unit.unit, Lean.Syntax, OptionM, List, String, Pure.pure, Bind.bind, Lean.Name.escapePart, PProd.fst, List.cons, Option.none, List.nil, Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, Lean.Syntax.mkNameLit, HAppend.hAppend, String.intercalate, Lean.SourceInfo.none, Lean.mkCIdent, Lean.Syntax.mkCApp, Lean.Quote.quote]]
[Lean.PersistentEnvExtension.setState,[Lean.EnvExtension.modifyState, Lean.PersistentEnvExtension.toEnvExtension, Lean.PersistentEnvExtensionState.mk, Lean.PersistentEnvExtensionState.importedEntries]]
[Lean.Elab.RecKind.noConfusion,[noConfusionEnum, Lean.Elab.RecKind.toCtorIdx]]
[Lean.Meta.isExprDefEqGuarded,[Bind.bind, MonadExcept.tryCatch, Lean.Meta.isExprDefEq, Pure.pure, DoResultPR.pure, PUnit.unit, DoResultPR.return, Bool.false, Lean.Meta.MetaM, Bool]]
[Lean.PrettyPrinter.Formatter.pushToken,[Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Lean.PrettyPrinter.FormatterM, Unit, ite, Eq, not, Substring.isEmpty, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Unit.unit]]
[Lean.ReducibilityStatus.semireducible.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[String.Range.mk.inj,[And.intro]]
[Lean.Option.Decl.mk.inj,[And.intro]]
[Lean.DeclarationRange.pos,[]]
[Int.toNat,[Nat, OfNat.ofNat]]
[UInt64.instRingUInt64.proof_3,[congrArg, UInt64.mk, Ring.gsmul_succ', UInt64.val]]
[Lean.Lsp.LocationLink.mk.inj,[And.intro]]
[Lean.Meta.FunInfo.getArity,[Array.size, Lean.Meta.FunInfo.paramInfo]]
[List.length_pos_of_ne_nil,[Iff.mpr, Nat.pos_iff_ne_zero, Iff.mp, List.length_eq_zero]]
[Lean.Json.Parser.num,[Bind.bind, Lean.Parsec.peek!, ite, Eq, Char.ofNat, Lean.Parsec.skip, Pure.pure, Neg.neg, OfNat.ofNat]]
[true_implies_iff,[Iff.intro, trivial]]
[Lean.Elab.Term.LValResolution.projIdx.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Set.instLawfulFunctorSet.proof_1,[LawfulFunctor.mk, rfl, funext, propext, Iff.intro, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Exists.intro, And.intro, Functor.map, Function.comp]]
[instInhabitedUInt16,[Inhabited.mk, UInt16.ofNatCore, OfNat.ofNat, instInhabitedUInt16.proof_1]]
[Lean.IR.mkProjExpr,[Lean.IR.Expr.proj]]
[Lean.Parser.Command.prefix,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Lean.instDecidableEqPosition,[Decidable, Eq, dite, Decidable.isTrue, rfl, Decidable.isFalse]]
[Lean.Expr.hasLevelParam,[Lean.Expr.Data.hasLevelParam, Lean.Expr.data]]
[Lean.Widget.TaggedText.text.injEq,[Eq.propIntro, Eq.refl, Lean.Widget.TaggedText.text, Eq.symm, eq_of_heq, HEq.refl]]
[Std.PersistentHashMap.instInhabitedNode,[Inhabited.mk, Std.PersistentHashMap.Node.entries, List.toArray, List.nil]]
[Lean.Parser.ParserState.mkUnexpectedError,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Array.push, Lean.Syntax.missing, Option.some, Lean.Parser.Error.mk]]
[Lean.ScopedEnvExtension.StateStack.scopedEntries,[]]
[Lean.Meta.DiscrTree.Key.fvar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Widget.InteractiveTermGoal.mk.inj,[And.intro]]
[Lean.Lsp.DiagnosticWith.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.DiagnosticWith.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.AltVarNames.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[seqLeft_eq_bind,[Eq.mpr, Eq.refl, Eq, SeqLeft.seqLeft, Bind.bind, Pure.pure, LawfulApplicative.seqLeft_eq, of_eq_true, Eq.trans, congrFun, congrArg, Seq.seq, map_eq_pure_bind, Function.const, seq_eq_bind_map, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, Function.const_apply, eq_self]]
[Lean.Elab.FieldInfo.projName,[]]
[Lean.LocalContext.forM,[Std.PersistentArray.forM, Lean.LocalContext.decls, Unit.unit, PUnit, Pure.pure, PUnit.unit]]
[Nat.one_eq_succ_zero,[rfl]]
[Lean.ProjectionFunctionInfo.ctorName,[]]
[Lean.RecursorRule.noConfusionType,[]]
[Lean.Widget.Lean.Widget.InteractiveHypothesis.instRpcEncodingInteractiveHypothesisRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Lean.Widget.InteractiveHypothesis.names, Lean.Widget.InteractiveHypothesis.type, Lean.Widget.InteractiveHypothesis.val?, Lean.Widget.InteractiveHypothesis.isInstance, Lean.Widget.InteractiveHypothesis.isType, Pure.pure, Lean.Server.RpcEncoding.rpcDecode, Lean.Widget.InteractiveHypothesis.mk]]
[UInt16.instRingUInt16,[Ring.mk, UInt16.instRingUInt16.proof_1, UInt16.mk, Ring.gsmul, UInt16.val, UInt16.instRingUInt16.proof_2, UInt16.instRingUInt16.proof_3, UInt16.instRingUInt16.proof_4, UInt16.instRingUInt16.proof_5]]
[Std.HashMap.toList,[Std.HashMap.fold, List.cons, Prod.mk, List.nil]]
[Lean.Lsp.DocumentHighlightParams.toTextDocumentPositionParams,[]]
[Array.elem,[Array.contains]]
[Lean.Meta.DefEqContext.lctx,[]]
[Lean.Meta.instInhabitedAltVarNames,[Inhabited.mk, Lean.Meta.AltVarNames.mk, arbitrary]]
[Lean.Elab.Command.ProjectionInfo.mk.inj,[And.intro]]
[Lean.Lsp.InitializedParams.toCtorIdx,[OfNat.ofNat]]
[Lean.Elab.Term.LVal.getOp.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[tacticRwa__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.Parser.Tactic.location]]
[exists_prop,[Iff.intro, And, And.intro, Exists, Exists.intro]]
[Lean.Elab.Deriving.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.unreachIsNodeAtom.proof_1,[Eq.refl, Lean.Syntax.atom, HEq.refl, False]]
[Function.bijective.comp,[Function.bijective, Function.comp, And.intro, Function.injective.comp, Function.surjective.comp]]
[Lean.Parser.Command.infixl.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.Meta.mkSorry,[Bind.bind, Lean.Meta.getLevel, Pure.pure, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil, Lean.ToExpr.toExpr]]
[Lean.MonadStateCacheT.run,[StateT.run', Std.mkHashMap, OfNat.ofNat]]
[Lean.KVMap.subset,[Bool, Lean.KVMap.subsetAux]]
[Lean.Parser.Term.doIfLetPure.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[instDecidableEqBool.proof_1,[]]
[Set.«term{_}»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.ParserDescr.cat, Bool.false]]
[Lean.Parser.interpolatedStrNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.interpolatedStrFn, Lean.Parser.Parser.fn]]
[Lean.KeyedDeclsAttribute.ExtensionState.erased,[]]
[Array.«term__[_:_]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Quotient.recOn,[Quot.recOn]]
[Lean.LeanPaths.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Deriving.Hashable.mkHashFuncs,[Bind.bind, ForIn.forIn, Lean.Elab.Deriving.Hashable.mkAuxFunction, Pure.pure, PUnit.unit, ForInStep.yield, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil]]
[Nat.below,[PUnit, PProd]]
[Lean.Meta.IndPredBelow.proveBrecOn.closeGoal,[Bind.bind, Lean.Meta.isExprMVarAssigned, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.IndPredBelow.proveBrecOn.introNPRec, Lean.Meta.IndPredBelow.backwardsChaining, Lean.Meta.withMVarContext, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Name.mkStr, Lean.Name.anonymous, Lean.MessageData.ofGoal]]
[Int.mul_assoc,[Eq, HMul.hMul, of_eq_true, Eq.trans, congr, congrArg, congrFun, Int.ofNat_mul_ofNat, Int.ofNat, Nat.mul_assoc, eq_self, Eq.symm, Int.negSucc, Int.ofNat_mul_negSucc_ofNat, Int.negOfNat, Nat.succ, Int.ofNat_mul_negOfNat, Eq.refl, Int.negOfNat_mul_ofNat, Int.negSucc_ofNat_ofNat, Int.negOfNat_mul_negSucc_ofNat, Int.mul_negSucc_ofNat_negSucc_ofNat, Int.negSucc_ofNat_mul_negOfNat]]
[absurd,[False.elim]]
[Lean.Parser.ParserModuleContext.options,[]]
[Lean.mkLevelSuccEx,[Lean.mkLevelSucc]]
[Lean.Parser.levelParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.PrettyPrinter.Delaborator.delabProjectionApp,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPStructureProjections, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Pure.pure, Lean.Expr.getAppFn, Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Lean.MonadEnv.getEnv, Lean.Environment.getProjectionFnInfo?, Option.none, guard, Eq, not, Lean.ProjectionFunctionInfo.fromClass, Bool.true, BEq.beq, Lean.Expr.getAppNumArgs, HAdd.hAdd, Lean.ProjectionFunctionInfo.numParams, OfNat.ofNat, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPExplicit, or, Lean.PrettyPrinter.Delaborator.SubExpr.withAppArg, Lean.PrettyPrinter.Delaborator.delab, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, List.toArray, List.cons, Lean.Syntax.atom, Lean.mkIdent, Lean.Name.mkSimple, List.nil, Alternative.failure]]
[List.decidableBexi.proof_1,[False, False.elim, Iff.mp, List.mem_nil]]
[Lean.ofExcept,[Pure.pure, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, ToString.toString]]
[Nat.repeat.loop,[PProd.fst]]
[Lean.Elab.Term.resolveLocalName,[Bind.bind, Lean.MonadLCtx.getLCtx, Pure.pure, Lean.MacroScopesView.name, List.nil, Lean.Elab.Term.resolveLocalName.loop]]
[Lean.Lsp.MarkupContent.kind,[]]
[mul_left_cancel_iff,[Iff.intro, mul_left_cancel, congrArg, HMul.hMul]]
[Std.Format.bracket,[Std.Format.group, Std.Format.nest, Int.ofNat, String.length, HAppend.hAppend, Std.Format.text, Std.Format.FlattenBehavior.allOrNone]]
[Lean.Parser.Command.elabArg.formatter,[Lean.Parser.Command.macroArg.formatter]]
[Lean.SSet.forM,[Lean.SMap.forM]]
[Lean.Lsp.DiagnosticRelatedInformation.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.DiagnosticRelatedInformation.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Json.instToFormatJson,[Std.ToFormat.mk, Lean.Json.render]]
[Lean.Elab.ExpandDeclIdResult.declName,[]]
[Lean.Elab.Command.StructFieldKind.subobject.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[imp.swap,[Iff.intro, Function.swap]]
[Lean.Meta.CongrLemma.theoremName,[]]
[Lean.Elab.Tactic.elabTerm,[Lean.withRef, Bind.bind, liftM, Lean.Elab.Term.elabTerm, Bool.true, Lean.Elab.Term.synthesizeSyntheticMVars, Bool.false, Lean.Meta.instantiateMVars]]
[Lean.Parser.Term.doLetArrow.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.doIdDecl.formatter, Lean.Parser.Term.doPatDecl.formatter]]
[not_or_distrib,[Iff.intro, And.intro, Or.inl, Or.inr, False, Or.elim]]
[String.split,[String.splitAux, OfNat.ofNat, List.nil]]
[FloatArray.push,[FloatArray, FloatArray.mk, Array.push]]
[Lean.Parser.rawIdentNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.rawIdentFn]]
[Lean.instInhabitedPersistentEnvExtension,[Inhabited.mk, Lean.PersistentEnvExtension.mk, arbitrary, List.toArray, List.nil, Std.Format.nil]]
[Substring.prev,[String.Pos, ite, Eq, HSub.hSub, String.prev]]
[Lean.IR.Param.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.Index.lt,[Decidable.decide, LT.lt]]
[heq_of_eq_rec_right,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, HEq, HEq.rfl]]
[Lean.MetavarContext.MkBinding.MCore,[EStateM, Lean.MetavarContext.MkBinding.Exception, Lean.MetavarContext.MkBinding.State]]
[Substring.str,[]]
[Lean.Elab.Term.ElabAppArgs.eraseNamedArg,[modify, Lean.Elab.Term.ElabAppArgs.State.mk, Lean.Elab.Term.ElabAppArgs.State.explicit, Lean.Elab.Term.ElabAppArgs.State.f, Lean.Elab.Term.ElabAppArgs.State.fType, Lean.Elab.Term.ElabAppArgs.State.args, Lean.Elab.Term.ElabAppArgs.eraseNamedArgCore, Lean.Elab.Term.ElabAppArgs.State.namedArgs, Lean.Elab.Term.ElabAppArgs.State.ellipsis, Lean.Elab.Term.ElabAppArgs.State.expectedType?, Lean.Elab.Term.ElabAppArgs.State.etaArgs, Lean.Elab.Term.ElabAppArgs.State.toSetErrorCtx, Lean.Elab.Term.ElabAppArgs.State.instMVars, Lean.Elab.Term.ElabAppArgs.State.propagateExpected]]
[Lean.Widget.InteractiveGoal.hyps,[]]
[Lean.Elab.Term.expandTermTry,[Lean.withRef, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Lean.Parser.Term.termTry,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.doSeq, Lean.Parser.many, HOrElse.hOrElse, Lean.Parser.Term.doCatch, Lean.Parser.Term.doCatchMatch, Lean.Parser.optional, Lean.Parser.Term.doFinally]]
[instDecidableIff.proof_1,[Iff.intro]]
[Lean.Parser.Tactic.locationHyp,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Lean.Elab.InfoTree.ibelow,[And, True]]
[Lean.Parser.rawCh,[Lean.Parser.Parser.mk, Lean.Parser.chFn]]
[Lean.HeadIndex.const.inj,[]]
[Array.getMax?,[dite, LT.lt, OfNat.ofNat, Array.size, Option.some, Array.foldl, ite, Eq, Bool.true, Option.none]]
[Lean.Meta.mkForallFVars,[ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Lean.Meta.liftMkBindingM, Lean.MetavarContext.mkForall]]
[Lean.ExternEntry.backend,[Lean.Name]]
[heq_iff_eq,[Iff.intro, eq_of_heq, heq_of_eq]]
[Lean.Meta.saveState,[Bind.bind, getThe, Lean.Core.State, MonadState.get, Pure.pure, Lean.Meta.SavedState.mk]]
[instOrOpUInt16,[OrOp.mk, UInt16.lor]]
[Std.Range.forM,[Std.Range.stop, Std.Range.start, Std.Range.forM.loop]]
[Lean.Parser.Command.optDefDeriving.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.notSymbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.ident.parenthesizer, Bool.false]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withBindingBody,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Meta.withLocalDecl, Lean.Expr.binderInfo, Lean.Expr.bindingDomain!, Lean.PrettyPrinter.Delaborator.SubExpr.descend, Lean.Expr.instantiate1, Lean.Expr.bindingBody!, OfNat.ofNat]]
[Lean.Lsp.TextDocumentItem.version,[]]
[Lean.Elab.Command.ElabStructResult.lctx,[]]
[Lean.Parser.Term.optEllipsis,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.optional, Lean.Parser.symbol]]
[Lean.Parser.Tactic.paren,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[Lean.IR.MapVars.mapArg,[Lean.IR.Arg.irrelevant, Lean.IR.Arg, Lean.IR.Arg.var]]
[Char.valid,[]]
[if_neg,[Eq, ite, absurd, rfl]]
[Lean.Parser.Command.terminationHintMany,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.lookahead, Lean.Parser.ident, Lean.Parser.symbol, Lean.Parser.many1Indent, Lean.Parser.group, Lean.Parser.ppLine, Lean.Parser.optional]]
[IO.Error.otherErrorToString,[Unit.unit, String, HAppend.hAppend, String.modify, OfNat.ofNat, Char.toLower, ToString.toString]]
[Lean.Parser.Term.anonymousCtor,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.sepBy, Lean.Parser.termParser, Bool.false]]
[Lean.Meta.mkSub,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getDecLevel, Lean.Meta.synthInstance, Lean.mkApp3, Lean.mkConst, List.cons, List.nil, Option.none, Pure.pure, Lean.mkApp6, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Parser.ParserFn,[Lean.Parser.ParserState]]
[Lean.KVMap.setInt,[Lean.KVMap.insert, Lean.DataValue.ofInt]]
[Lean.Parser.notFollowedByTermToken,[Lean.Parser.notFollowedByCategoryToken, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.instReprBinderInfo,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone]]
[Lean.Meta.isInductivePredicate,[Bind.bind, Lean.MonadEnv.getEnv, Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.Meta.MetaM, Bool, Lean.Environment.find?, Lean.Meta.forallTelescopeReducing, Lean.Meta.whnfD, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Pure.pure, BEq.beq, Lean.levelZero, Bool.false]]
[Lean.instToExprOption,[Lean.ToExpr.mk, Unit.unit, Lean.Expr, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.levelZero, List.nil, Lean.mkApp2, Lean.ToExpr.toExpr]]
[min_left_comm,[left_comm, min, min_comm, min_assoc]]
[Lean.Elab.Deriving.Hashable.mkMatch.mkAlts,[Bind.bind, ForIn.forIn, MProd.mk, Lean.getConstInfoCtor, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, liftM, Lean.Core.betaReduce, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, PUnit.unit, ForInStep.yield, Lean.Quote.quote, Lean.Meta.inferType, Lean.Core.mkFreshUserName, Unit.unit, Lean.Elab.Term.TermElabM, ForInStep, MProd, Array, Lean.Syntax, Array.findIdx?, BEq.beq, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Lean.mkIdent, Array.getOp, Lean.Elab.Deriving.Context.auxFunNames, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom]]
[Lean.Parser.Term.funBinder.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.evalInsideQuot, Lean.Parser.Term.funBinder]]
[Ne.symm,[Eq.symm]]
[UInt64.instSemiringUInt64.proof_10,[rfl]]
[List.instBEqList,[BEq.mk, List.beq]]
[Lean.Lsp.instToJsonDocumentSymbolResult,[Lean.ToJson.mk, Lean.ToJson.toJson, Lean.Lsp.DocumentSymbolResult.syms]]
[Lean.Parser.Term.binderDefault.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.Expr.getArg!,[Lean.Expr.getRevArg!, HSub.hSub, OfNat.ofNat]]
[IO.Error.noFileOrDirectory.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Match.Pattern.as.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.Pattern.as, Eq.symm, eq_of_heq, HEq.refl]]
[Std.RBMap.revFold,[Std.RBNode.revFold]]
[ByteSliceT.toSlice,[ByteSlice, ByteSlice.mk, HSub.hSub, ByteArray.size]]
[UInt32.mul,[UInt32.mk, HMul.hMul, UInt32.val]]
[Lean.Parser.Syntax.atom.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.strLit.formatter]]
[Lean.Elab.Tactic.Context.noConfusionType,[]]
[Lean.IR.Checker.CheckerState.foundVars,[]]
[Lean.Meta.Match.MatcherResult.addMatcher,[]]
[IO.FS.readFile,[Bind.bind, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.false, IO.FS.Handle.readToEnd]]
[Lean.Meta.SimpAll.State.mk.inj,[And.intro]]
[Array.mapIdx,[Id.run, Array.mapIdxM]]
[Lean.Parser.octalNumberFn,[Lean.Parser.mkNodeToken, Lean.numLitKind]]
[Lean.Parser.Term.typeAscription,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser]]
[Lean.getRegularInitFnNameFor?,[Lean.getInitFnNameForCore?, Lean.regularInitAttr]]
[fixCore1,[bfix1, USize.size]]
[Lean.Parser.Term.haveIdDecl,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.Term.haveIdLhs, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat, Bool.false]]
[Lean.Elab.Tactic.getNameOfIdent',[ite, Eq, Lean.Syntax.isIdent, Bool.true, Lean.Syntax.getId, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.ExprStructEq.noConfusionType,[]]
[Lean.Lsp.SemanticTokensLegend.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.SemanticTokensLegend.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.IndPredBelow.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Preorder.lt_iff_le_not_le,[]]
[Lean.Elab.Term.Quotation.Precheck.Context.noConfusionType,[]]
[instReprFloat,[Repr.mk, Std.Format.text, Float.toString]]
[Lean.Elab.Level.instMonadOptionsLevelElabM,[Lean.MonadOptions.mk, Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Level.Context.options]]
[Lean.Meta.getDecLevel,[Bind.bind, Lean.Meta.getLevel, Lean.Meta.decLevel]]
[Lean.Parser.Tactic.open.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.openDecl.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withOpenDecl.parenthesizer, Lean.Parser.Tactic.tacticSeq.parenthesizer]]
[instOfNatUInt64,[OfNat.mk, UInt64.ofNat]]
[Lean.Compiler.uintBinFoldFns,[List.foldl, HAppend.hAppend, List.map, Prod, Lean.Name, Lean.Compiler.BinFoldFn, Prod.mk, Lean.Compiler.NumScalarTypeInfo.id, Lean.Compiler.preUIntBinFoldFns, List.nil, Lean.Compiler.numScalarTypes]]
[Subtype.instDecidableEqSubtype,[Decidable, Eq, Subtype.mk, dite, Decidable.isTrue, Subtype.instDecidableEqSubtype.proof_1, Decidable.isFalse, Subtype.instDecidableEqSubtype.proof_2]]
[IO.FS.Stream.readRequestAs,[Bind.bind, IO.FS.Stream.readMessage, Lean.JsonRpc.Message.notification, Lean.JsonRpc.Message.response, Lean.JsonRpc.Message.responseError, IO, Lean.JsonRpc.Request, ite, Eq, Lean.FromJson.fromJson?, Pure.pure, Lean.JsonRpc.Request.mk, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Lean.Json.compress, Lean.ToJson.toJson]]
[Array.append,[Array.foldl, Array.push, OfNat.ofNat, Array.size]]
[Lean.Elab.logError,[Lean.Elab.log, Lean.MessageSeverity.error]]
[Lean.Lsp.instToJsonDocumentSymbol,[Lean.ToJson.mk, Lean.Lsp.instToJsonDocumentSymbol.go]]
[Lean.Lsp.instFromJsonTextDocumentIdentifier,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, Pure.pure, Lean.Lsp.TextDocumentIdentifier.mk]]
[Lean.Meta.Match.Pattern.noConfusionType,[]]
[Empty.elim,[sorryAx, Bool.true]]
[Lean.Elab.Frontend.runCommandElabM,[Bind.bind, MonadReader.read, MonadState.get, liftM, EIO.toIO', StateRefT'.run, Lean.Elab.Frontend.State.commandState, Lean.Elab.Frontend.FrontendM, Lean.MessageData.toString, Lean.Exception.toMessageData, MonadExcept.throw, IO.Error.userError, HAppend.hAppend, ToString.toString, Lean.Elab.Frontend.setCommandState, Pure.pure]]
[Lean.Parser.Command.runCmd,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser]]
[Ring.gsmul,[]]
[Lean.TheoremVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.TheoremVal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Json.getNat?,[Lean.Json.null, Lean.Json.bool, dite, Eq, Eq.symm, Lean.Json.num, Lean.JsonNumber.mk, Int.ofNat, Int.negSucc, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Except, String, Nat, Pure.pure, MonadExcept.throw]]
[Lean.Parser.identEq,[Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.identEqFn]]
[Lean.Widget.InteractiveTermGoal.noConfusionType,[]]
[Lean.Meta.mkEqMPR,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil]]
[Lean.Meta.Match.MatcherResult.unusedAltIdxs,[]]
[not_lt,[Iff.intro, le_of_not_gt, not_lt_of_ge]]
[Lean.Elab.Command.getRef,[Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Command.Context.ref]]
[Lean.Meta.getExprMVarAssignment?,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.getExprAssignment?]]
[Lean.Syntax.decodeScientificLitVal?,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Option.none, Char.isDigit, Lean.Syntax.decodeScientificLitVal?.decodeAfterExp, Lean.Syntax.decodeScientificLitVal?.decodeExp, Lean.Syntax.decodeScientificLitVal?.decodeAfterDot, Lean.Syntax.decodeScientificLitVal?.decode]]
[Array.foldlMUnsafe.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bind.bind, Array.uget, lcProof, Array.foldlMUnsafe.fold, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Term.doPatDecl.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.termParser.formatter, Lean.Parser.Term.leftArrow.formatter, Lean.Parser.doElemParser.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.checkColGt.formatter, Lean.Parser.symbol.formatter]]
[IO.FS.withFile,[Bind.bind, IO.FS.Handle.mk, Bool.true]]
[Lean.instQuoteString,[Lean.Quote.mk, Lean.Syntax.mkStrLit, Lean.SourceInfo.none]]
[Lean.Elab.Command.instAddErrorMessageContextCommandElabM,[Lean.AddErrorMessageContext.mk, Bind.bind, MonadReader.read, Lean.AddMessageContext.addMessageContext, Lean.Elab.addMacroStack, Lean.Elab.Command.Context.macroStack, Pure.pure, Prod.mk]]
[Std.RBTree.contains,[Option.isSome, Std.RBTree.find?]]
[Lean.Parser.Term.ident,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.ident]]
[Lean.Parser.Tactic.set_option.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter, Lean.ppSpace.formatter, Lean.Parser.Command.optionValue.formatter, Lean.Parser.Tactic.tacticSeq.formatter]]
[Lean.CollectLevelParams.State.visitedExpr,[]]
[Lean.Meta.SortLocalDecls.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.ReduceEval.reduceEval,[]]
[Lean.Exception.error.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Exception.error, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.sepBy1.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.sepBy1NoAntiquot.parenthesizer, Lean.Parser.sepByElemParser.parenthesizer]]
[Lean.Parser.eoi,[Lean.Parser.Parser.mk, Lean.Parser.eoiFn]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withMDataExpr,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, withTheReader, Lean.PrettyPrinter.Delaborator.SubExpr, Lean.PrettyPrinter.Delaborator.SubExpr.mk, Lean.PrettyPrinter.Delaborator.SubExpr.pos, panicWithPosWithDecl, OfNat.ofNat]]
[List.hasDecidableLt.proof_2,[Eq.refl, List.cons, List.nil, HEq.refl, False]]
[Substring.takeRightWhile,[Substring, Substring.mk]]
[Lean.LocalContext.findDecl?,[Id.run, Lean.LocalContext.findDeclM?]]
[Or.by_cases',[dite, Or.resolve_right]]
[Prod.allI,[Nat.anyAux, not, Prod.snd, HSub.hSub, Prod.fst]]
[Lean.Parser.nameLit,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.nameLitKind, Bool.true, Lean.Parser.nameLitNoAntiquot]]
[Lean.Parser.checkNoWsBefore,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.checkNoWsBeforeFn]]
[IO.FS.DirEntry.root,[]]
[Std.HashSetImp.erase.proof_1,[Subtype.property]]
[instDecidableLt_3,[UInt64.decLt]]
[instModUInt8,[Mod.mk, UInt8.mod]]
[Lean.PrefixTreeNode.find?,[Lean.PrefixTreeNode.find?.loop]]
[OrElse.orElse,[]]
[Lean.AttributeKind.toCtorIdx,[OfNat.ofNat]]
[Lean.CollectFVars.State.fvarSet,[]]
[StateCpsT.instLawfulMonadStateCpsT,[StateCpsT.instLawfulMonadStateCpsT.proof_1]]
[Lean.Parser.Term.binrel.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec]]
[Lean.traceCtx,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, not, Bool.true, Lean.enableTracing, Bool.false, tryFinally, Lean.MonadRef.getRef, Lean.getTraces, Lean.modifyTraces, Std.PersistentArray.mk, Pure.pure, Std.PersistentArray.isEmpty, Std.PersistentArray.push, Lean.TraceElem.mk]]
[IO.AsyncList.cons.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.collectTrivialBottomUps,[Bind.bind, MonadReader.read, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit, ForIn.forIn, PUnit.unit, ite, Eq, BEq.beq, Array.getOp, Lean.BinderInfo.default, Bool.true, andM, liftM, Lean.Meta.instantiateMVars, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.hasMVarAtCurrDepth, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isTrivialBottomUp, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.tryUnify, modify, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk, Array.set!, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.bottomUps, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.higherOrders, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.funBinders, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.provideds, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.namedArgs, Pure.pure, ForInStep.yield]]
[Lean.IR.FnBody.inc.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Sigma.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[WellFounded.fix'.impl,[WellFounded.fix'.impl]]
[Lean.IR.Checker.CheckerState.noConfusionType,[]]
[IO.FS.Stream.readNotificationAs,[Bind.bind, IO.FS.Stream.readMessage, Lean.JsonRpc.Message.request, Lean.JsonRpc.Message.response, Lean.JsonRpc.Message.responseError, IO, Lean.JsonRpc.Notification, ite, Eq, Lean.FromJson.fromJson?, Pure.pure, Lean.JsonRpc.Notification.mk, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Lean.Json.compress, Lean.ToJson.toJson]]
[Lean.Meta.CaseArraySizesSubgoal.mk.inj,[And.intro]]
[Lean.Server.FileWorker.handleSemanticTokens.highlightId,[Option.none, ReaderT, Lean.Server.FileWorker.SemanticTokensContext, StateT, Lean.Server.FileWorker.SemanticTokensState, Lean.Server.RequestM, PUnit, Lean.Syntax.getRange?, Bool.false, Bind.bind, MonadReader.read, ForIn.forIn, ite, LT.lt, Pure.pure, ForInStep.yield, PUnit.unit]]
[lt_of_le_not_le,[LT.lt, Iff.mpr, lt_iff_le_not_le, And.intro]]
[npow_rec,[OfNat.ofNat, HMul.hMul, PProd.fst]]
[Lean.JsonRpc.Notification.mk.inj,[And.intro]]
[Lean.Elab.Frontend.State.cmdPos,[]]
[Lean.Level.PP.Result.imaxNode.injEq,[Eq.propIntro, Eq.refl, Lean.Level.PP.Result.imaxNode, Eq.symm, eq_of_heq, HEq.refl]]
[Int.instCommRingInt.proof_2,[rfl]]
[Lean.Elab.InfoTree.ofJson.inj,[]]
[Lean.Elab.Tactic.ElimApp.State.insts,[]]
[Lean.IR.DeclInfo.mk.injEq,[Eq.propIntro, Eq.refl, Lean.IR.DeclInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.PlainGoal.noConfusionType,[]]
[Nat.toUInt32,[UInt32.ofNat]]
[List.disjoint_nil_left,[Not.elim, List.not_mem_nil]]
[Lean.Parser.Term.doSeq,[HOrElse.hOrElse, Lean.Parser.Term.doSeqBracketed, Lean.Parser.Term.doSeqIndent]]
[Lean.Elab.instInhabitedPreDefinition,[Inhabited.mk, Lean.Elab.PreDefinition.mk, arbitrary]]
[Lean.SMap.contains,[Bool, Std.HashMap.contains, or, Std.PersistentHashMap.contains]]
[Lean.Meta.NormNum.instLawfulOfNat_2,[Lean.Meta.NormNum.instLawfulOfNat_2.proof_1]]
[Lean.PrettyPrinter.Formatter.orelse.formatter,[HOrElse.hOrElse]]
[PProd.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, PProd.mk, Eq.symm, eq_of_heq, HEq.refl]]
[instReprPUnit,[Repr.mk, Std.Format.text]]
[Lean.ScopedEnvExtension.noConfusionType,[]]
[Lean.Macro.Methods.resolveGlobalName,[]]
[Tactic.Ring.HornerExpr.xadd.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.matchDiscr.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.Elab.Level.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Level.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.syntax,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.docComment, Lean.Parser.Term.attrKind, Lean.Parser.symbol, Lean.Parser.optPrecedence, Lean.Parser.Command.optNamedName, Lean.Parser.Command.optNamedPrio, Lean.Parser.many1, Lean.Parser.syntaxParser, Lean.Parser.argPrec, Lean.Parser.ident]]
[Function.bijective.injective,[And.left]]
[usize_size_gt_zero,[Nat.pos_pow_of_pos, System.Platform.numBits, Nat.zero_lt_succ, OfNat.ofNat]]
[Function.left_inverse_inv_fun,[]]
[Lean.isNoConfusion,[Lean.TagDeclarationExtension.isTagged, Lean.noConfusionExt]]
[Function.app,[]]
[Lean.Elab.Command.StructCtorView.ref,[]]
[fix5,[fixCore5, arbitrary]]
[Lean.Name.getPrefix,[Unit.unit, Lean.Name, Lean.Name.anonymous]]
[Lean.IR.FnBody.below,[PProd, PUnit]]
[Lean.Elab.Tactic.refineCore,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.getMainTarget, Lean.Elab.Tactic.elabTermWithHoles, Option.some, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Meta.assignExprMVar, Lean.Elab.Tactic.replaceMainGoal]]
[Lean.Elab.Term.BinderView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[IO.Process.StdioConfig.stdout,[]]
[List.append_nil,[rfl, of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.cons, id, eq_self]]
[Lean.Meta.IndPredBelow.mkConstructor,[Bind.bind, Lean.getConstInfoCtor, Lean.Meta.IndPredBelow.mkCtorType, Pure.pure, Lean.Constructor.mk]]
[Lean.IR.mkAlt,[Lean.IR.Alt.ctor, Lean.IR.CtorInfo.mk]]
[Lean.Core.instAddMessageContextCoreM,[Lean.AddMessageContext.mk, Lean.addMessageContextPartial]]
[Nat.div_one,[]]
[IO.FS.instOrdSystemTime,[Ord.mk, Ordering, Unit.unit, Ord.compare, Ordering.lt, Ordering.gt, Ordering.eq]]
[Lean.PrettyPrinter.Delaborator.instInhabitedDelabM,[Inhabited.mk, MonadExcept.throw, arbitrary]]
[Lean.PrettyPrinter.Parenthesizer.checkColGe.parenthesizer,[Pure.pure, Unit.unit]]
[Lean.Parser.Tactic.rcongr,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Lean.LocalContext.mkBinding,[Nat.foldRev, Unit.unit, Lean.Expr, Lean.LocalContext.findFVar?, ite, Eq, Bool.true, Lean.mkLambda, Lean.mkForall, Lean.Expr.hasLooseBVar, OfNat.ofNat, Lean.mkLet, Lean.Expr.lowerLooseBVars, panicWithPosWithDecl, Array.size]]
[Lean.Parser.Term.explicitBinder.formatter,[Lean.ppGroup.formatter, Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.Parser.Term.binderType.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.binderTactic.formatter, Lean.Parser.Term.binderDefault.formatter]]
[Std.PersistentArray.findSome?,[Id.run, Std.PersistentArray.findSomeM?]]
[Std.RBTree.find?,[Unit.unit, Option, Std.RBMap.findCore?, Option.some, Option.none]]
[Lean.Level.hasParam,[Lean.Level.Data.hasParam, Lean.Level.data]]
[Lean.IR.ExplicitBoxing.unboxResultIfNeeded,[ite, Eq, Lean.IR.IRType.isScalar, Bool.true, Bind.bind, getModify, Lean.IR.ExplicitBoxing.BoxingState.mk, HAdd.hAdd, Lean.IR.ExplicitBoxing.BoxingState.nextIdx, OfNat.ofNat, Lean.IR.ExplicitBoxing.BoxingState.auxDecls, Lean.IR.ExplicitBoxing.BoxingState.auxDeclCache, Lean.IR.ExplicitBoxing.BoxingState.nextAuxId, Pure.pure, Lean.IR.VarId.mk, Lean.IR.FnBody.vdecl, Lean.IR.IRType.object, Lean.IR.Expr.unbox]]
[Mathlib.Tactic.Lint.LintVerbosity.low.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Term.Do.DoIfView.optIdent,[]]
[Lean.Compiler.hasNospecializeAttribute,[Lean.Compiler.SpecializeAttributeKind.nospecialize]]
[Lean.instMonadOptions,[Lean.MonadOptions.mk, liftM, Lean.MonadOptions.getOptions]]
[Lean.Level.PP.Result.noConfusionType,[]]
[Lean.Parser.Attr.extern.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.optional.formatter, Lean.Parser.numLit.formatter, Lean.Parser.many.formatter, Lean.Parser.Attr.externEntry.formatter]]
[Lean.ConstantVal.name,[]]
[Lean.Meta.RecursorInfo.numArgs,[]]
[Nat.repr_length,[Eq.symm, Classical.em, Eq, HDiv.hDiv, Nat.succ, OfNat.ofNat, Eq.mpr, congrFun, congrArg, LE.le, List.length, ite_congr, Eq.trans, eq_true_of_decide, Eq.refl, Bool.true, List.cons, Nat.digitChar, HMod.hMod, List.nil, congr, Nat.toDigitsCore, Nat.to_digits_core_length, of_decide_eq_true, HAdd.hAdd]]
[Lean.Lsp.instToStringRpcRef,[ToString.mk, ToString.toString, Lean.Lsp.RpcRef.p]]
[Nat.coprime.mul,[Eq.trans, Nat.coprime.gcd_mul_left_cancel]]
[Array.isEqv,[dite, Eq, Array.size, Array.isEqvAux, OfNat.ofNat, Bool.false]]
[Lean.BinderInfo.isInstImplicit,[Lean.BinderInfo.default, Lean.BinderInfo.implicit, Lean.BinderInfo.strictImplicit, Unit.unit, Lean.BinderInfo.auxDecl, Bool, Bool.true, Bool.false]]
[Lean.resolveGlobalConstNoOverloadCore,[Bind.bind, Lean.resolveGlobalConstCore, List.nil, List.cons, Lean.Name, Pure.pure, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, HAppend.hAppend, ToString.toString, Lean.mkConst, List.map]]
[Lean.Meta.AbstractMVars.State.lctx,[]]
[Nat.div_mul_le_self,[LE.le, HMul.hMul, HDiv.hDiv, Eq.mpr, congrFun, congrArg, Eq.trans, Nat.div_zero, OfNat.ofNat, Nat.mul_zero, Nat.zero_le, Iff.mp, Nat.le_div_iff_mul_le, Nat.succ_pos, Nat.le_refl, HAdd.hAdd]]
[Lean.DelayedMetavarAssignment.fvars,[]]
[Lean.PrettyPrinter.Formatter.checkInsideQuot.formatter,[Pure.pure, Unit.unit]]
[Lean.Elab.Term.Quotation.resolveSectionVariable.loop,[Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, List, Prod, Lean.Name, String, Unit.unit, Lean.NameMap.find?, List.cons, Prod.mk, List.nil, PProd.fst]]
[Lean.Elab.Term.withoutPostponing,[MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.Context.declName?, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.currMacroScope, Bool.false, Lean.Elab.Term.Context.errToSorry, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.Term.Context.autoBoundImplicits, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection]]
[Lean.IR.tracePrefixOptionName,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Lsp.DeclarationParams.noConfusionType,[]]
[List.length_erasep_of_mem,[Eq, List.length, List.erasep, Nat.pred, List.exists_of_erasep, Eq.mpr, Eq.refl, congr, congrArg, List.length_append, Eq.trans, List.cons, HAdd.hAdd, List.length_cons, rfl]]
[Lean.Parser.Tactic.recover,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.IR.Arg.beq,[Lean.IR.Arg.var, Lean.IR.Arg.irrelevant, Unit.unit, Bool, BEq.beq, Bool.true, Bool.false]]
[IO.throwServerError,[MonadExcept.throw, IO.userError]]
[Lean.Parser.withOpenFn,[ite, GT.gt, Array.size, Lean.Parser.ParserState.stxStack, OfNat.ofNat, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.withOpenDeclFnCore, Lean.Syntax.getOp]]
[Lean.Name.components',[Unit.unit, List, Lean.Name, List.nil, List.cons, Lean.Name.mkStr, Lean.Name.anonymous, PProd.fst, Lean.Name.mkNum]]
[Lean.Parser.Term.namedPattern,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.checkStackTop, Lean.Parser.Term.isIdent, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.maxPrec]]
[Std.RBMap.findCore?,[Option, Sigma, Std.RBNode.findCore]]
[List.take,[List, List.nil, List.cons, PProd.fst]]
[Lean.Parser.parseHeader,[Bind.bind, Lean.mkEmptyEnvironment, OfNat.ofNat, Unit.unit, IO, Prod, Lean.Syntax, Lean.Parser.ModuleParserState, Lean.MessageLog, Lean.Parser.ParserState.errorMsg, Pure.pure, Prod.mk, Lean.Parser.ModuleParserState.mk, Lean.Parser.ParserState.pos, Bool.true, Lean.MessageLog.add, Lean.MessageLog.mk]]
[Lean.Elab.Tactic.SavedState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.moreArgs,[]]
[Lean.Parser.Term.local.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[List.tail?,[Unit.unit, Option, List, Option.none, Option.some]]
[Lean.MessageDataContext.noConfusionType,[]]
[Lean.Elab.Deriving.Hashable.mkHashableHeader,[Lean.Elab.Deriving.mkHeader, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat]]
[Lean.instInhabitedMessageLog,[Inhabited.mk, Lean.MessageLog.mk, arbitrary]]
[List.eraseDup,[List.pwFilter, Ne]]
[Lean.Elab.Deriving.Context.auxFunNames,[]]
[Lean.Parser.Term.suffices,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, Lean.Parser.symbol, Lean.Parser.Term.sufficesDecl, Lean.Parser.Term.optSemicolon, Lean.Parser.termParser, OfNat.ofNat]]
[Lean.profileitIO,[]]
[Lean.Parser.checkStackTopFn,[ite, Eq, Array.back, Lean.Parser.ParserState.stxStack, Bool.true, Lean.Parser.ParserState.mkUnexpectedError, List.nil]]
[Float.ofBinaryScientific,[Float.scaleB, UInt64.toFloat]]
[Lean.Parser.mergeOrElseErrors,[Lean.Parser.ParserState.mk, Option.none, Lean.Parser.ParserState, ite, Eq, BEq.beq, Bool.true, Option.some, Lean.Parser.Error.merge]]
[Lean.Expr.isLit,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[MonadState.set,[]]
[IO.FS.instReprMetadata,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, IO.FS.Metadata.accessed, Std.Format.line, IO.FS.Metadata.modified, IO.FS.Metadata.byteSize, IO.FS.Metadata.type]]
[instToBoolBool,[ToBool.mk]]
[Lean.Elab.Visibility.noConfusionType,[noConfusionTypeEnum, Lean.Elab.Visibility.toCtorIdx]]
[Lean.Parser.Tactic.casesM,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat]]
[Std.PersistentArray.div2Shift,[USize.shiftRight]]
[Lean.Parser.ParserState.stxStack,[]]
[Iff.mpr,[]]
[Lean.Syntax.getAntiquotSpliceSuffix,[ite, Eq, Lean.Syntax.isAntiquotSplice, Bool.true, Lean.Syntax.getOp, OfNat.ofNat]]
[IO.Error.noSuchThing.inj,[And.intro]]
[ST.instInhabitedRef,[Inhabited.mk, ST.Ref.mk, PointedType.val, ST.RefPointed, ST.instInhabitedRef.proof_1]]
[Fin.div,[Fin, Fin.mk, HMod.hMod, HDiv.hDiv, Fin.div.proof_1]]
[Std.Range.noConfusionType,[]]
[Lean.LocalDecl.setBinderInfo,[Lean.LocalDecl, Lean.LocalDecl.cdecl, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Meta.SimpAll.instInhabitedEntry,[Inhabited.mk, Lean.Meta.SimpAll.Entry.mk, arbitrary]]
[Lean.LBool.undef.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Command.exportPrivate,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[lt_by_cases,[dite, LT.lt, lt_by_cases.proof_1]]
[Lean.Meta.mkLetFVars,[Lean.Meta.mkLambdaFVars, Bool.false]]
[ToString.noConfusionType,[]]
[Lean.Syntax.isAtom,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Bool, Bool.true, Bool.false]]
[Quotient.rec,[Quot.rec]]
[Lean.LocalContext.getFVar!,[Lean.LocalContext.get!, Lean.Expr.fvarId!]]
[Nat.dvd_of_mul_dvd_mul_right,[Nat.dvd_of_mul_dvd_mul_left, Eq.mp, Eq.refl, Dvd.dvd, HMul.hMul, Nat.mul_comm]]
[Lean.Parser.Term.Command.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.commandParser]]
[PLift.down_up,[rfl]]
[Lean.levelOne,[Lean.mkLevelSucc, Lean.levelZero]]
[cast,[]]
[Std.Format.instBEqFlattenBehavior,[BEq.mk, BEq.beq, Std.Format.FlattenBehavior.toCtorIdx]]
[Lean.Parser.ParserExtension.OLeanEntry.kind.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.TagAttribute.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.TagAttribute.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.simpleBinderWithoutType,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.many1, Lean.Parser.Term.binderIdent, Lean.Parser.pushNone, Bool.true]]
[Lean.MetavarContext.setMVarType,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Std.PersistentHashMap.insert, Lean.MetavarContext.decls, Lean.MetavarDecl.mk, Lean.MetavarDecl.userName, Lean.MetavarDecl.lctx, Lean.MetavarDecl.depth, Lean.MetavarDecl.localInstances, Lean.MetavarDecl.kind, Lean.MetavarDecl.numScopeArgs, Lean.MetavarDecl.index, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment]]
[Lean.PrettyPrinter.Parenthesizer.skip.parenthesizer,[Pure.pure, Unit.unit]]
[Lean.Elab.InfoState.noConfusionType,[]]
[USize.lor,[USize.mk, Fin.lor, USize.val]]
[Std.RBTree.instForInRBTree,[ForIn.mk, Std.RBTree.forIn]]
[Lean.Parser.trailingNode,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.checkLhsPrec, Lean.Parser.trailingNodeAux, Lean.Parser.setLhsPrec]]
[forall₄_congr,[forall_congr', forall₃_congr]]
[Lean.Meta.abstract,[Lean.Meta.abstractRange, Array.size]]
[Lean.Parser.Syntax.cat,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.optPrecedence]]
[Lean.MetavarContext.MkBinding.instMonadHashMapCacheAdapterExprStructEqExprM,[Lean.MonadHashMapCacheAdapter.mk, Bind.bind, MonadState.get, Pure.pure, Lean.MetavarContext.MkBinding.State.cache, modify, Lean.MetavarContext.MkBinding.State.mk, Lean.MetavarContext.MkBinding.State.mctx, Lean.MetavarContext.MkBinding.State.ngen]]
[Lean.Lsp.LeanFileProgressParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instLEUInt16,[LE.mk, UInt16.le]]
[Lean.Elab.Term.PatternElabException.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.PatternElabException.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.WF.instInhabitedTerminationStrategy,[Inhabited.mk, Lean.Elab.WF.TerminationStrategy.mk, arbitrary]]
[Lean.Elab.Tactic.evalDone,[Lean.Elab.Tactic.done]]
[Lean.Xml.Parser.PEReference,[SeqRight.seqRight, Lean.Parsec.skipChar, Char.ofNat, Lean.Xml.Parser.Name]]
[Lean.Elab.Tactic.Conv.evalReduce,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.Conv.getLhs, liftM, Lean.Meta.reduce, Bool.true, Lean.Elab.Tactic.Conv.changeLhs]]
[not_false_iff,[iff_true_intro, not_false]]
[System.FilePath.parent,[Functor.map, System.FilePath.mk, String.extract, System.FilePath.toString, OfNat.ofNat, String.revFind, List.contains, System.FilePath.pathSeparators]]
[Lean.Meta.Simp.tryLemmaWithExtraArgs?,[Lean.Meta.withNewMCtxDepth, Bind.bind, liftM, Lean.Meta.SimpLemma.getValue, Lean.Meta.inferType, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.Simp.SimpM, Option, Lean.Meta.Simp.Result, Lean.Meta.instantiateMVars, Lean.Meta.whnf, ForIn.forIn, MProd.mk, Pure.pure, PUnit.unit, ForInStep.yield, Unit.unit, Option.some, Lean.Meta.Simp.Result.mk, Lean.mkAppN, Lean.Meta.mkCongrFun, Lean.Meta.isDefEq, ite, Eq, Bool.true, Lean.Meta.Simp.synthesizeArgs, Lean.Meta.SimpLemma.getName, Lean.Expr.isMVar, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Tactic.Ring.HornerExpr.e,[Lean.Expr]]
[Lean.isIdBeginEscape,[Decidable.decide, Eq, Lean.idBeginEscape]]
[Lean.Parser.Command.declModifiers.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.docComment.formatter, Lean.Parser.Term.attributes.formatter, Lean.PrettyPrinter.Formatter.ite, Eq, Lean.PrettyPrinter.Formatter.skip.formatter, Lean.ppDedent.formatter, Lean.ppLine.formatter, Lean.Parser.Command.visibility.formatter, Lean.Parser.Command.noncomputable.formatter, Lean.Parser.Command.unsafe.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.partial.formatter, Lean.Parser.Command.nonrec.formatter]]
[ExceptT.run_bind,[rfl]]
[Lean.Parser.Command.variable.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Bool.false]]
[Lean.mkLetDeclEx,[Lean.LocalDecl.ldecl, Bool.false]]
[Lean.Lsp.TextDocumentEdit.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.TextDocumentEdit.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.declModifiersF.parenthesizer,[Lean.Parser.Command.declModifiers.parenthesizer, Bool.false]]
[Lean.Elab.Term.elabProp,[Pure.pure, Lean.mkSort, Lean.levelZero]]
[decidable_of_bool,[Decidable, Decidable.isTrue, decidable_of_bool.proof_1, Decidable.isFalse, decidable_of_bool.proof_2]]
[Lean.IR.Borrow.ownVar,[Bind.bind, Lean.IR.Borrow.getCurrFn, modify]]
[Lean.IR.DeclInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.mkReducibilityHintsRegularEx,[Lean.ReducibilityHints.regular]]
[ReaderT.ext,[funext, id]]
[Lean.Elab.Term.Do.mkVarDeclCore,[Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.decl, Lean.Elab.Term.Do.CodeBlock.code, Lean.Elab.Term.Do.eraseVars, Lean.Elab.Term.Do.CodeBlock.uvars]]
[Semigroup.noConfusionType,[]]
[USize.instSemigroupUSize,[Semigroup.mk, USize.instSemigroupUSize.proof_1]]
[Lean.MonadError.toMonadRef,[]]
[Lean.JsonRpc.instCoeNotificationMessage,[Coe.mk, Lean.JsonRpc.Message.notification, Lean.JsonRpc.Notification.method, Except.toOption, Lean.Json.toStructured?, Lean.JsonRpc.Notification.param]]
[Lean.Elab.Term.ToDepElimPattern.State.mk.inj,[And.intro]]
[Lean.Meta.IndPredBelow.BrecOnVariables.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Level.paren.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.levelParser.formatter]]
[Lean.LocalDecl.setUserName,[Lean.LocalDecl, Lean.LocalDecl.cdecl, Lean.LocalDecl.ldecl]]
[Lean.Lsp.TextDocumentItem.mk.inj,[And.intro]]
[Lean.instInhabitedQuotKind,[Inhabited.mk, Lean.QuotKind.type]]
[UInt8.instSemiringUInt8.proof_4,[congrArg, UInt8.mk, AddMonoid.nsmul_succ', UInt8.val]]
[Lean.Parser.Term.let_tmp.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.letDecl.parenthesizer, Lean.Parser.Term.optSemicolon.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[unique_of_exists_unique,[Eq, Eq.trans, Eq.symm]]
[Nat.eq_or_lt_of_not_lt,[Or.resolve_left, Nat.lt_trichotomy]]
[is_dec_refl,[Eq, Bool.true]]
[Lean.Parser.Term.doElem.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.doElemParser.formatter]]
[Lean.JsonRpc.ErrorCode.parseError.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[instCommRingFin.proof_1,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.mul_def, congrFun, HMod.hMod, Nat.mul_comm, eq_self, HMul.hMul]]
[Nat.toUInt16,[UInt16.ofNat]]
[Ordering.gt.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.IR.Param.borrow,[]]
[Except.instMonadExcept,[Monad.mk]]
[Std.PersistentHashMap.Stats.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.PersistentHashMap.Stats.mk, Eq.symm, eq_of_heq, HEq.refl]]
[IO.Error.permissionDenied.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.permissionDenied, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.Command.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.Command.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Modifiers.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.continuity,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.isAbortExceptionId,[or, BEq.beq, Lean.Elab.abortCommandExceptionId, Lean.Elab.abortTermExceptionId, Lean.Elab.abortTacticExceptionId]]
[Lean.IR.CtorFieldInfo.irrelevant.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Term.MutualClosure.ClosureState.exprArgs,[]]
[Lean.Lsp.instInhabitedLineRange,[Inhabited.mk, Lean.Lsp.LineRange.mk, arbitrary]]
[Append.noConfusionType,[]]
[Lean.importModules,[Lean.profileitIO, Lean.withImporting, Bind.bind, StateRefT'.run, Lean.ImportState.mk, IO, Lean.Environment, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield, MProd.mk, ForInStep, MProd, Std.HashMap, Lean.Name, Lean.ConstantInfo, Lean.ModuleIdx, Std.HashMap.insert', Lean.ConstantInfo.name, ite, Eq, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Nat, Lean.EnvExtensionInterface.mkInitialExtStates, Lean.EnvExtensionInterfaceImp, ST.Ref.get, Lean.persistentEnvExtensionsRef, Lean.EnvExtension.modifyState, Lean.PersistentEnvExtension.toEnvExtension, Lean.PersistentEnvExtensionState.mk, Array.push, Lean.PersistentEnvExtensionState.importedEntries, Lean.PersistentEnvExtensionState.state, Lean.ImportState.moduleData, OfNat.ofNat, Lean.importModules.importMods]]
[Lean.Meta.Instances.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[String.map,[String.mapAux, OfNat.ofNat]]
[Lean.instInhabitedMacroScopesView,[Inhabited.mk, Lean.MacroScopesView.mk, arbitrary]]
[PUnit.unit.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.ScopedEnvExtension.Descr.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.getSyntheticMVarDecl?,[Bind.bind, MonadState.get, Pure.pure, List.find?, BEq.beq, Lean.Elab.Term.SyntheticMVarDecl.mvarId, Lean.Elab.Term.State.syntheticMVars]]
[Lean.Parser.Attr.export.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter]]
[Lean.Elab.Command.elabSyntaxAbbrev,[Bind.bind, Pure.pure, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Option.some, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Elab.Term.StructInst.FieldVal.term.inj,[]]
[Lean.IR.EmitC.Context.mainParams,[]]
[false_of_true_eq_false,[trivial]]
[Std.RBMap.min,[Option, Prod, Unit.unit, Std.RBNode.min, Option.some, Prod.mk, Option.none]]
[Lean.IR.UnreachableBranches.Value.truncateMaxDepth,[OfNat.ofNat]]
[Mathlib.TermUnsafe.termUnsafe_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.CompletionInfo.tactic.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.CompletionInfo.tactic, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.MetavarContext.MkBinding.collectDeps,[ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Pure.pure, Bind.bind, Nat.forM, Lean.MetavarContext.localDeclDependsOn, Lean.Expr.fvarId!, MonadExcept.throw, Lean.MetavarContext.MkBinding.Exception.revertFailure, PUnit.unit]]
[Lean.Lsp.DocumentSymbolParams.noConfusionType,[]]
[Lean.IR.CtorLayout.cidx,[]]
[USize.instSemiringUSize.proof_3,[congrArg, USize.mk, Semiring.nsmul_zero', USize.val]]
[Lean.Compiler.hasMacroInlineAttribute,[Lean.Compiler.InlineAttributeKind.macroInline]]
[Lean.Server.Completion.State.itemsOther,[]]
[Lean.IR.inferBorrow,[Bind.bind, Lean.IR.getEnv, Pure.pure, Lean.IR.Borrow.applyParamMap]]
[FloatArray.empty,[FloatArray.mkEmpty, OfNat.ofNat]]
[Lean.Compiler.setInlineAttribute,[Lean.EnumAttributes.setValue, Lean.Compiler.inlineAttrs]]
[Lean.PrettyPrinter.Parenthesizer.categoryParserOfStack.parenthesizer,[Bind.bind, MonadState.get, Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Syntax.getId]]
[Lean.Widget.Lean.Widget.CodeToken.instFromJsonRpcEncodingPacket,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.RpcRef, Pure.pure]]
[Lean.Meta.isMatcherApp,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Meta.isMatcherAppCore]]
[Lean.Meta.addPPExplicitToExposeDiff,[Bind.bind, Lean.MonadOptions.getOptions, ite, Eq, or, Lean.KVMap.getBool, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false, Bool.true, Pure.pure, Prod.mk, Lean.Meta.instantiateMVars, Lean.Meta.addPPExplicitToExposeDiff.visit, Lean.Meta.addPPExplicitToExposeDiff.hasExplicitDiff?]]
[Lean.Json.str.injEq,[Eq.propIntro, Eq.refl, Lean.Json.str, Eq.symm, eq_of_heq, HEq.refl]]
[Array.instHAppendArrayListArray,[HAppend.mk, Array.appendList]]
[Lean.IR.Sorry.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.CancelParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.CancelParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.ToParserDescrContext.behavior,[]]
[Std.PersistentArray.foldlM,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Bind.bind, Std.PersistentArray.root, Array.foldlM, Std.PersistentArray.tail, Array.size, GE.ge, Std.PersistentArray.tailOff, HSub.hSub, USize.ofNat, Std.PersistentArray.shift]]
[Function.inv_fun_eq,[Function.inv_fun_on_eq, Exists, And, Mem.mem, Set.univ, Eq, Exists.intro, And.intro, trivial]]
[Lean.Server.Watchdog.log,[Bind.bind, MonadReader.read, liftM, IO.FS.Stream.putStrLn, Lean.Server.Watchdog.ServerContext.hLog, IO.FS.Stream.flush]]
[Lean.Level.ibelow,[True, And]]
[Lean.Parser.ParserExtension.Entry.toOLeanEntry,[Lean.Parser.ParserExtension.OLeanEntry, Lean.Parser.ParserExtension.OLeanEntry.token, Lean.Parser.ParserExtension.OLeanEntry.kind, Lean.Parser.ParserExtension.OLeanEntry.category, Lean.Parser.ParserExtension.OLeanEntry.parser]]
[Lean.ParserCompiler.CombinatorAttribute.mk.inj,[And.intro]]
[Lean.QuotKind.noConfusionType,[noConfusionTypeEnum, Lean.QuotKind.toCtorIdx]]
[IO.AsyncList.noConfusionType,[]]
[Lean.Parser.Command.catBehavior.formatter,[Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.catBehaviorBoth.formatter, Lean.Parser.Command.catBehaviorSymbol.formatter]]
[Lean.IR.EmitC.emitLn,[Bind.bind, Lean.IR.EmitC.emit]]
[instOfNatUSize,[OfNat.mk, USize.ofNat]]
[IO.lazyPure,[Pure.pure, Unit.unit]]
[Lean.Parser.Tactic.opInduction,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Lean.Meta.synthInstance,[Lean.catchInternalId, Lean.Meta.isDefEqStuckExceptionId, Bind.bind, Lean.Meta.synthInstance?, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr]]
[Lean.IR.usesModuleFrom,[List.any, Array.toList, Lean.Environment.allImportedModuleNames, Lean.Name.isPrefixOf]]
[iff_true_left,[Iff.intro, Iff.mp, iff_of_true]]
[System.FilePath.withFileName,[Unit.unit, System.FilePath, System.FilePath.parent, System.FilePath.mk, HDiv.hDiv]]
[Lean.Parser.Tactic.revert,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Lean.SyntaxNode.getArg,[Lean.SyntaxNode.withArgs, Array.get!]]
[String.decEq.proof_1,[congrArg, String.mk]]
[Lean.Widget.CodeToken.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.MatcherApp.params,[]]
[Lean.Compiler.foldNatDecEq,[Lean.Compiler.foldNatBinPred, Lean.Compiler.mkNatEq, Decidable.decide, Eq]]
[Lean.SMap.findD,[Option.getD, Lean.SMap.find?]]
[Not,[False]]
[Complement.noConfusionType,[]]
[Lean.Meta.contradiction,[Bind.bind, Lean.Meta.contradictionCore, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing]]
[UInt32.instSemiringUInt32.proof_5,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, congrFun, HMul.hMul, UInt32.zero_def, UInt32.mul_def, UInt32.mk, OfNat.ofNat, MonoidWithZero.zero_mul, UInt32.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt32]]
[Lean.MessageData.instantiateMVars,[Lean.MetavarContext.mk, Lean.MessageData.instantiateMVars.visit]]
[Lean.Parser.symbol.formatter,[Lean.PrettyPrinter.Formatter.tokenWithAntiquot.formatter, Lean.PrettyPrinter.Formatter.symbolNoAntiquot.formatter]]
[Lean.Elab.DerivingClassView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.DerivingClassView.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Std.ShareCommon.ObjectMap,[Std.HashMap, Std.ShareCommon.Object]]
[Lean.Parser.Term.haveIdDecl.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Term.haveIdLhs.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Bool.false]]
[Lean.Meta.RecursorUnivLevelPos.noConfusionType,[]]
[Lean.IR.EmitC.emitLns,[List.forM, Lean.IR.EmitC.emitLn]]
[Lean.Elab.OpenDecl.M,[StateRefT', IO.RealWorld, Lean.Elab.OpenDecl.State]]
[Lean.LazyInitExtension.noConfusionType,[]]
[Mathlib.Tactic.Lint.NamedLinter.name,[Lean.Name.updatePrefix, Mathlib.Tactic.Lint.NamedLinter.declName, Lean.Name.anonymous]]
[List.empty_eq,[rfl]]
[Std.PersistentHashSet.erase,[Std.PersistentHashSet.mk, Std.PersistentHashMap.erase, Std.PersistentHashSet.set]]
[Lean.Meta.reduceNat?,[ite, Eq, or, Lean.Expr.hasFVar, Lean.Expr.hasMVar, Bool.true, Pure.pure, Option.none, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Option, Lean.Expr, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.reduceUnaryNatOp, Nat.succ, Lean.Meta.reduceBinNatOp, Nat.add, Nat.sub, Nat.mul, Nat.div, Nat.mod, Lean.Meta.reduceBinNatPred, Nat.beq, Nat.ble]]
[Decidable.byCases,[]]
[Lean.Meta.mkHCongr,[Bind.bind, Lean.Meta.getFunInfo, Lean.Meta.mkHCongrWithArity, Lean.Meta.FunInfo.getArity]]
[Lean.IR.ExplicitBoxing.castResultIfNeeded,[ite, Eq, Lean.IR.ExplicitBoxing.eqvTypes, Bool.true, Pure.pure, Lean.IR.FnBody.vdecl, Bind.bind, getModify, Lean.IR.ExplicitBoxing.BoxingState.mk, HAdd.hAdd, Lean.IR.ExplicitBoxing.BoxingState.nextIdx, OfNat.ofNat, Lean.IR.ExplicitBoxing.BoxingState.auxDecls, Lean.IR.ExplicitBoxing.BoxingState.auxDeclCache, Lean.IR.ExplicitBoxing.BoxingState.nextAuxId, Lean.IR.VarId.mk, Lean.IR.ExplicitBoxing.mkCast]]
[forall_prop_decidable.proof_1,[Iff.intro]]
[Lean.Elab.Term.Do.hasTerminalAction,[Lean.Elab.Term.Do.hasExitPointPred, Lean.Elab.Term.Do.Code.decl, Lean.Elab.Term.Do.Code.reassign, Lean.Elab.Term.Do.Code.joinpoint, Lean.Elab.Term.Do.Code.seq, Lean.Elab.Term.Do.Code.break, Lean.Elab.Term.Do.Code.continue, Lean.Elab.Term.Do.Code.return, Lean.Elab.Term.Do.Code.ite, Lean.Elab.Term.Do.Code.match, Lean.Elab.Term.Do.Code.jmp, Bool, Bool.true, Bool.false]]
[List.erasep_subset,[List.exists_or_eq_self_of_erasep, Eq.mpr, Eq.refl, Mem.mem, List.subset.refl, Eq.symm, HAppend.hAppend, List.cons, propext, List.mem_append, Or, Or.inl, Or.inr, List.mem_cons_of_mem]]
[IO.FS.Stream.isEof,[]]
[Lean.Lsp.instHashableRpcRef,[Hashable.mk, UInt64, mixHash, OfNat.ofNat, Hashable.hash]]
[Lean.instInhabitedSyntax,[Inhabited.mk, Lean.Syntax.missing]]
[trivial,[True.intro]]
[Lean.Meta.reduceNatNativeUnsafe,[Lean.evalConstCheck, Nat, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Parser.addParserCategory,[ite, Eq, Lean.Parser.isParserCategory, Bool.true, MonadExcept.throw, HAppend.hAppend, ToString.toString, Pure.pure, Lean.ScopedEnvExtension.addEntry, Lean.Parser.parserExtension, Lean.Parser.ParserExtension.Entry.category]]
[Lean.Parser.Term.fun.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.maxPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.unicodeSymbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.basicFun.parenthesizer, Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Lean.PrettyPrinter.Parenthesizer.State.stxTrav,[]]
[Lean.Widget.MsgToInteractive.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.instFromJsonTextEditBatch,[Lean.FromJson.mk, Lean.FromJson.fromJson?]]
[Lean.Expr.FoldConstsImpl.initCache,[Lean.Expr.FoldConstsImpl.State.mk, Array.mkArray, USize.toNat, Lean.Expr.FoldConstsImpl.cacheSize, cast, Lean.Expr.FoldConstsImpl.initCache.proof_1, Unit.unit, EmptyCollection.emptyCollection]]
[Lean.Expr.instantiateLevelParamsCore.visit,[ite, Eq, not, Lean.Expr.hasLevelParam, Bool.true, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.lit, Lean.Expr, Lean.Expr.updateLambdaE!, PProd.fst, PProd.snd, Lean.Expr.updateForallE!, Lean.Expr.updateLet!, Lean.Expr.updateApp!, Lean.Expr.updateProj!, Lean.Expr.updateMData!, Lean.Expr.updateConst!, List.map, Lean.Level.instantiateParams, Lean.Expr.updateSort!]]
[Lean.AttributeImpl.erase,[]]
[Lean.Parser.mkAntiquot.formatter,[Lean.Parser.leadingNode.formatter, Lean.Parser.maxPrec, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.setExpected.formatter, List.nil, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.manyNoAntiquot.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.antiquotExpr.formatter, Lean.PrettyPrinter.Formatter.ite, Eq, Bool.true, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.node.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.PrettyPrinter.Formatter.checkNoImmediateColon.formatter, Lean.PrettyPrinter.Formatter.pushNone.formatter]]
[Lean.MonadTrace.modifyTraceState,[]]
[tacticMatchTarget_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.Compiler.NumScalarTypeInfo.id,[]]
[Lean.IR.Decl.insertResetReuse,[Lean.IR.Decl.extern, Lean.IR.Decl, Lean.IR.Decl.updateBody!]]
[Lean.Parser.withOpenDeclFnCore,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.prec, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Parser.ParserContext.savedPos?, Lean.Parser.ParserContext.forbiddenTk?, Array.map, Lean.Syntax.getId, Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat, Bool.false]]
[Lean.Parser.Command.eraseAttr.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.rawIdent.formatter]]
[Lean.Elab.Term.instInhabitedMVarErrorKind,[Inhabited.mk, Lean.Elab.Term.MVarErrorKind.implicitArg, arbitrary]]
[Std.RBMap.depth,[Std.RBNode.depth, Subtype.val]]
[Array.forM,[Array.foldlM, PUnit.unit]]
[Lean.Elab.WF.mkFix,[Bind.bind, Lean.Meta.forallBoundedTelescope, Lean.Elab.PreDefinition.type, Option.some, OfNat.ofNat, liftM, Lean.Meta.inferType, Lean.Meta.getLevel, Lean.Meta.mkLambdaFVars, List.toArray, List.cons, List.nil, Bool.false, Bool.true, Pure.pure, Lean.mkApp4, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.whnf, Lean.Expr.bindingDomain!, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.mk, Lean.Elab.PreDefinition.ref, Lean.Elab.PreDefinition.kind, Lean.Elab.PreDefinition.levelParams, Lean.Elab.PreDefinition.modifiers, Lean.mkApp]]
[Lean.IR.Log.format,[Array.foldl, HAppend.hAppend, Std.ToFormat.format, Std.Format.line, Std.Format.nil, OfNat.ofNat, Array.size]]
[Lean.Json.Parser.escapedChar,[Bind.bind, Lean.Parsec.anyChar, dite, Eq, Char.ofNat, Unit.unit, Eq.symm, Lean.Parsec, Char, Pure.pure, Lean.Json.Parser.hexChar, HAdd.hAdd, HMul.hMul, OfNat.ofNat, Lean.Parsec.fail]]
[Function.involutive.right_inverse,[]]
[Lean.Parser.Trie.noConfusionType,[]]
[Nat.instModNat,[Mod.mk, Nat.mod]]
[Lean.Expr.fvar.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.fvar, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.doIfProp.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.optIdent.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Bool.false]]
[Lean.Parser.testParseModule,[Bind.bind, Lean.Parser.parseHeader, IO, Lean.Syntax, Lean.Parser.testParseModuleAux, List.toArray, List.nil, Pure.pure, Lean.Syntax.updateLeading]]
[UInt64.instRingUInt64.proof_1,[congrArg, UInt64.mk, Ring.sub_eq_add_neg, UInt64.val]]
[Lean.Lsp.RpcConnected.noConfusionType,[]]
[Lean.Syntax.getOptional?,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Option, Lean.Syntax, ite, Eq, and, BEq.beq, Lean.nullKind, Array.size, OfNat.ofNat, Bool.true, Option.some, Array.get!, Option.none]]
[Lean.Elab.Term.Do.ToCodeBlock.run,[ReaderT.run, Lean.Elab.Term.Do.ToCodeBlock.doSeqToCode, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, List.map, Lean.Syntax.getOp, OfNat.ofNat, Array.toList, Lean.Syntax.getArgs, List.nil, Lean.Elab.Term.Do.ToCodeBlock.Context.mk]]
[List.mem_insert_iff,[Classical.em, Mem.mem, Eq.mpr, Eq.refl, Iff, List.insert, Or, Eq, List.insert_of_mem, Iff.intro, Or.inr, Eq.symm, List.insert_of_not_mem, Iff.rfl]]
[Lean.Elab.Term.«termFun.»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol]]
[Lean.Macro.mkMethodsImp,[unsafeCast]]
[LawfulFunctor.comp_map,[]]
[Lean.instQuoteSyntax,[Lean.Quote.mk, id]]
[Lean.instInhabitedParserDescr,[Inhabited.mk, Lean.ParserDescr.symbol]]
[Function.injective.eq_iff',[Function.injective.eq_iff]]
[randNat,[Prod, Nat, Prod.mk]]
[Lean.mkRat,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Lean.Rat.normalize]]
[liftM,[MonadLiftT.monadLift]]
[Lean.Parser.Tactic.convertTo,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[IO.Error.unsupportedOperation.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Std.HashSetImp.WellFormed.brecOn,[Std.HashSetImp.WellFormed.below.mkWff, Std.HashSetImp.WellFormed.below.insertWff, Std.HashSetImp.WellFormed.below.eraseWff]]
[Lean.InductiveType.mk.inj,[And.intro]]
[Lean.Parser.ParserState.mkNode,[Lean.Parser.ParserState, ite, Eq, and, bne, Option.none, BEq.beq, Array.size, Bool.true, Lean.Parser.ParserState.mk]]
[Lean.Parser.Term.binrel,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.ppSpace, Lean.Parser.termParser, Lean.Parser.maxPrec]]
[Lean.ExternAttrData.entries,[]]
[Lean.Elab.FieldInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.FieldInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Expr.FindImpl.FindM,[StateT, Lean.Expr.FindImpl.State, Id]]
[Lean.PrettyPrinter.Formatter.strLit.formatter,[Lean.Parser.Term.str.formatter]]
[UInt64.instAddSemigroupUInt64,[AddSemigroup.mk, UInt64.instAddSemigroupUInt64.proof_1]]
[Lean.Meta.IndPredBelow.mkContext.motiveName,[ite, GT.gt, Array.size, OfNat.ofNat, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkSimple, HAppend.hAppend, ToString.toString, Nat.succ]]
[instMonadFinallyEIO,[inferInstanceAs, MonadFinally, EStateM, IO.RealWorld]]
[Array.mapSepElems,[Id.run, Array.mapSepElemsM]]
[UInt8.toChar,[Char.mk, UInt8.toUInt32, UInt8.toChar.proof_1]]
[IsAddRightCancel.noConfusionType,[]]
[withPtrAddr,[OfNat.ofNat]]
[Lean.Meta.UnificationHints.add,[Lean.Meta.UnificationHints.mk, Lean.Meta.DiscrTree.insertCore, Lean.Meta.UnificationHints.discrTree, Lean.Meta.UnificationHintEntry.keys, Lean.Meta.UnificationHintEntry.val]]
[Lean.Meta.TransparencyMode.hash,[Unit.unit, UInt64, OfNat.ofNat]]
[List.map₂,[List.nil, List.cons, List, PProd.fst]]
[Lean.Elab.Term.LetRecToLift.localInstances,[]]
[Lean.Meta.resetZetaFVarIds,[modify, Lean.Meta.State.mk, Lean.Meta.State.mctx, Lean.Meta.State.cache, EmptyCollection.emptyCollection, Lean.Meta.State.postponed]]
[Lean.Meta.CaseValueSubgoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.CaseValueSubgoal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Simp.rewriteCtorEq?,[Lean.Meta.withReducibleAndInstances, Unit.unit, Lean.Meta.MetaM, Option, Lean.Meta.Simp.Result, Lean.Expr.eq?, Pure.pure, Option.none, Bind.bind, Lean.Meta.whnf, Lean.MonadEnv.getEnv, Option.some, Prod.mk, Lean.Expr.constructorApp?, ite, Eq, bne, Lean.ConstantVal.name, Lean.ConstructorVal.toConstantVal, Bool.true, Lean.Meta.withLocalDeclD, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.mkNoConfusion, Lean.mkConst, List.nil, Lean.Meta.mkLambdaFVars, List.toArray, List.cons, Bool.false, Lean.Meta.mkEqFalse', Lean.Meta.Simp.Result.mk]]
[Nat.decLe,[dite, Eq, Nat.ble, Bool.true, Decidable.isTrue, Nat.le_of_ble_eq_true, Decidable.isFalse, Nat.not_le_of_not_ble_eq_true]]
[Lean.Parser.Term.leftArrow.formatter,[Lean.Parser.unicodeSymbol.formatter]]
[Lean.ConstantInfo.value!,[Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.Expr, panicWithPosWithDecl, OfNat.ofNat]]
[Substring.trim,[Substring, Substring.mk]]
[Lean.DefinitionSafety.noConfusion,[noConfusionEnum, Lean.DefinitionSafety.toCtorIdx]]
[Monoid.npow_zero',[]]
[Lean.Meta.Match.Pattern.arrayLit.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.refl, List.nil, Eq.trans, Eq.symm, List.cons.sizeOf_spec]]
[Lean.Parser.Command.whereStructField.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.Term.letDecl.parenthesizer]]
[Subarray.noConfusionType,[]]
[Lean.Elab.Term.StructInst.formatField,[HAppend.hAppend, Std.Format.joinSep, Lean.Elab.Term.StructInst.Field.lhs, Std.Format.text, Unit.unit, Std.Format, Lean.Elab.Term.StructInst.Field.val, Lean.Syntax.prettyPrint]]
[Lean.PersistentEnvExtensionDescr.name,[]]
[Lean.Elab.Structural.EqnsExtState.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Structural.EqnsExtState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[List.findSome?,[Unit.unit, Option, Option.none, Option.some, PProd.fst]]
[IO.FS.Metadata.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Function.sometimes,[dite, Nonempty, Classical.choice]]
[Quotient,[Quot, Setoid.r]]
[UInt16.shiftLeft,[UInt16.mk, HShiftLeft.hShiftLeft, UInt16.val, UInt16.modn, OfNat.ofNat]]
[Lean.Meta.instInhabitedInductionSubgoal,[Inhabited.mk, Lean.Meta.InductionSubgoal.mk, arbitrary]]
[runEST,[Except, Unit, Unit.unit, Except.ok, Except.error]]
[Lean.Parser.Term.funBinder,[HOrElse.hOrElse, Lean.Parser.Term.funStrictImplicitBinder, Lean.Parser.Term.funImplicitBinder, Lean.Parser.Term.instBinder, Lean.Parser.Term.funSimpleBinder, Lean.Parser.termParser, Lean.Parser.maxPrec]]
[Lean.instInhabitedAttributeApplicationTime,[Inhabited.mk, Lean.AttributeApplicationTime.afterTypeChecking]]
[OptionT.instMonadOptionT,[Monad.mk]]
[Lean.Lsp.instFromJsonSemanticTokensOptions,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.SemanticTokensLegend, Bool, Pure.pure, Lean.Lsp.SemanticTokensOptions.mk]]
[TC.wf.proof_1,[WellFounded.intro, TC.accessible, WellFounded.apply]]
[Lean.Meta.UnificationHints.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.getPPAll,[Lean.KVMap.get, Lean.Option.name, Lean.pp.all, Bool.false]]
[Sum.inl.inj,[]]
[Lean.IR.instInhabitedIndexSet,[Inhabited.mk, EmptyCollection.emptyCollection]]
[or_iff_not_and_not,[Decidable.or_iff_not_and_not]]
[EStateM.Result.noConfusionType,[]]
[instDecidableIff.proof_2,[Iff.mp]]
[Nat.shiftRight,[Nat, HDiv.hDiv, PProd.fst, OfNat.ofNat]]
[Lean.Meta.instToFormatInstanceEntry,[Std.ToFormat.mk, Option.none, Std.Format, Lean.Meta.InstanceEntry.globalName?, Std.ToFormat.format, Std.Format.text]]
[Lean.IR.EmitC.emitSetTag,[Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn]]
[Lean.Meta.ElimInfo.motivePos,[]]
[Lean.Parser.Command.nonrec.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.SSet.switch,[Lean.SMap.switch]]
[DivInvMonoid.toDiv,[]]
[Substring.nextn,[String.Pos, PProd.fst, Substring.next]]
[Lean.KernelException.other.inj,[]]
[Lean.Compiler.instInhabitedSpecInfo,[Inhabited.mk, Lean.Compiler.SpecInfo.mk, arbitrary]]
[Lean.Parser.peekToken,[ite, Eq, BEq.beq, Lean.Parser.TokenCacheEntry.startPos, Lean.Parser.ParserState.pos, Bool.true, Prod.mk, Except.ok, Lean.Parser.TokenCacheEntry.token, Lean.Parser.peekTokenAux]]
[plift.down,[]]
[Lean.Meta.Simp.Result.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.instMonadQuotationUnexpandM,[Lean.MonadQuotation.mk, Pure.pure, OfNat.ofNat, Lean.Name.mkStr, Lean.Name.anonymous, id]]
[Lean.Elab.Term.MutualClosure.ClosureState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.mkAtom,[Lean.Syntax.atom]]
[Lean.IR.EmitC.emitOffset,[ite, GT.gt, OfNat.ofNat, Bind.bind, Lean.IR.EmitC.emit, Pure.pure, PUnit.unit]]
[Lean.Eval.eval,[]]
[Lean.OptionDecl.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.OptionDecl.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Compiler.mkUnsafeRecName,[Lean.Name.mkStr]]
[Lean.instToJsonName,[Lean.ToJson.mk, Lean.Json.str, ToString.toString]]
[not_of_iff_false,[Iff.mp]]
[Lean.Meta.MatcherApp.toExpr,[Lean.mkAppN, Lean.Meta.MatcherApp.remaining]]
[instReprAtomUSize,[ReprAtom.mk]]
[Lean.Parser.Term.attrInstance,[Lean.Parser.ppGroup, Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.attrKind, Lean.Parser.attrParser]]
[List.isEmpty,[Unit.unit, Bool, Bool.true, Bool.false]]
[Lean.Parser.Tactic.ringExp!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.IR.EmitC.emitDeclInit,[Bind.bind, Lean.IR.EmitC.getEnv, ite, Eq, Lean.isIOUnitInitFn, Bool.true, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitCName, Lean.IR.EmitC.emitLn, BEq.beq, Array.size, Lean.IR.Decl.params, OfNat.ofNat, Option.none, Lean.IR.EmitC.M, Unit, Lean.getInitFnNameFor?, Lean.IR.Decl.name, Lean.IR.EmitC.emitMarkPersistent, Lean.IR.EmitC.emitCInitName, Pure.pure, PUnit.unit]]
[List.find?,[Unit.unit, Option, Option.none, Option.some, PProd.fst]]
[Lean.Meta.Simp.getCongrLemmas,[Bind.bind, readThe, Lean.Meta.Simp.Context, Pure.pure, Lean.Meta.Simp.Context.congrLemmas]]
[Lean.CollectMVars.State.noConfusionType,[]]
[Except.pure,[Except.ok]]
[Lean.Parser.Term.letEqnsDecl.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.letIdLhs.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.matchAlts.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Bool.false]]
[Lean.Lsp.instFromJsonDocumentHighlightParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.DocumentHighlightParams.mk, Lean.Lsp.TextDocumentPositionParams.mk]]
[instToStringId,[inferInstanceAs, ToString]]
[Lean.Json.bool.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.ParserCompiler.Context.noConfusionType,[]]
[USize.mul_def,[rfl]]
[instDecidableLe_4,[USize.decLe]]
[Lean.mkFVar,[Lean.Expr.fvar, Lean.Expr.mkData, mixHash, OfNat.ofNat, Hashable.hash, Bool.true, Bool.false]]
[Lean.Elab.Command.elabCheck,[Lean.Elab.Command.elabCheckCore, Bool.true]]
[Lean.IR.Borrow.BorrowInfCtx.currFn,[]]
[Array.ofSubarray,[Id.run, Bind.bind, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield]]
[Lean.Parser.Command.abbrev.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.Command.optDeclSig.parenthesizer, Lean.Parser.Command.declVal.parenthesizer]]
[Lean.Elab.Term.Do.JPDecl.body,[]]
[Lean.Parser.Level.max.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.nonReservedSymbol.formatter, Lean.Parser.many1.formatter, Lean.ppSpace.formatter, Lean.Parser.levelParser.formatter, Lean.Parser.maxPrec]]
[Lean.Elab.Term.LetRecToLift.mk.inj,[And.intro]]
[List.exists_mem_of_length_pos,[Exists, Mem.mem, Eq.refl, List.length, List.nil, HEq.refl, Exists.intro, List.mem_cons_self]]
[Lean.Expr.isAppOf,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Lean.Expr.getAppFn, BEq.beq, Bool.false]]
[Lean.KernelException.other.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.EnvExtensionInterfaceUnsafe.imp,[Lean.EnvExtensionInterface.mk, Lean.EnvExtensionInterfaceUnsafe.Ext, Inhabited.mk, arbitrary, Lean.EnvExtensionInterfaceUnsafe.registerExt, Lean.EnvExtensionInterfaceUnsafe.setState, Lean.EnvExtensionInterfaceUnsafe.modifyState, Lean.EnvExtensionInterfaceUnsafe.getState, Lean.EnvExtensionInterfaceUnsafe.mkInitialExtStates, Lean.EnvExtensionInterfaceUnsafe.ensureExtensionsArraySize]]
[Lean.Meta.isDefEq,[Lean.Meta.isExprDefEq]]
[Lean.Elab.Term.elabDepArrow,[Lean.Elab.Term.elabBinders, List.toArray, List.cons, List.nil, Bind.bind, Lean.Elab.Term.elabType, liftM, Lean.Meta.mkForallFVars, Bool.false, Bool.true]]
[Lean.Parser.ModuleParserState.noConfusionType,[]]
[Lean.Elab.Tactic.ElimApp.Result.elimApp,[]]
[«term{}»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol]]
[Lean.KeyedDeclsAttribute.OLeanEntry.mk.inj,[And.intro]]
[Lean.Parser.Command.inductive,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.declId, Lean.Parser.Command.optDeclSig, Lean.Parser.optional, HOrElse.hOrElse, Lean.Parser.many, Lean.Parser.Command.ctor, Lean.Parser.Command.optDeriving]]
[Lean.Expr.isSorry,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[Lean.mkLambda,[Lean.Expr.lam, Lean.Expr.mkDataForBinder, mixHash, UInt8.toUInt64, Hashable.hash, max, Lean.Expr.looseBVarRange, HSub.hSub, OfNat.ofNat, or, Lean.Expr.hasFVar, Lean.Expr.hasExprMVar, Lean.Expr.hasLevelMVar, Lean.Expr.hasLevelParam]]
[Option.map_id,[funext, Unit.unit, Eq, Option.map, id, rfl]]
[Std.Format.instMonadPrettyFormatStateMState,[Std.Format.MonadPrettyFormat.mk, modify, HAppend.hAppend, HAdd.hAdd, String.length, String.pushn, Char.ofNat, Bind.bind, MonadState.get, Pure.pure, Unit.unit]]
[ST.Ref.mk.injEq,[Eq.propIntro, Eq.refl, ST.Ref.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Option.instDecidableRelLt,[Unit.unit, Decidable, Option.lt, Decidable.isTrue, trivial, Decidable.isFalse, not_false]]
[Lean.Parser.termParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous]]
[Mathlib.Tactic.Lint.elements,[Bind.bind, ForIn.forIn, PUnit.unit, StateT, Array, Id, ForInStep, PUnit, Mathlib.Tactic.Lint.trieElements, Pure.pure, ForInStep.yield]]
[Lean.Parser.optionalNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.optionaInfo, Lean.Parser.Parser.info, Lean.Parser.optionalFn, Lean.Parser.Parser.fn]]
[Lean.Parser.Term.haveIdLhs.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.simpleBinderWithoutType.parenthesizer, Lean.Parser.Term.bracketedBinder.parenthesizer, Bool.false, Lean.Parser.Term.optType.parenthesizer]]
[Lean.Elab.Tactic.evalEraseAuxDiscrs,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.MonadLCtx.getLCtx, Lean.Elab.Tactic.getMainGoal, ForIn.forIn, liftM, Lean.Meta.tryClear, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.nil]]
[Std.HashMap.findEntry?,[Option, Prod, Std.HashMapImp.findEntry?]]
[Lean.Json.Structured.noConfusionType,[]]
[Lean.Expr.forallE.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.squeezeDSimp!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.Elab.Term.registerMVarErrorImplicitArgInfo,[Lean.Elab.Term.registerMVarErrorInfo, Lean.Elab.Term.MVarErrorInfo.mk, Lean.Elab.Term.MVarErrorKind.implicitArg]]
[Lean.Core.liftIOCore,[Bind.bind, Lean.MonadRef.getRef, liftM, IO.toEIO, Lean.Exception.error, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, ToString.toString]]
[Lean.Meta.collectUsedFVars,[Bind.bind, liftM, Lean.Meta.instantiateMVars, modify, Lean.collectFVars]]
[not_imp_of_and_not,[False]]
[Lean.Meta.SavedState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.WF.elabWFRel,[Option.none, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Elab.Term.withDeclName, Lean.Elab.PreDefinition.declName, Bind.bind, liftM, Lean.Meta.getLevel, Lean.Elab.Term.withSynthesize, Lean.Elab.Term.elabTermEnsuringType, Option.some, Bool.true, Bool.false, Lean.Meta.instantiateMVars, Lean.Meta.getMVars, Functor.discard, Lean.Elab.Term.logUnassignedUsingErrorInfos, Pure.pure, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Std.HashSet.numBuckets,[Array.size, Subtype.val, Std.HashSetImp.buckets]]
[Char.ne_of_val_ne,[absurd, Char.val_eq_of_eq]]
[Lean.Elab.Term.elabByTactic,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Bind.bind, liftM, Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.syntheticOpaque, Lean.Name.anonymous, Lean.MonadRef.getRef, Lean.Elab.Term.getDeclName?, Lean.Elab.Term.saveContext, Lean.Elab.Term.registerSyntheticMVar, Lean.Elab.Term.SyntheticMVarKind.tactic, Pure.pure, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[AddCommSemigroup.noConfusionType,[]]
[Lean.Core.Context.openDecls,[]]
[Lean.Meta.instToFormatSimpLemma,[Std.ToFormat.mk, HAppend.hAppend, Std.Format.text]]
[instHashableUInt32,[Hashable.mk, UInt32.toUInt64]]
[Lean.Export.Alloc.mk.inj,[And.intro]]
[List.subset_append_of_subset_left,[List.subset.trans, List.subset_append_left]]
[Lean.Lsp.LeanFileProgressParams.textDocument,[]]
[Lean.Meta.Match.Extension.Entry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[le_of_lt,[LE.le, And.left, le_not_le_of_lt]]
[String.decEq,[Decidable, Eq, dite, Decidable.isTrue, String.decEq.proof_1, Decidable.isFalse, String.decEq.proof_2]]
[Lean.Parser.Tactic.deltaInstance,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[Lean.Elab.WF.TerminationHint.noConfusionType,[]]
[Lean.Meta.Instances.mk.inj,[And.intro]]
[Lean.Syntax.Traverser.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Syntax.Traverser.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Delaborator.mkDelabAttribute,[Lean.KeyedDeclsAttribute.init, Lean.KeyedDeclsAttribute.Def.mk, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Meta.InstanceEntry.globalName?,[]]
[Lean.Elab.Term.MutualClosure.LetRecClosure.toLift,[]]
[Lean.Syntax.instToFormatSyntax,[Std.ToFormat.mk, Lean.Syntax.formatStx, Option.none, Bool.false]]
[Lean.Meta.orElse,[Bind.bind, Lean.MonadBacktrack.saveState, MonadExcept.tryCatch, Lean.Meta.SavedState.restore, Unit.unit]]
[System.instToStringFilePath,[ToString.mk, System.FilePath.toString]]
[Lean.Parser.node,[Lean.Parser.Parser.mk, Lean.Parser.nodeInfo, Lean.Parser.Parser.info, Lean.Parser.nodeFn, Lean.Parser.Parser.fn]]
[Stream.next?,[]]
[forall_eq,[Iff.intro, rfl, Eq.symm]]
[Lean.Parser.Command.where,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Lean.IR.instAlphaEqvVarId,[Lean.IR.AlphaEqv.mk, Lean.IR.VarId.alphaEqv]]
[Lean.Meta.Closure.mkLambda,[Lean.Meta.Closure.mkBinding, Bool.true]]
[Lean.Lsp.instToJsonDocumentFilter,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Lsp.DocumentFilter.language?, Lean.Lsp.DocumentFilter.scheme?, Lean.Lsp.DocumentFilter.pattern?, List.nil]]
[Lean.Widget.InfoPopup.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt8.shiftLeft,[UInt8.mk, HShiftLeft.hShiftLeft, UInt8.val, UInt8.modn, OfNat.ofNat]]
[Lean.isSubobjectField?,[Option.none, Option, Lean.Name, Lean.getFieldInfo?, Lean.StructureFieldInfo.subobject?]]
[List.forIn.loop,[Pure.pure, Bind.bind, PProd.fst]]
[Lean.IR.Checker.checkObjType,[Lean.IR.Checker.checkType, Lean.IR.IRType.isObj]]
[Std.RBNode.setBlack,[Std.RBNode.leaf, Std.RBNode, Std.RBNode.node, Std.Rbcolor.black]]
[Lean.Elab.CompletionInfo.dot.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[EStateM.orElse,[EStateM.Result.ok, EStateM.Result, Unit.unit, EStateM.Backtrackable.restore]]
[Lean.Expr.getRevArgD,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, PProd.fst]]
[Lean.instToMessageDataOption,[Lean.ToMessageData.mk, Unit.unit, Lean.MessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.isMarkedBorrowed,[Option.isSome, Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Elab.Term.StructInst.DefaultFields.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.StructInst.DefaultFields.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Array.qpartition,[Array.qpartition.loop]]
[Lean.Parser.ParserExtension.Entry.parser.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Mathlib.Tactic.Lint.instInhabitedLintVerbosity,[Inhabited.mk, Mathlib.Tactic.Lint.LintVerbosity.low]]
[IO.Process.SpawnArgs.args,[]]
[Lean.IR.NormalizeIds.N,[ReaderT, Lean.IR.IndexRenaming, StateM, Nat]]
[Lean.Elab.Structural.mkEqns,[Lean.MonadWithOptions.withOptions, Lean.Option.set, Lean.Meta.tactic.hygienic, Bool.false, Bind.bind, Lean.Meta.withNewMCtxDepth, Lean.Meta.lambdaTelescope, Lean.Elab.Structural.EqnInfo.value, Lean.Meta.mkEq, Lean.mkAppN, Lean.mkConst, Lean.Elab.Structural.EqnInfo.declName, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Name.anonymous, StateRefT'.run, ReaderT.run, Lean.Expr.mvarId!, List.toArray, List.nil, Lean.Meta.MetaM, Array, Lean.Expr, Pure.pure, Lean.MonadEnv.getEnv, ForIn.forIn, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Array.getOp, PUnit.unit]]
[Lean.Expr.listLit?,[List.nil, Lean.Expr.listLit?.loop]]
[Sum.inl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Std.HashMapImp.mkIdx,[Subtype.mk, HMod.hMod, USize.modn_lt]]
[Lean.Parser.Term.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.termParser.formatter, Lean.PrettyPrinter.Formatter.many1Unbox.formatter, Lean.Parser.commandParser.formatter]]
[Lean.Elab.Term.expandFun,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Term.expandFunBinders, Lean.MacroM, Lean.Syntax, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Macro.throwUnsupported, cond, Lean.Elab.Term.expandMatchAltsIntoMatch, Bool.false]]
[stx_?,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Lean.IR.Borrow.OwnedSet.insert,[Std.HashMap.insert, Unit.unit]]
[Lean.Parser.Term.prio.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.priorityParser.parenthesizer]]
[Lean.StructureFieldInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.coprime_one_left_iff,[of_eq_true, Eq.trans, congr, congrArg, Iff, congrFun, Eq, Nat.gcd_one_left, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true]]
[Lean.Elab.CompletionInfo.dot.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.CompletionInfo.dot, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.OpenDecl.State.openDecls,[]]
[Lean.Compiler.getImplementedBy,[Lean.ParametricAttribute.getParam, Lean.Compiler.implementedByAttr]]
[Lean.PersistentLevelSet,[Std.PHashSet, Lean.Level]]
[Lean.Meta.injectionIntro.go,[Lean.Meta.MetaM, Lean.Meta.InjectionResult, Pure.pure, Lean.Meta.InjectionResult.subgoal, Bind.bind, Lean.Meta.intro, Lean.Meta.withMVarContext, Lean.Meta.getLocalDecl, Lean.Meta.whnf, Lean.LocalDecl.type, Unit.unit, Prod, Lean.FVarId, Lean.MVarId, Lean.Expr.heq?, Prod.mk, Lean.Meta.isDefEq, ite, Eq, Bool.true, Lean.Meta.mkEqOfHEq, Lean.mkFVar, Lean.Meta.mkEq, Lean.Meta.assert, Lean.LocalDecl.userName, Lean.Meta.tryClear, PUnit.unit, PProd.fst, Array.push, Lean.Meta.intro1, List.nil]]
[instXorUSize,[Xor.mk, USize.xor]]
[Lean.isReducible,[Bind.bind, Lean.getReducibilityStatus, Unit.unit, Lean.ReducibilityStatus.semireducible, Lean.ReducibilityStatus.irreducible, Bool, Pure.pure, Bool.true, Bool.false]]
[Array.toListLitAux.proof_1,[Nat.le_of_succ_le]]
[Lean.ConstantInfo.hasValue,[Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Bool, Bool.true, Bool.false]]
[Lean.Meta.SimpEntry.toUnfold.inj,[]]
[Lean.ScopedEnvExtension.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.RecursorVal.isUnsafe,[]]
[«term_⊕'_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.MetavarContext.instMonadMCtxMetavarContextST,[Lean.MonadMCtx.mk, MonadState.get, modify]]
[Lean.ScopedEnvExtension.mk.inj,[And.intro]]
[String.atEnd,[Bool, Decidable.decide, GE.ge, String.utf8ByteSize]]
[Lean.Lsp.SymbolKind.null.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Lsp.DocumentSelector,[Array, Lean.Lsp.DocumentFilter]]
[Lean.Level.param.inj,[And.intro]]
[Nat.sub_add_min_cancel,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HSub.hSub, min, Nat.sub_eq_sub_min, Nat.sub_add_cancel, min_le_left, rfl]]
[Lean.Elab.Modifiers.isPartial,[Lean.Elab.Modifiers.mk, Lean.Elab.RecKind.nonrec, Lean.Elab.RecKind.default, Bool, Bool.true, Bool.false]]
[Lean.PrettyPrinter.Formatter.strLitNoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.visitAtom, Lean.strLitKind]]
[Lean.Elab.Command.Scope.isNoncomputable,[]]
[Lean.IR.MapVars.mapArgs,[Array.map, Lean.IR.MapVars.mapArg]]
[Lean.CollectMVars.State.mk.inj,[And.intro]]
[Lean.FVarId.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Syntax.reprint.reprintLeaf,[Lean.SourceInfo.synthetic, Lean.SourceInfo.none, String, HAppend.hAppend, ToString.toString]]
[Lean.HeadIndex.proj.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.div_eq_of_eq_mul_right,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, Nat.mul_div_cancel_left, rfl]]
[Array.concatMapM,[Array.foldlM, Bind.bind, Pure.pure, HAppend.hAppend, Array.empty, OfNat.ofNat, Array.size]]
[Lean.getPPAnalysisSkip,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false]]
[Lean.PrettyPrinter.Formatter.State.mk.inj,[And.intro]]
[Lean.Syntax.getKind,[Unit.unit, Lean.SyntaxNodeKind, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Name.mkSimple, Lean.identKind]]
[Lean.Expr.isForall,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[let_congr,[]]
[Nat.lt_of_le_and_ne,[LT.lt, Nat.eq_or_lt_of_le, absurd]]
[Lean.Xml.Parser.AttValue,[Bind.bind, HOrElse.hOrElse, Lean.Parsec.skipChar, Char.ofNat, SeqLeft.seqLeft, Lean.Parsec.many, Functor.map, Option.some, Lean.Parsec.satisfy, Decidable.decide, And, Ne, Lean.Xml.Parser.Reference, Pure.pure, Array.foldl, Option.none, String, String.push, OfNat.ofNat, Array.size]]
[Lean.Xml.Element.Element.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, Eq.refl, List.nil, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec]]
[Lean.Parser.Term.explicitUniv.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkStackTop.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.levelParser.formatter, Bool.false]]
[Lean.Parser.Command.copyDocString,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.unary]]
[instSemigroupFin,[Semigroup.mk, instSemigroupFin.proof_1]]
[instInhabitedExceptT,[Inhabited.mk, MonadExcept.throw, arbitrary]]
[not_or_intro,[False, absurd]]
[Lean.Server.RequestError.mk.inj,[And.intro]]
[Lean.Lsp.CompletionOptions.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.CompletionOptions.mk, Eq.symm, eq_of_heq, HEq.refl]]
[UInt32.decLe,[Decidable, LE.le, inferInstanceAs]]
[Lean.Meta.FVarSubst.find?,[Std.AssocList.find?, Lean.Meta.FVarSubst.map]]
[Lean.IR.Expr.ap.inj,[And.intro]]
[Std.PersistentHashSet.mk.inj,[]]
[Lean.Meta.SimpLemmas.toUnfold,[]]
[Lean.Meta.DiscrTree.instLTKey,[LT.mk, Eq, Lean.Meta.DiscrTree.Key.lt, Bool.true]]
[List.insert_of_not_mem,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, if_neg, List, List.cons, eq_self]]
[List.mem_singleton,[Iff.intro, List.eq_of_mem_singleton, Or.inl]]
[Lean.Meta.SynthInstance.tryAnswer,[Lean.Meta.withMCtx, Bind.bind, liftM, Lean.Meta.openAbstractMVarsResult, Lean.Meta.SynthInstance.Answer.result, Lean.Meta.SynthInstance.SynthM, Option, Lean.MetavarContext, Lean.Meta.isDefEq, ite, Eq, Bool.true, Lean.MonadMCtx.getMCtx, Pure.pure, Option.some, Option.none]]
[Lean.LBool.noConfusion,[noConfusionEnum, Lean.LBool.toCtorIdx]]
[Numeric.ofNat,[]]
[Lean.Parser.Command.inferMod.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer]]
[Lean.Lsp.Position.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.Position.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Command.StructView.ctor,[]]
[Lean.Meta.RecursorInfo.instToStringRecursorInfo,[ToString.mk, HAppend.hAppend, ToString.toString, Lean.Meta.RecursorInfo.recursorName, Lean.Meta.RecursorInfo.typeName, Lean.Meta.RecursorInfo.univLevelPos, Lean.Meta.RecursorInfo.depElim, Lean.Meta.RecursorInfo.recursive, Lean.Meta.RecursorInfo.numArgs, Lean.Meta.RecursorInfo.numParams, Lean.Meta.RecursorInfo.numIndices, Lean.Meta.RecursorInfo.numMinors, Lean.Meta.RecursorInfo.majorPos, Lean.Meta.RecursorInfo.motivePos, Lean.Meta.RecursorInfo.paramsPos, Lean.Meta.RecursorInfo.indicesPos, Lean.Meta.RecursorInfo.produceMotive]]
[Int.noConfusionType,[]]
[Task.get,[]]
[Lean.Position.lt,[Bool, Decidable.decide, LT.lt, Prod.mk]]
[Lean.Elab.Term.addNamedArg,[ite, Eq, Array.any, BEq.beq, Lean.Elab.Term.NamedArg.name, OfNat.ofNat, Array.size, Bool.true, Bind.bind, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.Parser.ParserExtension.instInhabitedState,[Inhabited.mk, Lean.Parser.ParserExtension.State.mk, arbitrary]]
[Lean.Parser.Tactic.ringExp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.isExternC,[Option.none, Option.some, Lean.ExternAttrData.mk, List.nil, List.cons, Lean.ExternEntry.adhoc, Lean.ExternEntry.inline, Lean.ExternEntry.standard, Lean.Name.anonymous, dite, Eq, Lean.Name.str, Eq.symm, Lean.Name.num, Lean.ExternEntry.foreign, Bool, Lean.getExternAttrData, Bool.true, Bool.false]]
[Lean.IR.Borrow.isOwned,[Bind.bind, Lean.IR.Borrow.getCurrFn, MonadState.get, Pure.pure, Lean.IR.Borrow.OwnedSet.contains, Lean.IR.Borrow.BorrowInfState.owned, Prod.mk, Lean.IR.VarId.idx]]
[Lean.Meta.isProp,[Bind.bind, Lean.Meta.isPropQuick, Unit.unit, Lean.Meta.MetaM, Bool, Pure.pure, Bool.true, Bool.false, Lean.Meta.inferType, Lean.Meta.whnfD, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.instantiateLevelMVars, and, PProd.fst, PProd.snd]]
[Int.pow,[Unit.unit, Int, OfNat.ofNat, HMul.hMul, PProd.fst]]
[Lean.StructureFieldInfo.subobject?,[]]
[Lean.IR.IsLive.visitJP,[Pure.pure, Lean.IR.HasIndex.visitJP]]
[Lean.Elab.Command.instInhabitedCommandElabM,[Inhabited.mk, MonadExcept.throw, arbitrary]]
[Lean.instFromJsonUInt64,[Lean.FromJson.mk, Bind.bind, Lean.bignumFromJson?, ite, GE.ge, UInt64.size, MonadExcept.throw, Pure.pure, PUnit.unit]]
[Lean.Elab.Deriving.SizeOf.mkSizeOfHandler,[Bind.bind, Array.allM, Lean.isInductive, OfNat.ofNat, Array.size, ite, Eq, and, Decidable.decide, GT.gt, Bool.true, Lean.Elab.Command.liftTermElabM, Option.none, liftM, Lean.Meta.mkSizeOfInstances, Array.getOp, Pure.pure, Bool.false]]
[Lean.Meta.IndPredBelow.mkCtorType.mkMotiveBinder,[Lean.Meta.forallTelescopeReducing, Lean.Expr.withApp, Bind.bind, Lean.Meta.mkForallFVars, Bool.false, Bool.true, Lean.Meta.IndPredBelow.mkCtorType.copyVarName, Lean.Expr.fvarId!, Lean.Meta.withLocalDecl, Lean.Expr.binderInfo]]
[Lean.LocalDecl.hasValue,[Bool, Bool.false, Bool.true]]
[Lean.Meta.simp,[Bind.bind, Lean.MonadOptions.getOptions, Lean.profileitM, Lean.Exception, Unit.unit, Lean.Meta.MetaM, Lean.Meta.Simp.Result, Lean.Meta.Simp.main, Lean.Meta.Simp.DefaultMethods.methods, Lean.Meta.Simp.Methods.mk, Lean.Meta.Simp.preDefault, Lean.Meta.Simp.postDefault]]
[Nat.pred_le_pred,[Nat.zero, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Nat.succ, LE.le, Nat.pred, Nat.le.refl, Nat.le_trans, Nat.le_succ]]
[or_imp_distrib,[Iff.intro, And.intro, Or.inl, Or.inr]]
[Lean.Parser.Term.scoped,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Classical.inhabited_of_exists,[Classical.inhabited_of_nonempty, Classical.inhabited_of_exists.proof_1]]
[Lean.Meta.Match.Extension.State.noConfusionType,[]]
[Lean.Elab.Term.elabTerm,[Lean.withRef]]
[Lean.Elab.Modifiers.mk.inj,[And.intro]]
[Lean.Widget.Lean.Widget.InteractiveGoal.instRpcEncodingInteractiveGoalRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Lean.Widget.InteractiveGoal.hyps, Lean.Widget.InteractiveGoal.type, Lean.Widget.InteractiveGoal.userName?, Pure.pure, Lean.Server.RpcEncoding.rpcDecode, Lean.Widget.InteractiveGoal.mk]]
[Lean.Expr.updateConst!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateConst, Lean.Expr.const, Lean.Expr.updateConst!.proof_1, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.IR.FnBody.noConfusionType,[]]
[String.Iterator.setCurr,[String.Iterator, String.Iterator.mk, String.set]]
[Lean.Parser.orelseFnCore,[Unit.unit, Lean.Parser.ParserState, Lean.Parser.ParserState.errorMsg, ite, Eq, BEq.beq, Lean.Parser.ParserState.pos, Bool.true, Lean.Parser.mergeOrElseErrors, Lean.Parser.ParserState.restore]]
[ExceptT.map,[ExceptT.mk, Bind.bind, Except, Pure.pure, Except.ok, Except.error]]
[Lean.ReducibilityHints.regular.injEq,[Eq.propIntro, Eq.refl, Lean.ReducibilityHints.regular, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.UnificationConstraint.noConfusionType,[]]
[Array.swap!,[dite, LT.lt, Array.size, Array.swap, Fin.mk, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Parser.Term.implicitBinder.formatter,[Lean.ppGroup.formatter, Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.Parser.Term.binderType.formatter]]
[Lean.setProtected,[Lean.MonadEnv.modifyEnv, Lean.addProtected]]
[Lean.Attribute.Builtin.getIdent,[Bind.bind, Lean.Attribute.Builtin.getIdent?, Unit.unit, Lean.AttrM, Lean.Syntax, Pure.pure, Lean.throwErrorAt, Lean.ToMessageData.toMessageData]]
[Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx,[OfNat.ofNat]]
[Lean.Parser.levelParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous]]
[setOf,[]]
[Lean.Parser.Command.in.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.withOpen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.commandParser.parenthesizer]]
[Lean.Elab.Term.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.expandExplicitBinders,[Bind.bind, Lean.MonadRef.getRef, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.expandExplicitBindersAux, Array.all, Lean.Syntax.getArgs, OfNat.ofNat, Array.size, Lean.expandBrackedBindersAux, Lean.Macro.throwError]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.analyzeConst,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM, Unit, MonadReader.read, ite, Eq, and, not, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.knowsLevel, List.isEmpty, Bool.true, Lean.MonadOptions.getOptions, Lean.getPPAnalyzeOmitMax, List.any, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.containsBadMax, Pure.pure, PUnit.unit, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.annotateBool, Lean.Name.mkStr, Lean.Name.anonymous, panicWithPosWithDecl, OfNat.ofNat]]
[Mathlib.Tactic.Lint.Linter.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.DiagnosticWith.tags?,[]]
[Lean.Elab.getResetInfoTrees,[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, Lean.Elab.MonadInfoTree.modifyInfoState, Lean.Elab.InfoState.mk, Lean.Elab.InfoState.enabled, Lean.Elab.InfoState.assignment, Lean.Elab.InfoState.trees, Std.PersistentArray.mk, Pure.pure]]
[Lean.LBool.noConfusionType,[noConfusionTypeEnum, Lean.LBool.toCtorIdx]]
[EStateM.set,[EStateM.Result.ok, PUnit.unit]]
[Lean.Parser.ensureUnaryParserAlias,[Functor.discard, Lean.Parser.getUnaryAlias, Lean.Parser.parserAliasesRef]]
[StateT.instMonadExceptOfStateT,[MonadExceptOf.mk, Function.comp, StateT.lift, throwThe, tryCatchThe]]
[AddMonoid.nsmul_zero',[]]
[Lean.Parser.Term.falseVal.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false]]
[Lean.Elab.Term.ElabAppArgs.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.ElabAppArgs.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.le_succ_of_le,[Nat.le_trans, Nat.le_succ]]
[Lean.Meta.Closure.mkNewLevelParam,[Bind.bind, MonadState.get, modify, Lean.Meta.Closure.State.mk, Lean.Meta.Closure.State.visitedLevel, Lean.Meta.Closure.State.visitedExpr, Array.push, Lean.Meta.Closure.State.levelParams, HAdd.hAdd, Lean.Meta.Closure.State.nextLevelIdx, OfNat.ofNat, Lean.Meta.Closure.State.levelArgs, Lean.Meta.Closure.State.newLocalDecls, Lean.Meta.Closure.State.newLocalDeclsForMVars, Lean.Meta.Closure.State.newLetDecls, Lean.Meta.Closure.State.nextExprIdx, Lean.Meta.Closure.State.exprMVarArgs, Lean.Meta.Closure.State.exprFVarArgs, Lean.Meta.Closure.State.toProcess, Pure.pure, Lean.mkLevelParam]]
[Lean.Parser.ParserExtension.Entry.token.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.ParserExtension.Entry.token, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.AttributeExtensionState.mk.inj,[And.intro]]
[Lean.Parser.ParserExtension.Entry.category.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserExtension.Entry.category, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Delaborator.Context.noConfusionType,[]]
[Lean.Elab.Command.getScope,[Bind.bind, MonadState.get, Pure.pure, List.head!, Lean.Elab.Command.State.scopes]]
[Lean.Rat.num,[]]
[Lean.Lsp.WorkDoneProgressBegin.mk.inj,[And.intro]]
[Fin.div.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[Lean.ScopedEnvExtension.addEntryFn,[Lean.ScopedEnvExtension.StateStack, Lean.ScopedEnvExtension.StateStack.mk, List.map, Lean.ScopedEnvExtension.State.mk, Lean.ScopedEnvExtension.Descr.addEntry, Lean.ScopedEnvExtension.State.state, Lean.ScopedEnvExtension.State.activeScopes, List.cons, Lean.ScopedEnvExtension.Entry.global, Lean.ScopedEnvExtension.Descr.toOLeanEntry, Lean.ScopedEnvExtension.ScopedEntries.insert, Lean.ScopedEnvExtension.Entry.scoped]]
[ReaderT.run,[]]
[Lean.NameGenerator.noConfusionType,[]]
[instBEqFloat,[BEq.mk, Float.beq]]
[Lean.Meta.isReadOnlyOrSyntheticOpaqueExprMVar,[Bind.bind, Lean.Meta.getMVarDecl, Lean.MetavarKind.natural, Lean.MetavarKind.synthetic, Unit.unit, Lean.Meta.MetaM, Bool, Lean.MetavarDecl.kind, Lean.Meta.getConfig, Pure.pure, not, Lean.Meta.Config.assignSyntheticOpaque, Lean.MonadMCtx.getMCtx, bne, Lean.MetavarDecl.depth, Lean.MetavarContext.depth]]
[Lean.Parser.atomic,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.atomicFn, Lean.Parser.Parser.fn]]
[Lean.ReducibilityHints.noConfusionType,[]]
[Lean.Lsp.ServerInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.ServerInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[«term_>>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Classical.inhabited_of_exists.proof_1,[Exists.elim, Nonempty.intro]]
[Lean.Meta.Simp.SimpLetCase.dep.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Iff.mp,[]]
[Lean.Elab.Term.StructInst.ExplicitSourceInfo.structName,[]]
[Not.imp,[mt]]
[Lean.Meta.mkEqFalse',[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil]]
[StateT.orElse,[HOrElse.hOrElse, Unit.unit]]
[Lean.Elab.Tactic.commandDeclare_config_elab____,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Lean.Lsp.SymbolKind.constant.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[exists_prop_decidable.proof_1,[Iff.intro, Exists.intro]]
[Nat.pow_le_pow_of_le_left,[Unit.unit, LE.le, HPow.hPow, Nat.le_refl, OfNat.ofNat, Nat.mul_le_mul, PProd.fst]]
[Lean.Elab.Term.resetMessageLog,[Lean.Elab.Term.setMessageLog, Lean.MessageLog.mk]]
[Lean.Expr.head,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.proj, Lean.Expr, PProd.fst, PProd.snd]]
[Lean.Parser.Command.terminationHint1,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat]]
[Lean.Compiler.foldNatDiv,[Lean.Compiler.foldNatBinOp, Div.div]]
[Lean.withoutModifyingState,[Bind.bind, Lean.MonadBacktrack.saveState, tryFinally, Lean.MonadBacktrack.restoreState]]
[List.hasDecEq.proof_4,[rfl]]
[List.lookup,[Option, Option.none, Unit.unit, BEq.beq, Option.some, PProd.fst]]
[Lean.Server.Watchdog.runClientTask,[Bind.bind, MonadReader.read, liftM, IO.asTask, Task.Priority.default, Pure.pure]]
[Lean.Elab.Term.Do.ToTerm.M,[ReaderT, Lean.Elab.Term.Do.ToTerm.Context, Lean.MacroM]]
[System.FilePath.instHDivFilePathStringFilePath,[HDiv.mk, System.FilePath.join, System.FilePath.mk]]
[Lean.MacroScopesView.imported,[]]
[IO.FS.FileType.other.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Unhygienic.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Unhygienic.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.OptionDecl.descr,[]]
[Lean.Parser.withAntiquotSuffixSplice,[Lean.Parser.Parser.mk, Lean.Parser.andthenInfo, Lean.Parser.Parser.info, Lean.Parser.withAntiquotSuffixSpliceFn, Lean.Parser.Parser.fn]]
[Lean.PrettyPrinter.Delaborator.getPPOption,[Bind.bind, Lean.PrettyPrinter.Delaborator.getOptionsAtCurrPos, Pure.pure]]
[Nat.coprime.pow_left,[Nat.coprime_one_left]]
[Lean.Elab.Command.CtorView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.CtorView.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Xml.Content.below,[PProd, PUnit]]
[Lean.Elab.isFreshInstanceName,[Lean.Name.anonymous, Lean.Name.num, Bool, String.isPrefixOf, Bool.false]]
[PSigma.revLexAccessible,[PSigma.revLexAccessible.proof_1]]
[Lean.Lsp.instFileSourcePlainTermGoalParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.PlainTermGoalParams.toTextDocumentPositionParams]]
[dite_true,[rfl]]
[Lean.Meta.UnificationHintEntry.noConfusionType,[]]
[Lean.PPContext.noConfusionType,[]]
[IO.Error.timeExpired.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[left_identity,[Eq]]
[Lean.Parser.ensureConstantParserAlias,[Functor.discard, Lean.Parser.getConstAlias, Lean.Parser.parserAliasesRef]]
[Lean.Meta.RecursorUnivLevelPos.majorType.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.open,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.openDecl, Lean.Parser.withOpenDecl, Lean.Parser.Tactic.tacticSeq]]
[Tactic.Ring.State.numAtoms,[]]
[Lean.instInhabitedDefinitionVal,[Inhabited.mk, Lean.DefinitionVal.mk, arbitrary]]
[Lean.Meta.isDefEqGuarded,[Lean.Meta.isExprDefEqGuarded]]
[Lean.IR.LocalContextEntry.param.inj,[]]
[Sum.inr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.withLCtx,[Lean.Meta.mapMetaM, Bind.bind, Lean.Meta.getLocalInstances, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth, ite, Eq, BEq.beq, Bool.true, Lean.Meta.resettingSynthInstanceCache]]
[prioDefault,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Elab.Term.Do.Alt.vars,[]]
[Lean.IR.mkVarArg,[Lean.IR.Arg.var]]
[Lean.Lsp.SemanticTokenType.property.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.PostponedEntry.ref,[]]
[«term_&&_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.withInfoHole,[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, ite, Eq, Lean.Elab.InfoState.enabled, Bool.true, Lean.Elab.getResetInfoTrees, Functor.map, Prod.fst, MonadFinally.tryFinally', Lean.Elab.MonadInfoTree.modifyInfoState, GT.gt, Std.PersistentArray.size, Lean.Elab.InfoState.trees, OfNat.ofNat, Lean.Elab.InfoState.mk, Std.PersistentHashMap.insert, Lean.Elab.InfoState.assignment, Std.PersistentArray.getOp, HSub.hSub]]
[Lean.Expr.ReplaceLevelImpl.replaceUnsafeM,[Lean.Expr.ReplaceLevelImpl.replaceUnsafeM.visit]]
[Lean.Parser.Tactic.match.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.generalizingParam.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.Term.matchDiscr.parenthesizer, Bool.false, Lean.Parser.Term.optType.parenthesizer, Lean.Parser.Tactic.matchAlts.parenthesizer]]
[instMonadLiftT_1,[MonadLiftT.mk]]
[Lean.Parser.ParserState.hasError,[bne, Lean.Parser.ParserState.errorMsg, Option.none]]
[Lean.Parser.Term.optType.formatter,[Lean.Parser.optional.formatter, Lean.Parser.Term.typeSpec.formatter]]
[Lean.Elab.Term.StructInst.FieldLHS.fieldIndex.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.StructInst.FieldLHS.fieldIndex, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.FnBody.setTag.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.setTag, Eq.symm, eq_of_heq, HEq.refl]]
[and_implies,[And.imp]]
[Std.mkHashSetImp,[Std.HashSetImp.mk, OfNat.ofNat, Subtype.mk, Array.mkArray, List.nil, Std.mkHashSetImp.proof_1]]
[Lean.Elab.Info.contains,[Option.any, String.Range.contains, Lean.Elab.Info.range?]]
[instReprId,[inferInstanceAs, Repr]]
[Lean.IR.Expr.reset.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.instOrOpNat,[OrOp.mk, Nat.lor]]
[Lean.Server.FileWorker.RpcSession.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt16.mk_val_eq,[Eq, UInt16.mk, UInt16.val, rfl]]
[Lean.Parser.Trie.find?,[OfNat.ofNat, Lean.Parser.Trie.find?.loop]]
[Lean.Parser.Term.doForDecl.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withForbidden.parenthesizer]]
[Lean.Parser.Command.declSig.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.many.formatter, Lean.ppSpace.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.simpleBinderWithoutType.formatter, Lean.Parser.Term.bracketedBinder.formatter, Bool.false, Lean.Parser.Term.typeSpec.formatter]]
[Lean.Elab.Term.mkSaveInfoAnnotation,[ite, Eq, Lean.Expr.isMVar, Bool.true, Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous]]
[LawfulMonad.bind_pure_comp,[]]
[Lean.Server.WithRpcRef.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Server.WithRpcRef.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.mul,[Nat, OfNat.ofNat, Nat.add, PProd.fst]]
[Lean.Parser.Tactic.ghostSimp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg]]
[Std.Format.ibelow,[True, And]]
[Lean.Expr.findLevelMVar?,[Lean.FindLevelMVar.main, Option.none]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.replaceLPsWithVars,[ite, Eq, not, Lean.Expr.hasLevelParam, Bool.true, Pure.pure, Bind.bind, PUnit.unit]]
[List.ne_nil_of_mem,[False, Eq.mp, Eq.refl, Mem.mem]]
[Lean.LocalContext.mkLetDecl,[Lean.LocalContext, Lean.LocalContext.mk, Std.PersistentHashMap.insert, Std.PersistentArray.push, Option.some]]
[Lean.Meta.DiscrTree.root,[]]
[Lean.Expr.iff?,[Lean.Expr.app2?, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.InductiveVal.mk.inj,[And.intro]]
[Function.uncurry_bicompl,[funext, Eq, Function.uncurry, Function.bicompl, Function.comp, Prod.map, rfl]]
[Lean.Lsp.DidCloseTextDocumentParams.textDocument,[]]
[Lean.MonadRecDepth.withRecDepth,[]]
[Nat.mul_dvd_mul_right,[Nat.mul_dvd_mul, Nat.dvd_refl]]
[Lean.IR.Param.mk.inj,[And.intro]]
[Lean.LocalContext.lastDecl,[Std.PersistentArray.get!, Lean.LocalContext.decls, HSub.hSub, Std.PersistentArray.size, OfNat.ofNat]]
[CommSemigroup.noConfusionType,[]]
[Iff.subst,[Eq.subst, propext]]
[Mathlib.Tactic.rename',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[Lean.Meta.addInstanceEntry,[Unit.unit, Lean.Meta.Instances, Lean.Meta.InstanceEntry.globalName?, Lean.Meta.Instances.mk, Lean.Meta.DiscrTree.insertCore, Lean.Meta.Instances.discrTree, Lean.Meta.InstanceEntry.keys, Std.PersistentHashSet.insert, Lean.Meta.Instances.instanceNames, Lean.Meta.Instances.erased]]
[LawfulApplicative.seqLeft_eq,[]]
[Char.isWhitespace,[or, Decidable.decide, Eq, Char.ofNat]]
[Set.instFunctorSet,[Functor.mk, Set.image]]
[Lean.Parser.Term.binderType.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.ite, Eq, Bool.true, Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.nullKind, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Lean.Parser.optional.parenthesizer]]
[Nat.mod,[WellFounded.fix, Nat.mod.proof_1, dite, And, LT.lt, OfNat.ofNat, LE.le, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le]]
[Lean.PrettyPrinter.parenthesizeCommand,[Lean.PrettyPrinter.parenthesize, Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat]]
[Lean.IR.FnBody.del.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Export.OfState.get,[]]
[List.pairwise.brecOn,[List.pairwise.below.nil, List.pairwise.below.cons]]
[and_congr_left,[Iff.trans, And.comm, and_congr_right]]
[instLEUSize,[LE.mk, USize.le]]
[Lean.Json.getObjVal?,[Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Lean.Json.arr, Except, String, Lean.Json, Unit.unit, Std.RBNode.find, Ord.compare, Pure.pure, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Lean.Elab.Tactic.Simp.DischargeWrapper.default.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Command.ElabHeaderResult.type,[]]
[List.forall_mem_cons,[List.ball_cons]]
[Std.HashSetImp.expand,[]]
[Lean.Meta.Match.Extension.Entry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.Extension.Entry.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Substring.take,[Substring.mk, Substring, HAdd.hAdd, Substring.nextn, OfNat.ofNat]]
[List.erase_cons_tail,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.erase_cons, if_neg, List, List.cons, List.erase, eq_self]]
[Lean.Expr.Data.hash,[UInt32.toUInt64, UInt64.toUInt32]]
[Lean.Syntax.node.inj,[And.intro]]
[Applicative.toSeqRight,[]]
[Lean.Parser.Tactic.intervalCases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[Lean.IR.Checker.checkPartialApp,[Bind.bind, Lean.IR.Checker.getDecl, ite, LT.lt, Array.size, Lean.IR.Decl.params, Pure.pure, PUnit.unit, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[«binderTerm∈_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[List.allM,[Unit.unit, Bool, Pure.pure, Bool.true, Bind.bind, PProd.fst, Bool.false]]
[Lean.Elab.Deriving.FromToJson.mkToJsonInstanceHandler.mkAlts,[Array.mapM, Bind.bind, Lean.getConstInfoCtor, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, ForIn.forIn, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, PUnit.unit, ForInStep.yield, MProd.mk, liftM, Lean.Meta.getLocalDecl, Lean.Expr.fvarId!, ite, Eq, not, Lean.Name.hasMacroScopes, Lean.LocalDecl.userName, Bool.true, Lean.Elab.Term.TermElabM, Lean.Syntax, Lean.mkIdent, Lean.ConstantVal.name, Array.append, BEq.beq, Array.size, Option.some, Option.none, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.InductiveVal.ctors]]
[Lean.Parser.Term.precheckedQuot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.quot]]
[bool,[Unit.unit, ToBool.toBool]]
[Lean.Meta.Match.MatchEqnsExtState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Expr.bindingInfo!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.BinderInfo, Lean.Expr.Data.binderInfo, panicWithPosWithDecl, OfNat.ofNat]]
[Int.coe_nat_sub,[Int.ofNat_sub]]
[System.instCoeStringFilePath,[Coe.mk, System.FilePath.mk]]
[Lean.MessageData.ofName.inj,[]]
[Lean.isNumericSubscript,[and, Decidable.decide, LE.le, OfNat.ofNat, Char.val]]
[Lean.IR.UnreachableBranches.M,[ReaderT, Lean.IR.UnreachableBranches.InterpContext, StateM, Lean.IR.UnreachableBranches.InterpState]]
[Lean.Parser.Tactic.subtypeInstance,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Meta.AbstractMVarsResult.noConfusionType,[]]
[cast_heq,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, HEq, cast]]
[Classical.typeDecidableEq,[inferInstance]]
[Lean.ConstantInfo.quotInfo.injEq,[Eq.propIntro, Eq.refl, Lean.ConstantInfo.quotInfo, Eq.symm, eq_of_heq, HEq.refl]]
[instToStringPUnit,[ToString.mk]]
[Lean.Parser.Tactic.squeezeSimpa?!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser]]
[Lean.Parser.Term.cdot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.symbol.formatter]]
[Nat.mul_le_mul_of_nonneg_left,[Decidable.em, LE.le, Eq.mpr, congrArg, HMul.hMul, Nat.le_antisymm, Nat.le_refl, Eq.symm, OfNat.ofNat, of_eq_true, Eq.trans, congr, congrFun, Nat.zero_le, Nat.zero_mul, eq_true_of_decide, Eq.refl, Bool.true, Nat.le_of_lt, Nat.mul_lt_mul_of_pos_left, Iff.mp, not_le]]
[ExceptT.run_lift,[rfl]]
[Lean.IR.EmitC.getDecl,[Bind.bind, Lean.IR.EmitC.getEnv, Unit.unit, Lean.IR.EmitC.M, Lean.IR.Decl, Lean.IR.findEnvDecl, Pure.pure, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Lean.Lsp.instFileSourceTextDocumentItem,[Lean.Lsp.FileSource.mk, Lean.Lsp.TextDocumentItem.uri]]
[Lean.Elab.Term.ToParserDescrContext.noConfusionType,[]]
[Lean.Parser.TokenTable,[Lean.Parser.Trie, Lean.Parser.Token]]
[Lean.Xml.Parser.EmptyElemTag,[SeqRight.seqRight, Lean.Parsec.skipString, Pure.pure, List.toArray, List.nil]]
[Lean.Expr.forEach,[Lean.Expr.forEach', Bind.bind, Pure.pure, Bool.true]]
[ReaderT.run_seq,[Eq.mpr, Eq.refl, Eq, ReaderT.run, Seq.seq, seq_eq_bind, rfl]]
[Lean.ScopedEnvExtension.getState,[List.nil, Lean.ScopedEnvExtension.StateStack.stateStack, Lean.PersistentEnvExtension.getState, Lean.ScopedEnvExtension.ext, Lean.ScopedEnvExtension.State.state, panicWithPosWithDecl, OfNat.ofNat]]
[List.drop,[List, List.nil, PProd.fst]]
[fixCore4,[bfix4, USize.size]]
[Lean.Parser.Module.prelude.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.IR.IsLive.visitArgs,[Pure.pure, Lean.IR.HasIndex.visitArgs]]
[instOfScientificFloat,[OfScientific.mk, ite, Eq, Bool.true, Float.ofBinaryScientific, HSub.hSub, HMul.hMul, Neg.neg, OfNat.ofNat, Int.ofNat, HPow.hPow]]
[Lean.Elab.Term.Do.Code.decl.inj,[And.intro]]
[Lean.Parser.Tactic.nlinarith!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy]]
[Lean.Widget.Lean.Widget.InfoWithCtx.instRpcEncodingWithRpcRefInfoWithCtxRpcRef,[Lean.Server.RpcEncoding.mk]]
[List.disjoint_right,[List.disjoint_comm]]
[Lean.Elab.DerivingClassView.mk.inj,[And.intro]]
[Lean.MessageData.withNamingContext.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MessageData.withNamingContext, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.checkNotAssigned,[Bind.bind, Lean.Meta.isExprMVarAssigned, ite, Eq, Bool.true, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing, Pure.pure, PUnit.unit]]
[Lean.Meta.FindOptions.noConfusionType,[]]
[Lean.JsonRpc.Response.result,[]]
[Lean.Elab.Command.expandMacroArg.mkSplicePat,[Lean.mkNullNode, List.toArray, List.cons, Lean.Syntax.mkAntiquotSuffixSpliceNode, Lean.Syntax.mkAntiquotNode, OfNat.ofNat, Option.none, Lean.Name.anonymous, List.nil]]
[Lean.IR.CtorFieldInfo.format,[Unit.unit, Std.Format, Std.Format.text, HAppend.hAppend, Std.ToFormat.format]]
[ByteSlice.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[IO.FS.Stream.writeJson,[Bind.bind, IO.FS.Stream.putStr, Lean.Json.compress, IO.FS.Stream.flush]]
[Lean.Parser.registerParserAttributeHook,[ST.Ref.modify, Lean.Parser.parserAttributeHooks, List.cons]]
[Lean.Parser.Tactic.decide.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.nonReservedSymbol.formatter, Bool.false]]
[Lean.Lsp.DiagnosticTag.toCtorIdx,[OfNat.ofNat]]
[Lean.Parser.Tactic.rcasesPat.ignore,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[String.capitalize,[String.set, OfNat.ofNat, Char.toUpper, String.get]]
[instToStringFloat,[ToString.mk, Float.toString]]
[Lean.Elab.Term.Do.CodeBlock.noConfusionType,[]]
[Lean.SMap.fromHashMap,[Lean.SMap.mk]]
[Lean.Parser.Tactic.matchRhs.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.hole.formatter, Lean.Parser.Term.syntheticHole.formatter, Lean.Parser.Tactic.tacticSeq.formatter]]
[Lean.MessageLog.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt8.instAddCommSemigroupUInt8,[AddCommSemigroup.mk, UInt8.instAddCommSemigroupUInt8.proof_1]]
[Lean.Elab.Term.Do.mkSimpleJmp,[Bind.bind, Lean.Elab.Term.Do.addFreshJP, Array.map, Prod.mk, Bool.true, ite, Eq, Array.isEmpty, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil, Lean.Elab.Term.Do.Code.jmp, List.toArray, Lean.mkIdentFrom]]
[ExceptCpsT.instInhabitedExceptCpsT,[Inhabited.mk, arbitrary]]
[Lean.Meta.Match.MatcherResult.noConfusionType,[]]
[Lean.Meta.mkSizeOfSpecLemmaName,[HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Lsp.LineRange.noConfusionType,[]]
[Lean.findModuleOf?,[Bind.bind, Functor.discard, Lean.getConstInfo, Lean.MonadEnv.getEnv, Unit.unit, Option, Lean.Name, Lean.Environment.getModuleIdxFor?, Pure.pure, Option.none, Option.some, Array.getOp, Lean.Environment.allImportedModuleNames]]
[Lean.Elab.Term.Do.ToTerm.Kind.regular.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Command.nonrec.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.Expr.ReplaceImpl.State.mk.inj,[And.intro]]
[Mathlib.TermUnsafe.mkAuxName,[Lean.MonadQuotation.withFreshMacroScope, Bind.bind, Lean.Elab.Term.getDeclName?, Lean.MonadQuotation.getMainModule, Lean.MonadQuotation.getCurrMacroScope, Pure.pure, Lean.addMacroScope]]
[Tactic.Ring.tacticRing,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Expr.ReplaceImpl.State.noConfusionType,[]]
[imp_not_self,[Iff.intro]]
[Int.ofNat_one,[rfl]]
[Int.mul,[Int, Int.ofNat, HMul.hMul, Int.negOfNat, Nat.succ]]
[Lean.Parser.Term.termUnless.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.withForbidden.formatter, Lean.Parser.termParser.formatter, Lean.Parser.Term.doSeq.formatter]]
[Nat.mod_eq_zero_of_dvd,[Exists.elim, Eq.mpr, Eq.refl, Eq, HMod.hMod, OfNat.ofNat, HMul.hMul, Nat.mul_mod_right, rfl]]
[Lean.Elab.Info.fmtHover?,[Lean.Elab.ContextInfo.runMetaM, Lean.Elab.Info.lctx, Bind.bind, MonadExcept.tryCatch, Option.none, Lean.Meta.MetaM, MProd, PUnit, Array, Std.Format, Pure.pure, PUnit.unit, MProd.mk, Unit.unit, MProd.fst, Lean.Elab.Info.docString?, Option, Lean.Elab.Info.fmtHover?.fmtTerm?, Lean.Elab.Info.fmtHover?.isAtomicFormat]]
[Int.zero_add,[Int.add_zero, Int.add_comm, OfNat.ofNat]]
[Lean.Meta.withMVarContext,[Lean.Meta.mapMetaM, Bind.bind, Lean.Meta.getMVarDecl, Lean.Meta.getLocalInstances, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth, ite, Eq, BEq.beq, Bool.true, Lean.Meta.resettingSynthInstanceCache, Lean.MetavarDecl.lctx, Lean.MetavarDecl.localInstances]]
[Lean.Server.Completion.HoverInfo.after.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[GroupWithZero.mul_zero,[]]
[Lean.Widget.Lean.Widget.InfoPopup.instFromJsonRpcEncodingPacket,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, Lean.Widget.TaggedText, String, Pure.pure]]
[Lean.Parser.Term.funBinder.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.funStrictImplicitBinder.formatter, Lean.Parser.Term.funImplicitBinder.formatter, Lean.Parser.Term.instBinder.formatter, Lean.Parser.Term.funSimpleBinder.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec]]
[Subarray.foldrM,[Array.foldrM, Subarray.as, Subarray.stop, Subarray.start]]
[Lean.Lsp.instToJsonCompletionParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.CompletionParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position]]
[Lean.OpaqueVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.OpaqueVal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.SimpLemma.getName,[Unit.unit, Lean.Name, Lean.Meta.SimpLemma.name?, Lean.Name.mkSimple]]
[Lean.Parser.leadingNode.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.PrettyPrinter.Formatter.node.formatter, Lean.PrettyPrinter.Formatter.setLhsPrec.formatter]]
[List.ne_of_not_mem_cons,[absurd, Or.inl]]
[List.mem_join_of_mem,[Iff.mpr, List.mem_join, Exists.intro, And.intro]]
[Nat.decidable_dvd,[decidable_of_decidable_of_iff, inferInstance, Nat.decidable_dvd.proof_1]]
[Function.has_left_inverse,[Exists, Function.left_inverse]]
[Std.HashMapImp.forM,[Std.HashMapImp.forBucketsM, Std.HashMapImp.buckets]]
[Lean.JsonNumber.exponent,[]]
[Lean.Json.Parser.natNonZero,[Bind.bind, Lean.Json.Parser.lookahead, And, LE.le, Char.ofNat, Lean.Json.Parser.natCore, OfNat.ofNat, Lean.Parsec, Nat, Pure.pure]]
[Lean.Server.FileWorker.handleDefinition,[Bind.bind, MonadReader.read, Lean.Server.RequestM.readDoc, Lean.Server.RequestM.withWaitFindSnap, Decidable.decide, GT.gt, Lean.Server.Snapshots.Snapshot.endPos, Pure.pure, List.toArray, List.nil, Option.none, Lean.Server.RequestM, Array, Lean.Lsp.LocationLink, Lean.Elab.InfoTree.hoverableInfoAt?, Lean.Server.Snapshots.Snapshot.infoTree, Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.Info.ofCompletionInfo, ite, Eq, BEq.beq, Lean.Server.FileWorker.GoToKind.type, Bool.true, liftM, Lean.Elab.ContextInfo.runMetaM, Lean.Elab.Info.lctx, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Lean.Expr.getAppFn, PUnit.unit]]
[Lean.githash,[Lean.getGithash, Unit.unit]]
[Lean.Compiler.hasInlineAttribute,[Lean.Compiler.InlineAttributeKind.inline]]
[List.disjoint_of_subset_right,[]]
[Int.ofNat_eq_ofNat_iff,[Iff.intro, Int.ofNat.inj, congr_arg, Int.ofNat]]
[instAddFloat,[Add.mk, Float.add]]
[Lean.Elab.Tactic.tacticToDischarge,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, getThe, Lean.Elab.Term.State, liftM, IO.mkRef, readThe, Lean.Elab.Term.Context, Prod.mk]]
[Lean.evalPrec,[Lean.Macro.withIncRecDepth, Bind.bind, Lean.expandMacros, cond, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Option.getD, Lean.Syntax.isNatLit?, OfNat.ofNat, Lean.Macro.throwErrorAt]]
[unexpandListToArray,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, Unit.unit]]
[Std.PersistentHashMap.getCollisionNodeSize.proof_1,[]]
[List.length_insert_of_mem,[Eq.mpr, Eq.refl, Eq, List.length, List.insert, List.insert_of_mem, rfl]]
[decidable_eq_of_bool_pred.proof_1,[absurd, Eq.mp, Eq.refl, Not, Eq, Bool.true]]
[Lean.ConstantInfo.axiomInfo.injEq,[Eq.propIntro, Eq.refl, Lean.ConstantInfo.axiomInfo, Eq.symm, eq_of_heq, HEq.refl]]
[«term‹_›»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Tactic.injectionsAndClear,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Parser.Command.optionValue,[HOrElse.hOrElse, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.strLit, Lean.Parser.numLit]]
[List.Perm_comm,[Iff.intro, List.Perm.symm]]
[Lean.Name.isInternal,[Lean.Name.anonymous, Bool, or, BEq.beq, String.get, OfNat.ofNat, Char.ofNat, PProd.fst, Bool.false]]
[Lean.Elab.getRefPosition,[Bind.bind, Lean.MonadFileMap.getFileMap, Lean.Elab.getRefPos, Pure.pure, Lean.FileMap.toPosition]]
[Lean.Parser.Term.noImplicitLambda.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec]]
[Lean.AttributeExtensionState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.AttributeExtensionState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.getPPPiBinderTypes,[Lean.KVMap.get, Lean.Option.name, Lean.pp.piBinderTypes, Lean.Option.defValue]]
[Lean.Parser.Term.completion,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk.inj,[And.intro]]
[CoeTC.coe,[]]
[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.mk.inj,[And.intro]]
[Lean.Parser.unicodeSymbol,[Lean.Parser.tokenWithAntiquot, Lean.Parser.unicodeSymbolNoAntiquot]]
[Lean.Lsp.WorkDoneProgressBegin.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.FileWorker.RpcSession.nextRef,[]]
[Lean.Level.addOffsetAux,[Lean.Level, PProd.fst, Lean.mkLevelSucc]]
[Lean.Lsp.RpcReleaseParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.RpcConnectParams.noConfusionType,[]]
[Lean.Elab.Term.instToStringNamedArg,[ToString.mk, HAppend.hAppend, ToString.toString, Lean.Elab.Term.NamedArg.name, Lean.Elab.Term.NamedArg.val]]
[Lean.PrettyPrinter.Formatter.instMonadTraverserFormatterM,[Lean.Syntax.MonadTraverser.mk, MonadState.mk, Functor.map, Lean.PrettyPrinter.Formatter.State.stxTrav, MonadState.get, modify, Lean.PrettyPrinter.Formatter.State.mk, Lean.PrettyPrinter.Formatter.State.leadWord, Lean.PrettyPrinter.Formatter.State.stack, MonadState.modifyGet, Prod, Lean.PrettyPrinter.Formatter.State, Prod.mk]]
[Lean.Lsp.InitializationOptions.mk.inj,[]]
[Nat.isValidChar,[Or, LT.lt, OfNat.ofNat, And]]
[Lean.Elab.Structural.addSmartUnfoldingDefAux,[Bind.bind, Lean.Elab.PreDefinition.value, Pure.pure, Lean.Elab.PreDefinition.mk, Lean.Elab.PreDefinition.ref, Lean.Elab.PreDefinition.kind, Lean.Elab.PreDefinition.levelParams, Lean.Elab.Modifiers.mk, Lean.Meta.mkSmartUnfoldingNameFor, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.type, Lean.Elab.Structural.addSmartUnfoldingDefAux.visit]]
[Lean.evalPrio,[Lean.Macro.withIncRecDepth, Bind.bind, Lean.expandMacros, cond, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Option.getD, Lean.Syntax.isNatLit?, OfNat.ofNat, Lean.Macro.throwErrorAt]]
[FloatArray.mk.injEq,[Eq.propIntro, Eq.refl, FloatArray.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.optDeriving,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.optional, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.notSymbol, Lean.Parser.Command.derivingClasses]]
[Lean.Elab.withoutModifyingStateWithInfoAndMessages,[controlAt, Lean.Elab.Term.TermElabM, Bind.bind, Lean.MonadBacktrack.saveState, tryFinally, MonadState.get, Lean.MonadBacktrack.restoreState]]
[Lean.ModuleData.constants,[]]
[modifyGetThe,[MonadStateOf.modifyGet]]
[Lean.Server.FileWorker.WorkerState.rpcSessions,[]]
[Lean.Elab.Command.StructFieldKind.noConfusionType,[noConfusionTypeEnum, Lean.Elab.Command.StructFieldKind.toCtorIdx]]
[Lean.Server.WithRpcRef.decodeUnsafeAs,[Bind.bind, Lean.Server.MonadRpcSession.rpcGetRef, Unit.unit, ExceptT, String, Lean.Server.WithRpcRef, MonadExcept.throw, HAppend.hAppend, ToString.toString, ite, Eq, bne, Bool.true, Pure.pure, PUnit.unit]]
[Lean.Lsp.instFileSourceTextDocumentPositionParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.TextDocumentPositionParams.textDocument]]
[Lean.Meta.Simp.Methods.noConfusionType,[]]
[Lean.Parsec.bind,[Lean.Parsec.ParseResult, Lean.Parsec.ParseResult.error]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withAppArg,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.PrettyPrinter.Delaborator.SubExpr.descend, Lean.Expr.appArg!, OfNat.ofNat]]
[Std.mkHashMapImp,[]]
[String.toFormat,[Std.Format.joinSep, String.splitOn, Std.Format.line]]
[Int.ofNat_sub,[]]
[Lean.Elab.Tactic.Location.noConfusionType,[]]
[Lean.Parser.registerParserCategory,[Bind.bind, IO.ofExcept, Lean.Parser.addParserCategory, Lean.registerAttributeOfBuilder, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.DataValue.ofName, List.nil]]
[Lean.Elab.Tactic.evalDecide,[Lean.Elab.Tactic.closeMainGoalUsing, Bind.bind, liftM, Lean.Meta.instantiateMVars, ite, Eq, Lean.Expr.hasFVar, Bool.true, Lean.Meta.zetaReduce, Pure.pure, PUnit.unit, Lean.Meta.mkDecide, Lean.Meta.withDefault, Lean.Meta.whnf, Lean.Expr.isConstOf, Lean.Name.mkStr, Lean.Name.anonymous, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr]]
[Std.Format.groupEx,[Std.Format.group, Std.Format.FlattenBehavior.allOrNone]]
[UInt64.ofNatCore,[UInt64.mk, Fin.mk]]
[Lean.Parser.Tactic.fapply,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.Elab.Term.Quotation.commandElab_stx_quot__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser]]
[Lean.Elab.Command.StructFieldInfo.noConfusionType,[]]
[Lean.EnvExtensionInterfaceUnsafe.instInhabitedExt,[Inhabited.mk, Lean.EnvExtensionInterfaceUnsafe.Ext.mk, arbitrary]]
[Lean.Elab.Info.lctx,[Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofCompletionInfo, Lean.LocalContext, Lean.Elab.TermInfo.lctx, Lean.Elab.FieldInfo.lctx, Lean.LocalContext.empty]]
[Lean.EnvExtensionInterfaceUnsafe.getState,[dite, LT.lt, Lean.EnvExtensionInterfaceUnsafe.Ext.idx, Array.size, Lean.Environment.extensions, unsafeCast, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.DataValue.getBoolEx,[Lean.DataValue.ofString, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Bool, Bool.false]]
[Lean.Lsp.DocumentHighlight.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[String.utf16PosToCodepointPos,[String.utf16PosToCodepointPosFrom, OfNat.ofNat]]
[Lean.Elab.processHeader,[MonadExcept.tryCatch, Bind.bind, Lean.importModules, Lean.Elab.headerToImports, Pure.pure, Prod.mk, Lean.mkEmptyEnvironment, OfNat.ofNat, Lean.MessageLog.add, Lean.Message.mk, Lean.Parser.InputContext.fileName, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, ToString.toString]]
[Lean.mkErrorStringWithPos,[HAppend.hAppend, ToString.toString, Lean.Position.line, Lean.Position.column]]
[Subtype.equivalence,[Equivalence.mk, Subtype.refl, Subtype.symm, Subtype.trans]]
[if_congr,[if_ctx_congr]]
[IO.FS.Stream.writeNotification,[IO.FS.Stream.writeMessage, Lean.JsonRpc.Message.notification, Lean.JsonRpc.Notification.method, Except.toOption, Lean.Json.toStructured?, Lean.JsonRpc.Notification.param]]
[Lean.Compiler.foldUIntAdd,[Lean.Compiler.foldBinUInt, Add.add]]
[Lean.PrettyPrinter.Delaborator.delabAppExplicit,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPExplicit, Bind.bind, Lean.PrettyPrinter.Delaborator.getParamKinds, Lean.PrettyPrinter.Delaborator.SubExpr.withAppFnArgs, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, ite, Eq, Lean.Expr.isConst, Bool.true, Lean.PrettyPrinter.Delaborator.delabConst, Lean.PrettyPrinter.Delaborator.delab, Lean.PrettyPrinter.Delaborator.DelabM, Prod, Lean.Syntax, List, Lean.PrettyPrinter.Delaborator.ParamKind, Array, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPAnalysisHole, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, BEq.beq, Lean.getPPInstances, Lean.Syntax.mkApp]]
[instToStringSubstring,[ToString.mk, Substring.toString]]
[Lean.SCC.M,[StateM, Lean.SCC.State]]
[Lean.instQuoteBool,[Lean.Quote.mk, Unit.unit, Lean.Syntax, Lean.mkCIdent, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.List.toSMap,[List.foldl, Lean.SMap, Lean.SMap.insert, Lean.SMap.mk]]
[Lean.Meta.isDefEqNative,[Bind.bind, Lean.Meta.reduceNative?, Unit.unit, Lean.Meta.MetaM, Lean.LBool, Pure.pure, Lean.LBool.undef]]
[Lean.Elab.Command.FieldMap,[Lean.NameMap, Lean.Expr]]
[Lean.CollectMVars.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.CollectMVars.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Widget.MsgEmbed.expr.inj,[]]
[le_imp_le_of_lt_imp_lt,[le_of_not_lt, not_le_of_gt]]
[instReprTuple,[ReprTuple.mk, List.cons, repr]]
[Std.HashSetBucket,[Subtype, GT.gt, Array.size, OfNat.ofNat]]
[Lean.Parser.andthen,[Lean.Parser.Parser.mk, Lean.Parser.andthenInfo, Lean.Parser.Parser.info, Lean.Parser.andthenFn, Lean.Parser.Parser.fn]]
[Lean.Meta.Match.Extension.State.switch,[Lean.Meta.Match.Extension.State.mk, Lean.SMap.switch, Lean.Meta.Match.Extension.State.map]]
[instMonadControlStateRefT',[inferInstanceAs, MonadControl, ReaderT, ST.Ref]]
[Equiv.symm_apply_apply,[Equiv.leftInv]]
[Lean.Parser.Tactic.pushNeg,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.Parser.charLit.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.charLitKind, Bool.true, Lean.PrettyPrinter.Formatter.charLitNoAntiquot.formatter]]
[Int.negSucc_ofNat_coe,[rfl]]
[Lean.DataValue.ofInt.injEq,[Eq.propIntro, Eq.refl, Lean.DataValue.ofInt, Eq.symm, eq_of_heq, HEq.refl]]
[eq_self,[propext, Iff.intro, trivial, rfl]]
[Lean.Parser.Command.deriving,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.derivingClasses, Lean.Parser.sepBy1, Lean.Parser.ident, Bool.false]]
[Lean.KVMap.setNat,[Lean.KVMap.insert, Lean.DataValue.ofNat]]
[Lean.Lsp.instToJsonPublishDiagnosticsParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.PublishDiagnosticsParams.uri, List.nil, Lean.Json.opt, Lean.Lsp.PublishDiagnosticsParams.version?, Lean.Lsp.PublishDiagnosticsParams.diagnostics]]
[Lean.Lsp.DefinitionParams.mk.inj,[]]
[Std.PersistentHashMap.Entry.noConfusionType,[]]
[Lean.Meta.SimpLemma.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.KernelException.funExpected.inj,[And.intro]]
[Lean.Elab.Tactic.AuxMatchTermState.nextIdx,[]]
[Lean.IR.Decl.maxIndex,[Lean.IR.MaxIndex.collectDecl, OfNat.ofNat]]
[Std.PersistentHashMap.findD,[Option.getD, Std.PersistentHashMap.find?]]
[Lean.Compiler.foldUIntMul,[Lean.Compiler.foldBinUInt, Mul.mul]]
[Mathlib.Tactic.Ext.«termExtIffProof%»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[IO.setAccessRights,[IO.Prim.setAccessRights, IO.FileRight.flags]]
[Lean.MetavarContext.MkBinding.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.dependsOnPred,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.findExprDependsOn]]
[Lean.Elab.Term.elabNoMatch,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Term.isLocalIdent?, Option.none, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Elab.Term.tryPostponeIfNoneOrMVar, Unit.unit, Pure.pure, liftM, Lean.Meta.mkFreshTypeMVar, Lean.MetavarKind.natural, not, Lean.Syntax.isNone, BEq.beq, Option.some, Lean.throwError, Lean.ToMessageData.toMessageData, PUnit.unit, List.toArray, List.cons, List.nil, Lean.mkNullNode, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.Elab.Term.withMacroExpansion, Lean.Elab.Term.elabTerm, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Xml.Parser.ExternalID,[HOrElse.hOrElse, SeqRight.seqRight, Lean.Parsec.skipString, Lean.Xml.Parser.S, Lean.Xml.Parser.SystemLiteral, Pure.pure, Unit.unit, Lean.Xml.Parser.PubidLiteral]]
[Lean.Elab.Command.expandNoKindMacroRulesAux,[Bind.bind, Lean.Elab.Command.inferMacroRulesAltKind, Array.getOp, OfNat.ofNat, ite, Eq, and, Lean.Name.isStr, BEq.beq, Lean.Name.getString!, Bool.true, Pure.pure, PUnit.unit]]
[Set.instLawfulFunctorSet,[Set.instLawfulFunctorSet.proof_1]]
[Lean.Parser.Command.example.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declSig.parenthesizer, Lean.Parser.Command.declVal.parenthesizer]]
[instHashable,[Hashable.mk, OfNat.ofNat]]
[Lean.Core.instMonadOptionsCoreM,[Lean.MonadOptions.mk, Bind.bind, MonadReader.read, Pure.pure, Lean.Core.Context.options]]
[Lean.Meta.mkDecide,[Lean.Meta.mkAppOptM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Option.some, Option.none, List.nil]]
[Lean.Elab.Tactic.evalRename,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.withoutModifyingStateWithInfoAndMessages, Lean.Meta.withNewMCtxDepth, Lean.Elab.Tactic.elabTerm, Option.none, Lean.MonadLCtx.getLCtx, Lean.LocalContext.findDeclRevM?, liftM, Lean.Meta.isDefEq, Lean.LocalDecl.type, Pure.pure, Option.some, Lean.LocalDecl.fvarId, Unit.unit, Lean.Elab.Tactic.TacticM, Lean.FVarId, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Meta.getLocalInstances, Lean.Elab.Tactic.getMainTarget, Lean.Elab.Tactic.getMainTag, Lean.Meta.mkFreshExprMVarAt, Lean.MetavarKind.syntheticOpaque, OfNat.ofNat, Lean.Elab.Tactic.getMainGoal, Lean.Meta.assignExprMVar, Lean.Elab.Tactic.replaceMainGoal, List.cons, Lean.Expr.mvarId!, List.nil, Lean.Elab.throwUnsupportedSyntax]]
[ByteArray.extract,[ByteArray.copySlice, ByteArray.empty, OfNat.ofNat, HSub.hSub, Bool.true]]
[Lean.IR.UnreachableBranches.InterpState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Export.State.stk,[]]
[Lean.Meta.AbstractMVars.mkFreshFVarId,[Bind.bind, Lean.Meta.AbstractMVars.mkFreshId, Pure.pure, Lean.FVarId.mk]]
[Fin.size_positive,[LT.lt, OfNat.ofNat, Nat.eq_or_lt_of_le, Nat.zero_le, Eq.symm, Nat.lt_trans]]
[Subtype.coind,[Subtype.mk]]
[Lean.Widget.goalToInteractive,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.findDecl?, Option.none, Lean.Meta.MetaM, Lean.Widget.InteractiveGoal, Lean.MonadOptions.getOptions, Lean.Meta.withLCtx, Lean.MetavarDecl.localInstances, Lean.Meta.ToHide.collect, Lean.MetavarDecl.type, Lean.LocalContext.foldlM, Prod, Array, Lean.Name, Option, Lean.Expr, Lean.Widget.InteractiveHypothesis, ite, Eq, or, and, not, Lean.LocalDecl.isAuxDecl, Std.RBTree.contains, Lean.LocalDecl.fvarId, Bool.true, Prod.mk, List.toArray, List.nil, OfNat.ofNat, Lean.Meta.instantiateMVars, Lean.Widget.exprToInteractive, Lean.Widget.InteractiveGoal.mk, Lean.Widget.goalToInteractive.ppVars, Lean.Widget.goalToInteractive.pushPending, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MVarId.name]]
[Lean.Parser.Term.pipeProj.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.minPrec, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.fieldIdx.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.Term.argument.parenthesizer]]
[Lean.Json.CompressWorkItem.objectField.inj,[And.intro]]
[unexpandEqNDRec,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[Lean.IR.LogEntry.step.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.mod_zero,[]]
[Lean.Parser.Tactic.clear_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.MetavarContext.isLevelAssignable,[Option.none, Bool, Std.PersistentHashMap.find?, Lean.MetavarContext.lDepth, BEq.beq, Lean.MetavarContext.depth, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Meta.assignLevelMVar,[Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.assignLevel]]
[FloatArray.forInUnsafe,[OfNat.ofNat, FloatArray.forInUnsafe.loop]]
[Lean.Elab.Deriving.Ord.mkMatch.mkAlts,[Bind.bind, ForIn.forIn, Lean.getConstInfoCtor, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, liftM, Lean.Core.betaReduce, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, PUnit.unit, ForInStep.yield, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, MProd.mk, Lean.Elab.Term.TermElabM, Array, Lean.Syntax, Lean.Meta.inferType, Lean.Meta.isProp, ite, Eq, or, Lean.Expr.containsFVar, Lean.Expr.fvarId!, Bool.true, Lean.Core.mkFreshUserName, Lean.mkIdent, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Array.pop]]
[Lean.Parser.Term.doLetRec.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.Term.letRecDecls.parenthesizer]]
[Lean.Parser.Term.doMatchAlts.parenthesizer,[Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer]]
[Lean.Meta.Match.Alt.replaceFVarId,[Lean.Meta.Match.Alt.mk, Lean.Meta.Match.Alt.ref, Lean.Meta.Match.Alt.idx, Lean.Expr.replaceFVarId, Lean.Meta.Match.Alt.rhs, List.map, Lean.replaceFVarIdAtLocalDecl, Lean.Meta.Match.Pattern.replaceFVarId, Lean.Meta.Match.Alt.patterns]]
[Lean.addAliasEntry,[Unit.unit, Lean.AliasState, Lean.SMap.find?, Prod.fst, Lean.SMap.insert, List.cons, Prod.snd, List.nil, ite, Eq, List.elem, Bool.true]]
[Nat.add_eq,[rfl]]
[Lean.Meta.Match.instInhabitedMatchEqnsExtState,[Inhabited.mk, Lean.Meta.Match.MatchEqnsExtState.mk, arbitrary]]
[UInt64.zero_def,[rfl]]
[ByteSlice.len,[]]
[Lean.IR.ExplicitRC.getJPParams,[Unit.unit, Array, Lean.IR.Param, Lean.IR.LocalContext.getJPParams, Lean.IR.ExplicitRC.Context.localCtx, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Meta.isLevelDefEqAuxImpl,[Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Meta.MetaM, Bool, Lean.Meta.isLevelDefEqAux, ite, Eq, BEq.beq, Lean.Level.getLevelOffset, Bool.true, Pure.pure, Lean.Level.getOffset, Bind.bind, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, PUnit.unit]]
[Nat.exists_coprime,[Exists.intro, HDiv.hDiv, Nat.gcd, And.intro, Nat.coprime_div_gcd_div_gcd, Eq.symm, Nat.div_mul_cancel, Nat.gcd_dvd_left, Nat.gcd_dvd_right]]
[instDecidableIff.proof_4,[Iff.intro, absurd]]
[Lean.Elab.Term.StructInst.DefaultFields.State.noConfusionType,[]]
[Lean.MessageData.ofLevel.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Mathlib.Tactic.Lint.Linter.noConfusionType,[]]
[Lean.Lsp.SymbolKind.key.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Subtype.restrict_def,[rfl]]
[Lean.Parser.Command.openOnly.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer]]
[Lean.CollectFVars.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.CollectFVars.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[USize.sub,[USize.mk, HSub.hSub, USize.val]]
[Lean.instInhabitedParametricAttribute,[Inhabited.mk, Lean.ParametricAttribute.mk, arbitrary]]
[Std.Format.nil.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Std.Format.paren,[Std.Format.bracket]]
[Lean.mkNoConfusionEnum,[Bind.bind, Lean.MonadEnv.getEnv, ite, Eq, Lean.Environment.contains, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.mkNoConfusionCore, Lean.mkNoConfusionEnum.mkToCtorIdx, Lean.mkNoConfusionEnum.mkNoConfusionType, Lean.mkNoConfusionEnum.mkNoConfusion]]
[Std.Format.pretty,[Prod.snd]]
[not_not_not,[Iff.intro, mt, not_not_intro]]
[Lean.Rat.div,[Lean.Rat.mul, Lean.Rat.inv]]
[Tactic.Ring.Cache.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Tactic.Ring.Cache.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.EmitC.emitCtorScalarSize,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Lean.IR.EmitC.emit, Bind.bind]]
[Lean.Elab.TacticInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.TacticInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.DocumentSymbolParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.TextDocumentContentChangeEvent.noConfusionType,[]]
[UInt32.decEq,[Decidable, Eq, dite, Decidable.isTrue, UInt32.decEq.proof_1, Decidable.isFalse, UInt32.decEq.proof_2]]
[instSubsingletonForall,[instSubsingletonForall.proof_1]]
[Lean.Elab.Term.Do.ToCodeBlock.expandLiftMethod,[ite, Eq, not, Bool.true, Pure.pure, Prod.mk, List.nil, Bind.bind, StateT.run, Bool.false, Lean.Elab.Term.Do.ToCodeBlock.M, Prod, List, Lean.Syntax]]
[List.decidableMem,[Unit.unit, Decidable, Mem.mem, Decidable.isFalse, not_false, dite, Eq, Decidable.isTrue, List.decidableMem.proof_1, List.cons, PProd.fst, List.decidableMem.proof_2, List.decidableMem.proof_3]]
[add_neg_cancel_right,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, add_assoc, add_right_neg, OfNat.ofNat, add_zero, rfl]]
[Lean.Parser.Term.let_delayed,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, Lean.Parser.symbol, Lean.Parser.Term.letDecl, Lean.Parser.Term.optSemicolon, Lean.Parser.termParser, OfNat.ofNat]]
[imp_true_iff,[iff_true_intro, trivial]]
[Lean.DeclarationRange.endPos,[]]
[Prod.map,[Prod, Prod.mk]]
[Lean.Parser.Term.set_option.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.Command.optionValue.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Lean.Parser.Command.aliasLR,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.binderIdent]]
[Std.RBMap.instForInRBMapProd,[ForIn.mk, Std.RBMap.forIn]]
[Lean.Parser.Term.char.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.charLit.parenthesizer]]
[Lean.Elab.Tactic.done,[Bind.bind, Lean.Elab.Tactic.getUnsolvedGoals, ite, Eq, List.isEmpty, Bool.true, Pure.pure, PUnit.unit, liftM, Lean.Elab.Term.reportUnsolvedGoals, Lean.Elab.throwAbortTactic]]
[instDecidableXor.proof_2,[Or.inl, And.intro]]
[Lean.InductiveVal.numCtors,[List.length, Lean.InductiveVal.ctors]]
[Lean.Expr.FoldConstsImpl.visited.proof_2,[lcProof]]
[instModUSize,[Mod.mk, USize.mod]]
[Lean.Parser.Term.trailing_parser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.optExprPrecedence.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[String.leftpad,[String.mk, List.leftpad, String.data]]
[List.append_eq_nil,[of_eq_true, Eq.trans, congr, congrArg, Iff, congrFun, Eq, List.nil_append, List.nil, And, eq_self, true_and, iff_self, Eq.symm, List.cons_append, eq_false', false_and, eq_true_of_decide, Eq.refl, Bool.true]]
[Quot.exists_rep,[Quot.inductionOn, Exists.intro, rfl]]
[Lean.MonadRef.noConfusionType,[]]
[Lean.TransformStep.visit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.Delaborator.State.noConfusionType,[]]
[and,[Unit.unit, Bool, Bool.false]]
[Prod.rprod,[WellFoundedRelation.mk, Prod.RProd, WellFoundedRelation.rel, Prod.rprod.proof_1]]
[Lean.Meta.MatcherApp.mk.inj,[And.intro]]
[Lean.Parser.Command.variable,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.ppSpace, Lean.Parser.Term.bracketedBinder, Bool.false]]
[Lean.Meta.MatcherApp.noConfusionType,[]]
[Lean.instQuoteNat,[Lean.Quote.mk, Lean.Syntax.mkNumLit, ToString.toString, Lean.SourceInfo.none]]
[Lean.IR.AltCore.mmodifyBody,[Lean.IR.Alt, Functor.map, Lean.IR.Alt.ctor, Lean.IR.Alt.default]]
[Lean.SimplePersistentEnvExtensionDescr.addImportedFn,[]]
[Lean.letFunAnnotation?,[Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous]]
[UInt64.toUInt32,[Nat.toUInt32, UInt64.toNat]]
[Lean.Meta.Match.MatcherResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.WithRpcRef.noConfusionType,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.checkpointDefEq,[Lean.Meta.checkpointDefEq, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isDefEqAssigning, Bool.false]]
[Lean.Elab.Info.ofTermInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Command.Context.currMacroScope,[]]
[Tactic.Ring.horner_horner,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HAdd.hAdd, HMul.hMul, add_zero, HPow.hPow, mul_assoc, Eq.symm, pow_add, eq_self]]
[Std.ShareCommonM.run,[Std.ShareCommonT.run]]
[EStateM.modifyGet,[EStateM.Result, EStateM.Result.ok]]
[Lean.Elab.Command.StructFieldView.value?,[]]
[Lean.ScopedEnvExtension.addLocalEntry,[Unit.unit, Lean.Environment, Lean.ScopedEnvExtension.StateStack.stateStack, Lean.PersistentEnvExtension.setState, Lean.ScopedEnvExtension.ext, Lean.ScopedEnvExtension.StateStack.mk, List.cons, Lean.ScopedEnvExtension.StateStack.scopedEntries, Lean.ScopedEnvExtension.StateStack.newEntries]]
[Lean.IR.ExplicitBoxing.getScrutineeType,[Unit.unit, Lean.IR.IRType, Lean.IR.IRType.object, ite, LT.lt, OfNat.ofNat, Lean.IR.IRType.uint8, Lean.IR.IRType.uint16, Lean.IR.IRType.uint32]]
[String.takeRightWhile,[Substring.toString, Substring.takeRightWhile, String.toSubstring]]
[Nat.add,[Nat, Nat.succ, PProd.fst]]
[IO.Error.alreadyExists.inj,[And.intro]]
[Lean.Lsp.DocumentFilter.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.openRenamingItem.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.unicodeSymbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer]]
[Lean.Parser.checkNoImmediateColon,[Lean.Parser.Parser.mk, ite, Eq, Lean.Parser.checkTailNoWs, Bool.true, String.atEnd, BEq.beq, Char.ofNat, Lean.Parser.ParserState.mkUnexpectedError, List.nil]]
[Function.left_inverse_of_surjective_of_right_inverse,[Eq, Eq.mpr, Eq.refl, Eq.symm, rfl]]
[Lean.Compiler.foldNatMul,[Lean.Compiler.foldNatBinOp, Mul.mul]]
[Lean.Parser.Tactic.eraseAuxDiscrs.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.maxPrec, Lean.Parser.symbol.formatter]]
[Lean.Parser.Tactic.acMono,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[instForIn,[ForIn.mk, Stream.forIn]]
[Nat.gcd_one_left,[Eq.mpr, Eq.refl, Eq, Nat.gcd, OfNat.ofNat, Nat.gcd_succ, HMod.hMod, Nat.succ, Nat.mod_one, rfl]]
[Lean.Core.State.traceState,[]]
[Lean.JsonRpc.instCoeResponseErrorMessage,[Coe.mk, Lean.JsonRpc.Message.responseError, Lean.JsonRpc.ResponseError.id, Lean.JsonRpc.ResponseError.code, Lean.JsonRpc.ResponseError.message, Option.map, Lean.ToJson.toJson, Lean.JsonRpc.ResponseError.data?]]
[Lean.Parser.Command.catBehaviorBoth.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false]]
[Lean.Meta.FunInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.FunInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.Borrow.BorrowInfCtx.noConfusionType,[]]
[Lean.KeyedDeclsAttribute.Def.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KeyedDeclsAttribute.Def.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.AbstractMVars.State.nextParamIdx,[]]
[not_and_not_right,[Decidable.not_and_not_right]]
[Lean.Elab.Command.CollectAxioms.State.axioms,[]]
[Monad.noConfusionType,[]]
[Lean.CollectMVars.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.RequestError.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Syntax.Traverser.noConfusionType,[]]
[Lean.IR.Checker.CheckerContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Message.fileName,[]]
[Nat.add_lt_add_right,[Nat.add_lt_add_left, Nat.add_comm]]
[Lean.Elab.Term.CollectPatternVars.main,[Bind.bind, Array.mapM, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Elab.Term.MatchAltView.patterns, Lean.Elab.Term.MatchAltView.mk, Lean.Elab.Term.MatchAltView.ref, Lean.Elab.Term.MatchAltView.rhs]]
[Lean.ParserCompiler.CombinatorAttribute.getDeclFor?,[Lean.NameMap.find?, Lean.SimplePersistentEnvExtension.getState, Lean.ParserCompiler.CombinatorAttribute.ext]]
[Lean.Meta.collectMVarsAtDecl,[Lean.Declaration.forExprM, Lean.Meta.collectMVars]]
[Lean.Elab.InfoTree.hoverableInfoAt?,[Id.run, Option.none, Option.some, Prod.mk, Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.Info.ofCompletionInfo, Id, Option, Prod, Lean.Elab.ContextInfo, Lean.Elab.Info, ite, Eq, Lean.Expr.isSyntheticSorry, Lean.Elab.TermInfo.expr, Bool.true, Pure.pure, Bind.bind, PUnit.unit]]
[Lean.Parser.Tactic.Conv.nestedConv,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.Parser.Tactic.Conv.convSeqBracketed]]
[Lean.ConstantInfo.thmInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.lookaheadFn,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Parser.ParserState.restore]]
[Std.HashSetImp.foldBucketsM,[Array.foldlM, List.foldlM, Subtype.val, OfNat.ofNat, Array.size]]
[Ring.noConfusionType,[]]
[Lean.MessageData.nil,[Lean.MessageData.ofFormat, Std.Format.nil]]
[Lean.Elab.Tactic.liftMetaTactic1,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Option.none, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.nil]]
[Lean.monadNameGeneratorLift,[Lean.MonadNameGenerator.mk, liftM, Lean.MonadNameGenerator.getNGen, Lean.MonadNameGenerator.setNGen]]
[Lean.Elab.Term.elabBinRelCore,[Bind.bind, Lean.Elab.Term.resolveId?, Lean.Syntax.getOp, OfNat.ofNat, Bool.false, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.MonadBacktrack.saveState, Lean.Elab.Term.withSynthesize, Lean.Elab.Term.elabTerm, Option.none, Bool.true, ite, Eq, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, liftM, Lean.Meta.inferType, Lean.Elab.Term.ensureHasType, Option.some, Pure.pure, PUnit.unit, MonadExcept.tryCatch, Lean.withRef, Prod.mk, Lean.Elab.Term.SavedState.restore, Lean.throwUnknownConstant, Lean.Syntax.getId, Lean.Elab.Term.elabBinRelCore.toBoolIfNecessary]]
[Lean.MetavarContext.isExprAssigned,[Std.PersistentHashMap.contains, Lean.MetavarContext.eAssignment]]
[Lean.Elab.Term.ContainsPendingMVar.M,[Lean.MonadCacheT, Lean.Expr, Unit, OptionT, Lean.Elab.Term.TermElabM]]
[Std.AssocList.any,[Unit.unit, Bool, Bool.false, or, PProd.fst]]
[Lean.Parser.Tactic.prettyCases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[instShiftLeftUInt64,[ShiftLeft.mk, UInt64.shiftLeft]]
[Lean.Server.FileWorker.Reference.isDeclaration,[]]
[Lean.Meta.FVarSubst.map,[]]
[Lean.getSanitizeNames,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Lean.sanitizeNamesDefault]]
[Lean.KernelException.unknownConstant.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.unknownConstant, Eq.symm, eq_of_heq, HEq.refl]]
[not_imp_self,[Decidable.not_imp_self]]
[Tactic.Ring.evalConstMul,[Tactic.Ring.RingM, Prod, Tactic.Ring.HornerExpr, Lean.Expr, Bind.bind, liftM, Lean.Meta.mkMul, Prod.fst, Lean.Meta.NormNum.eval, Pure.pure, Prod.mk, Tactic.Ring.HornerExpr.const, HMul.hMul, Prod.snd, PProd.fst, PProd.snd, Tactic.Ring.HornerExpr.xadd', Tactic.Ring.mkAppCS, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Tactic.Ring.HornerExpr.e, List.nil]]
[Lean.Elab.Term.ensureNoUnassignedMVars,[Bind.bind, liftM, Lean.Meta.getMVarsAtDecl, Lean.Elab.Term.logUnassignedUsingErrorInfos, Option.none, ite, Eq, Bool.true, Lean.Elab.throwAbortCommand, Pure.pure, PUnit.unit]]
[Lean.Meta.InjectionResultCore.subgoal.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.declVal.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.declValSimple.parenthesizer, Lean.Parser.Command.declValEqns.parenthesizer, Lean.Parser.Command.whereStructInst.parenthesizer]]
[Nat.coprime.dvd_of_dvd_mul_right,[Eq.mp, Eq.refl, Dvd.dvd, HMul.hMul, OfNat.ofNat, Nat.mul_one, Nat.gcd, Nat.coprime.gcd_eq_one, Nat.gcd_mul_left]]
[Lean.CompactedRegion,[USize]]
[Lean.Parser.Term.open.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.openDecl.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withOpenDecl.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Function.left_inverse.eq_right_inverse,[]]
[Lean.Elab.Term.SavedContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.SavedContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Attr.class,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Lean.Environment.contains,[Lean.SMap.contains, Lean.Environment.constants]]
[Lean.Elab.Term.Quotation.Precheck,[Lean.Elab.Term.Quotation.PrecheckM, Unit]]
[Std.Format.nestD,[Std.Format.nest, Int.ofNat, Std.Format.defIndent]]
[Lean.instInhabitedLazyInitExtension,[Inhabited.mk, Lean.LazyInitExtension.mk, arbitrary, Pure.pure]]
[Std.RBMap.any,[Bool, Std.RBNode.any]]
[Lean.Meta.Closure.State.levelParams,[]]
[Lean.Elab.TerminationHints.terminationBy?,[]]
[Lean.Parser.Command.catBehavior.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.catBehaviorBoth.parenthesizer, Lean.Parser.Command.catBehaviorSymbol.parenthesizer]]
[Lean.Json.obj.inj,[]]
[Lean.Parser.ParserExtension.OLeanEntry.category.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.RpcEncoding.rpcDecode,[]]
[Nat.add_le_to_le_sub,[Eq.mpr, Eq.refl, Iff, LE.le, HAdd.hAdd, HSub.hSub, Eq.symm, Nat.add_sub_cancel, propext, Nat.sub_le_sub_right_iff, Iff.rfl]]
[Array.swap.proof_1,[Eq.symm, Array.size_set, Array.get]]
[Lean.Elab.Term.Quotation.HeadCheck.slice.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MonadError.toAddErrorMessageContext,[]]
[Lean.Elab.Deriving.mkDiscrs,[Bind.bind, ForIn.forIn, Lean.Elab.Deriving.mkDiscr, Pure.pure, PUnit.unit, ForInStep.yield, Array.mapM, Lean.Elab.Deriving.Header.targetNames, HAppend.hAppend]]
[Lean.IR.Expr.sproj.inj,[And.intro]]
[Lean.Meta.UnificationHint.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.UnificationHint.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Level.ident.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.ident.formatter]]
[Lean.Elab.Command.expandMutualNamespace,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, Option.some, Lean.MacroM, ForInStep, MProd, Array, Lean.Syntax, Option, Lean.Name, Lean.Elab.Command.expandDeclNamespace?, Pure.pure, PUnit.unit, ForInStep.yield, ite, Eq, BEq.beq, Bool.true, Lean.Macro.throwErrorAt, HAppend.hAppend, ToString.toString, Unit.unit, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Macro.throwUnsupported]]
[Lean.Meta.getErasedInstances,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Meta.Instances.erased, Lean.ScopedEnvExtension.getState, Lean.Meta.instanceExtension]]
[Lean.PrettyPrinter.registerParserCompilers,[Bind.bind, Lean.ParserCompiler.registerParserCompiler, Lean.ParserCompiler.Context.mk, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.parenthesizerAttribute, Lean.PrettyPrinter.combinatorParenthesizerAttribute, Lean.PrettyPrinter.formatterAttribute, Lean.PrettyPrinter.combinatorFormatterAttribute]]
[Lean.Lsp.LineRange.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.MatcherApp.altNumParams,[]]
[Lean.Lsp.RpcCallParams.params,[]]
[FloatSpec.noConfusionType,[]]
[Lean.JsonRpc.instBEqResponse,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Meta.Closure.MkValueTypeClosureResult.levelParams,[]]
[Lean.Elab.Term.MVarErrorInfo.ref,[]]
[Lean.Elab.Term.MutualClosure.ClosureState.newLocalDecls,[]]
[Nat.anyM.loop,[Unit.unit, Bool, Pure.pure, Bool.false, Bind.bind, HSub.hSub, OfNat.ofNat, Bool.true, PProd.fst]]
[Lean.RecursorRule.mk.inj,[And.intro]]
[Lean.ModuleData.imports,[]]
[Lean.Meta.ReduceMatcherResult.notMatcher.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Array.modifyM,[dite, LT.lt, Array.size, Bind.bind, Pure.pure, Array.set, Array.modifyM.proof_1]]
[or_iff_not_imp_left,[Decidable.or_iff_not_imp_left]]
[Std.PersistentArray.push,[ite, Eq, or, Decidable.decide, LT.lt, Array.size, Std.PersistentArray.tail, USize.toNat, Std.PersistentArray.branching, GE.ge, Std.PersistentArray.size, Std.PersistentArray.tooBig, Bool.true, Std.PersistentArray.mkNewTail]]
[Lean.Parser.Tactic.reassoc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const]]
[Lean.Elab.Term.LetRecView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LetRecView.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.elabProj,[Bind.bind, List.nil, Bool.false, List.toArray, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.Elab.Term.TermElabM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Pure.pure, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError]]
[Lean.Elab.Tactic.tryTactic,[MonadExcept.tryCatch, Bind.bind, Functor.discard, Pure.pure, Bool.true, Bool.false]]
[Lean.Parser.many1Indent.formatter,[Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.many1.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkColGe.formatter]]
[UInt32.eq_of_val_eq,[Eq, congrArg, UInt32.mk]]
[Lean.Elab.Term.MutualClosure.main,[Bind.bind, Lean.MonadMCtx.getMCtx, liftM, Lean.Meta.resetZetaFVarIds, Lean.Meta.withTrackingZeta, List.forM, Lean.Meta.withLCtx, Lean.Elab.Term.LetRecToLift.lctx, Lean.Elab.Term.LetRecToLift.localInstances, Lean.Meta.check, Lean.Elab.Term.LetRecToLift.type, Lean.Elab.Term.LetRecToLift.val, List.mapM, Lean.Meta.lambdaTelescope, Lean.Meta.instantiateForall, Lean.MonadLCtx.getLCtx, StateRefT'.run, Lean.Elab.Term.MutualClosure.ClosureState.mk, Lean.Elab.Term.TermElabM, Lean.Elab.Term.MutualClosure.ClosureState, Pure.pure, Array.reverse, Lean.Elab.Term.MutualClosure.ClosureState.newLocalDecls, Lean.Elab.Term.MutualClosure.ClosureState.localDecls, Lean.Elab.Term.MutualClosure.ClosureState.newLetDecls, Lean.Elab.Term.MutualClosure.ClosureState.exprArgs, Array.map, Lean.LocalContext.get!, Lean.Expr.fvarId!, Lean.Meta.assignExprMVar, Lean.Elab.Term.LetRecToLift.mvarId, Lean.Elab.Term.MutualClosure.LetRecClosure.mk, Lean.Elab.Term.LetRecToLift.ref, Lean.Elab.Term.LetRecToLift.mk, Lean.Elab.Term.LetRecToLift.fvarId, Lean.Elab.Term.LetRecToLift.attrs, Lean.Elab.Term.LetRecToLift.shortDeclName, Lean.Elab.Term.LetRecToLift.declName, Option.get!, Std.RBMap.find?, Array.mapM, Lean.Meta.instantiateMVars, Lean.Elab.DefViewElabHeader.type, Lean.Elab.DefViewElabHeader.mk, Lean.Elab.DefViewElabHeader.ref, Lean.Elab.DefViewElabHeader.modifiers, Lean.Elab.DefViewElabHeader.kind, Lean.Elab.DefViewElabHeader.shortDeclName, Lean.Elab.DefViewElabHeader.declName, Lean.Elab.DefViewElabHeader.levelNames, Lean.Elab.DefViewElabHeader.binderIds, Lean.Elab.DefViewElabHeader.numParams, Lean.Elab.DefViewElabHeader.valueStx, Lean.Elab.Term.MutualClosure.LetRecClosure.toLift, Lean.Elab.Term.MutualClosure.LetRecClosure.ref, Lean.Elab.Term.MutualClosure.LetRecClosure.localDecls, Lean.Elab.Term.MutualClosure.LetRecClosure.closed, Lean.Elab.Term.MutualClosure.pushMain, Lean.Elab.Term.MutualClosure.pushLetRecs, List.toArray, List.nil]]
[StateT.run_bind_lift,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, LawfulMonad.bind_assoc, Pure.pure, Prod.mk, Bind.bind, funext, LawfulMonad.pure_bind, eq_self]]
[Lean.Parser.Tactic.induction,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlts]]
[Lean.Parser.ParserContext.suppressInsideQuot,[]]
[Lean.Import.mk.inj,[And.intro]]
[Lean.Meta.SynthInstance.Waiter.consumerNode.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.SynthInstance.Waiter.consumerNode, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.rwRuleSeq,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.rwRule, Bool.true]]
[Lean.Parser.antiquotNestedExpr.formatter,[Lean.PrettyPrinter.Formatter.node.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.symbolNoAntiquot.formatter, Lean.PrettyPrinter.Formatter.decQuotDepth.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Lean.Meta.mkDecideProof,[Bind.bind, Lean.Meta.mkDecide, Lean.Meta.mkEq, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.Meta.mkEqRefl, Lean.Meta.mkExpectedTypeHint, Lean.Meta.mkAppM, List.toArray, List.cons]]
[Lean.Elab.Term.elabQuotedName,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Syntax.isNameLit?, Lean.Syntax.getOp, OfNat.ofNat, Pure.pure, Lean.ToExpr.toExpr, Lean.Elab.throwIllFormedSyntax]]
[List.subset,[Mem.mem]]
[Lean.Elab.Command.strLitToPattern,[Unit.unit, Lean.MacroM, Lean.Syntax, Lean.Syntax.isStrLit?, Pure.pure, Lean.mkAtomFrom, Lean.Macro.throwUnsupported]]
[Lean.PrettyPrinter.formatTerm,[Lean.PrettyPrinter.format, Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Meta.SimpLemma.getValue,[ite, Eq, and, Lean.Expr.isConst, Lean.Meta.SimpLemma.proof, Array.isEmpty, Lean.Meta.SimpLemma.levelParams, Bool.true, Bind.bind, Lean.getConstInfo, Lean.Expr.constName!, List.isEmpty, Lean.ConstantInfo.levelParams, Pure.pure, List.mapM, Lean.Meta.mkFreshLevelMVar, Lean.Expr.updateConst!, Array.mapM, Lean.Expr.instantiateLevelParamsArray]]
[Lean.PPFns.ppExpr,[]]
[Decidable.not_iff_comm,[Eq.mpr, Eq.refl, Iff, Not, propext, iff_def, And, and_congr, Decidable.not_imp_comm, imp_not_comm]]
[Lean.Parser.Term.argument.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkWsBefore.formatter, Lean.PrettyPrinter.Formatter.checkColGt.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.namedArgument.formatter, Lean.Parser.Term.ellipsis.formatter, Lean.Parser.termParser.formatter, Lean.Parser.argPrec]]
[Lean.PrettyPrinter.Formatter.group,[Bind.bind, Lean.PrettyPrinter.Formatter.concat, modify, Lean.PrettyPrinter.Formatter.State.mk, Lean.PrettyPrinter.Formatter.State.stxTrav, Lean.PrettyPrinter.Formatter.State.leadWord, Array.modify, Lean.PrettyPrinter.Formatter.State.stack, HSub.hSub, Array.size, OfNat.ofNat, Std.Format.fill]]
[Lean.Attribute.add,[Bind.bind, Lean.MonadEnv.getEnv, Lean.ofExcept, Lean.getAttributeImpl, Lean.AttributeImpl.add]]
[Nat.succ_eq_add_one,[rfl]]
[Lean.NameGenerator.mk.inj,[And.intro]]
[Mathlib.RunTac.tacticRunTac_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[ByteArray.toSliceT,[ByteSliceT.mk, OfNat.ofNat]]
[Function.eval,[]]
[Lean.Meta.Match.Problem.toMessageData,[Lean.Meta.Match.withGoalOf, Bind.bind, List.mapM, Lean.Meta.Match.Alt.toMessageData, Lean.Meta.Match.Problem.alts, Lean.Meta.inferType, Pure.pure, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.Match.Problem.vars, Lean.indentD, Lean.MessageData.joinSep, Lean.MessageData.ofFormat, Std.Format.line, Lean.Meta.Match.examplesToMessageData, Lean.Meta.Match.Problem.examples]]
[Quotient.liftOn₂,[Quotient.lift₂]]
[Lean.Lsp.instBEqDiagnosticRelatedInformation,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Server.DocumentMeta.version,[]]
[Lean.Parser.sepByFn,[Bool.true]]
[Nat.lt_of_lt_of_eq,[]]
[Lean.getExternEntryFor,[Lean.getExternEntryForAux, Lean.ExternAttrData.entries]]
[Function.injective.prod_map,[]]
[Lean.Elab.Tactic.ElabSimpArgsResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Tactic.evalConstructor,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Meta.constructor, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Bool.false, Lean.Elab.Tactic.replaceMainGoal]]
[Lean.IR.EmitC.emitFns,[Bind.bind, Lean.IR.EmitC.getEnv, List.forM, List.reverse, Lean.IR.EmitC.emitDecl]]
[Function.funext_iff,[Iff.intro, rfl, funext]]
[Lean.Parser.Command.commentBody,[Lean.Parser.Parser.mk, Lean.Parser.rawFn, Lean.Parser.finishCommentBlock, OfNat.ofNat, Bool.true]]
[Lean.Server.FileWorker.WorkerState.noConfusionType,[]]
[Lean.Parser.Term.doPatDecl.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.Term.leftArrow.parenthesizer, Lean.Parser.doElemParser.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer, Lean.Parser.symbol.parenthesizer]]
[System.instInhabitedFilePath,[Inhabited.mk, System.FilePath.mk, arbitrary]]
[Lean.Parser.Command.mixfix.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.Command.mixfixKind.formatter, Lean.Parser.precedence.formatter, Lean.Parser.Command.optNamedName.formatter, Lean.Parser.Command.optNamedPrio.formatter, Lean.ppSpace.formatter, Lean.Parser.strLit.formatter, Lean.Parser.darrow.formatter, Lean.Parser.termParser.formatter]]
[HSub.hSub,[]]
[Subtype.symm,[Setoid.symm]]
[Lean.Server.RpcEncoding.DerivingParams.withRef,[]]
[Lean.Parser.Term.sort.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkWsBefore.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer, Lean.Parser.levelParser.parenthesizer, Lean.Parser.maxPrec]]
[Lean.Elab.DefViewElabHeader.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.DefViewElabHeader.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.mkAtomFrom,[Lean.Syntax.atom, Lean.SourceInfo.fromRef]]
[Std.HashMapImp.findEntry?,[Option, Prod, Std.AssocList.findEntry?, Array.uget, Subtype.val]]
[Lean.KeyedDeclsAttribute.ExtensionState.newEntries,[]]
[Lean.Parser.Command.set_option.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.Command.optionValue.parenthesizer]]
[Lean.Elab.Term.elabBinder,[Lean.Elab.Term.elabBinders, List.toArray, List.cons, List.nil, Array.getOp, OfNat.ofNat]]
[Lean.MetavarContext.hasAssignableLevelMVar,[Bool, and, Lean.Level.hasMVar, PProd.fst, or, PProd.snd, Lean.MetavarContext.isLevelAssignable, Bool.false]]
[Lean.Lsp.WorkDoneProgressEnd.message?,[]]
[Lean.Parser.Command.protected,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Lean.Meta.DecLevelContext.mk.inj,[]]
[Function.decidable_eq_pfun,[Decidable, Eq, decidable_of_iff, Function.decidable_eq_pfun.proof_1]]
[Lean.Widget.TaggedText.append.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.trans, Eq.refl, SizeOf.sizeOf, List.nil, HAdd.hAdd, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec]]
[instStreamProdProd,[Stream.mk, Option, Prod, Unit.unit, Stream.next?, Option.none, Option.some, Prod.mk]]
[Std.Range.forIn,[Std.Range.stop, Std.Range.start, Std.Range.forIn.loop]]
[Lean.instMonadCacheReaderT,[Lean.MonadCache.mk, Lean.MonadCache.findCached?, Lean.MonadCache.cache]]
[List.mem_constructor,[Exists, Eq, List.nil, HAppend.hAppend, List.cons, Eq.refl, Eq.mpr, Exists.intro, rfl, Eq.symm, List.cons_append]]
[Lean.Meta.IndPredBelow.Context.belowNames,[]]
[Lean.MonadRecDepth.getRecDepth,[]]
[Lean.Parser.TokenMap.insert,[Unit.unit, Lean.Parser.TokenMap, Std.RBMap.find?, Std.RBMap.insert, List.cons, List.nil]]
[StateT.bind,[Bind.bind, Prod]]
[Lean.Meta.smartUnfoldingMatch?,[Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.instInhabitedOptionDecls,[Inhabited.mk, EmptyCollection.emptyCollection]]
[Lean.Meta.getUnfoldEqnFor?,[Bind.bind, ST.Ref.get, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, Lean.Meta.MetaM, ForInStep, MProd, Option, Lean.Name, PUnit, Pure.pure, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, MProd.fst]]
[List.exists_mem_of_ne_nil,[List.exists_mem_of_length_pos, List.length_pos_of_ne_nil]]
[Std.Format.append.inj,[And.intro]]
[Lean.Syntax.TopDown.firstChoiceOnly,[]]
[Lean.Widget.Lean.Widget.InfoPopup.instRpcEncodingInfoPopupRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Lean.Widget.InfoPopup.type, Lean.Widget.InfoPopup.exprExplicit, Lean.Widget.InfoPopup.doc, Pure.pure, Lean.Server.RpcEncoding.rpcDecode, Lean.Widget.InfoPopup.mk]]
[Std.PersistentArray.pop,[ite, GT.gt, Array.size, Std.PersistentArray.tail, OfNat.ofNat, Std.PersistentArray.mk, Std.PersistentArray.root, Array.pop, HSub.hSub, Std.PersistentArray.size, Std.PersistentArray.shift, Std.PersistentArray.tailOff, Std.PersistentArray, Std.PersistentArray.popLeaf, Eq, and, BEq.beq, Std.PersistentArrayNode.isNode, Array.get!, Bool.true, Std.PersistentArray.initShift, Std.PersistentArrayNode.node]]
[Lean.Lsp.InitializeParams.mk.inj,[And.intro]]
[MonoidWithZero.noConfusionType,[]]
[instMonadControlReaderT,[MonadControl.mk, id]]
[Lean.ConstantInfo.opaqueInfo.injEq,[Eq.propIntro, Eq.refl, Lean.ConstantInfo.opaqueInfo, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.TermInfo.lctx,[]]
[Nat.any,[Nat.anyAux]]
[Lean.Widget.InteractiveGoal.mk.inj,[And.intro]]
[Lean.Parser.Syntax.binary,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.syntaxParser]]
[Lean.Lsp.instFileSourceTypeDefinitionParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.TypeDefinitionParams.toTextDocumentPositionParams]]
[Lean.PrettyPrinter.Formatter.formatterForKindUnsafe,[ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.PrettyPrinter.Formatter.push, Std.Format.text, Lean.Syntax.MonadTraverser.goLeft, Lean.Syntax.MonadTraverser.getCur, liftM, Lean.PrettyPrinter.runForNodeKind, Lean.PrettyPrinter.formatterAttribute, Lean.PrettyPrinter.Formatter.interpretParserDescr', Lean.PrettyPrinter.Formatter.withMaybeTag, Unit.unit, Option, Nat, Lean.SourceInfo.original, Lean.SourceInfo.none, Option.some, Option.none]]
[Lean.Meta.Match.Example.var.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.forall,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.unicodeSymbol, Lean.Parser.many1, Lean.Parser.ppSpace, HOrElse.hOrElse, Lean.Parser.Term.simpleBinder, Lean.Parser.Term.bracketedBinder, Bool.false, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat]]
[Lean.Meta.Simp.ConfigCtx.noConfusionType,[]]
[Std.HashSet.insert,[Std.HashSet, Subtype.mk, Std.HashSetImp.insert, Std.HashSetImp.WellFormed.insertWff]]
[Lean.Meta.CongrLemma.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[eq_or_ne,[em, Eq]]
[Lean.Elab.Term.Do.ToCodeBlock.Context.m,[]]
[Lean.Export.Entry.noConfusionType,[]]
[Lean.DefinitionSafety.noConfusionType,[noConfusionTypeEnum, Lean.DefinitionSafety.toCtorIdx]]
[Int.ofNat_add,[rfl]]
[Lean.ScopedEnvExtension.add,[Unit.unit, Unit, Lean.MonadEnv.modifyEnv, Lean.ScopedEnvExtension.addEntry, Lean.ScopedEnvExtension.addLocalEntry, Bind.bind, Lean.MonadResolveName.getCurrNamespace, Lean.ScopedEnvExtension.addScopedEntry]]
[Lean.Meta.check,[Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.all]]
[Lean.IR.Checker.usizeSize,[Lean.IR.Checker.getUSizeSize, Unit.unit]]
[Fin.modn_def,[Eq, HMod.hMod, Fin.mk, Fin.val, Nat.mod_lt, Fin.size_positive, rfl]]
[Lean.Elab.TacticInfo.noConfusionType,[]]
[Std.ShareCommon.PState,[Std.ShareCommon.PersistentState]]
[Applicative.toSeqLeft,[]]
[Std.HashSetImp.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.instToJsonProd,[Lean.ToJson.mk, Lean.Json, Lean.Json.arr, List.toArray, List.cons, Lean.ToJson.toJson, List.nil]]
[List.getLastD,[List.getLast, List.cons, List.getLastD.proof_1]]
[Lean.IR.ExplicitBoxing.castArgsIfNeededAux,[Bind.bind, ForIn.forIn, MProd.mk, Unit.unit, Lean.IR.ExplicitBoxing.M, ForInStep, MProd, Array, Lean.IR.Arg, Lean.IR.FnBody, Nat, Pure.pure, PUnit.unit, Lean.IR.ExplicitBoxing.getVarType, ite, Eq, Lean.IR.ExplicitBoxing.eqvTypes, Bool.true, getModify, Lean.IR.ExplicitBoxing.BoxingState.mk, HAdd.hAdd, Lean.IR.ExplicitBoxing.BoxingState.nextIdx, OfNat.ofNat, Lean.IR.ExplicitBoxing.BoxingState.auxDecls, Lean.IR.ExplicitBoxing.BoxingState.auxDeclCache, Lean.IR.ExplicitBoxing.BoxingState.nextAuxId, Lean.IR.VarId.mk, Lean.IR.ExplicitBoxing.mkCast, Prod, Prod.mk]]
[Lean.Elab.instInhabitedDefViewElabHeader,[Inhabited.mk, Lean.Elab.DefViewElabHeader.mk, arbitrary]]
[Function.forall_update_iff,[Iff.intro, Function.update]]
[ExceptT.finally,[MonadFinally.mk, ExceptT.mk, Bind.bind, MonadFinally.tryFinally', Option.none, Option.some, Except.error, Except, Except.ok, Prod, Pure.pure, Prod.mk]]
[Lean.Parser.checkTailLinebreak,[Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Bool, Lean.Syntax.getTailInfo, Substring.contains, Char.ofNat, Bool.false]]
[And.right,[]]
[Lean.MessageData.noConfusionType,[]]
[Lean.Server.Watchdog.ServerEvent.noConfusionType,[]]
[Lean.Meta.simpAll,[Lean.Meta.withMVarContext, StateRefT'.run', Lean.Meta.SimpAll.main, Lean.Meta.SimpAll.State.mk]]
[ofNat_mul,[Eq, Numeric.ofNat, HMul.hMul, of_eq_true, Eq.trans, congr, congrArg, Nat.mul_zero, ofNat_zero, MonoidWithZero.mul_zero, eq_self, OfNat.ofNat, Nat.mul_succ, ofNat_add, congrFun, HAdd.hAdd, ofNat_one, mul_add, mul_one]]
[Lean.ScopedEnvExtension.addEntry,[Lean.PersistentEnvExtension.addEntry, Lean.ScopedEnvExtension.ext, Lean.ScopedEnvExtension.Entry.global]]
[Lean.Elab.getOptDerivingClasses,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Unit.unit, Array, Lean.Elab.DerivingClassView, OptionM.run, Array.sequenceMap, Array.getSepElems, Lean.Syntax.getArgs, Lean.Syntax.isNone, Option.none, Option.some, Bind.bind, ForIn.forIn, MProd.mk, ForInStep, MProd, Subarray, Option, Lean.Syntax, Stream.next?, Pure.pure, ForInStep.done, Lean.Elab.resolveGlobalConstNoOverloadWithInfo, PUnit.unit, ForInStep.yield, List.toArray, List.nil]]
[Lean.Expr.hasLevelMVarEx,[Lean.Expr.hasLevelMVar]]
[Lean.Elab.Term.mkFreshIdent,[Bind.bind, Lean.Elab.Term.mkFreshBinderName, Pure.pure, Lean.mkIdentFrom]]
[Lean.Server.FileWorker.SemanticTokensContext.beginPos,[]]
[solve,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[Lean.getAttributeNames,[Std.PersistentHashMap.foldl, List.cons, List.nil]]
[ExceptCpsT.run_bind_throw,[rfl]]
[Lean.MetavarContext.MkBinding.State.cache,[]]
[Lean.Elab.Deriving.Header.noConfusionType,[]]
[Lean.Elab.Tactic.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.unknown,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.withPosition, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.errorAtSavedPos]]
[Nat.mul_div_cancel,[Eq.mp, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, HAdd.hAdd, OfNat.ofNat, Nat.zero_add, Nat.zero_div]]
[Lean.Meta.CheckAssignment.run,[Bind.bind, Lean.Meta.getMVarDecl, StateRefT'.run', ReaderT.run, Lean.Meta.CheckAssignment.State.mk]]
[Lean.Parser.withResultOfInfo,[Lean.Parser.ParserInfo.mk, Lean.Parser.ParserInfo.collectTokens, Lean.Parser.ParserInfo.collectKinds]]
[imp_not_comm,[imp.swap]]
[Lean.Json.getObjValAs?,[Lean.FromJson.fromJson?, Lean.Json.getObjValD]]
[Lean.Parser.Command.optNamedPrio,[Lean.Parser.optional, HAndThen.hAndThen, Lean.Parser.ppSpace, Lean.Parser.Command.namedPrio]]
[Lean.Expr.instantiateLevelParamsCore,[Lean.Expr.instantiateLevelParamsCore.visit]]
[Lean.JsonRpc.Response.mk.inj,[And.intro]]
[Lean.Meta.Simp.Cache,[Lean.ExprMap, Lean.Meta.Simp.Result]]
[Lean.PrettyPrinter.Parenthesizer.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.EmitC.emitCtor,[Bind.bind, Lean.IR.EmitC.emitLhs, ite, Eq, and, BEq.beq, Lean.IR.CtorInfo.size, OfNat.ofNat, Lean.IR.CtorInfo.usize, Lean.IR.CtorInfo.ssize, Bool.true, Lean.IR.EmitC.emit, Lean.IR.CtorInfo.cidx, Lean.IR.EmitC.emitLn, Lean.IR.EmitC.emitAllocCtor, Lean.IR.EmitC.emitCtorSetArgs]]
[Lean.IR.ExplicitBoxing.BoxingState.nextAuxId,[]]
[Lean.Parser.LeadingIdentBehavior.noConfusionType,[noConfusionTypeEnum, Lean.Parser.LeadingIdentBehavior.toCtorIdx]]
[Mathlib.Prelude.Rename.elabAlign,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Lean.Elab.Command.liftCoreM, Mathlib.Prelude.Rename.addNameAlignment, Lean.Syntax.getId, Lean.Elab.throwUnsupportedSyntax]]
[Lean.instCoeIntDataValue,[Coe.mk, Lean.DataValue.ofInt]]
[FloatSpec.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Expr.Data.looseBVarRange,[UInt64.toUInt32, UInt64.shiftRight, OfNat.ofNat]]
[Lean.Elab.Term.mkConst,[Bind.bind, Lean.getConstInfo, ite, GT.gt, List.length, Lean.ConstantInfo.levelParams, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, liftM, Lean.Meta.mkFreshLevelMVars, Pure.pure, Lean.mkConst]]
[Array.feraseIdx,[Array.eraseIdxAux, HAdd.hAdd, Fin.val, OfNat.ofNat]]
[Array.insertionSort.swapLoop.proof_2,[Eq.mpr, Eq.refl, LT.lt, Array.size, Array.swap, Fin.mk, Nat.lt_trans, Nat.lt_succ_self, Eq.symm, Array.size_swap]]
[Lean.Elab.Info.format,[IO, Std.Format, Lean.Elab.TacticInfo.format, Lean.Elab.TermInfo.format, Lean.Elab.CommandInfo.format, Lean.Elab.MacroExpansionInfo.format, Lean.Elab.FieldInfo.format, Lean.Elab.CompletionInfo.format]]
[Lean.Meta.IndPredBelow.Context.mk.inj,[And.intro]]
[Lean.Elab.Tactic.withLocation,[Unit.unit, Lean.Elab.Tactic.TacticM, Unit, Bind.bind, Array.forM, Lean.Elab.Tactic.withMainContext, Lean.Elab.Tactic.getFVarId, OfNat.ofNat, Array.size, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Elab.Tactic.tryTactic, Lean.MonadLCtx.getLCtx, ForIn.forIn, ForInStep.yield, Lean.Elab.Tactic.getMainGoal]]
[StdGen.s2,[]]
[Lean.instMonadQuotation,[Lean.MonadQuotation.mk, liftM, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, MonadFunctorT.monadMap, Lean.MonadQuotation.withFreshMacroScope]]
[Lean.Lsp.InitializeParams.capabilities,[]]
[Lean.IR.Expr.alphaEqv,[Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.fap, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Bool, and, BEq.beq, Lean.IR.AlphaEqv.aeqv, Bool.false]]
[Lean.Lsp.instFromJsonRpcConnectParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, Pure.pure, Lean.Lsp.RpcConnectParams.mk]]
[Lean.Meta.ensureAtMostOne,[Unit.unit, List.cons, Lean.Meta.MetaM, Option, Lean.MVarId, Pure.pure, Option.none, Option.some, Lean.throwError]]
[Lean.Macro.State.traceMsgs,[]]
[Char.ofNat,[dite, Nat.isValidChar, Char.mk, UInt32.mk, Fin.mk, LT.lt, UInt32.size, Nat.lt_trans, of_decide_eq_true, Eq.refl, Bool.true, OfNat.ofNat, Char.ofNat.proof_1, Char.ofNat.proof_2]]
[«term_\/_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.DiscrTree.empty,[Lean.Meta.DiscrTree.mk, Std.PersistentHashMap.mk]]
[Lean.Parser.optionalFn,[Lean.Parser.ParserState.mkNode, Lean.nullKind]]
[Lean.Meta.GeneralizeTelescope.Entry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt8.instAddSemigroupUInt8.proof_1,[congrArg, UInt8.mk, AddSemigroup.add_assoc, UInt8.val]]
[Lean.Widget.instInhabitedInteractiveGoal,[Inhabited.mk, Lean.Widget.InteractiveGoal.mk, arbitrary]]
[Lean.IR.FnBody.mdata.inj,[And.intro]]
[Lean.Server.Watchdog.WorkerEvent.noConfusionType,[]]
[Lean.Macro.Context.noConfusionType,[]]
[Lean.Elab.Term.expandArgs,[Lean.Elab.Term.TermElabM, Prod, Array, Lean.Elab.Term.NamedArg, Lean.Elab.Term.Arg, Bool, Bind.bind, Array.foldlM, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Term.addNamedArg, Lean.Elab.Term.NamedArg.mk, Lean.Elab.Term.Arg.stx, Pure.pure, Prod.mk, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, Array.push, List.toArray, List.nil, OfNat.ofNat, Array.size]]
[Lean.Meta.SizeOfSpecNested.main.step,[Bind.bind, liftM, Lean.Meta.isDefEq, ite, Eq, Bool.true, Lean.Meta.mkEqRefl, Lean.matchConstRec, Lean.Expr.getAppFn, Lean.Meta.SizeOfSpecNested.throwFailed, MonadReader.read, Unit.unit, Lean.Meta.SizeOfSpecNested.M, Lean.Expr, Lean.NameMap.find?, Lean.Meta.SizeOfSpecNested.Context.recMap, Lean.ConstantVal.name, Lean.RecursorVal.toConstantVal, Lean.Meta.SizeOfSpecNested.throwUnexpected, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Pure.pure, Lean.mkAppN, Lean.mkConst, List.tail!, Lean.Meta.SizeOfSpecNested.Context.params, Lean.Meta.SizeOfSpecNested.Context.localInsts, Array.ofSubarray, List.toArray, List.cons, List.nil]]
[Lean.Meta.Match.Alt.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.elabBinRel,[Lean.Elab.Term.elabBinRelCore, Bool.false]]
[Nat.coprime.gcd_mul_right_cancel_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.mul_comm, Nat.coprime.gcd_mul_left_cancel_right, rfl]]
[Lean.Meta.MetaM.run,[StateRefT'.run]]
[Prod.lex,[WellFoundedRelation.mk, Prod.Lex, WellFoundedRelation.rel, Prod.lex.proof_1]]
[of_decide_eq_true,[absurd, ne_true_of_eq_false, decide_eq_false]]
[if_t_t,[Eq, ite, rfl]]
[Lean.Declaration.mutualDefnDecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Mod.mod,[]]
[Lean.PrettyPrinter.Parenthesizer.scientificLitNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken]]
[Lean.instMonadLCtx,[Lean.MonadLCtx.mk, liftM, Lean.MonadLCtx.getLCtx]]
[Lean.Lsp.PublishDiagnosticsParams.mk.inj,[And.intro]]
[Lean.IR.LocalContext.isParam,[Option.none, Option.some, Lean.IR.LocalContextEntry.localVar, Lean.IR.LocalContextEntry.joinPoint, Bool, Std.RBMap.find?, Bool.true, Bool.false]]
[Lean.Meta.mkPropExt,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil]]
[ULift.down,[]]
[«term_|>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Widget.Lean.Widget.InteractiveHypothesis.instToJsonRpcEncodingPacket,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil, Lean.Json.opt]]
[Substring.takeWhile,[Substring, Substring.mk]]
[Lean.matchConstStruct,[Lean.matchConstInduct, ite, Eq, or, Lean.InductiveVal.isRec, bne, Lean.InductiveVal.numIndices, OfNat.ofNat, Bool.true, Unit.unit, List.nil, List.cons, Lean.InductiveVal.ctors, Bind.bind, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo]]
[Lean.Meta.Simp.Methods.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Add.add,[]]
[Lean.Level.isEquiv,[or, BEq.beq, Lean.Level.normalize]]
[Quotient.sound.proof_1,[Quot.sound]]
[Lean.Elab.DefViewElabHeader.noConfusionType,[]]
[Lean.Lsp.PublishDiagnosticsParams.uri,[]]
[and_iff_not_or_not,[Decidable.and_iff_not_or_not]]
[Lean.Meta.Match.Unify.State.mk.inj,[]]
[Lean.Parser.Term.do.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.argPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer]]
[Nat.dvd_refl,[Exists.intro, OfNat.ofNat, of_eq_true, Eq.trans, congrArg, Eq, Nat.mul_one, eq_self]]
[Lean.Macro.Context.methods,[]]
[Lean.ppExpr,[ite, Eq, Lean.Option.get, Lean.PPContext.opts, Lean.pp.raw, Bool.true, Pure.pure, Std.ToFormat.format, ToString.toString, MonadExcept.tryCatch, Lean.PPFns.ppExpr, Lean.EnvExtension.getState, Lean.ppExt, Lean.PPContext.env, Lean.pp.rawOnError, HAppend.hAppend, Std.Format.line]]
[Lean.Parser.Term.funImplicitBinder.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.lookahead.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.implicitBinder.formatter, Bool.false]]
[Lean.IR.FnBody.vdecl.inj,[And.intro]]
[not_non_contradictory_iff_absurd,[Iff.intro, mt, not_not_intro]]
[Lean.Widget.InteractiveHypothesis.type,[]]
[CoeHTCT.coe,[]]
[EStateM.instOrElseEStateM,[OrElse.mk, EStateM.orElse]]
[«termIfLet_:=_Then_Else_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.instMonadMetaM,[Monad.mk]]
[Lean.InductiveVal.isNested,[]]
[Lean.registerAttributeOfDecl,[Bind.bind, Lean.mkAttributeImplOfConstant, ite, Eq, Lean.isAttribute, Lean.AttributeImplCore.name, Lean.AttributeImpl.toAttributeImplCore, Bool.true, MonadExcept.throw, HAppend.hAppend, ToString.toString, Pure.pure, Lean.PersistentEnvExtension.addEntry, Lean.attributeExtension, Prod.mk, Lean.AttributeExtensionOLeanEntry.decl]]
[Lean.PrettyPrinter.Formatter.fieldIdx.formatter,[Lean.PrettyPrinter.Formatter.visitAtom, Lean.fieldIdxKind]]
[Subsingleton.noConfusionType,[]]
[xor,[Or, And, Not]]
[Lean.Parser.Command.terminationHintMany.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.lookahead.formatter, Lean.Parser.ident.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1Indent.formatter, Lean.Parser.group.formatter, Lean.ppLine.formatter, Lean.Parser.optional.formatter]]
[Lean.isGreek,[and, Decidable.decide, LE.le, OfNat.ofNat, Char.val]]
[Lean.Parser.FirstTokens.merge,[Lean.Parser.FirstTokens.epsilon, Lean.Parser.FirstTokens.unknown, Lean.Parser.FirstTokens.tokens, Lean.Parser.FirstTokens.optTokens, Lean.Parser.FirstTokens, Lean.Parser.FirstTokens.toOptional, HAppend.hAppend]]
[Subarray.forRevM,[Array.forRevM, Subarray.as, Subarray.stop, Subarray.start]]
[ByteArray.toUInt64BE!,[ite, Eq, BEq.beq, ByteArray.size, OfNat.ofNat, Bool.true, HOr.hOr, HShiftLeft.hShiftLeft, UInt8.toUInt64, ByteArray.get!, panicWithPosWithDecl, HAppend.hAppend]]
[Lean.MonadCache.cache,[]]
[Lean.MetavarDecl.lctx,[]]
[Lean.Meta.Simp.State.mk.inj,[And.intro]]
[List.mem_of_mem_cons_of_mem,[Or.elim, List.eq_or_mem_of_mem_cons, Eq.symm]]
[add_right_neg,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat, Eq.symm, add_left_neg, neg_neg, rfl]]
[Lean.EnumAttributes.ext,[]]
[Lean.Meta.InductionSubgoal.mvarId,[]]
[Lean.Elab.Term.elabSyntheticHole,[ite, Eq, Lean.Name.isAnonymous, Bool.true, Unit.unit, Bind.bind, Lean.MonadMCtx.getMCtx, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.MetavarContext.findUserName?, Lean.Elab.Term.getMVarDecl, Lean.MonadLCtx.getLCtx, Lean.LocalContext.isSubPrefixOf, Lean.MetavarDecl.lctx, List.toArray, List.nil, Pure.pure, Lean.MetavarContext.getExprAssignment?, liftM, Lean.Meta.instantiateMVars, Lean.MetavarContext.isWellFormed, Lean.Meta.withLCtx, Lean.MetavarDecl.localInstances, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.MetavarContext.isDelayedAssigned, Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.assignExpr]]
[String.back,[String.get, String.prev, String.bsize]]
[Lean.Parser.Tactic.acChange,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Lean.Elab.Tactic.TacticM,[ReaderT, Lean.Elab.Tactic.Context, StateRefT', IO.RealWorld, Lean.Elab.Tactic.State, Lean.Elab.Term.TermElabM]]
[Lean.Xml.Parser.PEDecl,[SeqRight.seqRight, Lean.Parsec.skipString, Lean.Xml.Parser.S, Lean.Parsec.skipChar, Char.ofNat, Lean.Xml.Parser.Name, Lean.Xml.Parser.PEDef, optional]]
[Lean.Parser.Tactic.withReducibleAndInstances,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[«stx_,*»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[IO.FS.Mode.noConfusion,[noConfusionEnum, IO.FS.Mode.toCtorIdx]]
[Lean.Meta.UnificationHintEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[String.toNat!,[ite, Eq, String.isNat, Bool.true, String.foldl, HAdd.hAdd, HMul.hMul, OfNat.ofNat, HSub.hSub, Char.toNat, Char.ofNat, panicWithPosWithDecl]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.motive,[]]
[Lean.Lsp.instFromJsonWaitForDiagnosticsParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, Nat, Pure.pure, Lean.Lsp.WaitForDiagnosticsParams.mk]]
[Lean.Parser.Term.typeAscription.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.instMonadRecDepthMonadCacheT,[inferInstanceAs, Lean.MonadRecDepth, StateRefT', Std.HashMap]]
[Lean.Meta.forallMetaTelescope,[List.toArray, List.nil, OfNat.ofNat, Bool.false, Option.none]]
[Lean.AddErrorMessageContext.add,[]]
[instDecidableEqPUnit,[Decidable.isTrue, PUnit.subsingleton]]
[Lean.MessageSeverity.warning.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parsec.ParseResult.success.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parsec.ParseResult.success, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.instInhabitedLOption,[Inhabited.mk, Lean.LOption.none]]
[EIO.catchExceptions,[EStateM.Result, Empty, IO.RealWorld, EStateM.Result.ok]]
[Lean.Parser.sepByElemParser,[Lean.Parser.withAntiquotSpliceAndSuffix, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol, HAppend.hAppend, String.trim]]
[Lean.Lsp.TextEdit.range,[]]
[instAndOpUInt8,[AndOp.mk, UInt8.land]]
[lt_or_ge,[lt_or_le]]
[Lean.EnvironmentHeader.quotInit,[]]
[WellFounded.fix,[WellFounded.fixF, WellFounded.apply]]
[Lean.MessageData.node.injEq,[Eq.propIntro, Eq.refl, Lean.MessageData.node, Eq.symm, eq_of_heq, HEq.refl]]
[Fin.shiftRight.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[Lean.LocalContext.usesUserName,[Option.isSome, Lean.LocalContext.findFromUserName?]]
[HMul.hMul,[]]
[Lean.Parser.checkStackTop,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.checkStackTopFn]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.annotations,[]]
[Lean.Meta.SortLocalDecls.Context.noConfusionType,[]]
[Lean.Parser.Command.declModifiersT,[Lean.Parser.Command.declModifiers, Bool.true]]
[Lean.IR.EmitC.paramEqArg,[Lean.IR.Arg.irrelevant, Bool, BEq.beq, Lean.IR.Param.x, Bool.false]]
[Lean.Meta.addSimpLemmaEntry.updateLemmaNames,[Unit.unit, Std.PHashSet, Lean.Name, Lean.Meta.SimpLemma.name?, Std.PersistentHashSet.insert]]
[Lean.Lsp.PlainTermGoalParams.mk.inj,[]]
[Lean.IR.UnreachableBranches.Value.below,[PUnit, PProd]]
[Lean.JsonRpc.Response.noConfusionType,[]]
[List.reverseAux_reverseAux_nil,[rfl, of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.cons, List.reverseAux, eq_self]]
[Lean.Elab.Command.Scope.currNamespace,[]]
[Lean.Compiler.instBEqInlineAttributeKind,[BEq.mk, BEq.beq, Lean.Compiler.InlineAttributeKind.toCtorIdx]]
[Lean.Lsp.TextDocumentItem.languageId,[]]
[or_and_distrib_left,[Iff.intro, And.intro, Or.inl, And.imp, Or.inr, Function.comp, imp_intro, Or.imp_right]]
[List.get?,[Nat.zero, List.nil, Nat.succ, Option, Option.some, PProd.fst, Option.none]]
[StateT.run_lift,[rfl]]
[Lean.DataValue.ofBool.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.ExplicitBoxing.N,[StateM, Nat]]
[Lean.Parser.Tactic.«tactic_<;>[_]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false]]
[List.mem_cons_iff,[Iff.rfl]]
[Lean.IR.FnBody.del.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.del, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.JsonRpc.instInhabitedRequestID,[Inhabited.mk, Lean.JsonRpc.RequestID.str, arbitrary]]
[iff_iff_implies_and_implies,[Iff.intro, And.intro, Iff.mp, Iff.mpr, And.left, And.right]]
[ulift.down_up,[rfl]]
[Std.Format.getWidth,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Std.Format.defWidth]]
[Lean.Expr.updateMData!.proof_1,[rfl]]
[mul_mul_mul_comm,[of_eq_true, Eq.trans, congr, congrArg, Eq, mul_left_comm, HMul.hMul, mul_assoc, eq_self]]
[Lean.Elab.Term.MutualClosure.ClosureState.localDecls,[]]
[Lean.Elab.Command.getCurrMacroScope,[Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Command.Context.currMacroScope]]
[commandGenIntDeclars__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[evalIntrov,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, GE.ge, Lean.Syntax.getNumArgs, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.Elab.Tactic.evalTactic, Lean.Elab.throwUnsupportedSyntax, evalIntrov.introsDep, evalIntrov.intro1PStep]]
[Lean.instReprFVarId,[Repr.mk, Repr.reprPrec, Lean.FVarId.name]]
[Lean.Elab.Term.mkTypeMismatchError,[Bind.bind, liftM, Lean.Meta.mkHasTypeButIsExpectedMsg, Pure.pure, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Eq.subst,[]]
[Lean.Lsp.SymbolKind.class.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Expr.ReplaceLevelImpl.cacheSize,[OfNat.ofNat]]
[String.dropWhile,[Substring.toString, Substring.dropWhile, String.toSubstring]]
[Lean.Expr.applyFVarSubst,[Lean.Meta.FVarSubst.apply]]
[UInt16.instSemiringUInt16,[Semiring.mk, UInt16.instSemiringUInt16.proof_1, UInt16.instSemiringUInt16.proof_2, UInt16.mk, Semiring.nsmul, UInt16.val, UInt16.instSemiringUInt16.proof_3, UInt16.instSemiringUInt16.proof_4, UInt16.instSemiringUInt16.proof_5, UInt16.instSemiringUInt16.proof_6, UInt16.instSemiringUInt16.proof_7, UInt16.instSemiringUInt16.proof_8, UInt16.instSemiringUInt16.proof_9, UInt16.instSemiringUInt16.proof_10, UInt16.instSemiringUInt16.proof_11, UInt16.instSemiringUInt16.proof_12, UInt16.instSemiringUInt16.proof_13]]
[Lean.instQuoteList,[Lean.Quote.mk, Unit.unit, Lean.Syntax, Lean.mkCIdent, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.mkCApp, List.toArray, List.cons, Lean.Quote.quote, PProd.fst, List.nil]]
[Lean.Expr.mvar.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.mvar, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.NormalizeIds.normVar,[Functor.map, Lean.IR.VarId.mk, Lean.IR.NormalizeIds.normIndex, Lean.IR.VarId.idx]]
[Lean.PrettyPrinter.Formatter.checkWsBefore.formatter,[Bind.bind, MonadState.get, ite, Eq, bne, Lean.PrettyPrinter.Formatter.State.leadWord, Bool.true, Lean.PrettyPrinter.Formatter.pushLine, Pure.pure, PUnit.unit]]
[MonadExcept.orElse,[MonadExcept.tryCatch, Unit.unit]]
[Lean.Parser.doElemParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous]]
[«term_==_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Subarray.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.identNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.identFn]]
[Tactic.Ring.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Tactic.Ring.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.LeadingIdentBehavior.noConfusion,[noConfusionEnum, Lean.Parser.LeadingIdentBehavior.toCtorIdx]]
[Lean.Meta.CaseArraySizesSubgoal.noConfusionType,[]]
[«term~~~_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Lsp.DocumentSymbolAux.children?,[]]
[Lean.KVMap.instValueDataValue,[Lean.KVMap.Value.mk, id, Option.some]]
[Lean.Meta.instantiateMVars,[Lean.MonadCacheT.run, Lean.MetavarContext.instantiateExprMVars]]
[Lean.CollectFVars.State.noConfusionType,[]]
[max_le,[dite, LT.lt, Eq.mpr, congrFun, congrArg, LE.le, if_pos, if_neg]]
[Array.insertionSort,[OfNat.ofNat, Array.size, Array.insertionSort.traverse, Array.insertionSort.swapLoop]]
[Mathlib.Tactic.Lint.LintVerbosity.noConfusion,[noConfusionEnum, Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx]]
[Lean.Parser.ParserState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[trans_rel_left,[]]
[Lean.Meta.trySynthInstance,[Lean.catchInternalId, Lean.Meta.isDefEqStuckExceptionId, toLOptionM, Lean.Meta.synthInstance?, Pure.pure, Lean.LOption.undef]]
[instRingFin.proof_1,[of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.sub_def, Fin.add_def, Fin.mk, HMod.hMod, HSub.hSub, Fin.val, instNegFin.proof_1, Fin.mk.injEq, HAdd.hAdd, Nat.mod_lt, Fin.size_positive, Nat.add_mod_mod, eq_self]]
[Float.ofInt,[Float, Float.ofNat, Float.neg, Nat.succ]]
[Lean.Meta.RecursorInfo.indicesPos,[]]
[Lean.getPPLetVarTypes,[Lean.KVMap.get, Lean.Option.name, Lean.pp.letVarTypes, Lean.getPPAll]]
[Lean.Elab.Term.ToDepElimPattern.M,[StateRefT', IO.RealWorld, Lean.Elab.Term.ToDepElimPattern.State, Lean.Elab.Term.TermElabM]]
[calcStep,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary]]
[ByteArray.empty,[ByteArray.mkEmpty, OfNat.ofNat]]
[Lean.Syntax.Traverser.mk.inj,[And.intro]]
[Array.sequenceMap.loop,[dite, LT.lt, Array.size, Unit.unit, Array, Pure.pure, Bind.bind, Array.get, Fin.mk, PProd.fst, HAdd.hAdd, OfNat.ofNat, Array.push]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.mvars,[]]
[Lean.Elab.Tactic.pruneSolvedGoals,[Bind.bind, Lean.Elab.Tactic.getGoals, List.filterM, Functor.map, not, liftM, Lean.Meta.isExprMVarAssigned, Lean.Elab.Tactic.setGoals]]
[GroupWithZero.toDivInvMonoid,[]]
[Lean.Lsp.SymbolKind.boolean.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[«stx_,+,?»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Lean.Parser.Command.openSimple,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.many1, HAndThen.hAndThen, Lean.Parser.checkColGt, Lean.Parser.ident]]
[List.nil_subset,[False.elim, Iff.mp, List.mem_nil_iff]]
[Lean.Parser.nameLit.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.nameLitKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.nameLitNoAntiquot.parenthesizer]]
[FloatSpec.lt,[]]
[Nat.add_zero,[rfl]]
[IO.Process.Stdio.toHandleType,[Unit.unit, IO.FS.Handle, Unit]]
[IO.Error.interrupted.inj,[And.intro]]
[Applicative.toFunctor,[]]
[Lean.Parser.Term.doForDecl.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.termParser.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.withForbidden.formatter]]
[Lean.Elab.Term.State.levelNames,[]]
[Lean.Meta.SynthInstance.GeneratorNode.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Tactic.TryThis.addTermSuggestion,[Bind.bind, Tactic.TryThis.delabToRefinableSyntax, Tactic.TryThis.addSuggestion]]
[Lean.Parser.Term.explicit.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec]]
[Lean.Expr.FoldConstsImpl.initCache.proof_1,[lcProof]]
[Lean.PersistentEnvExtensionDescr.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PersistentEnvExtensionDescr.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.elabIdent,[Bind.bind, List.nil, Bool.false, List.toArray, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.Elab.Term.TermElabM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Pure.pure, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError]]
[Substring.toString,[String, String.extract]]
[Lean.MonadBacktrack.restoreState,[]]
[Lean.Core.instInhabitedState,[Inhabited.mk, Lean.Core.State.mk, arbitrary]]
[Lean.ScopedEnvExtension.descr,[]]
[Lean.Parser.Term.structInstLVal.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.ident.formatter, Lean.PrettyPrinter.Formatter.fieldIdx.formatter, Lean.Parser.Term.structInstArrayRef.formatter, Lean.Parser.many.formatter, Lean.Parser.group.formatter, Lean.Parser.symbol.formatter]]
[Lean.SMap.size,[HAdd.hAdd, Std.HashMap.size, Lean.SMap.map₁, Std.PersistentHashMap.size, Lean.SMap.map₂]]
[invImage.proof_1,[InvImage.wf, WellFoundedRelation.wf]]
[Lean.IR.CtorFieldInfo.object.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.Do.ToTerm.Kind.nestedPRBC.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[String.data,[]]
[UInt8.instNumericUInt8,[Numeric.mk, UInt8.mk, Numeric.ofNat]]
[List.eq_nil_of_length_eq_zero,[rfl, False.elim, Eq.mp, Eq.trans, congrFun, congrArg, Eq, List.length_cons, OfNat.ofNat, eq_false']]
[Lean.ConstructorVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ConstructorVal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.StructInst.Struct.modifyFields,[Id.run, Lean.Elab.Term.StructInst.Struct.modifyFieldsM]]
[Lean.Elab.Command.Scope.openDecls,[]]
[Lean.Parser.Term.optIdent,[Lean.Parser.optional, Lean.Parser.atomic, HAndThen.hAndThen, Lean.Parser.Term.ident, Lean.Parser.symbol]]
[Lean.resetTraceState,[Lean.MonadTrace.modifyTraceState, Lean.TraceState.mk]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.nameNotRoundtrippable.containsNum,[Unit.unit, Bool, PProd.fst, Bool.true, Bool.false]]
[Lean.Widget.formatInfos,[Bind.bind, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, Lean.MonadOptions.getOptions, Lean.Meta.instantiateMVars, Lean.PrettyPrinter.delabCore, Lean.Meta.MetaM, Prod, Std.Format, Std.RBMap, Nat, Lean.Elab.Info, Ord.compare, liftM, Lean.PrettyPrinter.parenthesizeTerm, Lean.PrettyPrinter.formatTerm, Pure.pure, Prod.mk, EmptyCollection.emptyCollection]]
[Lean.getLibDir,[ite, Eq, Unit.unit, Bool.true, Bind.bind, Pure.pure, PUnit.unit]]
[Function.uncurry_curry,[funext, Eq, Function.uncurry, Function.curry, rfl]]
[Lean.Elab.Term.LetIdDeclView.binders,[]]
[StateT.failure,[Alternative.failure]]
[Lean.Lsp.SemanticTokensParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[CommMonoid.mul_comm,[]]
[Lean.mkStrLit,[Lean.mkLit, Lean.Literal.strVal]]
[Lean.Parser.Tactic.nontriviality,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.simpArg]]
[Lean.ConstantInfo.recInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Tactic.LibrarySearch.librarySearch,[Bind.bind, Lean.MonadOptions.getOptions, Lean.profileitM, Lean.Exception, Lean.Meta.inferType, MonadState.get, MonadExcept.tryCatch, Lean.Meta.solveByElim, Pure.pure, DoResultPR.return, Option.none, PUnit.unit, MonadStateOf.set, DoResultPR.pure, Lean.Meta.MetaM, Option, Array, Prod, Lean.MetavarContext, List, Lean.MVarId]]
[Nat.mul_add,[Nat.left_distrib]]
[Lean.PrettyPrinter.Delaborator.SubExpr.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.SubExpr.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.injections',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.parser]]
[OptionT.bind,[OptionT.mk, Bind.bind, Unit.unit, Option, Pure.pure, Option.none]]
[Lean.Parser.Term.fun,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.maxPrec, HAndThen.hAndThen, Lean.Parser.unicodeSymbol, HOrElse.hOrElse, Lean.Parser.Term.basicFun, Lean.Parser.Term.matchAlts, Lean.Parser.termParser, OfNat.ofNat]]
[UInt64.instRingUInt64.proof_4,[congrArg, UInt64.mk, SubNegMonoid.gsmul_neg', UInt64.val]]
[Lean.Json.num.injEq,[Eq.propIntro, Eq.refl, Lean.Json.num, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.shouldReduceReducibleOnly,[Bind.bind, Lean.Meta.getTransparency, Pure.pure, BEq.beq, Lean.Meta.TransparencyMode.reducible]]
[FloatSpec.val,[]]
[dite_false,[rfl]]
[Lean.IR.LocalContext.contains,[Std.RBMap.contains]]
[Lean.MessageData.mkPPContext,[Lean.PPContext.mk, Lean.MessageDataContext.env, Lean.MessageDataContext.mctx, Lean.MessageDataContext.lctx, Lean.MessageDataContext.opts, Lean.NamingContext.currNamespace, Lean.NamingContext.openDecls]]
[ByteArray.foldlMUnsafe,[ite, LT.lt, LE.le, ByteArray.size, USize.ofNat, Pure.pure, ByteArray.foldlMUnsafe.fold]]
[Lean.PrettyPrinter.Formatter.concat,[Lean.PrettyPrinter.Formatter.fold, Array.foldl, Std.Format.nil, OfNat.ofNat, Array.size]]
[Lean.Meta.CheckAssignment.Context.hasCtxLocals,[]]
[implies_true_iff,[Iff.intro, trivial]]
[Lean.Parser.checkLineEq,[Lean.Parser.Parser.mk, Lean.Parser.checkLineEqFn]]
[Lean.IR.JoinPointId.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Simp.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[ByteSlice.off,[]]
[StdGen.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, StdGen.mk, Eq.symm, eq_of_heq, HEq.refl]]
[IO.Error.hardwareFault.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Tactic.Conv.evalConvSeq1Indented,[Lean.Elab.Tactic.evalTacticSeq1Indented]]
[Lean.Parser.Term.attr.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.attrParser]]
[Lean.Meta.AbstractMVars.State.emap,[]]
[List.range,[List.rangeAux, List.nil]]
[Lean.Lsp.Command.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Json.noConfusionType,[]]
[Lean.ConstantInfo.axiomInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.IRType.object.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Quote.quote,[]]
[Lean.SMap.find?',[Option, Std.HashMap.find?, Option.orElse, Std.PersistentHashMap.find?]]
[IO,[EIO, IO.Error]]
[Lean.IR.Param.ty,[]]
[Lean.JsonRpc.instBEqNotification,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Elab.Term.MutualClosure.LetRecClosure.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.digitChar,[ite, Eq, OfNat.ofNat, Char.ofNat]]
[Eq.mp,[]]
[Lean.IR.Expr.lit.injEq,[Eq.propIntro, Eq.refl, Lean.IR.Expr.lit, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.instInhabitedVarIdSet,[Inhabited.mk, EmptyCollection.emptyCollection]]
[Lean.Lsp.TextDocumentIdentifier.mk.inj,[]]
[Lean.Level.imax.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Level.imax, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.MetavarContext.UnivMVarParamResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MetavarContext.UnivMVarParamResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.instFromJsonSemanticTokensLegend,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Array, String, Pure.pure, Lean.Lsp.SemanticTokensLegend.mk]]
[Lean.Meta.SynthInstance.GeneratorNode.noConfusionType,[]]
[Lean.Lsp.DidCloseTextDocumentParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[«term_<|_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[of_not_imp,[Decidable.of_not_imp]]
[Lean.MessageData.sbracket,[Lean.MessageData.bracket]]
[Function.right_inverse.comp_eq_id,[funext]]
[Lean.PersistentEnvExtension.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PersistentEnvExtension.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.ExternEntry.foreign.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.substCore,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getMVarTag, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getLocalDecl, Lean.Meta.matchEq?, Lean.LocalDecl.type, Unit.unit, Lean.Meta.MetaM, Prod, Lean.Meta.FVarSubst, Lean.MVarId, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing, Lean.Meta.instantiateMVars, ite, Eq, Bool.true, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.FVarId.name, Pure.pure, PUnit.unit, Lean.indentExpr]]
[Lean.Parser.Command.declSig,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.many, Lean.Parser.ppSpace, HOrElse.hOrElse, Lean.Parser.Term.simpleBinderWithoutType, Lean.Parser.Term.bracketedBinder, Bool.false, Lean.Parser.Term.typeSpec]]
[Lean.Parser.Tactic.simpRw,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[UInt64.mod,[UInt64.mk, HMod.hMod, UInt64.val]]
[Lean.MetavarContext.mkLambda,[Bind.bind, Lean.MetavarContext.mkBinding, Bool.true, Lean.MetavarContext.MkBindingM, Lean.Expr, Pure.pure]]
[Lean.Parser.Tactic.injection,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Lean.MonadMCtx.modifyMCtx,[]]
[Lean.instReprDefinitionSafety,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone]]
[Lean.MessageData.group.inj,[]]
[instReprInt,[Repr.mk, Std.Format.text, Int.repr]]
[Lean.IR.Borrow.InitParamMap.initBorrow,[Array.map, Lean.IR.Param.mk, Lean.IR.Param.x, Lean.IR.IRType.isObj, Lean.IR.Param.ty]]
[instRingFin.proof_3,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, Semiring.nsmul_succ', HAdd.hAdd, Semiring.nsmul, eq_self, propext, forall_const, Fin, Nat]]
[Lean.Widget.TaggedText.instRpcEncodingTaggedTextTaggedText,[Lean.Server.RpcEncoding.mk, Lean.Widget.TaggedText.mapM, Lean.Server.RpcEncoding.rpcEncode, Lean.Server.RpcEncoding.rpcDecode]]
[StateT.instAlternativeStateT,[Alternative.mk, StateT.failure, StateT.orElse]]
[Lean.Widget.InteractiveTermGoal.type,[]]
[Lean.mkLevelZeroEx,[Lean.levelZero]]
[Lean.Core.checkMaxHeartbeatsCore,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Pure.pure, PUnit.unit, Bind.bind, liftM, IO.getNumHeartbeats, MonadReader.read, GT.gt, HSub.hSub, Lean.Core.Context.initHeartbeats, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, HDiv.hDiv]]
[Lean.Elab.Tactic.Conv.matchPattern?,[Lean.Meta.withNewMCtxDepth, Bind.bind, Lean.Meta.openAbstractMVarsResult, Lean.Meta.MetaM, Option, Prod, Lean.Expr, Array, Lean.Meta.withReducible, Lean.Elab.Tactic.Conv.matchPattern?.go?]]
[Lean.sanitizeNamesDefault,[Bool.true]]
[Nat.eq_zero_of_le_zero,[Nat.le_antisymm, Nat.zero_le]]
[Lean.Elab.Term.expandMatchAltsIntoMatchTactic,[Lean.withRef, Lean.MacroM, Lean.Syntax, ite, Eq, Bool.true, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.MonadQuotation.withFreshMacroScope, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, PProd.fst, Array.push, Array.size]]
[Lean.Meta.SynthInstance.ConsumerNode.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SynthInstance.ConsumerNode.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Do.Code.break.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Export.State.mk.inj,[And.intro]]
[Lean.Meta.Simp.Step.done.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Simp.Step.done, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Export.State.names,[]]
[Lean.Elab.Term.StructInst.FieldLHS.fieldName.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.StructInst.FieldLHS.fieldName, Eq.symm, eq_of_heq, HEq.refl]]
[List.map_map,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.map, List.map_nil, eq_self, List.nil, List.map_cons, List.cons, congrFun, Function.comp_apply, Function.comp]]
[Fin.instModFin,[Mod.mk, Fin.mod]]
[Lean.Meta.setMVarTag,[modify, Lean.Meta.State.mk, Lean.MetavarContext.renameMVar, Lean.Meta.State.mctx, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed]]
[Fin.land.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[OptionT.instMonadLiftOptionT,[MonadLift.mk, OptionT.lift]]
[Lean.PrettyPrinter.Formatter.notFollowedBy.formatter,[Pure.pure, Unit.unit]]
[Lean.Parser.Tactic.seq1.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.tacticParser.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer, Bool.true]]
[List.mem_remove_iff,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, List.mem_nil_iff, And, ne_eq, false_and, Not, Eq, eq_true_of_decide, Eq.refl, Bool.true, Eq.mpr, Mem.mem, ite, List.remove, List.cons, List.mem_cons_iff, Decidable.em, congrFun, if_pos, List, Or, Iff.intro, And.intro, Or.inr, Ne, Or.resolve_left, Eq.symm, if_neg, Or.inl, Ne.symm, And.left, And.right]]
[List.pure,[List.cons, List.nil]]
[Lean.Meta.Closure.mkBinding,[Nat.foldRev, Lean.Expr, ite, Eq, Bool.true, Lean.mkLambda, Lean.mkForall, Lean.Expr.hasLooseBVar, OfNat.ofNat, Lean.mkLet, Lean.Expr.lowerLooseBVars, Array.size]]
[USize.mk_val_eq,[Eq, USize.mk, USize.val, rfl]]
[Lean.commitIfNoEx,[Bind.bind, Lean.MonadBacktrack.saveState, MonadExcept.tryCatch, Lean.MonadBacktrack.restoreState, MonadExcept.throw]]
[Lean.Elab.TacticInfo.mk.inj,[And.intro]]
[Lean.Lsp.instToJsonSaveOptions,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.SaveOptions.includeText, List.nil]]
[Lean.Parser.Command.prefix.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[PSum.noConfusionType,[]]
[Lean.Meta.instInhabitedFVarSubst,[Inhabited.mk, Lean.Meta.FVarSubst.mk, arbitrary]]
[Lean.Widget.MsgEmbed.goal.injEq,[Eq.propIntro, Eq.refl, Lean.Widget.MsgEmbed.goal, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.notSymbol.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.notFollowedBy.parenthesizer, Lean.Parser.symbol.parenthesizer]]
[Lean.Parser.Tactic.measurability?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.IR.ExplicitBoxing.addBoxedVersions,[HAppend.hAppend]]
[Lean.Meta.addSimpLemmaEntry,[ite, Eq, Lean.Meta.SimpLemma.post, Bool.true, Lean.Meta.SimpLemmas.mk, Lean.Meta.SimpLemmas.pre, Lean.Meta.DiscrTree.insertCore, Lean.Meta.SimpLemmas.post, Lean.Meta.SimpLemma.keys, Lean.Meta.SimpLemmas.lemmaNames, Lean.Meta.SimpLemmas.toUnfold, Lean.Meta.SimpLemmas.erased, Lean.Meta.addSimpLemmaEntry.updateLemmaNames]]
[Prod.map_fst',[funext, Prod.map_fst]]
[Lean.Syntax.topDown,[Lean.Syntax.TopDown.mk]]
[instToFormatList,[Std.ToFormat.mk, List.format]]
[Lean.Parser.Tactic.let'',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser]]
[Lean.Parser.Level.hole.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.Elab.assignInfoHoleId,[Bind.bind, Lean.Elab.getInfoHoleIdAssignment?, ite, Eq, Option.isNone, Bool.true, Lean.Elab.MonadInfoTree.modifyInfoState, Lean.Elab.InfoState.mk, Lean.Elab.InfoState.enabled, Std.PersistentHashMap.insert, Lean.Elab.InfoState.assignment, Lean.Elab.InfoState.trees, panicWithPosWithDecl, OfNat.ofNat, HAppend.hAppend]]
[Lean.KernelException.typeExpected.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.groupBy,[Unit.unit, List, List.nil, List.groupByAux, List.cons]]
[Lean.IR.VarId.mk.injEq,[Eq.propIntro, Eq.refl, Lean.IR.VarId.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Command.State.ngen,[]]
[Std.RBNode.noConfusionType,[]]
[instDecidableRelLtLtOfOrd,[inferInstanceAs, DecidableRel, Eq, BEq.beq, Ord.compare, Ordering.lt, Bool.true]]
[Lean.Parser.Attr.externEntry,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.ident, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.strLit]]
[Lean.Parser.Command.listUnusedDecls,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Lean.Meta.Match.Pattern.val.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[commandOfNat_class___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Lean.Lsp.SymbolKind.typeParameter.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Term.arrow.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.unicodeSymbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.IR.IRType.uint16.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.SynthInstance.main,[Lean.Core.withCurrHeartbeats, Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Array.instCoeSubarrayArray,[Coe.mk, Array.ofSubarray]]
[MonadExcept.orelse',[MonadExcept.tryCatch, MonadExcept.throw, ite, Eq, Bool.true]]
[UInt16.instRingUInt16.proof_2,[congrArg, UInt16.mk, Ring.gsmul_zero', UInt16.val]]
[ST.Ref.ref,[]]
[Lean.instInhabitedFVarId,[Inhabited.mk, Lean.FVarId.mk, arbitrary]]
[Lean.Meta.InductionSubgoal.fields,[]]
[Lean.Meta.Closure.State.nextExprIdx,[]]
[Lean.Parser.isQuotableCharDefault,[or, BEq.beq, Char.ofNat]]
[List.exists_or_eq_self_of_erasep,[Classical.em, Exists, And, Mem.mem, Or, Eq, List.erasep, Not, HAppend.hAppend, List.cons, Or.inr, List.exists_of_erasep, Eq.symm, Or.inl, List.erasep_of_forall_not, Eq.mp, Eq.trans, propext, not_exists, forall_congr, not_and, Eq.refl]]
[Lean.IR.LitVal.str.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.doMatch.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.generalizingParam.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.Term.matchDiscr.parenthesizer, Bool.false, Lean.Parser.Term.optType.parenthesizer, Lean.Parser.Term.doMatchAlts.parenthesizer]]
[Lean.Server.Watchdog.FileWorker.proc,[]]
[Lean.Meta.Simp.Config.mk.inj,[And.intro]]
[Lean.Meta.Match.State.counterExamples,[]]
[Lean.Parser.Term.waitIfContainsMVar.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.IR.EmitC.argToCString,[Lean.IR.Arg.irrelevant, String, ToString.toString]]
[Lean.Parser.LeadingIdentBehavior.default.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[EmptyCollection.noConfusionType,[]]
[ByteArray.foldlM.proof_1,[Nat.le_refl, ByteArray.size]]
[Lean.Elab.Term.Do.Code.action.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.Do.Code.action, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.occursCheck,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.occursCheck]]
[Lean.Elab.Term.SavedContext.options,[]]
[Lean.Server.Watchdog.ServerEvent.workerEvent.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.LocalContext.find?,[Std.PersistentHashMap.find?, Lean.LocalContext.fvarIdToDecl]]
[Lean.KeyedDeclsAttribute.addBuiltin,[ST.Ref.modify, Lean.KeyedDeclsAttribute.tableRef, Unit.unit, Lean.KeyedDeclsAttribute.Table, Lean.SMap.find?, Lean.KeyedDeclsAttribute.OLeanEntry.key, Lean.KeyedDeclsAttribute.AttributeEntry.toOLeanEntry, Lean.SMap.insert, List.cons, List.nil, Lean.KeyedDeclsAttribute.AttributeEntry.mk, Lean.KeyedDeclsAttribute.OLeanEntry.mk]]
[exists_apply_eq_apply,[Exists.intro, rfl]]
[coeM,[Bind.bind, Pure.pure, coe]]
[MonadStateOf.modifyGet,[]]
[Lean.IR.mkJmp,[Lean.IR.FnBody.jmp]]
[Lean.Elab.Deriving.Repr.mkReprInstanceHandler,[Bind.bind, Array.allM, Lean.isInductive, OfNat.ofNat, Array.size, ite, Eq, and, Decidable.decide, GT.gt, Bool.true, Lean.Elab.Command.liftTermElabM, Option.none, Lean.Elab.Deriving.mkContext, Array.getOp, Lean.Elab.Deriving.Repr.mkMutualBlock, Lean.Elab.Deriving.mkInstanceCmds, Lean.Name.mkStr, Lean.Name.anonymous, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Array.forM, Lean.Elab.Command.elabCommand, Bool.false]]
[Lean.IR.ExpandResetReuse.isSelfSet,[Lean.IR.Arg.irrelevant, Bool, Option.none, Option.some, Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.fap, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Std.HashMap.find?, Lean.IR.ExpandResetReuse.Context.projMap, and, BEq.beq, Bool.false]]
[Lean.Lsp.ServerCapabilities.mk.inj,[And.intro]]
[Lean.Core.instMonadNameGeneratorCoreM,[Lean.MonadNameGenerator.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Core.State.ngen, modify, Lean.Core.State.mk, Lean.Core.State.env, Lean.Core.State.nextMacroScope, Lean.Core.State.traceState]]
[Lean.Elab.Term.PatternVarDecl.anonymousVar.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.PatternVarDecl.anonymousVar, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.instantiateLocalDeclMVars,[Lean.Meta.MetaM, Lean.LocalDecl, Bind.bind, Lean.Meta.instantiateMVars, Pure.pure, Lean.LocalDecl.cdecl, Lean.LocalDecl.ldecl]]
[UInt16.instAddCommSemigroupUInt16.proof_1,[congrArg, UInt16.mk, AddCommSemigroup.add_comm, UInt16.val]]
[Lean.Expr.hash,[Lean.Expr.Data.hash, Lean.Expr.data]]
[Lean.mkApp6,[Lean.mkAppB, Lean.mkApp4]]
[Lean.extractMacroScopes,[Unit.unit, Lean.MacroScopesView, Lean.Name.hasMacroScopes, Lean.Name.anonymous, PProd.fst, List.cons, Lean.Name.str, Lean.Name.num, BEq.beq, Lean.MacroScopesView.mk, Lean.Name, Lean.Name.mkStr, Lean.Name.mkNum, panic, List.nil]]
[Lean.Server.Watchdog.initAndRunWatchdogAux,[Bind.bind, MonadReader.read, MonadExcept.tryCatch, Functor.discard, liftM, IO.FS.Stream.readLspNotificationAs, Lean.Server.Watchdog.ServerContext.hIn, Lean.Lsp.InitializedParams, Lean.Server.Watchdog.runClientTask, Lean.Server.Watchdog.mainLoop, Lean.Server.Watchdog.shutdown, MonadExcept.throw, IO.FS.Stream.readLspMessage, Pure.pure, Lean.JsonRpc.Message.notification, Option.none]]
[Lean.MacroScopesView.review,[Unit.unit, Lean.Name, Lean.MacroScopesView.scopes, Lean.MacroScopesView.name, List.foldl, Lean.Name.mkNum]]
[Lean.DeclarationRange.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.DeclarationRange.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.num.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.numLit.formatter]]
[Lean.PrettyPrinter.Formatter.sepBy1NoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.sepByNoAntiquot.formatter]]
[Lean.Meta.DefaultInstances.priorities,[]]
[Lean.Parser.Tactic.equivRw,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.Parser.Term.haveDecl.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.haveIdDecl.formatter, Lean.Parser.Term.letPatDecl.formatter, Lean.Parser.Term.haveEqnsDecl.formatter, Bool.false]]
[Set.instEmptyCollectionSet,[EmptyCollection.mk, Eq, Bool.false, Bool.true]]
[min_eq_left_of_lt,[min_eq_left, le_of_lt]]
[Nat.max,[ite, LE.le]]
[Lean.RecursorVal.getFirstMinorIdx,[HAdd.hAdd, Lean.RecursorVal.numParams, Lean.RecursorVal.numMotives]]
[String.toList,[String.data]]
[Nat.coprime.mul_right,[Nat.coprime.symm, Nat.coprime.mul]]
[Std.PersistentArray.foldrM,[Bind.bind, Array.foldrM, Std.PersistentArray.tail, Array.size, OfNat.ofNat, Std.PersistentArray.root]]
[Lean.Parser.Command.openSimple.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.many1.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkColGt.formatter, Lean.Parser.ident.formatter]]
[Lean.Parser.Command.ctor.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declModifiers.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.inferMod.parenthesizer, Lean.Parser.Command.optDeclSig.parenthesizer]]
[Lean.Elab.Command.getBracketedBinderIds,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, List.toArray, List.nil, List.cons, Lean.Syntax.getId]]
[Lean.Lsp.instFromJsonSemanticTokensRangeParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Range, Pure.pure, Lean.Lsp.SemanticTokensRangeParams.mk]]
[System.FilePath.noConfusionType,[]]
[Lean.Parser.ParserContext.resolveName,[Lean.ResolveName.resolveGlobalName, Lean.Parser.ParserModuleContext.env, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserModuleContext.currNamespace, Lean.Parser.ParserModuleContext.openDecls]]
[Lean.Parser.Tactic.tacticInfer_instance,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.ToJson.noConfusionType,[]]
[UInt64.toNat,[Fin.val, UInt64.val]]
[Lean.Meta.introNCore,[Bind.bind, Lean.Meta.getHygienicIntro, ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Pure.pure, Prod.mk, List.toArray, List.nil, Lean.Meta.withMVarContext, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType, Lean.MonadLCtx.getLCtx, Lean.Meta.MetaM, Prod, Array, Lean.FVarId, Lean.MVarId, Array.map, Lean.Expr.fvarId!, Unit.unit, Lean.Name, List, and, not, List.cons, bne, Lean.Name.mkSimple, liftM, Lean.Core.mkFreshUserName, Lean.LocalContext.getUnusedName]]
[ReprTuple.reprTuple,[]]
[ByteArray.forIn.loop,[Pure.pure]]
[Lean.Elab.levelMVarToParamPreDecls,[StateRefT'.run', Array.mapM, Bind.bind, Lean.Elab.Term.levelMVarToParam', Lean.Elab.PreDefinition.type, Lean.Elab.PreDefinition.value, Pure.pure, Lean.Elab.PreDefinition.mk, Lean.Elab.PreDefinition.ref, Lean.Elab.PreDefinition.kind, Lean.Elab.PreDefinition.levelParams, Lean.Elab.PreDefinition.modifiers, Lean.Elab.PreDefinition.declName, OfNat.ofNat]]
[Lean.IR.EmitC.emitFileFooter,[Lean.IR.EmitC.emitLns, List.cons, List.nil]]
[Lean.PrettyPrinter.Parenthesizer.dbgTraceState.parenthesizer,[]]
[Substring.foldl,[String.foldlAux]]
[Function.inv_fun_comp,[funext, Function.left_inverse_inv_fun]]
[LawfulMonad.pure_bind,[]]
[Function.inv_fun_on_eq,[And.right, Function.inv_fun_on_pos]]
[Substring.trimRight,[Substring.dropRightWhile, Char.isWhitespace]]
[Lean.IR.Checker.getType,[Bind.bind, MonadReader.read, Unit.unit, Lean.IR.Checker.M, Lean.IR.IRType, Lean.IR.LocalContext.getType, Lean.IR.Checker.CheckerContext.localCtx, Pure.pure, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Function.bijective_iff_exists_unique,[Iff.intro, ExistsUnique, Eq, Exists.intro, And.intro, Function.bijective.injective, Eq.trans, Eq.symm, unique_of_exists_unique, rfl, ExistsUnique.exists]]
[Lean.ImportState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.QuotKind.noConfusion,[noConfusionEnum, Lean.QuotKind.toCtorIdx]]
[ForM.noConfusionType,[]]
[Lean.Parser.Tactic.generalizeProofs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.binderIdent, Lean.Parser.Tactic.location]]
[instDecidableOr,[Decidable, Or, Decidable.isTrue, Or.inl, Or.inr, Decidable.isFalse, instDecidableOr.proof_1]]
[StateCpsT.runK_monadLift,[rfl]]
[unexpandListCons,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, Unit.unit]]
[Array.size_push,[List.length_concat, Array.data]]
[List.mem_map_of_injective,[Iff.intro, Mem.mem, List.mem_map_of_mem]]
[decidableLt_of_decidableLe.proof_1,[not_le_of_gt]]
[max_eq_right_of_lt,[max_eq_right, le_of_lt]]
[Lean.instFromJsonString,[Lean.FromJson.mk, Lean.Json.getStr?]]
[instBEq,[BEq.mk, Decidable.decide, Eq]]
[Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.term,[]]
[Lean.SMap.empty,[Lean.SMap.mk]]
[Lean.Meta.ReduceMatcherResult.partialApp.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Tactic.unfoldProjs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.PrettyPrinter.Parenthesizer.sepBy1NoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.sepByNoAntiquot.parenthesizer]]
[Lean.Widget.Lean.Widget.InteractiveHypothesis.instFromJsonRpcEncodingPacket,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Array, String, Lean.Widget.TaggedText, Option, Bool, Pure.pure]]
[Lean.PrettyPrinter.Parenthesizer.interpretParserDescr,[Lean.Core.CoreM, Lean.PrettyPrinter.Parenthesizer, liftM, Lean.Parser.getConstAlias, Lean.PrettyPrinter.Parenthesizer.parenthesizerAliasesRef, Bind.bind, Lean.Parser.getUnaryAlias, Lean.PrettyPrinter.Parenthesizer.interpretParserDescr, Pure.pure, Lean.Parser.getBinaryAlias, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.Parser.sepBy.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Lean.ParserCompiler.CombinatorAttribute.runDeclFor, Lean.PrettyPrinter.combinatorParenthesizerAttribute, Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer]]
[Lean.Name.mangle,[HAppend.hAppend, Unit.unit, String, Lean.Name.str, Lean.Name.num, PProd.fst, ToString.toString]]
[Lean.Elab.Visibility.toCtorIdx,[OfNat.ofNat]]
[Lean.IR.EmitC.emitBoxFn,[Unit.unit, Lean.IR.IRType.uint8, Lean.IR.IRType.uint16, Lean.IR.IRType.irrelevant, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.struct, Lean.IR.IRType.union, Lean.IR.EmitC.M, Unit, Lean.IR.EmitC.emit]]
[Array.partition,[Id.run, Bind.bind, ForIn.forIn, MProd.mk, ite, Eq, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, Id, Prod, Array, Prod.mk]]
[Lean.ParserCompiler.CombinatorAttribute.runDeclFor,[Bind.bind, Lean.MonadEnv.getEnv, Option.none, Lean.Core.CoreM, Lean.ParserCompiler.CombinatorAttribute.getDeclFor?, Lean.evalConst, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.AttributeImplCore.name, Lean.AttributeImpl.toAttributeImplCore, Lean.ParserCompiler.CombinatorAttribute.impl]]
[Lean.Meta.SynthInstance.tryResolve,[Lean.traceCtx, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.withMCtx, liftM, Lean.Meta.SynthInstance.tryResolveCore]]
[Lean.IR.Arg.irrelevant.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Int.ofNat_mul_subNatNat,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HMul.hMul, Int.ofNat, Nat.zero_eq, Int.ofNat_zero, Int.subNatNat, Int.zero_mul, Nat.zero_mul, Int.sub_nat_self, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true, Eq.symm]]
[Lean.instInhabitedClosedTermCache,[Inhabited.mk, Lean.ClosedTermCache.mk, arbitrary]]
[Lean.Widget.MsgEmbed.noConfusionType,[]]
[And.imp_left,[And.imp, id]]
[Lean.MonadLCtx.noConfusionType,[]]
[Lean.Elab.Term.toParserDescr.resolveParserName,[Bind.bind, MonadExcept.tryCatch, Lean.Elab.resolveGlobalConstWithInfos, Option.none, Lean.MonadEnv.getEnv, Pure.pure, List.filterMap, Unit.unit, Option, Prod, Lean.Name, Bool, Lean.Environment.find?, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Name.anonymous, Lean.Name.str, dite, Eq, Eq.symm, Lean.Name.num, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.ConstantInfo.type, Option.some, Prod.mk, Bool.false, Bool.true, DoResultPR.pure, PUnit.unit, DoResultPR.return, List.nil, Lean.Elab.Term.ToParserDescrM, List]]
[Lean.IR.UnreachableBranches.inferStep,[Bind.bind, MonadReader.read, modify, Lean.IR.UnreachableBranches.InterpState.mk, Array.map, EmptyCollection.emptyCollection, Lean.IR.UnreachableBranches.InterpContext.decls, Lean.IR.UnreachableBranches.InterpState.funVals, Nat.foldM, Lean.IR.UnreachableBranches.M, Bool, Array.getOp, MonadState.get, MonadWithReader.withReader, Lean.IR.UnreachableBranches.InterpContext.mk, Lean.IR.UnreachableBranches.InterpContext.env, Lean.IR.UnreachableBranches.InterpContext.lctx, Array.forM, Lean.IR.UnreachableBranches.updateVarAssignment, Lean.IR.Param.x, Lean.IR.UnreachableBranches.Value.top, OfNat.ofNat, Array.size, Lean.IR.UnreachableBranches.interpFnBody, Pure.pure, or, bne, Bool.false]]
[SubNegMonoid.noConfusionType,[]]
[Lean.ClosedTermCache.noConfusionType,[]]
[Lean.Server.FileWorker.EditableDocument.meta,[]]
[Lean.PrettyPrinter.Parenthesizer,[Lean.PrettyPrinter.ParenthesizerM, Unit]]
[Nat.mod_self,[Eq.mpr, Eq.refl, Eq, HMod.hMod, OfNat.ofNat, Nat.mod_eq_sub_mod, Nat.le_refl, HSub.hSub, Nat.sub_self, Nat.zero_mod, rfl]]
[Equiv.self_comp_symm,[funext, Equiv.apply_symm_apply]]
[Lean.DefinitionVal.noConfusionType,[]]
[EStateM.map,[EStateM.Result, EStateM.Result.ok, EStateM.Result.error]]
[Lean.Lsp.DocumentHighlightParams.mk.inj,[]]
[Lean.Elab.Term.StructInst.Struct.fields,[Lean.Elab.Term.StructInst.Fields]]
[Lean.IR.Checker.markIndex,[Bind.bind, MonadState.get, ite, Eq, Std.RBTree.contains, Lean.IR.Checker.CheckerState.foundVars, Bool.true, MonadExcept.throw, HAppend.hAppend, ToString.toString, Pure.pure, PUnit.unit]]
[Lean.MetavarContext.addExprMVarDeclExp,[Lean.MetavarContext.addExprMVarDecl, OfNat.ofNat]]
[Lean.collectFVars,[Lean.CollectFVars.main]]
[Lean.Elab.Term.elabLetDeclCore,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Elab.Term.elabLetDeclAux, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, List.nil, Lean.Elab.Term.withMacroExpansion, Lean.Elab.Term.elabTerm, Lean.Elab.liftMacroM, Lean.Elab.Term.expandLetEqnsDecl, Lean.Elab.throwUnsupportedSyntax]]
[Prod.forall,[Iff.intro, Prod.mk]]
[Lean.Parser.ParserCategory.behavior,[]]
[Lean.Meta.forEachExpr,[Lean.Meta.forEachExpr', Bind.bind, Pure.pure, Bool.true]]
[Lean.Server.FileWorker.SemanticTokensState.mk.inj,[And.intro]]
[Lean.Parser.Term.noMatch,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.const, Bool.false]]
[Lean.Parser.Term.borrowed,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.leadPrec]]
[Lean.Elab.Term.Do.Code.ite.inj,[And.intro]]
[Lean.Parser.Tactic.tacticDestruct_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Subtype.forall,[Iff.intro, Subtype.mk]]
[Std.PersistentHashMap.instInhabitedEntry,[Inhabited.mk, Std.PersistentHashMap.Entry.null]]
[Lean.Level.PP.Result.offset.inj,[And.intro]]
[Lean.Meta.GeneralizeTelescope.Entry.type,[]]
[instMonadControlT_1,[MonadControlT.mk, Pure.pure]]
[Lean.Lsp.RpcKeepAliveParams.noConfusionType,[]]
[Int.negOfNat_mul_negSucc_ofNat,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Int.negOfNat, Int.negSucc, Int.ofNat, Nat.succ, Int.mul_comm, Int.negSucc_ofNat_mul_negOfNat, Nat.mul_comm, rfl]]
[Lean.MessageData.ofArray,[Lean.MessageData.ofList, Array.toList]]
[Lean.Compiler.SpecArgKind.noConfusionType,[noConfusionTypeEnum, Lean.Compiler.SpecArgKind.toCtorIdx]]
[Lean.Parser.withOpenDeclFn,[ite, GT.gt, Array.size, Lean.Parser.ParserState.stxStack, OfNat.ofNat, Lean.Parser.withOpenDeclFnCore]]
[UInt16.land,[UInt16.mk, Fin.land, UInt16.val]]
[Lean.IR.Decl.expandResetReuse,[Lean.IR.Decl.normalizeIds, Lean.IR.ExpandResetReuse.main]]
[List.append'_eq_append,[Eq, List.append', HAppend.hAppend, rfl, of_eq_true, Eq.trans, congr, congrArg, List.cons, PProd.fst, List.cons_append, eq_self]]
[Lean.Elab.throwAutoBoundImplicitLocal,[MonadExcept.throw, Lean.Exception.internal, Lean.Elab.autoBoundImplicitExceptionId, Lean.KVMap.insert, Lean.KVMap.empty, Lean.Name.mkStr, Lean.Name.anonymous, Lean.DataValue.ofName]]
[Lean.Meta.Simp.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Simp.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Tactic.evalTacticSeq,[Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat]]
[Function.surjective_iff_has_right_inverse,[Iff.intro, Function.surjective.has_right_inverse, Function.has_right_inverse.surjective]]
[List.disjoint_of_subset_left,[]]
[Lean.Elab.Command.StructCtorView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.notFollowedByCategoryTokenFn,[Unit.unit, Lean.Parser.ParserState, Lean.Parser.getCategory, Lean.Parser.ParserState.mkUnexpectedError, HAppend.hAppend, ToString.toString, List.nil, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, ite, Eq, and, Decidable.decide, GT.gt, Lean.Parser.ParserContext.quotDepth, OfNat.ofNat, BEq.beq, Bool.true, Option.none, Std.RBMap.find?, Lean.Parser.PrattParsingTables.leadingTable, Lean.Parser.ParserCategory.tables, Lean.Name.mkSimple]]
[Lean.LocalInstance.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.LocalInstance.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.SavedState.meta,[]]
[Lean.Occurrences.isAll,[Unit.unit, Lean.Occurrences.pos, Lean.Occurrences.neg, Bool, Bool.true, Bool.false]]
[Lean.IR.ExplicitBoxing.boxArgsIfNeeded,[Bind.bind, Lean.IR.ExplicitBoxing.castArgsIfNeededAux, Lean.IR.IRType.object, Lean.IR.ExplicitBoxing.M, Lean.IR.FnBody, Pure.pure, Lean.IR.reshape]]
[instInhabitedList,[Inhabited.mk, List.nil]]
[instToBoolOption,[ToBool.mk, Option.toBool]]
[Lean.PrettyPrinter.Delaborator.instAlternativeDelabM,[Alternative.mk, Lean.PrettyPrinter.Delaborator.failure, Lean.PrettyPrinter.Delaborator.orElse]]
[Equiv.perm,[Equiv]]
[Lean.Elab.Term.getLetRecsToLift,[Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Term.State.letRecsToLift]]
[IO.FS.lines,[Bind.bind, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.false, List.toArray, List.nil, IO.FS.lines.read]]
[Lean.KernelException.typeExpected.inj,[And.intro]]
[Lean.Syntax.ident.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.coprime_comm,[Iff.intro, Nat.coprime.symm]]
[Lean.IR.Borrow.collectExpr,[Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Lean.IR.Borrow.M, Unit, SeqRight.seqRight, Lean.IR.Borrow.ownVar, Lean.IR.Borrow.ownArgsIfParam, Bind.bind, Lean.IR.Borrow.isOwned, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.IR.Borrow.getParamInfo, Lean.IR.Borrow.ParamMap.Key.decl, Lean.IR.Borrow.ownArgsUsingParams, Lean.IR.Borrow.ownArgs, Unit.unit]]
[Lean.Server.FileWorker.initializeWorker,[Bind.bind, Lean.Server.FileWorker.compileHeader, IO, Prod, Lean.Server.FileWorker.WorkerContext, Lean.Server.FileWorker.WorkerState, Lean.Server.FileWorker.CancelToken.new, Lean.Server.FileWorker.unfoldCmdSnaps, Bool.true, Pure.pure, Prod.mk, Lean.Server.FileWorker.WorkerState.mk, Std.RBMap.empty]]
[Lean.Parser.ParserContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[plift.noConfusionType,[]]
[Lean.IR.IRType.uint64.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Int.decEq.proof_2,[absurd]]
[Lean.Parser.scientificLitFn,[ite, Eq, and, not, Lean.Parser.ParserState.hasError, Lean.Syntax.isOfKind, Array.back, Lean.Parser.ParserState.stxStack, Lean.scientificLitKind, Bool.true, Lean.Parser.ParserState.mkErrorAt, Option.some]]
[AddCommMonoid.toAddMonoid,[]]
[System.FilePath.withExtension,[Unit.unit, System.FilePath, System.FilePath.fileStem, System.FilePath.withFileName, ite, Eq, String.isEmpty, Bool.true, HAppend.hAppend]]
[ST,[EST, Empty]]
[Lean.KeyedDeclsAttribute.OLeanEntry.noConfusionType,[]]
[Lean.Meta.withNewBinderInfos,[Lean.Meta.mapMetaM, Bind.bind, Lean.MonadLCtx.getLCtx, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.localInstances, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth]]
[«term-_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[mul_right_inj,[Iff.intro, mul_left_cancel, congrArg, HMul.hMul]]
[Int.eq_zero_ofNatAbs_eq_zero,[Eq, OfNat.ofNat, congr_arg, Int.ofNat, absurd, Nat.succ_ne_zero]]
[AddMonoid.nsmul_succ',[]]
[Set.instMemSet,[Mem.mk, Set.mem]]
[Lean.Meta.mkHEq,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getLevel, Pure.pure, Lean.mkApp4, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil]]
[instLTNat,[LT.mk, Nat.lt]]
[tacticAnyGoals_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser]]
[Decidable.eq_or_ne,[dec_em, Eq]]
[Int.decEq.proof_1,[rfl]]
[Lean.Elab.Attribute.name,[]]
[Subsingleton.elim.proof_1,[Subsingleton.allEq]]
[instModUInt16,[Mod.mk, UInt16.mod]]
[Lean.Parser.Tactic.Conv.convSkip,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.IR.ExplicitRC.VarInfo.consume,[]]
[Lean.Meta.SavedState.noConfusionType,[]]
[Lean.Meta.getMatcherInfoCore?,[Lean.Meta.Match.Extension.getMatcherInfo?]]
[Lean.Meta.IndPredBelow.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.IndPredBelow.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Function.surjective.of_comp_iff',[Iff.intro, Exists, Eq, Exists.intro, Function.bijective.injective, Function.surjective.comp, Function.bijective.surjective]]
[Lean.Core.CoreM.run',[Functor.map, Prod.fst, Lean.Core.CoreM.run]]
[Int.instCommRingInt,[CommRing.mk, Int.mul_comm]]
[Lean.MetavarContext.getLevelAssignment?,[Std.PersistentHashMap.find?, Lean.MetavarContext.lAssignment]]
[Lean.Meta.withConfig,[Lean.Meta.mapMetaM, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.lctx, Lean.Meta.Context.localInstances, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth]]
[Lean.Elab.Term.StructInst.ExplicitSourceInfo.stx,[]]
[List.leftpad_suffix,[Exists.intro, List.repeat, HSub.hSub, List.length, rfl]]
[USize.instSemiringUSize.proof_10,[rfl]]
[fix2,[fixCore2, arbitrary]]
[Lean.MetavarContext.UnivMVarParamResult.noConfusionType,[]]
[And.assoc,[Iff.intro, And, And.intro]]
[exists_congr,[Iff.intro, exists_imp_exists, Iff.mp, Iff.mpr]]
[Int.natAbs_pos_of_ne_zero,[Or.resolve_left, Nat.eq_zero_or_pos, Int.natAbs, mt, Int.eq_zero_ofNatAbs_eq_zero]]
[Fin.nsmuls_eq,[Eq, HMul.hMul, Fin.ofNat', Fin.size_positive', Fin.val, Fin.eq_of_val_eq, Eq.mpr, congrFun, congrArg, Fin.mul_def, Fin.mk, HMod.hMod, Nat.mod_lt, Eq.refl, Eq.symm, Nat.mod_eq_of_lt, Nat.mul_mod, rfl]]
[USize.ofNat32,[USize.mk, Fin.mk, USize.ofNat32.proof_1]]
[Lean.Widget.exprToInteractiveExplicit,[Bind.bind, Lean.Widget.formatExplicitInfos, Lean.Meta.MetaM, Lean.Widget.CodeWithInfos, Lean.MonadEnv.getEnv, Lean.MonadMCtx.getMCtx, Lean.MonadOptions.getOptions, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, Pure.pure, Lean.Widget.tagExprInfos]]
[Lean.Parser.Tactic.guardExprEq,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[Std.ShareCommonT.run,[StateT.run', Std.ShareCommon.State.empty]]
[Lean.IR.Borrow.applyParamMap,[Lean.IR.Borrow.ApplyParamMap.visitDecls]]
[Lean.Lsp.DiagnosticSeverity.noConfusion,[noConfusionEnum, Lean.Lsp.DiagnosticSeverity.toCtorIdx]]
[LinearOrder.decidable_le,[]]
[Equiv.inv_fun_as_coe,[rfl]]
[Lean.Elab.Tactic.run,[Lean.Meta.withMVarContext, Bind.bind, MonadState.get, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, List.nil, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState, tryFinally, Functor.map, Prod.fst, StateRefT'.run, Lean.Elab.Tactic.Context.mk, Lean.Name.anonymous, Lean.Elab.Tactic.State.mk, List.cons]]
[Lean.Meta.NormNum.isNat_rawNat,[rfl]]
[instModUInt64,[Mod.mk, UInt64.mod]]
[HOr.noConfusionType,[]]
[Lean.getPPAnalyze,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze, Lean.Option.defValue]]
[List.erasep_append_right,[Eq, List.erasep, HAppend.hAppend, rfl, of_eq_true, Eq.trans, congr, congrArg, List.cons_append, List.erasep_cons_of_neg, Not, eq_false, And.left, Iff.mp, List.forall_mem_cons, eq_true_of_decide, Eq.refl, Bool.true, List.cons, PProd.fst, And.right, eq_self]]
[Lean.Meta.AbstractMVars.M,[StateM, Lean.Meta.AbstractMVars.State]]
[Lean.ScopedEnvExtension.popScope,[List.nil, List.cons, Lean.Environment, Lean.ScopedEnvExtension.StateStack.stateStack, Lean.PersistentEnvExtension.setState, Lean.ScopedEnvExtension.ext, Lean.ScopedEnvExtension.StateStack.mk, Lean.ScopedEnvExtension.StateStack.scopedEntries, Lean.ScopedEnvExtension.StateStack.newEntries]]
[Decidable.not_imp_symm,[Decidable.by_contradiction, Function.comp]]
[IO.Error.noSuchThing.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Tactic.SavedState.term,[]]
[Nat.le_add_right,[LE.le, HAdd.hAdd, Nat.le_refl, Nat.le_succ_of_le, PProd.fst]]
[Lean.Meta.FVarSubst.get,[Unit.unit, Lean.Expr, Std.AssocList.find?, Lean.Meta.FVarSubst.map, Lean.mkFVar]]
[Lean.PrettyPrinter.Delaborator.ParamKind.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.abel,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.Meta.DiscrTree.mkPath,[Lean.Meta.withReducible, Lean.Meta.DiscrTree.mkPathAux, Bool.true, Array.push]]
[Function.right_id,[rfl]]
[PSigma.skipLeft,[WellFoundedRelation.mk, PSigma.SkipLeft, WellFoundedRelation.rel, PSigma.skipLeft.proof_1]]
[Lean.Parser.ParserModuleContext.currNamespace,[]]
[Lean.Elab.Tactic.liftMetaTacticAux,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Elab.Tactic.TacticM, Lean.Elab.Tactic.replaceMainGoal, Pure.pure]]
[Lean.IR.Borrow.OwnedSet.Key,[Prod, Lean.IR.FunId, Lean.IR.Index]]
[IO.FS.Mode.append.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.BinderInfo.hash,[Unit.unit, UInt64, OfNat.ofNat]]
[WellFoundedRelation.mk.inj,[]]
[Lean.mkAppRev,[Array.foldr, Lean.mkApp, Array.size, OfNat.ofNat]]
[coeSort,[CoeSort.coe]]
[Lean.Parser.ParserState.pushSyntax,[Lean.Parser.ParserState.mk, Array.push, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.pos, Lean.Parser.ParserState.cache, Lean.Parser.ParserState.errorMsg]]
[Lean.Elab.isValidAutoBoundLevelName,[Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Bool, and, Decidable.decide, GT.gt, String.length, OfNat.ofNat, Char.isLower, String.getOp, Substring.all, Substring.drop, String.toSubstring, or, Char.isDigit, Lean.isSubScriptAlnum, BEq.beq, Char.ofNat, Bool.false]]
[Lean.Meta.CongrArgKind.toCtorIdx,[OfNat.ofNat]]
[Lean.Parser.PrattParsingTables.trailingTable,[]]
[Lean.Parser.Command.printAxioms.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.ident.formatter]]
[Lean.Parser.doElemParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.instFromJsonName,[Lean.FromJson.mk, Bind.bind, Lean.Json.getStr?, ite, Eq, BEq.beq, Bool.true, Pure.pure, Lean.Name.anonymous, Lean.Syntax.decodeNameLit, HAppend.hAppend, Option.none, Except, String, Lean.Name, MonadExcept.throw, ToString.toString]]
[Std.ShareCommon.ObjectSet.insert,[Std.HashSet.insert]]
[Lean.Parser.Command.attribute.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.eraseAttr.parenthesizer, Lean.Parser.Term.attrInstance.parenthesizer, Bool.false, Lean.Parser.many1.parenthesizer, Lean.Parser.ident.parenthesizer]]
[Lean.Elab.CompletionInfo.endSection.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.CompletionInfo.endSection, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.acRfl,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Meta.State.mk.inj,[And.intro]]
[Lean.Elab.DefKind.example.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Nat.zero_mul,[Unit.unit, Eq, HMul.hMul, OfNat.ofNat, rfl, Eq.symm, PProd.fst, Nat.mul_succ]]
[Lean.Parser.Term.doFor.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.Term.doForDecl.parenthesizer, Bool.false, Lean.Parser.Term.doSeq.parenthesizer]]
[Lean.Elab.Frontend.setCommandState,[modify, Lean.Elab.Frontend.State.mk, Lean.Elab.Frontend.State.parserState, Lean.Elab.Frontend.State.cmdPos, Lean.Elab.Frontend.State.commands]]
[repr,[Repr.reprPrec, OfNat.ofNat]]
[Lean.Lsp.instFromJsonDiagnosticWith,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.Range, Option, Lean.Lsp.DiagnosticSeverity, Lean.Lsp.DiagnosticCode, String, Array, Lean.Lsp.DiagnosticTag, Lean.Lsp.DiagnosticRelatedInformation, Pure.pure, Lean.Lsp.DiagnosticWith.mk]]
[Lean.Meta.Cases.Context.majorDecl,[]]
[Lean.FileMap.ofString,[OfNat.ofNat, List.toArray, List.cons, List.nil, Lean.FileMap.ofString.loop]]
[Inter.inter,[]]
[Lean.Parser.Term.let.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.letDecl.formatter, Lean.Parser.Term.optSemicolon.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[StateT.pure,[Pure.pure, Prod.mk]]
[Lean.Parser.Term.letIdDecl.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Term.letIdLhs.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Bool.false]]
[Lean.Expr.Data.hasLevelParam,[BEq.beq, UInt64.land, UInt64.shiftRight, OfNat.ofNat]]
[Lean.PrefixTreeNode.ibelow,[And, True]]
[Lean.Lsp.instFromJsonMarkupContent,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.MarkupKind, String, Pure.pure, Lean.Lsp.MarkupContent.mk]]
[Std.instInhabitedPersistentArrayNode,[Inhabited.mk, Std.PersistentArrayNode.node, arbitrary]]
[HAnd.hAnd,[]]
[Lean.JsonRpc.Message.responseError.inj,[And.intro]]
[tryCatchThe,[MonadExceptOf.tryCatch]]
[Lean.Parser.Tactic.intro,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Lean.Meta.ParamInfo.isImplicit,[BEq.beq, Lean.Meta.ParamInfo.binderInfo, Lean.BinderInfo.implicit]]
[Lean.Lsp.DocumentSymbolParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DocumentSymbolParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[List.replicate,[List.nil, List.replicate.loop]]
[Lean.Expr.updateLet!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateLet, Lean.Expr.letE, Lean.Expr.updateLet!.proof_1, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.hasConst,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Environment.contains]]
[Lean.Server.FileWorker.RpcSession.keepAliveTimeMs,[OfNat.ofNat]]
[Lean.Elab.Command.instInhabitedElabHeaderResult,[Inhabited.mk, Lean.Elab.Command.ElabHeaderResult.mk, arbitrary]]
[Lean.TagDeclarationExtension.instInhabitedTagDeclarationExtension,[inferInstanceAs, Inhabited, Lean.SimplePersistentEnvExtension, Lean.Name, Lean.NameSet]]
[ByteSlice.mk.inj,[And.intro]]
[Lean.Meta.ParamInfo.isStrictImplicit,[BEq.beq, Lean.Meta.ParamInfo.binderInfo, Lean.BinderInfo.strictImplicit]]
[Lean.Elab.Tactic.evalDelta,[Bind.bind, Lean.resolveGlobalConstNoOverload, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.withLocation, Lean.Elab.Tactic.deltaLocalDecl, Lean.Elab.Tactic.deltaTarget, liftM, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Syntax.missing]]
[Lean.Elab.Level.instAddMessageContextLevelElabM,[Lean.AddMessageContext.mk, Pure.pure]]
[Lean.EnumAttributes.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.expandBrackedBindersAux,[Array.size, Lean.expandBrackedBindersAux.loop]]
[Option.toMonad,[Unit.unit, Alternative.failure, Pure.pure]]
[Std.ShareCommon.mkObjectPersistentSet,[Std.PersistentHashSet.empty]]
[instDecidableIte,[Decidable, ite]]
[Lean.PersistentExprMap,[Std.PHashMap, Lean.Expr]]
[Lean.Compiler.SpecEntry.cache.inj,[And.intro]]
[Lean.DeclarationRange.noConfusionType,[]]
[Lean.Meta.Closure.mkValueTypeClosureAux,[Bind.bind, liftM, Lean.Meta.resetZetaFVarIds, Lean.Meta.withTrackingZeta, Lean.Meta.Closure.collectExpr, Lean.Meta.Closure.process, Pure.pure, Prod.mk]]
[Lean.Syntax.getAtomVal!,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, String, panicWithPosWithDecl, OfNat.ofNat]]
[Nat.le_of_succ_le_succ,[Nat.pred_le_pred]]
[Lean.Elab.ContextInfo.fileMap,[]]
[Lean.Parser.Command.declId.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Bool.false]]
[Lean.Expr.FindImpl.initCache.proof_1,[lcProof]]
[Nat.eq_zero_of_zero_dvd,[Exists.elim, Eq.trans, Nat.zero_mul]]
[min_assoc,[eq_min, le_trans, min_le_left, min, le_min, min_le_right]]
[npow_eq_pow,[rfl]]
[Lean.Exception.error.inj,[And.intro]]
[Lean.HeadIndex.sort.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[USize.instNumericUSize,[Numeric.mk, USize.mk, Numeric.ofNat]]
[MonadControlT.stM,[]]
[Lean.Meta.Match.Extension.Entry.info,[]]
[Mathlib.Tactic.Ext.«termExtProof%»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Lean.instMonadMCtx,[Lean.MonadMCtx.mk, liftM, Lean.MonadMCtx.getMCtx, Lean.MonadMCtx.modifyMCtx]]
[Lean.Parser.withAntiquotSpliceAndSuffix.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquotSplice.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withoutInfo.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquotSuffixSplice.parenthesizer]]
[instDecidableArrow,[dite, Decidable.isTrue, instDecidableArrow.proof_1, Decidable.isFalse, instDecidableArrow.proof_2, instDecidableArrow.proof_3]]
[Lean.Elab.getPrintMessageEndPos,[Lean.KVMap.getBool, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false]]
[Lean.Core.instInhabitedCoreM,[Inhabited.mk, MonadExcept.throw, arbitrary]]
[Lean.Meta.instInhabitedParamInfo,[Inhabited.mk, Lean.Meta.ParamInfo.mk, arbitrary]]
[Tactic.Cache,[IO.Ref, Sum, Lean.Meta.MetaM, Task, Except, Lean.Exception]]
[Lean.Elab.Term.LetIdDeclView.id,[]]
[Equivalence.noConfusionType,[]]
[Lean.mkMapDeclarationExtension,[Lean.registerSimplePersistentEnvExtension, Lean.SimplePersistentEnvExtensionDescr.mk, Lean.NameMap.insert, Prod.fst, Prod.snd, EmptyCollection.emptyCollection, Array.qsort, List.toArray, Lean.Name.quickLt, OfNat.ofNat, HSub.hSub, Array.size]]
[HEq.symm,[HEq.ndrecOn, HEq.refl]]
[Lean.IR.UnreachableBranches.InterpState.funVals,[]]
[PSum.inr.inj,[]]
[Lean.CollectMVars.Visitor,[Lean.CollectMVars.State]]
[Lean.Lsp.TextDocumentEdit.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.Quotation.MatchResult.covered.inj,[And.intro]]
[Lean.Meta.SimpLemma.post,[]]
[Lean.Parser.Tactic.eapply,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.TagAttribute.getDecls,[Id.run, Bind.bind, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield]]
[Array.foldlM.proof_1,[Nat.le_refl, Array.size]]
[Lean.Parser.ParserCategory.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Simp.simp.withNewLemmas,[Bind.bind, Lean.Meta.Simp.getConfig, ite, Eq, Lean.Meta.Simp.Config.contextual, Bool.true, Lean.Meta.Simp.getSimpLemmas, ForIn.forIn, MProd.mk, liftM, Lean.Meta.isProof, Lean.Meta.SimpLemmas.add, List.toArray, List.nil, Bool.false, OfNat.ofNat, Option.none, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Meta.Simp.M, Lean.Meta.Simp.withSimpLemmas]]
[Lean.Parser.Command.omit,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[«term_*>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.Term.elabChoice,[Bind.bind, List.nil, Bool.false, List.toArray, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.Elab.Term.TermElabM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Pure.pure, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError]]
[Fin.mul_def,[Eq, HMul.hMul, Fin.mk, HMod.hMod, Fin.val, Nat.mod_lt, Fin.size_positive, rfl]]
[ExistsUnique.elim,[Exists.elim, And.left, And.right]]
[Lean.Json.instToJsonStructured,[Lean.ToJson.mk, Lean.Json, Lean.Json.arr, Lean.Json.obj]]
[Lean.Elab.Command.StructFieldKind.noConfusion,[noConfusionEnum, Lean.Elab.Command.StructFieldKind.toCtorIdx]]
[Lean.JsonNumber.mk.inj,[And.intro]]
[Lean.Lsp.Hover.mk.inj,[And.intro]]
[Lean.Elab.throwPostpone,[MonadExcept.throw, Lean.Exception.internal, Lean.Elab.postponeExceptionId, Lean.KVMap.mk]]
[Lean.Meta.getElimInfo,[Bind.bind, Lean.getConstInfo, Lean.Meta.forallTelescopeReducing, Lean.ConstantInfo.type, ite, Eq, and, Lean.Expr.isFVar, Array.all, OfNat.ofNat, Array.size, Decidable.decide, GT.gt, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr]]
[Lean.Parser.PrattParsingTables.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.PrattParsingTables.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.Checker.getDecl,[Bind.bind, MonadReader.read, Unit.unit, Lean.IR.Checker.M, Lean.IR.Decl, Lean.IR.findEnvDecl', Lean.IR.Checker.CheckerContext.env, Lean.IR.Checker.CheckerContext.decls, MonadExcept.throw, HAppend.hAppend, ToString.toString, Pure.pure]]
[Lean.Xml.Content.Character.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Tactic.Ring.instInhabitedHornerExpr,[Inhabited.mk, Tactic.Ring.HornerExpr.const, Lean.mkRawNatLit, OfNat.ofNat]]
[instMonadState,[MonadState.mk, getThe, MonadStateOf.set, MonadStateOf.modifyGet]]
[Lean.ReducibilityHints.regular.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[EStateM.tryCatch,[EStateM.Result.ok, EStateM.Result, EStateM.Backtrackable.restore]]
[Lean.Parser.tacticParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Widget.Lean.Widget.InteractiveGoals.instToJsonRpcEncodingPacket,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil]]
[Classical.choose,[Subtype.val, Classical.indefiniteDescription]]
[imp_or_distrib,[Decidable.imp_or_distrib]]
[Lean.Parser.Module.header.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Module.prelude.formatter, Lean.ppLine.formatter, Lean.Parser.many.formatter, Lean.Parser.Module.import.formatter]]
[UInt16.add_def,[rfl]]
[ExceptCpsT.runCatch_lift,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, bind_pure, eq_self]]
[Lean.Elab.Term.BinderView.id,[]]
[Array.foldrM,[dite, LE.le, Array.size, ite, LT.lt, Pure.pure, Nat.le_refl, Array.foldrM.fold]]
[Lean.Elab.Term.LetRecToLift.declName,[]]
[Lean.PLevelSet,[Lean.PersistentLevelSet]]
[Lean.Elab.Tactic.Conv.updateLhs,[Bind.bind, Lean.Elab.Tactic.Conv.getRhs, liftM, Lean.Meta.mkEq, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.mkLHSGoal, Lean.Name.anonymous, Lean.Elab.Tactic.getMainGoal, Lean.Meta.mkEqTrans, Lean.Meta.assignExprMVar, Lean.Elab.Tactic.replaceMainGoal, List.cons, Lean.Expr.mvarId!, List.nil]]
[Lean.Parser.Term.dbgTrace.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.interpolatedStr.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Lean.Parser.Term.optSemicolon.formatter]]
[Lean.Meta.instToStringRecursorUnivLevelPos,[ToString.mk, Unit.unit, String, ToString.toString]]
[Lean.Level.Data.depth,[UInt64.toUInt32, UInt64.shiftRight, OfNat.ofNat]]
[Lean.Parser.Command.namespace.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter]]
[Lean.Parser.Command.check_failure.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter]]
[Lean.Meta.SynthInstance.addAnswer,[Bind.bind, MonadReader.read, ite, GE.ge, Lean.Meta.SynthInstance.ConsumerNode.size, Lean.Meta.SynthInstance.Context.maxResultSize, Lean.traceM, Lean.Name.mkStr, Lean.Name.anonymous, liftM, Lean.Meta.inferType, Lean.Meta.SynthInstance.ConsumerNode.mvar, Pure.pure, HAppend.hAppend, Lean.ToMessageData.toMessageData, Unit.unit, Lean.Meta.withMCtx, Lean.Meta.SynthInstance.ConsumerNode.mctx, Lean.Meta.instantiateMVars, Lean.isTracingEnabledFor, Eq, Bool.true, Lean.addTrace, PUnit.unit, Lean.Meta.SynthInstance.getEntry, Lean.Meta.SynthInstance.isNewAnswer, Lean.Meta.SynthInstance.TableEntry.answers, modify, Lean.Meta.SynthInstance.State.mk, Lean.Meta.SynthInstance.State.result?, Lean.Meta.SynthInstance.State.generatorStack, Lean.Meta.SynthInstance.State.resumeStack, Std.HashMap.insert, Lean.Meta.SynthInstance.State.tableEntries, Array.forM, Lean.Meta.SynthInstance.wakeUp, Lean.Meta.SynthInstance.TableEntry.waiters, OfNat.ofNat, Array.size]]
[Lean.Compiler.NumScalarTypeInfo.noConfusionType,[]]
[Lean.Meta.InjectionResultCore.subgoal.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.InjectionResultCore.subgoal, Eq.symm, eq_of_heq, HEq.refl]]
[List.enumFrom,[List, Prod, Nat, List.nil, List.cons, Prod.mk, PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[Lean.Literal.natVal.injEq,[Eq.propIntro, Eq.refl, Lean.Literal.natVal, Eq.symm, eq_of_heq, HEq.refl]]
[instSemiringFin,[Semiring.mk, instSemiringFin.proof_6, HMul.hMul, Fin.ofNat', Fin.size_positive, instSemiringFin.proof_7, instSemiringFin.proof_8, instSemiringFin.proof_9, instSemiringFin.proof_10, instSemiringFin.proof_11, instSemiringFin.proof_12, instSemiringFin.proof_13, instSemiringFin.proof_14]]
[Lean.Level.succ.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.MonadInfoTree.getInfoState,[]]
[Lean.Lsp.SymbolKind.property.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[instMonadLiftSTEST,[MonadLift.mk, EStateM.Result, EStateM.Result.ok]]
[Lean.Server.FileWorker.instCoeErrorElabTaskError,[Coe.mk, Lean.Server.FileWorker.ElabTaskError.ioError]]
[List.toStringAux,[Bool.false, Bool.true, String, HAppend.hAppend, ToString.toString, PProd.fst]]
[Lean.Meta.elimMVarDeps,[ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Lean.Meta.liftMkBindingM, Lean.MetavarContext.elimMVarDeps]]
[List.map_eq_nil,[Iff.intro, rfl, Eq.symm, Eq.refl, Eq.mpr, Eq, List.map, List.nil]]
[Lean.Parser.Command.inferMod.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter]]
[Lean.Meta.InstanceEntry.noConfusionType,[]]
[Lean.Parser.FirstTokens.optTokens.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.SemanticTokensParams.textDocument,[]]
[Lean.Widget.CodeToken.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Widget.CodeToken.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.mkLevelMVarEx,[Lean.mkLevelMVar]]
[Std.AssocList.insert,[Std.AssocList.cons]]
[Lean.StructureInfo.structName,[]]
[Lean.PrettyPrinter.Unexpander,[Lean.PrettyPrinter.UnexpandM, Lean.Syntax]]
[Lean.IR.args.alphaEqv,[Array.isEqv, Lean.IR.AlphaEqv.aeqv]]
[Lean.JsonRpc.Request.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonRpc.Request.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.adaptMacro,[Lean.Elab.liftMacroM]]
[UInt8.mod_def,[rfl]]
[Lean.Compiler.mkNatLt,[Lean.mkAppN, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.levelZero, List.nil, List.toArray]]
[Mathlib.Tactic.Lint.formatLemmas,[Bind.bind, Array.mapM, Lean.mkConstWithLevelParams, Pure.pure, Lean.ToMessageData.toMessageData]]
[Array.getLit.proof_1,[Eq.symm]]
[Mathlib.Tactic.Lint.printWarning,[Bind.bind, Lean.mkConstWithLevelParams, Pure.pure, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Std.PersistentArray.instAppendPersistentArray,[Append.mk, Std.PersistentArray.append]]
[Classical.typeDecidable,[PSum, False, Classical.propDecidable, Nonempty, PSum.inl, arbitrary, PSum.inr, Classical.typeDecidable.proof_1]]
[instReprTupleProd,[ReprTuple.mk, List, Std.Format, ReprTuple.reprTuple, List.cons, repr]]
[Lean.Lsp.DiagnosticCode.int.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DiagnosticCode.int, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.instToJsonProgressParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.ProgressParams.token, List.nil, Lean.Lsp.ProgressParams.value]]
[Lean.Lsp.PlainTermGoalParams.noConfusionType,[]]
[Lean.Widget.TaggedText.text.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[FloatArray.foldlM,[dite, LE.le, FloatArray.size, FloatArray.foldlM.proof_1]]
[Lean.IR.FnBody.inc.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.inc, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.ReduceMatcherResult.reduced.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.ReduceMatcherResult.reduced, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.SynthInstance.Waiter.noConfusionType,[]]
[Lean.Server.FileWorker.RefIdent.fvar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.HeadIndex.const.injEq,[Eq.propIntro, Eq.refl, Lean.HeadIndex.const, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.eraseAttr.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.rawIdent.parenthesizer]]
[Lean.Parser.Term.fromTerm.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter]]
[Lean.Meta.Match.MatchEqns.eqnNames,[]]
[Lean.Elab.Term.Do.ToTerm.Kind.nestedBC.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Lsp.Position.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.FileMap.mk.inj,[And.intro]]
[Lean.Elab.Term.elabSorry,[Bind.bind, Lean.Elab.logWarning, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom, Lean.Elab.Term.withMacroExpansion, Lean.Elab.Term.elabTerm, Bool.true]]
[Lean.IR.reshape,[Lean.IR.reshapeAux, Array.size]]
[Lean.Meta.DiscrTree.Key.ctorIdx,[Unit.unit, Nat, OfNat.ofNat]]
[Lean.Elab.Term.Do.Code.joinpoint.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.Quotation.HeadCheck.noConfusionType,[]]
[Lean.Parser.Tactic.matchAlts.parenthesizer,[Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.Tactic.matchRhs.parenthesizer]]
[Nat.strong_induction_on,[Nat.strong_rec_on]]
[Lean.Elab.Info.ofMacroExpansionInfo.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Info.ofMacroExpansionInfo, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.getStructureCtor,[Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.InductiveVal.mk, Lean.ConstantVal.mk, List.nil, List.cons, Bool.true, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.ConstructorVal, Lean.Environment.find?, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.instInhabitedMessageData,[Inhabited.mk, Lean.MessageData.ofFormat, arbitrary]]
[Lean.Elab.Tactic.Location.wildcard.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[And.imp_right,[And.imp, id]]
[Lean.Syntax.ifNode,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Subtype.mk, Lean.Syntax.node, Lean.IsNode.mk, Unit.unit]]
[Lean.Parser.Tactic.piInstance,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Std.ShareCommon.ObjectSet.find?,[Std.HashSet.find?]]
[Lean.Lsp.instFromJsonTextDocumentRegistrationOptions,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, Lean.Lsp.DocumentSelector, Pure.pure, Lean.Lsp.TextDocumentRegistrationOptions.mk]]
[Lean.Elab.Command.expandInCmd,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Lean.Syntax.ibelow,[True, And]]
[Lean.IR.UnreachableBranches.updateCurrFnSummary,[Bind.bind, MonadReader.read, modify, Lean.IR.UnreachableBranches.InterpState.mk, Lean.IR.UnreachableBranches.InterpState.assignments, Std.PersistentArray.modify, Lean.IR.UnreachableBranches.InterpState.funVals, Lean.IR.UnreachableBranches.Value.widening, Lean.IR.UnreachableBranches.InterpContext.env]]
[«term_<|>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instMonadControlOptionT,[MonadControl.mk, Option, liftM, OptionT.run]]
[ReaderT.orElse,[HOrElse.hOrElse, Unit.unit]]
[Lean.IR.Sorry.State.modified,[]]
[Lean.Parser.Command.synth.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter]]
[Lean.RecursorVal.kEx,[Lean.RecursorVal.k]]
[Lean.Elab.Term.Do.Code.reassign.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Name.isAtomic,[Unit.unit, Lean.Name.str, Lean.Name.num, Bool, Bool.true, Bool.false]]
[Lean.Meta.withAtLeastTransparency,[Lean.Meta.withConfig, Lean.Meta.Config.mk, Lean.Meta.Config.foApprox, Lean.Meta.Config.ctxApprox, Lean.Meta.Config.quasiPatternApprox, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct]]
[Lean.Literal.strVal.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt8.xor,[UInt8.mk, Fin.xor, UInt8.val]]
[Lean.JsonRpc.RequestID.str.inj,[]]
[em',[Or.swap, em]]
[Lean.MetavarContext.isExprAssignable,[BEq.beq, Lean.MetavarDecl.depth, Lean.MetavarContext.depth]]
[Lean.IR.LitVal.beq,[Lean.IR.LitVal.num, Lean.IR.LitVal.str, Bool, BEq.beq, Bool.false]]
[coeId,[CoeT.mk]]
[Lean.StructureFieldInfo.lt,[Lean.Name.quickLt, Lean.StructureFieldInfo.fieldName]]
[Lean.Lsp.TypeDefinitionParams.toTextDocumentPositionParams,[]]
[Lean.Parser.Command.elab_rules,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.suppressInsideQuot, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.docComment, Lean.Parser.Term.attrKind, Lean.Parser.symbol, Lean.Parser.Command.optKind, Lean.Parser.ident, Lean.Parser.Term.matchAlts, Lean.Parser.termParser]]
[Lean.Meta.DefEqContext.localInstances,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.higherOrders,[]]
[Lean.LocalContext.renameUserName,[Lean.LocalContext, Unit.unit, Lean.LocalContext.findFromUserName?, Lean.LocalContext.mk, Std.PersistentHashMap.insert, Lean.LocalDecl.fvarId, Std.PersistentArray.set, Lean.LocalDecl.index, Option.some]]
[Lean.Lsp.TextDocumentEdit.textDocument,[]]
[UInt32.instSemiringUInt32.proof_13,[UInt32.eq_of_val_eq, Eq.mpr, congrArg, Eq, Fin.ofNat', HAdd.hAdd, OfNat.ofNat, Fin.size_positive', UInt32.val, Eq.trans, UInt32.mk, UInt32.one_def, UInt32.add_def]]
[Lean.IR.ExplicitRC.addDec,[Lean.IR.FnBody.dec, OfNat.ofNat, Bool.true, Lean.IR.ExplicitRC.VarInfo.persistent]]
[Lean.Elab.Command.CtorView.declName,[]]
[Std.HashSetImp.reinsertAux,[Std.HashSetBucket, Std.HashSetBucket.update, List.cons, Array.uget, Subtype.val]]
[Lean.mkLevelMax,[Lean.Level.max, Lean.Level.mkData, mixHash, OfNat.ofNat, Hashable.hash, HAdd.hAdd, Nat.max, Lean.Level.depth, or, Lean.Level.hasMVar, Lean.Level.hasParam]]
[Lean.mkBVarEx,[Lean.mkBVar]]
[Function.Equiv.symm,[Eq.symm]]
[Lean.Parser.Tactic.squeezeSimpa?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser]]
[Lean.Parser.Tactic.apply',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.Elab.Tactic.withMainContext,[Bind.bind, Lean.Elab.Tactic.getMainGoal, Lean.Meta.withMVarContext]]
[Lean.Meta.SizeOfSpecNested.M,[ReaderT, Lean.Meta.SizeOfSpecNested.Context, Lean.Meta.MetaM]]
[instDecidableArrow.proof_2,[absurd]]
[Lean.Parser.Term.doContinue.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Char.toUpper,[ite, And, GE.ge, OfNat.ofNat, LE.le, Char.ofNat, HSub.hSub]]
[Lean.Server.FileWorker.instBEqGoToKind,[BEq.mk, BEq.beq, Lean.Server.FileWorker.GoToKind.toCtorIdx]]
[Ring.gsmul_neg',[]]
[Lean.Lsp.TextDocumentSyncOptions.mk.inj,[And.intro]]
[Lean.Elab.Term.Context.macroStack,[]]
[Lean.Parsec.hexDigit,[Lean.Parsec.attempt, Bind.bind, Lean.Parsec.anyChar, ite, Or, And, LE.le, Char.ofNat, Pure.pure, Lean.Parsec.fail, ToString.toString]]
[Lean.instInhabitedMVarIdMap,[Inhabited.mk, EmptyCollection.emptyCollection]]
[Lean.NameSet.insert,[Std.RBTree.insert]]
[Nat.land,[Nat.bitwise, and]]
[Lean.Parser.Term.doMatch,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.Term.generalizingParam, Lean.Parser.sepBy1, Lean.Parser.Term.matchDiscr, Bool.false, Lean.Parser.Term.optType, Lean.Parser.Term.doMatchAlts]]
[Mathlib.ExtendedBinder.«term∀ᵉ_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Mathlib.ExtendedBinder.extBinders, Lean.ParserDescr.cat]]
[Lean.Meta.NormNum.isNat_add,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, OfNat.ofNat, Lean.Meta.NormNum.isNat, HAdd.hAdd, ofNat_add]]
[Lean.Widget.InteractiveGoal.type,[]]
[Lean.Parser.Command.structureTk,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[and_assoc,[And.assoc]]
[Lean.KeyedDeclsAttribute.instInhabitedExtensionState,[Inhabited.mk, Lean.KeyedDeclsAttribute.ExtensionState.mk, arbitrary]]
[List.instAppendList,[Append.mk, List.append]]
[Nat.add_comm,[Eq, HAdd.hAdd, Eq.symm, Nat.zero_add]]
[Lean.Syntax.mkNumLit,[Lean.Syntax.mkLit, Lean.numLitKind]]
[Lean.Parser.Term.binderTactic,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.Tactic.tacticSeq]]
[Or.imp_right,[Or.imp, id]]
[Int.instNumericInt,[Numeric.mk, Int.ofNat]]
[Lean.Lsp.ClientInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.ClientInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Array.foldrM.fold.proof_1,[Nat.lt_of_lt_of_le, Nat.lt_succ_self]]
[Lean.Lsp.ReferenceParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[EIO.mapTask,[BaseIO.mapTask, EIO.toBaseIO]]
[Lean.Elab.Tactic.ElimApp.Context.noConfusionType,[]]
[Lean.PrettyPrinter.Formatter.checkLinebreakBefore.formatter,[Pure.pure, Unit.unit]]
[instAddCommGroup.proof_3,[Semiring.nsmul_zero']]
[ST.Ref.h,[]]
[Lean.Server.Snapshots.Snapshot.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.Expr.proj.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.proj, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.instFileSourceSemanticTokensParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.SemanticTokensParams.textDocument]]
[Lean.Meta.Simp.SimpLetCase.nondep.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Reader,[ReaderT, Id]]
[instSemiringFin.proof_1,[Fin.eq_of_val_eq, Eq.mpr, congrFun, congrArg, Eq, Eq.trans, Fin.val, Fin.add_def, OfNat.ofNat, HMod.hMod, HAdd.hAdd, Fin.zero_def, Nat.add_zero, Nat.mod_eq_of_lt, Fin.isLt]]
[Lean.privateToUserName?,[ite, Eq, Lean.isPrivateName, Bool.true, Option.some, Lean.Name.anonymous, Lean.Name.num, Lean.Name, Lean.Name.mkStr, PProd.fst, Option.none]]
[Lean.Meta.MatcherApp.remaining,[]]
[Lean.SCC.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.builtin_initialize.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.visibility.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.Term.typeSpec.parenthesizer, Lean.Parser.Term.leftArrow.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer]]
[Lean.Parser.Term.doIfLet,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat, HOrElse.hOrElse, Lean.Parser.Term.doIfLetPure, Lean.Parser.Term.doIfLetBind, Bool.false]]
[List.disjoint_of_disjoint_cons_left,[List.disjoint_of_subset_left, List.subset_cons]]
[Lean.Server.FileWorker.Reference.mk.inj,[And.intro]]
[Lean.Parser.FirstTokens.tokens.inj,[]]
[List.erasep,[Unit.unit, List, List.nil, ite, List.cons, PProd.fst]]
[if_false,[if_neg, not_false]]
[Lean.Parser.Command.optNamedPrio.formatter,[Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.ppSpace.formatter, Lean.Parser.Command.namedPrio.formatter]]
[Lean.Widget.instInhabitedGetInteractiveDiagnosticsParams,[Inhabited.mk, Lean.Widget.GetInteractiveDiagnosticsParams.mk, arbitrary]]
[Nat.coprime.coprime_mul_right_right,[Nat.coprime.coprime_dvd_right, Nat.dvd_mul_right]]
[Lean.Meta.Simp.Config.proj,[]]
[Lean.Meta.Match.MkMatcherInput.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.JsonNumber.instDecidableLt,[inferInstanceAs, Decidable, Eq, Lean.JsonNumber.lt, Bool.true]]
[Std.PersistentArray.findSomeM?,[Bind.bind, Std.PersistentArray.findSomeMAux, Std.PersistentArray.root, Unit.unit, Option, Array.findSomeM?, Std.PersistentArray.tail, Pure.pure, Option.some]]
[Lean.Server.FileWorker.instBEqRefIdent,[BEq.mk, Lean.Server.FileWorker.RefIdent.const, Lean.Server.FileWorker.RefIdent.fvar, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Lsp.WorkspaceFolder.name,[]]
[instReprAtomFloat,[ReprAtom.mk]]
[Lean.Xml.Parser.digitsToNat,[Array.foldl, HAdd.hAdd, HMul.hMul, OfNat.ofNat, Array.size]]
[Lean.Elab.Term.LetRecDeclView.attrs,[]]
[Lean.mkIdent,[Lean.Syntax.ident, Lean.SourceInfo.none, String.toSubstring, ToString.toString, List.nil]]
[Lean.Compiler.InlineAttributeKind.inlineIfReduce.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.instInhabitedAuxLemmas,[Inhabited.mk, Lean.Meta.AuxLemmas.mk, arbitrary]]
[Task.map,[Task.pure, Task.get]]
[Lean.Meta.Match.Unify.State.noConfusionType,[]]
[List.filterAux,[List, List.reverse, Unit.unit, PProd.fst, List.cons]]
[Lean.casesOnSuffix,[]]
[Lean.Export.Entry.expr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Level.ident,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.ident]]
[Lean.Elab.InfoTree.node.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.InfoTree.node, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.FnBody.resetBody,[Lean.IR.FnBody.setBody, Lean.IR.FnBody.nil]]
[Lean.Meta.DiscrTree.Key.proj.inj,[And.intro]]
[min_comm,[eq_min, min_le_right, min_le_left, le_min]]
[Lean.IR.Decl.elimDead,[Lean.IR.Decl.extern, Lean.IR.Decl, Lean.IR.Decl.updateBody!, Lean.IR.FnBody.elimDead]]
[Lean.Lsp.TextEditBatch,[Array, Lean.Lsp.TextEdit]]
[SeqLeft.seqLeft,[]]
[Lean.Expr.setPPExplicit,[Lean.Expr.setOption, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Parser.Tactic.finish,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.sepBy1]]
[Lean.Server.FileWorker.ElabTaskError.noConfusionType,[]]
[UInt16.ofNat,[UInt16.mk, Fin.ofNat]]
[ForM.forM,[]]
[Lean.Meta.ParamInfo.hasFwdDeps,[]]
[Lean.IR.Decl.noConfusionType,[]]
[Lean.PrettyPrinter.Parenthesizer.pushNone.parenthesizer,[Lean.Syntax.MonadTraverser.goLeft]]
[Function.sometimes_eq,[dif_pos, Nonempty.intro]]
[Lean.Elab.Command.StructCtorView.name,[]]
[Lean.Export.Entry.level.inj,[]]
[exists_of_exists_unique,[Exists.elim, Exists.intro, And.left]]
[Lean.IR.FreeIndices.insertParams,[Array.foldl, Std.RBTree.insert, Lean.IR.VarId.idx, Lean.IR.Param.x, OfNat.ofNat, Array.size]]
[AddCommGroup.noConfusionType,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.inBottomUp,[]]
[Prod.swap_surjective,[Function.right_inverse.surjective, Prod.swap_left_inverse]]
[Lean.Parser.Term.panic.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[unexpandSubtype,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[Option.none.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.CasesSubgoal.mk.inj,[And.intro]]
[Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.uvars,[]]
[Lean.Elab.Term.elabBindersEx,[Lean.Elab.Term.withoutPostponingUniverseConstraints, ite, Eq, Array.isEmpty, Bool.true, List.toArray, List.nil, OfNat.ofNat]]
[USize.instSemiringUSize.proof_9,[rfl]]
[Nat.lt_asymm,[Nat.le_lt_antisymm, Nat.le_of_lt]]
[Lean.unifConstraint,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.symbol]]
[timeCmdElab,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, liftM, IO.monoMsNow, Lean.Elab.Command.elabCommand, Lean.Elab.logInfoAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, HSub.hSub, Lean.Elab.throwUnsupportedSyntax]]
[Lean.IR.Expr.reuse.inj,[And.intro]]
[Lean.InductiveVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.checkOutParams,[Bind.bind, MonadReader.read, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit, ForIn.forIn, PUnit.unit, ite, Eq, BEq.beq, Array.getOp, Lean.BinderInfo.instImplicit, Bool.true, liftM, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.inspectOutParams, Pure.pure, ForInStep.yield]]
[Lean.PrettyPrinter.Parenthesizer.strLitNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken]]
[instReprSum,[Repr.mk, Std.Format, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg]]
[Lean.Elab.Term.MutualClosure.FixPoint.State.modified,[]]
[Lean.PrettyPrinter.Delaborator.OptionsPerPos,[Std.RBMap, Lean.PrettyPrinter.Delaborator.Pos, Lean.Options, Ord.compare]]
[Std.PersistentHashMap.mkEmptyEntriesArray,[Array.mkArray, USize.toNat, Std.PersistentHashMap.branching, Std.PersistentHashMap.Entry.null]]
[Lean.Compiler.NumScalarTypeInfo.ofNatFn,[]]
[Nat.imax,[ite, Eq, OfNat.ofNat, Nat.max]]
[Lean.IR.FnBody.ibelow,[And, True]]
[ExceptT.seqLeft_eq,[]]
[Lean.Lsp.Ipc.collectDiagnostics,[Bind.bind, Lean.Lsp.Ipc.writeRequest, Lean.JsonRpc.Request.mk, Lean.Lsp.WaitForDiagnosticsParams.mk, Lean.Lsp.Ipc.collectDiagnostics.loop]]
[UInt64.mod_def,[rfl]]
[Lean.Lsp.instFromJsonPublishDiagnosticsParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, Option, Int, Array, Lean.Lsp.Diagnostic, Pure.pure, Lean.Lsp.PublishDiagnosticsParams.mk]]
[Thunk.pure,[Thunk.mk]]
[UInt16.val_eq_of_eq,[Eq, UInt16.val, congrArg]]
[Lean.Widget.InteractiveGoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[bfix3,[PProd.fst]]
[Lean.Parser.Command.openRenaming,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.ident, Lean.Parser.symbol, Lean.Parser.sepBy1, Lean.Parser.Command.openRenamingItem, Bool.false]]
[Subtype.heq_iff_coe_heq,[]]
[Lean.Json.Structured.arr.injEq,[Eq.propIntro, Eq.refl, Lean.Json.Structured.arr, Eq.symm, eq_of_heq, HEq.refl]]
[List.get_cons_drop,[Eq.refl, List.length, List.nil, HEq.refl, Eq, List.cons, List.get, List.drop, HAdd.hAdd, OfNat.ofNat, rfl, PProd.fst, Nat.le_of_succ_le_succ, List.length_cons, Nat.add]]
[ExceptT.instLawfulMonadExceptT.proof_1,[LawfulMonad.mk, ExceptT.bind_pure_comp, rfl, ExceptT.ext, of_eq_true, Eq.trans, congrFun, congrArg, Eq, ExceptT.run_bind, Pure.pure, Bind.bind, ExceptT.run_pure, Except, ExceptT.run, Except.error, LawfulMonad.pure_bind, Except.ok, eq_self, Eq.mpr, congr, LawfulMonad.bind_assoc, funext, bind_congr, Eq.symm, Eq.refl]]
[Lean.Meta.Match.MatcherInfo.altNumParams,[]]
[default.sizeOf,[OfNat.ofNat]]
[Lean.Meta.DefaultInstanceEntry.className,[]]
[Lean.ConstantInfo.defnInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.DiagnosticRelatedInformation.location,[]]
[eq_rec_constant,[rfl, Eq.symm, eq_of_heq, Eq.refl, HEq.refl]]
[Std.instInhabitedFormat,[Inhabited.mk, Std.Format.nil]]
[withPtrEqUnsafe,[ite, Eq, BEq.beq, ptrAddrUnsafe, Bool.true, Unit.unit]]
[Lean.Elab.Term.FunBinders.State.mk.inj,[And.intro]]
[decidableEq_of_decidableLe.proof_2,[le_refl]]
[«term_++_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Command.exit.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.AttributeImpl.add,[]]
[List.beq,[Unit.unit, List.nil, List.cons, Bool, Bool.true, and, BEq.beq, PProd.fst, Bool.false]]
[Lean.Parser.Command.namespace.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer]]
[Lean.Lsp.instFromJsonVersionedTextDocumentIdentifier,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, Option, Nat, Pure.pure, Lean.Lsp.VersionedTextDocumentIdentifier.mk]]
[Lean.IR.Borrow.markModified,[modify, Lean.IR.Borrow.BorrowInfState.mk, Lean.IR.Borrow.BorrowInfState.owned, Bool.true, Lean.IR.Borrow.BorrowInfState.paramMap]]
[Lean.MetavarContext.MkBindingM,[ReaderT, Lean.LocalContext, Lean.MetavarContext.MkBinding.MCore]]
[right_inverse,[Eq]]
[Option.toLOption,[Unit.unit, Lean.LOption, Lean.LOption.none, Lean.LOption.some]]
[Lean.TraceElem.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.TraceElem.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.ScopedEnvExtension.ScopedEntries.noConfusionType,[]]
[Lean.Elab.Term.Do.ToCodeBlock.mkForInBody,[Bind.bind, MonadReader.read, Lean.Elab.liftMacroM, Lean.Elab.Term.Do.ToTerm.run, Lean.Elab.Term.Do.CodeBlock.code, Lean.Elab.Term.Do.ToCodeBlock.Context.m, ite, Eq, Lean.Elab.Term.Do.hasReturn, Bool.true, Lean.Elab.Term.Do.ToTerm.Kind.forInWithReturn, Lean.Elab.Term.Do.ToTerm.Kind.forIn, Pure.pure, Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.mk]]
[Lean.Syntax.getNumArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Nat, Array.size, OfNat.ofNat]]
[Lean.instToMessageData,[Lean.ToMessageData.mk, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[Lean.Elab.Tactic.evalWithReducibleAndInstances,[Lean.Meta.withReducibleAndInstances, Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.IR.EmitC.emitMainFn,[Bind.bind, Lean.IR.EmitC.getDecl, Lean.Name.mkStr, Lean.Name.anonymous, Lean.IR.Decl.extern, Lean.IR.EmitC.M, Unit, ite, Eq, or, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw]]
[Lean.Name.hash,[Unit.unit, UInt64, UInt64.ofNatCore, OfNat.ofNat, Lean.Name.hash.proof_1]]
[Lean.mkAuxName,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure]]
[Lean.Parser.Tactic.isBounded_default,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Std.HashMapBucket.update,[Subtype.mk, Array.uset, Subtype.val, Std.HashMapBucket.update.proof_1]]
[Lean.Parser.Command.optionValue.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.strLit.parenthesizer, Lean.Parser.numLit.parenthesizer]]
[Lean.instInhabitedPosition,[Inhabited.mk, Lean.Position.mk, arbitrary]]
[Lean.AttributeExtensionState.newEntries,[]]
[Lean.Parser.Term.proj.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.fieldIdx.parenthesizer, Lean.Parser.Term.ident.parenthesizer]]
[implies_true,[propext, Iff.intro, trivial, True.intro]]
[Lean.Elab.OpenDecl.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[unexpandEqRec,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[Lean.Meta.Match.Extension.addMatcherInfo,[Lean.PersistentEnvExtension.addEntry, Lean.Meta.Match.Extension.extension, Lean.Meta.Match.Extension.Entry.mk]]
[Lean.Parser.categoryParserOfStack,[Lean.Parser.Parser.mk, Lean.Parser.categoryParserOfStackFn, Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.tokens, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Parser.ParserContext.savedPos?, Lean.Parser.ParserContext.forbiddenTk?]]
[Function.injective_surj_inv,[Function.right_inverse.injective, Function.right_inverse_surj_inv]]
[Lean.Elab.Command.expandMutualElement,[Bind.bind, ForIn.forIn, MProd.mk, Lean.Macro.expandMacro?, Unit.unit, Lean.MacroM, ForInStep, MProd, Array, Lean.Syntax, Bool, Pure.pure, PUnit.unit, ForInStep.yield, ite, Eq, Bool.true, Lean.Syntax.setArg, OfNat.ofNat, Lean.mkNullNode, Lean.Macro.throwUnsupported]]
[Lean.IR.FnBody.vdecl.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.vdecl, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Closure.State.newLocalDecls,[]]
[Lean.Expr.ReplaceLevelImpl.State.noConfusionType,[]]
[Lean.Meta.Simp.withSimpLemmas,[Bind.bind, MonadState.get, modify, Lean.Meta.Simp.State.mk, EmptyCollection.emptyCollection, Lean.Meta.Simp.State.numSteps, tryFinally, withTheReader, Lean.Meta.Simp.Context, Lean.Meta.Simp.Context.mk, Lean.Meta.Simp.Context.config, Lean.Meta.Simp.Context.congrLemmas, Lean.Meta.Simp.Context.parent?, Lean.Meta.Simp.Context.dischargeDepth]]
[Lean.Environment.find?,[Lean.SMap.find?', Lean.Environment.constants]]
[Lean.Parser.Command.structSimpleBinder,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.Command.declModifiers, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.Command.inferMod, Lean.Parser.Command.optDeclSig, HOrElse.hOrElse, Lean.Parser.Term.binderTactic, Lean.Parser.Term.binderDefault]]
[Lean.Meta.InfoCacheKey.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.KeyedDeclsAttribute.ExtensionState.mk.inj,[And.intro]]
[Lean.Meta.WhnfCache,[Lean.PersistentExprStructMap, Lean.Expr]]
[Lean.Elab.OpenDecl.elabOpenDecl,[Bind.bind, Lean.MonadResolveName.getOpenDecls, Lean.MonadResolveName.getCurrNamespace, StateRefT'.run', ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, ForIn.forIn, PUnit.unit, Lean.resolveNamespace, Lean.Syntax.getId, modify, Lean.Elab.OpenDecl.State.mk, List.cons, Lean.Elab.OpenDecl.State.openDecls, Lean.Elab.OpenDecl.State.currNamespace, Lean.OpenDecl.simple, List.nil, Lean.activateScoped, Pure.pure, ForInStep.yield, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.OpenDecl.resolveId, Lean.OpenDecl.explicit]]
[Lean.Elab.Term.State.messages,[]]
[Array.mkArray,[Array.mk, List.replicate]]
[Lean.IR.Sorry.visitExpr.getSorryDepFor?,[ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, MonadExcept.throw, Bind.bind, MonadState.get, Option.none, ExceptT, Lean.Name, Lean.IR.Sorry.M, Unit, Lean.NameMap.find?, Lean.IR.Sorry.State.localSorryMap, liftM, Lean.IR.findDecl, Option.some, Lean.IR.Decl.fdecl, Lean.IR.DeclInfo.mk, Lean.IR.Decl.extern, Pure.pure, Unit.unit]]
[ReaderT.instMonadExceptOfReaderT,[MonadExceptOf.mk, liftM, MonadExcept.throw, tryCatchThe]]
[Lean.Parser.identEqFn,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Parser.ParserState, Array.back, Lean.Parser.ParserState.stxStack, bne, Lean.Parser.ParserState.mkErrorAt, HAppend.hAppend, ToString.toString, Option.some]]
[IO.FS.FileType.noConfusionType,[noConfusionTypeEnum, IO.FS.FileType.toCtorIdx]]
[Lean.Meta.SynthInstance.mkGeneratorNode?,[Bind.bind, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Lean.Meta.SynthInstance.getInstances, ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Option.none, Lean.MonadMCtx.getMCtx, Option.some, Lean.Meta.SynthInstance.GeneratorNode.mk, Array.size]]
[Lean.Elab.Tactic.Conv.markAsConvGoal,[Bind.bind, Lean.Meta.getMVarType, ite, Eq, Option.isSome, Lean.isLHSGoal?, Bool.true, Pure.pure, PUnit.unit]]
[Nat.mul_le_mul_right,[Nat.mul_le_mul_left, Nat.mul_comm]]
[Lean.Core.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Core.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.isDep,[]]
[decidableOfDecidableOfIff,[dite, Decidable.isTrue, Iff.mp, Decidable.isFalse, decidableOfDecidableOfIff.proof_1]]
[Lean.Environment.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.FunBinders.State.expectedType?,[]]
[UInt64.instNegUInt64,[Neg.mk, UInt64.mk, Neg.neg, UInt64.val]]
[Lean.Elab.Command.instMonadInfoTreeCommandElabM,[Lean.Elab.MonadInfoTree.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Command.State.infoState, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.traceState]]
[Lean.Elab.Term.ElabAppArgs.State.args,[]]
[Lean.Meta.SimpAll.main,[Bind.bind, MonadState.get, liftM, Lean.Meta.getNondepPropHyps, Lean.Meta.SimpAll.State.mvarId, ForIn.forIn, PUnit.unit, Lean.Meta.getLocalDecl, ite, Eq, Std.PersistentHashSet.contains, Lean.LocalDecl.userName, Bool.true, Pure.pure, ForInStep.yield, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.SimpLemmas.add, Lean.Meta.Simp.Context.simpLemmas, Lean.Meta.SimpAll.State.ctx, List.toArray, List.nil, Bool.false, OfNat.ofNat, Option.some, Lean.Meta.instantiateMVars, Lean.LocalDecl.type, modify, Lean.Meta.SimpAll.State.mk, Lean.Meta.SimpAll.State.modified, Array.push, Lean.Meta.SimpAll.State.entries, Lean.Meta.Simp.Context.mk, Lean.Meta.Simp.Context.config, Lean.Meta.Simp.Context.congrLemmas, Lean.Meta.Simp.Context.parent?, Lean.Meta.Simp.Context.dischargeDepth, Option.none, Lean.Meta.assertHypotheses, Array.map, Lean.Meta.Hypothesis.mk, Lean.Meta.SimpAll.Entry.userName, Lean.Meta.SimpAll.Entry.type, Lean.Meta.SimpAll.Entry.proof, Lean.Meta.SimpAll.M, Option, Lean.MVarId, liftCoeM, Lean.Meta.tryClearMany, Lean.Meta.SimpAll.Entry.fvarId]]
[Std.PersistentHashMap.getCollisionNodeSize.proof_2,[Eq.refl, Std.PersistentHashMap.Node.entries, HEq.refl, False]]
[Ring.toSub,[]]
[TC.accessible.proof_1,[Acc.intro, Acc.inv]]
[Lean.JsonRpc.Message.request.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonRpc.Message.request, Eq.symm, eq_of_heq, HEq.refl]]
[Std.ShareCommon.ObjectMap.insert,[Std.HashMap.insert]]
[Lean.Widget.InteractiveGoals.mk.inj,[]]
[Lean.PersistentEnvExtension.statsFn,[]]
[Lean.Elab.Term.Do.CodeBlock.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.RecursorInfo.noConfusionType,[]]
[Lean.IR.IRType.noConfusionType,[]]
[Fin.modn,[Fin, Fin.mk, HMod.hMod, Fin.modn.proof_1]]
[Lean.IR.Arg.var.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Compiler.getInfoFromVal,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Compiler.NumScalarTypeInfo, Lean.Compiler.getInfoFromFn, Lean.Compiler.numScalarTypes, Option.none]]
[Lean.Elab.Tactic.ElimApp.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.Do.ToTerm.Kind.noConfusionType,[noConfusionTypeEnum, Lean.Elab.Term.Do.ToTerm.Kind.toCtorIdx]]
[Lean.Parser.TokenCacheEntry.noConfusionType,[]]
[Lean.JsonNumber.instToStringJsonNumber,[ToString.mk, Lean.JsonNumber.toString]]
[Lean.HeadIndex.proj.inj,[And.intro]]
[Lean.PrettyPrinter.Parenthesizer.notFollowedByCategoryToken.parenthesizer,[Pure.pure, Unit.unit]]
[right_comm,[]]
[Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.guardTarget,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.Simp.SimpM,[ReaderT, Lean.Meta.Simp.Context, StateRefT', IO.RealWorld, Lean.Meta.Simp.State, Lean.Meta.MetaM]]
[UInt8.sub,[UInt8.mk, HSub.hSub, UInt8.val]]
[Lean.PrettyPrinter.Parenthesizer.evalInsideQuot.parenthesizer,[]]
[Lean.ConstantInfo.numLevelParams,[List.length, Lean.ConstantInfo.levelParams]]
[Lean.Meta.SynthInstance.modifyTop,[modify, Lean.Meta.SynthInstance.State.mk, Lean.Meta.SynthInstance.State.result?, Array.modify, Lean.Meta.SynthInstance.State.generatorStack, HSub.hSub, Array.size, OfNat.ofNat, Lean.Meta.SynthInstance.State.resumeStack, Lean.Meta.SynthInstance.State.tableEntries]]
[Lean.Elab.Term.StructInst.CtorHeaderResult.mk.inj,[And.intro]]
[instReprOption,[Repr.mk, Std.Format, Std.Format.text, Repr.addAppParen, HAppend.hAppend, reprArg]]
[Lean.Elab.Info.isSmaller,[Option.none, Bool, Lean.Elab.Info.size?, Lean.Elab.Info.pos?, Decidable.decide, LT.lt, Bool.true, Bool.false]]
[Lean.mkConstWithLevelParams,[Bind.bind, Lean.getConstInfo, Pure.pure, Lean.mkConst, List.map, Lean.mkLevelParam, Lean.ConstantInfo.levelParams]]
[Fin.zero_def,[]]
[ForInStep.done.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.isGlobalInstance,[Std.PersistentHashMap.contains, Lean.ScopedEnvExtension.getState, Lean.Meta.globalInstanceExtension]]
[Lean.Lsp.WaitForDiagnosticsParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[MonadExceptOf.noConfusionType,[]]
[Lean.Meta.mkConstWithFreshMVarLevels,[Bind.bind, Lean.getConstInfo, Lean.Meta.mkFreshLevelMVarsFor, Pure.pure, Lean.mkConst]]
[Lean.EnvExtensionInterface.noConfusionType,[]]
[imp_or_distrib',[Decidable.imp_or_distrib']]
[Array.findIdx?,[Array.size, OfNat.ofNat, rfl, Array.findIdx?.loop]]
[Lean.Elab.ElabInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.ElabInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[ofBoolUsing_eq_false,[of_decide_eq_false]]
[Lean.Parser.Tactic.applyNormed,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.Meta.Config.etaStruct,[]]
[Lean.Meta.CheckAssignment.throwOutOfScopeFVar,[MonadExcept.throw, Lean.Exception.internal, Lean.Meta.CheckAssignment.outOfScopeExceptionId, Lean.KVMap.mk]]
[Lean.KernelException.alreadyDeclared.inj,[And.intro]]
[Lean.Xml.Parser.AttlistDecl,[SeqRight.seqRight, Lean.Parsec.skipString, Lean.Xml.Parser.S, Lean.Xml.Parser.Name, Lean.Parsec.many, Lean.Xml.Parser.AttDef, optional, Lean.Parsec.skipChar, Char.ofNat]]
[Lean.ConstantVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ConstantVal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[decidableLt_of_decidableLe.proof_2,[le_of_lt]]
[instStreamSubarray,[Stream.mk, dite, LT.lt, Subarray.start, Subarray.stop, Option.none]]
[Nat.le_trans,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, LE.le, Nat.le.step, PProd.fst]]
[Lean.IR.Expr.ctor.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.RecursorVal.all,[]]
[ExceptT.instMonadLiftExceptExceptT,[MonadLift.mk, ExceptT.mk, Pure.pure]]
[Unit,[PUnit]]
[Lean.Expr.hasLooseBVars,[Decidable.decide, GT.gt, Lean.Expr.looseBVarRange, OfNat.ofNat]]
[Lean.Server.Snapshots.Snapshot.endPos,[Lean.Parser.ModuleParserState.pos, Lean.Server.Snapshots.Snapshot.mpState]]
[Lean.Elab.Term.LVal.fieldName.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LVal.fieldName, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.matchType,[]]
[Function.update_comp_eq_of_forall_ne,[Function.update_comp_eq_of_forall_ne']]
[Lean.Parser.Tactic.split,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.location]]
[Mathlib.Prelude.Rename.RenameMap,[Std.HashMap, Lean.Name]]
[Lean.Elab.instToFormatModifiers,[Std.ToFormat.mk, Std.Format.bracket, Std.Format.joinSep, HAppend.hAppend, Std.Format.text, Std.Format.line]]
[Lean.Meta.matchEq?,[Lean.Meta.matchHelper?, Pure.pure, Lean.Expr.eq?]]
[Lean.Parser.Term.arrayRef,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, Lean.Parser.termParser]]
[Lean.instToStringAttributeKind,[ToString.mk, Unit.unit, String]]
[Lean.Meta.Closure.State.toProcess,[]]
[Lean.Elab.Term.SyntheticMVarKind.coe.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.SyntheticMVarKind.coe, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Simp.Result.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Simp.Result.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.instFromJsonFilePath,[Lean.FromJson.mk, Functor.map, System.FilePath.mk, Lean.Json.getStr?]]
[Lean.Meta.openAbstractMVarsResult,[Bind.bind, Array.mapM, Lean.Meta.mkFreshLevelMVar, Lean.Meta.AbstractMVarsResult.paramNames, Lean.Meta.lambdaMetaTelescope, Option.some, Lean.Meta.AbstractMVarsResult.numMVars]]
[Lean.instCoeExprExprStructEq,[Coe.mk, Lean.ExprStructEq.mk]]
[Lean.Json.below,[PUnit, PProd]]
[instInhabitedPointedType,[Inhabited.mk, PointedType.mk, PUnit, PUnit.unit]]
[Lean.SimplePersistentEnvExtensionDescr.toArrayFn,[]]
[Lean.Server.FileWorker.CancelToken.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Module.header.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Module.prelude.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.Module.import.parenthesizer]]
[EStateM.adaptExcept,[EStateM.Result, EStateM.Result.error, EStateM.Result.ok]]
[Std.PersistentArray.mkEmptyArray,[Array.mkEmpty, USize.toNat, Std.PersistentArray.branching]]
[Lean.Meta.ParamInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.ParamInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[flip,[]]
[Tactic.Ring.HornerExpr.const.injEq,[Eq.propIntro, And.intro, Eq.refl, Tactic.Ring.HornerExpr.const, Eq.symm, eq_of_heq, HEq.refl]]
[instReprAtomString,[ReprAtom.mk]]
[Lean.IR.Borrow.OwnedSet.contains,[Std.HashMap.contains]]
[Lean.instMonadRecDepthReaderT,[Lean.MonadRecDepth.mk, Lean.MonadRecDepth.withRecDepth, Lean.MonadRecDepth.getRecDepth, Lean.MonadRecDepth.getMaxRecDepth]]
[Lean.Lsp.SemanticTokens.noConfusionType,[]]
[Int.negSucc_ofNat_mul_subNatNat,[]]
[Lean.NameSanitizerState.userName2Sanitized,[]]
[Lean.Parser.error,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.errorFn]]
[Lean.IR.formatParams,[Lean.IR.formatArray]]
[Lean.Expr.heq?,[Lean.Expr.app4?, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Elab.ContextInfo.ppGoals,[ite, Eq, List.isEmpty, Bool.true, Pure.pure, Std.Format.text, Lean.Elab.ContextInfo.runMetaM, Lean.LocalContext.mk, Bind.bind, List.mapM, Lean.Meta.ppGoal, Std.Format.prefixJoin]]
[Lean.Elab.Command.Context.cmdPos,[]]
[Std.HashMap.getOp,[Std.HashMap.find?]]
[Lean.Elab.Term.expandSuffices,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Lean.Macro.throwUnsupported]]
[Fin.add,[Fin, Fin.mk, HMod.hMod, HAdd.hAdd, Fin.add.proof_1]]
[DoResultPRBC.noConfusionType,[]]
[String.isSuffix,[List.isSuffix]]
[instDecidableEqSum.proof_4,[absurd]]
[IO.FS.Stream.putStrLn,[IO.FS.Stream.putStr, String.push, Char.ofNat]]
[Lean.Expr.isFVar,[Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[instShiftLeftUSize,[ShiftLeft.mk, USize.shiftLeft]]
[Lean.Elab.Command.elabInductive,[Bind.bind, Lean.Elab.Command.checkValidInductiveModifier, Lean.Elab.Command.CommandElabM, Lean.Elab.Command.InductiveView, Lean.Elab.Command.expandDeclId, Lean.Elab.addDeclarationRanges, Array.mapM, Lean.withRef, Lean.Elab.elabModifiers, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, and, Lean.Elab.Modifiers.isPrivate, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Syntax.getArgs, Lean.Elab.getOptDerivingClasses, Lean.Elab.Command.InductiveView.mk, Lean.Elab.Command.elabInductiveViews, List.toArray, List.cons, List.nil]]
[Equivalence.trans,[]]
[Lean.isSubScriptAlnum,[or, Lean.isNumericSubscript, and, Decidable.decide, LE.le, OfNat.ofNat, Char.val]]
[evalIntrov.intro1PStep,[Lean.Elab.Tactic.liftMetaTactic, Bind.bind, Lean.Meta.intro1P, Lean.Meta.MetaM, List, Lean.MVarId, Pure.pure, List.cons, List.nil]]
[Lean.interpolatedStrLitKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.instInhabitedProjectionFunctionInfo,[Inhabited.mk, Lean.ProjectionFunctionInfo.mk, arbitrary]]
[Lean.CollectLevelParams.Visitor,[Lean.CollectLevelParams.State]]
[Lean.Meta.SynthInstance.MkTableKey.State.lmap,[]]
[unexpandIte,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[Std.RBTree.revFold,[Std.RBMap.revFold]]
[List.exists_mem_cons_of_exists,[Exists, And, Mem.mem, List.cons, Exists.intro, And.intro, Or.inr]]
[Lean.Syntax.Traverser.up,[ite, GT.gt, Array.size, Lean.Syntax.Traverser.parents, OfNat.ofNat, Lean.Syntax.Traverser.mk, Array.pop, Lean.Syntax.Traverser.idxs]]
[Lean.IR.VarTypeMap,[Std.HashMap, Lean.IR.VarId, Lean.IR.IRType]]
[Lean.Meta.Simp.Config.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.define,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarTag, Lean.Meta.getMVarType, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.assignExprMVar, Pure.pure, Lean.Expr.mvarId!]]
[Lean.Lsp.RpcCallParams.method,[]]
[«term_<<<_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Compiler.SpecEntry.info.inj,[And.intro]]
[«term_|||_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[invImage,[WellFoundedRelation.mk, InvImage, WellFoundedRelation.rel, invImage.proof_1]]
[Lean.IR.LocalContext,[Std.RBMap, Lean.IR.Index, Lean.IR.LocalContextEntry, Ord.compare]]
[instDecidableEqSum.proof_3,[rfl]]
[UInt16.toUInt8,[Nat.toUInt8, UInt16.toNat]]
[Lean.Meta.NormNum.eval_of_isNat,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, OfNat.ofNat, HEq.refl, Eq, Lean.Meta.NormNum.LawfulOfNat.isNat_ofNat]]
[UInt64.size_positive,[of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.PrettyPrinter.Delaborator.delabBVar,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Pure.pure, Lean.mkIdent, Lean.Name.mkSimple, HAppend.hAppend, ToString.toString, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Parser.ParserExtension.OLeanEntry.category.inj,[And.intro]]
[List.reverse_nil,[rfl]]
[HShiftRight.noConfusionType,[]]
[Lean.Parser.Command.initialize,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.visibility, Lean.Parser.symbol, Lean.Parser.atomic, Lean.Parser.ident, Lean.Parser.Term.typeSpec, Lean.Parser.Term.leftArrow, Lean.Parser.Term.doSeq]]
[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.curr,[]]
[Lean.Parser.Command.notationItem.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.strLit.parenthesizer, Lean.Parser.Command.identPrec.parenthesizer]]
[Lean.Parser.Term.doCatch.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.darrow.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer]]
[Lean.Elab.Term.ElabAppArgs.State.propagateExpected,[]]
[Lean.Elab.Tactic.getFVarId,[Lean.withRef, Bind.bind, Lean.Elab.Tactic.withMainContext, Lean.Elab.Tactic.elabTermForApply, Bool.false, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Elab.Tactic.TacticM, Lean.FVarId, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.IR.ExplicitRC.Context.localCtx,[]]
[max_self,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, if_t_t, LT.lt, eq_self]]
[Lean.IR.NormalizeIds.normArg,[Lean.IR.Arg.irrelevant, Lean.IR.NormalizeIds.M, Lean.IR.Arg, Functor.map, Lean.IR.Arg.var, Lean.IR.NormalizeIds.normVar, Pure.pure]]
[Lean.Elab.Command.elabElabRulesAux,[Bind.bind, Array.mapM, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, not, Lean.Syntax.isQuot, Lean.Elab.throwUnsupportedSyntax, Pure.pure, PUnit.unit, Option.none, Option.some, Lean.Elab.Command.CommandElabM, Lean.Syntax, Lean.Syntax.getId, Lean.throwError, Lean.ToMessageData.toMessageData]]
[String.find,[String.findAux, String.bsize, OfNat.ofNat]]
[instSemiringFin.proof_2,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.mul_def, OfNat.ofNat, congrFun, HMod.hMod, HMul.hMul, Fin.zero_def, Nat.zero_mul, Nat.zero_mod, eq_true_of_decide, Eq.refl, Bool.true]]
[Lean.Parser.Command.syntaxCat,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident, Lean.Parser.Command.catBehavior]]
[Lean.Json.Parser.natMaybeZero,[Bind.bind, Lean.Json.Parser.natNumDigits, Lean.Parsec, Nat, Pure.pure]]
[Lean.Elab.Term.SyntheticMVarKind.tactic.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.instFromJsonTextEdit,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.Range, String, Pure.pure, Lean.Lsp.TextEdit.mk]]
[Lean.Elab.Term.CollectPatternVars.Context.paramDeclIdx,[]]
[Lean.getPPMotivesPi,[Lean.KVMap.get, Lean.Option.name, Lean.pp.motives.pi, Lean.Option.defValue]]
[Lean.Meta.IndPredBelow.findBelowIdx,[Array.findSomeM?, Bind.bind, Lean.Meta.inferType, Lean.Expr.withApp, Option.none, Option.some, Lean.Meta.MetaM, Option, Prod, Lean.Expr, Nat, Lean.Expr.constName?, Array.indexOf?, Lean.Meta.isInductivePredicate, ite, Eq, Bool.true, Array.getOp, Lean.getConstInfoInduct, Pure.pure, Prod.mk, Fin.val, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Name.anonymous, MonadExcept.tryCatch, Lean.isTracingEnabledFor, Lean.Meta.ppGoal, Lean.Expr.mvarId!, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, PUnit.unit]]
[Lean.IR.ExplicitRC.VarInfo.ref,[]]
[Lean.Elab.throwIllFormedSyntax,[Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.Meta.shouldReduceAll,[Bind.bind, Lean.Meta.getTransparency, Pure.pure, BEq.beq, Lean.Meta.TransparencyMode.all]]
[List.map_id,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.map_nil, List.nil, eq_self, List.map_cons, congr, List.cons, id_eq]]
[Lean.Parser.Term.funImplicitBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.lookahead.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.implicitBinder.parenthesizer, Bool.false]]
[UInt8.decLe,[Decidable, LE.le, inferInstanceAs]]
[Lean.Elab.Tactic.elabTermWithHoles,[Bind.bind, Lean.MonadMCtx.getMCtx, Lean.Elab.Tactic.elabTermEnsuringType, Bool.false, liftM, Lean.Meta.getMVarsNoDelayed, Array.filterM, Lean.Elab.Term.isLetRecAuxMVar, Pure.pure, not, OfNat.ofNat, Array.size, ite, Eq, Bool.true, Array.toList, Lean.Meta.getMVarDecl, Lean.MetavarKind.isNatural, Lean.MetavarDecl.kind, Lean.Elab.Tactic.filterOldMVars, Lean.Elab.Tactic.logUnassignedAndAbort]]
[Lean.Meta.Closure.State.visitedExpr,[]]
[LawfulMonad.bind_assoc,[]]
[Lean.Elab.Command.elabAttr,[Bind.bind, ForIn.forIn, MProd.mk, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.MonadEnv.getEnv, Lean.isAttribute, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, ForInStep.yield, Lean.Elab.Command.CommandElabM, Unit, Lean.Elab.elabAttrs, Lean.withRef, Lean.Elab.Command.liftTermElabM, Option.none, Lean.Elab.resolveGlobalConstNoOverloadWithInfo, Lean.Elab.Term.applyAttributes, liftM, Lean.Attribute.erase]]
[Lean.Meta.Match.Extension.instInhabitedState,[Inhabited.mk, Lean.Meta.Match.Extension.State.mk]]
[Lean.Parser.Term.letIdLhs.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.ident.formatter, Lean.PrettyPrinter.Formatter.notFollowedBy.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many.formatter, Lean.ppSpace.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.simpleBinderWithoutType.formatter, Lean.Parser.Term.bracketedBinder.formatter, Bool.false, Lean.Parser.Term.optType.formatter]]
[Option.eq_none_of_isNone,[Eq.refl, Bool.true, HEq.refl, Eq, Option.none, rfl]]
[CommGroup.toGroup,[]]
[Lean.IR.FnBody.beq,[Lean.IR.FnBody.alphaEqv, EmptyCollection.emptyCollection]]
[Lean.Meta.SplitIf.discharge?,[Bind.bind, liftM, Lean.Meta.instantiateMVars, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Expr.notNot?, Pure.pure, PUnit.unit]]
[Lean.Parser.Term.borrowed.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.leadPrec]]
[Substring.stopPos,[]]
[Tactic.Find.findType,[Lean.Meta.withReducible, Bind.bind, liftM, Lean.Meta.instantiateMVars, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.abstractMVars, Lean.MonadEnv.getEnv, Tactic.DeclCache.get, Tactic.Find.findDeclsPerHead, ForIn.forIn, Lean.Meta.mkFreshLevelMVars, Lean.ConstantInfo.numLevelParams, Pure.pure, Lean.ConstantInfo.instantiateTypeLevelParams, Lean.Meta.forallTelescopeReducing, Lean.Meta.AbstractMVarsResult.numMVars, Lean.Expr.instantiateLevelParamsArray, Lean.Meta.AbstractMVarsResult.expr, Lean.Meta.AbstractMVarsResult.paramNames, List.toArray, Lean.Meta.lambdaMetaTelescope, Lean.Elab.Term.TermElabM, Bool, andM, Lean.Meta.isDefEq, Array.toList, List.nil, ite, Eq, Bool.true, GT.gt, OfNat.ofNat, Lean.Elab.logInfo, Lean.ToMessageData.toMessageData, ForInStep.done, PUnit.unit, ForInStep.yield]]
[Lean.Parser.Term.namedPattern.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkStackTop.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec]]
[Nat.toDigits,[Nat.toDigitsCore, HAdd.hAdd, OfNat.ofNat, List.nil]]
[Lean.Meta.withNewLocalInstance,[Lean.Meta.mapMetaM, Bind.bind, Lean.Meta.getFVarLocalDecl, Lean.BinderInfo.default, Lean.BinderInfo.implicit, Lean.BinderInfo.strictImplicit, Lean.BinderInfo.instImplicit, Unit.unit, Lean.Meta.MetaM, Lean.LocalDecl.binderInfo, Lean.Meta.resettingSynthInstanceCache, MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Context.config, Lean.Meta.Context.lctx, Array.push, Lean.Meta.Context.localInstances, Lean.LocalInstance.mk, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth]]
[le_or_gt,[le_or_lt]]
[Lean.IR.ExplicitRC.Context.env,[]]
[Lean.Elab.Tactic.evalClear,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Tactic.getFVarIds, Lean.Elab.Tactic.withMainContext, liftM, Lean.Meta.sortFVarIds, ForIn.forIn, PUnit.unit, Lean.Elab.Tactic.getMainGoal, Lean.Meta.clear, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.nil, Pure.pure, ForInStep.yield, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Elab.Term.Quotation.runPrecheck,[Bind.bind, Lean.MonadOptions.getOptions, ite, Eq, and, Lean.Option.get, Lean.Elab.Term.Quotation.quotPrecheck, Lean.Elab.Term.Quotation.hygiene, Bool.true, ReaderT.run, Lean.Elab.Term.Quotation.precheck, Lean.Elab.Term.Quotation.Precheck.Context.mk, EmptyCollection.emptyCollection, Pure.pure, PUnit.unit]]
[Lean.Lsp.DocumentUri,[String]]
[Lean.IR.UnreachableBranches.InterpContext.lctx,[]]
[Lean.Lsp.instToJsonDidChangeTextDocumentParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.DidChangeTextDocumentParams.textDocument, List.nil, Lean.Lsp.DidChangeTextDocumentParams.contentChanges]]
[Lean.EnvironmentHeader.regions,[]]
[Set.setOf.unexpander,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesIdent, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[Lean.Meta.Simp.instInhabitedContext,[Inhabited.mk, Lean.Meta.Simp.Context.mk, arbitrary]]
[Lean.Parser.orelseFn,[Lean.Parser.orelseFnCore, Bool.true]]
[Nat.coprime.coprime_mul_left,[Nat.coprime.coprime_dvd_left, Nat.dvd_mul_left]]
[instDecidableEqUInt16,[UInt16.decEq]]
[Lean.Parser.Tactic.generalize,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.generalizeArg, Lean.ParserDescr.symbol]]
[Lean.EnvExtensionInterfaceUnsafe.Ext.noConfusionType,[]]
[Lean.Lsp.DidChangeTextDocumentParams.textDocument,[]]
[Lean.Parser.Tactic.hint,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Std.PersistentArray.foldr,[Id.run, Std.PersistentArray.foldrM]]
[Semiring.toNumeric,[]]
[Lean.PrettyPrinter.Parenthesizer.parserOfStack.parenthesizer,[Bind.bind, MonadState.get, Lean.PrettyPrinter.Parenthesizer.parenthesizerForKind, Lean.Syntax.getKind]]
[Nat.gcd_mul_right_left,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.mul_comm, Nat.gcd_mul_left_left, rfl]]
[Int.fmod,[Int.ofNat, Int.negSucc, Nat.succ, Int, OfNat.ofNat, HMod.hMod, Int.subNatNat, Neg.neg]]
[List.forA,[Unit.unit, PUnit, Pure.pure, PUnit.unit, SeqRight.seqRight, PProd.fst]]
[Lean.Elab.Term.Do.Code.continue.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.Do.Code.continue, Eq.symm, eq_of_heq, HEq.refl]]
[USize.decEq.proof_2,[absurd]]
[Lean.EnumAttributes.noConfusionType,[]]
[Lean.Syntax.TopDown.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Syntax.TopDown.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrefixTree.insert.proof_1,[Lean.PrefixTreeNode.WellFormed.insertWff, Subtype.property]]
[UInt32.toUInt16,[Nat.toUInt16, UInt32.toNat]]
[Lean.Meta.AbstractMVarsResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Environment.isNamespace,[Lean.NameSSet.contains, Lean.SimplePersistentEnvExtension.getState, Lean.namespacesExt]]
[Array.isEmpty,[Decidable.decide, Eq, Array.size, OfNat.ofNat]]
[Int.mod,[Int, Int.ofNat, HMod.hMod, Nat.succ, Neg.neg]]
[Lean.isEnumType,[Bind.bind, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Bool, ite, Eq, and, not, Lean.Expr.isProp, Lean.ConstantVal.type, Lean.InductiveVal.toConstantVal, BEq.beq, List.length, Lean.InductiveVal.all, OfNat.ofNat, Lean.InductiveVal.numIndices, Lean.InductiveVal.numParams, List.isEmpty, Lean.InductiveVal.ctors, Lean.InductiveVal.isRec, Lean.InductiveVal.isNested, Lean.InductiveVal.isUnsafe, Bool.true, List.allM, Lean.ConstantInfo.inductInfo, Pure.pure, Lean.ConstructorVal.numFields, Bool.false]]
[Lean.Elab.WF.expandTerminationHint,[Option.none, Lean.MacroM, Lean.Elab.WF.TerminationHint, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Lean.Elab.WF.TerminationHint.one, Lean.Elab.WF.TerminationHintValue.mk, Lean.Syntax.getOp, OfNat.ofNat, Bind.bind, Array.foldlM, Unit.unit, Lean.NameMap, Lean.Elab.WF.TerminationHintValue, Lean.Macro.throwErrorAt, HAppend.hAppend, ToString.toString, Lean.Syntax.getId, Lean.NameMap.insert, EmptyCollection.emptyCollection, Lean.Syntax.getArgs, Array.size, ForIn.forIn, PUnit.unit, ForInStep, Option, Lean.Name, Lean.NameMap.find?, ForInStep.yield, Lean.Elab.WF.TerminationHint.many, Lean.Macro.throwUnsupported, Lean.Elab.WF.TerminationHint.none]]
[Lean.Xml.Parser.PublicID,[SeqLeft.seqLeft, Lean.Parsec.skipString, Lean.Xml.Parser.S, Lean.Xml.Parser.PubidLiteral]]
[Functor.mapRev,[Functor.map]]
[Array.«term__[_:]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Lsp.SymbolKind.string.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Command.Context.fileMap,[]]
[Lean.Elab.RecKind.default.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[instOrdChar,[Ord.mk, compareOfLessAndEq]]
[Lean.IR.JPLiveVarMap,[Std.RBMap, Lean.IR.JoinPointId, Lean.IR.LiveVarSet, Ord.compare, Lean.IR.JoinPointId.idx]]
[Lean.SCC.State.nextIndex,[]]
[Lean.Parser.Trie.empty,[Lean.Parser.Trie.Node, Option.none, Std.RBNode.leaf]]
[Lean.LocalContext.foldl,[Id.run, Lean.LocalContext.foldlM]]
[IO.FS.instReprSystemTime,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, IO.FS.SystemTime.sec, Std.Format.line, IO.FS.SystemTime.nsec]]
[Lean.ParametricAttribute.attr,[]]
[Functor.map_map,[Eq.symm, LawfulFunctor.comp_map]]
[Lean.IR.FnBody.jdecl.inj,[And.intro]]
[Measure,[InvImage, LT.lt]]
[List.nil_union,[of_eq_true, eq_self]]
[Nat.mul_lt_mul,[Nat.lt_of_lt_of_le, Nat.mul_lt_mul_of_pos_right, Nat.mul_le_mul_of_nonneg_left]]
[Lean.Expr.hasExprMVar,[Lean.Expr.Data.hasExprMVar, Lean.Expr.data]]
[Lean.IR.Checker.CheckerState.mk.inj,[]]
[Std.HashSet.find?,[Option, Std.HashSetImp.find?]]
[String.toSubstring,[Substring.mk, OfNat.ofNat, String.bsize]]
[Lean.Parser.Tactic.ext?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[prodHasDecidableLt,[inferInstanceAs, Decidable, Or, LT.lt, Prod.fst, And, Eq, Prod.snd]]
[Lean.Lsp.instFromJsonPosition,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Nat, Pure.pure, Lean.Lsp.Position.mk]]
[Lean.Lsp.WorkDoneProgressBegin.toWorkDoneProgressReport,[]]
[MonadState.noConfusionType,[]]
[Lean.mkListNode,[Lean.mkNullNode]]
[Lean.Parser.Tactic.congr,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Tactic.mapply,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[IO.FS.Stream.Buffer.pos,[]]
[Lean.MonadCacheT.instAlternativeMonadCacheT,[inferInstanceAs, Alternative, StateRefT', Std.HashMap]]
[PSigma.snd,[]]
[Lean.Syntax.MonadTraverser.goLeft,[modify, Lean.Syntax.Traverser.left]]
[Quotient.liftOn,[Quot.liftOn]]
[Lean.JsonRpc.Notification.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonRpc.Notification.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.getSimpLemmas,[Lean.Meta.SimpExtension.getLemmas, Lean.Meta.simpExtension]]
[Lean.Meta.RecursorInfo.depElim,[]]
[Lean.Meta.generalize,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarTag, Lean.Meta.getMVarType, Lean.Meta.instantiateMVars, OfNat.ofNat, Lean.Meta.isTypeCorrect, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.throwTacticEx, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Syntax.missing, Lean.Meta.generalize.go]]
[Lean.Lsp.DocumentSymbolParams.mk.inj,[]]
[Lean.Json.str.inj,[]]
[Lean.Server.Watchdog.parseParams,[Lean.Server.Watchdog.ServerM, Lean.FromJson.fromJson?, Pure.pure, liftM, IO.throwServerError, HAppend.hAppend, ToString.toString, Lean.Json.compress]]
[Lean.mkInductiveValEx,[Lean.InductiveVal.mk, Lean.ConstantVal.mk]]
[Lean.LocalContext.findDeclRevM?,[Std.PersistentArray.findSomeRevM?, Lean.LocalContext.decls, Unit.unit, Option, Pure.pure, Option.none]]
[Lean.AttributeKind.global.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[«term%[_|_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false]]
[Tactic.Ring.zero_horner,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, HAdd.hAdd, MonoidWithZero.zero_mul, HPow.hPow, zero_add, eq_self]]
[UInt8.neg_def,[rfl]]
[forall_eq',[of_eq_true, Eq.trans, congrFun, congrArg, Iff, forall_congr, implies_congr, propext, eq_comm, Eq.refl, forall_eq, iff_self]]
[Lean.Rat.instNegRat,[Neg.mk, Lean.Rat.neg]]
[String.codepointPosToUtf8PosFrom,[String.Pos, PProd.fst, String.next]]
[Lean.Elab.Term.MkInstResult.instType,[]]
[Lean.IR.Borrow.OwnedSet.instBEqKey,[BEq.mk, Lean.IR.Borrow.OwnedSet.beq]]
[Lean.Module.commands,[]]
[Lean.AttributeExtensionState.noConfusionType,[]]
[Lean.Elab.Term.Quotation.HeadCheck.unconditional.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.TraceElem.msg,[]]
[Lean.Parser.Level.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.levelParser]]
[Or.neg_resolve_right,[Or.elim, id, absurd]]
[Lean.Parser.Term.leftArrow.parenthesizer,[Lean.Parser.unicodeSymbol.parenthesizer]]
[Lean.Parser.Syntax.unary,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.syntaxParser]]
[Lean.PrettyPrinter.Formatter.checkStackTop.formatter,[Pure.pure, Unit.unit]]
[Lean.Parser.Term.let_fun.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.letDecl.parenthesizer, Lean.Parser.Term.optSemicolon.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[DoResultPRBC.continue.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.FunInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[OptionT.mk,[]]
[Lean.Elab.WF.TerminationHint.one.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.termParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Meta.DiscrTree.mkNoindexAnnotation,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.IR.EmitC.emitIsTaggedPtr,[Bind.bind, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn]]
[Lean.Elab.Command.State.mk.inj,[And.intro]]
[DoResultBC.continue.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Tactic.SavedState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.SavedState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.RpcRef.noConfusionType,[]]
[instAddCommGroup.proof_1,[Semiring.add_zero]]
[Lean.PPContext.mctx,[]]
[Lean.Meta.DiscrTree.hasNoindexAnnotation,[Option.isSome, Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Name.reprPrec,[Unit.unit, Std.Format, Std.Format.text, Repr.addAppParen, HAppend.hAppend, PProd.fst, OfNat.ofNat, repr, ite, Eq, Bool, Bool.false, Bool.true, Lean.Name.toString]]
[Lean.PrettyPrinter.Delaborator.delabDIte.delabBranch,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, guard, Eq, Lean.Expr.isLambda, Bool.true, Unit.unit, Lean.PrettyPrinter.Delaborator.DelabM, Prod, Lean.Syntax, Lean.Name, Lean.PrettyPrinter.Delaborator.SubExpr.withBindingBody, Lean.PrettyPrinter.Delaborator.delab, Pure.pure, Prod.mk, Lean.PrettyPrinter.Delaborator.withBindingBodyUnusedName, Lean.Syntax.getId]]
[Lean.Parser.mkParserAttributeImpl,[Lean.AttributeImpl.mk, Lean.AttributeImplCore.mk, Lean.AttributeApplicationTime.afterCompilation, Bind.bind, Lean.Attribute.Builtin.getPrio, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, liftM, Lean.Parser.mkParserOfConstant, List.forM, MonadExcept.tryCatch, Lean.Parser.addToken, Lean.Exception.internal, Lean.AttrM, PUnit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, MonadExcept.throw, Std.PersistentHashMap.forM, Lean.MonadEnv.modifyEnv, Lean.Parser.addSyntaxNodeKind, Unit, Lean.Parser.addParser, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.ScopedEnvExtension.add, Lean.Parser.parserExtension]]
[instToFormatProd,[Std.ToFormat.mk, Std.Format, Std.Format.paren, HAppend.hAppend, Std.ToFormat.format, Std.Format.text, Std.Format.line]]
[instSubUInt32,[Sub.mk, UInt32.sub]]
[Lean.instInhabitedDefinitionSafety,[Inhabited.mk, Lean.DefinitionSafety.unsafe]]
[Lean.Parser.orelseInfo,[Lean.Parser.ParserInfo.mk, Function.comp, Lean.Parser.ParserInfo.collectTokens, Lean.Parser.ParserInfo.collectKinds, Lean.Parser.FirstTokens.merge, Lean.Parser.ParserInfo.firstTokens]]
[Lean.Meta.InductionSubgoal.subst,[]]
[Lean.Elab.Tactic.evalRotateLeft,[Bind.bind, Lean.Elab.Tactic.getGoals, Lean.Elab.Tactic.setGoals, List.rotateLeft]]
[Lean.ScopedEnvExtension.addScopedEntry,[Lean.PersistentEnvExtension.addEntry, Lean.ScopedEnvExtension.ext, Lean.ScopedEnvExtension.Entry.scoped]]
[Lean.Meta.Match.Pattern.var.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Pattern.var, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.Hover.contents,[]]
[IO.FS.Metadata.accessed,[]]
[Lean.IR.addParamsRename,[OptionM.run, ite, Eq, bne, Array.size, Bool.true, Alternative.failure, Bind.bind, ForIn.forIn, Lean.IR.addParamRename, Array.getOp, Pure.pure, PUnit.unit, ForInStep.yield]]
[Lean.Parser.Command.decreasingBy.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.terminationHint.parenthesizer, Lean.Parser.Tactic.tacticSeq.parenthesizer]]
[Lean.Parser.Tactic.finCases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.ParserDescr.cat, Lean.ParserDescr.unary]]
[Lean.IR.Checker.checkVar,[Bind.bind, MonadReader.read, ite, Eq, or, Lean.IR.LocalContext.isLocalVar, Lean.IR.Checker.CheckerContext.localCtx, Lean.IR.VarId.idx, Lean.IR.LocalContext.isParam, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Prod.snd_injective,[Prod.ext', Subsingleton.elim, Prod.fst]]
[Mathlib.ExtendedBinder.«term∀___,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[instReprUInt32,[Repr.mk, repr, UInt32.toNat]]
[StateT.seqRight_eq,[StateT.ext, Eq.mpr, congr, congrArg, Eq, StateT.run_seqRight, Eq.trans, StateT.run_seq, Functor.map, id, Bind.bind, StateT.run_map, map_eq_pure_bind, Prod.mk, Prod.snd, StateT.run, funext, Prod.fst, LawfulMonad.bind_assoc, Pure.pure, LawfulMonad.pure_bind, congrFun, id_eq, bind_congr, of_eq_true, Prod.ext, bind_pure, eq_self, Eq.symm, Eq.refl]]
[Function.extend_def,[Eq.mpr, Eq.refl, Eq, Function.extend, dite, Exists, Classical.choose, Subsingleton.elim, Classical.propDecidable, rfl]]
[String.toInt?,[OptionM.run, ite, Eq, String.get, OfNat.ofNat, Char.ofNat, Bind.bind, Substring.toNat?, Substring.drop, String.toSubstring, Pure.pure, Neg.neg, Int.ofNat, Functor.map, String.toNat?]]
[Lean.Meta.SynthInstance.getMaxHeartbeats,[HMul.hMul, Lean.Option.get, Lean.Meta.synthInstance.maxHeartbeats, OfNat.ofNat]]
[Lean.Elab.Term.elabForIn,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Term.isLocalIdent?, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, List.nil, Lean.Elab.Term.elabTerm, Lean.Elab.Term.tryPostponeIfNoneOrMVar, liftM, Lean.Meta.inferType, Lean.Meta.mkFreshLevelMVar, Lean.Meta.mkFreshExprMVar, Option.some, Lean.mkSort, Lean.mkLevelSucc, Lean.MetavarKind.natural, MonadExcept.tryCatch, Lean.Meta.mkAppM, Lean.Elab.Term.tryPostpone, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Elab.throwUnsupportedSyntax, Lean.Elab.Term.elabForIn.getMonad, Lean.Elab.Term.elabForIn.throwFailure]]
[Bool.false_and,[rfl, Eq.symm, Eq.refl]]
[Lean.OpaqueVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Simp.pre,[Bind.bind, MonadReader.read, liftM, Lean.Meta.Simp.Methods.pre]]
[Lean.Elab.Term.instMonadTermElabM,[Monad.mk]]
[Lean.IR.getEnv,[Bind.bind, MonadState.get, Pure.pure, Lean.IR.CompilerState.env]]
[Lean.Lsp.Location.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.Location.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Server.FileWorker.queueRequest,[Lean.Server.FileWorker.updatePendingRequests, Std.RBMap.insert]]
[Lean.Meta.DiscrTree.insert,[Bind.bind, Lean.Meta.DiscrTree.mkPath, Pure.pure, Lean.Meta.DiscrTree.insertCore]]
[Lean.MonadStateCacheT.instMonadHashMapCacheAdapterMonadStateCacheT,[Lean.MonadHashMapCacheAdapter.mk, MonadState.get, modify]]
[USize.instSemigroupUSize.proof_1,[congrArg, USize.mk, Semigroup.mul_assoc, USize.val]]
[Lean.Meta.IndPredBelow.Variables.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.abel!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.PrettyPrinter.mkCombinatorParenthesizerAttribute,[Lean.ParserCompiler.registerCombinatorAttribute, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Elab.Term.LetRecToLift.noConfusionType,[]]
[Lean.NameMap.instEmptyCollectionNameMap,[EmptyCollection.mk, Lean.mkNameMap]]
[Lean.Message.mk.inj,[And.intro]]
[IO.Error.resourceBusy.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt32.add_def,[rfl]]
[Lean.Elab.FieldInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.evalExpr,[Lean.withoutModifyingEnv, Bind.bind, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.inferType, Lean.Meta.whnfD, ite, Eq, Lean.Expr.isConstOf, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr]]
[Lean.Elab.Term.Do.ToTerm.Kind.noConfusion,[noConfusionEnum, Lean.Elab.Term.Do.ToTerm.Kind.toCtorIdx]]
[Std.Format.group.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.Format.group, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.squeezeDSimp?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.Parser.Tactic.refine,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[StateT.run_monadMap,[rfl]]
[Lean.Meta.mkAdd,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getDecLevel, Lean.Meta.synthInstance, Lean.mkApp3, Lean.mkConst, List.cons, List.nil, Option.none, Pure.pure, Lean.mkApp6, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Elab.logWarning,[Lean.Elab.log, Lean.MessageSeverity.warning]]
[Std.RBTree.all,[Std.RBMap.all]]
[Lean.PrettyPrinter.Formatter.State.noConfusionType,[]]
[Lean.MetavarContext.lDepth,[]]
[withTheReader,[MonadWithReaderOf.withReader]]
[Lean.LocalInstance.mk.inj,[And.intro]]
[Lean.Elab.deltaRHS?,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getMVarType', Pure.pure, Lean.Expr.eq?, Option.none, Lean.Meta.MetaM, Option, Lean.MVarId, liftM, Lean.Meta.delta?, BEq.beq, Lean.Meta.mkEq, coeM, Lean.Meta.replaceTargetDefEq, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing]]
[UInt16.size,[OfNat.ofNat]]
[Lean.Elab.Term.ElabAppArgs.State.etaArgs,[]]
[Lean.Elab.Term.MVarErrorKind.noConfusionType,[]]
[Lean.Parser.Term.tupleTail.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.termParser.formatter, Bool.false]]
[Std.Range.mk.inj,[And.intro]]
[List.mapA,[Unit.unit, List, Pure.pure, List.nil, Seq.seq, Functor.map, List.cons, PProd.fst]]
[UInt8.sub_def,[rfl]]
[FloatArray.noConfusionType,[]]
[Fin.instShiftLeftFin,[ShiftLeft.mk, Fin.shiftLeft]]
[termIfThenElse,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.const]]
[Lean.instBEqAttributeApplicationTime,[BEq.mk, BEq.beq, Lean.AttributeApplicationTime.toCtorIdx]]
[Lean.Elab.Term.CollectPatternVars.State.mk.inj,[And.intro]]
[Lean.ModuleIdx,[Nat]]
[Lean.Meta.CheckAssignment.instMonadCacheExprExprCheckAssignmentM,[Lean.MonadCache.mk, Bind.bind, MonadState.get, Pure.pure, Std.HashMap.find?, Lean.Meta.CheckAssignment.State.cache, Lean.ExprStructEq.mk, modify, Lean.Meta.CheckAssignment.State.mk, Std.HashMap.insert]]
[Lean.Json.CompressWorkItem.json.inj,[]]
[Lean.Lsp.TextEdit.noConfusionType,[]]
[String.repeat,[String.mk, List.repeat]]
[Lean.Expr.arrayLit?,[Unit.unit, Option, Prod, Lean.Expr, List, Lean.Expr.app2?, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Expr.listLit?, Option.none]]
[Lean.Meta.getMVars,[Bind.bind, StateRefT'.run, Lean.Meta.collectMVars, Lean.CollectMVars.State.mk, Lean.Meta.MetaM, Array, Lean.MVarId, Pure.pure, Lean.CollectMVars.State.result]]
[Alternative.orElse,[]]
[stx!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.isExtern,[Option.isSome, Lean.getExternAttrData]]
[and_not_self_iff,[Iff.intro, And.right, And.left, False.elim]]
[Lean.Tactic.solveByElim,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const]]
[Lean.Parser.Term.match.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.generalizingParam.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.Term.matchDiscr.parenthesizer, Bool.false, Lean.Parser.Term.optType.parenthesizer, Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Lean.Lsp.WorkDoneProgressReport.noConfusionType,[]]
[Lean.Elab.Command.StructFieldView.binderInfo,[]]
[Lean.Parser.isParserCategory,[Std.PersistentHashMap.contains, Lean.Parser.ParserExtension.State.categories, Lean.ScopedEnvExtension.getState, Lean.Parser.parserExtension]]
[Lean.Meta.mkAuxDefinition,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.Meta.Match.MatchEqns.splitterName,[]]
[Lean.Compiler.InlineAttributeKind.macroInline.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[exists_prop_decidable.proof_2,[mt]]
[Lean.Elab.MacroExpansionInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.instBEqVarId,[BEq.mk, BEq.beq, Lean.IR.VarId.idx]]
[Lean.Name.toString.maybePseudoSyntax,[Lean.Name.anonymous, Lean.Name.num, Bool, Lean.Name.getRoot, or, String.isPrefixOf, Bool.false]]
[Lean.IR.ExpandResetReuse.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.doSeqBracketed,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.withoutPosition, Lean.Parser.many1, Lean.Parser.Term.doSeqItem, Lean.Parser.ppLine]]
[Lean.Meta.CaseArraySizesSubgoal.elems,[]]
[Lean.Parser.Term.do,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.argPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.doSeq]]
[Lean.IR.Expr.uproj.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.uproj, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.whereDecls.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1Indent.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.Term.letRecDecl.parenthesizer, Lean.Parser.optional.parenthesizer]]
[Subtype.prop,[Subtype.property]]
[Nat.gcd_mul_lcm,[]]
[Lean.Export.alloc,[Bind.bind, MonadState.get, modify, Lean.Export.OfState.modify, Lean.Export.Alloc.mk, Std.HashMap.insert, Lean.Export.Alloc.map, HAdd.hAdd, OfNat.ofNat, Pure.pure]]
[Lean.Parser.symbol,[Lean.Parser.tokenWithAntiquot, Lean.Parser.symbolNoAntiquot]]
[Lean.Meta.project?,[Bind.bind, Lean.Meta.whnf, Lean.matchConstCtor, Lean.Expr.getAppFn, Pure.pure, Option.none, ite, LT.lt, Option.some, Lean.Expr.getArg!, Lean.Expr.getAppNumArgs]]
[Lean.PrettyPrinter.Formatter.eoi.formatter,[Pure.pure, Unit.unit]]
[Ord.compare,[]]
[String.takeRight,[Substring.toString, Substring.takeRight, String.toSubstring]]
[Char.isAlpha,[or, Char.isUpper, Char.isLower]]
[Lean.Macro.trace,[modify, Lean.Macro.State.mk, Lean.Macro.State.macroScope, List.cons, Prod.mk, Lean.Macro.State.traceMsgs]]
[Lean.Lsp.instHashableRange,[Hashable.mk, UInt64, mixHash, OfNat.ofNat, Hashable.hash]]
[Lean.Elab.throwAbortTactic,[MonadExcept.throw, Lean.Exception.internal, Lean.Elab.abortTacticExceptionId, Lean.KVMap.mk]]
[Lean.traceM,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, Pure.pure, PUnit.unit]]
[Lean.Parser.Term.termTry.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer, Lean.Parser.many.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.doCatch.parenthesizer, Lean.Parser.Term.doCatchMatch.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.doFinally.parenthesizer]]
[Lean.Lsp.DidChangeTextDocumentParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[MonadFinally.noConfusionType,[]]
[Lean.PrettyPrinter.Formatter.manyNoAntiquot.formatter,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.PrettyPrinter.Formatter.visitArgs, Nat.forM, Array.size, Lean.Syntax.getArgs]]
[Lean.Meta.FVarSubst.noConfusionType,[]]
[Lean.Expr.letE.inj,[And.intro]]
[List.isEqv,[List.nil, List.cons, Bool, Bool.true, and, PProd.fst, Bool.false]]
[Lean.Parser.Term.termUnless,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.withForbidden, Lean.Parser.termParser, Lean.Parser.Term.doSeq]]
[Lean.Elab.Term.Do.mkSeq,[Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.seq, Lean.Elab.Term.Do.CodeBlock.code, Lean.Elab.Term.Do.CodeBlock.uvars]]
[UInt32.ofNat,[UInt32.mk, Fin.ofNat]]
[Tactic.Ring.HornerExpr.noConfusionType,[]]
[Lean.Elab.ContextInfo.runMetaM,[Bind.bind, Lean.Core.CoreM.toIO, Lean.Core.Context.mk, Lean.Elab.ContextInfo.options, Lean.Elab.ContextInfo.currNamespace, Lean.Elab.ContextInfo.openDecls, Lean.Core.State.mk, Lean.Elab.ContextInfo.env, IO, Pure.pure]]
[Lean.Level.PP.Result.ibelow,[True, And]]
[Lean.Elab.instInhabitedTacticInfo,[Inhabited.mk, Lean.Elab.TacticInfo.mk, arbitrary]]
[Lean.PPContext.lctx,[]]
[Lean.Elab.Tactic.Conv.evalLhs,[Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Elab.Tactic.Conv.congr, ite, GE.ge, OfNat.ofNat, dite, LT.lt, List.length, ForIn.forIn, Unit.unit, Lean.Elab.Tactic.TacticM, ForInStep, Std.Range, Stream.next?, Pure.pure, ForInStep.done, Eq, bne, Bool.true, Lean.Meta.applyRefl, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, ForInStep.yield, PUnit.unit, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.get, List.nil, HSub.hSub, Int.ofNat]]
[Lean.Elab.checkSyntaxNodeKind,[Bind.bind, Lean.MonadEnv.getEnv, ite, Eq, Lean.Parser.isValidSyntaxNodeKind, Bool.true, Pure.pure, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.Elab.Command.withNamespace,[Bind.bind, Unit.unit, Lean.Name.num, Lean.Elab.Command.CommandElabM, Unit, Pure.pure, PProd.fst, Lean.MonadResolveName.getCurrNamespace, modify, Lean.Elab.Command.State.mk, Lean.Environment.registerNamespace, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, List.cons, Lean.Elab.Command.Scope.mk, Lean.Elab.Command.Scope.opts, Lean.Elab.Command.Scope.openDecls, Lean.Elab.Command.Scope.levelNames, Lean.Elab.Command.Scope.varDecls, Lean.Elab.Command.Scope.varUIds, or, Lean.Elab.Command.Scope.isNoncomputable, List.head!, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Lean.pushScope, ite, Eq, Bool.true, Lean.activateScoped, PUnit.unit, Lean.Name.mkStr, Lean.throwError, Lean.ToMessageData.toMessageData, Bool.false, List.drop, Lean.Name.getNumParts]]
[Lean.Widget.InfoPopup.exprExplicit,[]]
[Lean.Parser.Term.doSeqIndent.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.many1Indent.formatter, Lean.Parser.Term.doSeqItem.formatter]]
[Lean.PrettyPrinter.Formatter.checkTailWs.formatter,[Pure.pure, Unit.unit]]
[Lean.Server.FileWorker.GoToKind.declaration.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Expr.ReplaceImpl.cache.proof_1,[lcProof]]
[Lean.IR.instInhabitedVarId,[Inhabited.mk, Lean.IR.VarId.mk, arbitrary]]
[imp_iff_right,[Iff.intro, imp_intro]]
[Lean.Elab.Term.isMonadApp,[Bind.bind, Lean.Elab.Term.isTypeApp?, Option.none, Lean.Elab.Term.TermElabM, Bool, liftM, Lean.Meta.isMonad?, Pure.pure, Option.isSome, Bool.false]]
[Lean.Parser.Tactic.rcases?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.casesTarget, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[Lean.Meta.generalizeIndices,[Lean.Meta.withMVarContext, Bind.bind, Lean.MonadLCtx.getLCtx, Lean.Meta.getLocalInstances, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getLocalDecl, Lean.Meta.whnf, Lean.LocalDecl.type, Lean.Expr.withApp, Lean.matchConstInduct, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing, ite, GT.gt, Lean.InductiveVal.numIndices, OfNat.ofNat, Pure.pure, PUnit.unit]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.instMonadReaderOfSubExprAnalyzeM,[MonadReaderOf.mk, Functor.map, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.subExpr, MonadReader.read]]
[Lean.Parser.Attr.defaultInstance,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.optional, Lean.Parser.priorityParser]]
[Lean.Elab.Frontend.State.parserState,[]]
[List.cons_append,[rfl]]
[Function.update_eq_self,[Iff.mpr, Function.update_eq_iff, And.intro, rfl]]
[Int.zero_mul,[Int.mul_zero, Int.mul_comm, OfNat.ofNat]]
[Lean.Lsp.TextDocumentIdentifier.noConfusionType,[]]
[DoResultBC.noConfusionType,[]]
[Std.AssocList.all,[Unit.unit, Bool, Bool.true, and, PProd.fst]]
[optParam,[]]
[Lean.Elab.Deriving.FromToJson.mkToJsonInstanceHandler,[ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.isStructure, Array.getOp, Lean.Elab.Command.liftTermElabM, Option.none, Lean.Elab.Deriving.mkContext, Lean.Elab.Deriving.mkHeader, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.Deriving.Context.typeInfos, Array.mapM, Lean.Elab.Deriving.FromToJson.mkJsonField, Lean.Elab.Term.TermElabM, Lean.Syntax, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.mkIdent, HAppend.hAppend, Lean.Elab.Deriving.Header.targetNames, Lean.Syntax.atom, Lean.Elab.Deriving.Context.auxFunNames, Array.append, Lean.Elab.Deriving.Header.binders, Lean.Syntax.SepArray.elemsAndSeps, Lean.Syntax.SepArray.ofElems, Lean.Elab.Deriving.mkInstanceCmds, Array.forM, Lean.Elab.Command.elabCommand, Lean.getConstInfoInduct, Lean.Elab.Deriving.mkDiscrs, dite, Option.some, Eq.symm, Array.toArrayLit_eq, Array.getLit, of_decide_eq_true, id, Eq.refl, Lean.Quote.quote, Lean.Name.getString!, Lean.ConstantVal.name, Lean.ConstructorVal.toConstantVal, Lean.mkSepArray, Array.map, Lean.mkAtom, Array.mapIdxM, Fin.val, Lean.Elab.Deriving.Context.usePartial, Lean.Elab.Deriving.mkLocalInstanceLetDecls, Lean.Elab.Deriving.Header.argNames, Lean.Elab.Deriving.mkLet, PUnit.unit, Bool.false, Lean.Elab.Deriving.FromToJson.mkToJsonInstanceHandler.mkAlts]]
[Lean.Parser.Command.structure.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.structureTk.formatter, Lean.Parser.Command.classTk.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.many.formatter, Lean.ppSpace.formatter, Lean.Parser.Term.bracketedBinder.formatter, Bool.false, Lean.Parser.optional.formatter, Lean.Parser.Command.extends.formatter, Lean.Parser.Term.optType.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.structCtor.formatter, Lean.Parser.Command.structFields.formatter, Lean.Parser.Command.optDeriving.formatter]]
[Lean.instToFormatProdNameDataValue,[Std.ToFormat.mk, Std.Format, HAppend.hAppend, Std.ToFormat.format, Std.Format.text]]
[Lean.replaceRef,[Option.none, Lean.Syntax, Lean.Syntax.getPos?, Bool.false]]
[Lean.Elab.Command.ElabHeaderResult.lctx,[]]
[Lean.Xml.Content.Element.injEq,[Eq.propIntro, Eq.refl, Lean.Xml.Content.Element, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Tactic.elabTermEnsuringType,[Bind.bind, Lean.Elab.Tactic.elabTerm, Unit.unit, Lean.Elab.Tactic.TacticM, Lean.Expr, Pure.pure, liftM, Lean.Meta.inferType, Lean.Meta.withAssignableSyntheticOpaque, Lean.Meta.isDefEq, ite, Eq, Bool.true, PUnit.unit, Lean.Elab.Term.throwTypeMismatchError, Option.none]]
[Lean.KVMap.forIn,[List.forIn, Lean.KVMap.entries]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isDefEqAssigning,[MonadWithReader.withReader, Lean.Meta.Context.mk, Lean.Meta.Config.mk, Lean.Meta.Config.foApprox, Lean.Meta.Config.ctxApprox, Lean.Meta.Config.quasiPatternApprox, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Bool.true, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct, Lean.Meta.Context.lctx, Lean.Meta.Context.localInstances, Lean.Meta.Context.defEqCtx?, Lean.Meta.Context.synthPendingDepth, Lean.Meta.isDefEq]]
[Lean.Elab.ExpandDeclIdResult.levelNames,[]]
[Lean.Elab.Term.getMainModule,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Environment.mainModule]]
[UInt32.instSemiringUInt32.proof_4,[congrArg, UInt32.mk, AddMonoid.nsmul_succ', UInt32.val]]
[Lean.Level.Data.hasParam,[BEq.beq, UInt64.land, UInt64.shiftRight, OfNat.ofNat]]
[Lean.Occurrences.neg.injEq,[Eq.propIntro, Eq.refl, Lean.Occurrences.neg, Eq.symm, eq_of_heq, HEq.refl]]
[instHMod,[HMod.mk, Mod.mod]]
[iff_false_left,[Iff.intro, mt, Iff.mpr, iff_of_false]]
[not_of_not_not_not,[absurd, not_not_intro]]
[Lean.Expr.letName!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Name, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Server.FileWorker.SemanticTokensState.noConfusionType,[]]
[Lean.Elab.ContextInfo.noConfusionType,[]]
[Lean.Elab.Attribute.noConfusionType,[]]
[Lean.Meta.Match.instReprMatchEqns,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.Meta.Match.MatchEqns.eqnNames, Std.Format.line, Lean.Meta.Match.MatchEqns.splitterName, Lean.Meta.Match.MatchEqns.splitterAltNumParams]]
[decidable_of_iff',[decidable_of_decidable_of_iff, Iff.symm]]
[Lean.Occurrences.noConfusionType,[]]
[Lean.Syntax.setArg,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.node, Array.setD]]
[Lean.Elab.Tactic.Conv.isImplies,[ite, Eq, Lean.Expr.isArrow, Bool.true, andM, Lean.Meta.isProp, Lean.Expr.bindingDomain!, Lean.Expr.bindingBody!, Pure.pure, Bool.false]]
[Tactic.Ring.HornerExpr.xadd',[Bind.bind, Tactic.Ring.mkAppCS, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Tactic.Ring.HornerExpr.e, Prod.fst, List.nil, Pure.pure, Tactic.Ring.HornerExpr.xadd]]
[Lean.Meta.getCongrLemmas,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.ScopedEnvExtension.getState, Lean.Meta.congrExtension]]
[instInhabitedUSize,[Inhabited.mk, USize.ofNatCore, OfNat.ofNat, instInhabitedUSize.proof_1]]
[Semiring.zero_mul,[]]
[UInt16.instRingUInt16.proof_4,[congrArg, UInt16.mk, SubNegMonoid.gsmul_neg', UInt16.val]]
[Lean.isInitializerExecutionEnabled,[ST.Ref.get]]
[Lean.Lsp.CompletionItem.detail?,[]]
[List.drop_eq_nil_of_le,[Eq.mpr, Eq.refl, Eq, List.drop, List.nil, Eq.symm, List.length'_eq_length, List.drop_eq_nil_of_le']]
[Lean.Parser.many.formatter,[Lean.PrettyPrinter.Formatter.manyNoAntiquot.formatter, Lean.Parser.withAntiquotSpliceAndSuffix.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol.formatter]]
[Ring.sub_eq_add_neg,[]]
[Lean.Widget.Lean.Widget.InteractiveTermGoal.instRpcEncodingInteractiveTermGoalRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Lean.Widget.InteractiveTermGoal.hyps, Lean.Widget.InteractiveTermGoal.type, Lean.Widget.InteractiveTermGoal.range, Pure.pure, Lean.Server.RpcEncoding.rpcDecode, Lean.Widget.InteractiveTermGoal.mk]]
[Lean.Parser.Command.declaration,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Command.declModifiers, Bool.false, HOrElse.hOrElse, Lean.Parser.Command.abbrev, Lean.Parser.Command.def, Lean.Parser.Command.theorem, Lean.Parser.Command.constant, Lean.Parser.Command.instance, Lean.Parser.Command.axiom, Lean.Parser.Command.example, Lean.Parser.Command.inductive, Lean.Parser.Command.classInductive, Lean.Parser.Command.structure]]
[StdGen.mk.inj,[And.intro]]
[Lean.ExternEntry.adhoc.injEq,[Eq.propIntro, Eq.refl, Lean.ExternEntry.adhoc, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.SemanticTokenType.toNat,[Unit.unit, Nat, OfNat.ofNat]]
[Nat.foldAux,[PProd.fst, HSub.hSub, Nat.succ]]
[Lean.LocalContext.modifyLocalDecl,[Lean.LocalContext, Unit.unit, Lean.LocalContext.find?, Lean.LocalContext.mk, Std.PersistentHashMap.insert, Lean.LocalDecl.fvarId, Std.PersistentArray.set, Lean.LocalDecl.index, Option.some]]
[add_left_neg,[AddGroup.add_left_neg]]
[Lean.Lsp.LocationLink.originSelectionRange?,[]]
[EStateM.Result.ok.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.Do.DoIfView.ref,[]]
[Lean.Elab.Term.StructInst.ExplicitSourceInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.waitIfContainsMVar,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.termParser]]
[Std.PersistentHashSet.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Tactic.Conv.evalParen,[Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Server.parseRequestParams,[Except.mapError, Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.parseError, HAppend.hAppend, ToString.toString, Lean.Json.compress, Lean.FromJson.fromJson?]]
[Nat.zero_lt_of_lt,[LT.lt, OfNat.ofNat]]
[Ne.def,[rfl]]
[Lean.Meta.subst,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getLocalDecl, Lean.Meta.matchEq?, Lean.LocalDecl.type, Unit.unit, Lean.Meta.MetaM, Lean.MVarId, Lean.Meta.whnf, ite, Eq, Lean.Expr.isFVar, Bool.true, bne, Lean.Meta.mkEq, Lean.Meta.substCore, Lean.Meta.FVarSubst.mk, Pure.pure, Prod.snd, Bool.false, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Syntax.missing, Lean.LocalDecl.isLet, Lean.mkFVar, PUnit.unit]]
[Lean.Expr.FindImpl.findUnsafe?,[Id.run, StateT.run', Lean.Expr.FindImpl.findM?, Lean.Expr.FindImpl.cacheSize, Lean.Expr.FindImpl.initCache]]
[Lean.Elab.instantiateMVarsAtPreDecls,[Array.mapM, Bind.bind, liftM, Lean.Meta.instantiateMVars, Lean.Elab.PreDefinition.type, Lean.Elab.PreDefinition.value, Pure.pure, Lean.Elab.PreDefinition.mk, Lean.Elab.PreDefinition.ref, Lean.Elab.PreDefinition.kind, Lean.Elab.PreDefinition.levelParams, Lean.Elab.PreDefinition.modifiers, Lean.Elab.PreDefinition.declName]]
[Lean.Server.Watchdog.PendingRequestMap,[Std.RBMap, Lean.JsonRpc.RequestID, Lean.JsonRpc.Message, Ord.compare]]
[Lean.PrettyPrinter.Parenthesizer.numLit.parenthesizer,[Lean.Parser.Term.num.parenthesizer]]
[Lean.Elab.instToStringVisibility,[ToString.mk, Unit.unit, String]]
[Thunk.noConfusionType,[]]
[Lean.Lsp.ProgressParams.value,[]]
[Std.RBNode.balance₃,[Std.RBNode.leaf, Std.RBNode.node, Std.Rbcolor.red, Std.Rbcolor.black, Std.RBNode]]
[Lean.Xml.Parser.predefinedEntityToChar,[dite, Eq, Unit.unit, Eq.symm, Option, Lean.Xml.Parser.LeanChar, Option.some, Char.ofNat, Option.none]]
[ByteSlice.toArray,[ByteArray, ByteArray.extract]]
[Lean.Expr.fvarId!,[Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.FVarId, panicWithPosWithDecl, OfNat.ofNat]]
[List.length_pos_iff_exists_mem,[Iff.intro, List.exists_mem_of_length_pos, LT.lt, OfNat.ofNat, List.length, List.length_pos_of_mem]]
[Lean.Elab.Deriving.DecEq.mkAuxFunction,[Bind.bind, Pure.pure, Array.getOp, Lean.Elab.Deriving.Context.auxFunNames, OfNat.ofNat, Lean.Elab.Deriving.Context.typeInfos, Lean.Elab.Deriving.DecEq.mkDecEqHeader, Lean.Elab.Deriving.DecEq.mkMatch, Lean.Elab.Deriving.Header.argNames, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom, Lean.mkIdent, Lean.Elab.Deriving.Header.targetNames, Array.append]]
[of_as_true,[False.elim]]
[Lean.Lsp.SemanticTokensRangeParams.textDocument,[]]
[Nat.dvd_gcd,[Nat.gcd.induction, Eq.mpr, Eq.refl, Dvd.dvd, Nat.gcd, OfNat.ofNat, Nat.gcd_zero_left, Nat.gcd_rec, Iff.mpr, Nat.dvd_mod_iff]]
[Lean.IR.CompilerM,[ReaderT, Lean.Options, EStateM, String, Lean.IR.CompilerState]]
[Lean.Server.Watchdog.WorkerEvent.terminated.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Array.size_mkArray,[List.length_replicate]]
[Function.cantor_surjective,[False]]
[or_of_or_of_imp_right,[Or.imp_right]]
[Std.PersistentHashMap.find?,[Option, Std.PersistentHashMap.findAux, UInt64.toUSize, Hashable.hash]]
[Lean.ModuleData.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[ExceptT.bind_throw,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, LawfulMonad.pure_bind, Except.error, Except, Pure.pure, eq_self]]
[Nat.lt_of_sub_eq_succ,[Iff.mp, not_le, False.elim, Eq.mp, Eq.trans, congrFun, congrArg, Eq, Nat.sub_eq_zero_of_le, Nat.succ, eq_false']]
[Lean.PrefixTreeNode.Node.inj,[And.intro]]
[Lean.Parser.Term.letIdDeclNoBinders,[Lean.Parser.node, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.Term.ident, Lean.Parser.pushNone, Lean.Parser.Term.optType, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat]]
[Lean.QuotKind.lift.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Command.Scope.noConfusionType,[]]
[Lean.Elab.TacticInfo.goalsBefore,[]]
[Iff.noConfusionType,[]]
[Mathlib.Tactic.Lint.heuristicallyExtractSimpLemmasCore,[Id.run, Bind.bind, ForIn.forIn, ite, Eq, Std.PersistentHashSet.contains, Lean.Meta.SimpLemmas.toUnfold, Lean.Meta.Simp.Context.simpLemmas, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, Lean.SMap.contains, Lean.Meta.CongrLemmas.lemmas, Lean.Meta.Simp.Context.congrLemmas, Option.none, Id, ForInStep, Std.HashSet, Lean.Name, Std.HashMap.find?, Std.HashSet.toArray]]
[Lean.PrettyPrinter.Delaborator.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.TransparencyMode.reducible.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.SimplePersistentEnvExtensionDescr.mk.inj,[And.intro]]
[Set.mem,[]]
[Nat.dvd_gcd_iff,[Iff.intro, And.intro, Nat.dvd_trans, And.left, Nat.gcd_dvd, And.right, Nat.dvd_gcd]]
[Mem.mem,[]]
[IO.AsyncList.asyncTail.injEq,[Eq.propIntro, Eq.refl, IO.AsyncList.asyncTail, Eq.symm, eq_of_heq, HEq.refl]]
[ByteArray.foldlMUnsafe.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bind.bind, ByteArray.uget, lcProof, ByteArray.foldlMUnsafe.fold, HAdd.hAdd, OfNat.ofNat]]
[Nat.gcd_dvd_gcd_mul_right_right,[Nat.gcd_dvd_gcd_of_dvd_right, Nat.dvd_mul_right]]
[Lean.Elab.Command.instMonadLogCommandElabM,[Lean.Elab.MonadLog.mk, Lean.MonadRef.getRef, Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Command.Context.fileName, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.MessageLog.add, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState]]
[Lean.Parser.Command.declValSimple,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.optional, Lean.Parser.Term.whereDecls]]
[mul_one,[Monoid.mul_one]]
[Lean.PrettyPrinter.Delaborator.State.mk.inj,[And.intro]]
[Lean.Parser.Term.arrayRef.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.Meta.Cache.defEqAll,[]]
[Lean.Elab.Structural.mkBRecOn,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Subarray.foldr,[Id.run, Subarray.foldrM]]
[Lean.Meta.registerGetEqnsFn,[Bind.bind, Lean.initializing, ite, Eq, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, IO.userError]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withAppFn,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.PrettyPrinter.Delaborator.SubExpr.descend, Lean.Expr.appFn!, OfNat.ofNat]]
[Lean.Parser.Tactic.matchAlts.formatter,[Lean.Parser.Term.matchAlts.formatter, Lean.Parser.Tactic.matchRhs.formatter]]
[Lean.Elab.ElabInfo.noConfusionType,[]]
[Lean.Level.max.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Level.max, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.tacticRefine_lift_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.Elab.Command.ElabStructResult.projInfos,[]]
[Lean.Meta.Match.InjectionAnyResult.subgoal.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.instEval,[Lean.Eval.mk, IO.println, ToString.toString, Unit.unit]]
[Tactic.Ring.Cache.α,[]]
[neq_of_not_iff,[mt, Eq.to_iff]]
[Substring.drop,[Substring.mk, Substring, HAdd.hAdd, Substring.nextn, OfNat.ofNat]]
[Fin.val,[]]
[Lean.Environment.isProjectionFn,[Lean.MapDeclarationExtension.contains, Lean.projectionFnInfoExt]]
[Lean.PrettyPrinter.Delaborator.delabConst,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, MonadReader.read, Lean.PrettyPrinter.Delaborator.getPPOption, Lean.getPPPrivateNames, Lean.PrettyPrinter.Delaborator.unresolveNameGlobal, Lean.getPPUniverses, ite, Eq, or, List.isEmpty, not, Bool.true, Lean.MonadLCtx.getLCtx, Lean.LocalContext.usesUserName, and, BEq.beq, Lean.PrettyPrinter.Delaborator.Context.inPattern, Pure.pure, PUnit.unit, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkIdent, Lean.Syntax.atom, Array.append, List.nil, Lean.mkSepArray, Array.map, Lean.mkAtom, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.PersistentEnvExtensionState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.elabWaitIfTypeContainsMVar,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, liftM, Lean.MonadMCtx.getMCtx, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.MetavarContext.findUserName?, Lean.Syntax.getId, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.instantiateMVars, Lean.mkMVar, Lean.Meta.inferType, Lean.Expr.hasExprMVar, Lean.Elab.Term.tryPostpone, Pure.pure, PUnit.unit, Lean.Elab.throwUnsupportedSyntax]]
[Lean.MessageSeverity.error.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[ExceptT.bind,[ExceptT.mk, Bind.bind, ExceptT.bindCont]]
[System.SearchPath.parse,[List.map, System.FilePath.mk, String.split, BEq.beq, System.SearchPath.separator]]
[Lean.NameGenerator.next,[Lean.NameGenerator.mk, Lean.NameGenerator.namePrefix, HAdd.hAdd, Lean.NameGenerator.idx, OfNat.ofNat]]
[emptyWf.proof_1,[WellFounded.intro, Acc.intro, Acc, emptyRelation, Eq.refl]]
[Lean.IR.UnreachableBranches.InterpContext.decls,[]]
[Id.run,[]]
[Lean.EnvExtensionInterfaceUnsafe.Ext.mk.inj,[And.intro]]
[Lean.Lsp.ClientCapabilities.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.ClientCapabilities.toCtorIdx]]
[Lean.Server.WithRpcRef.mk.inj,[]]
[Std.HashMap.numBuckets,[Array.size, Subtype.val, Std.HashMapImp.buckets]]
[Lean.Json.pretty,[Std.Format.pretty, Lean.Json.render]]
[Lean.Parser.Level.paren,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.levelParser]]
[Id.bind_eq,[rfl]]
[ne_true_of_eq_false,[Not, Eq, Bool.true]]
[Lean.Expr.projExpr!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr, panicWithPosWithDecl, OfNat.ofNat]]
[Nat.sub_lt,[LT.lt, HSub.hSub, absurd, Nat.lt_irrefl, OfNat.ofNat, Eq.symm, Nat.succ_sub_succ_eq_sub]]
[Lean.Compiler.SpecEntry.cache.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Command.CollectAxioms.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.CollectAxioms.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Function.update_comp_eq_of_injective,[Function.update_comp_eq_of_injective']]
[Lean.IR.ExplicitRC.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.getInitFnNameFor?,[HOrElse.hOrElse, Lean.getBuiltinInitFnNameFor?, Lean.getRegularInitFnNameFor?]]
[Lean.Parser.Tactic.«tactic_<;>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Lsp.instInhabitedDiagnosticRelatedInformation,[Inhabited.mk, Lean.Lsp.DiagnosticRelatedInformation.mk, arbitrary]]
[Lean.Syntax.decodeNameLit,[ite, Eq, BEq.beq, String.get, OfNat.ofNat, Char.ofNat, Bool.true, Unit.unit, List.cons, Option, Lean.Name, Substring.drop, String.toSubstring, List.nil, Option.none, Option.some, List.foldr, Lean.isIdBeginEscape, String.front, Lean.Name.mkStr, String.dropRight, String.drop, Lean.Name.anonymous]]
[Lean.Elab.PreDefinition.declName,[]]
[Lean.Elab.Term.elabSort,[Bind.bind, ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, Lean.levelZero, Lean.Elab.Term.elabLevel, Lean.Syntax.getOp, OfNat.ofNat, Lean.mkSort]]
[Lean.Elab.Tactic.evalRefine,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Tactic.refineCore, Bool.false, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Rat.instSubRat,[Sub.mk, Lean.Rat.sub]]
[Function.const,[]]
[Lean.Lsp.instToJsonSymbolKind,[Lean.ToJson.mk, Unit.unit, Lean.Json, OfNat.ofNat]]
[USize.ofNat,[USize.mk, Fin.ofNat', usize_size_gt_zero]]
[heq_of_eq,[Eq.subst, HEq.refl]]
[Lean.Elab.Command.addLinter,[Bind.bind, ST.Ref.get, Lean.Elab.Command.lintersRef, ST.Ref.set, Array.push]]
[Lean.Meta.Instances.erase,[ite, Eq, Std.PersistentHashSet.contains, Lean.Meta.Instances.instanceNames, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Std.PArray,[Std.PersistentArray]]
[Lean.Parser.Command.terminationBy.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.terminationHint.formatter, Lean.Parser.termParser.formatter]]
[Lean.Elab.applyDerivingHandlers,[Bind.bind, ST.Ref.get, Lean.Elab.derivingHandlersRef, Unit.unit, Lean.Elab.Command.CommandElabM, Unit, Lean.NameMap.find?, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Elab.defaultHandler]]
[Lean.getConstInfoRec,[Bind.bind, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.RecursorVal, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkConst, List.nil]]
[UInt8.zero_def,[rfl]]
[Lean.Parsec.eof,[ite, Eq, String.Iterator.hasNext, Bool.true, Lean.Parsec.ParseResult.error, Lean.Parsec.expectedEndOfInput, Lean.Parsec.ParseResult.success, Unit.unit]]
[Except.error.inj,[]]
[Array.findIdx?.loop,[dite, LT.lt, Array.size, Option, Nat, False.elim, Array.findIdx?.loop.proof_1, ite, Eq, Array.get, Fin.mk, Bool.true, Option.some, Option.none]]
[Lean.PrettyPrinter.Formatter.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Formatter.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.elabFun,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.liftMacroM, Lean.Elab.Term.expandFunBinders, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Elab.Term.elabFunBinders, Lean.Elab.Term.elabTermEnsuringType, Option.none, liftM, Lean.Meta.mkLambdaFVars, Bool.false, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Meta.Simp.tryRewriteCtorEq,[Bind.bind, liftM, Lean.Meta.Simp.rewriteCtorEq?, Unit.unit, Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step, Pure.pure, Lean.Meta.Simp.Step.done]]
[Lean.RecursorVal.mk.inj,[And.intro]]
[apply_dite,[Decidable.em, of_eq_true, Eq.trans, congr, congrArg, Eq, dite_congr, eq_true, Eq.refl, Eq.mpr_prop, Eq.mpr_not, dite_true, eq_self, True.intro, Eq.symm, eq_false, dite_false, not_false]]
[Lean.LBool.toCtorIdx,[OfNat.ofNat]]
[Lean.Widget.InfoWithCtx.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[IO.FS.SystemTime.sec,[]]
[instOrElse,[OrElse.mk, Alternative.orElse]]
[Lean.Meta.SortLocalDecls.Context.localDecls,[]]
[Lean.Parser.Term.haveEqnsDecl,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.Term.haveIdLhs, Lean.Parser.Term.matchAlts, Lean.Parser.termParser, OfNat.ofNat, Bool.false]]
[ByteArray.forIn.loop.proof_1,[Nat.lt_of_le_of_lt, Nat.sub_le, HSub.hSub, ByteArray.size, OfNat.ofNat, Nat.sub_lt, Nat.zero_lt_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self, of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Elab.Structural.EqnInfo.levelParams,[]]
[Lean.Parser.pushNone,[Lean.Parser.Parser.mk, Lean.Parser.ParserState.pushSyntax, Lean.mkNullNode, List.toArray, List.nil]]
[Lean.Server.FileWorker.Reference.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.FileWorker.Reference.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Xml.Parser.document,[SeqLeft.seqLeft, SeqRight.seqRight, Lean.Xml.Parser.prolog, Lean.Xml.Parser.element, Lean.Parsec.many, Lean.Xml.Parser.Misc, Lean.Parsec.eof]]
[Lean.MonadCacheT.instMonadRefMonadCacheT,[inferInstanceAs, Lean.MonadRef, StateRefT', Std.HashMap]]
[Lean.IR.instInhabitedAlt,[Inhabited.mk, Lean.IR.Alt.default, arbitrary]]
[Array.appendCore.loop,[dite, LT.lt, Array.size, Unit.unit, Array, PProd.fst, HAdd.hAdd, OfNat.ofNat, Array.push, Array.get, Fin.mk]]
[Lean.Meta.Match.MatchEqnsExtState.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.MatchEqnsExtState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.openHiding.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer]]
[Lean.Meta.Closure.mkValueTypeClosure,[Bind.bind, StateRefT'.run, ReaderT.run, Lean.Meta.Closure.mkValueTypeClosureAux, Lean.Meta.Closure.Context.mk, Lean.Meta.Closure.State.mk, Lean.Meta.MetaM, Lean.Meta.Closure.MkValueTypeClosureResult, Pure.pure, Lean.Meta.Closure.MkValueTypeClosureResult.mk, Lean.Meta.Closure.State.levelParams, Lean.Meta.Closure.State.levelArgs, HAppend.hAppend, Array.reverse, Lean.Meta.Closure.State.exprFVarArgs, Lean.Meta.Closure.State.exprMVarArgs]]
[IO.FS.Stream.putStr,[]]
[Lean.IR.instToFormatLitVal,[Std.ToFormat.mk, Std.Format, Std.ToFormat.format, repr]]
[Lean.AttributeKind.local.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.attrParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Meta.instReprElimAltInfo,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.Meta.ElimAltInfo.name, Std.Format.line, Lean.Meta.ElimAltInfo.numFields]]
[Lean.Lsp.Ipc.ipcStdioConfig,[IO.Process.StdioConfig.mk, IO.Process.Stdio.piped, IO.Process.Stdio.inherit]]
[Lean.MessageData.withContext.inj,[And.intro]]
[Lean.Parser.Command.macroRhs.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.MetavarDecl.depth,[]]
[Nat.instCommSemiringNat,[CommSemiring.mk, Nat.mul_comm]]
[ByteArray.foldlM.loop.proof_1,[Nat.lt_of_lt_of_le]]
[Lean.Lsp.WorkDoneProgressReport.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.WorkDoneProgressReport.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Delaborator.Context.subExpr,[]]
[Nat.find_spec,[And.left, Subtype.property, Nat.find_x]]
[Lean.Meta.simpGoal,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, ForIn.forIn, MProd.mk, Option.none, Lean.Meta.getLocalDecl, Lean.Meta.instantiateMVars, Lean.LocalDecl.type, Unit.unit, Lean.Meta.MetaM, ForInStep, MProd, Option, Prod, Array, Lean.FVarId, Lean.MVarId, Lean.Meta.Hypothesis, Std.RBMap.find?, Lean.LocalDecl.fvarId, Pure.pure, Lean.Meta.SimpLemmas.eraseCore, Lean.Meta.Simp.Context.simpLemmas, Lean.Meta.Simp.Context.mk, Lean.Meta.Simp.Context.config, Lean.Meta.Simp.Context.congrLemmas, Lean.Meta.Simp.Context.parent?, Lean.Meta.Simp.Context.dischargeDepth, MProd.fst, PUnit.unit]]
[Or.intro_left,[Or.inl]]
[List.disjoint_symm,[]]
[Lean.Lsp.instFileSourceDidChangeTextDocumentParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.DidChangeTextDocumentParams.textDocument]]
[tacticBy_cases_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.DeclarationRanges.selectionRange,[]]
[Lean.Elab.Term.State.mvarErrorInfos,[]]
[StateT,[Prod]]
[instSubsingletonSquash.proof_1,[Subsingleton.intro, Squash.ind, Quot.sound, True.intro]]
[Lean.Parser.Module.updateTokens,[Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.prec, Lean.Parser.TokenTable, Lean.Parser.addParserTokens, Lean.Parser.ParserContext.tokens, Lean.Parser.Parser.info, Lean.Parser.Module.header, panicWithPosWithDecl, OfNat.ofNat, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Lean.Parser.ParserContext.savedPos?, Lean.Parser.ParserContext.forbiddenTk?]]
[Lean.Elab.Command.command_Irreducible_def___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[Lean.Meta.intros,[Bind.bind, Lean.Meta.getMVarType, Lean.Meta.instantiateMVars, ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Pure.pure, Prod.mk, List.toArray, List.nil, Lean.Meta.introN, Bool.false]]
[Lean.Syntax.decodeCharLit,[OptionM.run, ite, Eq, BEq.beq, Char.ofNat, Bool.true, Bind.bind, Lean.Syntax.decodeQuotedChar, OfNat.ofNat, OptionM, Char, Pure.pure]]
[Lean.Parser.Tactic.tacticRefine_lift'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.Parser.Term.sorry,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Lean.Parser.Command.terminationHint,[HOrElse.hOrElse, Lean.Parser.Command.terminationHintMany, Lean.Parser.Command.terminationHint1]]
[Int.subNatNat,[Unit.unit, Int, HSub.hSub, Int.ofNat, Int.negSucc]]
[UInt8.instAddCommSemigroupUInt8.proof_1,[congrArg, UInt8.mk, AddCommSemigroup.add_comm, UInt8.val]]
[id_eq,[rfl]]
[Option.bind,[Option, Option.none]]
[Nat.gcd_mul_gcd_of_coprime_of_mul_eq_mul,[Nat.dvd_antisymm, Nat.coprime.dvd_of_dvd_mul_right, Nat.coprime.mul, Nat.coprime.gcd_left, Eq.mpr, Eq.refl, Dvd.dvd, HMul.hMul, Nat.gcd, Eq.symm, Nat.mul_dvd_mul, And.left, Nat.gcd_dvd, Nat.gcd_comm]]
[Lean.Elab.Term.StructInst.instToStringFieldStruct,[ToString.mk, Function.comp, ToString.toString, Std.ToFormat.format]]
[Tactic.Ring.State.atoms,[]]
[Lean.IR.ExplicitRC.updateVarInfoWithParams,[Lean.IR.ExplicitRC.Context.mk, Lean.IR.ExplicitRC.Context.env, Lean.IR.ExplicitRC.Context.decls, Lean.IR.ExplicitRC.Context.jpLiveVarMap, Lean.IR.ExplicitRC.Context.localCtx]]
[Lean.Elab.IO.processCommands,[Bind.bind, StateRefT'.run, ReaderT.run, Lean.Elab.Frontend.processCommands, Lean.Elab.Frontend.Context.mk, Lean.Elab.Frontend.State.mk, Lean.Parser.ModuleParserState.pos, IO, Lean.Elab.Frontend.State, Pure.pure]]
[Lean.Environment.evalConstCheck,[Unit.unit, ExceptT, String, Id, Lean.Environment.find?, MonadExcept.throw, HAppend.hAppend, ToString.toString, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.ConstantInfo.type, ite, Eq, bne, Bool.true, Lean.Environment.evalConst]]
[Lean.Meta.CaseArraySizesSubgoal.mvarId,[]]
[Lean.Syntax.updateLeading,[StateT.run', Lean.Syntax.replaceM, Lean.Syntax.missing, Lean.Syntax.node, Lean.SourceInfo.original, Lean.Syntax.atom, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Lean.Syntax.ident, StateM, String.Pos, Option, Lean.Syntax, Bind.bind, MonadState.get, MonadStateOf.set, Pure.pure, Option.some, Option.none, OfNat.ofNat]]
[Lean.Parser.Tactic.eraseAuxDiscrs.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.symbol.parenthesizer]]
[Lean.Elab.Deriving.DecEq.mkDecEq,[Bind.bind, Lean.getConstInfoInduct, ite, Eq, Lean.InductiveVal.isNested, Bool.true, Pure.pure, Bool.false, Lean.Elab.Command.liftTermElabM, Option.none, Lean.Elab.Deriving.DecEq.mkDecEqCmds, Array.forM, Lean.Elab.Command.elabCommand, OfNat.ofNat, Array.size]]
[Lean.Parser.Trie.Node.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.refl, Std.RBNode.leaf, Eq.trans, congr, congrFun, Eq.symm, Std.RBNode.node.sizeOf_spec]]
[Lean.Expr.FindImpl.cacheSize,[OfNat.ofNat]]
[Lean.Syntax.isNameLit?,[Option.none, Option, Lean.Name, Lean.Syntax.isLit?, Lean.nameLitKind, Lean.Syntax.decodeNameLit]]
[Lean.Parser.TokenMap.instInhabitedTokenMap,[Inhabited.mk, Std.RBMap.empty]]
[or_true,[propext, Iff.intro, trivial, Or.inr]]
[Lean.Elab.InfoTree.hole.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.InfoTree.hole, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.let,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, Lean.Parser.symbol, Lean.Parser.Term.letDecl, Lean.Parser.Term.optSemicolon, Lean.Parser.termParser, OfNat.ofNat]]
[Lean.Parser.Term.forInMacro,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.maxPrec]]
[Lean.Expr.lit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.mkSProjExpr,[Lean.IR.Expr.sproj]]
[Lean.Meta.SimpAll.Entry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SimpAll.Entry.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.identKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[IO.AccessRight.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.AccessRight.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Name.mkNum.proof_1,[of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.FileMap.lines,[]]
[Prod.RProdSubLex.proof_1,[Prod.Lex.left, Eq.symm, eq_of_heq, Eq.refl, HEq.refl]]
[ExceptT.lift,[ExceptT.mk, Functor.map, Except.ok]]
[Lean.Parser.Tactic.inhabit,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.IR.AltCore.modifyBody,[Lean.IR.Alt, Lean.IR.Alt.ctor, Lean.IR.Alt.default]]
[Lean.Elab.MacroStackElem.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.MacroStackElem.mk, Eq.symm, eq_of_heq, HEq.refl]]
[instAddUInt8,[Add.mk, UInt8.add]]
[Lean.Meta.getExpectedNumArgsAux,[Lean.Meta.withDefault, Lean.Meta.forallTelescopeReducing, Pure.pure, Prod.mk, Array.size, Lean.Expr.isMVar, Lean.Expr.getAppFn]]
[Std.HashMapImp.forBucketsM,[Array.forM, Std.AssocList.forM, Subtype.val, OfNat.ofNat, Array.size]]
[Lean.Meta.IndPredBelow.BrecOnVariables.params,[]]
[Lean.Elab.Term.NamedArg.name,[]]
[UInt32.decEq.proof_1,[rfl]]
[Lean.Parser.Term.subst.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.termParser.formatter, Bool.false]]
[Lean.AddMessageContext.addMessageContext,[]]
[hidden,[]]
[Lean.ParserCompiler.CombinatorAttribute.noConfusionType,[]]
[Nat.mod_eq,[congrFun, WellFounded.fix_eq, WellFoundedRelation.wf, measure, id, dite, And, LT.lt, OfNat.ofNat, LE.le, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le, dif_eq_if, HMod.hMod]]
[Lean.Meta.InfoCacheKey.noConfusionType,[]]
[Lean.Elab.Term.Quotation.resolveSectionVariable,[Lean.MacroScopesView.name, List.nil, Lean.Elab.Term.Quotation.resolveSectionVariable.loop]]
[Nat.coprime_self,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, Eq, Nat.gcd_self, OfNat.ofNat, iff_self]]
[Lean.Meta.Simp.Result.getProof,[Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.Meta.Simp.Result.proof?, Pure.pure, Lean.Meta.mkEqRefl, Lean.Meta.Simp.Result.expr]]
[Lean.Elab.InfoTree.context.inj,[And.intro]]
[Lean.Parser.Term.assert.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Lean.Parser.Term.optSemicolon.formatter]]
[Lean.IR.LocalContextEntry.joinPoint.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.LocalContextEntry.joinPoint, Eq.symm, eq_of_heq, HEq.refl]]
[Std.HashSet.erase,[Std.HashSet, Subtype.mk, Std.HashSetImp.erase, Std.HashSetImp.WellFormed.eraseWff]]
[Lean.Elab.CompletionInfo.tactic.inj,[And.intro]]
[Lean.Parser.Tactic.simpStar,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol]]
[Lean.Elab.Command.elabSetOption,[Bind.bind, Lean.Elab.elabSetOption, Lean.Syntax.getOp, OfNat.ofNat, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Option.get, Lean.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Lean.Elab.Command.modifyScope, Lean.Elab.Command.Scope.mk, Lean.Elab.Command.Scope.header, Lean.Elab.Command.Scope.currNamespace, Lean.Elab.Command.Scope.openDecls, Lean.Elab.Command.Scope.levelNames, Lean.Elab.Command.Scope.varDecls, Lean.Elab.Command.Scope.varUIds, Lean.Elab.Command.Scope.isNoncomputable]]
[Lean.JsonRpc.ErrorCode.rpcNeedsReconnect.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Group.mul_left_inv,[]]
[Std.PersistentHashMap.Stats.numCollisions,[]]
[Lean.AttributeExtensionState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Xml.Parser.PI,[Bind.bind, SeqLeft.seqLeft, Lean.Parsec.skipString, Lean.Xml.Parser.PITarget, optional, SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Parsec.manyChars, Lean.Parsec.notFollowedBy, Lean.Xml.Parser.Char]]
[Lean.Meta.CongrLemmas.lemmas,[]]
[Lean.Parser.Tactic.clearValue,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const]]
[Mul.mul,[]]
[Lean.Parser.Tactic.applyFun,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location, Lean.ParserDescr.symbol]]
[Lean.PrettyPrinter.Delaborator.ParamKind.bInfo,[]]
[Lean.SyntaxNode.getNumArgs,[Lean.SyntaxNode.withArgs, Array.size]]
[Id.instOfNatId,[inferInstanceAs, OfNat]]
[Lean.Parser.mkParserOfConstant,[Lean.Parser.mkParserOfConstantAux, Lean.Parser.compileParserDescr]]
[Lean.Lsp.StaticRegistrationOptions.id?,[]]
[Lean.MVarId.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Simp.Context.dischargeDepth,[]]
[Nat.div_eq_of_lt,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, OfNat.ofNat, Nat.div_eq, ite, And, LT.lt, LE.le, HAdd.hAdd, HSub.hSub, if_neg, Nat.not_le_of_gt, And.right, rfl]]
[Lean.Option.Decl.defValue,[]]
[ReprAtom.noConfusionType,[]]
[Lean.KeyedDeclsAttribute.ExtensionState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[inv_eq_of_mul_eq_one,[left_inv_eq_right_inv, inv_mul_self]]
[Subtype.map_involutive,[Subtype.ext, Subtype.val]]
[Lean.Parser.Term.doLetArrow,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.withPosition, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, HOrElse.hOrElse, Lean.Parser.Term.doIdDecl, Lean.Parser.Term.doPatDecl]]
[Lean.ConstantInfo.value?,[Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Option, Lean.Expr, Option.some, Option.none]]
[Nat.lt_by_cases,[Nat.lt_ge_by_cases, Nat.le_antisymm]]
[Lean.IR.checkDecl,[Bind.bind, Lean.IR.getEnv, Except.ok, Lean.IR.CompilerM, Unit, StateT.run', Lean.IR.Checker.checkDecl, Lean.IR.Checker.CheckerContext.mk, Lean.IR.Checker.CheckerState.mk, MonadExcept.throw, HAppend.hAppend, ToString.toString, Lean.IR.Decl.name, Pure.pure, Unit.unit]]
[Nat.gcd_dvd,[Nat.gcd.induction, And.intro, Exists.intro, OfNat.ofNat, of_eq_true, Eq.trans, congrArg, Eq, congrFun, HMul.hMul, Nat.gcd_zero_left, Nat.mul_zero, eq_true_of_decide, Eq.refl, Bool.true, Nat.mul_one, eq_self, Eq.mpr, Dvd.dvd, Nat.gcd, Nat.gcd_rec, Iff.mp, Nat.dvd_mod_iff, Eq.mp, HMod.hMod, Eq.symm]]
[Lean.Elab.Term.Do.ToCodeBlock.ensureInsideFor,[Bind.bind, MonadReader.read, ite, Eq, Lean.Elab.Term.Do.ToCodeBlock.Context.insideFor, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Int.sign_neg_one,[rfl]]
[Nat.coprime_one_right_iff,[of_eq_true, Eq.trans, congr, congrArg, Iff, congrFun, Eq, Nat.gcd_one_right, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true]]
[Lean.Elab.Term.MutualClosure.ClosureState.newLetDecls,[]]
[Lean.Elab.Term.StructInst.instInhabitedFieldLHS,[Inhabited.mk, Lean.Elab.Term.StructInst.FieldLHS.fieldName, arbitrary]]
[Decidable.peirce,[dite, Not.elim]]
[Lean.Compiler.foldStrictAnd,[Option.none, Option.some, Bool.false, Bool.true, Option, Lean.Expr]]
[Lean.FVarIdHashSet,[Std.HashSet, Lean.FVarId]]
[Lean.FVarIdMap,[Std.RBMap, Lean.FVarId, Lean.Name.quickCmp, Lean.FVarId.name]]
[Lean.Level.depth,[UInt32.toNat, Lean.Level.Data.depth, Lean.Level.data]]
[Lean.PrettyPrinter.Delaborator.annotateCurPos,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getPos, Pure.pure, Lean.PrettyPrinter.Delaborator.annotatePos]]
[Nat.sub_pos_of_lt,[Nat.lt_of_add_lt_add_right, Eq.mpr, Eq.refl, LT.lt, HAdd.hAdd, OfNat.ofNat, HSub.hSub, Nat.zero_add, Nat.sub_add_cancel, Nat.le_of_lt]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.containsBadMax,[Lean.Level.zero, Lean.Level.param, Lean.Level.mvar, Bool, PProd.fst, or, and, Lean.Level.hasParam, PProd.snd, Bool.false]]
[bfix6,[PProd.fst]]
[Lean.Elab.Command.elabNamespace,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Unit.unit, Lean.Name.num, Lean.Elab.Command.CommandElabM, Unit, Pure.pure, Bind.bind, PProd.fst, Lean.MonadResolveName.getCurrNamespace, modify, Lean.Elab.Command.State.mk, Lean.Environment.registerNamespace, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, List.cons, Lean.Elab.Command.Scope.mk, Lean.Elab.Command.Scope.opts, Lean.Elab.Command.Scope.openDecls, Lean.Elab.Command.Scope.levelNames, Lean.Elab.Command.Scope.varDecls, Lean.Elab.Command.Scope.varUIds, or, Lean.Elab.Command.Scope.isNoncomputable, List.head!, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Lean.pushScope, Lean.activateScoped, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData, Bool.false, Lean.Syntax.getId, Lean.Elab.throwUnsupportedSyntax]]
[instHashableFin,[Hashable.mk, Nat.toUInt64, Fin.val]]
[Lean.IR.instToFormatVarId,[Std.ToFormat.mk, Std.Format.text, ToString.toString]]
[Std.PersistentHashMap.Stats.toString,[HAppend.hAppend, ToString.toString, Std.PersistentHashMap.Stats.numNodes, Std.PersistentHashMap.Stats.numNull, Std.PersistentHashMap.Stats.numCollisions, Std.PersistentHashMap.Stats.maxDepth]]
[Mathlib.Tactic.Lint.printWarnings,[Bind.bind, Mathlib.Tactic.Lint.sortResults, Array.mapM, Lean.Core.CoreM, Lean.MessageData, Mathlib.Tactic.Lint.printWarning, Pure.pure, Lean.MessageData.joinSep, Array.toList, Lean.MessageData.ofFormat, Std.Format.line]]
[Lean.Meta.ppGoal.pushPending,[ite, Eq, List.isEmpty, Bool.true, Pure.pure, Unit.unit, Lean.Meta.MetaM, Std.Format, Bind.bind, Lean.Meta.ppExpr, HAppend.hAppend, Std.Format.group, Std.Format.joinSep, List.reverse, Std.ToFormat.format, Std.Format.text, Std.Format.nest, Std.Format.line, Std.Format.FlattenBehavior.allOrNone]]
[Lean.Lsp.instFileSourceDefinitionParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.DefinitionParams.toTextDocumentPositionParams]]
[Lean.Parser.addSyntaxNodeKind,[Lean.ScopedEnvExtension.addEntry, Lean.Parser.parserExtension, Lean.Parser.ParserExtension.Entry.kind]]
[Lean.InductiveType.ctors,[]]
[Lean.SyntaxNode.modifyArgs,[Lean.Syntax, Lean.Syntax.node, Lean.unreachIsNodeMissing, Lean.unreachIsNodeAtom, Lean.unreachIsNodeIdent]]
[Lean.PrettyPrinter.Delaborator.isFOLike,[Pure.pure, or, Lean.Expr.isFVar, Lean.Expr.isConst]]
[Lean.KernelException.noConfusionType,[]]
[Lean.Compiler.mkNatLe,[Lean.mkAppN, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.levelZero, List.nil, List.toArray]]
[Lean.Parser.FirstTokens.toOptional,[Lean.Parser.FirstTokens.epsilon, Lean.Parser.FirstTokens.unknown, Lean.Parser.FirstTokens.optTokens, Lean.Parser.FirstTokens]]
[Lean.Literal.noConfusionType,[]]
[Lean.addClass,[ite, Eq, Lean.isClass, Bool.true, Except.error, HAppend.hAppend, ToString.toString, Unit.unit, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Except, String, Lean.Environment, Lean.Environment.find?, Bind.bind, OfNat.ofNat, List.toArray, List.nil, Lean.ConstantInfo.type, Except.ok, Lean.PersistentEnvExtension.addEntry, Lean.classExtension, Lean.ClassEntry.mk]]
[Lean.LeanPaths.noConfusionType,[]]
[List.exists_cons_of_ne_nil,[absurd, Eq.refl, List.nil, Exists.intro, rfl]]
[Lean.Elab.Command.StructFieldView.name,[]]
[Lean.RecursorVal.numMotives,[]]
[optionCoe,[CoeTail.mk, Option.some]]
[Lean.Macro.throwUnsupported,[MonadExcept.throw, Lean.Macro.Exception.unsupportedSyntax]]
[Lean.Parser.Command.end,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.ident]]
[Lean.Elab.Command.catchExceptions,[EIO.catchExceptions, Lean.Elab.Command.withLogging, Pure.pure, Unit.unit]]
[Lean.IR.IRType.instBEqIRType,[BEq.mk, Lean.IR.IRType.beq]]
[StateCpsT,[]]
[CommSemigroup.toSemigroup,[]]
[Lean.ScopedEnvExtension.ScopedEntries.mk.injEq,[Eq.propIntro, Eq.refl, Lean.ScopedEnvExtension.ScopedEntries.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.getMainModuleDoc,[Lean.SimplePersistentEnvExtension.getState]]
[Lean.Elab.expandOptDeclSig,[ite, Eq, Lean.Syntax.isNone, Bool.true, Prod.mk, Option.none, Option.some, Lean.Syntax.getOp, OfNat.ofNat]]
[instHXor,[HXor.mk, Xor.xor]]
[instMonadReaderOf,[MonadReaderOf.mk, liftM, MonadReader.read]]
[Lean.Meta.SynthInstance.hasInferTCGoalsRLAttribute,[Lean.TagAttribute.hasTag, Lean.Meta.SynthInstance.inferTCGoalsRLAttr]]
[Std.ShareCommon.Object,[NonScalar]]
[Lean.Meta.Match.MatcherInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Closure.MkValueTypeClosureResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instReprULift,[Repr.mk, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg, ULift.down]]
[Lean.IR.EmitC.toCName,[Bind.bind, Lean.IR.EmitC.getEnv, Unit.unit, Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Lean.IR.EmitC.M, String, Lean.getExportNameFor, Pure.pure, Lean.IR.EmitC.throwInvalidExportName, ite, Eq, BEq.beq, Lean.Name.mkStr, Bool.true, Lean.IR.EmitC.leanMainFn, Lean.Name.mangle]]
[Lean.Elab.Command.ElabStructResult.localInsts,[]]
[Lean.SCC.Data.index?,[]]
[Lean.Parser.Term.ensureExpectedType,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.strLit, Lean.Parser.termParser, Lean.Parser.maxPrec]]
[Lean.mkInductiveDeclEs,[Lean.Declaration.inductDecl]]
[Lean.recOnSuffix,[]]
[Lean.IR.Expr.reset.inj,[And.intro]]
[ForInStep.yield.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.exists_of_length_succ,[Exists, Eq, List.cons, absurd, Eq.symm, Nat.succ_ne_zero, Exists.intro, rfl]]
[Lean.Parser.isEOI,[Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous]]
[IO.Error.mkProtocolError,[IO.Error.protocolError]]
[Function.inv_fun_on,[dite, Exists, And, Mem.mem, Eq, Classical.choose, Classical.choice]]
[UInt8.add_def,[rfl]]
[Classical.indefiniteDescription.proof_1,[Nonempty, Subtype, Nonempty.intro, Subtype.mk]]
[Lean.PrettyPrinter.Delaborator.delabNameMkStr,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPNotation, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.PrettyPrinter.Delaborator.reifyName, Pure.pure, Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.mkNameLit, HAppend.hAppend, ToString.toString, Lean.SourceInfo.none, List.nil]]
[Lean.Meta.getLocalDeclFromUserName,[Bind.bind, Lean.MonadLCtx.getLCtx, Unit.unit, Lean.Meta.MetaM, Lean.LocalDecl, Lean.LocalContext.findFromUserName?, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.StructureFieldInfo.noConfusionType,[]]
[Prod.snd_swap,[rfl]]
[Lean.Environment.extensions,[]]
[Nat.mul_dvd_mul,[Dvd.dvd, HMul.hMul, Exists.intro, Eq.mpr, Eq.refl, Eq, Nat.mul_assoc, Eq.symm, Nat.mul_comm, rfl]]
[ByteArray.push,[ByteArray, ByteArray.mk, Array.push]]
[Lean.Meta.Match.Unify.expandIfVar,[Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.Match.Unify.M, Lean.Expr, Bind.bind, MonadState.get, Pure.pure, Lean.Meta.FVarSubst.apply, Lean.Meta.Match.Unify.State.fvarSubst]]
[instIsAddRightCancel.proof_1,[Eq.mpr, Eq.refl, Eq, Eq.symm, add_neg_cancel_right, HAdd.hAdd, Neg.neg, rfl]]
[FloatArray.forIn,[FloatArray.size, Nat.le_refl, FloatArray.forIn.loop]]
[Lean.getPPAnalyzeCheckInstances,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.checkInstances, Lean.Option.defValue]]
[instInhabitedOrdering,[Inhabited.mk, Ordering.lt]]
[Lean.Elab.Term.registerMVarErrorHoleInfo,[Lean.Elab.Term.registerMVarErrorInfo, Lean.Elab.Term.MVarErrorInfo.mk, Lean.Elab.Term.MVarErrorKind.hole]]
[instDecidableIff.proof_3,[Iff.mpr]]
[Lean.Meta.InfoCacheKey.expr,[]]
[Lean.Parser.Command.whereStructInst,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1Indent, Lean.Parser.group, Lean.Parser.Command.whereStructField, Lean.Parser.optional]]
[PSigma.skipLeft.proof_1,[PSigma.revLex, WellFoundedRelation.wf, emptyWf]]
[Lean.Meta.CongrLemma.hypothesesPos,[]]
[Lean.Elab.Command.CtorView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.export,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident, Lean.Parser.many1]]
[Lean.Elab.Term.tryPostponeIfMVar,[ite, Eq, Lean.Expr.isMVar, Lean.Expr.getAppFn, Bool.true, Bind.bind, liftM, Lean.Meta.instantiateMVars, Lean.Elab.Term.tryPostpone, Pure.pure, PUnit.unit]]
[Std.HashSetBucket.update,[Subtype.mk, Array.uset, Subtype.val, Std.HashSetBucket.update.proof_1]]
[Lean.IR.mkPAppExpr,[Lean.IR.Expr.pap]]
[Std.PersistentArray.Stats.noConfusionType,[]]
[Classical.epsilon_spec,[Classical.epsilon_spec_aux, nonempty_of_exists]]
[Lean.Meta.GeneralizeTelescope.Entry.modified,[]]
[Fin.overflowingMul,[Prod.mk, Decidable.decide, LE.le, HMul.hMul, Fin.val]]
[Lean.Parser.Term.anonymousCtor.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy.parenthesizer, Lean.Parser.termParser.parenthesizer, Bool.false]]
[Lean.Parser.Tactic.sliceLHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq]]
[Lean.Lsp.HoverParams.toTextDocumentPositionParams,[]]
[Lean.IR.EmitC.Context.jpMap,[]]
[Std.HashMapImp.find?,[Option, Std.AssocList.find?, Array.uget, Subtype.val]]
[Lean.ConstructorVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.SynthInstance.GeneratorNode.instances,[]]
[Lean.MonadLCtx.getLCtx,[]]
[Option.get!,[Unit.unit, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Elab.Command.elabPrint,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Lean.withRef, Bind.bind, Lean.Elab.resolveGlobalConstWithInfos, Option.none, List.forM, Lean.MonadEnv.getEnv, Unit.unit, Lean.Elab.Command.CommandElabM, Unit, Lean.Environment.find?, Lean.MessageData, Pure.pure, Lean.DefinitionSafety.unsafe, Lean.DefinitionSafety.safe, Lean.Elab.logInfo, Bool.false, ForIn.forIn, Lean.getConstInfo, PUnit.unit, ForInStep.yield, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkConst, List.nil, Lean.Elab.logInfoAt, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Option.get!, Lean.Syntax.isStrLit?]]
[Int.instDecidableEqInt,[Int.decEq]]
[Lean.NameMap.find?,[Std.RBMap.find?]]
[Lean.Parser.Term.macroDollarArg.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter]]
[iff_true_right,[Iff.trans, Iff.comm, iff_true_left]]
[Lean.KernelException.funExpected.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Deriving.Hashable.mkAuxFunction,[Bind.bind, Pure.pure, Array.getOp, Lean.Elab.Deriving.Context.auxFunNames, Lean.Elab.Deriving.Context.typeInfos, Lean.Elab.Deriving.Hashable.mkHashableHeader, Lean.Elab.Deriving.Hashable.mkMatch, ite, Eq, Lean.Elab.Deriving.Context.usePartial, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Lean.Syntax.atom, Lean.mkIdent, Array.append, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk]]
[Mathlib.Tactic.Lint.Linter.noErrorsFound,[]]
[instRingFin,[Ring.mk, Fin, Semiring.nsmul, Neg.neg, Nat.succ, instRingFin.proof_2, instRingFin.proof_3, instRingFin.proof_4, instRingFin.proof_5]]
[Lean.Parser.Term.doTry,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.doSeq, Lean.Parser.many, HOrElse.hOrElse, Lean.Parser.Term.doCatch, Lean.Parser.Term.doCatchMatch, Lean.Parser.optional, Lean.Parser.Term.doFinally]]
[Lean.Elab.Term.precheckFun,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.liftMacroM, Lean.Elab.Term.expandFunBinders, Lean.Elab.Term.Quotation.PrecheckM, Unit, ForIn.forIn, liftM, BEq.beq, Array.mapM, or, Lean.identKind, Pure.pure, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Term.mkFreshIdent, Lean.Elab.Term.BinderView.mk, Lean.Elab.Term.expandOptType, Lean.BinderInfo.default, Lean.Syntax.isNone, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Elab.Term.declareTacticSyntax, Lean.mkIdentFrom, Lean.Elab.throwUnsupportedSyntax, Lean.Syntax.getNumArgs, Lean.mkHole, Lean.BinderInfo.implicit, Lean.BinderInfo.strictImplicit, Lean.MonadQuotation.withFreshMacroScope, Lean.MonadQuotation.addMacroScope, Lean.BinderInfo.instImplicit, Lean.Elab.Term.Quotation.withNewLocals, Lean.Elab.Term.Quotation.precheck, Lean.Elab.Term.BinderView.type, PUnit.unit, ForInStep.yield]]
[List.inter,[List.filter, Decidable.decide, Mem.mem]]
[Lean.Elab.ExpandDeclIdResult.mk.inj,[And.intro]]
[Lean.Elab.DefView.noConfusionType,[]]
[String.Iterator.remainingToString,[String, String.extract, String.bsize]]
[Array.foldl,[Id.run, Array.foldlM]]
[Lean.Lsp.SymbolKind.file.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.CaseValueSubgoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.manyIndent.formatter,[Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.many.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkColGe.formatter]]
[instLTUInt32,[LT.mk, LT.lt, UInt32.val]]
[Lean.Meta.IndPredBelow.mkCtorType.addHeaderVars,[Bind.bind, Array.mapIdxM, Lean.Meta.IndPredBelow.Context.headers, Pure.pure, Prod.mk, Array.getOp, Lean.Meta.IndPredBelow.Context.belowNames, Fin.val, Lean.Meta.withLocalDeclsD, Lean.Meta.IndPredBelow.mkCtorType.addMotives, Lean.Meta.IndPredBelow.Variables.mk, Lean.Meta.IndPredBelow.Variables.target, Lean.Meta.IndPredBelow.Variables.params, Lean.Meta.IndPredBelow.Variables.args, Lean.Meta.IndPredBelow.Variables.motives, Lean.Meta.IndPredBelow.Variables.innerType]]
[Lean.Syntax.decodeStrLit,[Lean.Syntax.decodeStrLitAux, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.noConfusionType,[]]
[Lean.Syntax.missing.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Command.macroArg,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.atomic, Lean.Parser.ident, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, Lean.Parser.syntaxParser, Lean.Parser.argPrec]]
[Lean.Expr.updateProj!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr, Lean.Expr.updateProj, Lean.Expr.proj, Lean.Expr.updateProj!.proof_1, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Parser.Term.doMatchAlts.formatter,[Lean.Parser.Term.matchAlts.formatter, Lean.Parser.Term.doSeq.formatter]]
[Lean.Elab.PreDefinition.noConfusionType,[]]
[Lean.Core.instMonadResolveNameCoreM,[Lean.MonadResolveName.mk, Bind.bind, MonadReader.read, Pure.pure, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls]]
[Lean.Parser.checkColGtFn,[Unit.unit, Lean.Parser.ParserState, Lean.Parser.ParserContext.savedPos?, ite, GT.gt, Lean.Position.column, Lean.Parser.ParserState.mkError]]
[ByteArray.noConfusionType,[]]
[Lean.Parser.Command.optDefDeriving.formatter,[Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.notSymbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.ident.formatter, Bool.false]]
[List.hasDecidableLt.proof_4,[Eq.symm, eq_of_heq, Eq.refl, List.cons, HEq.refl, False, absurd]]
[Int.decLe,[Decidable, Int.NonNeg, Decidable.isTrue, Int.NonNeg.mk, Decidable.isFalse, Eq.refl, Int.negSucc, HEq.refl, False, HSub.hSub]]
[Lean.Lsp.Ipc.runWith,[Bind.bind, IO.Process.spawn, IO.Process.SpawnArgs.mk, Lean.Lsp.Ipc.ipcStdioConfig, System.FilePath.toString, ReaderT.run]]
[Lean.Parser.Tactic.Conv.ring!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[mul_add,[Semiring.mul_add]]
[Lean.Message.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.TacticInfo.mctxBefore,[]]
[Lean.MessageData.compose.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MessageData.compose, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.RecKind.noConfusionType,[noConfusionTypeEnum, Lean.Elab.RecKind.toCtorIdx]]
[Lean.instInhabitedPrefixTree,[Inhabited.mk, Lean.PrefixTree.empty]]
[Lean.Parser.getParserPriority,[dite, Eq, Unit.unit, Eq.symm, Except, String, Nat, Lean.Syntax.getNumArgs, Pure.pure, OfNat.ofNat, Lean.Syntax.isNatLit?, Lean.Syntax.getArg, MonadExcept.throw]]
[IO.FS.FileType.symlink.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Tactic.elabSimpConfigCore,[ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, Lean.Meta.Simp.Config.mk, Lean.withoutModifyingState, Lean.Meta.withLCtx, Lean.LocalContext.mk, EmptyCollection.emptyCollection, Lean.Elab.Term.withSynthesize, Bind.bind, Lean.Elab.Term.elabTermEnsuringType, Lean.Syntax.getOp, OfNat.ofNat, Option.some, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Option.none, liftM, Lean.Meta.instantiateMVars, Bool.false]]
[Lean.Lsp.DocumentSymbolAux.selectionRange,[]]
[Nat.coprime.dvd_of_dvd_mul_left,[Nat.coprime.dvd_of_dvd_mul_right, Eq.mp, Eq.refl, Dvd.dvd, HMul.hMul, Nat.mul_comm]]
[Lean.IR.Checker.checkFullApp,[Bind.bind, Lean.IR.Checker.getDecl, ite, Eq, BEq.beq, Array.size, Lean.IR.Decl.params, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Lean.Meta.RewriteResult.eqProof,[]]
[Lean.Parser.mkAntiquotSplice.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.maxPrec, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.setExpected.parenthesizer, List.nil, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.manyNoAntiquot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.nullKind]]
[Lean.Parser.Tactic.classical,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Lsp.ReferenceParams.mk.inj,[And.intro]]
[map_eq_pure_bind,[Eq.mpr, Eq.refl, Eq, Functor.map, Bind.bind, Pure.pure, Eq.symm, LawfulMonad.bind_pure_comp, rfl]]
[Lean.IR.EmitC.emitTag,[ite, Eq, Lean.IR.IRType.isObj, Bool.true, Bind.bind, Lean.IR.EmitC.emit]]
[Lean.Syntax.mkAntiquotSpliceNode,[Lean.mkNode, HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkAtom, Lean.mkNullNode, List.nil]]
[Lean.MetavarContext.MkBinding.Exception.revertFailure.inj,[And.intro]]
[not_or_of_imp,[Decidable.not_or_of_imp]]
[List.mem_cons,[Iff.rfl]]
[Lean.Meta.lambdaLetTelescope,[Lean.Meta.map2MetaM, Bind.bind, Lean.MonadLCtx.getLCtx, List.toArray, List.nil, OfNat.ofNat, Bool.true]]
[Function.injective.ne,[mt]]
[Lean.Parser.Command.infixl,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Lean.Elab.Term.MVarErrorInfo.logError.addArgName,[Unit.unit, Lean.MessageData, Lean.Elab.Term.MVarErrorInfo.argName?, ite, Eq, Lean.Name.hasMacroScopes, Bool.true, HAppend.hAppend, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.ToMessageData.toMessageData]]
[Lean.IR.UniqueIds.checkParams,[Array.allM, Lean.IR.UniqueIds.checkId, Lean.IR.VarId.idx, Lean.IR.Param.x, OfNat.ofNat, Array.size]]
[Lean.ReducibilityHints.isRegular,[Lean.ReducibilityHints.opaque, Lean.ReducibilityHints.abbrev, Bool, Bool.true, Bool.false]]
[Lean.Lsp.SemanticTokens.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.SemanticTokens.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.JoinPointId.mk.injEq,[Eq.propIntro, Eq.refl, Lean.IR.JoinPointId.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.getPPInstanceTypes,[Lean.KVMap.get, Lean.Option.name, Lean.pp.instanceTypes, Lean.Option.defValue]]
[Lean.Syntax.setKind,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.node]]
[Array.set!,[Array.setD]]
[Lean.LocalContext.mkEmpty,[Lean.LocalContext.mk]]
[Lean.Parser.Command.namedName,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.ident]]
[Lean.Elab.Term.instAddErrorMessageContextTermElabM,[Lean.AddErrorMessageContext.mk, Bind.bind, MonadReader.read, Lean.AddMessageContext.addMessageContext, Lean.Elab.addMacroStack, Lean.Elab.Term.Context.macroStack, Pure.pure, Prod.mk]]
[UInt16.instSemiringUInt16.proof_10,[rfl]]
[Lean.Xml.Parser.CDSect,[SeqLeft.seqLeft, SeqRight.seqRight, Lean.Xml.Parser.CDStart, Lean.Xml.Parser.CData, Lean.Xml.Parser.CDEnd]]
[DoResultSBC.break.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.Conv.ringNF!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.ringMode]]
[Lean.mkAttributeImplOfBuilder,[Bind.bind, ST.Ref.get, Lean.attributeImplBuilderTableRef, Unit.unit, IO, Lean.AttributeImpl, Std.HashMap.find?, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, IO.ofExcept]]
[Lean.Unhygienic,[ReaderT, Lean.Unhygienic.Context, StateM, Lean.MacroScope]]
[Lean.LOption.noConfusionType,[]]
[Lean.Elab.Term.StructInst.Source.explicit.inj,[]]
[Lean.Parser.Term.waitIfContainsMVar.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.termParser.formatter]]
[CommMonoid.noConfusionType,[]]
[Lean.Lsp.Hover.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Compiler.hasNoInlineAttribute,[Lean.Compiler.InlineAttributeKind.noinline]]
[Std.PersistentArray.mkNewTail,[ite, LE.le, Std.PersistentArray.size, USize.toNat, Std.PersistentArray.mul2Shift, OfNat.ofNat, HAdd.hAdd, Std.PersistentArray.shift, Std.PersistentArray.initShift, Std.PersistentArray.mk, Std.PersistentArray.insertNewLeaf, Std.PersistentArray.root, USize.ofNat, HSub.hSub, Std.PersistentArray.tail, Std.PersistentArray.mkEmptyArray, Std.PersistentArrayNode.node, Array.push, Std.PersistentArray.mkNewPath, List.toArray, List.nil]]
[Lean.Meta.Simp.Methods.pre,[]]
[Std.HashSet.size,[Nat]]
[Tactic.Ring.HornerExpr.xadd.inj,[And.intro]]
[String.leftpad_length,[Eq, String.length, String.leftpad, max, of_eq_true, Eq.trans, congrFun, congrArg, List.leftpad_length, List.length, eq_self]]
[Lean.Lsp.instInhabitedCancelParams,[Inhabited.mk, Lean.Lsp.CancelParams.mk, arbitrary]]
[UInt64.toUInt8,[Nat.toUInt8, UInt64.toNat]]
[Lean.Elab.Term.elabLetRec,[Bind.bind, Array.mapM, Lean.Elab.expandOptDocComment?, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, List.toArray, List.nil, Lean.Elab.elabDeclAttrs, Lean.Syntax.getSepArgs, Lean.Elab.Term.LetRecView.mk, Lean.Elab.Term.LetRecView.decls, ForIn.forIn, Unit.unit, Lean.Elab.Term.TermElabM, ForInStep, Subarray, Lean.Expr, Stream.next?, ForInStep.done, Lean.Elab.Term.addTermInfo, Lean.Elab.Term.LetRecDeclView.ref, Option.none, Lean.Name.anonymous, ForInStep.yield, Lean.Meta.forallBoundedTelescope, Lean.Elab.Term.LetRecDeclView.type, Option.some, Array.size, Lean.Elab.Term.LetRecDeclView.binderIds, PUnit.unit, Array.getOp, Lean.Elab.Term.withDeclName, Lean.Elab.Term.LetRecDeclView.declName, Lean.Elab.Term.elabTermEnsuringType, Lean.Elab.Term.LetRecDeclView.valStx, liftM, Lean.Meta.mkLambdaFVars, Bool.false, Lean.Elab.Term.LetRecView.body, MonadState.get, List.any, BEq.beq, Lean.Elab.Term.LetRecToLift.declName, Lean.withRef, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MonadLCtx.getLCtx, Lean.Meta.getLocalInstances, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Array.toList, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState, Lean.mkAppN]]
[eq_false_of_decide,[propext, Iff.intro, absurd, of_decide_eq_false, False.elim]]
[instToStringSubtype,[ToString.mk, ToString.toString, Subtype.val]]
[Lean.Parser.ParserState.mkErrorAt,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Array.push, Lean.Syntax.missing, Option.some, Lean.Parser.Error.mk, List.cons, List.nil, Array.shrink]]
[Acc.ndrec,[]]
[Lean.Meta.IndPredBelow.mkBelowMatcher,[Bind.bind, Lean.Meta.Match.getMkMatcherInputInContext, Lean.Meta.forallBoundedTelescope, Lean.Meta.Match.MkMatcherInput.matchType, Option.some, Lean.Meta.Match.MkMatcherInput.numDiscrs, Lean.Meta.inferType, Array.getOp, Lean.Expr.withApp, Lean.getConstInfoInduct, Pure.pure, Prod.mk, Lean.Meta.MetaM, Prod, Lean.Name, Lean.Expr, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.withLocalDeclD, Lean.Meta.mkForallFVars, Array.push, Bool.false, Bool.true, Lean.Expr.replaceFVars, Lean.Meta.MatcherApp.discrs, Unit, List.mapM, Lean.Meta.Match.MkMatcherInput.lhss, Array.mapIdxM, Array.zip, List.toArray, List.zip, Lean.Meta.MatcherApp.alts, Lean.Meta.withExistingLocalDecls, HAppend.hAppend, Lean.Meta.Match.AltLHS.fvarDecls, Lean.Meta.lambdaTelescope, Lean.isTracingEnabledFor, ite, Eq, Lean.addTrace, Lean.ToMessageData.toMessageData, Array.map, Lean.LocalDecl.toExpr, Array.toSubarray, OfNat.ofNat, Array.size, PUnit.unit, Lean.Meta.Match.MkMatcherInput.matcherName, List.foldl, List.nil, ForIn.forIn, Lean.Meta.Match.Pattern.toMessageData, Lean.Meta.Match.AltLHS.patterns, ForInStep.yield, Lean.Meta.Match.mkMatcher, Lean.Meta.Match.MkMatcherInput.mk, HAdd.hAdd, Lean.Meta.Match.MatcherResult.addMatcher, Lean.Meta.check, Lean.Meta.Match.MatcherResult.matcher, Lean.Meta.IndPredBelow.mkBelowMatcher.addBelowPattern, Lean.Meta.IndPredBelow.mkBelowMatcher.convertToBelow, Lean.Meta.IndPredBelow.mkBelowMatcher.transformFields, Lean.Meta.IndPredBelow.mkBelowMatcher.toInaccessible, Lean.Meta.IndPredBelow.mkBelowMatcher.newMotive]]
[Lean.HeadIndex.lit.injEq,[Eq.propIntro, Eq.refl, Lean.HeadIndex.lit, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.local,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[UInt8.instRingUInt8.proof_2,[congrArg, UInt8.mk, Ring.gsmul_zero', UInt8.val]]
[Lean.TraceElem.mk.inj,[And.intro]]
[Lean.Elab.Info.updateContext?,[Option.none, Option.some, Lean.Elab.Info.ofTermInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.Info.ofCompletionInfo, Option, Lean.Elab.ContextInfo, Lean.Elab.ContextInfo.mk, Lean.Elab.ContextInfo.env, Lean.Elab.ContextInfo.fileMap, Lean.Elab.TacticInfo.mctxAfter, Lean.Elab.ContextInfo.options, Lean.Elab.ContextInfo.currNamespace, Lean.Elab.ContextInfo.openDecls]]
[List.groupByAux,[List.nil, List.cons, List, Unit.unit, PProd.fst, List.reverse]]
[USize.instSemiringUSize.proof_2,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, USize.zero_def, USize.add_def, USize.mk, OfNat.ofNat, zero_add, USize.val, USize.mk_val_eq, eq_self, propext, forall_const, USize]]
[Lean.Server.FileWorker.WorkerState.doc,[]]
[instOfNat_1,[OfNat.mk, One.one]]
[Lean.KeyedDeclsAttribute.getEntries,[ite, Eq, Std.PersistentHashSet.isEmpty, Lean.KeyedDeclsAttribute.ExtensionState.erased, Bool.true, List.filter, not, Std.PersistentHashSet.contains, Lean.KeyedDeclsAttribute.OLeanEntry.declName, Lean.KeyedDeclsAttribute.AttributeEntry.toOLeanEntry]]
[UInt16.modn,[UInt16.mk, HMod.hMod, UInt16.val]]
[MonadExceptOf.tryCatch,[]]
[Lean.Lsp.SemanticTokensLegend.tokenModifiers,[]]
[Lean.unreachIsNodeMissing,[False.elim, Lean.unreachIsNodeMissing.proof_1]]
[instShiftRightUInt16,[ShiftRight.mk, UInt16.shiftRight]]
[Lean.Expr.mvar.inj,[And.intro]]
[Lean.Macro.State.noConfusionType,[]]
[Lean.Parser.Term.doIfLetPure.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter]]
[Lean.IR.ExplicitBoxing.BoxingState.auxDeclCache,[]]
[Lean.«tacticIntro.»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol]]
[FloatArray.forIn.loop,[Pure.pure]]
[Lean.Parser.Term.doIfLet.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.doIfLetPure.parenthesizer, Lean.Parser.Term.doIfLetBind.parenthesizer, Bool.false]]
[Lean.Elab.Term.elabNamedPattern,[Bind.bind, List.nil, Bool.false, List.toArray, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.Elab.Term.TermElabM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Pure.pure, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError]]
[InvImage.wf.proof_1,[WellFounded.intro, InvImage.accessible, WellFounded.apply]]
[Ordering.noConfusion,[noConfusionEnum, Ordering.toCtorIdx]]
[List.perm_middle,[List.Perm, HAppend.hAppend, List.cons, List.Perm.refl, List.nil, List.Perm.trans, List.Perm.cons, List.Perm.swap]]
[Nat.sub_le_sub_right,[Unit.unit, LE.le, HSub.hSub, Nat.pred_le_pred, PProd.fst]]
[Lean.Meta.Closure.State.exprMVarArgs,[]]
[Lean.ResolveName.resolveGlobalName.loop,[Lean.Name.anonymous, Lean.Name.num, List, Prod, Lean.Name, String, Unit.unit, List.cons, Lean.Name.str, ite, Eq, and, Lean.Environment.contains, or, not, Lean.Name.isAtomic, Lean.isProtected, Bool.true, PProd.fst, List.nil, List.map, Prod.mk, List.eraseDups, Option.none, Option.some]]
[Lean.Compiler.SpecInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Compiler.SpecInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[UInt32.instSemiringUInt32.proof_9,[rfl]]
[UInt16.decEq.proof_1,[rfl]]
[Lean.Elab.Tactic.Conv.evalConvConvSeq,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.Conv.getLhs, Lean.Elab.Tactic.Conv.convert, Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.Conv.updateLhs]]
[instCoeDep,[CoeDep.mk, coeFun]]
[Lean.Eval.noConfusionType,[]]
[And.elim,[And.left, And.right]]
[Lean.mkBelowName,[Lean.Name.mkStr, Lean.belowSuffix]]
[USize.add,[USize.mk, HAdd.hAdd, USize.val]]
[IO.Error.protocolError.inj,[And.intro]]
[Lean.Compiler.SpecInfo.mk.inj,[And.intro]]
[Lean.IR.FnBody.jdecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instRingFin.proof_2,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.mul_def, Fin.mk, HMod.hMod, Nat.mod_lt, Fin.size_positive, congrFun, HMul.hMul, Nat.zero_mod, Nat.zero_mul, Fin.zero_def, eq_true_of_decide, Eq.refl, Bool.true]]
[Equiv.toFun,[]]
[le_of_not_le,[Or.resolve_left, le_total]]
[Lean.IR.instToFormatArg,[Std.ToFormat.mk, Unit.unit, Std.Format, Std.ToFormat.format, Std.Format.text]]
[Lean.IR.CompilerState.noConfusionType,[]]
[Lean.Meta.mkGeneralizationForbiddenSet,[Bind.bind, ForIn.forIn, MProd.mk, Lean.Meta.MetaM, Lean.FVarIdSet, Array.toList, Lean.CollectFVars.State.fvarSet, Lean.Meta.mkGeneralizationForbiddenSet.visit, Lean.Meta.mkGeneralizationForbiddenSet.loop]]
[Lean.IR.FnBody.nil,[Lean.IR.FnBody.unreachable]]
[Lean.DefinitionVal.toConstantVal,[]]
[Lean.Server.instRpcEncodingProdProd,[Lean.Server.RpcEncoding.mk, Prod, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Pure.pure, Prod.mk, ExceptT, String, Lean.Server.RpcEncoding.rpcDecode]]
[Lean.IR.EmitC.emitFileHeader,[Bind.bind, Lean.IR.EmitC.getEnv, Lean.IR.EmitC.getModName, Lean.IR.EmitC.emitLn, HAppend.hAppend, ToString.toString, Lean.IR.EmitC.emit, Array.forM, Lean.Environment.imports, OfNat.ofNat, Array.size, Lean.IR.EmitC.emitLns, List.cons, List.nil]]
[Lean.Elab.DefKind.opaque.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.addTermInfo,[Bind.bind, modify, Lean.PrettyPrinter.Delaborator.State.mk, Std.RBMap.insert, Lean.PrettyPrinter.Delaborator.State.infos, Lean.PrettyPrinter.Delaborator.State.holeIter, Lean.PrettyPrinter.Delaborator.addTermInfo.mkTermInfo]]
[UInt32.sub,[UInt32.mk, HSub.hSub, UInt32.val]]
[Lean.IR.instInhabitedFnBody,[Inhabited.mk, Lean.IR.FnBody.unreachable]]
[HPow.hPow,[]]
[Lean.Meta.setMVarKind,[Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.setMVarKind]]
[Lean.addMessageContextPartial,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, Pure.pure, Lean.MessageData.withContext, Lean.MessageDataContext.mk, Lean.MetavarContext.mk, Lean.LocalContext.mk]]
[OptionT.instMonadFunctorOptionT,[MonadFunctor.mk, Option]]
[Subtype.map,[Subtype.mk, Subtype.val, Subtype.map.proof_1]]
[Function.const_def,[rfl]]
[ReaderT.run_pure,[rfl]]
[Int.ofNat_add_ofNat,[rfl]]
[Lean.Meta.UnificationHintEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.UnificationHintEntry.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Context.fileName,[]]
[StateRefT'.instMonadLiftStateRefT',[MonadLift.mk, StateRefT'.lift]]
[Lean.Lsp.TextDocumentSyncKind.noConfusion,[noConfusionEnum, Lean.Lsp.TextDocumentSyncKind.toCtorIdx]]
[Nat.dvd_trans,[Dvd.dvd, Exists.intro, HMul.hMul]]
[Lean.Option.get?,[Lean.KVMap.get?, Lean.Option.name]]
[Lean.PersistentEnvExtensionState.importedEntries,[]]
[Lean.IR.ExplicitBoxing.BoxingState.mk.inj,[And.intro]]
[Lean.IR.ExplicitRC.visitDecl,[Lean.IR.Decl.extern, Lean.IR.Decl, Lean.IR.Decl.updateBody!]]
[Lean.Meta.Simp.rewrite.inErasedSet,[Unit.unit, Bool, Lean.Meta.SimpLemma.name?, Bool.false, Std.PersistentHashSet.contains]]
[Int.add_assoc_aux2,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HAdd.hAdd, Int.negSucc_ofNat_add_negSucc_ofNat, Int.ofNat, Int.negSucc_ofNat_add_ofNat, Nat.succ, Int.negSucc, Eq.refl, Int.subNatNat, Int.add_comm, Int.subNatNat_add_negSucc_ofNat, of_eq_true, Nat.add_succ, Nat.succ_add, Nat.add_comm, eq_self]]
[Std.AssocList.find?,[Unit.unit, Option, Option.none, BEq.beq, Option.some, PProd.fst]]
[Lean.Elab.Info.isTerm,[Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.Info.ofCompletionInfo, Bool, Bool.true, Bool.false]]
[ExceptT.instMonadLiftExceptT,[MonadLift.mk, ExceptT.lift]]
[Lean.DataValue.ofName.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.pipeCompletion,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.minPrec, OfNat.ofNat, Lean.Parser.symbol]]
[coeOfHead,[CoeHTCT.mk, coeHead]]
[dif_pos,[Eq, dite, rfl, absurd]]
[Decidable.and_iff_not_or_not,[Eq.mpr, Eq.refl, Iff, And, Not, Or, Eq.symm, propext, Decidable.not_and_distrib, Decidable.not_not, Iff.rfl]]
[instAddCommSemigroupFin.proof_1,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.add_def, congrFun, HMod.hMod, Nat.add_comm, eq_self, HAdd.hAdd]]
[Lean.Meta.Split.simpMatchTarget,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getMVarType, Lean.Meta.instantiateMVars, Lean.Meta.Split.simpMatch, Lean.Meta.applySimpResultToTarget]]
[Lean.Elab.Term.Do.ToTerm.mkIte,[ite, Eq, Lean.Syntax.isNone, Bool.true, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Lean.Parser.ParserState.mkEOIError,[Lean.Parser.ParserState.mkUnexpectedError]]
[Lean.Elab.Term.StructInst.ExplicitSourceInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.StructInst.ExplicitSourceInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.syntaxAbbrev.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.docComment.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter, Lean.Parser.many1.formatter, Lean.Parser.syntaxParser.formatter]]
[Lean.Server.Completion.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.Completion.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.getDeclarationRange,[Bind.bind, Lean.MonadFileMap.getFileMap, Pure.pure, Lean.DeclarationRange.mk, Lean.Lsp.Position.character, Lean.FileMap.leanPosToLspPos]]
[Lean.Parser.Command.notationItem,[HAndThen.hAndThen, Lean.Parser.ppSpace, Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, HOrElse.hOrElse, Lean.Parser.strLit, Lean.Parser.Command.identPrec]]
[Lean.Lsp.DidChangeTextDocumentParams.mk.inj,[And.intro]]
[Std.RBTree.any,[Std.RBMap.any]]
[Fin.shiftRight,[Fin, Fin.mk, HMod.hMod, HShiftRight.hShiftRight, Fin.shiftRight.proof_1]]
[Lean.Parser.Command.infixr.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[IO.Error.resourceBusy.inj,[And.intro]]
[Lean.InductiveVal.numParams,[]]
[Lean.Export.Entry.name.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.Snapshots.Snapshot.isAtEnd,[or, Lean.Parser.isEOI, Lean.Server.Snapshots.Snapshot.stx, Lean.Parser.isExitCommand]]
[Int.one_mul,[Eq, HMul.hMul, OfNat.ofNat]]
[Lean.Syntax.TopDown.stx,[]]
[Std.ShareCommon.mkObjectMap,[Std.mkHashMap, OfNat.ofNat]]
[Lean.Lsp.instBEqDiagnosticWith,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Meta.Config.constApprox,[]]
[Lean.instEmptyCollectionMVarIdMap,[inferInstanceAs, EmptyCollection, Std.RBMap, Lean.MVarId, Lean.Name.quickCmp, Lean.MVarId.name]]
[Lean.Elab.Command.StructFieldInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.StructFieldInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.caseValues.loop,[Lean.Meta.MetaM, Array, Lean.Meta.CaseValuesSubgoal, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing, Bind.bind, Lean.Meta.withMVarContext, Lean.Meta.getMVarTag, Lean.Meta.checkNotAssigned, Lean.Meta.getMVarType, Lean.Meta.mkEq, Lean.mkFVar, Lean.Meta.foldPatValue, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.mkAppOptM, List.toArray, List.cons, Option.none, Option.some, List.nil, Lean.Meta.assignExprMVar, Lean.Meta.intro1P, Lean.Expr.mvarId!, Prod, Lean.Meta.CaseValueSubgoal, Lean.Meta.substCore, Bool.false, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, List.map, Lean.FVarId.name, Lean.Meta.FVarSubst.domain, Pure.pure, PUnit.unit, Prod.mk, Lean.Name.appendIndexAfter, Lean.Meta.FVarSubst.mk, Lean.Meta.appendTagSuffix, Lean.Meta.CaseValueSubgoal.mvarId, Array.foldlM, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.MVarId, Lean.Meta.FVarSubst.get, Lean.Meta.CaseValueSubgoal.subst, Lean.Meta.tryClear, OfNat.ofNat, Array.size, Unit.unit, HAdd.hAdd, Array.push, Lean.Meta.CaseValuesSubgoal.mk, Lean.Meta.CaseValueSubgoal.newH, PProd.fst]]
[Lean.Parser.Tactic.ghostFunTac,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[System.FilePath.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[usize_size_eq,[]]
[Lean.Compiler.atMostOnce.instAndThenVisitor,[AndThen.mk, Lean.Compiler.atMostOnce.seq, Unit.unit]]
[Lean.Elab.Term.isLocalIdent?,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Elab.Term.TermElabM, Option, Lean.Expr, Bind.bind, Lean.Elab.Term.resolveLocalName, Option.none, Option.some, Prod.mk, List.cons, Pure.pure]]
[Lean.Parser.Term.doCatch.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.Parser.optional.formatter, Lean.Parser.termParser.formatter, Lean.Parser.darrow.formatter, Lean.Parser.Term.doSeq.formatter]]
[Lean.Parser.leadPrec,[OfNat.ofNat]]
[UInt8.shiftRight,[UInt8.mk, HShiftRight.hShiftRight, UInt8.val, UInt8.modn, OfNat.ofNat]]
[UInt16.le,[LE.le, UInt16.val]]
[Lean.version.patch,[Unit.unit]]
[Lean.PersistentLevelMap,[Std.PHashMap, Lean.Level]]
[Lean.ConstantInfo.thmInfo.inj,[]]
[Lean.Elab.Tactic.ElimApp.setMotiveArg,[Bind.bind, Lean.Meta.inferType, Lean.mkMVar, Lean.Meta.mkLambdaFVars, Array.map, Lean.mkFVar, Bool.false, Bool.true, Lean.Meta.isDefEqGuarded, ite, Eq, Pure.pure, PUnit.unit, Lean.Meta.mkHasTypeButIsExpectedMsg, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr]]
[Std.PersistentHashSet.instEmptyCollectionPersistentHashSet,[EmptyCollection.mk, Std.PersistentHashSet.empty]]
[Std.PersistentArray.modify,[ite, GE.ge, Std.PersistentArray.tailOff, Std.PersistentArray.mk, Std.PersistentArray.root, Array.modify, Std.PersistentArray.tail, HSub.hSub, Std.PersistentArray.size, Std.PersistentArray.shift, Std.PersistentArray.modifyAux, USize.ofNat]]
[Lean.Parser.ppGroup,[id]]
[Lean.Compiler.SpecInfo.argKinds,[]]
[Lean.Meta.Match.getEquationsFor,[Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.Meta.MetaM, Lean.Meta.Match.MatchEqns, Std.PersistentHashMap.find?, Lean.Meta.Match.MatchEqnsExtState.map, Lean.EnvExtension.getState, Lean.Meta.Match.matchEqnsExt, Pure.pure, Lean.Meta.withConfig, Lean.Meta.Config.mk, Lean.Meta.Config.foApprox, Lean.Meta.Config.ctxApprox, Lean.Meta.Config.quasiPatternApprox, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Bool.false, Lean.getConstInfo, Lean.Meta.getMatcherInfo?, Option.none, Lean.Meta.forallTelescopeReducing, Lean.ConstantInfo.type, ForIn.forIn, MProd.mk, Lean.Meta.inferType, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Array.getOp, Lean.Meta.dependsOn, Lean.Expr.fvarId!, and, Lean.Expr.isConstOf, Lean.Name.mkStr, Lean.Name.anonymous, not, Prod.mk, List.toArray, List.nil, List.cons, Lean.mkConst, PUnit.unit, Prod, Lean.Expr, Nat, Lean.Meta.instantiateForall, ForInStep.yield, Array.filterMapM, Lean.Meta.forallTelescope, Array.mapM, Subarray.toArray, Array.toSubarray, HSub.hSub, StateRefT'.run', OptionT.run, SeqRight.seqRight, MonadState.get, Option, Array.foldrM, Lean.Meta.mkArrow, Array.filterM, Lean.Meta.mkForallFVars, Option.some, Array.forM, OptionT, StateRefT', IO.RealWorld, Array, PUnit, Lean.Expr.eq?, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.isTracingEnabledFor, Lean.addTrace, ForInStep, MProd, Lean.Name]]
[Lean.getAllParentStructures,[Prod.snd, StateT.run, List.toArray, List.nil, Lean.getAllParentStructures.visit]]
[instReprAtomInt,[ReprAtom.mk]]
[Lean.Widget.InteractiveHypothesis.mk.inj,[And.intro]]
[«stx_+»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[FloatSpec.float,[]]
[Lean.Elab.Term.instToStringLVal,[ToString.mk, String, ToString.toString, HAppend.hAppend]]
[neg_add_cancel_left,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, Eq.symm, add_assoc, add_left_neg, OfNat.ofNat, zero_add, rfl]]
[Lean.Server.Watchdog.FileWorker.doc,[]]
[PSum.inl.injEq,[Eq.propIntro, Eq.refl, PSum.inl, Eq.symm, eq_of_heq, HEq.refl]]
[Repr.reprPrec,[]]
[Lean.Elab.Term.MatchAltView.patterns,[]]
[Lean.Syntax.unescapeAntiquot,[ite, Eq, Lean.Syntax.isAntiquot, Bool.true, Lean.Syntax.setArg, OfNat.ofNat, Lean.mkNullNode, Array.pop, Lean.Syntax.getArgs, Lean.Syntax.getOp]]
[List.contains,[List.elem]]
[Lean.MVarIdSet,[Std.RBTree, Lean.MVarId, Lean.Name.quickCmp, Lean.MVarId.name]]
[LawfulApplicative.seqRight_eq,[]]
[Lean.Elab.Deriving.mkInductiveApp,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append]]
[Not.decidable_imp_symm,[Decidable.not_imp_symm]]
[Lean.Meta.Split.applyMatchSplitter,[Bind.bind, ite, Eq, Array.all, Lean.Expr.isFVar, OfNat.ofNat, Array.size, Bool.true, Pure.pure, Prod.mk, Array.map, Lean.Expr.fvarId!, Array.mapM, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.GeneralizeArg.mk, Option.some, Lean.Meta.generalize, Lean.Meta.MetaM, Prod, Array, Lean.FVarId, Lean.MVarId, Array.ofSubarray, Array.toSubarray, List, Lean.Meta.revert, Lean.Meta.introNP, Lean.Meta.getMatcherInfo?, Option.none, Lean.Meta.Match.getEquationsFor, Lean.Meta.withMVarContext, Lean.Meta.getMVarType, Lean.Meta.mkLambdaFVars, Bool.false, Lean.Meta.Match.MatcherInfo.uElimPos?, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.Meta.Match.MatcherInfo.getFirstDiscrPos,[HAdd.hAdd, Lean.Meta.Match.MatcherInfo.numParams, OfNat.ofNat]]
[Lean.IR.ExpandResetReuse.Context.noConfusionType,[]]
[Lean.Lsp.instFromJsonTextDocumentSyncKind,[Lean.FromJson.mk, Except.error, dite, Eq, Unit.unit, Eq.symm, Except.ok, Except, String, Lean.Lsp.TextDocumentSyncKind, Lean.Json.getNat?, Pure.pure, Lean.Lsp.TextDocumentSyncKind.none, Lean.Lsp.TextDocumentSyncKind.full, Lean.Lsp.TextDocumentSyncKind.incremental, MonadExcept.throw]]
[Lean.Elab.Term.ToDepElimPattern.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.ToDepElimPattern.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[String.Iterator.pos,[String.Pos]]
[Lean.Macro.Methods.getCurrNamespace,[]]
[Lean.Meta.SavedState.meta,[]]
[Lean.IR.LocalContext.addLocal,[Std.RBMap.insert, Lean.IR.VarId.idx, Lean.IR.LocalContextEntry.localVar]]
[DivInvMonoid.div_eq_mul_inv,[]]
[Std.RBTree.max,[Unit.unit, Option, Std.RBMap.max, Option.some, Option.none]]
[Lean.Meta.Closure.pickNextToProcess?,[Bind.bind, Lean.MonadLCtx.getLCtx, MonadState.get, ite, Eq, Array.isEmpty, Lean.Meta.Closure.State.toProcess, Bool.true, Pure.pure, Option.none, MonadState.modifyGet, Prod, Option, Lean.Meta.Closure.ToProcessElement, Lean.Meta.Closure.State, Prod.mk, Option.some, Lean.Meta.Closure.State.mk, Lean.Meta.Closure.State.visitedLevel, Lean.Meta.Closure.State.visitedExpr, Lean.Meta.Closure.State.levelParams, Lean.Meta.Closure.State.nextLevelIdx, Lean.Meta.Closure.State.levelArgs, Lean.Meta.Closure.State.newLocalDecls, Lean.Meta.Closure.State.newLocalDeclsForMVars, Lean.Meta.Closure.State.newLetDecls, Lean.Meta.Closure.State.nextExprIdx, Lean.Meta.Closure.State.exprMVarArgs, Lean.Meta.Closure.State.exprFVarArgs]]
[Lean.Lsp.DiagnosticRelatedInformation.mk.inj,[And.intro]]
[Lean.Elab.Term.LVal.getOp.inj,[And.intro]]
[Semiring.zero_add,[]]
[toBoolUsing_eq_true,[decide_eq_true]]
[Lean.Elab.MonadMacroAdapter.noConfusionType,[]]
[Lean.Meta.localDeclDependsOnPred,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.findLocalDeclDependsOn]]
[Lean.Meta.addCongrLemma,[Bind.bind, Lean.Meta.mkCongrLemma, Lean.ScopedEnvExtension.add, Lean.Meta.congrExtension]]
[Lean.Json.Structured.arr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt8.instCommRingUInt8,[CommRing.mk, UInt8.instCommRingUInt8.proof_1]]
[Lean.Meta.AbstractMVarsResult.expr,[]]
[Lean.EnvExtensionInterfaceUnsafe.Ext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.mkAttributeImplOfEntry,[IO, Lean.AttributeImpl, IO.ofExcept, Lean.mkAttributeImplOfConstant, Lean.mkAttributeImplOfBuilder]]
[String.toName,[List.foldl, Lean.Name.mkStr, String.trim, Lean.Name.anonymous]]
[Task.pure.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Syntax.getTailInfo,[Option.getD, Lean.Syntax.getTailInfo?, Lean.SourceInfo.none]]
[Nat.mod_mod,[Or.elim, Nat.eq_zero_or_pos, of_eq_true, Eq.trans, congr, congrArg, Eq, HMod.hMod, Nat.mod_zero, eq_self, Nat.mod_eq_of_lt, Nat.mod_lt]]
[IO.Error.mkHardwareFault,[IO.Error.hardwareFault]]
[Lean.Elab.Deriving.Context.mk.inj,[And.intro]]
[Lean.Server.RequestM.bindTask,[liftM, EIO.bindTask, Task.Priority.default]]
[tryFinally,[Functor.map, Prod.fst]]
[Lean.Parser.Command.infix,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Lean.Compiler.findUnFoldFn,[List.lookup, Lean.Compiler.unFoldFns]]
[Lean.Elab.Deriving.DecEq.mkDecEqHeader,[Lean.Elab.Deriving.mkHeader, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat]]
[Lean.Parser.Command.structCtor,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.atomic, HAndThen.hAndThen, Lean.Parser.Command.declModifiers, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.Command.inferMod, Lean.Parser.symbol]]
[UInt8.instSemiringUInt8.proof_9,[rfl]]
[Lean.Parser.Term.letIdLhs,[HAndThen.hAndThen, Lean.Parser.Term.ident, Lean.Parser.notFollowedBy, Lean.Parser.checkNoWsBefore, Lean.Parser.symbol, Lean.Parser.many, Lean.Parser.ppSpace, HOrElse.hOrElse, Lean.Parser.Term.simpleBinderWithoutType, Lean.Parser.Term.bracketedBinder, Bool.false, Lean.Parser.Term.optType]]
[Lean.Elab.Term.State.noConfusionType,[]]
[List.append_subset_of_subset_of_subset,[Or.elim, Iff.mp, List.mem_append]]
[Lean.Elab.Tactic.MkSimpContextResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.tfaeHave,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Lean.Parser.Command.infixl.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.SCC.Data.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.SCC.Data.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.KeyedDeclsAttribute.Key,[Lean.Name]]
[Lean.mkLevelParam,[Lean.Level.param, Lean.Level.mkData, mixHash, OfNat.ofNat, Hashable.hash, Bool.false, Bool.true]]
[Lean.Lsp.instFromJsonTextDocumentItem,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, String, Nat, Pure.pure, Lean.Lsp.TextDocumentItem.mk]]
[List.zip,[List.zipWith, Prod.mk]]
[Lean.Server.FileWorker.handleRpcConnect,[Bind.bind, liftM, Lean.Server.FileWorker.RpcSession.new, Lean.Server.FileWorker.WorkerM, Lean.Lsp.RpcConnected, IO.mkRef, modify, Lean.Server.FileWorker.WorkerState.mk, Lean.Server.FileWorker.WorkerState.doc, Lean.Server.FileWorker.WorkerState.pendingRequests, Std.RBMap.insert, Lean.Server.FileWorker.WorkerState.rpcSessions, Pure.pure, Lean.Lsp.RpcConnected.mk]]
[Nat.mul_pred_right,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Nat.pred, HSub.hSub, Nat.mul_comm, Nat.mul_pred_left, rfl]]
[Lean.ConstantInfo.quotInfo.inj,[]]
[and_iff_left_iff_imp,[Iff.intro, And.right, Iff.mpr, and_iff_left_of_imp]]
[Lean.ExprStructEq.instHashableExprStructEq,[Hashable.mk, Lean.ExprStructEq.hash]]
[Lean.ScopedEnvExtension.Entry.global.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Expr.eq?,[Lean.Expr.app3?, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Elab.withInfoTreeContext,[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, ite, Eq, Lean.Elab.InfoState.enabled, Bool.true, Lean.Elab.getResetInfoTrees, Functor.map, Prod.fst, MonadFinally.tryFinally', Lean.Elab.InfoState.trees, Lean.Elab.MonadInfoTree.modifyInfoState, Lean.Elab.InfoState.mk, Lean.Elab.InfoState.assignment, Std.PersistentArray.push]]
[IO.Error.interrupted.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[toBoolUsing,[Decidable.decide]]
[Lean.KeyedDeclsAttribute.tableRef,[]]
[Lean.Elab.Term.StructInst.Struct.ref,[Lean.Syntax]]
[UInt32.instSemiringUInt32.proof_3,[congrArg, UInt32.mk, Semiring.nsmul_zero', UInt32.val]]
[Lean.ModuleData.mk.inj,[And.intro]]
[Lean.Server.DocumentMeta.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.DocumentMeta.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.LetRecToLift.type,[]]
[Lean.Meta.AbstractMVarsResult.numMVars,[]]
[Lean.Elab.Tactic.Conv.evalCongr,[Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Elab.Tactic.Conv.congr, Lean.Elab.Tactic.replaceMainGoal]]
[ByteSliceT.off,[]]
[Lean.MetavarContext.UnivMVarParamResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Function.injective.of_comp_iff,[Iff.intro, Function.injective.of_comp, Function.injective.comp]]
[coeOfHeadOfTC,[CoeHTCT.mk, coeTC, coeHead]]
[Lean.Widget.CodeToken.noConfusionType,[]]
[Lean.PrettyPrinter.ParenthesizerM,[ReaderT, Lean.PrettyPrinter.Parenthesizer.Context, StateRefT', IO.RealWorld, Lean.PrettyPrinter.Parenthesizer.State, Lean.Core.CoreM]]
[Lean.IR.LocalContext.getType,[Option.none, Option.some, Lean.IR.LocalContextEntry.joinPoint, Option, Lean.IR.IRType, Std.RBMap.find?, Lean.IR.VarId.idx]]
[ByteArray.uset,[ByteArray, ByteArray.mk, Array.uset]]
[Lean.LocalContext.empty,[Lean.LocalContext.mk]]
[instHAnd,[HAnd.mk, AndOp.and]]
[USize.instAddSemigroupUSize.proof_1,[congrArg, USize.mk, AddSemigroup.add_assoc, USize.val]]
[Nat.forM.loop,[Unit.unit, Unit, Pure.pure, Bind.bind, HSub.hSub, OfNat.ofNat, PProd.fst]]
[Lean.Elab.Term.synthesizeAppInstMVars,[Bind.bind, ForIn.forIn, PUnit.unit, Lean.Elab.Term.synthesizeInstMVarCore, Option.none, ite, Eq, Bool.true, Pure.pure, ForInStep.yield, Lean.Elab.Term.registerSyntheticMVarWithCurrRef, Lean.Elab.Term.SyntheticMVarKind.typeClass, Lean.MonadRef.getRef, Lean.Elab.Term.registerMVarErrorImplicitArgInfo]]
[Function.swap,[]]
[Array.getSepElems,[Array.getEvenElems]]
[BaseIO.mapTasks,[List.nil, BaseIO.mapTasks.go]]
[Lean.Core.transform,[Lean.MonadCacheT.run, Lean.Core.transform.visit]]
[Lean.Elab.Term.ElabAppArgs.State.instMVars,[]]
[Lean.Elab.Term.elabNoImplicitLambda,[Lean.Elab.Term.elabTerm, Lean.Syntax.getOp, OfNat.ofNat, Functor.map, Lean.Elab.Term.mkNoImplicitLambdaAnnotation, Bool.true]]
[instReprSourceInfo,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, HAppend.hAppend, Std.Format.text, Std.Format.line, reprArg, Std.Format.FlattenBehavior.allOrNone]]
[Lean.Name.cmp,[Unit.unit, Lean.Name.str, Lean.Name.num, Ordering, Ordering.eq, Ordering.lt, Ordering.gt, PProd.fst, Ord.compare]]
[Nat.eq_zero_of_mul_eq_zero,[Or, Eq, OfNat.ofNat, Or.inl, rfl, Or.inr, Nat.eq_zero_of_add_eq_zero_left, Eq.mp, Eq.refl, HMul.hMul, HAdd.hAdd, Nat.succ_mul]]
[Lean.Elab.Command.StructFieldInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[commandSudoSet_option___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Lean.Elab.Deriving.Context.noConfusionType,[]]
[Lean.getPPInstantiateMVars,[Lean.KVMap.get, Lean.Option.name, Lean.pp.instantiateMVars, Lean.Option.defValue]]
[Lean.Parser.tacticParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Parsec.skipChar,[SeqRight.seqRight, Lean.Parsec.pchar, Pure.pure, Unit.unit]]
[UInt16.instAddCommSemigroupUInt16,[AddCommSemigroup.mk, UInt16.instAddCommSemigroupUInt16.proof_1]]
[Std.PersistentHashMap.maxDepth,[OfNat.ofNat]]
[Lean.Parser.Tactic.tryFor,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.parser]]
[Lean.PrettyPrinter.Formatter.pushLine,[Bind.bind, Lean.PrettyPrinter.Formatter.push, Std.Format.line, modify, Lean.PrettyPrinter.Formatter.State.mk, Lean.PrettyPrinter.Formatter.State.stxTrav, Lean.PrettyPrinter.Formatter.State.stack]]
[Quotient.recOnSubsingleton₂,[Quot.recOnSubsingleton]]
[Lean.MetavarKind.noConfusion,[noConfusionEnum, Lean.MetavarKind.toCtorIdx]]
[Lean.IR.CompilerState.log,[]]
[by_contra,[Decidable.by_contradiction]]
[Lean.Elab.instMonadInfoTree,[Lean.Elab.MonadInfoTree.mk, liftM, Lean.Elab.MonadInfoTree.getInfoState, Lean.Elab.MonadInfoTree.modifyInfoState]]
[Lean.Expr.letE.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[iff_not_self,[Iff.mpr]]
[Lean.Level.getOffsetAux,[Lean.Level.zero, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Nat, PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.RpcRef.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.Sorry.State.mk.inj,[And.intro]]
[Lean.IR.ExplicitBoxing.BoxingContext.mk.inj,[And.intro]]
[Lean.Xml.Element.Element.inj,[And.intro]]
[Std.HashSetImp.foldM,[Std.HashSetImp.foldBucketsM, Std.HashSetImp.buckets]]
[Lean.IR.EmitC.quoteString,[HAppend.hAppend]]
[Lean.Lsp.WorkspaceFolder.noConfusionType,[]]
[Std.Range.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.Range.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Fin.ofNat.proof_1,[Nat.mod_lt, Nat.zero_lt_succ]]
[Lean.isLetFun,[Unit.unit, Bool, Lean.letFunAnnotation?, Bool.false, and, Lean.Expr.isApp, Lean.Expr.isLambda, Lean.Expr.appFn!]]
[Lean.Elab.Term.MutualClosure.insertReplacementForLetRecs,[List.foldl, Std.RBMap.insert, Lean.Elab.Term.LetRecToLift.fvarId, Lean.Elab.Term.MutualClosure.LetRecClosure.toLift, Lean.Elab.Term.MutualClosure.LetRecClosure.closed]]
[Lean.MonadCacheT,[StateRefT', Std.HashMap]]
[Lean.Elab.throwAbortCommand,[MonadExcept.throw, Lean.Exception.internal, Lean.Elab.abortCommandExceptionId, Lean.KVMap.mk]]
[List.length_pos_of_mem,[LT.lt, OfNat.ofNat, List.length, List.nil, Eq.refl, Eq.mpr, List.cons, List.length_cons, Nat.zero_lt_succ]]
[Lean.Parser.Term.bracketedBinderF,[Lean.Parser.Term.bracketedBinder, Bool.false]]
[Lean.Parser.Tactic.Conv.ringNF,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.ringMode]]
[Lean.Meta.Simp.Config.memoize,[]]
[Lean.LocalContext.sanitizeNames,[Bind.bind, MonadState.get, ite, Eq, not, Lean.getSanitizeNames, Lean.NameSanitizerState.options, Bool.true, Pure.pure, StateT.run', Nat.foldRevM, Unit.unit, StateT, Lean.NameSet, StateM, Lean.NameSanitizerState, Lean.LocalContext, Std.PersistentArray.getOp, Lean.LocalContext.decls, or, Lean.Name.hasMacroScopes, Lean.LocalDecl.userName, Lean.NameSet.contains, modify, Lean.NameSet.insert, liftM, Lean.sanitizeName, Lean.LocalContext.setUserName, Lean.LocalDecl.fvarId, Std.PersistentArray.size, EmptyCollection.emptyCollection]]
[instReprFin,[Repr.mk, repr, Fin.val]]
[Lean.instMetaEval,[Lean.MetaEval.mk, Bind.bind, Lean.Eval.eval, Pure.pure]]
[instCommSemiring,[CommSemiring.mk, CommRing.mul_comm]]
[Semiring.toSemigroup,[]]
[Lean.Json.setObjVal!,[Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Lean.Json.arr, Lean.Json, Lean.Json.obj, Std.RBNode.insert, Ord.compare, panicWithPosWithDecl, OfNat.ofNat]]
[forall_prop_of_true,[forall_const]]
[Lean.Elab.Term.Do.mkDoSeq,[Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkNullNode, Array.map, List.nil]]
[Lean.JsonNumber.fromInt,[Lean.JsonNumber.mk, OfNat.ofNat]]
[Function.bijective.surjective,[And.right]]
[Lean.IR.ExplicitBoxing.getVarType,[Bind.bind, Lean.IR.ExplicitBoxing.getLocalContext, Unit.unit, Lean.IR.ExplicitBoxing.M, Lean.IR.IRType, Lean.IR.LocalContext.getType, Pure.pure, Lean.IR.IRType.object]]
[Lean.Compiler.FFI.getCFlags,[HAppend.hAppend, List.toArray, List.cons, System.FilePath.toString, HDiv.hDiv, System.FilePath.mk, List.nil, String.splitOn, String.trim, Unit.unit]]
[Lean.Level.collectMVars,[Lean.Level.zero, Lean.Level.param, Lean.MVarIdSet, PProd.fst, PProd.snd, Std.RBTree.insert]]
[Lean.Meta.mkPure,[Lean.Meta.mkAppOptM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Option.some, Option.none, List.nil]]
[Lean.Name.isStr,[Lean.Name.anonymous, Lean.Name.num, Bool, Bool.true, Bool.false]]
[Std.PersistentHashMap.Node.collision.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.PersistentHashMap.Node.collision, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.FnBody.mdata.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.mdata, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Tactic.setGoals,[modify, Lean.Elab.Tactic.State.mk]]
[FloatArray.size,[Nat, Array.size]]
[Lean.Syntax.below,[PUnit, PProd]]
[InvImage,[]]
[Lean.IR.UnreachableBranches.updateJPParamsAssignment,[Bind.bind, MonadReader.read, Nat.foldM, Lean.IR.UnreachableBranches.findVarValue, Lean.IR.Param.x, Lean.IR.UnreachableBranches.findArgValue, ite, Eq, BEq.beq, Bool.true, Pure.pure, modify, Lean.IR.UnreachableBranches.InterpState.mk, Array.modify, Lean.IR.UnreachableBranches.InterpState.assignments, Std.HashMap.insert, Lean.IR.UnreachableBranches.InterpState.funVals, Bool.false, Array.size]]
[Lean.Server.FileWorker.handleReferences.applyIdMap,[Lean.Server.FileWorker.RefIdent.const, Lean.Server.FileWorker.RefIdent, Lean.Server.FileWorker.RefIdent.fvar, Std.HashMap.findD]]
[Lean.Server.WithRpcRef.val,[]]
[Prod.ext,[rfl, Eq.symm, Eq.refl]]
[Lean.Widget.instReprTaggedText,[Repr.mk]]
[Lean.MonadHashMapCacheAdapter.findCached?,[Bind.bind, Lean.MonadHashMapCacheAdapter.getCache, Pure.pure, Std.HashMap.find?]]
[Lean.SMap.map₁,[]]
[Lean.Parser.invalidLongestMatchParser,[Lean.Parser.ParserState.mkError]]
[Lean.Elab.Tactic.AuxMatchTermState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MessageData.instCoeListMessageDataMessageData,[Coe.mk, Lean.MessageData.ofList]]
[Lean.Elab.Term.withoutPending,[Bind.bind, MonadState.get, tryFinally, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState]]
[zero_lt_of_lt,[LT.lt, OfNat.ofNat, Nat.lt_trans, Nat.zero_lt_succ]]
[MonadWithReaderOf.noConfusionType,[]]
[Lean.PrettyPrinter.Delaborator.instMonadQuotationDelabM,[Lean.MonadQuotation.mk, Pure.pure, arbitrary]]
[Lean.IR.EmitC.Context.mainFn,[]]
[Lean.Meta.reduceBoolNativeUnsafe,[Lean.evalConstCheck, Bool, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.IR.EmitC.toStringArgs,[List.map, Lean.IR.EmitC.argToCString, Array.toList]]
[instToStringDecidable,[ToString.mk, String]]
[StateCpsT.instLawfulMonadStateCpsT.proof_1,[LawfulMonad.mk, rfl]]
[Lean.Parser.Term.doReturn.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkLineEq.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Lean.Meta.casesRec,[Lean.Meta.saturate, Lean.Meta.withMVarContext, Bind.bind, Lean.MonadLCtx.getLCtx, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, ite, Eq, Bool.true, Lean.observing?, Lean.Meta.cases, Lean.LocalDecl.fvarId, List.toArray, List.nil, Pure.pure, List.map, Lean.Meta.InductionSubgoal.mvarId, Lean.Meta.CasesSubgoal.toInductionSubgoal, Array.toList, Option.isSome, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, Lean.Meta.MetaM, Option, List, Lean.MVarId, MProd.fst]]
[Lean.Parser.nonReservedSymbolNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.nonReservedSymbolInfo, Lean.Parser.nonReservedSymbolFn]]
[Lean.Meta.RecursorInfo.isMinor,[ite, LE.le, Lean.Meta.RecursorInfo.motivePos, Bool.false, Eq, and, Decidable.decide, Lean.Meta.RecursorInfo.firstIndexPos, Lean.Meta.RecursorInfo.majorPos, Bool.true]]
[Lean.Parser.Tactic.guardProofTerm,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[MonadExceptOf.throw,[]]
[Lean.JsonRpc.ErrorCode.toCtorIdx,[OfNat.ofNat]]
[Lean.Meta.tryClearMany,[Array.foldrM, Lean.Meta.tryClear, Array.size, OfNat.ofNat]]
[congrArg,[rfl]]
[Lean.mkConstructorValEx,[Lean.ConstructorVal.mk, Lean.ConstantVal.mk]]
[Std.HashMap.insert.proof_2,[]]
[Lean.Server.FileWorker.EditableDocument.mk.inj,[And.intro]]
[Std.withShareCommon,[Std.MonadShareCommon.withShareCommon]]
[Lean.Parser.Tactic.abel1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.JsonRpc.ErrorCode.unknownErrorCode.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Nat.repeat,[Nat.repeat.loop]]
[exists_prop_decidable,[dite, decidable_of_decidable_of_iff, exists_prop_decidable.proof_1, Decidable.isFalse, exists_prop_decidable.proof_2]]
[UInt64.lt,[LT.lt, UInt64.val]]
[Lean.HeadIndex.fvar.injEq,[Eq.propIntro, Eq.refl, Lean.HeadIndex.fvar, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.runMetaEval,[IO.FS.withIsolatedStreams, liftM, EIO.toBaseIO, Lean.MetaEval.eval, Bool.false]]
[List.cons.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.SynthInstance.instInhabitedSynthM,[Inhabited.mk, arbitrary]]
[Array.getLit,[Array.get, Fin.mk, Array.getLit.proof_1]]
[Lean.Expr.etaExpandedStrict?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Expr, PProd.fst, PProd.snd, HAdd.hAdd, OfNat.ofNat, Lean.Expr.lam, ite, Eq, BEq.beq, Bool.true, Option.none, Lean.Expr.hasLooseBVars, Option.some]]
[Lean.AttributeImpl.mk.inj,[And.intro]]
[instDecidableIff,[dite, Decidable.isTrue, instDecidableIff.proof_1, Decidable.isFalse, instDecidableIff.proof_2, instDecidableIff.proof_3, instDecidableIff.proof_4]]
[Lean.Export.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Export.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.DocumentSymbolAux.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.DocumentSymbolAux.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Command.mkMessageAux,[Lean.Elab.mkMessageCore, Lean.Elab.Command.Context.fileName, Lean.Elab.Command.Context.fileMap, Option.getD, Lean.Syntax.getPos?, Bool.false, Lean.Elab.Command.Context.cmdPos]]
[Lean.Lsp.LeanFileProgressParams.noConfusionType,[]]
[Lean.Module.mk.inj,[And.intro]]
[Lean.Parser.Trie.matchPrefix,[Prod.mk, Option.none, Lean.Parser.Trie.matchPrefix.loop]]
[Lean.Widget.MsgEmbed.instFromJsonRpcEncodingPacket,[Lean.FromJson.mk, Except.orElseLazy, Except.bind, Lean.Json.parseTagged, OfNat.ofNat, Option.none, Bind.bind, Lean.FromJson.fromJson?, Array.getOp, Pure.pure, Except.error]]
[Lean.ReducibilityHints.getHeightEx,[Lean.ReducibilityHints.opaque, Lean.ReducibilityHints.abbrev, UInt32, OfNat.ofNat]]
[Lean.JsonNumber.mantissa,[]]
[lt_by_cases.proof_1,[le_antisymm, le_of_not_gt]]
[Lean.Meta.SynthInstance.mkTableKeyFor,[Lean.Meta.withMCtx, Bind.bind, liftM, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Pure.pure, Lean.Meta.SynthInstance.mkTableKey]]
[Lean.Parser.Term.binop,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.ppSpace, Lean.Parser.termParser, Lean.Parser.maxPrec]]
[Lean.KVMap.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.mkAxiomValEx,[Lean.AxiomVal.mk, Lean.ConstantVal.mk]]
[Nat.eq_zero_of_gcd_eq_zero_left,[Eq, OfNat.ofNat, Nat.eq_zero_or_pos, absurd, Eq.symm, ne_of_lt, Nat.gcd_pos_of_pos_left]]
[Function.comp_const,[rfl]]
[Lean.isOutParam,[Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat]]
[Lean.Elab.Term.LValResolution.localRec.inj,[And.intro]]
[Lean.Xml.parse,[Except, String, Lean.Xml.Element, Lean.Xml.Parser.document, String.mkIterator, Except.ok, Except.error, HAppend.hAppend, ToString.toString, Nat.repr, String.Iterator.i, String.Iterator.extract, String.Iterator.prevn, OfNat.ofNat]]
[Lean.IR.Checker.CheckerContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Checker.CheckerContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[instOrdUInt16,[Ord.mk, compareOfLessAndEq]]
[String.dropRight,[Substring.toString, Substring.dropRight, String.toSubstring]]
[Lean.Syntax.Traverser.idxs,[]]
[Lean.IR.UnreachableBranches.resetVarAssignment,[Bind.bind, MonadReader.read, modify, Lean.IR.UnreachableBranches.InterpState.mk, Array.modify, Lean.IR.UnreachableBranches.InterpState.assignments, Lean.IR.UnreachableBranches.InterpContext.currFnIdx, Std.HashMap.insert, Lean.IR.UnreachableBranches.Value.bot, Lean.IR.UnreachableBranches.InterpState.funVals]]
[Mathlib.ExtendedBinder.«term∃ᵉ_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Mathlib.ExtendedBinder.extBinders, Lean.ParserDescr.cat]]
[le_max_left,[dite, LT.lt, of_eq_true, Eq.trans, congrArg, LE.le, if_pos, eq_true, le_refl, Eq.mpr, if_neg, le_of_not_lt]]
[Lean.Elab.Command.Scope.opts,[]]
[Lean.Lsp.TextEdit.mk.inj,[And.intro]]
[Lean.JsonRpc.Message.responseError.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.ble_succ_eq_true,[Eq.refl, Bool.true, HEq.refl, Eq, Nat.ble, Nat.succ, rfl, PProd.fst]]
[Lean.Macro.Context.ref,[]]
[Int.sign_zero,[rfl]]
[CommSemiring.mul_comm,[]]
[Lean.KeyedDeclsAttribute.mk.inj,[And.intro]]
[Lean.Macro.Methods.expandMacro?,[]]
[Lean.Parser.ParserCategory.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserCategory.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Mathlib.Tactic.Lint.«command#lintMathlibAll+-*Only__»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[IO.FS.Metadata.type,[]]
[Lean.Compiler.mkUIntTypeName,[Lean.Name.mkSimple, HAppend.hAppend, ToString.toString]]
[Lean.Elab.TerminationHints.noConfusionType,[]]
[Lean.Meta.Match.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.mkLevelMax',[ite, Eq, BEq.beq, Bool.true, Lean.Level.isZero, Lean.Level.getLevelOffset, GE.ge, Lean.Level.getOffset, Lean.mkLevelMax]]
[Lean.LocalDecl.fvarId,[Lean.FVarId]]
[Lean.Parser.Term.stateRefT.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.macroArg.formatter, Lean.Parser.Term.macroLastArg.formatter]]
[Lean.JsonNumber.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.JsonNumber.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Formatter.parserOfStack.formatter,[Bind.bind, MonadState.get, Lean.PrettyPrinter.Formatter.formatterForKind, Lean.Syntax.getKind]]
[Lean.Elab.Tactic.mkInitialTacticInfo,[Bind.bind, Lean.MonadMCtx.getMCtx, Lean.Elab.Tactic.getUnsolvedGoals, Pure.pure, Lean.Elab.Tactic.mkTacticInfo]]
[USize.shiftLeft,[USize.mk, HShiftLeft.hShiftLeft, USize.val, USize.modn, System.Platform.numBits]]
[Lean.Export.instOfStateLevel,[Lean.Export.OfState.mk, Lean.Export.State.levels, Lean.Export.State.mk, Lean.Export.State.names, Lean.Export.State.exprs, Lean.Export.State.defs, Lean.Export.State.stk]]
[ReaderT.failure,[Alternative.failure]]
[Lean.HeadIndex.mvar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[iff_not_comm,[Decidable.iff_not_comm]]
[Lean.Elab.Term.synthesizeCoeInstMVarCore,[Bind.bind, Lean.MonadOptions.getOptions, Lean.Elab.Term.synthesizeInstMVarCore, Option.some, Lean.Option.get, Lean.Elab.Term.maxCoeSize]]
[not_and,[and_imp]]
[Lean.Exception.hasSyntheticSorry,[Lean.Exception.internal, Bool, Lean.MessageData.hasSyntheticSorry, Bool.false]]
[ST.Ref.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[false_iff,[propext, Iff.intro, Iff.mpr, False.elim]]
[Lean.Meta.Closure.MkValueTypeClosureResult.exprArgs,[]]
[Lean.PrettyPrinter.Delaborator.Pos,[Nat]]
[UInt16.lor,[UInt16.mk, Fin.lor, UInt16.val]]
[Lean.MetavarDecl.kind,[]]
[Lean.Elab.withMacroExpansionInfo,[Lean.Elab.withInfoContext]]
[Lean.IR.EmitC.emitApp,[ite, GT.gt, Array.size, Lean.closureMaxArgs, Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitArgs, Lean.IR.EmitC.emitLn, Lean.IR.EmitC.emitLhs]]
[Lean.Server.Watchdog.GroupedEdits.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.Watchdog.GroupedEdits.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.binop.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.ppSpace.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec]]
[List.set,[List, List.cons, PProd.fst, List.nil]]
[Lean.SyntaxNode.withArgs,[Lean.unreachIsNodeMissing, Lean.unreachIsNodeAtom, Lean.unreachIsNodeIdent]]
[Lean.Parser.Term.sorry.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.modifyTraces,[Lean.MonadTrace.modifyTraceState, Lean.TraceState.mk, Lean.TraceState.enabled, Lean.TraceState.traces]]
[Lean.Elab.Term.BinderView.type,[]]
[Lean.PrettyPrinter.Parenthesizer.State.trailPrec,[]]
[Lean.MessageLog.hasErrors,[Std.PersistentArray.any, Lean.MessageLog.msgs, Lean.MessageSeverity.information, Lean.MessageSeverity.warning, Unit.unit, Bool, Lean.Message.severity, Bool.true, Bool.false]]
[Lean.Elab.Term.LetIdDeclView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.length_nil,[rfl]]
[Lean.Parser.Term.attributes.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.Term.attrInstance.formatter, Bool.false]]
[Lean.Server.RequestError.instCoeErrorRequestError,[Coe.mk, Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.internalError, ToString.toString]]
[UInt16.add,[UInt16.mk, HAdd.hAdd, UInt16.val]]
[LinearOrder.le_total,[]]
[Lean.Lsp.instToJsonHoverParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.HoverParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position]]
[Nat.le.intro,[Nat.le_add_right]]
[Lean.Parser.interpolatedStrFn,[ite, Eq, String.atEnd, Bool.true, Lean.Parser.ParserState.mkEOIError, List.nil, bne, Char.ofNat, Lean.Parser.ParserState.mkError, Lean.Parser.interpolatedStrFn.parse]]
[Lean.Parser.Term.nomatch.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Function.injective.decidable_eq,[decidable_of_iff, Eq, Function.injective.eq_iff]]
[Lean.MessageData.ofFormat.injEq,[Eq.propIntro, Eq.refl, Lean.MessageData.ofFormat, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Formatter.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Formatter.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Mathlib.Tactic.Ext.tacticSplitAnds,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.maxRecDepthErrorMessage,[]]
[Lean.Elab.Term.Do.ToCodeBlock.withNewMutableVars,[MonadWithReader.withReader, ite, Eq, Bool.true, Lean.Elab.Term.Do.ToCodeBlock.Context.mk, Lean.Elab.Term.Do.ToCodeBlock.Context.ref, Lean.Elab.Term.Do.ToCodeBlock.Context.m, Lean.Elab.Term.Do.insertVars, Lean.Elab.Term.Do.ToCodeBlock.Context.mutableVars, Lean.Elab.Term.Do.ToCodeBlock.Context.insideFor]]
[Lean.Parser.Syntax.sepBy1.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.syntaxParser.parenthesizer, Lean.Parser.strLit.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false]]
[Lean.Meta.ToHide.State.hiddenInaccessible,[]]
[Function.update_idem,[funext, Decidable.em, Eq, of_eq_true, Eq.trans, congr, congrArg, dite_congr, congrFun, eq_self, Eq.refl, Eq.symm, Eq.mpr_prop, dite_true, True.intro, eq_false, dite_false]]
[Lean.Elab.Term.StructInst.Field.isSimple,[Lean.Elab.Term.StructInst.Field.mk, List.nil, List.cons, Bool, Bool.true, Bool.false]]
[Lean.Elab.Term.expandLetEqnsDecl,[Bind.bind, Lean.Elab.Term.expandMatchAltsIntoMatch, Bool.false, Pure.pure, Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.getOp, OfNat.ofNat, Lean.mkAtomFrom, List.nil]]
[Lean.Export.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.dynamicQuot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.PrettyPrinter.Parenthesizer.parserOfStack.parenthesizer]]
[Lean.Elab.Command.inferMacroRulesAltKind,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, not, Lean.Syntax.isQuot, Bind.bind, Lean.Elab.throwUnsupportedSyntax, Pure.pure, PUnit.unit]]
[Nat.mul_div_cancel',[Eq.mp, Eq.refl, Eq, HAdd.hAdd, OfNat.ofNat, HMul.hMul, HDiv.hDiv, Nat.zero_add, HMod.hMod, Nat.mod_eq_zero_of_dvd]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.hyps,[]]
[Lean.unreachIsNodeMissing.proof_1,[Eq.refl, Lean.Syntax.missing, HEq.refl, False]]
[Mathlib.ExtendedBinder.«termSatisfiesBinderPred%__»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Tactic.ringNF,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.ringMode, Lean.Parser.Tactic.location]]
[Lean.Meta.Match.Example.arrayLit.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.refl, SizeOf.sizeOf, List.nil, Eq.trans, HAdd.hAdd, Eq.symm, List.cons.sizeOf_spec]]
[Lean.Parser.mkTokenAndFixPos,[Unit.unit, Lean.Parser.ParserState, Lean.Parser.ParserState.mkErrorAt, Option.none, ite, Eq, BEq.beq, Lean.Parser.ParserContext.forbiddenTk?, Option.some, Bool.true, Lean.Parser.ParserState.pushSyntax]]
[IO.appDir,[Bind.bind, IO.appPath, Pure.pure, System.FilePath.parent, Option.none, IO, System.FilePath, IO.FS.realPath, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString]]
[List.subset.trans,[]]
[Lean.Lsp.RpcConnectParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.CtorFieldInfo.object.injEq,[Eq.propIntro, Eq.refl, Lean.IR.CtorFieldInfo.object, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.binrel_no_prop,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.ppSpace, Lean.Parser.termParser, Lean.Parser.maxPrec]]
[Lean.Parser.Module.prelude.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.Parser.Command.macroTailDefault.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter, Lean.Parser.darrow.formatter, Lean.Parser.Command.macroRhs.formatter, Lean.PrettyPrinter.Formatter.categoryParserOfStack.formatter, OfNat.ofNat]]
[Lean.IR.FnBody.dec.inj,[And.intro]]
[UInt16.instSemiringUInt16.proof_5,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, congrFun, HMul.hMul, UInt16.zero_def, UInt16.mul_def, UInt16.mk, OfNat.ofNat, MonoidWithZero.zero_mul, UInt16.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt16]]
[Nat.add_sub_cancel,[]]
[Lean.InductiveType.noConfusionType,[]]
[Lean.Server.Watchdog.GroupedEdits.params,[]]
[forall_prop_decidable,[dite, decidableOfDecidableOfIff, forall_prop_decidable.proof_1, Decidable.isTrue, forall_prop_decidable.proof_2]]
[Int.ofNat_succ,[rfl]]
[Lean.interpolatedStrKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Expr.betaRev,[ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Lean.Expr, LT.lt, HAdd.hAdd, PProd.fst, PProd.snd, Lean.Expr.mkAppRevRange, Lean.Expr.instantiateRange]]
[EmptyCollection.emptyCollection,[]]
[Lean.FVarId.mk.inj,[]]
[Nat.coprime.gcd_eq_one,[id]]
[Subtype.simps.coe,[Subtype.val]]
[Lean.IR.AltCore.ctor.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Std.PersistentHashMap.root,[]]
[IO.Process.Output.stdout,[]]
[Int.instCommRingInt.proof_6,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Int.ofNat, Nat.succ, HAdd.hAdd, Int.ofNat_succ, OfNat.ofNat, Int.distrib_right, Int.add_comm, Int.one_mul, rfl]]
[Lean.Level.max.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Match.InjectionAnyResult.subgoal.inj,[]]
[Lean.JsonRpc.instFromJsonErrorCode,[Lean.FromJson.mk, Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.JsonNumber.mk, Int.ofNat, dite, Eq, Unit.unit, Eq.symm, Int.negSucc, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Except, String, Lean.JsonRpc.ErrorCode, Pure.pure, Lean.JsonRpc.ErrorCode.parseError, Lean.JsonRpc.ErrorCode.invalidRequest, Lean.JsonRpc.ErrorCode.methodNotFound, Lean.JsonRpc.ErrorCode.invalidParams, Lean.JsonRpc.ErrorCode.internalError, Lean.JsonRpc.ErrorCode.serverNotInitialized, Lean.JsonRpc.ErrorCode.unknownErrorCode, Lean.JsonRpc.ErrorCode.contentModified, Lean.JsonRpc.ErrorCode.requestCancelled, Lean.JsonRpc.ErrorCode.rpcNeedsReconnect, MonadExcept.throw]]
[Lean.scientificLitKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Tactic.DeclCache,[Prod, Tactic.Cache, Lean.Meta.MetaM]]
[Lean.Elab.MacroExpansionInfo.format,[Bind.bind, Lean.Elab.ContextInfo.ppSyntax, Lean.Elab.MacroExpansionInfo.lctx, Lean.Elab.MacroExpansionInfo.stx, Lean.Elab.MacroExpansionInfo.output, Pure.pure, HAppend.hAppend, Std.ToFormat.format]]
[Lean.Parser.Command.syntaxCat.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter, Lean.Parser.Command.catBehavior.formatter]]
[instReprSubarray,[Repr.mk, HAppend.hAppend, repr, Subarray.toArray, Std.Format.text]]
[Lean.FVarIdSet,[Std.RBTree, Lean.FVarId, Lean.Name.quickCmp, Lean.FVarId.name]]
[Lean.Lsp.DiagnosticWith.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MetavarContext.noConfusionType,[]]
[Lean.Xml.Parser.DeclSep,[HOrElse.hOrElse, Lean.Xml.Parser.PEReference, SeqRight.seqRight, Lean.Xml.Parser.S, Pure.pure, Unit.unit]]
[Lean.Lsp.RpcKeepAliveParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.UniqueIds.checkDecl,[Lean.IR.UniqueIds.M, Bool, andM, Lean.IR.UniqueIds.checkParams, Lean.IR.UniqueIds.checkFnBody]]
[Lean.Meta.GeneralizeIndicesSubgoal.noConfusionType,[]]
[iff_and_self,[Eq.mpr, Eq.refl, Iff, And, propext, and_comm, iff_self_and, Iff.rfl]]
[Lean.Parser.many1NoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.many1Fn, Lean.Parser.Parser.fn]]
[instHashableList,[Hashable.mk, List.foldl, mixHash, Hashable.hash, OfNat.ofNat]]
[Lean.Parser.Term.hole.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.Parser.ModuleParserState.recovering,[]]
[Lean.MessageLog.isEmpty,[Std.PersistentArray.isEmpty, Lean.MessageLog.msgs]]
[Prod.exists,[Iff.intro, Exists, Prod.mk, Exists.intro]]
[Lean.KVMap.instValueString,[Lean.KVMap.Value.mk, Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Option, String, Option.some, Option.none]]
[Lean.Meta.Simp.mkCongrFun,[Unit.unit, Lean.Meta.MetaM, Lean.Meta.Simp.Result, Lean.Meta.Simp.Result.proof?, Pure.pure, Lean.Meta.Simp.Result.mk, Lean.mkApp, Lean.Meta.Simp.Result.expr, Option.none, Bind.bind, Lean.Meta.mkCongrFun, Option.some]]
[if_ctx_congr_prop,[Iff, ite, absurd, Iff.mp, not_iff_not_of_iff, Iff.mpr]]
[decidableOfDecidableOfEq,[]]
[Lean.Parser.trailingLoopStep,[Lean.Parser.longestMatchFn, Option.some, HAppend.hAppend, Lean.Parser.PrattParsingTables.trailingParsers]]
[Lean.Parser.Tactic.ring1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[FloatArray.forIn.loop.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self]]
[Lean.IR.FnBody.sset.inj,[And.intro]]
[Lean.Meta.NormNum.isNat,[Eq, OfNat.ofNat]]
[Lean.Parser.Command.classInductive.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.group.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.Command.optDeclSig.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.many.formatter, Lean.Parser.Command.ctor.formatter, Lean.Parser.Command.optDeriving.formatter]]
[Nat.lcm_self,[Eq, Nat.lcm, Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, OfNat.ofNat, Nat.lcm_zero_left, rfl]]
[Lean.Parser.Tactic.revertTargetDeps,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Elab.Tactic.evalFailIfSuccess,[Bind.bind, MonadExcept.tryCatch, Lean.Elab.Tactic.evalTactic, Pure.pure, Bool.true, Bool.false, ite, Eq, Lean.throwError, Lean.ToMessageData.toMessageData, PUnit.unit]]
[List.subset_cons_of_subset,[Or.inr]]
[Lean.Elab.Term.StructInst.DefaultFields.Context.allStructNames,[]]
[instSizeOfNat,[SizeOf.mk]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.noConfusionType,[]]
[Lean.Meta.DiscrTree.instInhabitedDiscrTree,[Inhabited.mk, Lean.Meta.DiscrTree.mk]]
[Array.eraseIdx'.proof_1,[rfl]]
[Lean.DefinitionVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.DefinitionVal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Server.instInhabitedDocumentMeta,[Inhabited.mk, Lean.Server.DocumentMeta.mk, arbitrary]]
[Lean.Meta.DiscrTree.instDecidableLt,[inferInstanceAs, Decidable, Eq, Lean.Meta.DiscrTree.Key.lt, Bool.true]]
[Lean.Lsp.TextDocumentItem.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.ParserCompiler.CombinatorAttribute.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ParserCompiler.CombinatorAttribute.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Expr.ctorName,[String]]
[Lean.Elab.Term.LValResolution.const.inj,[And.intro]]
[Function.involutive.eq_iff,[Function.injective.eq_iff', Function.involutive.injective]]
[Lean.Parser.Term.doLetArrow.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.doIdDecl.parenthesizer, Lean.Parser.Term.doPatDecl.parenthesizer]]
[Lean.Meta.UnificationHint.constraints,[]]
[Lean.Parser.Tactic.unfoldWf,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[instCoeStringError,[Coe.mk, IO.userError]]
[Lean.Parser.Tactic.rwRule,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat]]
[Lean.Meta.Match.MatcherInfo.numParams,[]]
[Lean.Elab.Command.getScopes,[Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Command.State.scopes]]
[Lean.ExternEntry.foreign.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ExternEntry.foreign, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.MessageDataContext.mctx,[]]
[Lean.bignumToJson,[Lean.Json.str, ToString.toString]]
[Lean.Elab.MacroExpansionInfo.stx,[]]
[Lean.QuotKind.toCtorIdx,[OfNat.ofNat]]
[Nat.gcd_zero_right,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, Nat.gcd, Nat.zero_eq, OfNat.ofNat, Nat.gcd_zero_left, eq_true_of_decide, Eq.refl, Bool.true, Eq.symm, Nat.gcd_succ, Nat.zero_mod, Nat.succ, eq_self]]
[instToStringUSize,[ToString.mk, ToString.toString, USize.toNat]]
[Lean.Expr.FoldConstsImpl.State.noConfusionType,[]]
[Lean.Elab.Term.StructInst.Field.toSyntax,[List.nil, Lean.Syntax, Lean.Elab.Term.StructInst.Field.lhs, Lean.Syntax.setArg, OfNat.ofNat, Lean.mkNullNode, List.toArray, List.cons, Lean.Elab.Term.StructInst.FieldLHS.toSyntax, Bool.true, Array.map, Bool.false, panicWithPosWithDecl]]
[Std.PersistentArray.tailOff,[]]
[Std.PersistentHashMap.Stats.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Mod.noConfusionType,[]]
[Lean.Core.State.ngen,[]]
[Std.RBNode.node.inj,[And.intro]]
[Lean.Meta.mkEqSymm,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.eq?, Lean.Meta.getLevel, Lean.mkApp4, Lean.mkConst, List.cons, List.nil, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr]]
[Lean.Elab.Info.docString?,[Bind.bind, Lean.MonadEnv.getEnv, Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.Info.ofCompletionInfo, Lean.Meta.MetaM, Option, String, Option.none, Lean.Expr.constName?, Lean.Elab.TermInfo.expr, liftM, Lean.findDocString?, Pure.pure, PUnit.unit]]
[Lean.instInhabitedSourceInfo,[Inhabited.mk, Lean.SourceInfo.none]]
[List.span,[List.spanAux, List.nil]]
[autoParam,[]]
[Lean.IR.Expr.box.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.box, Eq.symm, eq_of_heq, HEq.refl]]
[Std.HashMap.isEmpty,[Decidable.decide, Eq, Std.HashMap.size, OfNat.ofNat]]
[Lean.Elab.Level.mkFreshLevelMVar,[Bind.bind, Lean.mkFreshMVarId, modify, Lean.Elab.Level.State.mk, Lean.Elab.Level.State.ngen, Lean.MetavarContext.addLevelMVarDecl, Lean.Elab.Level.State.mctx, Lean.Elab.Level.State.levelNames, Pure.pure, Lean.mkLevelMVar]]
[AddMonoid.zero_add,[]]
[Equiv.apply_symm_apply,[Equiv.rightInv]]
[Lean.IR.Decl.name,[Lean.IR.FunId]]
[Lean.Parser.Term.have.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.haveDecl.parenthesizer, Lean.Parser.Term.optSemicolon.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Lean.Elab.Tactic.evalAnyGoals,[Bind.bind, Lean.Elab.Tactic.getGoals, ForIn.forIn, MProd.mk, liftM, Lean.Meta.isExprMVarAssigned, ite, Eq, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Elab.Tactic.setGoals, List.cons, List.nil, MonadExcept.tryCatch, Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Tactic.getUnsolvedGoals, Lean.Elab.Tactic.TacticM, ForInStep, MProd, Bool, Array, Lean.MVarId, MProd.fst, Unit, Lean.throwError, Lean.ToMessageData.toMessageData]]
[instLEUInt64,[LE.mk, UInt64.le]]
[UInt64.instAddCommSemigroupUInt64,[AddCommSemigroup.mk, UInt64.instAddCommSemigroupUInt64.proof_1]]
[instLTOption,[LT.mk, Option.lt, LT.lt]]
[Int.instLEInt,[LE.mk, Int.le]]
[List.equiv_iff_subset_and_subset,[Iff.intro, And.intro, Iff.mp, Iff.mpr, Iff, Mem.mem]]
[instLTUSize,[LT.mk, USize.lt]]
[Lean.Elab.ContextInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.str,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.strLit]]
[AddSemigroup.add_assoc,[]]
[UInt16.decLe,[Decidable, LE.le, inferInstanceAs]]
[Lean.MetavarContext.findLocalDeclDependsOn,[Bool, Lean.MetavarContext.findExprDependsOn, StateT.run', orM, Lean.MetavarContext.DependsOn.main, EmptyCollection.emptyCollection]]
[UInt32.instSemiringUInt32.proof_12,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HMul.hMul, UInt32.add_def, UInt32.mul_def, UInt32.mk, HAdd.hAdd, UInt32.val, UInt32.eq_of_val_eq, Semiring.add_mul]]
[Lean.Parser.Tactic.tacticLet'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Lean.Elab.Term.expandDbgTrace,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.interpolatedStrKind, Bool.true, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom]]
[Lean.Server.registerRpcCallHandler,[Bind.bind, liftM, IO.initializing, ite, Eq, not, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Pure.pure, PUnit.unit]]
[Function.injective.of_comp,[]]
[Lean.Elab.Deriving.Header.binders,[]]
[Lean.Server.FileWorker.unfoldCmdSnaps,[ite, Eq, and, Lean.MessageLog.hasErrors, Lean.Server.Snapshots.Snapshot.msgLog, Bool.true, Pure.pure, IO.AsyncList.nil, Bind.bind, MonadReader.read, liftM, IO.AsyncList.unfoldAsync, Lean.Server.FileWorker.CancelToken.check, Lean.Server.Snapshots.Snapshot.isAtEnd, Lean.Server.publishDiagnostics, Std.PersistentArray.toArray, Lean.Server.Snapshots.Snapshot.diagnostics, Lean.Server.publishProgressDone, MonadExcept.throw, Lean.Server.FileWorker.ElabTaskError.eof, PUnit.unit]]
[UInt16.mul,[UInt16.mk, HMul.hMul, UInt16.val]]
[Lean.Meta.Closure.pushFVarArg,[modify, Lean.Meta.Closure.State.mk, Lean.Meta.Closure.State.visitedLevel, Lean.Meta.Closure.State.visitedExpr, Lean.Meta.Closure.State.levelParams, Lean.Meta.Closure.State.nextLevelIdx, Lean.Meta.Closure.State.levelArgs, Lean.Meta.Closure.State.newLocalDecls, Lean.Meta.Closure.State.newLocalDeclsForMVars, Lean.Meta.Closure.State.newLetDecls, Lean.Meta.Closure.State.nextExprIdx, Lean.Meta.Closure.State.exprMVarArgs, Array.push, Lean.Meta.Closure.State.exprFVarArgs, Lean.Meta.Closure.State.toProcess]]
[Lean.Elab.Info.ofTacticInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[false_implies_iff,[Iff.intro, trivial, False.elim]]
[Function.involutive.injective,[Function.left_inverse.injective, Function.involutive.left_inverse]]
[Lean.ImportState.moduleData,[]]
[Lean.Parser.Tactic.exactModCast,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[instInhabitedDepArrow,[Inhabited.mk, arbitrary]]
[IO.Process.Child.stdin,[]]
[Char.isValidCharNat,[Or, LT.lt, OfNat.ofNat, And]]
[«term_%_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Std.PersistentArray.stats,[Std.PersistentArray.collectStats, Std.PersistentArray.root, Std.PersistentArray.Stats.mk, OfNat.ofNat, Array.size, Std.PersistentArray.tail]]
[Lean.LBool.and,[Lean.LBool.false, Lean.LBool.undef, Lean.LBool]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.forceRegularApp,[]]
[Lean.KeyedDeclsAttribute.ExtensionState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KeyedDeclsAttribute.ExtensionState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.LocalInstance.noConfusionType,[]]
[Lean.PrettyPrinter.Delaborator.getUnusedName.bodyUsesSuggestion,[Option.isSome, Lean.Expr.find?, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Unit.unit, Lean.LocalContext.find?, Bool.false, BEq.beq, Lean.LocalDecl.userName]]
[Int.sign,[Unit.unit, Int, OfNat.ofNat, Neg.neg]]
[Lean.Meta.DecLevelContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.decimalNumberFn.parseOptDot,[ite, Eq, BEq.beq, Char.ofNat, Bool.true, Char.isDigit, Lean.Parser.takeWhileFn, Lean.Parser.ParserState.setPos]]
[mul_left_inv,[Group.mul_left_inv]]
[Lean.Elab.Term.ToDepElimPattern.State.newLocals,[]]
[UInt64.val,[]]
[String.Iterator.nextn,[String.Iterator, PProd.fst, String.Iterator.next]]
[Lean.Elab.Tactic.State.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Tactic.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.UnreachableBranches.Value.choice.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.refl, SizeOf.sizeOf, List.nil, Eq.trans, HAdd.hAdd, Eq.symm, List.cons.sizeOf_spec]]
[Lean.Elab.Tactic.instInhabitedState,[Inhabited.mk, Lean.Elab.Tactic.State.mk, arbitrary]]
[Lean.ParserCompiler.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ParserCompiler.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Server.FileWorker.ElabTaskError.ioError.injEq,[Eq.propIntro, Eq.refl, Lean.Server.FileWorker.ElabTaskError.ioError, Eq.symm, eq_of_heq, HEq.refl]]
[List.singleton_append,[rfl]]
[Lean.Parser.takeWhileFn,[Lean.Parser.takeUntilFn, not]]
[UInt16.toUInt32,[Nat.toUInt32, UInt16.toNat]]
[Lean.Meta.Simp.Result.noConfusionType,[]]
[Lean.Parser.LeadingIdentBehavior.symbol.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[instNonempty,[instNonempty.proof_1]]
[Lean.Meta.CaseValuesSubgoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.all,[not, Nat.any]]
[Lean.IR.CtorFieldInfo.usize.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[StateCpsT.runK_pure,[rfl]]
[Lean.IR.FnBody.dec.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.dec, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.TermElabM,[ReaderT, Lean.Elab.Term.Context, StateRefT', IO.RealWorld, Lean.Elab.Term.State, Lean.Meta.MetaM]]
[HEq.rfl,[HEq.rfl.proof_1]]
[Int.subNatNat_of_lt,[Eq.mpr, Eq.refl, Eq, Int.subNatNat, Int.negSucc, Nat.pred, HSub.hSub, Int.subNatNat_of_sub_eq_succ, Nat.succ, Nat.succ_pred_eq_of_pos, Nat.sub_pos_of_lt, rfl]]
[Function.surjective_to_subsingleton,[Exists, Eq, Exists.intro, Subsingleton.elim]]
[Substring.atEnd,[Bool, BEq.beq, HAdd.hAdd]]
[Lean.Elab.Term.LetIdDeclView.type,[]]
[Lean.Parser.registerBuiltinParserAttribute,[Bind.bind, ST.Ref.get, Lean.Parser.builtinParserCategoriesRef, IO.ofExcept, ite, Eq, Std.PersistentHashMap.contains, Bool.true, MonadExcept.throw, HAppend.hAppend, ToString.toString, Pure.pure, Std.PersistentHashMap.insert, Lean.Parser.ParserCategory.mk, Lean.Parser.PrattParsingTables.mk, ST.Ref.set, Lean.registerBuiltinAttribute, Lean.AttributeImpl.mk, Lean.AttributeImplCore.mk, Lean.AttributeApplicationTime.afterCompilation, liftM, Lean.Attribute.Builtin.getPrio, BEq.beq, Lean.AttributeKind.global, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.Elab.Term.FunBinders.State.fvars,[]]
[Lean.Meta.DiscrTree.Key.star.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Function.comp_left,[]]
[Lean.Elab.Frontend.Context.noConfusionType,[]]
[Lean.Lsp.TextDocumentSyncOptions.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.TextDocumentSyncOptions.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.coprime.mul_dvd_of_dvd_of_dvd,[Dvd.dvd, HMul.hMul, Nat.mul_dvd_mul_left, Nat.coprime.dvd_of_dvd_mul_left, Nat.coprime.symm, Eq.symm]]
[Lean.Meta.InstanceEntry.mk.inj,[And.intro]]
[dbgTrace,[Unit.unit]]
[Lean.Meta.Match.Pattern.inaccessible.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Match.Pattern.inaccessible, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.MetavarDecl.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.StructInst.Source.implicit.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.StructInst.Source.implicit, Eq.symm, eq_of_heq, HEq.refl]]
[instHAndThen,[HAndThen.mk, AndThen.andThen]]
[Lean.Parser.PrattParsingTables.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.forM,[Unit.unit, PUnit, Pure.pure, PUnit.unit, Bind.bind, PProd.fst]]
[Lean.PrettyPrinter.Parenthesizer.ParenthesizerAliasValue,[Lean.Parser.AliasValue, Lean.PrettyPrinter.Parenthesizer]]
[Lean.Compiler.CSimp.Entry.mk.inj,[And.intro]]
[Nat.add_le_add_iff_le_right,[Iff.intro, Nat.le_of_add_le_add_right, Nat.add_le_add_right]]
[StateRefT'.run,[Bind.bind, ST.mkRef, ST.Ref.get, Pure.pure, Prod.mk]]
[Lean.Parser.Term.letPatDecl.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.pushNone.formatter, Lean.Parser.Term.optType.formatter, Lean.Parser.symbol.formatter, Bool.false]]
[Lean.Meta.isType,[Bind.bind, Lean.Meta.isTypeQuick, Unit.unit, Lean.Meta.MetaM, Bool, Pure.pure, Bool.true, Bool.false, Lean.Meta.inferType, Lean.Meta.whnfD, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj]]
[Lean.Lsp.Ipc.waitForExit,[Bind.bind, MonadReader.read, liftM, IO.Process.Child.wait]]
[Nat.add_lt_add_left,[Nat.lt_of_succ_le, Nat.add_le_add_left, Nat.succ_le_of_lt, Nat.add_succ]]
[Lean.Parser.Command.macroRhs,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HOrElse.hOrElse, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.withPosition, Lean.Parser.termParser]]
[Std.HashSetImp.foldBuckets,[Id.run, Std.HashSetImp.foldBucketsM]]
[Nat.dvd_mul_right,[Exists.intro, rfl]]
[Lean.instInhabitedAttributeImplCore,[Inhabited.mk, Lean.AttributeImplCore.mk, arbitrary]]
[Lean.Macro.throwError,[Bind.bind, Lean.MonadRef.getRef, MonadExcept.throw, Lean.Macro.Exception.error]]
[instAddCommGroup.proof_4,[Semiring.nsmul_succ']]
[Lean.Compiler.binFoldFns,[HAppend.hAppend, Lean.Compiler.boolFoldFns, Lean.Compiler.uintBinFoldFns, Lean.Compiler.natFoldFns]]
[Lean.Meta.NormNum.instLawfulOfNat,[Lean.Meta.NormNum.instLawfulOfNat.proof_1]]
[Lean.idEndEscape,[Char.ofNat]]
[Lean.Meta.SynthInstance.getNextToResume,[Bind.bind, MonadState.get, modify, Lean.Meta.SynthInstance.State.mk, Lean.Meta.SynthInstance.State.result?, Lean.Meta.SynthInstance.State.generatorStack, Array.pop, Lean.Meta.SynthInstance.State.resumeStack, Lean.Meta.SynthInstance.State.tableEntries, Pure.pure]]
[LawfulApplicative.seq_assoc,[]]
[Lean.Expr.app2?,[ite, Eq, Lean.Expr.isAppOfArity, OfNat.ofNat, Bool.true, Option.some, Prod.mk, Lean.Expr.appArg!, Lean.Expr.appFn!, Option.none]]
[Lean.MetavarContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.isIOUnitBuiltinInitFn,[Lean.isIOUnitInitFnCore, Lean.builtinInitAttr]]
[HXor.hXor,[]]
[GE.ge,[LE.le]]
[Lean.Elab.Command.State.traceState,[]]
[Lean.Lsp.WaitForDiagnosticsParams.mk.inj,[And.intro]]
[Lean.EnvExtensionState,[PointedType.type, Lean.EnvExtensionStateSpec]]
[Semiring.npow,[]]
[Lean.Elab.Term.Do.getDoReassignVars,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Pure.pure, List.toArray, List.cons, Lean.Elab.Term.Do.getLetIdDeclVar, List.nil, Lean.Elab.Term.Do.getLetPatDeclVars, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.SMap.foldStage2,[Std.PersistentHashMap.foldl, Lean.SMap.map₂]]
[Lean.withoutModifyingEnv,[Bind.bind, Lean.MonadEnv.getEnv, tryFinally, Lean.setEnv]]
[Lean.Meta.IndPredBelow.mkBrecOnDecl.mkIH,[Bind.bind, Lean.Meta.instantiateForall, Prod.snd, liftM, Pure.pure, Prod.mk]]
[instTransEq.proof_1,[Eq.symm]]
[Substring.isEmpty,[BEq.beq, Substring.bsize, OfNat.ofNat]]
[Lean.LocalContext.isSubPrefixOf,[Lean.LocalContext.isSubPrefixOfAux, Lean.LocalContext.decls, OfNat.ofNat]]
[Lean.formatKVMap,[Std.Format.sbracket, Std.Format.joinSep, Lean.KVMap.entries, Std.Format.text]]
[Lean.Elab.DefKind.toCtorIdx,[OfNat.ofNat]]
[instHModUSizeNatUSize,[HMod.mk, USize.modn]]
[Nat.div_lt_iff_lt_mul,[Eq.mpr, Eq.refl, Iff, LT.lt, HDiv.hDiv, HMul.hMul, Eq.symm, propext, not_le, Not, LE.le, not_congr, Nat.le_div_iff_mul_le]]
[Function.surj_inv_eq,[Classical.choose_spec]]
[Lean.Elab.Deriving.Header.targetType,[]]
[Lean.Core.Context.noConfusionType,[]]
[Lean.Elab.Command.Ctor2InferMod,[Std.HashMap, Lean.Name, Bool]]
[Lean.Parser.Tactic.dUnfold,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.Parser.Tactic.location]]
[Lean.Meta.rewrite,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.MetaM, Lean.Meta.RewriteResult, Unit.unit, Lean.Expr.iff?, Lean.Meta.mkEq]]
[Lean.Lsp.instFileSourceReferenceParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.ReferenceParams.toTextDocumentPositionParams]]
[Lean.isIdEndEscape,[Decidable.decide, Eq, Lean.idEndEscape]]
[Lean.Environment.moduleIdxForModule?,[Option.map, Fin.val, Array.indexOf?, Lean.Environment.allImportedModuleNames]]
[Lean.instInhabitedExternAttrData,[Inhabited.mk, Lean.ExternAttrData.mk, arbitrary]]
[Lean.PersistentEnvExtensionDescr.mk.inj,[And.intro]]
[Lean.Parser.Tactic.measurability!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Declaration.axiomDecl.inj,[]]
[Lean.JsonRpc.Message.noConfusionType,[]]
[Lean.Elab.DefKind.isDefOrAbbrevOrOpaque,[Unit.unit, Lean.Elab.DefKind.theorem, Lean.Elab.DefKind.example, Bool, Bool.true, Bool.false]]
[inferInstance,[]]
[Lean.Elab.Tactic.Conv.evalConvSeq,[Lean.Elab.Tactic.evalTactic, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Expr.mdata.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.mdata, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Do.Code.jmp.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Code.jmp, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.init_quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Lean.Server.FileWorker.WorkerContext.hIn,[]]
[Lean.Expr.setPPUniverses,[Lean.Expr.setOption, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.KVMap.mk.injEq,[Eq.propIntro, Eq.refl, Lean.KVMap.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.addTrailingParser,[Unit.unit, Except, String, Lean.Parser.ParserCategories, Lean.Parser.getCategory, Lean.Parser.throwUnknownParserCategory, Pure.pure, Std.PersistentHashMap.insert, Lean.Parser.ParserCategory.mk, Lean.Parser.FirstTokens.epsilon, Lean.Parser.FirstTokens.unknown, Lean.Parser.PrattParsingTables, Lean.Parser.ParserInfo.firstTokens, Lean.Parser.Parser.info, Lean.Parser.PrattParsingTables.mk, Lean.Parser.PrattParsingTables.leadingTable, Lean.Parser.PrattParsingTables.leadingParsers, Lean.Parser.PrattParsingTables.trailingTable, List.cons, Prod.mk, Lean.Parser.PrattParsingTables.trailingParsers, Lean.Parser.ParserCategory.tables, Lean.Parser.ParserCategory.behavior]]
[Lean.Meta.TransparencyMode.instHashableTransparencyMode,[Hashable.mk, Lean.Meta.TransparencyMode.hash]]
[Lean.Parser.dbgTraceState,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.dbgTraceStateFn, Lean.Parser.Parser.fn]]
[Lean.Expr.hasAnyFVar.visit,[ite, Eq, not, Lean.Expr.hasFVar, Bool.true, Bool.false, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lit, Bool, or, PProd.fst, PProd.snd]]
[ToBool.toBool,[]]
[CoeT.coe,[]]
[Trans.noConfusionType,[]]
[Lean.Expr.isConstOf,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, BEq.beq, Bool.false]]
[Lean.Compiler.SpecializeAttributeKind.nospecialize.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Substring.startPos,[]]
[Lean.Exception.error.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[IO.Process.Stdio.inherit.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Lsp.instToJsonPlainTermGoalParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.PlainTermGoalParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position]]
[Lean.Elab.Term.Do.ToCodeBlock.Catch.mk.inj,[And.intro]]
[Lean.PrettyPrinter.Delaborator.State.holeIter,[]]
[Lean.IR.EmitC.emitReset,[Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn, Nat.forM, Lean.IR.EmitC.emitLhs]]
[List.card_map_eq_of_inj_on,[of_eq_true, Eq.trans, implies_congr, Eq.refl, List.inj_on, List.nil, congr, congrArg, Eq, List.card, List.map_nil, List.card_nil, eq_true_of_decide, Bool.true, implies_true, Decidable.em, Mem.mem, List.map, List.exists_of_mem_map, Eq.symm]]
[right_cancelative,[Eq]]
[Lean.Widget.InteractiveGoal.userName?,[]]
[Char.utf8Size,[ite, LE.le, UInt32.ofNatCore, OfNat.ofNat, Char.utf8Size.proof_1, Char.utf8Size.proof_2, Char.utf8Size.proof_3, Char.utf8Size.proof_4, Char.utf8Size.proof_5, Char.utf8Size.proof_6, Char.utf8Size.proof_7]]
[Lean.EnvironmentHeader.mk.inj,[And.intro]]
[Lean.Parser.Term.depArrow.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.bracketedBinder.formatter, Lean.Parser.unicodeSymbol.formatter, Lean.Parser.termParser.formatter]]
[Lean.Elab.Tactic.ElabSimpArgsResult.mk.inj,[And.intro]]
[Nat.find,[Subtype.val, Nat.find_x]]
[IO.Error.permissionDenied.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.private.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.Lsp.DocumentHighlight.range,[]]
[Lean.Meta.Closure.ToProcessElement.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[InvImage.accessible.proof_1,[Acc.intro, rfl]]
[Lean.Parser.Term.doLetRec.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.group.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.Term.letRecDecls.formatter]]
[Lean.SCC.Data.mk.inj,[And.intro]]
[Fin.land,[Fin, Fin.mk, HMod.hMod, Nat.land, Fin.land.proof_1]]
[Lean.Parser.Command.print.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.ident.formatter, Lean.Parser.strLit.formatter]]
[«term_≈_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[UInt8.instSemiringUInt8.proof_7,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt8.one_def, UInt8.mul_def, UInt8.mk, OfNat.ofNat, one_mul, UInt8.val, UInt8.mk_val_eq, eq_self, propext, forall_const, UInt8]]
[Lean.Parser.nonReservedSymbol,[Lean.Parser.tokenWithAntiquot, Lean.Parser.nonReservedSymbolNoAntiquot]]
[Tactic.Ring.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Std.RBMap.foldM,[Std.RBNode.foldM]]
[Lean.Meta.SynthInstance.ConsumerNode.mk.inj,[And.intro]]
[Lean.KVMap.insertCore,[List, Prod, Lean.Name, Lean.DataValue, List.cons, Prod.mk, List.nil, ite, Eq, BEq.beq, Bool.true, PProd.fst]]
[Lean.JsonRpc.instFromJsonRequestID,[Lean.FromJson.mk, Lean.Json.null, Lean.Json.bool, Lean.Json.arr, Lean.Json.obj, Except, String, Lean.JsonRpc.RequestID, Pure.pure, Lean.JsonRpc.RequestID.str, Lean.JsonRpc.RequestID.num, MonadExcept.throw]]
[instShiftRightUInt8,[ShiftRight.mk, UInt8.shiftRight]]
[Lean.Parser.Syntax.cat.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.Parser.optPrecedence.formatter]]
[ExceptT.seqRight_eq,[]]
[Lean.Parser.Term.generalizingParam.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.trueVal.parenthesizer, Lean.Parser.Term.falseVal.parenthesizer]]
[Lean.Parser.Tactic.use,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[Lean.ScopedEnvExtension.Entry.scoped.inj,[And.intro]]
[Command.simpsProj,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Command.simpsRule, Bool.false]]
[Lean.Elab.Term.MatchAltView.ref,[]]
[List.card_eq_of_equiv,[Nat.le_antisymm, List.card_subset_le, And.left, And.right]]
[Lean.Meta.forallTelescope,[Lean.Meta.map2MetaM, Bool.false, Option.none]]
[Lean.Meta.SynthInstance.Waiter.root.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Command.eval.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.Lsp.instFromJsonDiagnosticRelatedInformation,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.Location, String, Pure.pure, Lean.Lsp.DiagnosticRelatedInformation.mk]]
[Lean.Elab.InfoTree.deepestNodes,[Option.none, Lean.Elab.InfoTree.deepestNodes.go]]
[Lean.LocalContext.findDeclM?,[Std.PersistentArray.findSomeM?, Lean.LocalContext.decls, Unit.unit, Option, Pure.pure, Option.none]]
[Lean.CollectLevelParams.State.mk.inj,[And.intro]]
[Lean.Server.Watchdog.ServerContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.instance.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.optNamedPrio.formatter, Lean.Parser.optional.formatter, Lean.ppSpace.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.Command.declSig.formatter, Lean.Parser.Command.declVal.formatter, Lean.Parser.Command.terminationSuffix.formatter]]
[Lean.IR.ExplicitRC.VarMap,[Std.RBMap, Lean.IR.VarId, Lean.IR.ExplicitRC.VarInfo, Ord.compare, Lean.IR.VarId.idx]]
[Lean.IR.Borrow.collectDecls,[Bind.bind, MonadReader.read, Lean.IR.Borrow.whileModifing, Array.forM, Lean.IR.Borrow.collectDecl, Lean.IR.Borrow.BorrowInfCtx.decls, OfNat.ofNat, Array.size, MonadState.get, Pure.pure, Lean.IR.Borrow.BorrowInfState.paramMap]]
[not_imp,[Decidable.not_imp]]
[Lean.setImplementedBy,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.Compiler.setImplementedBy, Lean.setEnv, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[Std.PersistentArray.findSomeRev?,[Id.run, Std.PersistentArray.findSomeRevM?]]
[List.map_cons,[rfl]]
[Lean.IR.FnBody.body,[Lean.IR.FnBody.case, Lean.IR.FnBody.ret, Lean.IR.FnBody.jmp, Lean.IR.FnBody.unreachable, Lean.IR.FnBody]]
[Lean.mkBelow,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.MonadEnv.modifyEnv, Lean.throwKernelException, Lean.mkBelowImp]]
[Lean.Lsp.RpcKeepAliveParams.uri,[]]
[SubNegMonoid.gsmul,[]]
[Lean.IR.UnreachableBranches.InterpContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.UnreachableBranches.InterpContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.elabPipeProj,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Term.withoutPostponingUniverseConstraints, Bind.bind, Lean.Elab.Term.expandArgs, Bool.false, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, BEq.beq, Array.size, OfNat.ofNat, Lean.Elab.Term.applyResult, Array.getOp, GT.gt, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.joinSep, Array.toList, Lean.withRef, Array.mapM, Lean.MessageData, panicWithPosWithDecl, Lean.Elab.getRefPos, Unit.unit, Lean.Syntax.getPos?, Lean.Exception.getRef, Lean.Exception.toMessageData, Lean.MonadFileMap.getFileMap, Lean.Position.line, Lean.Position.column, Lean.throwError, Lean.Elab.throwUnsupportedSyntax]]
[true_iff_false,[iff_false_intro, Iff.mp, trivial]]
[Lean.Meta.Simp.Config.contextual,[]]
[Lean.Parser.AliasValue.unary.inj,[]]
[Lean.Meta.GeneralizeTelescope.Entry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.GeneralizeTelescope.Entry.mk, Eq.symm, eq_of_heq, HEq.refl]]
[OfScientific.noConfusionType,[]]
[Lean.Parser.rawFn,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Parser.ParserState.pushSyntax]]
[Lean.Message.endPos,[]]
[Float.mk.injEq,[Eq.propIntro, Eq.refl, Float.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.exit,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.checkKnowsType,[Bind.bind, MonadReader.read, ite, Eq, not, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.knowsType, Bool.true, MonadExcept.throw, Lean.Exception.internal, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeFailureId, Lean.KVMap.mk, Pure.pure, PUnit.unit]]
[Lean.Widget.instToJsonGetInteractiveDiagnosticsParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Widget.GetInteractiveDiagnosticsParams.lineRange?, List.nil]]
[Lean.PrettyPrinter.Formatter.checkColGe.formatter,[Pure.pure, Unit.unit]]
[Lean.Meta.Simp.instReprConfig,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.Meta.Simp.Config.maxSteps, Std.Format.line, Lean.Meta.Simp.Config.maxDischargeDepth, Lean.Meta.Simp.Config.contextual, Lean.Meta.Simp.Config.memoize, Lean.Meta.Simp.Config.singlePass, Lean.Meta.Simp.Config.zeta, Lean.Meta.Simp.Config.beta, Lean.Meta.Simp.Config.eta, Lean.Meta.Simp.Config.etaStruct, Lean.Meta.Simp.Config.iota, Lean.Meta.Simp.Config.proj, Lean.Meta.Simp.Config.decide]]
[Lean.PrettyPrinter.Parenthesizer.withAntiquotSuffixSplice.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, Lean.Syntax.isAntiquotSuffixSplice, Bool.true, Lean.PrettyPrinter.Parenthesizer.visitArgs, SeqRight.seqRight]]
[Lean.Syntax.SepArray.ofElems,[Lean.Syntax.SepArray.mk, Lean.mkSepArray, Lean.mkAtom]]
[Lean.IR.ExplicitRC.Context.mk.inj,[And.intro]]
[Lean.Lsp.RpcCallParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Level.mvarId!,[Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.MVarId, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Lsp.TextDocumentItem.noConfusionType,[]]
[Lean.Parser.Command.declValEqns.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.Term.matchAltsWhereDecls.formatter]]
[Lean.addMessageContextFull,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadMCtx.getMCtx, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Pure.pure, Lean.MessageData.withContext, Lean.MessageDataContext.mk]]
[Lean.Parser.Tactic.tacticErw__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.Parser.Tactic.location]]
[Lean.Parser.Tactic.cc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[instXorUInt64,[Xor.mk, UInt64.xor]]
[Lean.Parser.Command.identPrec,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.optPrecedence]]
[Lean.Meta.DecLevelContext.canAssignMVars,[]]
[Lean.Elab.Term.instInhabitedMatchAltView,[Inhabited.mk, Lean.Elab.Term.MatchAltView.mk, arbitrary]]
[Lean.PrettyPrinter.Parenthesizer.sepByNoAntiquot.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.PrettyPrinter.Parenthesizer.visitArgs, List.forM, List.reverse, List.range, Array.size, Lean.Syntax.getArgs, ite, Eq, BEq.beq, HMod.hMod, OfNat.ofNat, Bool.true]]
[Lean.Elab.Term.elabStrLit,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Syntax.isStrLit?, Pure.pure, Lean.mkStrLit, Lean.Elab.throwIllFormedSyntax]]
[Prod.map_snd,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Prod.snd, prod_map, eq_self]]
[List.lengthTR,[List.lengthTRAux, OfNat.ofNat]]
[Int.negOfNat_add,[Unit.unit, Eq, HAdd.hAdd, Int.negOfNat, of_eq_true, Eq.trans, congr, congrArg, Nat.zero_eq, Nat.add_zero, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true, Eq.mpr, congrFun, Nat.succ, Nat.zero_add, rfl, Nat.succ_add]]
[Lean.Elab.Term.CollectPatternVars.Context.paramDecls,[]]
[Lean.Lsp.SymbolKind.method.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Union.noConfusionType,[]]
[Lean.Elab.Command.elabInitQuot,[Bind.bind, Lean.MonadEnv.getEnv, Lean.Elab.Command.CommandElabM, Unit, Lean.Environment.addDecl, Lean.Declaration.quotDecl, Lean.setEnv, Lean.MonadOptions.getOptions, Lean.throwError, Lean.KernelException.toMessageData]]
[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer]]
[Eq.substr,[Eq.symm]]
[Lean.Core.instMonadWithOptionsCoreM,[Lean.MonadWithOptions.mk, MonadWithReader.withReader, Lean.Core.Context.mk, Lean.Core.Context.options, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats]]
[Lean.Elab.isAutoBoundImplicitLocalException?,[Lean.Exception.error, Option, Lean.Name, ite, Eq, BEq.beq, Lean.Elab.autoBoundImplicitExceptionId, Bool.true, Option.some, Lean.KVMap.getName, Lean.Name.mkStr, Lean.Name.anonymous, Option.none]]
[false_of_ne,[Ne.irrefl]]
[instReprSigma,[Repr.mk, Std.Format, Std.Format.bracket, HAppend.hAppend, repr, Std.Format.text]]
[IO.FS.instBEqFileType,[BEq.mk, BEq.beq, IO.FS.FileType.toCtorIdx]]
[Lean.Lsp.Range.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.Range.mk, Eq.symm, eq_of_heq, HEq.refl]]
[exacts,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat]]
[Lean.Core.mkFreshUserName,[Bind.bind, MonadState.modifyGet, Prod.mk, Lean.Core.State.nextMacroScope, Lean.Core.State.mk, Lean.Core.State.env, HAdd.hAdd, OfNat.ofNat, Lean.Core.State.ngen, Lean.Core.State.traceState, Lean.MonadEnv.getEnv, Pure.pure, Lean.addMacroScope, Lean.Environment.mainModule]]
[Lean.Macro.Exception.noConfusionType,[]]
[Lean.Meta.State.postponed,[]]
[Lean.Meta.throwLetTypeMismatchMessage,[Bind.bind, Lean.MonadLCtx.getLCtx, Option.none, Option.some, Lean.LocalDecl.cdecl, Lean.Meta.MetaM, Lean.LocalContext.find?, Lean.Meta.inferType, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Compiler.checkIsDefinition,[Unit.unit, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Except, String, Unit, Lean.Environment.find?, Except.ok, Except.error, HAppend.hAppend, ToString.toString]]
[Nat.fold,[Nat.foldAux]]
[Lean.Expr.hasLevelParamEx,[Lean.Expr.hasLevelParam]]
[Lean.Meta.AuxLemmas.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Bool.false.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.expandDeclSig,[Prod.mk, Lean.Syntax.getOp, OfNat.ofNat]]
[List.length_replicate.aux,[of_eq_true, Eq.trans, congrArg, Eq, List.length, congrFun, HAdd.hAdd, Nat.zero_eq, Nat.zero_add, eq_self, congr, List.cons, List.length_cons, Nat.add_succ, Nat.succ_add, Nat.succ]]
[Lean.Meta.ByCasesSubgoal.mk.inj,[And.intro]]
[Exists.nonempty,[Nonempty, Nonempty.intro]]
[Array.zipWith,[Array.zipWithAux, OfNat.ofNat, List.toArray, List.nil]]
[Lean.Lsp.TextDocumentItem.text,[]]
[Lean.Meta.simpTarget,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.simpTargetCore]]
[Lean.Meta.NormNum.instLawfulOfNat.proof_1,[Lean.Meta.NormNum.LawfulOfNat.mk, rfl]]
[Nat.coprime.coprime_mul_left_right,[Nat.coprime.coprime_dvd_right, Nat.dvd_mul_left]]
[IO.Error.noFileOrDirectory.inj,[And.intro]]
[Lean.MonadCache.noConfusionType,[]]
[Lean.SourceInfo.getPos?,[Lean.SourceInfo.synthetic, Bool.true, Lean.SourceInfo.none, Option, String.Pos, Option.some, Option.none]]
[Lean.Meta.CongrArgKind.heq.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.DefaultInstanceEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Name.hash.proof_1,[of_decide_eq_true, Eq.refl, Bool.true]]
[Subarray.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Subarray.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.DiagnosticTag.noConfusion,[noConfusionEnum, Lean.Lsp.DiagnosticTag.toCtorIdx]]
[List.head?,[Unit.unit, Option, Option.none, Option.some]]
[Lean.Meta.Split.splitMatch,[Bind.bind, Lean.Meta.matchMatcherApp?, Option.none, Lean.Meta.MetaM, List, Lean.MVarId, Lean.Meta.Match.getEquationsFor, Lean.Meta.MatcherApp.matcherName, Lean.Meta.Split.applyMatchSplitter, Lean.Meta.MatcherApp.matcherLevels, Lean.Meta.MatcherApp.params, Lean.Meta.MatcherApp.discrs, List.foldlM, Prod, Nat, Lean.Meta.withMVarContext, Lean.Meta.getMVarType, Lean.Meta.instantiateMVars, Lean.Meta.getCongrLemmas, Pure.pure, Lean.Meta.Simp.Context.mk, Lean.Meta.Simp.Config.mk, Bool.false, Lean.Meta.SimpLemmas.mk, Lean.Meta.Simp.main, Lean.Meta.Simp.Methods.mk, ite, Eq, Lean.Expr.isAppOf, Bool.true, liftM, Lean.Meta.reduceRecMatcher?, Unit.unit, Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step, Lean.Meta.Simp.Step.done, Lean.Meta.Simp.Result.mk, Lean.Meta.withReducible, Lean.Meta.Simp.tryLemma?, Lean.Meta.SimpLemma.mk, Lean.mkConst, List.nil, Option.some, Lean.Meta.SplitIf.discharge?, Lean.Meta.Simp.Step.visit, Lean.Meta.Simp.Result.proof?, Lean.Meta.replaceTargetEq, Lean.Meta.Simp.Result.expr, Lean.Meta.replaceTargetDefEq, Array.getOp, Lean.Meta.Match.MatchEqns.eqnNames, Prod.mk, HAdd.hAdd, OfNat.ofNat, List.cons, List.reverse, Lean.throwError, Lean.ToMessageData.toMessageData]]
[ST.Prim.Ref.modifyGet,[Bind.bind, ST.Prim.Ref.get, ST, ST.Prim.Ref.set, Pure.pure]]
[Lean.LocalDecl.type,[Lean.Expr]]
[Lean.Expr.ReplaceLevelImpl.State.mk.inj,[And.intro]]
[Lean.PrettyPrinter.Delaborator.isSimpleHOFun,[Bind.bind, Lean.PrettyPrinter.Delaborator.returnsPi, Lean.PrettyPrinter.Delaborator.isNonConstFun, Pure.pure, and, not]]
[Lean.Lsp.RpcRef.p,[]]
[Lean.Elab.Term.Do.Code.match.inj,[And.intro]]
[Lean.Lsp.ProgressParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.ProgressParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.typeSpec.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter]]
[ByteArray.size,[Nat, Array.size]]
[Lean.Elab.Command.openPrivate,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[Lean.Parser.ParserExtension.Entry.kind.inj,[]]
[UInt64.ofNat,[UInt64.mk, Fin.ofNat]]
[Lean.OpenDecl.simple.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instDecidableXor.proof_3,[Or.inr, And.intro]]
[Lean.MetavarContext.mkMetavarContext,[Lean.MetavarContext.mk]]
[Function.inv_fun_on_eq',[]]
[Lean.Meta.UnificationHints.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.UnificationHints.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Delaborator.unfoldMDatas,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Lean.Expr, PProd.fst]]
[Lean.Parser.eoiFn,[ite, Eq, String.atEnd, Lean.Parser.InputContext.input, Lean.Parser.ParserContext.toInputContext, Bool.true, Lean.Parser.ParserState.mkError]]
[Lean.Parser.Command.protected.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.instInhabitedFileMap,[Inhabited.mk, Lean.FileMap.mk, arbitrary]]
[Lean.Elab.Term.LetRecToLift.val,[]]
[bfix5,[PProd.fst]]
[Std.ShareCommonT.monadShareCommon,[Std.MonadShareCommon.mk, Std.ShareCommonT.withShareCommon]]
[Lean.mkConstEx,[Lean.mkConst]]
[Lean.KVMap.noConfusionType,[]]
[Lean.getPPMotivesAll,[Lean.KVMap.get, Lean.Option.name, Lean.pp.motives.all, Lean.Option.defValue]]
[Lean.Elab.Tactic.getUnsolvedGoals,[Bind.bind, Lean.Elab.Tactic.pruneSolvedGoals, Lean.Elab.Tactic.getGoals]]
[Lean.Elab.instInhabitedAttribute,[Inhabited.mk, Lean.Elab.Attribute.mk, arbitrary]]
[fixCore5,[bfix5, USize.size]]
[Lean.Parser.Command.catBehaviorSymbol.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.nonReservedSymbol.formatter, Bool.false]]
[USize.instCommRingUSize.proof_1,[USize.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, USize.val, USize.mul_def, CommSemiring.mul_comm]]
[Function.surjective.exists₃,[Iff.trans, Function.surjective.exists, exists_congr, Function.surjective.exists₂]]
[HDiv.hDiv,[]]
[CoeFun.coe,[]]
[Except.error.injEq,[Eq.propIntro, Eq.refl, Except.error, Eq.symm, eq_of_heq, HEq.refl]]
[List.mem_bind,[Eq.mpr, congrFun, congrArg, Iff, Eq.trans, propext, List.mem_join, Exists, funext, And, List.mem_map, Mem.mem, Iff.intro, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Exists.intro, And.intro, Eq, rfl]]
[Std.HashMapImp.noConfusionType,[]]
[Lean.PrettyPrinter.formatTactic,[Lean.PrettyPrinter.format, Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous]]
[Nat.gcd_eq_right_iff_dvd,[Eq.mpr, Eq.refl, Iff, Dvd.dvd, Eq, Nat.gcd, Nat.gcd_comm, Nat.gcd_eq_left_iff_dvd]]
[le_of_not_gt,[le_of_not_lt]]
[ReaderT.tryFinally,[MonadFinally.mk, MonadFinally.tryFinally']]
[Lean.registerAttributeImplBuilder,[Bind.bind, ST.Ref.get, Lean.attributeImplBuilderTableRef, ite, Eq, Std.HashMap.contains, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Pure.pure, PUnit.unit]]
[Lean.SCC.Data.noConfusionType,[]]
[Lean.Compiler.InlineAttributeKind.noConfusionType,[noConfusionTypeEnum, Lean.Compiler.InlineAttributeKind.toCtorIdx]]
[Lean.Elab.InfoTree.node.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, congrFun, congr, Eq.symm, Std.PersistentArrayNode.node.sizeOf_spec, Eq.refl, List.nil, List.cons.sizeOf_spec, Array.mk.sizeOf_spec, Std.PersistentArrayNode.leaf.sizeOf_spec, Std.PersistentArray.mk.sizeOf_spec]]
[Lean.IR.instToFormatIRType,[Std.ToFormat.mk]]
[Lean.PrettyPrinter.Delaborator.SubExpr.maxChildren,[OfNat.ofNat]]
[Lean.IR.Expr.unbox.inj,[]]
[Lean.IR.UnreachableBranches.InterpState.noConfusionType,[]]
[Lean.Meta.Simp.Config.decide,[]]
[Lean.Lsp.instFromJsonDocumentSymbolParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Pure.pure, Lean.Lsp.DocumentSymbolParams.mk]]
[instHDiv,[HDiv.mk, Div.div]]
[Lean.Meta.addDefaultInstance,[Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.Meta.MetaM, Unit, Lean.Environment.find?, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.forallTelescopeReducing, Lean.ConstantInfo.type, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr.getAppFn, ite, Eq, Lean.isClass, Bool.true, Pure.pure, PUnit.unit]]
[Lean.Parser.Attr.ancestor,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[Lean.Elab.Term.tryPostponeIfNoneOrMVar,[Unit.unit, Lean.Elab.Term.TermElabM, Unit, Lean.Elab.Term.tryPostponeIfMVar, Lean.Elab.Term.tryPostpone]]
[Lean.Lsp.InitializeParams.trace,[]]
[coeOfHTCT,[CoeT.mk, CoeHTCT.coe]]
[UInt32.instAddSemigroupUInt32,[AddSemigroup.mk, UInt32.instAddSemigroupUInt32.proof_1]]
[Lean.PrettyPrinter.Delaborator.shouldShowMotive,[Bind.bind, andM, Pure.pure, Lean.getPPMotivesPi, Lean.PrettyPrinter.Delaborator.returnsPi, Lean.getPPMotivesNonConst, Lean.PrettyPrinter.Delaborator.isNonConstFun, orM, Lean.getPPMotivesAll]]
[IO.FS.Stream.writeLspNotification,[IO.FS.Stream.writeLspMessage, Lean.JsonRpc.Message.notification, Lean.JsonRpc.Notification.method, Except.toOption, Lean.Json.toStructured?, Lean.JsonRpc.Notification.param]]
[Function.inv_fun_neg,[Function.inv_fun_on_neg, mt, Exists, Eq, Exists.intro]]
[Lean.Lsp.InitializeResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.mem_append_eq,[propext, List.mem_append]]
[Lean.Meta.Simp.State.numSteps,[]]
[Lean.Elab.Deriving.BEq.mkMatch.mkAlts,[Bind.bind, ForIn.forIn, Lean.getConstInfoCtor, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, liftM, Lean.Core.betaReduce, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, PUnit.unit, ForInStep.yield, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, MProd.mk, Lean.Elab.Term.TermElabM, Lean.Syntax, ite, Eq, Lean.Expr.containsFVar, Lean.Expr.fvarId!, Bool.true, Lean.Core.mkFreshUserName, Lean.Meta.inferType, Lean.Expr.isAppOf, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Lean.mkIdent, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.Elab.Deriving.BEq.mkMatch.mkElseAlt]]
[Lean.Elab.Tactic.Conv.evalChange,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Tactic.Conv.getLhs, Lean.MonadMCtx.getMCtx, liftM, Lean.Meta.inferType, Lean.Elab.Tactic.elabTermEnsuringType, Option.some, Bool.false, Lean.Meta.getMVars, Lean.Elab.Tactic.filterOldMVars, Lean.Elab.Tactic.logUnassignedAndAbort, Lean.Meta.isDefEqGuarded, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Elab.throwUnsupportedSyntax]]
[List.card_cons_of_mem,[Eq.mpr, Eq.refl, Eq, ite, Mem.mem, List.card, HAdd.hAdd, OfNat.ofNat, if_pos, rfl]]
[Lean.Parser.Tactic.seq1,[Lean.Parser.node, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.sepBy1, Lean.Parser.tacticParser, OfNat.ofNat, Lean.Parser.symbol, Bool.true]]
[Lean.Meta.UnificationHints.mk.inj,[]]
[Lean.Parser.Tactic.withReducible,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Lean.Meta.ReduceMatcherResult.reduced.inj,[]]
[Lean.Parser.Term.termPquoteₓ_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Int.neg_eq_neg_one_mul,[Unit.unit, Eq, Neg.neg, HMul.hMul, OfNat.ofNat, rfl]]
[Lean.Meta.DefaultInstanceEntry.noConfusionType,[]]
[Lean.IR.CollectUsedDecls.collect,[modify, Lean.NameSet.insert]]
[Lean.Parser.Tactic.Conv.convIntro___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[Lean.throwUnknownConstant,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkConst, List.nil]]
[Nat.decEq,[Decidable, Eq, Nat.beq, Nat.decEq.proof_1, Decidable.isTrue, Nat.eq_of_beq_eq_true, Decidable.isFalse, Nat.ne_of_beq_eq_false]]
[Lean.SCC.State.sccs,[]]
[IO.FS.SystemTime.mk.inj,[And.intro]]
[Lean.MonadResolveName.noConfusionType,[]]
[Lean.Meta.collectUsedFVarsAtFVars,[Array.forM, Bind.bind, liftM, Lean.Meta.inferType, Lean.Meta.collectUsedFVars, OfNat.ofNat, Array.size]]
[Lean.Parser.ParserContext.prec,[]]
[Lean.ConstantInfo.defnInfo.inj,[]]
[Lean.Meta.SynthInstance.SubgoalsResult.noConfusionType,[]]
[Lean.setReducibilityStatusImp,[Except.error, Lean.Environment, Lean.EnumAttributes.setValue, Lean.reducibilityAttrs]]
[Numeric.OfNat,[OfNat.mk, Numeric.ofNat]]
[Lean.DefinitionVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Thunk.get,[Unit.unit]]
[Subarray.h₁,[]]
[Lean.Elab.Command.instMonadQuotationCommandElabM,[Lean.MonadQuotation.mk, Lean.Elab.Command.getCurrMacroScope, Lean.Elab.Command.getMainModule, Lean.Elab.Command.withFreshMacroScope]]
[Lean.Parser.Syntax.numPrec.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.numLit.formatter]]
[Classical.propDecidable.proof_1,[Nonempty, Decidable, Classical.em, Nonempty.intro, Decidable.isTrue, Decidable.isFalse]]
[Lean.Parser.Tactic.revertDeps,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const]]
[Lean.Parser.Command.unsafe,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Lean.Parser.Term.doIfProp.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.optIdent.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Bool.false]]
[Lean.Lsp.InitializationOptions.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.InitializationOptions.mk, Eq.symm, eq_of_heq, HEq.refl]]
[List.minimum?,[Unit.unit, Option, Option.none, Option.some, List.foldl, min]]
[Nat.gcd_eq_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, Nat.gcd_comm, Nat.gcd_eq_left, rfl]]
[Lean.SCC.scc,[List, List.reverse, Lean.SCC.State.sccs]]
[Lean.Lsp.SemanticTokensParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.SemanticTokensParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[IO.Error.resourceBusy.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.resourceBusy, Eq.symm, eq_of_heq, HEq.refl]]
[instSemigroupFin.proof_1,[Fin.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, Fin.val, Eq.trans, congrFun, HMul.hMul, Fin.mul_def, Fin.mk, HMod.hMod, Nat.mod_lt, Fin.size_positive, Eq.refl, Eq.symm, Eq.mp, Nat.mul_mod, Nat.mod_eq_of_lt, Fin.isLt, Nat.mul_assoc, rfl]]
[instDecidablePredComp,[inferInstanceAs, DecidablePred]]
[Lean.Elab.Tactic.State.noConfusionType,[]]
[coeOfTCOfTail,[CoeHTCT.mk, coeTail, coeTC]]
[TC.wf,[TC.wf.proof_1]]
[Function.surjective.forall₃,[Iff.trans, Function.surjective.forall, forall_congr', Function.surjective.forall₂]]
[Tactic.Ring.horner,[HAdd.hAdd, HMul.hMul, HPow.hPow]]
[Lean.Meta.DiscrTree.Trie.ibelow,[And, True]]
[PNonScalar.noConfusionType,[]]
[Lean.Parser.Attr.class.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.Lsp.instFileSourceDeclarationParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.DeclarationParams.toTextDocumentPositionParams]]
[Lean.ModuleData.entries,[]]
[Lean.Server.Snapshots.Snapshot.mpState,[]]
[Lean.Lsp.LeanFileProgressProcessingInfo.range,[]]
[Lean.Meta.Config.transparency,[]]
[Lean.Elab.DefView.deriving?,[]]
[Lean.instQuoteArray,[Lean.Quote.mk, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Quote.quote, Array.toList, List.nil]]
[Lean.Parser.Term.scientific.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.scientificLit.formatter]]
[Lean.Meta.CasesSubgoal.toInductionSubgoal,[]]
[Lean.instCoeNameDataValue,[Coe.mk, Lean.DataValue.ofName]]
[Lean.Meta.reduceProj?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Meta.MetaM, Option, Lean.Expr, Lean.Meta.project?, Pure.pure, Option.none]]
[IO.FS.Stream.getLine,[]]
[Lean.Parser.Tactic.quotSeq.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.Tactic.seq1.formatter]]
[MProd.fst,[]]
[UInt8.instCommRingUInt8.proof_1,[UInt8.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, UInt8.val, UInt8.mul_def, CommSemiring.mul_comm]]
[Prod.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.InitializeResult.serverInfo?,[]]
[Lean.Elab.instToStringModifiers,[ToString.mk, Function.comp, ToString.toString, Std.ToFormat.format]]
[Lean.Lsp.DidCloseTextDocumentParams.mk.inj,[]]
[Lean.Elab.headerToImports,[HAppend.hAppend, List.map, Lean.Import.mk, Array.toList, Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat]]
[timeCmd,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Lsp.Location.range,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.withKnowing,[MonadWithReader.withReader, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.inBottomUp, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.parentIsApp, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.subExpr]]
[Lean.Parser.Term.doIfProp,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.Term.optIdent, Lean.Parser.termParser, OfNat.ofNat, Bool.false]]
[Lean.Elab.Term.TermElabM.toIO,[Bind.bind, Lean.Meta.MetaM.toIO, Lean.Elab.Term.TermElabM.run, IO, Prod, Lean.Core.State, Lean.Meta.State, Lean.Elab.Term.State, Pure.pure, Prod.mk]]
[Lean.Xml.Parser.hexDigitToNat,[ite, And, LE.le, Char.ofNat, HSub.hSub, Char.toNat, HAdd.hAdd, OfNat.ofNat]]
[IO.Error.illegalOperation.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Xml.Parser.Attribute,[Bind.bind, Lean.Xml.Parser.Name, Lean.Xml.Parser.Eq, Lean.Xml.Parser.AttValue, Pure.pure, Prod.mk]]
[Lean.Parser.Command.extends,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.sepBy1, Lean.Parser.termParser, Bool.false]]
[Lean.Core.withCurrHeartbeats,[controlAt, Lean.Core.CoreM, Bind.bind, liftM, IO.getNumHeartbeats, MonadWithReader.withReader, Lean.Core.Context.mk, Lean.Core.Context.options, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.maxHeartbeats]]
[Lean.initSearchPath,[Bind.bind, Lean.getBuiltinSearchPath, Lean.addSearchPathFromEnv, ST.Ref.set, Lean.searchPathRef]]
[AddCommSemigroup.add_comm,[]]
[Lean.Elab.Tactic.evalFirst,[ite, Eq, Array.isEmpty, Bool.true, Bind.bind, Lean.Elab.throwUnsupportedSyntax, Pure.pure, PUnit.unit, Lean.Elab.Tactic.evalFirst.loop]]
[Lean.Elab.PreDefinition.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.FileMap.leanPosToLspPos,[Lean.Lsp.Position, Lean.Lsp.Position.mk, HSub.hSub, OfNat.ofNat, String.codepointPosToUtf16PosFrom, Lean.FileMap.source, Array.get!, Lean.FileMap.positions]]
[Lean.Parser.Command.partial.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Nat.le_of_ble_eq_true,[Eq.refl, Bool.true, HEq.refl, LE.le, Nat.zero_le, Nat.succ_le_succ, PProd.fst]]
[Lean.Expr.getArgD,[Lean.Expr.getRevArgD, HSub.hSub, OfNat.ofNat]]
[Int.decEq.proof_4,[absurd]]
[StateT.ext,[funext]]
[UInt8.mul,[UInt8.mk, HMul.hMul, UInt8.val]]
[IO.Error.instToStringError,[ToString.mk, IO.Error.toString]]
[Lean.KeyedDeclsAttribute.OLeanEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[MonadStateOf.noConfusionType,[]]
[Lean.mkFreshFVarId,[Bind.bind, Lean.mkFreshId, Pure.pure, Lean.FVarId.mk]]
[LawfulMonad.toLawfulApplicative,[]]
[Lean.MessageData.withContext.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MessageData.withContext, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.KeyedDeclsAttribute.Def.descr,[]]
[Lean.IR.logMessageIf,[Bind.bind, MonadReader.read, ite, Eq, Option.none, Option.some, Lean.DataValue.ofString, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Bool, Lean.KVMap.find, Lean.KVMap.getBool, Lean.IR.tracePrefixOptionName, Bool.false, Bool.true, Lean.IR.log, Lean.IR.LogEntry.message, Std.ToFormat.format, Pure.pure, PUnit.unit, HAppend.hAppend]]
[RandomGen.next,[]]
[Lean.IR.checkDecls,[Array.forM, Lean.IR.checkDecl, OfNat.ofNat, Array.size]]
[Lean.KernelException.exprTypeMismatch.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.Watchdog.findFileWorker!,[Bind.bind, Lean.Server.Watchdog.findFileWorker?, Option.none, Lean.Server.Watchdog.ServerM, Lean.Server.Watchdog.FileWorker, Pure.pure, liftM, IO.throwServerError, HAppend.hAppend, ToString.toString]]
[Lean.Parser.Tactic.Conv.nestedTactic,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Lean.Elab.withInfoContext',[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, ite, Eq, Lean.Elab.InfoState.enabled, Bool.true, Lean.Elab.getResetInfoTrees, Functor.map, Prod.fst, MonadFinally.tryFinally', Unit.unit, Unit, Lean.Elab.MonadInfoTree.modifyInfoState, Lean.Elab.InfoState.mk, Lean.Elab.InfoState.assignment, Lean.Elab.InfoState.trees, Std.PersistentArray, Lean.Elab.InfoTree, Std.PersistentArray.push, Lean.Elab.InfoTree.node, Lean.Elab.InfoTree.hole]]
[Lean.Name.lt,[BEq.beq, Lean.Name.cmp, Ordering.lt]]
[Lean.Elab.isValidAutoBoundImplicitName,[Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Bool, and, Decidable.decide, GT.gt, String.length, OfNat.ofNat, or, Lean.isGreek, String.getOp, Char.isLower, Substring.all, Substring.drop, String.toSubstring, Char.isDigit, Lean.isSubScriptAlnum, BEq.beq, Char.ofNat, Bool.false]]
[Lean.Elab.Command.StructCtorView.inferMod,[]]
[Lean.Elab.Tactic.ElimApp.State.f,[]]
[List.map_singleton,[rfl]]
[instTransEq_1.proof_1,[]]
[String.offsetOfPos,[String.offsetOfPosAux, OfNat.ofNat]]
[Lean.Widget.InteractiveHypothesis.isType,[]]
[Lean.Parser.Tactic.Conv.slice,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Lean.Environment.const2ModIdx,[]]
[Lean.IR.ExplicitBoxing.BoxingState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.IRType.ibelow,[True, And]]
[Lean.Json.arr.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.trans, Eq.refl, SizeOf.sizeOf, List.nil, HAdd.hAdd, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec]]
[Lean.Meta.TransparencyMode.toCtorIdx,[OfNat.ofNat]]
[Lean.Lsp.StaticRegistrationOptions.noConfusionType,[]]
[Lean.EnvExtension.instInhabitedEnvExtension,[Lean.EnvExtensionInterface.inhabitedExt, Lean.EnvExtensionInterfaceImp]]
[Lean.Meta.RewriteResult.mvarIds,[]]
[Lean.ParserCompiler.compileEmbeddedParsers,[Lean.Meta.MetaM, Unit, Pure.pure, Unit.unit, PProd.fst, SeqRight.seqRight, PProd.snd, Functor.discard, Lean.ParserCompiler.compileParserExpr, Bool.false, Lean.mkConst, List.nil]]
[Lean.Meta.IndPredBelow.proveBrecOn,[Bind.bind, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Name.anonymous, Lean.Expr.mvarId!, Lean.Meta.MetaM, Lean.Expr, List.nil, List.cons, Lean.MonadOptions.getOptions, List.forM, Lean.Meta.instantiateMVars, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Meta.IndPredBelow.proveBrecOn.intros, Lean.Meta.IndPredBelow.proveBrecOn.applyIH, Lean.Meta.IndPredBelow.proveBrecOn.induction, Lean.Meta.IndPredBelow.proveBrecOn.applyCtors, Lean.Meta.IndPredBelow.proveBrecOn.introNPRec, Lean.Meta.IndPredBelow.proveBrecOn.closeGoal]]
[Lean.instReprSMap,[Repr.mk, Repr.addAppParen, HAppend.hAppend, reprArg, Lean.SMap.toList, Std.Format.text]]
[Lean.Parser.Tactic.obtain,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.rcasesPatMed, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy1]]
[Std.Format.defIndent,[OfNat.ofNat]]
[Lean.Meta.getTheoremInfo,[Bind.bind, Lean.Meta.shouldReduceAll, ite, Eq, Bool.true, Pure.pure, Option.some, Option.none]]
[Lean.Elab.Command.liftCoreM,[Bind.bind, MonadState.get, MonadReader.read, liftM, IO.getNumHeartbeats, Lean.Elab.Command.CommandElabM, modify, Lean.Elab.Command.State.mk, Lean.Core.State.env, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Core.State.ngen, Lean.Elab.Command.State.infoState, Lean.Core.State.traceState, Pure.pure, MonadExcept.throw]]
[Lean.Elab.MacroExpansionInfo.output,[]]
[Lean.Meta.SizeOfSpecNested.Context.params,[]]
[Lean.KVMap.instValueName,[Lean.KVMap.Value.mk, Lean.DataValue.ofName, Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Option, Lean.Name, Option.some, Option.none]]
[UInt64.instInhabitedFinSize,[Inhabited.mk, Fin.ofNat', OfNat.ofNat, UInt64.size_positive]]
[Nat.pow_succ,[rfl]]
[Lean.Lsp.WorkDoneProgressReport.cancellable,[]]
[Lean.PrettyPrinter.Parenthesizer.checkLineEq.parenthesizer,[Pure.pure, Unit.unit]]
[Lean.Parser.Tactic.dsimp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.IR.mkVarJPMaps,[Lean.IR.CollectMaps.collectDecl, Prod.mk, EmptyCollection.emptyCollection]]
[Lean.Elab.Command.CollectAxioms.M,[ReaderT, Lean.Environment, StateM, Lean.Elab.Command.CollectAxioms.State]]
[not_and_of_not_left,[mt, And.left]]
[Lean.Parser.Error.mk.inj,[And.intro]]
[Lean.Meta.simpIfLocalDecl,[Bind.bind, Lean.Meta.SplitIf.getSimpContext, Lean.Meta.simpLocalDecl, Option.some, Lean.Meta.SplitIf.discharge?, Bool.false, Option.none, Lean.Meta.MetaM, Lean.MVarId, Pure.pure, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Meta.Match.Alt.patterns,[]]
[EIO,[EStateM, IO.RealWorld]]
[Lean.Lsp.instFromJsonPlainGoal,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, String, Array, Pure.pure, Lean.Lsp.PlainGoal.mk]]
[Lean.Name.getRoot,[Unit.unit, Lean.Name.str, Lean.Name.anonymous, Lean.Name.num, Lean.Name, PProd.fst]]
[Lean.IR.Borrow.preserveTailCall,[Bind.bind, MonadReader.read, Lean.IR.Expr.ctor, Lean.IR.Expr.reset, Lean.IR.Expr.reuse, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.fap, Lean.IR.FnBody.vdecl, Lean.IR.FnBody.jdecl, Lean.IR.FnBody.set, Lean.IR.FnBody.setTag, Lean.IR.FnBody.uset, Lean.IR.FnBody.sset, Lean.IR.FnBody.inc, Lean.IR.FnBody.dec, Lean.IR.FnBody.del, Lean.IR.FnBody.mdata, Lean.IR.FnBody.case, Lean.IR.FnBody.ret, Lean.IR.Arg.irrelevant, Lean.IR.FnBody.jmp, Lean.IR.FnBody.unreachable, Lean.IR.Expr.pap, Lean.IR.Expr.ap, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Lean.IR.Borrow.M, Unit, ite, Eq, and, Array.any, Lean.IR.Borrow.BorrowInfCtx.decls, BEq.beq, Lean.IR.Decl.name, OfNat.ofNat, Array.size, Bool.true, Lean.IR.Borrow.getParamInfo, Lean.IR.Borrow.ParamMap.Key.decl, Lean.IR.Borrow.ownParamsUsingArgs, Pure.pure, PUnit.unit, Unit.unit]]
[Lean.Elab.Term.Quotation.HeadCheck.shape.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.Watchdog.WorkerEvent.processGroupedEdits.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Lsp.VersionedTextDocumentIdentifier.mk.inj,[And.intro]]
[Lean.Elab.Term.Arg.stx.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.Arg.stx, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Match.Alt.fvarDecls,[]]
[Lean.Parser.Tactic.applyField,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Nat.mul_eq,[rfl]]
[StateT.run_get,[rfl]]
[FloatArray.foldlM.loop.proof_1,[Nat.lt_of_lt_of_le]]
[Lean.Meta.caseValues,[OfNat.ofNat, Array.toList, List.toArray, List.nil, Lean.Meta.caseValues.loop]]
[List.isInfix,[Exists, Eq, HAppend.hAppend]]
[Lean.Meta.Rewrite.Config.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Rewrite.Config.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Expr.and?,[Lean.Expr.app2?, Lean.Name.mkStr, Lean.Name.anonymous]]
[Iff.elim_left,[Iff.elim_left.proof_1]]
[ReaderT.instLawfulMonadReaderT,[ReaderT.instLawfulMonadReaderT.proof_1]]
[Lean.Meta.liftMkBindingM,[Bind.bind, Lean.MonadLCtx.getLCtx, Lean.MonadMCtx.getMCtx, Lean.MonadNameGenerator.getNGen, Lean.Meta.MetaM, Lean.MetavarContext.MkBinding.State.mk, Lean.MonadNameGenerator.setNGen, Lean.MetavarContext.MkBinding.State.ngen, Lean.Meta.setMCtx, Lean.MetavarContext.MkBinding.State.mctx, Pure.pure, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.Export.OfState.modify,[]]
[Lean.Meta.approxDefEq,[Lean.Meta.mapMetaM, Lean.Meta.withConfig, Lean.Meta.Config.mk, Bool.true, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct]]
[Lean.Xml.Parser.DefaultDecl,[HOrElse.hOrElse, Lean.Parsec.skipString, SeqRight.seqRight, optional, SeqLeft.seqLeft, Lean.Xml.Parser.S, Lean.Xml.Parser.AttValue, Pure.pure, Unit.unit]]
[Lean.Elab.elabSetOption,[Bind.bind, Lean.MonadRef.getRef, Lean.Elab.addCompletionInfo, Lean.Elab.CompletionInfo.option, Lean.Syntax.setArgs, Array.ofSubarray, Array.toSubarray, Lean.Syntax.getArgs, OfNat.ofNat, Unit.unit, Lean.Options, Lean.Syntax.isStrLit?, Lean.DataValue.ofString, Lean.Syntax.isNatLit?, Lean.DataValue.ofNat, Lean.Syntax.missing, Lean.Syntax.node, dite, Eq, Eq.symm, Lean.Syntax.atom, Lean.Syntax.ident, Lean.DataValue.ofBool, Bool.true, Bool.false, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.elabSetOption.setOption]]
[Lean.IR.EmitC.emitExternDeclAux,[Bind.bind, Lean.IR.EmitC.getEnv, Lean.IR.EmitC.emitFnDeclAux]]
[«term_$__»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Lean.Elab.Term.MVarErrorKind.implicitArg.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Fin.shiftLeft.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[Lean.Meta.instantiateLevelMVars,[Lean.MetavarContext.instantiateLevelMVars]]
[Nat.zero_le,[Unit.unit, LE.le, OfNat.ofNat, Nat.le.refl, Nat.le.step, PProd.fst]]
[IO.Error.userError.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Match.Pattern.var.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instComplementUInt32,[Complement.mk, UInt32.complement]]
[Lean.IR.Param.noConfusionType,[]]
[Std.PersistentArrayNode.below,[PProd, PUnit]]
[Lean.AttributeImplCore.noConfusionType,[]]
[Lean.Elab.Tactic.getMainTarget,[Bind.bind, Lean.Elab.Tactic.getMainDecl, liftM, Lean.Meta.instantiateMVars, Lean.MetavarDecl.type]]
[Lean.Xml.Parser.intSubset,[SeqRight.seqRight, Lean.Parsec.many, HOrElse.hOrElse, Lean.Xml.Parser.markupDecl, Lean.Xml.Parser.DeclSep, Pure.pure, Unit.unit]]
[Lean.Meta.Simp.Step.done.inj,[]]
[Lean.FileMap.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.cdot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.symbol.parenthesizer]]
[Task.Priority.default,[OfNat.ofNat]]
[Nat.log2,[WellFounded.fix, Nat.log2.proof_1, dite, GE.ge, OfNat.ofNat, HAdd.hAdd, HDiv.hDiv, Eq.refl, Nat.zero, HEq.refl, absurd, of_decide_eq_false, Decidable.decide, Nat.succ, LT.lt, of_decide_eq_true, Bool.true, Eq.mpr, Nat.div_eq, ite, And, LE.le, HSub.hSub, if_pos, And.intro, Nat.succ_lt_succ, Nat.zero_lt_succ, Nat.lt_trans, PProd.fst, PProd.snd, Nat.lt_succ_self]]
[Lean.PersistentEnvExtensionState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PersistentEnvExtensionState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Do.JPDecl.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.JPDecl.mk, Eq.symm, eq_of_heq, HEq.refl]]
[hasOfNatOfCoe,[OfNat.mk, coe, OfNat.ofNat]]
[Lean.Expr.hasSyntheticSorry,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lit, Bool, or, Lean.Expr.isSyntheticSorry, PProd.fst, PProd.snd, Bool.false]]
[Lean.Widget.InteractiveTermGoal.toInteractiveGoal,[Lean.Widget.InteractiveGoal.mk, Lean.Widget.InteractiveTermGoal.hyps, Lean.Widget.InteractiveTermGoal.type, Option.none]]
[UInt32.instSemiringUInt32.proof_7,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt32.one_def, UInt32.mul_def, UInt32.mk, OfNat.ofNat, one_mul, UInt32.val, UInt32.mk_val_eq, eq_self, propext, forall_const, UInt32]]
[Lean.Elab.Level.Context.options,[]]
[Subtype.ext_iff_val,[Subtype.ext_iff]]
[Lean.Elab.Tactic.evalApply,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Tactic.evalApplyLikeTactic, Lean.Meta.apply, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Lsp.MarkupContent.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Level.instantiateParams,[Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Level, ite, Eq, Lean.Level.hasParam, Bool.true, Lean.Level.updateSucc!, PProd.fst, Lean.Level.updateMax!, PProd.snd, Lean.Level.updateIMax!, Unit.unit]]
[Lean.mkFVarEx,[Lean.mkFVar]]
[instHAppend,[HAppend.mk, Append.append]]
[Lean.Elab.Term.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.InfoState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.InfoState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.CollectPatternVars.Context.mk.inj,[And.intro]]
[Lean.Lsp.instToJsonInitializationOptions,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Lsp.InitializationOptions.editDelay?, List.nil]]
[Lean.Elab.Term.ElabAppArgs.State.ellipsis,[]]
[Lean.Lsp.Command.command,[]]
[Lean.Elab.GoalsAtResult.useAfter,[]]
[Lean.Elab.elabDeriving,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Unit.unit, Lean.Elab.Command.CommandElabM, Unit, OptionM.run, Array.sequenceMap, Array.getSepElems, Lean.Syntax.getArgs, Lean.Syntax.isNone, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Bind.bind, Array.mapM, Lean.Elab.resolveGlobalConstNoOverloadWithInfo, ForIn.forIn, ForInStep, Subarray, Option, Lean.Syntax, Stream.next?, Pure.pure, ForInStep.done, MonadExcept.tryCatch, Lean.withRef, and, BEq.beq, Array.size, Option.isNone, Lean.Elab.Command.liftTermElabM, Lean.Elab.Term.processDefDeriving, Array.getOp, PUnit.unit, Lean.Elab.logException, ForInStep.yield, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Parser.Tactic.itauto,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[List.card_cons_of_not_mem,[Eq.mpr, Eq.refl, Eq, ite, Mem.mem, List.card, HAdd.hAdd, OfNat.ofNat, if_neg, rfl]]
[Lean.Elab.Structural.RecArgInfo.indPred,[]]
[Lean.ToMessageData.toMessageData,[]]
[List.cons_ne_self,[mt, congr_arg, List.length', Nat.succ_ne_self]]
[Lean.Elab.Term.Do.attachJPs,[Array.foldr, Lean.Elab.Term.Do.attachJP, Array.size, OfNat.ofNat]]
[Decidable.iff_iff_and_or_not_and_not,[Iff.intro, Eq.mpr, Eq.refl, Or, And, Not, propext, Decidable.em, Or.inl, And.intro, Eq.symm, Or.inr, Iff, And.right, And.left, False.elim]]
[String.toAsciiByteArray.loop.proof_1,[Nat.Up.WF, String.utf8ByteSize]]
[MonadLift.noConfusionType,[]]
[Prod.swap_swap_eq,[funext, Prod.swap_swap]]
[Lean.Elab.Structural.EqnsExtState.mk.inj,[]]
[Decidable.of_not_imp,[Decidable.by_contradiction, not_not_of_not_imp]]
[UInt32.mod_def,[rfl]]
[Lean.Parser.checkNoWsBeforeFn,[ite, Eq, Lean.Parser.checkTailNoWs, Bool.true, Lean.Parser.ParserState.mkError]]
[String.toUpper,[String.map, Char.toUpper]]
[Lean.Parser.Term.subst,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.sepBy1, Lean.Parser.termParser, Bool.false]]
[Lean.Elab.Tactic.Conv.evalConvSeqBracketed,[Bind.bind, Lean.Elab.Tactic.mkInitialTacticInfo, Lean.Syntax.getOp, OfNat.ofNat, Lean.withRef, Lean.Elab.Tactic.closeUsingOrAdmit, Lean.Elab.withInfoContext, Pure.pure, Unit.unit, Lean.Elab.Tactic.evalManyTacticOptSemi, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Elab.Tactic.evalTactic]]
[Lean.Lsp.DocumentSymbolAux.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.LetRecDeclView.type,[]]
[Lean.SMap.forM,[Bind.bind, Std.HashMap.forM, Lean.SMap.map₁, Std.PersistentHashMap.forM, Lean.SMap.map₂]]
[Std.RBNode.leaf.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Syntax.getPos?,[Lean.SourceInfo.getPos?, Lean.Syntax.getHeadInfo]]
[Equiv.instCoeFunEquivArrow,[CoeFun.mk, Equiv.toFun]]
[Lean.Meta.Hypothesis.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Hypothesis.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Compiler.voidType,[Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Lean.Exception.internal.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.rename,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Lean.Parser.Tactic.Conv.convRw__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq]]
[decidableOfDecidableOfIff.proof_1,[absurd, Iff.mpr]]
[Lean.Parser.Tactic.locationWildcard,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol]]
[Lean.Lsp.instFileSourceTextDocumentEdit,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.TextDocumentEdit.textDocument]]
[Or.resolve_right,[Or.elim, id, absurd]]
[Lean.Parser.Command.derivingClasses,[Lean.Parser.sepBy1, Lean.Parser.group, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.symbol, Lean.Parser.Term.structInst, Bool.false]]
[IO.FS.writeFile,[Bind.bind, IO.FS.Handle.mk, IO.FS.Mode.write, Bool.false, IO.FS.Handle.putStr]]
[CoeFun.noConfusionType,[]]
[Lean.Meta.SizeOfSpecNested.Context.mk.inj,[And.intro]]
[Lean.IR.Checker.checkVarType,[Bind.bind, Lean.IR.Checker.getType, Lean.IR.Checker.checkType]]
[Lean.Level.updateMax!,[Lean.Level.zero, Lean.Level.succ, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Level, Lean.Level.updateMax, Lean.Level.max, Lean.Level.updateMax!.proof_1, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.ModuleData.noConfusionType,[]]
[Lean.Parser.Term.funStrictImplicitBinder.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.lookahead.formatter, Lean.Parser.Term.strictImplicitLeftBracket.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.strictImplicitRightBracket.formatter, Lean.Parser.Term.strictImplicitBinder.formatter, Bool.false]]
[Lean.getOptionDeclsArray,[Bind.bind, Lean.getOptionDecls, Pure.pure, Std.RBMap.fold, Array.push, Prod.mk, List.toArray, List.nil]]
[Lean.Elab.Term.resolveLocalName.loop,[Unit.unit, Option, Prod, Lean.Expr, List, String, Lean.LocalContext.findFromUserName?, Lean.MacroScopesView.review, Lean.MacroScopesView.mk, Lean.MacroScopesView.imported, Lean.MacroScopesView.mainModule, Lean.MacroScopesView.scopes, ite, Eq, and, Lean.LocalDecl.isAuxDecl, not, List.isEmpty, Bool.true, Option.none, Option.some, Prod.mk, Lean.LocalDecl.toExpr, Lean.Name.anonymous, Lean.Name.num, PProd.fst, List.cons]]
[Except.mapError,[Except, Except.error, Except.ok]]
[List.forIn_nil,[rfl]]
[Lean.ClassState.mk.inj,[]]
[Lean.PrettyPrinter.Delaborator.ParamKind.noConfusionType,[]]
[Lean.IR.ExplicitBoxing.castArgsIfNeeded,[Bind.bind, Lean.IR.ExplicitBoxing.castArgsIfNeededAux, Lean.IR.Param.ty, Array.getOp, Lean.IR.ExplicitBoxing.M, Lean.IR.FnBody, Pure.pure, Lean.IR.reshape]]
[Lean.Elab.Term.Do.hasBreakContinueReturn,[Lean.Elab.Term.Do.hasExitPointPred, Lean.Elab.Term.Do.Code.decl, Lean.Elab.Term.Do.Code.reassign, Lean.Elab.Term.Do.Code.joinpoint, Lean.Elab.Term.Do.Code.seq, Lean.Elab.Term.Do.Code.action, Lean.Elab.Term.Do.Code.ite, Lean.Elab.Term.Do.Code.match, Lean.Elab.Term.Do.Code.jmp, Bool, Bool.true, Bool.false]]
[ltOfOrd,[LT.mk, Eq, BEq.beq, Ord.compare, Ordering.lt, Bool.true]]
[Xor.noConfusionType,[]]
[Lean.Parser.ParserExtension.addEntryImpl,[Lean.Parser.ParserExtension.State, Except.error, ite, Eq, BEq.beq, Bool.true, MonadExcept.throw, Unit.unit, Except, String, Lean.Parser.TokenTable, Lean.Parser.Trie.find?, Pure.pure, Lean.Parser.Trie.insert, Lean.Parser.ParserExtension.State.tokens, Lean.Parser.ParserExtension.State.mk, Lean.Parser.ParserExtension.State.kinds, Lean.Parser.ParserExtension.State.categories, panicWithPosWithDecl, OfNat.ofNat, Lean.Parser.SyntaxNodeKindSet.insert, Std.PersistentHashMap.contains, Std.PersistentHashMap.insert, Lean.Parser.ParserCategory.mk, Lean.Parser.PrattParsingTables.mk, Lean.Parser.addParser]]
[Lean.Widget.CodeWithInfos,[Lean.Widget.TaggedText, Lean.Widget.CodeToken]]
[Lean.Elab.Term.StructInst.Struct.source,[Lean.Elab.Term.StructInst.Source]]
[Lean.Elab.Term.StructInst.FieldLHS.toSyntax,[Lean.Syntax, ite, Eq, Bool.true, Lean.mkIdentFrom, Lean.mkGroupNode, List.toArray, List.cons, Lean.mkAtomFrom, List.nil]]
[Lean.Elab.Term.setElabConfig,[Lean.Meta.Config.mk, Bool.true, Bool.false, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct]]
[Array.findSome!,[Unit.unit, Array.findSome?, panicWithPosWithDecl, OfNat.ofNat]]
[Prod.forall',[Prod.forall]]
[Lean.Elab.Command.elabCommandTopLevel,[Lean.withRef, Bind.bind, MonadState.modifyGet, Prod.mk, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.MessageLog.mk, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Lean.Elab.getResetInfoTrees, Lean.Elab.Command.withLogging, Lean.Elab.Command.runLinters, Lean.Elab.Command.elabCommand, MonadState.get, Pure.pure, Lean.MonadOptions.getOptions, ite, Eq, and, not, Lean.Option.get, Lean.Elab.Command.showPartialSyntaxErrors, Lean.MessageLog.hasErrors, Lean.Syntax.hasMissing, Bool.true, PUnit.unit]]
[Lean.Parser.Term.typeSpec,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser]]
[Lean.KernelException.letTypeMismatch.inj,[And.intro]]
[List.ne_nil_of_length_pos,[Nat.lt_irrefl, OfNat.ofNat, Eq.subst, Iff.mpr, List.length_eq_zero]]
[StateT.instLawfulMonadStateT,[StateT.instLawfulMonadStateT.proof_1]]
[Lean.Syntax.setTailInfo,[Unit.unit, Lean.Syntax, Lean.Syntax.setTailInfoAux]]
[Lean.Meta.CaseValueSubgoal.mk.inj,[And.intro]]
[Lean.Elab.Tactic.ElimApp.M,[ReaderT, Lean.Elab.Tactic.ElimApp.Context, StateRefT', IO.RealWorld, Lean.Elab.Tactic.ElimApp.State, Lean.Elab.Term.TermElabM]]
[Lean.Meta.mkLevelStuckErrorMessage,[Unit.unit, Lean.Meta.MetaM, Lean.MessageData, Lean.Meta.PostponedEntry.ctx?, Pure.pure, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.Meta.PostponedEntry.lhs, Lean.Meta.PostponedEntry.rhs, Lean.Meta.withLCtx, Lean.Meta.DefEqContext.lctx, Lean.Meta.DefEqContext.localInstances, Bind.bind, Lean.Meta.instantiateMVars, Lean.Meta.DefEqContext.lhs, Lean.Meta.DefEqContext.rhs, MonadExcept.tryCatch, Lean.Meta.inferType, Lean.AddMessageContext.addMessageContext, Lean.MessageData.ofExpr]]
[Lean.Meta.Hypothesis.value,[]]
[Std.PersistentHashMap.Stats.mk.inj,[And.intro]]
[Lean.Elab.Tactic.ElabSimpArgsResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.ElabSimpArgsResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.ReferenceParams.noConfusionType,[]]
[Lean.Meta.DefaultInstances.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[ExceptT.mk,[]]
[Lean.Lsp.RpcCallParams.mk.inj,[And.intro]]
[GroupWithZero.inv_zero,[]]
[Lean.PrettyPrinter.parenthesizeTerm,[Lean.PrettyPrinter.parenthesize, Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat]]
[instIsAddRightCancel,[IsAddRightCancel.mk, instIsAddRightCancel.proof_1]]
[Lean.Meta.cleanup.collectPropsStep,[Bind.bind, MonadState.get, Lean.MonadLCtx.getLCtx, ForIn.forIn, PUnit.unit, liftM, Lean.Meta.isProp, Lean.LocalDecl.type, ite, Eq, Bool.true, Lean.Meta.dependsOnPred, Std.RBTree.contains, Lean.Meta.cleanup.addUsedFVar, Lean.LocalDecl.fvarId, Pure.pure, ForInStep.yield]]
[Lean.Elab.Info.isCompletion,[Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofTermInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Bool, Bool.true, Bool.false]]
[Lean.Widget.Lean.Widget.InteractiveGoals.instRpcEncodingInteractiveGoalsRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Lean.Widget.InteractiveGoals.goals, Pure.pure, Lean.Server.RpcEncoding.rpcDecode, Lean.Widget.InteractiveGoals.mk]]
[termℕ,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Lean.Expr.replaceFVars,[Lean.Expr.instantiateRev, Lean.Expr.abstract]]
[Lean.Lsp.DefinitionParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Attr.externEntry.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.strLit.parenthesizer]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.matcherTy,[]]
[Lean.ConstantInfo.levelParams,[Lean.ConstantVal.levelParams, Lean.ConstantInfo.toConstantVal]]
[Lean.instReprLiteral,[Repr.mk, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, HAppend.hAppend, Std.Format.text, Std.Format.line, reprArg, Std.Format.FlattenBehavior.allOrNone]]
[Lean.Elab.Term.expandAssert,[Unit.unit, Lean.MacroM, Lean.Syntax, Lean.Syntax.reprint, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Quote.quote]]
[map_congr,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Functor.map, funext, eq_self]]
[Lean.Meta.isMatcherCore,[Option.isSome, Lean.Meta.getMatcherInfoCore?]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.info,[]]
[Int.decLt,[Decidable, Int.NonNeg, Decidable.isTrue, Int.NonNeg.mk, Decidable.isFalse, Eq.refl, Int.negSucc, HEq.refl, False, HSub.hSub, HAdd.hAdd, OfNat.ofNat]]
[mt,[]]
[Lean.instInhabitedExprStructEq,[Inhabited.mk, Lean.ExprStructEq.mk, arbitrary]]
[Lean.Meta.MVarRenaming.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[String.foldr,[String.foldrAux, String.bsize, OfNat.ofNat]]
[Lean.Meta.mkOfEqTrue,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil]]
[Lean.Meta.Match.Unify.Context.noConfusionType,[]]
[Lean.Meta.IndPredBelow.mkBelowMatcher.addBelowPattern,[Lean.Meta.withExistingLocalDecls, Lean.Meta.Match.AltLHS.fvarDecls, Bind.bind, Lean.Meta.IndPredBelow.mkBelowMatcher.convertToBelow, Array.getOp, Lean.Meta.MetaM, Lean.Meta.Match.AltLHS, Array.toList, Lean.Meta.IndPredBelow.mkBelowMatcher.toInaccessible, Pure.pure, Lean.Meta.Match.AltLHS.mk, Lean.Meta.Match.AltLHS.ref, HAppend.hAppend]]
[Lean.Lsp.InitializeParams.clientInfo?,[]]
[Lean.Parser.Tactic.rotate,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const]]
[Lean.resolveGlobalName,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, Pure.pure, Lean.ResolveName.resolveGlobalName]]
[Lean.instCoeNatDataValue,[Coe.mk, Lean.DataValue.ofNat]]
[Lean.MetavarContext.instInhabitedMetavarContext,[Inhabited.mk, Lean.MetavarContext.mk]]
[Lean.Lsp.instToJsonMarkupContent,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.MarkupContent.kind, List.nil, Lean.Lsp.MarkupContent.value]]
[Lean.PrettyPrinter.Parenthesizer.visitToken,[Bind.bind, modify, Lean.PrettyPrinter.Parenthesizer.State.mk, Lean.PrettyPrinter.Parenthesizer.State.stxTrav, Option.none, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.State.minPrec, Lean.PrettyPrinter.Parenthesizer.State.trailPrec, Lean.PrettyPrinter.Parenthesizer.State.trailCat, Bool.true, Lean.Syntax.MonadTraverser.goLeft]]
[Lean.Elab.Command.adaptExpander,[Bind.bind, Lean.Elab.Command.withMacroExpansion, Lean.Elab.Command.elabCommand]]
[Lean.Elab.Term.expandUnreachable,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Lean.ScopedEnvExtension.StateStack.newEntries,[]]
[Lean.MVarId.noConfusionType,[]]
[Lean.IR.CtorLayout.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.CtorLayout.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Mathlib.Tactic.Lint.Linter.mk.inj,[And.intro]]
[Lean.Xml.Parser.TokenizedType,[HOrElse.hOrElse, Lean.Parsec.skipString]]
[List.erase_nil,[rfl]]
[List.exists_mem_cons_of,[Exists.intro, And.intro, List.mem_cons_self]]
[String.set,[String, String.mk, List, Char, List.nil, ite, Eq, List.cons, PProd.fst, HAdd.hAdd, String.csize, OfNat.ofNat]]
[Lean.Server.FileWorker.SemanticTokensContext.noConfusionType,[]]
[instDecidableRelLeLeOfOrd,[inferInstanceAs, DecidableRel, Eq, Ordering.isLE, Ord.compare, Bool.true]]
[List.disjoint_comm,[Iff.intro, List.disjoint_symm]]
[Lean.Expr.updateLet!.proof_1,[rfl]]
[Lean.Elab.Term.StructInst.Field.lhs,[]]
[Lean.Elab.Tactic.isHoleRHS,[or, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Json.bool.injEq,[Eq.propIntro, Eq.refl, Lean.Json.bool, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Name.simpMacroScopes,[Unit.unit, Lean.Name, Lean.Name.hasMacroScopes, Lean.Name.anonymous, Lean.Name.str, Lean.Name.mkNum, PProd.fst, BEq.beq]]
[Nat.mod_lt,[Nat.mod.inductionOn]]
[List.erase_eq_erasep,[rfl, Classical.em, Eq, of_eq_true, Eq.trans, congr, congrArg, List.erase, List.cons, List.erase_cons_head, List.erasep_cons_of_pos, congrFun, eq_self, Eq.symm, List.erase_cons_tail, ne_eq, Not, eq_false, Ne.symm, eq_true_of_decide, Eq.refl, Bool.true, List.erasep_cons_of_neg, List.erasep]]
[Lean.Parser.Tactic.Conv.guardLHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.add_le_add_left,[LE.le, HAdd.hAdd, Nat.le.dest]]
[IO.withStdin,[Bind.bind, liftM, IO.setStdin, tryFinally, Functor.discard]]
[Lean.Parser.skip,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo]]
[Lean.Parser.Term.letDecl.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.notFollowedBy.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.letIdDecl.parenthesizer, Lean.Parser.Term.letPatDecl.parenthesizer, Lean.Parser.Term.letEqnsDecl.parenthesizer]]
[Std.PersistentArray.any,[Id.run, Std.PersistentArray.anyM]]
[Lean.Lsp.instToJsonWorkDoneProgressReport,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.WorkDoneProgressReport.kind, List.nil, Lean.Json.opt, Lean.Lsp.WorkDoneProgressReport.message?, Lean.Lsp.WorkDoneProgressReport.cancellable, Lean.Lsp.WorkDoneProgressReport.percentage?]]
[List.partition,[List.partitionAux, Prod.mk, List.nil]]
[Lean.instToMessageDataString,[Lean.ToMessageData.mk, Lean.stringToMessageData]]
[Std.PersistentArray.allM,[Bind.bind, Std.PersistentArray.anyM, Pure.pure, not]]
[Lean.OpaqueVal.value,[]]
[instOrOpUSize,[OrOp.mk, USize.lor]]
[Lean.Parser.instCoeStringParser,[Coe.mk, Lean.Parser.symbol]]
[Lean.Server.RequestContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.RequestContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.throwUnknownMVar,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MVarId.name]]
[Lean.ParserCompiler.registerCombinatorAttribute,[Bind.bind, Lean.registerSimplePersistentEnvExtension, Lean.SimplePersistentEnvExtensionDescr.mk, Lean.NameMap.insert, Prod.fst, Prod.snd, Lean.mkStateFromImportedEntries, EmptyCollection.emptyCollection, Lean.registerBuiltinAttribute, Pure.pure, Lean.ParserCompiler.CombinatorAttribute.mk]]
[Lean.IR.ExplicitBoxing.BoxingState.noConfusionType,[]]
[HAnd.noConfusionType,[]]
[Lean.Expr.getRevArg!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, PProd.fst, panicWithPosWithDecl, OfNat.ofNat]]
[Char.utf16Size,[ite, LE.le, Char.val, OfNat.ofNat]]
[not_true,[iff_false_intro, not_not_intro, trivial]]
[Lean.Elab.Modifiers.isUnsafe,[]]
[Subtype.noConfusionType,[]]
[Lean.Elab.Command.hasNoErrorMessages,[Bind.bind, MonadState.get, Pure.pure, not, Lean.MessageLog.hasErrors, Lean.Elab.Command.State.messages]]
[Lean.KVMap.getInt,[Option.none, Option.some, Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofName, Lean.DataValue.ofNat, Int, Lean.KVMap.find]]
[Lean.StructureInfo.fieldInfo,[]]
[instReprProd,[Repr.mk, Std.Format, Std.Format.bracket, Std.Format.joinSep, List.reverse, ReprTuple.reprTuple, List.cons, repr, List.nil, HAppend.hAppend, Std.Format.text, Std.Format.line]]
[Lean.Elab.Term.NamedArg.noConfusionType,[]]
[Lean.Meta.AbstractNestedProofs.Context.baseName,[]]
[Lean.Elab.Term.PatternElabException.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.logMessage,[Bind.bind, MonadReader.read, ite, Eq, Option.none, Option.some, Lean.DataValue.ofString, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Bool, Lean.KVMap.find, Lean.KVMap.getBool, Lean.IR.tracePrefixOptionName, Bool.false, Bool.true, Lean.IR.log, Lean.IR.LogEntry.message, Std.ToFormat.format, Pure.pure, PUnit.unit]]
[Lean.Meta.matchConstructorApp?,[Bind.bind, Lean.MonadEnv.getEnv, Lean.Meta.matchHelper?, Pure.pure, Lean.Expr.isConstructorApp?]]
[Lean.Elab.Term.LVal.getRef,[Lean.Syntax]]
[Lean.Parser.antiquotNestedExpr,[Lean.Parser.node, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.symbolNoAntiquot, Lean.Parser.decQuotDepth, Lean.Parser.termParser, OfNat.ofNat]]
[Lean.Meta.DiscrTree.Key.proj.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.DiscrTree.Key.proj, Eq.symm, eq_of_heq, HEq.refl]]
[Sigma.snd,[]]
[Lean.Parser.Tactic.squeezeSimpa!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser]]
[Array.toArrayLit.proof_1,[Nat.le_refl, Array.size]]
[iff_false,[propext, Iff.intro, Iff.mp, False.elim]]
[Lean.Elab.Term.Do.mkSingletonDoSeq,[Lean.Elab.Term.Do.mkDoSeq, List.toArray, List.cons, List.nil]]
[Lean.LocalContext.setUserName,[Lean.LocalContext.mk, Std.PersistentHashMap.insert, Lean.LocalContext.fvarIdToDecl, Lean.LocalDecl.fvarId, Std.PersistentArray.set, Lean.LocalContext.decls, Lean.LocalDecl.index, Option.some]]
[Lean.Parser.nonReservedSymbolInfo,[Lean.Parser.ParserInfo.mk, ite, Eq, Bool.true, Lean.Parser.FirstTokens.tokens, List.cons, List.nil]]
[UInt16.instSemigroupUInt16.proof_1,[congrArg, UInt16.mk, Semigroup.mul_assoc, UInt16.val]]
[Lean.Parser.Tactic.propagateTags,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser]]
[String.anyAux,[String.anyAux.loop]]
[«command_ClassAbbrev__:_:=__,»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[Lean.IR.Borrow.BorrowInfState.mk.inj,[And.intro]]
[Lean.Parser.Term.optSemicolon.parenthesizer,[Lean.Parser.ppDedent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ppLine.parenthesizer]]
[Lean.Meta.Simp.Step.visit.inj,[]]
[Lean.Elab.Tactic.Conv.convert,[Bind.bind, liftM, Lean.Elab.Tactic.Conv.mkConvGoalFor, Lean.Elab.Tactic.TacticM, Prod, Lean.Expr, Lean.Elab.Tactic.getGoals, tryFinally, Lean.Elab.Tactic.setGoals, List.cons, Lean.Expr.mvarId!, List.nil, ForIn.forIn, PUnit.unit, MonadExcept.tryCatch, Lean.Meta.applyRefl, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Pure.pure, Unit.unit, ForInStep.yield, Lean.Elab.Tactic.pruneSolvedGoals, ite, Eq, List.isEmpty, Bool.true, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.goalsToMessageData, Lean.Meta.instantiateMVars, Prod.mk]]
[exists_eq_left,[Iff.intro, Exists.intro, And.intro, rfl]]
[ByteArray.instInhabitedByteArray,[Inhabited.mk, ByteArray.empty]]
[Lean.Meta.resettingSynthInstanceCacheWhen,[ite, Eq, Bool.true, Lean.Meta.resettingSynthInstanceCache]]
[Lean.Elab.Command.mkDefViewOfAbbrev,[Lean.Elab.DefView, Lean.Elab.DefView.mk, Lean.Elab.DefKind.abbrev, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Elab.Info.ofCompletionInfo.inj,[]]
[Lean.Lsp.DiagnosticCode.noConfusionType,[]]
[Lean.Elab.Term.Do.getPatternsVarsEx,[HOrElse.hOrElse, Functor.map, Lean.Elab.Term.getPatternVarNames, Lean.Elab.Term.getPatternsVars, Array.map, Lean.Syntax.getId, Lean.Elab.Term.Quotation.getPatternsVars]]
[Lean.Expr.ReplaceImpl.cacheSize,[OfNat.ofNat]]
[Lean.MetavarKind.toCtorIdx,[OfNat.ofNat]]
[Lean.Meta.InfoCacheKey.mk.inj,[And.intro]]
[List.exists_mem_cons_iff,[Iff.intro, List.or_exists_of_exists_mem_cons, Or.elim, List.exists_mem_cons_of, List.exists_mem_cons_of_exists]]
[Lean.Parser.getUnaryAlias,[Bind.bind, Lean.Parser.getAlias, Unit.unit, Lean.Parser.AliasValue.const, Lean.Parser.AliasValue.binary, IO, Pure.pure, MonadExcept.throw, coe, HAppend.hAppend, ToString.toString]]
[Lean.markBorrowed,[Lean.mkAnnotation, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Meta.SynthInstance.SubgoalsResult.instTypeBody,[]]
[Prod.noConfusionType,[]]
[Lean.Json.CompressWorkItem.objectField.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[pow_one,[Eq.mpr, Eq.refl, Eq, HPow.hPow, OfNat.ofNat, Nat.one_eq_succ_zero, Nat.succ, pow_succ, HMul.hMul, pow_zero, one_mul, rfl]]
[Lean.Server.FileWorker.RefIdent.const.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.SimplePersistentEnvExtension.getState,[Prod.snd, Lean.PersistentEnvExtension.getState]]
[Prod.fst_eq_iff,[Iff, Eq, Prod.fst, Prod.mk, Prod.snd, of_eq_true, Eq.trans, congrArg, Prod.mk.injEq, And, eq_self, and_true, iff_self]]
[Lean.Meta.splitIfTarget?,[Lean.commitWhenSome?, Bind.bind, Lean.Meta.getMVarType, Lean.Meta.SplitIf.splitIfAt?, Option.none, Lean.Meta.MetaM, Option, Prod, Lean.Meta.ByCasesSubgoal, Lean.Meta.simpIfTarget, Lean.Meta.ByCasesSubgoal.mvarId, Bool.false, ite, Eq, and, BEq.beq, Bool.true, Pure.pure, Option.some, Prod.mk, Lean.Meta.ByCasesSubgoal.mk, Lean.Meta.ByCasesSubgoal.fvarId]]
[Lean.Parser.Term.explicitBinder,[Lean.Parser.ppGroup, Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.Term.binderIdent, Lean.Parser.Term.binderType, Lean.Parser.optional, HOrElse.hOrElse, Lean.Parser.Term.binderTactic, Lean.Parser.Term.binderDefault]]
[Lean.Meta.getLevelMVarDepth,[Bind.bind, Lean.MonadMCtx.getMCtx, Option.none, Lean.Meta.MetaM, Nat, Lean.MetavarContext.findLevelDepth?, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MVarId.name]]
[Lean.Level.isExplicit,[Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Bool, Bool.true, and, not, Lean.Level.hasMVar, Lean.Level.hasParam, PProd.fst, Bool.false]]
[Lean.Parser.Tactic.Conv.normCast,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Elab.Term.elabCommandQuot,[Lean.Elab.Term.adaptExpander, Lean.Elab.Term.Quotation.stxQuot.expand]]
[Lean.Json.CompressWorkItem.json.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Mathlib.Tactic.Lint.getChecks,[ite, Eq, Bool.true, Bind.bind, Pure.pure, List.nil, Lean.MonadEnv.getEnv, Lean.TagAttribute.getDecls, Mathlib.Tactic.Lint.mathlibLinterAttr, Mathlib.Tactic.Lint.getLinters, Array.toList]]
[mul_right_inv,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Inv.inv, OfNat.ofNat, Eq.symm, mul_left_inv, inv_inv, rfl]]
[Lean.Elab.Command.StructView.fields,[]]
[Lean.Parser.Tactic.continuity?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.Simp.Config.eta,[]]
[Lean.EnvironmentHeader.trustLevel,[]]
[Lean.Parser.Command.universe.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.ident.formatter]]
[Lean.Compiler.BinFoldFn,[Option, Lean.Expr]]
[List.append_eq_appendTR,[funext, rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, List.cons, List.reverseAux_reverseAux, List.nil, eq_self, List.reverseAux]]
[Lean.Elab.InfoTree.termGoalAt?,[Lean.Elab.InfoTree.smallestInfo?, Id.run, ite, Eq, Lean.Elab.Info.contains, Bool.true, Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.Info.ofCompletionInfo, Id, Bool, Pure.pure, or, not, Lean.Syntax.isIdent, Lean.Elab.ElabInfo.stx, Lean.Elab.TermInfo.toElabInfo, Std.HashSet.contains, Option.get!, Lean.Elab.Info.pos?, Bind.bind, PUnit.unit, Lean.Elab.InfoTree.termGoalAt?.getHeadFnPos?]]
[max,[ite, LT.lt]]
[System.SearchPath.toString,[String.intercalate, Char.toString, System.SearchPath.separator, List.map, System.FilePath.toString]]
[Lean.Name.replacePrefix,[Lean.Name.str, Lean.Name.num, Lean.Name, Lean.Name.anonymous, ite, Eq, BEq.beq, Bool.true, Lean.Name.mkStr, PProd.fst, Lean.Name.mkNum]]
[Dvd.noConfusionType,[]]
[Int.subNatNat_sub,[Eq.mpr, Eq.refl, Eq, Int.subNatNat, HSub.hSub, HAdd.hAdd, Eq.symm, Int.subNatNat_add_add, Nat.sub_add_cancel, rfl]]
[Lean.Lsp.instFromJsonLeanFileProgressProcessingInfo,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.Range, Pure.pure, Lean.Lsp.LeanFileProgressProcessingInfo.mk]]
[Lean.Elab.Term.Do.ToTerm.reassignToTerm,[Lean.withRef, Lean.MonadQuotation.withFreshMacroScope, ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.getKind, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Lean.Quote.quote, List.nil, Lean.Macro.throwErrorAt]]
[List.card_nil,[rfl]]
[Lean.Meta.RecursorInfo.mk.inj,[And.intro]]
[Mathlib.Tactic.Lint.NamedLinter.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Mathlib.Tactic.Lint.NamedLinter.mk, Eq.symm, eq_of_heq, HEq.refl]]
[IO.AccessRight.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.levelParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Meta.Match.counterExamplesToMessageData,[Lean.MessageData.joinSep, List.map, Lean.Meta.Match.counterExampleToMessageData, Lean.MessageData.ofFormat, Std.Format.line]]
[Lean.Meta.isMatcherAppCore?,[ite, Eq, Lean.Expr.isConst, Bool.true, Option.none, Option, Lean.Meta.Match.MatcherInfo, Lean.Meta.getMatcherInfoCore?, Lean.Expr.constName!, GE.ge, Lean.Expr.getAppNumArgs, Lean.Meta.Match.MatcherInfo.arity, Option.some]]
[Lean.Elab.WF.TerminationStrategy.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.pred_lt,[LT.lt, Nat.pred, absurd, rfl, Nat.lt_succ_of_le, Nat.le_refl, Nat.succ]]
[Lean.Elab.Term.MVarErrorInfo.logError,[Unit.unit, Lean.Elab.Term.TermElabM, Unit, Lean.Elab.Term.MVarErrorInfo.kind, Bind.bind, liftM, Lean.Meta.instantiateMVars, Lean.Elab.logErrorAt, Lean.Elab.Term.MVarErrorInfo.ref, Lean.MessageData.tagged, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.Term.MVarErrorInfo.logError.addArgName, Lean.Elab.Term.MVarErrorInfo.logError.appendExtra]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.instInhabitedContext,[Inhabited.mk, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk, arbitrary]]
[Lean.PrettyPrinter.Delaborator.delabMVar,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, liftM, Lean.Meta.getMVarDecl, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Lean.mkIdent, List.nil, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Server.FileWorker.handleSemanticTokensFull,[Lean.Server.FileWorker.handleSemanticTokens, OfNat.ofNat, HShiftLeft.hShiftLeft]]
[Lean.Parser.Command.macroTail.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.macroTailTactic.formatter, Lean.Parser.Command.macroTailCommand.formatter, Lean.Parser.Command.macroTailDefault.formatter]]
[Lean.Elab.Structural.State.addMatchers,[]]
[Lean.getPPUniverses,[Lean.KVMap.get, Lean.Option.name, Lean.pp.universes, Lean.getPPAll]]
[PSigma.revLexAccessible.proof_1,[Acc.intro, PSigma.mk, Eq.symm, eq_of_heq, Eq.refl, HEq.refl]]
[Lean.Elab.instInhabitedDefKind,[Inhabited.mk, Lean.Elab.DefKind.def]]
[Lean.instInhabitedLocalInstance,[Inhabited.mk, Lean.LocalInstance.mk, arbitrary]]
[Lean.instInhabitedOptions,[Inhabited.mk, Lean.KVMap.mk]]
[Lean.Meta.instReprElimInfo,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.Meta.ElimInfo.name, Std.Format.line, Lean.Meta.ElimInfo.motivePos, Lean.Meta.ElimInfo.targetsPos, Lean.Meta.ElimInfo.altsInfo]]
[Lean.Parser.Tactic.Conv.convConvSeq,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq]]
[Lean.ConstantInfo.name,[Lean.ConstantVal.name, Lean.ConstantInfo.toConstantVal]]
[Lean.Elab.ContextInfo.options,[]]
[Lean.Syntax.getAntiquotSpliceContents,[Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Lsp.TextDocumentSyncKind.incremental.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.EnumAttributes.getValue,[Unit.unit, Option, Lean.Environment.getModuleIdxFor?, Array.binSearch, Lean.PersistentEnvExtension.getModuleEntries, Lean.EnumAttributes.ext, Prod.mk, arbitrary, Lean.Name.quickLt, Prod.fst, OfNat.ofNat, HSub.hSub, Array.size, Option.some, Option.none, Lean.NameMap.find?, Lean.PersistentEnvExtension.getState]]
[Lean.Syntax.MonadTraverser.getCur,[Functor.map, Lean.Syntax.Traverser.cur, MonadState.get]]
[Lean.PrettyPrinter.Parenthesizer.liftCoreM,[liftM]]
[Lean.Meta.ReduceMatcherResult.stuck.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.ReduceMatcherResult.stuck, Eq.symm, eq_of_heq, HEq.refl]]
[or_not,[em]]
[instInhabitedExcept,[Inhabited.mk, Except.error, arbitrary]]
[Nat.instCommSemiringNat.proof_1,[of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.succ_mul, Nat.add_comm, HMul.hMul, eq_self, HAdd.hAdd]]
[Lean.withImportModules,[Bind.bind, Lean.importModules, tryFinally, Lean.Environment.freeRegions]]
[Function.surjective.has_right_inverse,[Exists.intro, Function.surj_inv, Function.right_inverse_surj_inv]]
[Lean.Lsp.PlainGoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[not_forall,[Decidable.not_forall]]
[Std.Format.tag.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.Format.tag, Eq.symm, eq_of_heq, HEq.refl]]
[String.Iterator.extract,[String, ite, Eq, or, Decidable.decide, Ne, GT.gt, Bool.true, String.extract]]
[Lean.IR.NormalizeIds.normJP,[Functor.map, Lean.IR.JoinPointId.mk, Lean.IR.NormalizeIds.normIndex, Lean.IR.JoinPointId.idx]]
[Std.mkHashSet,[Subtype.mk, Std.mkHashSetImp, Std.HashSetImp.WellFormed.mkWff]]
[Nat.gcd,[WellFounded.fix, Nat.gcd.proof_1, Unit.unit, Nat, HMod.hMod, Nat.succ, Nat.mod_lt, Nat.zero_lt_succ]]
[Lean.Compiler.atMostOnce.AtMostOnceData.result,[]]
[Std.RBNode.balLeft,[Std.RBNode.leaf, Std.RBNode.node, Std.Rbcolor.red, Std.Rbcolor.black, Std.RBNode, Std.RBNode.balance₃, Std.RBNode.setRed]]
[Lean.Meta.mkSimpLemmas,[Lean.Meta.withReducible, Bind.bind, Lean.Meta.inferType, Lean.Meta.isProp, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Array.map, Lean.Expr, List.toArray, Array.mapM, Lean.Meta.instantiateMVars, Lean.Meta.withNewMCtxDepth, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.MetaM, Lean.Meta.SimpLemma, Lean.Meta.whnfR, Unit.unit, Lean.Expr.eq?, Lean.Meta.DiscrTree.mkPath, Prod.mk]]
[Lean.Meta.CaseArraySizesSubgoal.subst,[]]
[Lean.Parser.setLhsPrec,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.setLhsPrecFn]]
[Lean.Parser.instInhabitedParser,[Inhabited.mk, Lean.Parser.Parser.mk, arbitrary]]
[Lean.Meta.matchFalse,[Lean.Meta.testHelper, Pure.pure, Lean.Expr.isConstOf, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.strLt,[Decidable.decide, LT.lt]]
[Lean.ConstantVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.noImplicitLambda.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec]]
[Lean.OptionDecl.defValue,[]]
[ExceptCpsT.instLawfulMonadExceptCpsT.proof_1,[LawfulMonad.mk, rfl]]
[Lean.LocalContext.mkLambda,[Lean.LocalContext.mkBinding, Bool.true]]
[Lean.Elab.expandOptNamedPrio,[ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, OfNat.ofNat, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Lean.evalPrio, Lean.Macro.throwUnsupported]]
[instAddUInt16,[Add.mk, UInt16.add]]
[String.codepointPosToUtf16Pos,[String.codepointPosToUtf16PosFrom, OfNat.ofNat]]
[Prod.map_snd',[funext, Prod.map_snd]]
[Lean.Elab.Tactic.ElimApp.evalAlts,[Bind.bind, ForIn.forIn, PUnit.unit, ite, Eq, bne, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Array.any, Bool, BEq.beq, OfNat.ofNat, Array.size, Pure.pure, ForInStep.yield, Lean.throwErrorAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.withInfoContext, Lean.Elab.Tactic.ElimApp.evalAlts.go, Lean.Elab.Tactic.ElimApp.evalAlts.applyPreTac]]
[STWorld.noConfusionType,[]]
[Lean.Parser.Tactic.rintroPat.binder,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[Lean.Elab.Term.StructInst.FieldLHS.modifyOp.inj,[And.intro]]
[Lean.Server.Watchdog.ServerContext.initParams,[]]
[Ord.noConfusionType,[]]
[List.exists_of_mem_join,[Iff.mp, List.mem_join]]
[Std.mkPersistentArray,[Nat.fold, Std.PersistentArray.push, Std.PersistentArray.empty]]
[Lean.IR.mkUSet,[Lean.IR.FnBody.uset]]
[Lean.IR.ExpandResetReuse.eraseProjIncFor,[Lean.IR.ExpandResetReuse.eraseProjIncForAux, Array.mkArray, Option.none, List.toArray, List.nil]]
[Lean.PrettyPrinter.Delaborator.getExprKind,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Pure.pure, Lean.Name, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr.getAppFn, List.nil, List.cons, Prod.mk, Lean.KVMap.entries]]
[UInt64.instAddSemigroupUInt64.proof_1,[congrArg, UInt64.mk, AddSemigroup.add_assoc, UInt64.val]]
[IO.FS.Metadata.byteSize,[]]
[Lean.Elab.Term.ToParserDescrContext.first,[]]
[Lean.Meta.instReprTransparencyMode,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone]]
[Lean.Meta.Closure.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[String.append,[String, String.mk, HAppend.hAppend]]
[Lean.Export.State.defs,[]]
[Lean.Parser.Attr.toAdditive?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const]]
[Lean.Meta.Match.Extension.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.sub_zero,[rfl]]
[Lean.Parser.ident,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.identKind, Bool.true, Lean.Parser.identNoAntiquot]]
[Array.eraseIdxSzAuxInstance,[Inhabited.mk, Subtype.mk, Array.pop, Array.size_pop]]
[Char.instInhabitedChar,[Inhabited.mk, Char.ofNat]]
[Lean.Server.Completion.State.noConfusionType,[]]
[IO.rand,[Bind.bind, ST.Ref.get, IO.stdGenRef, IO, Nat, ST.Ref.set, Pure.pure]]
[Lean.Widget.MsgEmbed.expr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.Delaborator.Context.defaultOptions,[]]
[Lean.NameSet.instEmptyCollectionNameSet,[EmptyCollection.mk, Lean.NameSet.empty]]
[ToBool.noConfusionType,[]]
[List.erasep_append_left,[List.nil, Eq, List.erasep, HAppend.hAppend, Classical.em, of_eq_true, Eq.trans, congr, congrArg, List.cons_append, List.erasep_cons_of_pos, eq_true, congrFun, eq_self, Eq.symm, Eq.mpr, List.erasep_cons_of_neg, Not, eq_false, eq_true_of_decide, Eq.refl, Bool.true, List.cons.injEq, And, true_and, PProd.fst, List.mem_of_ne_of_mem, mt, eq_of_heq, HEq.refl, rfl]]
[Lean.Elab.Term.StructInst.FieldLHS.modifyOp.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.StructInst.FieldLHS.modifyOp, Eq.symm, eq_of_heq, HEq.refl]]
[Decidable.or_iff_not_imp_left,[Iff.intro, Or.resolve_left, dite, Or.inl, Function.comp, Or.inr]]
[Lean.Message.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Message.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Server.Completion.find?.choose,[ite, Eq, not, Lean.Elab.Info.isCompletion, Bool.true, Option.isSome, Lean.Elab.Info.occursInside?, Option, Prod, Lean.Server.Completion.HoverInfo, Lean.Elab.ContextInfo, Lean.Elab.Info, or, bne, Unit.unit, Lean.Server.Completion.HoverInfo.inside, Option.some, Prod.mk, HSub.hSub, Lean.Elab.Info.isSmaller, Option.none, Lean.Server.Completion.HoverInfo.after, Lean.Elab.Info.occursBefore?, Decidable.decide, LT.lt, and, BEq.beq]]
[EStateM.instInhabitedEStateM,[Inhabited.mk, EStateM.Result.error, arbitrary]]
[Hashable.hash,[]]
[Lean.Parser.instInhabitedInputContext,[Inhabited.mk, Lean.Parser.InputContext.mk, arbitrary]]
[Lean.Parser.Attr.defaultInstance.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false, Lean.Parser.optional.parenthesizer, Lean.Parser.priorityParser.parenthesizer]]
[Lean.MonadStateCacheT,[StateT, Std.HashMap]]
[Lean.Meta.Match.MatcherInfo.uElimPos?,[]]
[Lean.Elab.Deriving.explicitBinderF,[Lean.Parser.Term.explicitBinder, Bool.false]]
[Lean.Parser.getConstAlias,[Bind.bind, Lean.Parser.getAlias, Unit.unit, IO, Pure.pure, MonadExcept.throw, coe, HAppend.hAppend, ToString.toString]]
[Lean.mkNot,[Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Lean.Parser.Tactic.generalizes,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.generalizesArg]]
[List.insert_equiv_cons,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, List.mem_insert_iff, List.mem_cons_iff, iff_self, Or, Eq, Mem.mem]]
[Std.HashSetImp.buckets,[]]
[Lean.Elab.InfoTree.getCompletionInfos,[Lean.Elab.InfoTree.foldInfo, Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofTermInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Array, Prod, Lean.Elab.ContextInfo, Lean.Elab.CompletionInfo, Array.push, Prod.mk, List.toArray, List.nil]]
[Lean.KeyedDeclsAttribute.instInhabitedOLeanEntry,[Inhabited.mk, Lean.KeyedDeclsAttribute.OLeanEntry.mk, arbitrary]]
[Lean.Parser.Priority.numPrio.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.numLit.parenthesizer]]
[IO.FS.readBinFile,[Bind.bind, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.true, IO.FS.Handle.readBinToEnd]]
[Lean.Lsp.instFromJsonDocumentSelector,[Lean.FromJson.mk, Lean.FromJson.fromJson?]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.postponed,[]]
[Lean.PrettyPrinter.Parenthesizer.checkTailWs.parenthesizer,[Pure.pure, Unit.unit]]
[Lean.Meta.SynthInstance.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SynthInstance.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.CasesSubgoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.CasesSubgoal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Tactic.evalTraceState,[Bind.bind, Lean.Elab.Tactic.getUnsolvedGoals, Lean.Elab.logInfo, Lean.Elab.goalsToMessageData]]
[instInhabitedStdGen,[Inhabited.mk, StdGen.mk, OfNat.ofNat]]
[Lean.Elab.FieldInfo.val,[]]
[Lean.Meta.DiscrTree.instReprKey,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, HAppend.hAppend, Std.Format.text, Std.Format.line, reprArg, Std.Format.FlattenBehavior.allOrNone]]
[Lean.IR.instToStringJoinPointId,[ToString.mk, HAppend.hAppend, ToString.toString, Lean.IR.JoinPointId.idx]]
[Nat.instDecidableCoprime,[dite, Eq, Nat.gcd, OfNat.ofNat, Decidable.isTrue, Decidable.isFalse]]
[Lean.Meta.SimpLemmas.isDeclToUnfold,[Std.PersistentHashSet.contains, Lean.Meta.SimpLemmas.toUnfold]]
[UInt64.instSemiringUInt64.proof_4,[congrArg, UInt64.mk, AddMonoid.nsmul_succ', UInt64.val]]
[Lean.EnvExtensionInterface.mk.inj,[And.intro]]
[Lean.Core.Context.initHeartbeats,[]]
[Lean.getNatOption,[Bind.bind, Lean.MonadOptions.getOptions, Pure.pure, Lean.KVMap.getNat]]
[Lean.Meta.DiscrTree.Key.const.inj,[And.intro]]
[IO.FileRight.mk.inj,[And.intro]]
[Lean.Xml.Parser.PubidChar,[HOrElse.hOrElse, Lean.Parsec.asciiLetter, Lean.Parsec.digit, Lean.Xml.Parser.endl, Lean.Parsec.attempt, Bind.bind, Lean.Parsec.anyChar, ite, Eq, String.contains, Bool.true, Pure.pure, Lean.Parsec.fail]]
[Lean.Parser.many1,[Lean.Parser.many1NoAntiquot, Lean.Parser.withAntiquotSpliceAndSuffix, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol]]
[Lean.Meta.SimpAll.State.noConfusionType,[]]
[Lean.Elab.Tactic.elabAsFVar,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.elabTerm, Option.none, Bool.false, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Elab.Tactic.TacticM, Lean.FVarId, Pure.pure, liftM, Lean.Meta.inferType, Unit.unit, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true]]
[not_congr,[Iff.intro, mt, Iff.mpr, Iff.mp]]
[Lean.Syntax.atom.inj,[And.intro]]
[Lean.PrettyPrinter.parenthesize,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Std.ToFormat.format, Pure.pure, PUnit.unit]]
[Lean.Lsp.instFromJsonClientCapabilities,[Lean.FromJson.mk, Pure.pure, Lean.Lsp.ClientCapabilities.mk]]
[Lean.isCasesOnRecursor,[Lean.Name.anonymous, Lean.Name.num, Bool, and, BEq.beq, Lean.casesOnSuffix, Lean.isAuxRecursor, Bool.false]]
[FloatArray.set,[FloatArray, FloatArray.mk, Array.set]]
[Lean.Server.Watchdog.ServerM,[ReaderT, Lean.Server.Watchdog.ServerContext, IO]]
[Lean.ConstantVal.mk.inj,[And.intro]]
[Lean.Parser.Tactic.delta',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.Elab.Level.State.mctx,[]]
[Lean.Server.replaceLspRange,[String.toFileMap, HAppend.hAppend]]
[Lean.Elab.Term.StructInst.DefaultFields.Context.noConfusionType,[]]
[Lean.Lsp.SymbolKind.constructor.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Std.PersistentHashMap.isUnaryNode.proof_1,[Eq.mpr, Eq.refl, LT.lt, OfNat.ofNat, Array.size, Eq.symm, of_decide_eq_true, Bool.true]]
[Lean.Elab.Term.StructInst.DefaultFields.tryToSynthesizeDefault,[OfNat.ofNat, Lean.Elab.Term.StructInst.DefaultFields.tryToSynthesizeDefault.loop]]
[Lean.Elab.Command.elabMutualDef,[Bind.bind, Array.mapM, Lean.Elab.elabModifiers, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, and, Decidable.decide, GT.gt, Array.size, Lean.Elab.Modifiers.isNonrec, Bool.true, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Elab.Command.runTermElabM, Option.none, Lean.Elab.Term.elabMutualDef]]
[Lean.hasNeverExtractAttribute,[Lean.hasNeverExtractAttribute.visit]]
[Lean.Elab.Info.type?,[Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofCompletionInfo, Lean.Meta.MetaM, Option, Lean.Expr, coeM, Lean.Meta.inferType, Lean.Elab.TermInfo.expr, Lean.Elab.FieldInfo.val, Pure.pure, Option.none]]
[Lean.BinderInfo.strictImplicit.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Json.instCoeStringJson,[Coe.mk, Lean.Json.str]]
[Lean.Parser.Term.panic,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat]]
[Lean.Expr.instantiateLevelParamsArray,[Lean.Expr.instantiateLevelParamsCore, OfNat.ofNat]]
[instDecidableLe,[UInt32.decLe]]
[Lean.TheoremVal.noConfusionType,[]]
[Decidable.eq_or_lt_of_le,[Or.symm, Decidable.lt_or_eq_of_le]]
[Std.RBNode.lowerBound,[Option, Sigma, Unit.unit, PProd.fst, PProd.snd, Option.some, Sigma.mk]]
[Lean.MetavarContext.LevelMVarToParam.Context.mk.inj,[And.intro]]
[Lean.Elab.Term.StructInst.Field.mk.inj,[And.intro]]
[Lean.Parser.Command.macroTail,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HOrElse.hOrElse, Lean.Parser.Command.macroTailTactic, Lean.Parser.Command.macroTailCommand, Lean.Parser.Command.macroTailDefault]]
[EStateM.run,[]]
[unsafeBaseIO,[EStateM.Result.error, EStateM.run, Unit.unit]]
[Lean.Lsp.CompletionParams.mk.inj,[]]
[Int.natAbs_zero,[rfl]]
[Lean.Meta.map2MetaM,[controlAt, Lean.Meta.MetaM, MonadControlT.stM]]
[Lean.IR.LocalContext.isJP,[Option.none, Option.some, Lean.IR.LocalContextEntry.param, Lean.IR.LocalContextEntry.localVar, Bool, Std.RBMap.find?, Bool.true, Bool.false]]
[Lean.Elab.Structural.recArgHasLooseBVarsAt,[Option.isSome]]
[System.FilePath.fileName,[ite, Eq, or, String.isEmpty, BEq.beq, Bool.true, Option.none, Option.some]]
[Fin.instAddFin,[Add.mk, Fin.add]]
[tacticIterate___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.parser]]
[Lean.Meta.AltVarNames.mk.inj,[And.intro]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.knowsType,[]]
[Lean.Meta.FunInfo.noConfusionType,[]]
[Lean.Elab.Term.blockImplicitLambda,[or, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bool.false, and, BEq.beq, Lean.Syntax.getKind, Lean.Syntax.getOp, OfNat.ofNat, Array.any, Array.size, cond, Lean.Syntax.matchesNull]]
[UInt8.instSemiringUInt8,[Semiring.mk, UInt8.instSemiringUInt8.proof_1, UInt8.instSemiringUInt8.proof_2, UInt8.mk, Semiring.nsmul, UInt8.val, UInt8.instSemiringUInt8.proof_3, UInt8.instSemiringUInt8.proof_4, UInt8.instSemiringUInt8.proof_5, UInt8.instSemiringUInt8.proof_6, UInt8.instSemiringUInt8.proof_7, UInt8.instSemiringUInt8.proof_8, UInt8.instSemiringUInt8.proof_9, UInt8.instSemiringUInt8.proof_10, UInt8.instSemiringUInt8.proof_11, UInt8.instSemiringUInt8.proof_12, UInt8.instSemiringUInt8.proof_13]]
[UInt64.size,[OfNat.ofNat]]
[Lean.ParserCompiler.replaceParserTy,[Lean.Expr.replace, ite, Eq, Lean.Expr.isConstOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Option.some, Lean.mkConst, Lean.ParserCompiler.Context.tyName, List.nil, Option.none]]
[PSum.inr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.NameHashSet,[Std.HashSet, Lean.Name]]
[Lean.MetavarContext.localDeclDependsOn,[Lean.MetavarContext.findLocalDeclDependsOn, BEq.beq]]
[Lean.Parser.Term.namedArgument.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.Parser.ParserAttributeHook.noConfusionType,[]]
[Lean.Expr.updateConst,[Lean.mkConst, Lean.Expr.constName!]]
[Lean.Parser.getNext,[String.get, String.next]]
[Lean.Elab.WF.packDomain,[Bind.bind, ForIn.forIn, MProd.mk, Lean.Meta.lambdaTelescope, Lean.Elab.PreDefinition.value, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.PreDefinition.declName, Pure.pure, PUnit.unit, Lean.Meta.MetaM, ForInStep, MProd, Array, Nat, Lean.Elab.PreDefinition, Bool, ForInStep.yield, not]]
[Lean.IR.Log,[Array, Lean.IR.LogEntry]]
[Lean.Expr.Data.hasFVar,[BEq.beq, UInt64.land, UInt64.shiftRight, OfNat.ofNat]]
[Lean.Parser.manyIndent,[Lean.Parser.withPosition, Lean.Parser.many, HAndThen.hAndThen, Lean.Parser.checkColGe]]
[Lean.Meta.Match.MatchEqnsExtState.map,[]]
[Lean.Parser.errorAtSavedPosFn,[Unit.unit, Lean.Parser.ParserState, Lean.Parser.ParserContext.savedPos?, Lean.Parser.ParserState.mk, Array.push, Lean.Syntax.missing, Option.some, Lean.Parser.Error.mk]]
[Lean.Elab.Term.synthesizeSyntheticMVarsUsingDefault,[Bind.bind, Lean.Elab.Term.synthesizeSyntheticMVars, Bool.true, Bool.false]]
[withPtrEqDecEq.proof_2,[ofBoolUsing_eq_true]]
[Lean.Parser.Term.ensureExpectedType.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.strLit.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec]]
[Lean.Meta.AssertAfterResult.fvarId,[]]
[Array.uset,[Array.set, Fin.mk, USize.toNat]]
[Lean.Server.Watchdog.FileWorker.noConfusionType,[]]
[Lean.Elab.Command.mkDefViewOfConstant,[Lean.Elab.Command.CommandElabM, Lean.Elab.DefView, Unit.unit, Lean.Syntax.getOptional?, Lean.Syntax.getOp, OfNat.ofNat, Bind.bind, Pure.pure, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Prod.mk, List.nil, Lean.mkNode, List.toArray, Lean.mkAtomFrom]]
[Lean.instInhabitedConstructor,[Inhabited.mk, Lean.Constructor.mk, arbitrary]]
[Lean.Meta.instMetaEvalMetaM,[Lean.MetaEval.mk, Lean.MetaEval.eval, Lean.Meta.MetaM.run', Lean.Meta.Context.mk, Lean.Meta.State.mk, Bool.true]]
[List.length_insert_of_not_mem,[Eq.mpr, Eq.refl, Eq, List.length, List.insert, HAdd.hAdd, OfNat.ofNat, List.insert_of_not_mem, List.cons, Eq.symm, List.length'_eq_length, List.length', rfl]]
[Lean.ScopedEnvExtension.ext,[]]
[Fin.modn_lt,[LT.lt, Fin.val, HMod.hMod, Nat.lt_of_le_of_lt, Nat.mod_le, Nat.mod_lt]]
[Lean.Meta.Match.Pattern.replaceFVarId,[Lean.Meta.Match.Pattern.applyFVarSubst, Lean.Meta.FVarSubst.insert]]
[Lean.getAttrParamOptPrio,[ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, OfNat.ofNat, Unit.unit, Lean.AttrM, Nat, Lean.Syntax.isNatLit?, Lean.Syntax.getOp, Lean.throwErrorAt, Lean.ToMessageData.toMessageData]]
[Lean.OpenDecl.explicit.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.OpenDecl.explicit, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Match.Problem.examples,[]]
[Lean.Parser.ParserExtension.Entry.token.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.disjoint_iff_ne,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, List.disjoint_left, forall_congr, implies_congr, Eq.refl, Mem.mem, ne_eq, imp_not_comm, forall_eq', iff_self, Not]]
[Lean.Syntax.isCharLit?,[Option.none, Option, Char, Lean.Syntax.isLit?, Lean.charLitKind, Lean.Syntax.decodeCharLit]]
[Lean.Meta.AbstractMVarsResult.mk.inj,[And.intro]]
[Lean.Elab.Term.getMVarSyntaxMVarId,[Lean.MVarId.mk, Lean.Syntax.getKind, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Parser.Command.theorem.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.Command.declSig.parenthesizer, Lean.Parser.Command.declVal.parenthesizer, Lean.Parser.Command.terminationSuffix.parenthesizer]]
[Lean.Parser.Level.num.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.numLit.parenthesizer]]
[instMonadExceptOfExceptT,[MonadExceptOf.mk, ExceptT.mk, throwThe, tryCatchThe]]
[Lean.Parser.Command.docComment.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.ppDedent.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.commentBody.formatter, Lean.ppLine.formatter]]
[Lean.Parser.Command.catBehavior,[Lean.Parser.optional, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.nonReservedSymbol, Bool.false, HOrElse.hOrElse, Lean.Parser.Command.catBehaviorBoth, Lean.Parser.Command.catBehaviorSymbol]]
[Nat.instCommSemiringNat.proof_3,[rfl]]
[List.concat_eq_append',[Eq, List.concat, List.append', List.cons, List.nil, Eq.symm, List.append_nil, of_eq_true, Eq.trans, congrFun, congrArg, PProd.fst, eq_self]]
[Lean.IR.Expr.isTaggedPtr.injEq,[Eq.propIntro, Eq.refl, Lean.IR.Expr.isTaggedPtr, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Server.Watchdog.handleDidClose,[Lean.Server.Watchdog.terminateFileWorker, Lean.Lsp.TextDocumentIdentifier.uri, Lean.Lsp.DidCloseTextDocumentParams.textDocument]]
[add_mul,[Semiring.add_mul]]
[Tactic.Ring.horner_pow,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HPow.hPow, add_zero, HMul.hMul, mul_pow, HAdd.hAdd, Eq.symm, pow_mul, OfNat.ofNat, eq_self]]
[Lean.Elab.Term.LVal.fieldIdx.inj,[And.intro]]
[Lean.Server.Watchdog.ServerEvent.clientError.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.InputContext.noConfusionType,[]]
[Lean.Meta.DiscrTree.Trie.node.inj,[And.intro]]
[Lean.Syntax.setHeadInfo,[Unit.unit, Lean.Syntax, Lean.Syntax.setHeadInfoAux]]
[Lean.Lsp.ServerCapabilities.documentHighlightProvider,[]]
[Lean.Elab.Command.expandNotation,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Lean.Macro.throwUnsupported]]
[Lean.Compiler.foldNatDecLe,[Lean.Compiler.foldNatBinPred, Lean.Compiler.mkNatLe, Decidable.decide, LE.le]]
[HMod.hMod,[]]
[Lean.InductiveType.type,[]]
[MonadControl.stM,[]]
[Lean.Parser.Attr.defaultInstance.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.optional.formatter, Lean.Parser.priorityParser.formatter]]
[Array.modify,[Id.run, Array.modifyM]]
[Lean.Elab.Command.StructFieldView.inferMod,[]]
[List.card_subset_le,[LE.le, List.card, Eq.mpr, congrFun, congrArg, List.card_nil, Nat.zero_le, Decidable.em, Mem.mem, Eq.symm, Eq.refl]]
[Lean.Meta.SimpAll.State.ctx,[]]
[Subtype.restrict_apply,[rfl]]
[Lean.Parser.Tactic.matchRhs.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.hole.parenthesizer, Lean.Parser.Term.syntheticHole.parenthesizer, Lean.Parser.Tactic.tacticSeq.parenthesizer]]
[Tactic.LibrarySearch.lines,[Lean.MessageData.joinSep, Lean.MessageData.ofFormat, Std.Format.line]]
[Lean.Parser.notFollowedByCommandToken,[Lean.Parser.notFollowedByCategoryToken, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Elab.Term.Do.mkTerminalAction,[Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.action]]
[instLTFin,[LT.mk, LT.lt, Fin.val]]
[«term_/\_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.commitWhen,[Bind.bind, Lean.MonadBacktrack.saveState, MonadExcept.tryCatch, Unit.unit, Bool, Pure.pure, Bool.true, Lean.MonadBacktrack.restoreState, Bool.false, MonadExcept.throw]]
[decide_true_eq_true,[Eq, Decidable.decide, True, Bool.true, rfl, False.elim, True.intro]]
[Lean.IR.EmitC.emitInc,[Bind.bind, Lean.IR.EmitC.emit, ite, Eq, Bool.true, BEq.beq, OfNat.ofNat, bne, Pure.pure, PUnit.unit]]
[Nat.foldRev.loop,[PProd.fst]]
[instLEFloat,[LE.mk, Float.le]]
[Lean.AttributeExtensionOLeanEntry.decl.injEq,[Eq.propIntro, Eq.refl, Lean.AttributeExtensionOLeanEntry.decl, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.ExplicitRC.Context.varMap,[]]
[Lean.SimpleScopedEnvExtension.Descr.noConfusionType,[]]
[instMulUInt32,[Mul.mk, UInt32.mul]]
[List.card_map_le,[of_eq_true, Eq.trans, congr, congrArg, LE.le, List.card, List.map_nil, List.card_nil, eq_true_of_decide, Eq.refl, Bool.true, Decidable.em, Mem.mem, List.map, Eq.mpr, congrFun, List.map_cons, List.card_cons_of_mem, eq_true, List.cons, Nat.le_trans, List.card_le_card_cons, Eq.symm]]
[Lean.Meta.FVarSubst.domain,[Std.AssocList.foldl, List.cons, List.nil, Lean.Meta.FVarSubst.map]]
[Lean.Expr.updateLambda!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateLambda, Lean.Expr.lam, Lean.Expr.updateLambda!.proof_1, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Meta.throwAppTypeMismatch,[Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Prod, Lean.Expr, Lean.BinderInfo, Pure.pure, Prod.mk, Lean.Expr.Data.binderInfo, Lean.Meta.throwFunctionExpected, ite, Eq, Lean.BinderInfo.isExplicit, Bool.true, PUnit.unit]]
[Lean.Meta.InjectionResultCore.solved.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Lsp.SemanticTokensOptions.mk.inj,[And.intro]]
[Lean.RecursorVal.getFirstIndexIdx,[HAdd.hAdd, Lean.RecursorVal.numParams, Lean.RecursorVal.numMotives, Lean.RecursorVal.numMinors]]
[Lean.PrefixTree.foldMatchingM,[Lean.PrefixTreeNode.foldMatchingM, Subtype.val]]
[Lean.Meta.IndPredBelow.mkCtorType.copyVarName,[Bind.bind, Lean.Meta.getLocalDecl, liftM, Lean.Core.mkFreshUserName, Lean.LocalDecl.userName]]
[Lean.Meta.Match.Pattern.arrayLit.inj,[And.intro]]
[Quot.hrecOn,[Quot.recOn, Quot.hrecOn.proof_1]]
[Lean.Parser.Term.simpleBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.Parser.Term.optType.parenthesizer]]
[Lean.Elab.instInhabitedFieldInfo,[Inhabited.mk, Lean.Elab.FieldInfo.mk, arbitrary]]
[Lean.Parser.ParserInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.instFVarIdHashSetEmptyCollection,[Std.HashSet.instEmptyCollectionHashSet]]
[Lean.Elab.Term.MutualClosure.ClosureState.mk.inj,[And.intro]]
[Lean.IR.Checker.CheckerContext.localCtx,[]]
[Lean.Level.zero.inj,[]]
[Lean.Lsp.instInhabitedDiagnosticWith,[Inhabited.mk, Lean.Lsp.DiagnosticWith.mk, arbitrary]]
[Classical.indefiniteDescription,[Classical.choice, Classical.indefiniteDescription.proof_1]]
[Lean.LocalContext.findFromUserName?,[Std.PersistentArray.findSomeRev?, Lean.LocalContext.decls, Unit.unit, Option, Lean.LocalDecl, Option.none, ite, Eq, BEq.beq, Lean.LocalDecl.userName, Bool.true, Option.some]]
[Lean.IR.LitVal.str.inj,[]]
[Lean.Meta.SimpLemmas.eraseCore,[Pure.pure, Lean.Meta.SimpLemmas.mk, Lean.Meta.SimpLemmas.pre, Lean.Meta.SimpLemmas.post, Std.PersistentHashSet.erase, Lean.Meta.SimpLemmas.lemmaNames, Lean.Meta.SimpLemmas.toUnfold, Std.PersistentHashSet.insert, Lean.Meta.SimpLemmas.erased]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.bottomUps,[]]
[Lean.Server.Watchdog.FileWorker.erasePendingRequest,[ST.Ref.modify, Lean.Server.Watchdog.FileWorker.pendingRequestsRef, Std.RBMap.erase]]
[CommSemiring.toSemiring,[]]
[List.toSSet,[List.foldl, Lean.SSet.insert, Lean.SMap.mk]]
[Lean.Meta.MatcherApp.matcherName,[]]
[Lean.Elab.Term.StructInst.CtorHeaderResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.StructInst.CtorHeaderResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.NameSSet.insert,[Lean.SSet.insert]]
[Lean.Parser.Command.nonrec,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Lean.Widget.TaggedText.tag.inj,[And.intro]]
[Lean.Expr.bvar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.mkApp5,[Lean.mkApp, Lean.mkApp4]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.args,[]]
[List.mapIdxM,[OfNat.ofNat, List.mapIdxM.loop]]
[Lean.getPPAnalysisNeedsType,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false]]
[Lean.ProjectionFunctionInfo.numParams,[]]
[Function.injective.ne_iff,[Iff.intro, mt, congr_arg, Function.injective.ne]]
[Lean.Parser.Tactic.fconstructor,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Array.forRevM,[Array.foldrM, PUnit.unit]]
[Lean.Elab.Deriving.mkInstanceCmds,[Bind.bind, ForIn.forIn, ite, Eq, Array.contains, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, Bool.true, Lean.Elab.Deriving.mkInductArgNames, Lean.Elab.Deriving.mkImplicitBinders, Lean.Elab.Deriving.mkInstImplicitBinders, Lean.Elab.Deriving.mkInductiveApp, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkIdent, List.nil, Lean.Syntax.atom, PUnit.unit, ForInStep.yield]]
[false_or,[propext, Iff.intro, False.elim, Or.inr]]
[Array.shrink,[HSub.hSub, Array.size, Array.shrink.loop]]
[Lean.Lsp.ServerCapabilities.semanticTokensProvider?,[]]
[Lean.Elab.DefViewElabHeader.levelNames,[]]
[Or.intro_right,[Or.inr]]
[UInt16.zero_def,[rfl]]
[Lean.Server.FileWorker.CancelToken.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Server.FileWorker.CancelToken.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.ToExpr.toExpr,[]]
[Lean.InductiveVal.isReflexiveEx,[Lean.InductiveVal.isReflexive]]
[Mathlib.Tactic.Lint.LintVerbosity.noConfusionType,[noConfusionTypeEnum, Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx]]
[Nat.le_div_iff_mul_le,[Nat.mod.inductionOn, Eq.mpr, Eq.refl, Iff, LE.le, HDiv.hDiv, HMul.hMul, Nat.div_eq, congrFun, congrArg, Eq.trans, ite_congr, congr, And, eq_true, eq_true_of_decide, Bool.true, HAdd.hAdd, HSub.hSub, OfNat.ofNat, ite_true, of_eq_true, Nat.zero_eq, Nat.zero_le, Nat.zero_mul, Eq.symm, Nat.succ, Nat.add_one, propext, Nat.add_le_add_iff_le_right, Nat.succ_mul, Nat.add_sub_cancel, Nat.sub_le_sub_right_iff, And.right, Iff.rfl, eq_false, ite_false, Nat.not_succ_le_zero, Nat.add_comm, false_iff, not_le, Nat.lt_of_lt_of_le, Iff.mp, And.intro, Nat.le_add_right]]
[Nat.coprime.coprime_dvd_right,[Nat.coprime.symm, Nat.coprime.coprime_dvd_left]]
[tacticAssumption',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Name.instDecidableRelLtNameHasLtQuick,[inferInstanceAs, DecidableRel, Eq, Lean.Name.quickLt, Bool.true]]
[Union.union,[]]
[Lean.Meta.DiscrTree.instToFormatDiscrTree,[Std.ToFormat.mk, Lean.Meta.DiscrTree.format]]
[Std.HashMapImp.contains.proof_1,[Subtype.property]]
[Lean.Lsp.instToJsonCompletionItem,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.CompletionItem.label, List.nil, Lean.Json.opt, Lean.Lsp.CompletionItem.detail?, Lean.Lsp.CompletionItem.documentation?]]
[Lean.Parser.mkParserOfConstantUnsafe,[Bind.bind, MonadReader.read, Unit.unit, Lean.ImportM, Prod, Bool, Lean.Parser.Parser, Lean.Environment.find?, MonadExcept.throw, coe, HAppend.hAppend, ToString.toString, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Name.anonymous, Lean.Name.str, dite, Eq, Eq.symm, Lean.Name.num, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.ConstantInfo.type, liftM, IO.ofExcept, Lean.Environment.evalConst, Pure.pure, Prod.mk, Bool.false, Bool.true, Lean.ParserDescr, Lean.TrailingParserDescr]]
[Lean.PrettyPrinter.delab,[Bind.bind, Lean.PrettyPrinter.delabCore, Lean.Meta.MetaM, Lean.Syntax, Pure.pure]]
[Lean.Elab.Tactic.evalOpen,[tryFinally, Bind.bind, Lean.pushScope, Lean.Elab.OpenDecl.elabOpenDecl, Lean.Syntax.getOp, OfNat.ofNat, withTheReader, Lean.Core.Context, Lean.Core.Context.mk, Lean.Core.Context.options, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats, Lean.Elab.Tactic.evalTactic, Lean.popScope]]
[Lean.Parser.Term.doubleQuotedName,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.checkNoWsBefore, Lean.Parser.rawCh, Char.ofNat, Bool.false, Lean.Parser.Term.ident]]
[Lean.Parser.Tactic.hGeneralize,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.binderIdent, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser]]
[Array.toArrayLit_eq,[sorryAx, Eq, Array.toArrayLit, Bool.false]]
[Lean.EnvExtensionInterface.inhabitedExt,[]]
[Lean.TheoremVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.MData.empty,[Lean.KVMap.mk]]
[Lean.Expr.fvar.inj,[And.intro]]
[Lean.EnvExtensionInterfaceUnsafe.registerExt,[Bind.bind, Lean.initializing, ite, Eq, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, IO.userError]]
[Lean.Syntax.toNat,[Unit.unit, Nat, Lean.Syntax.isNatLit?, OfNat.ofNat]]
[instInhabitedFloat,[Inhabited.mk, Float.mk, FloatSpec.val, floatSpec]]
[Lean.Parser.Command.mixfix.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.attrKind.parenthesizer, Lean.Parser.Command.mixfixKind.parenthesizer, Lean.Parser.precedence.parenthesizer, Lean.Parser.Command.optNamedName.parenthesizer, Lean.Parser.Command.optNamedPrio.parenthesizer, Lean.Parser.ppSpace.parenthesizer, Lean.Parser.strLit.parenthesizer, Lean.Parser.darrow.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[ExceptCpsT.instLawfulMonadExceptCpsT,[ExceptCpsT.instLawfulMonadExceptCpsT.proof_1]]
[Lean.Elab.Term.StructInst.Struct.noConfusionType,[]]
[Lean.Meta.deltaExpand,[Lean.Core.transform, Bind.bind, Lean.Meta.delta?, Unit.unit, Lean.Core.CoreM, Lean.TransformStep, Pure.pure, Lean.TransformStep.visit, Lean.TransformStep.done]]
[ByteArray.mk.injEq,[Eq.propIntro, Eq.refl, ByteArray.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.ImportM,[ReaderT, Lean.ImportM.Context, IO]]
[IsMulRightCancel.mul_right_cancel,[]]
[Int.decEq.proof_3,[rfl]]
[Lean.Parser.Term.notFollowedByRedefinedTermToken,[Lean.Parser.notFollowedBy, HOrElse.hOrElse, Lean.Parser.symbol]]
[Lean.Module.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[not_of_not_imp,[mt, imp_intro]]
[Lean.Expr.bvar.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.bvar, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.isDelayedAssigned,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.isDelayedAssigned]]
[Lean.InternalExceptionId.mk.injEq,[Eq.propIntro, Eq.refl, Lean.InternalExceptionId.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.explicitRC,[Bind.bind, Lean.IR.getEnv, Pure.pure, Array.map, Lean.IR.ExplicitRC.visitDecl]]
[instOne,[One.mk, OfNat.ofNat]]
[Lean.markNoConfusion,[Lean.TagDeclarationExtension.tag, Lean.noConfusionExt]]
[ReaderT.instAlternativeReaderT,[Alternative.mk, ReaderT.failure, ReaderT.orElse]]
[Div.noConfusionType,[]]
[Lean.Lsp.LeanFileProgressProcessingInfo.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.LeanFileProgressProcessingInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.instToJsonDiagnosticWith,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.DiagnosticWith.range, List.nil, Lean.Lsp.DiagnosticWith.fullRange, Lean.Json.opt, Lean.Lsp.DiagnosticWith.severity?, Lean.Lsp.DiagnosticWith.code?, Lean.Lsp.DiagnosticWith.source?, Lean.Lsp.DiagnosticWith.message, Lean.Lsp.DiagnosticWith.tags?, Lean.Lsp.DiagnosticWith.relatedInformation?]]
[forall₃_congr,[forall_congr', forall₂_congr]]
[Std.instEmptyCollectionRBMap,[EmptyCollection.mk, Std.RBMap.empty]]
[Lean.Parser.Tactic.decide.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.nonReservedSymbol.parenthesizer, Bool.false]]
[Lean.Lsp.TextDocumentPositionParams.textDocument,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isHigherOrder,[Lean.Meta.forallTelescopeReducing, Pure.pure, and, Decidable.decide, GT.gt, Array.size, OfNat.ofNat, Lean.Expr.isSort]]
[Option.isEqSome,[Bool, BEq.beq, Bool.false]]
[Lean.instForInMVarIdSetMVarId,[inferInstanceAs, ForIn, Std.RBTree, Lean.MVarId, Lean.Name.quickCmp, Lean.MVarId.name]]
[Lean.Elab.Term.MutualClosure.LetRecClosure.noConfusionType,[]]
[Lean.Lsp.SymbolKind.noConfusion,[noConfusionEnum, Lean.Lsp.SymbolKind.toCtorIdx]]
[«stx_,*,?»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Lean.Meta.GeneralizeIndicesSubgoal.mk.inj,[And.intro]]
[Lean.Meta.cases,[Lean.Meta.Cases.cases]]
[Lean.Lsp.InitializeParams.processId?,[]]
[Lean.Lsp.SaveOptions.mk.inj,[]]
[Lean.Parser.Syntax.subPrio,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.Term.synthesizeInst,[Bind.bind, liftM, Lean.Meta.instantiateMVars, Lean.Meta.trySynthInstance, Option.none, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr]]
[Std.RBNode.balRight,[Std.RBNode.leaf, Std.RBNode.node, Std.Rbcolor.black, Std.RBNode, Std.Rbcolor.red, Std.RBNode.balance₃, Std.RBNode.setRed]]
[Lean.Elab.checkSyntaxNodeKindAtNamespaces,[Unit.unit, Lean.Name.str, Lean.Name.num, Lean.Name, HOrElse.hOrElse, Lean.Elab.checkSyntaxNodeKind, HAppend.hAppend, PProd.fst, Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.Syntax.mkNameLit,[Lean.Syntax.mkLit, Lean.nameLitKind]]
[Lean.Meta.instReduceEvalString,[Lean.Meta.ReduceEval.mk, Bind.bind, Lean.Meta.whnf, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.natVal, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, String, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr]]
[Or.left_comm,[Iff.trans, Iff.symm, Or.assoc, or_congr, Or.comm, Iff.refl]]
[Quotient.lift₂.proof_1,[Setoid.refl]]
[Lean.Elab.Term.elabParen,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.Elab.Term.withSynthesize, Lean.Elab.Term.elabType, Lean.Elab.Term.elabTerm, Option.some, Lean.Elab.Term.ensureHasType, Option.none, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Xml.Parser.NDataDecl,[SeqLeft.seqLeft, SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Parsec.skipString, Lean.Xml.Parser.Name]]
[Lean.Elab.Term.Quotation.Precheck.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.FieldInfo.format,[Lean.Elab.ContextInfo.runMetaM, Lean.Elab.FieldInfo.lctx, Bind.bind, Lean.Meta.inferType, Lean.Elab.FieldInfo.val, Lean.Meta.ppExpr, Pure.pure, HAppend.hAppend, Std.ToFormat.format, Lean.Elab.FieldInfo.fieldName, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Std.Format, Lean.Elab.FieldInfo.stx]]
[Lean.Parser.Tactic.intros,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[Lean.Module.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Module.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.ParserState.mkError,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Array.push, Lean.Syntax.missing, Option.some, Lean.Parser.Error.mk, List.cons, List.nil]]
[Lean.LocalContext.foldr,[Id.run, Lean.LocalContext.foldrM]]
[Lean.Elab.DefViewElabHeader.declName,[]]
[Lean.Parser.mkAntiquotSplice,[Lean.Parser.leadingNode, Lean.Parser.maxPrec, Lean.Parser.atomic, HAndThen.hAndThen, Lean.Parser.setExpected, List.nil, Lean.Parser.symbol, Lean.Parser.manyNoAntiquot, Lean.Parser.checkNoWsBefore, Lean.Parser.node, Lean.nullKind]]
[Lean.Elab.Tactic.evalIntro,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Lean.Syntax.getId, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, List.nil, Lean.Elab.Tactic.evalTactic, GE.ge, Lean.Syntax.getNumArgs, Array.append, Lean.Elab.throwUnsupportedSyntax, Lean.Elab.Tactic.evalIntro.introStep]]
[Lean.Compiler.foldNatDecLt,[Lean.Compiler.foldNatBinPred, Lean.Compiler.mkNatLt, Decidable.decide, LT.lt]]
[IO.FS.Stream.readLspMessage,[MonadExcept.tryCatch, Bind.bind, Unit.unit, IO, Nat, List.lookup, String.toNat?, Pure.pure, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, IO.FS.Stream.readMessage]]
[Std.rbmapOf,[Std.RBMap.fromList]]
[Lean.Parser.Term.matchAlt.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ppIndent.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Bool.false, Lean.Parser.darrow.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGe.parenthesizer]]
[List.instSetoidList,[Setoid.mk, List.Perm, List.Perm.Equivalence]]
[Lean.Parser.Term.sort.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.checkWsBefore.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.PrettyPrinter.Formatter.checkColGt.formatter, Lean.Parser.levelParser.formatter, Lean.Parser.maxPrec]]
[Lean.Meta.Simp.Config.zeta,[]]
[Lean.Parser.Term.let_tmp,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, Lean.Parser.symbol, Lean.Parser.Term.letDecl, Lean.Parser.Term.optSemicolon, Lean.Parser.termParser, OfNat.ofNat]]
[Lean.Expr.FindImpl.findM?.visit,[Bind.bind, liftM, Lean.Expr.FindImpl.visited, ite, Eq, Bool.true, Alternative.failure, Pure.pure, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lit, OptionT, Lean.Expr.FindImpl.FindM, Lean.Expr, HOrElse.hOrElse, Lean.Expr.FindImpl.findM?.visit]]
[Lean.IR.IRType.irrelevant.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.CollectFVars.instInhabitedState,[Inhabited.mk, Lean.CollectFVars.State.mk, arbitrary]]
[left_distributive,[Eq]]
[Alternative.toApplicative,[]]
[Lean.Meta.Match.proveCondEqThm,[Bind.bind, Lean.Meta.instantiateMVars, Lean.Meta.withLCtx, Lean.LocalContext.mk, EmptyCollection.emptyCollection, Lean.Meta.forallTelescope, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Name.anonymous, Lean.Meta.deltaTarget, Lean.Expr.mvarId!, BEq.beq, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MessageData.ofGoal, Pure.pure, PUnit.unit, Lean.Meta.Match.proveCondEqThm.go]]
[Lean.Parser.Term.matchDiscr.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.PrettyPrinter.Formatter.evalInsideQuot.formatter, Lean.Parser.Term.matchDiscr.formatter]]
[Lean.Lsp.instToJsonWorkspaceFolder,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.WorkspaceFolder.uri, List.nil, Lean.Lsp.WorkspaceFolder.name]]
[Lean.Elab.Command.MkInstanceName.isFirst,[Bind.bind, MonadState.get, Pure.pure, BEq.beq]]
[Lean.Lsp.SymbolKind.interface.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[and_not_self,[False]]
[Lean.IR.instToStringExpr,[ToString.mk, Std.Format.pretty, Std.ToFormat.format, Std.Format.defWidth]]
[Lean.Server.Snapshots.Snapshot.stx,[]]
[Lean.Elab.Term.Do.ToCodeBlock.Context.insideFor,[]]
[Lean.Meta.Match.MatcherInfo.noConfusionType,[]]
[Lean.Server.Snapshots.Snapshot.diagnostics,[Std.PersistentArray.map, Lean.Widget.InteractiveDiagnostic.toDiagnostic, Lean.Server.Snapshots.Snapshot.interactiveDiags]]
[exists_unique_of_exists_of_unique,[Exists.elim, ExistsUnique.intro]]
[Lean.Json.Parser.any,[Bind.bind, Lean.Parsec.ws, Lean.Json.Parser.anyCore, Unit.unit, Lean.Parsec.eof, Pure.pure]]
[Float.val,[]]
[Lean.Elab.Term.StructInst.FieldLHS.fieldName.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.Formatter.instCoeArrowFormatterArrowFormatterFormatterFormatterAliasValue,[Coe.mk, Lean.Parser.AliasValue.binary]]
[Lean.KVMap.getName,[Option.none, Option.some, Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Lean.Name, Lean.KVMap.find]]
[Lean.Meta.DiscrTree.Key.other.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Fin.subUnderflows?,[Decidable.decide, LT.lt, Fin.val]]
[measure,[invImage, Nat.lt_wfRel]]
[Lean.Meta.registerGetUnfoldEqnFn,[Bind.bind, Lean.initializing, ite, Eq, Bool.true, Pure.pure, PUnit.unit, MonadExcept.throw, IO.userError]]
[Lean.Elab.Tactic.State.mk.inj,[]]
[Lean.PersistentEnvExtension.modifyState,[Lean.EnvExtension.modifyState, Lean.PersistentEnvExtension.toEnvExtension, Lean.PersistentEnvExtensionState.mk, Lean.PersistentEnvExtensionState.importedEntries, Lean.PersistentEnvExtensionState.state]]
[Lean.Meta.smartUnfoldingMatchAlt?,[Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Elab.Structural.EqnInfo.recArgPos,[]]
[Lean.Meta.mkFreshExprSyntheticOpaqueMVar,[Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.syntheticOpaque]]
[Lean.Meta.SimpLemmas.erased,[]]
[UInt8.noConfusionType,[]]
[Lean.Elab.Term.Do.hasReturn,[Lean.Elab.Term.Do.hasExitPointPred, Lean.Elab.Term.Do.Code.decl, Lean.Elab.Term.Do.Code.reassign, Lean.Elab.Term.Do.Code.joinpoint, Lean.Elab.Term.Do.Code.seq, Lean.Elab.Term.Do.Code.action, Lean.Elab.Term.Do.Code.break, Lean.Elab.Term.Do.Code.continue, Lean.Elab.Term.Do.Code.ite, Lean.Elab.Term.Do.Code.match, Lean.Elab.Term.Do.Code.jmp, Bool, Bool.true, Bool.false]]
[Lean.Parser.Term.scoped.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.Elab.throwUnsupportedSyntax,[MonadExcept.throw, Lean.Exception.internal, Lean.Elab.unsupportedSyntaxExceptionId, Lean.KVMap.mk]]
[left_commutative,[Eq]]
[Lean.IR.LocalContextEntry.localVar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.instInhabitedExpr,[Inhabited.mk, Lean.Expr.bvar, arbitrary]]
[Equiv.rightInv,[]]
[Lean.Parser.Term.bracketedBinder,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.none, Bool.false, HOrElse.hOrElse, Lean.Parser.Term.explicitBinder, Lean.Parser.Term.strictImplicitBinder, Lean.Parser.Term.implicitBinder, Lean.Parser.Term.instBinder]]
[Lean.Parser.Tactic.compVal,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Std.PersistentArray.Stats.tailSize,[]]
[Lean.Elab.Term.Do.Code.match.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, Eq.refl, List.nil, congr, Lean.Elab.Term.Do.Alt.mk, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec]]
[Lean.Parser.quotedCharCoreFn,[ite, Eq, String.atEnd, Bool.true, Lean.Parser.ParserState.mkEOIError, List.nil, Lean.Parser.ParserState.next, BEq.beq, Char.ofNat, Lean.Parser.andthenFn, Lean.Parser.hexDigitFn, Lean.Parser.ParserState.mkUnexpectedError]]
[Lean.MessageDataContext.opts,[]]
[Lean.Expr.updateLet,[Lean.mkLet, Lean.Expr.letName!, Bool.false]]
[Lean.Declaration.thmDecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.strLit.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.strLitKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.strLitNoAntiquot.parenthesizer]]
[Mathlib.Tactic.Ext.mkIff,[Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[UInt16.instAddSemigroupUInt16,[AddSemigroup.mk, UInt16.instAddSemigroupUInt16.proof_1]]
[Lean.Parser.Command.identScope,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.cat, OfNat.ofNat]]
[SubNegMonoid.gsmul_neg',[]]
[Lean.Meta.mkForallCongr,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil]]
[List.count,[List.countp, Eq]]
[Lean.Elab.Term.reportMatcherResultErrors,[ite, Eq, List.isEmpty, Lean.Meta.Match.MatcherResult.counterExamples, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.withHeadRefOnly, Lean.Elab.logError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.Match.counterExamplesToMessageData]]
[Lean.Elab.Tactic.Conv.evalWhnf,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.Conv.getLhs, liftM, Lean.Meta.whnf, Lean.Elab.Tactic.Conv.changeLhs]]
[Lean.Parser.Command.init_quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.Elab.Term.CollectPatternVars.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.DocumentMeta.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Quotation.HeadCheck.other.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.IndPredBelow.BrecOnVariables.indices,[]]
[Array.getOp,[Array.get!]]
[Lean.Elab.Term.MkInstResult.noConfusionType,[]]
[UInt64.instRingUInt64.proof_5,[UInt64.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, UInt64.val, congrFun, HAdd.hAdd, UInt64.neg_def, UInt64.add_def, UInt64.mk, Neg.neg, add_left_neg, UInt64.zero_def, eq_true_of_decide, Eq.refl, Bool.true]]
[Lean.Server.Watchdog.handleDidOpen,[Lean.Server.Watchdog.startFileWorker, Lean.Server.DocumentMeta.mk, Lean.Lsp.TextDocumentItem.uri, Lean.Lsp.TextDocumentItem.version, String.toFileMap, Lean.Lsp.TextDocumentItem.text]]
[guardExprStrict,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[Lean.Parser.rawIdent.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.identKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.rawIdentNoAntiquot.parenthesizer]]
[Lean.mkBInductionOn,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.MonadEnv.modifyEnv, Lean.throwKernelException, Lean.mkBInductionOnImp]]
[Nat.coprime_div_gcd_div_gcd,[Eq.mpr, Eq.refl, Nat.coprime, HDiv.hDiv, Nat.gcd, propext, Nat.coprime_iff_gcd_eq_one, Eq, OfNat.ofNat, Nat.gcd_div, Nat.gcd_dvd_left, Nat.gcd_dvd_right, Nat.div_self, rfl]]
[Lean.PrettyPrinter.Formatter.FormatterAliasValue,[Lean.Parser.AliasValue, Lean.PrettyPrinter.Formatter]]
[Lean.Elab.Term.Quotation.getPatternsVars,[Array.foldlM, Bind.bind, Lean.Elab.Term.Quotation.getPatternVars, Pure.pure, HAppend.hAppend, List.toArray, List.nil, OfNat.ofNat, Array.size]]
[Lean.InductiveVal.noConfusionType,[]]
[Lean.IR.formatAlt,[Std.Format, HAppend.hAppend, Std.ToFormat.format, Lean.IR.CtorInfo.name, Std.Format.text, Std.Format.nest, Int.ofNat, Std.Format.line]]
[Lean.Parser.Command.parameter,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[Nat.gcd_mul_left,[Nat.gcd.induction, of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, Nat.gcd, Nat.mul_zero, HMul.hMul, Nat.gcd_zero_left, eq_self, Eq.mp, Eq.refl, HMod.hMod, Eq.symm, Nat.gcd_rec, Nat.mul_mod_mul_left]]
[Lean.Lsp.instFromJsonTypeDefinitionParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.TypeDefinitionParams.mk, Lean.Lsp.TextDocumentPositionParams.mk]]
[And.congr_left_iff,[Eq.mpr, congrArg, Iff, And, Eq.trans, Eq.symm, propext, And.congr_right_iff, congr, and_comm, Iff.rfl]]
[Lean.Parser.ppSpace,[Lean.Parser.skip]]
[Lean.Elab.CompletionInfo.namespaceId.inj,[]]
[Lean.Elab.Term.LetRecDeclView.noConfusionType,[]]
[Lean.Elab.Tactic.ElimApp.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.LogEntry.fmt,[Std.Format, HAppend.hAppend, Std.Format.bracket, Std.ToFormat.format, Array.foldl, Std.Format.line, Std.Format.nil, OfNat.ofNat, Array.size]]
[List.mem_filterAux,[Iff, Mem.mem, List.filterAux, Or, And, Eq, Bool.true, of_eq_true, Eq.trans, congr, congrArg, propext, List.mem_reverse, congrFun, List.mem_nil_iff, false_and, false_or, iff_self, Eq.mpr, Unit.unit, List, List.cons, List.mem_cons_iff, PProd.fst, Iff.intro, Or.inl, And.intro, Or.inr, And.left, And.right, Eq.symm, Eq.refl, Eq.mp, Bool.false]]
[Lean.Parser.Term.matchDiscr.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Term.ident.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter]]
[Decidable.not_or_of_imp,[dite, Or.inr, Or.inl]]
[Lean.Parser.Command.localized,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.ParserDescr.cat]]
[Function.Equiv.refl,[rfl]]
[Lean.Elab.Modifiers.visibility,[]]
[Lean.Widget.GetInteractiveDiagnosticsParams.mk.inj,[]]
[Lean.Elab.Tactic.tryTactic?,[MonadExcept.tryCatch, Bind.bind, Pure.pure, Option.some, Option.none]]
[Lean.Elab.Deriving.mkLet,[Array.foldrM, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.size, OfNat.ofNat]]
[Subtype.map_comp,[rfl]]
[Lean.Parser.ParserCategories,[Std.PersistentHashMap, Lean.Name, Lean.Parser.ParserCategory]]
[Std.HashMapImp.reinsertAux,[Std.HashMapBucket, Std.HashMapBucket.update, Std.AssocList.cons, Array.uget, Subtype.val]]
[Lean.Parser.Command.eval.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter]]
[Lean.indentD,[Lean.MessageData.nestD, HAppend.hAppend, Lean.MessageData.ofFormat, Std.Format.line]]
[Lean.Parser.Term.explicit,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.maxPrec]]
[min_le_right,[dite, LE.le, Eq.mpr, congrFun, congrArg, if_pos, of_eq_true, Eq.trans, if_neg, eq_true, le_refl]]
[«term_-_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Function.hfunext,[]]
[Lean.Elab.Term.FunBinders.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.FunBinders.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Match.MkMatcherInput.lhss,[]]
[Lean.Server.RequestM.mapTask,[Bind.bind, liftM, EIO.mapTask, Task.Priority.default, Pure.pure, Task.map, liftExcept]]
[Lean.addTrace,[Bind.bind, Lean.MonadRef.getRef, Lean.AddMessageContext.addMessageContext, Lean.modifyTraces, Std.PersistentArray.push, Lean.TraceElem.mk, Lean.MessageData.tagged, HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ToMessageData.toMessageData, Lean.addTrace.addTraceOptions]]
[Lean.Parser.Tactic.splitIfs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location, Lean.ParserDescr.symbol, Lean.binderIdent]]
[Lean.ClassEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instAndOpUSize,[AndOp.mk, USize.land]]
[Function.surjective.prod_map,[Exists, Eq, Prod.map, Exists.intro, Prod.mk, Prod.ext']]
[Lean.Meta.forallTelescopeCompatible,[controlAt, Lean.Meta.MetaM, Lean.Meta.forallTelescopeCompatibleAux, List.toArray, List.nil]]
[Lean.Compiler.foldUnOp,[OptionM.run, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, OptionM, Lean.Expr, Bind.bind, Lean.Compiler.findUnFoldFn, Alternative.failure]]
[Lean.PrettyPrinter.Formatter.setExpected.formatter,[]]
[System.mkFilePath,[System.FilePath.mk, String.intercalate, Char.toString, System.FilePath.pathSeparator]]
[Array.anyMUnsafe,[ite, LT.lt, LE.le, Array.size, USize.ofNat, Pure.pure, Bool.false, Array.anyMUnsafe.any]]
[Lean.IR.IRType.struct.inj,[And.intro]]
[Lean.Parser.Tactic.mono,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser, Lean.Parser.Tactic.mono.side, Lean.ParserDescr.sepBy1, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.simpArg]]
[Lean.Elab.Term.mkTermElabAttributeUnsafe,[Lean.Elab.mkElabAttribute, Lean.Elab.Term.TermElab, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Elab.Command.elabExportPrivate,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Parser.Term.termTry.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.doSeq.formatter, Lean.Parser.many.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.doCatch.formatter, Lean.Parser.Term.doCatchMatch.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.doFinally.formatter]]
[Lean.Elab.Term.expandOptPrecedence,[ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, Option.none, Bind.bind, Lean.evalPrec, Lean.Syntax.getOp, OfNat.ofNat, Option.some]]
[Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.alts,[]]
[max_assoc,[eq_max, le_trans, le_max_left, max, max_le, le_max_right]]
[Subtype.mk_eq_mk,[Subtype.ext_iff]]
[Lean.Server.FileWorker.WorkerContext.hLog,[]]
[Lean.instMonadLiftImportMAttrM,[MonadLift.mk, Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, liftM, Lean.ImportM.Context.mk]]
[Lean.KeyedDeclsAttribute.Def.onAdded,[]]
[Lean.Lsp.DocumentSymbolAux.mk.inj,[And.intro]]
[Lean.Elab.MonadMacroAdapter.getCurrMacroScope,[]]
[Lean.Elab.Info.ofFieldInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.ParserState.keepLatest,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Lean.Parser.ParserState.keepTop, Option.none]]
[EStateM.dummySave,[PUnit.unit]]
[instInhabitedSort,[Inhabited.mk, PUnit]]
[Decidable.by_cases,[Decidable.byCases]]
[Lean.Meta.elimOptParam,[Lean.Core.transform, ite, Eq, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Bool.true, Pure.pure, Lean.TransformStep.visit, Lean.Expr.getArg!, Lean.Expr.getAppNumArgs, Lean.TransformStep.done]]
[instOfNatUInt32,[OfNat.mk, UInt32.ofNat]]
[IO.Error.noSuchThing.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.noSuchThing, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.toSuperscriptString,[List.asString, Nat.toSuperDigits]]
[Lean.ParametricAttribute.mk.inj,[And.intro]]
[Equiv.trans.proof_2,[Function.right_inverse.comp, Equiv.rightInv]]
[Lean.Parser.ParserExtension.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.ParserExtension.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Command.addUnivLevel,[Lean.withRef, Bind.bind, Lean.Elab.Command.getLevelNames, ite, Eq, List.elem, Bool.true, Lean.Elab.throwAlreadyDeclaredUniverseLevel, Lean.Elab.Command.modifyScope, Lean.Elab.Command.Scope.mk, Lean.Elab.Command.Scope.header, Lean.Elab.Command.Scope.opts, Lean.Elab.Command.Scope.currNamespace, Lean.Elab.Command.Scope.openDecls, List.cons, Lean.Elab.Command.Scope.levelNames, Lean.Elab.Command.Scope.varDecls, Lean.Elab.Command.Scope.varUIds, Lean.Elab.Command.Scope.isNoncomputable]]
[Lean.Declaration.defnDecl.injEq,[Eq.propIntro, Eq.refl, Lean.Declaration.defnDecl, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.instInhabitedInductiveVal,[Inhabited.mk, Lean.InductiveVal.mk, arbitrary]]
[Lean.Parser.Error.expected,[]]
[Function.combine,[]]
[Lean.Name.str.inj,[And.intro]]
[Lean.Parser.checkLinebreakBeforeFn,[ite, Eq, Lean.Parser.checkTailLinebreak, Bool.true, Lean.Parser.ParserState.mkError]]
[Lean.getOptionDefaulValue,[Bind.bind, Lean.getOptionDecl, Pure.pure, Lean.OptionDecl.defValue]]
[Lean.mkApp2,[Lean.mkAppB]]
[Lean.PPContext.opts,[]]
[Lean.Lsp.DiagnosticWith.noConfusionType,[]]
[Lean.Server.DocumentMeta.noConfusionType,[]]
[Nat.div_eq,[congrFun, WellFounded.fix_eq, WellFoundedRelation.wf, measure, id, dite, And, LT.lt, OfNat.ofNat, LE.le, HAdd.hAdd, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le, Nat.zero, dif_eq_if, HDiv.hDiv]]
[StateRefT'.instAlternativeStateRefT',[inferInstanceAs, Alternative, ReaderT, ST.Ref]]
[Lean.Elab.DefView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.Watchdog.GroupedEdits.noConfusionType,[]]
[Lean.Elab.Term.getMVarErrorInfo?,[Bind.bind, MonadState.get, Pure.pure, Std.RBMap.find?, Lean.Elab.Term.State.mvarErrorInfos]]
[Lean.Elab.Term.Quotation.Precheck.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.Quotation.Precheck.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.instInhabitedDefView,[Inhabited.mk, Lean.Elab.DefView.mk, arbitrary]]
[Lean.Parser.Command.postfix,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Lean.Lsp.RpcConnected.sessionId,[]]
[Lean.Elab.Term.withoutModifyingElabMetaStateWithInfo,[Bind.bind, MonadState.get, getThe, Lean.Meta.State, tryFinally, Lean.Elab.withSaveInfoContext, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState, MonadStateOf.set]]
[Lean.Attribute.Builtin.getId?,[Bind.bind, Lean.Attribute.Builtin.getIdent?, Pure.pure, Functor.map, Lean.Syntax.getId]]
[Lean.Lsp.instFileSourceWaitForDiagnosticsParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.WaitForDiagnosticsParams.uri]]
[Lean.instFVarIdHashSetInhabited,[Std.HashSet.instInhabitedHashSet]]
[Lean.Module.header,[]]
[Subarray.start,[]]
[Lean.Parser.Attr.intro!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Name.num.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Name.num, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.IndPredBelow.mkCtorType.rebuild,[Lean.Expr.withApp, Lean.Meta.IndPredBelow.Variables.innerType, Bind.bind, Lean.Meta.mkForallFVars, Lean.Meta.IndPredBelow.Variables.target, Bool.false, Bool.true, Pure.pure, Lean.Meta.IndPredBelow.mkCtorType.replaceTempVars]]
[Lean.Elab.Term.LValResolution.const.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LValResolution.const, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.SizeOfSpecNested.main,[Bind.bind, liftM, Lean.Meta.isDefEq, ite, Eq, Bool.true, Lean.Meta.mkEqRefl, Lean.Meta.whnfI, Lean.Meta.unfoldDefinition, Lean.Meta.SizeOfSpecNested.main.loop, Lean.Meta.SizeOfSpecNested.main.step]]
[Lean.Elab.Command.elabReduce,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.withoutModifyingEnv, Lean.Elab.Command.runTermElabM, Option.some, Bind.bind, Lean.Elab.Term.elabTerm, Option.none, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Bool.false, liftM, Lean.Meta.instantiateMVars, Lean.Elab.Term.levelMVarToParam, OfNat.ofNat, Lean.Elab.Term.TermElabM, Unit, withTheReader, Lean.Core.Context, Lean.Core.Context.mk, Lean.KVMap.setBool, Lean.Core.Context.options, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats, Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.all, Lean.Meta.reduce, Lean.Elab.logInfoAt, Lean.MessageData.ofExpr, Lean.Elab.throwUnsupportedSyntax]]
[ne_false_of_eq_true,[Not, Eq, Bool.false]]
[Lean.ProjectionFunctionInfo.mk.inj,[And.intro]]
[instLTUInt8,[LT.mk, UInt8.lt]]
[Lean.Elab.Tactic.ElimApp.evalAlts.go,[Bind.bind, ForIn.forIn, MProd.mk, Lean.Elab.Tactic.TacticM, ForInStep, MProd, Array, Lean.MVarId, Lean.Syntax, Bool, liftM, Option.none, PUnit.unit, ite, Eq, BEq.beq, Lean.Meta.ElimAltInfo.name, Bool.true, Pure.pure, ForInStep.done, Option.some, Lean.Meta.ElimAltInfo.numFields, ForInStep.yield, Unit.unit, Lean.Elab.Term.TermElabM, Nat, MProd.fst, Array.findIdx?, Lean.Syntax.hasArgs, Lean.Syntax.getOp, OfNat.ofNat, Lean.Name.eraseMacroScopes, Lean.Syntax.getId, Lean.Name.mkStr, Lean.Name.anonymous, Array.getOp, Unit]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Std.RBMap.find?,[Option, Std.RBNode.find]]
[Mathlib.ExtendedBinder.«binderTerm≤_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.ParserContext.mk.inj,[And.intro]]
[Lean.Lsp.TextDocumentSyncOptions.willSave,[]]
[ExceptT.pure,[ExceptT.mk, Pure.pure, Except.ok]]
[Lean.Parser.Term.doubleQuotedName.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.PrettyPrinter.Formatter.rawCh.formatter, Char.ofNat, Lean.Parser.Term.ident.formatter]]
[Lean.Expr.mkDataForLet,[ite, GT.gt, HSub.hSub, Nat.pow, OfNat.ofNat, panicWithPosWithDecl, Lean.BinderInfo.default]]
[Lean.Parser.Command.openOnly.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.ident.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter]]
[Lean.Meta.UnificationHint.pattern,[]]
[Lean.Meta.UnificationHints.noConfusionType,[]]
[Lean.Elab.Deriving.implicitBinderF,[Lean.Parser.Term.implicitBinder, Bool.false]]
[Lean.Parser.Tactic.safe,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.sepBy1]]
[Lean.Parser.Term.doIfLetBind.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter]]
[Lean.instInhabitedAttributeExtensionState,[Inhabited.mk, Lean.AttributeExtensionState.mk, arbitrary]]
[Lean.Elab.GoalsAtResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.Completion.find?,[IO, Option, Lean.Lsp.CompletionList, Option.none, Option.some, Prod.mk, Lean.Elab.Info.ofTacticInfo, Lean.Elab.Info.ofTermInfo, Lean.Elab.Info.ofCommandInfo, Lean.Elab.Info.ofMacroExpansionInfo, Lean.Elab.Info.ofFieldInfo, Lean.Elab.InfoTree.foldInfo, Lean.Elab.CompletionInfo.namespaceId, Lean.Elab.CompletionInfo.endSection, Lean.Elab.ContextInfo.runMetaM, Bind.bind, StateRefT'.run, OptionT.run, Lean.Server.Completion.State.mk, Lean.Meta.MetaM, Pure.pure, Lean.Lsp.CompletionList.mk, Bool.true, HAppend.hAppend, Array.qsort, Decidable.decide, LT.lt, Lean.Lsp.CompletionItem.label, OfNat.ofNat, HSub.hSub, Array.size, Lean.Server.Completion.State.itemsMain, Lean.Server.Completion.State.itemsOther, Lean.Elab.TermInfo.lctx, MonadExcept.tryCatch, liftM, Lean.Meta.inferType, Lean.Elab.TermInfo.expr, Lean.Meta.instantiateMVars, EmptyCollection.emptyCollection, Prod.snd, Lean.Server.Completion.HoverInfo.after, Lean.Server.Completion.M, Unit, PUnit.unit, Lean.LocalContext.mk, Lean.getOptionDecls, Lean.MonadOptions.getOptions, ForIn.forIn, ForInStep, Array, Lean.Lsp.CompletionItem, Lean.MonadEnv.getEnv, Lean.Server.Completion.find?.choose]]
[Int.ofNat.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[IO.FS.instInhabitedSystemTime,[Inhabited.mk, IO.FS.SystemTime.mk, arbitrary]]
[Lean.Parser.Tactic.caseArg,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.sepBy1, Lean.binderIdent, Lean.ParserDescr.symbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[Lean.Name.toString,[Lean.Name.toStringWithSep, and, not, Lean.Name.isInaccessibleUserName, Lean.Name.hasMacroScopes, Lean.Name.toString.maybePseudoSyntax]]
[Function.injective.has_left_inverse,[Exists.intro, Function.inv_fun, Function.left_inverse_inv_fun]]
[Lean.Expr.getAppFn,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, PProd.fst]]
[instHashableBool,[Hashable.mk, Unit.unit, UInt64, OfNat.ofNat]]
[Lean.Elab.Frontend.Context.mk.inj,[]]
[List.append_assoc,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HAppend.hAppend, List.cons_append, List.cons, eq_self]]
[Lean.MessageData.ofSyntax.inj,[]]
[Lean.Import.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Import.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Simp.discharge?,[Bind.bind, MonadReader.read, liftM, Lean.Meta.Simp.Methods.discharge?]]
[Lean.JsonRpc.ErrorCode.noConfusion,[noConfusionEnum, Lean.JsonRpc.ErrorCode.toCtorIdx]]
[Lean.Elab.Deriving.BEq.mkAuxFunction,[Bind.bind, Pure.pure, Array.getOp, Lean.Elab.Deriving.Context.auxFunNames, Lean.Elab.Deriving.Context.typeInfos, Lean.Elab.Deriving.BEq.mkBEqHeader, Lean.Elab.Deriving.BEq.mkMatch, ite, Eq, Lean.Elab.Deriving.Context.usePartial, Bool.true, Lean.Elab.Deriving.mkLocalInstanceLetDecls, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.Deriving.Header.argNames, Lean.Elab.Deriving.mkLet, PUnit.unit]]
[Lean.Parser.TrailingParser,[Lean.Parser.Parser]]
[Std.PersistentHashMap.erase,[Std.PersistentHashMap, Std.PersistentHashMap.mk, ite, Eq, Bool.true, HSub.hSub, OfNat.ofNat]]
[Lean.Elab.WF.TerminationHintValue.mk.inj,[And.intro]]
[Squash.ind,[Quot.ind]]
[Lean.Meta.instInhabitedDefaultInstances,[Inhabited.mk, Lean.Meta.DefaultInstances.mk, arbitrary]]
[Int.neg_ofNat_of_succ,[rfl]]
[funext,[]]
[Lean.Meta.instReduceEvalOption,[Lean.Meta.ReduceEval.mk, Bind.bind, Lean.Meta.whnf, Pure.pure, Lean.Expr.getAppFn, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Option, ite, Eq, and, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Bool.true, Option.none, Functor.map, Option.some, Lean.Meta.reduceEval, Lean.Expr.appArg!, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr]]
[Lean.Elab.MacroStackElem.after,[]]
[Lean.Elab.Command.elabInductiveViews,[Bind.bind, Lean.Elab.Command.runTermElabM, Option.some, Lean.Elab.Command.InductiveView.declName, Lean.withRef, Lean.Elab.Term.getLevelNames, ite, GT.gt, Array.size, OfNat.ofNat, ForIn.forIn, PUnit.unit, Eq, BEq.beq, Lean.Elab.Command.InductiveView.levelNames, Bool.true, Pure.pure, ForInStep.yield, Lean.throwErrorAt, Lean.Elab.Command.InductiveView.ref, Lean.ToMessageData.toMessageData, Lean.Elab.Term.withLevelNames, List.toArray, List.nil, Lean.Elab.Modifiers.isUnsafe, Lean.Elab.Command.InductiveView.modifiers, Lean.Elab.Command.ElabHeaderResult.view, Lean.Elab.Command.ElabHeaderResult.params, Option.none, Array.mapM, Lean.Meta.withLCtx, Lean.Elab.Command.ElabHeaderResult.lctx, Lean.Elab.Command.ElabHeaderResult.localInsts, liftM, Lean.Meta.mkForallFVars, Lean.Elab.Command.ElabHeaderResult.type, Bool.false, Prod.mk, Lean.Elab.Command.InductiveView.shortDeclName, Lean.Meta.inferType, Lean.Meta.forallTelescopeReducing, Decidable.decide, List.mapM, Lean.Elab.Term.withAutoBoundImplicit, Lean.Elab.Term.elabBinders, Lean.Syntax.getArgs, Lean.Elab.Command.CtorView.binders, Lean.Elab.Command.CtorView.ref, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Lean.Elab.Term.addAutoBoundImplicits, Lean.Constructor.mk, Lean.Elab.Command.CtorView.declName, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Constructor, Lean.Elab.Command.CtorView.type?, Lean.throwError, Lean.Elab.Term.elabType, Lean.Elab.Term.synthesizeSyntheticMVars, Lean.Meta.instantiateMVars, Lean.Meta.transform, Lean.TransformStep.done, Lean.Expr.getAppFn, HAppend.hAppend, Lean.indentExpr, Array.toList, Lean.Elab.Command.InductiveView.ctors, Lean.Level, Lean.InductiveType.type, Lean.Meta.whnfD, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Elab.Command.shouldInferResultUniverse, StateRefT'.run, List.forM, Lean.Meta.collectUsedFVars, Lean.InductiveType.ctors, Lean.Constructor.type, Lean.CollectFVars.State.mk, Prod, Lean.LocalContext, Lean.LocalInstances, Array, Lean.Expr, Lean.Meta.removeUnused, Lean.Constructor.name, Lean.InductiveType.mk, Lean.InductiveType.name, StateRefT'.run', Lean.Elab.Term.levelMVarToParam', Lean.Level.isParam, Lean.Elab.Command.checkResultingUniverse, Lean.Meta.mkSizeOfInstances, Lean.Meta.IndPredBelow.mkBelow, Lean.Meta.mkInjectiveTheorems, Lean.NameSet.contains, Lean.Elab.DerivingClassView.applyHandlers]]
[Lean.Parser.Command.moduleDoc.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.ppDedent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.commentBody.parenthesizer, Lean.Parser.ppLine.parenthesizer]]
[List.hasDecEq.proof_6,[absurd]]
[Lean.Expr.binderInfoEx,[Lean.Expr.binderInfo]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.subExpr,[]]
[Lean.Parser.Command.structImplicitBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Command.declModifiers.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.inferMod.parenthesizer, Lean.Parser.Command.declSig.parenthesizer]]
[«term_<||>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[USize.neg_def,[rfl]]
[em,[Classical.em]]
[IO.mapTasks,[EIO.mapTasks]]
[Lean.Elab.Term.withoutPostponingUniverseConstraints,[Bind.bind, liftM, Lean.Meta.getResetPostponed, MonadExcept.tryCatch, Lean.Meta.processPostponed, Bool.false, Bool.true, ite, Eq, Pure.pure, PUnit.unit, Lean.Meta.getPostponed, ForIn.forIn, MProd.mk, Lean.Level.normLt, Lean.Elab.Term.TermElabM, ForInStep, MProd, Std.HashSet, Prod, Lean.Level, Array, Lean.Meta.PostponedEntry, Unit, Lean.Meta.mkLevelStuckErrorMessage, Array.getOp, Lean.Elab.logErrorAt, Lean.Meta.PostponedEntry.ref, ForInStep.yield, OfNat.ofNat, Lean.throwErrorAt, Lean.Meta.setPostponed, MonadExcept.throw, DoResultPR.pure]]
[eq_iff_iff,[Iff.symm, iff_iff_eq]]
[Lean.Expr.app3?,[ite, Eq, Lean.Expr.isAppOfArity, OfNat.ofNat, Bool.true, Option.some, Prod.mk, Lean.Expr.appArg!, Lean.Expr.appFn!, Option.none]]
[Lean.ExprStructEq.mk.injEq,[Eq.propIntro, Eq.refl, Lean.ExprStructEq.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Do.ToTerm.mkUVarTuple,[Bind.bind, MonadReader.read, Array.mapM, Lean.mkIdentFromRef, Lean.Elab.Term.Do.ToTerm.Context.uvars, liftM, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Array.getOp, Array.foldrM, Array.back, Array.extract, HSub.hSub]]
[Lean.Parser.Command.postfix.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.NameTrie.forMatchingM,[Lean.PrefixTree.forMatchingM, List.nil, List, Lean.NamePart, PProd.fst, List.cons, Lean.NamePart.str, Lean.NamePart.num]]
[Lean.mkAnd,[Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Nat.not_le_of_lt,[Nat.not_le_of_gt]]
[Lean.Server.RequestContext.mk.inj,[And.intro]]
[Lean.Meta.CongrTheorem.proof,[]]
[Lean.Parser.Command.macroTail.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.macroTailTactic.parenthesizer, Lean.Parser.Command.macroTailCommand.parenthesizer, Lean.Parser.Command.macroTailDefault.parenthesizer]]
[Float.lt,[FloatSpec.lt, floatSpec]]
[Lean.Elab.Term.MutualClosure.insertReplacementForMainFns,[Nat.fold, Std.RBMap.insert, Lean.Expr.fvarId!, Array.getOp, Lean.mkAppN, Lean.mkConst, Lean.Elab.DefViewElabHeader.declName, List.nil, Array.size]]
[Lean.Meta.casesAnd,[Bind.bind, Lean.Meta.casesRec, Lean.Meta.instantiateMVars, Lean.LocalDecl.type, Pure.pure, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.Meta.exactlyOne, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[Int.le,[Int.NonNeg, HSub.hSub]]
[Lean.JsonRpc.instFromJsonNotification,[Lean.FromJson.mk, Bind.bind, Lean.FromJson.fromJson?, Lean.JsonRpc.Message.request, Lean.JsonRpc.Message.response, Lean.JsonRpc.Message.responseError, Except, String, Lean.JsonRpc.Notification, Pure.pure, Lean.ToJson.toJson, Lean.JsonRpc.Notification.mk, MonadExcept.throw]]
[Std.AssocList.cons.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.AssocList.cons, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.SynthInstance.instInhabitedGeneratorNode,[Inhabited.mk, Lean.Meta.SynthInstance.GeneratorNode.mk, arbitrary]]
[Lean.Elab.Command.checkValidInductiveModifier,[ite, Eq, Lean.Elab.Modifiers.isNoncomputable, Bool.true, Bind.bind, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Eq.mpr_prop,[Eq.symm]]
[termSudoSet_option___In_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Nat.not_lt_zero,[Nat.not_succ_le_zero]]
[Ordering.noConfusionType,[noConfusionTypeEnum, Ordering.toCtorIdx]]
[Nat.ne_of_beq_eq_false,[False]]
[Lean.Elab.goalsToMessageData,[Lean.MessageData.joinSep, List.map, Lean.MessageData.ofGoal, Lean.ToMessageData.toMessageData]]
[IO.AsyncList.cons.inj,[And.intro]]
[Lean.AttributeImplBuilderTable,[Std.HashMap, Lean.Name, Lean.AttributeImplBuilder]]
[Std.HashMapImp.fold,[Std.HashMapImp.foldBuckets, Std.HashMapImp.buckets]]
[Char.instLEChar,[LE.mk, Char.le]]
[Lean.Meta.IndPredBelow.mkContext.motiveType,[Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.InductiveVal.toConstantVal, Bind.bind, Lean.Meta.mkArrow, Lean.mkAppN, Lean.Meta.IndPredBelow.mkContext.mkIndValConst, Lean.mkSort, Lean.levelZero, Lean.Meta.mkForallFVars, Bool.false, Bool.true]]
[Lean.MonadCacheT.instMonadFinallyMonadCacheT,[inferInstanceAs, MonadFinally, StateRefT', Std.HashMap]]
[Substring.next,[String.Pos, ite, Eq, HSub.hSub, String.next]]
[Lean.IR.CtorInfo.beq,[Bool, and, BEq.beq]]
[Lean.Parser.ParserState.mkErrorsAt,[Lean.Parser.ParserState, Lean.Parser.ParserState.mk, Array.push, Lean.Syntax.missing, Option.some, Lean.Parser.Error.mk, Array.shrink]]
[Lean.Lsp.instFromJsonPlainTermGoal,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, String, Lean.Lsp.Range, Pure.pure, Lean.Lsp.PlainTermGoal.mk]]
[Lean.Elab.Structural.EqnInfo.declName,[]]
[Lean.Lsp.DiagnosticCode.int.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.Do.getLetEqnsDeclVar,[Lean.Syntax.getId, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Meta.Config.zetaNonDep,[]]
[Lean.Parser.Tactic.applyWith',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.kabstract,[Bind.bind, Lean.Meta.instantiateMVars, ite, Eq, and, Lean.Expr.isFVar, BEq.beq, Lean.Occurrences.all, Bool.true, Pure.pure, Lean.Expr.abstract, List.toArray, List.cons, List.nil, StateRefT'.run', OfNat.ofNat, Lean.Meta.kabstract.visit]]
[Lean.IR.Expr.noConfusionType,[]]
[Lean.Rat.sub,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, HSub.hSub, HMul.hMul, Lean.Rat.num, Int.ofNat, Lean.Rat.den, HDiv.hDiv]]
[Lean.HeadIndex.lit.inj,[]]
[«term∃_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
[Lean.Elab.Command.InductiveView.declName,[]]
[Lean.Elab.instInhabitedTerminationHints,[Inhabited.mk, Lean.Elab.TerminationHints.mk, arbitrary]]
[Lean.Meta.Match.MkMatcherInput.matchType,[]]
[Lean.Meta.Contradiction.Config.genDiseq,[]]
[Lean.Compiler.SpecState.mk.inj,[And.intro]]
[Lean.EnvExtension.modifyState,[Lean.EnvExtensionInterface.modifyState, Lean.EnvExtensionInterfaceImp]]
[Lean.Elab.Term.elabMVarWithIdKind,[Pure.pure, Lean.mkInaccessible, Lean.mkMVar, Lean.Elab.Term.getMVarSyntaxMVarId]]
[Function.involutive.surjective,[Exists.intro]]
[orM,[Bind.bind, Unit.unit, ToBool.toBool, Pure.pure]]
[List.mem_erasep_of_neg,[Iff.intro, List.mem_of_mem_erasep, Or.elim, List.exists_or_eq_self_of_erasep, Eq.mpr, Eq.refl, Mem.mem, List.erasep]]
[IO.Error.hardwareFault.inj,[And.intro]]
[Lean.mkCasesOnName,[Lean.Name.mkStr, Lean.casesOnSuffix]]
[Lean.Lsp.instToJsonRpcReleaseParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.RpcReleaseParams.uri, List.nil, Lean.Lsp.RpcReleaseParams.sessionId, Lean.Lsp.RpcReleaseParams.refs]]
[Lean.Expr.isCharLit,[and, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.Expr.isNatLit, Lean.Expr.appArg!]]
[Substring.extract,[Substring, ite, GE.ge, Substring.mk, OfNat.ofNat, Nat.min, HAdd.hAdd]]
[Lean.Meta.reduceNative?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Option, Lean.Expr, ite, Eq, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Meta.reduceBoolNative, Pure.pure, Option.some, Lean.ToExpr.toExpr, Lean.Meta.reduceNatNative, Option.none]]
[Lean.Meta.mkImpCongr,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil]]
[Lean.Name.appendIndexAfter,[Lean.Name.modifyBase, Lean.Name.anonymous, Lean.Name.num, Lean.Name, Lean.Name.mkStr, HAppend.hAppend, ToString.toString]]
[Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.mk.inj,[And.intro]]
[Mathlib.ExtendedBinder.extBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Mathlib.ExtendedBinder.extBinder, Mathlib.ExtendedBinder.extBinderCollection]]
[Lean.Elab.Term.logUnassignedUsingErrorInfos,[Bind.bind, MonadState.get, ForIn.forIn, MProd.mk, Lean.Elab.Term.TermElabM, ForInStep, MProd, Bool, Array, Lean.Elab.Term.MVarErrorInfo, Lean.MVarIdSet, ite, Eq, Std.RBTree.contains, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, liftM, Lean.Meta.getMVars, Lean.mkMVar, Array.any, Array.contains, OfNat.ofNat, Array.size, Lean.Meta.withMVarContext, Lean.Elab.Term.MVarErrorInfo.mvarId, Lean.Elab.Term.MVarErrorInfo.logError]]
[Lean.JsonRpc.Message.request.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.anonymousCtor.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.sepBy.formatter, Lean.Parser.termParser.formatter, Bool.false]]
[Lean.Parser.Tactic.zify,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.Meta.withLocalDeclD,[Lean.Meta.withLocalDecl, Lean.BinderInfo.default]]
[Std.ShareCommon.PersistentState.shareCommon,[Prod.mk]]
[Lean.IR.FnBody.set.inj,[And.intro]]
[le_total,[LinearOrder.le_total]]
[Lean.ConstantVal.type,[]]
[Lean.Xml.Parser.contentspec,[HOrElse.hOrElse, Lean.Parsec.skipString, Lean.Xml.Parser.Mixed, Lean.Xml.Parser.children]]
[instReprStdGen,[Repr.mk, Std.Format, Std.Format.bracket, HAppend.hAppend, repr, Std.Format.text]]
[Lean.IR.VarId.alphaEqv,[Unit.unit, Bool, Std.RBMap.find?, Lean.IR.VarId.idx, BEq.beq]]
[String.modify,[String.set, String.get]]
[IO.Error.unsupportedOperation.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.unsupportedOperation, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.letrec,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, Lean.Parser.group, Lean.Parser.symbol, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.Term.letRecDecls, Lean.Parser.Term.optSemicolon, Lean.Parser.termParser, OfNat.ofNat]]
[Lean.Parser.Command.visibility.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.private.parenthesizer, Lean.Parser.Command.protected.parenthesizer]]
[instDivUInt8,[Div.mk, UInt8.div]]
[Std.RBNode.insert,[ite, Eq, Std.RBNode.isRed, Bool.true, Std.RBNode.setBlack, Std.RBNode.ins]]
[Subtype.coe_eq_iff,[Iff.intro, Exists.intro, Subtype.property, Eq.symm, Subtype.coe_eta, Eq, Subtype.val, rfl]]
[Array.appendList,[List.foldl, Array.push]]
[instSemiringFin.proof_11,[rfl]]
[Lean.Elab.Command.StructView.scopeLevelNames,[]]
[Lean.JsonRpc.instInhabitedResponse,[Inhabited.mk, Lean.JsonRpc.Response.mk, arbitrary]]
[Lean.Elab.Tactic.Conv.congr,[Lean.Meta.withMVarContext, Bind.bind, Lean.Elab.Tactic.Conv.getLhsRhsCore, Lean.Meta.MetaM, List, Lean.MVarId, Lean.Meta.instantiateMVars, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[StateT.instLawfulMonadStateT.proof_1,[LawfulMonad.mk, StateT.ext, Eq.mpr, congr, congrArg, Eq, Eq.trans, StateT.run_bind, Pure.pure, Bind.bind, StateT.run, funext, StateT.run_pure, Prod.fst, Prod.snd, StateT.run_map, LawfulMonad.bind_pure_comp, Prod.mk, rfl, of_eq_true, congrFun, LawfulMonad.pure_bind, eq_self, LawfulMonad.bind_assoc]]
[Lean.PrettyPrinter.Formatter.checkPrec.formatter,[Pure.pure, Unit.unit]]
[Std.RBMap.all,[Bool, Std.RBNode.all]]
[Int.zero_ne_one,[sorryAx, False, Bool.true]]
[Lean.Elab.Term.traceAtCmdPos,[Lean.withRef, Lean.Syntax.missing, Lean.Elab.trace]]
[Lean.Elab.Term.instToStringPatternVar,[ToString.mk, String, ToString.toString, HAppend.hAppend, Lean.MVarId.name]]
[Lean.Elab.Command.instMonadRefCommandElabM,[Lean.MonadRef.mk, Lean.Elab.Command.getRef, MonadWithReader.withReader, Lean.Elab.Command.Context.mk, Lean.Elab.Command.Context.fileName, Lean.Elab.Command.Context.fileMap, Lean.Elab.Command.Context.currRecDepth, Lean.Elab.Command.Context.cmdPos, Lean.Elab.Command.Context.macroStack, Lean.Elab.Command.Context.currMacroScope]]
[Lean.Parser.Module.import.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.ident.parenthesizer]]
[Lean.IR.CollectMaps.collectVar,[Prod, Lean.IR.VarTypeMap, Lean.IR.JPParamsMap, Prod.mk, Std.HashMap.insert]]
[Lean.Elab.Term.Do.attachJP,[Lean.Elab.Term.Do.Code.joinpoint, Lean.Elab.Term.Do.JPDecl.name, Lean.Elab.Term.Do.JPDecl.params, Lean.Elab.Term.Do.JPDecl.body]]
[Lean.Parser.Command.include,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[IO.AccessRight.write,[]]
[Lean.Level.instToStringLevel,[ToString.mk, Std.Format.pretty, Lean.Level.format, Std.Format.defWidth]]
[Function.inv_fun_on_neg,[]]
[Lean.JsonRpc.Notification.param,[]]
[«term_⊆_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.MessageData.ofFormat.inj,[]]
[Lean.Parser.Command.simp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.parser, Lean.ParserDescr.cat]]
[Lean.PrettyPrinter.Parenthesizer.withOpenDecl.parenthesizer,[]]
[Lean.KeyedDeclsAttribute.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KeyedDeclsAttribute.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.refine',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.PPContext.currNamespace,[]]
[Lean.Elab.TerminationHints.decreasingBy?,[]]
[imp_congr,[imp_congr_ctx]]
[Std.RBTree.fold,[Std.RBMap.fold]]
[Lean.Elab.Tactic.evalTacticSeq1Indented,[Lean.Elab.Tactic.evalManyTacticOptSemi, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Elab.Tactic.evalTacticSeqBracketed,[Bind.bind, Lean.Elab.Tactic.mkInitialTacticInfo, Lean.Syntax.getOp, OfNat.ofNat, Lean.withRef, Lean.Elab.Tactic.closeUsingOrAdmit, Lean.Elab.withInfoContext, Pure.pure, Unit.unit, Lean.Elab.Tactic.evalManyTacticOptSemi]]
[Lean.Meta.Simp.ConfigCtx.mk.inj,[]]
[IO.Error.mkTimeExpired,[IO.Error.timeExpired]]
[Nat.div_eq_sub_div,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HAdd.hAdd, HSub.hSub, OfNat.ofNat, Nat.div_eq, ite, And, LT.lt, LE.le, if_pos, And.intro, rfl]]
[Lean.Elab.Tactic.MkSimpContextResult.fvarIdToLemmaId,[]]
[Lean.Lsp.ClientInfo.noConfusionType,[]]
[Lean.IR.UnreachableBranches.Value.ibelow,[True, And]]
[Lean.Parser.Term.suffices.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.sufficesDecl.formatter, Lean.Parser.Term.optSemicolon.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Lean.Parser.Tactic.linarith!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy]]
[coeTrans,[CoeTC.mk, coeB, coeTC]]
[Lean.LocalContext.findFVar?,[Lean.LocalContext.find?, Lean.Expr.fvarId!]]
[instMonadST,[inferInstanceAs, Monad, EST, Empty]]
[ExceptT.bindCont,[Except, Pure.pure, Except.error]]
[Lean.Parser.Trie.below,[PProd, PUnit]]
[Lean.Elab.OpenDecl.resolveId,[Bind.bind, Lean.MonadEnv.getEnv, ite, Eq, Lean.Environment.contains, Bool.true, Pure.pure, Lean.withRef, Lean.resolveGlobalConstNoOverloadCore]]
[instInhabitedTask,[Inhabited.mk, Task.pure, arbitrary]]
[Nat.not_lt,[Iff.intro, Nat.le_of_not_lt, Nat.not_lt_of_le]]
[Lean.Meta.InductionSubgoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.JsonNumber.lt,[Bool, dite, Eq, Prod.mk, Int.ofNat, Unit.unit, Eq.symm, Int.negSucc, Bool.true, Bool.false, ite, LT.lt, GT.gt, Decidable.decide]]
[Lean.Parser.Term.haveIdLhs.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.many.formatter, Lean.ppSpace.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.simpleBinderWithoutType.formatter, Lean.Parser.Term.bracketedBinder.formatter, Bool.false, Lean.Parser.Term.optType.formatter]]
[Lean.Elab.Tactic.Conv.evalPattern,[Lean.Elab.Tactic.withMainContext, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, liftM, Lean.Elab.Term.withoutPending, Lean.Elab.Term.elabTerm, Option.none, Lean.Meta.abstractMVars, Lean.Elab.Tactic.Conv.getLhs, IO.mkRef, Lean.Meta.getCongrLemmas, Pure.pure, Lean.Meta.Simp.Context.mk, Lean.Meta.Simp.Config.mk, Bool.false, Lean.Meta.SimpLemmas.mk, Lean.Meta.Simp.main, Lean.Meta.Simp.Methods.mk, ST.Ref.get, Option.isSome, Lean.Meta.Simp.Step.visit, Lean.Meta.Simp.Result.mk, Lean.Elab.Tactic.Conv.matchPattern?, Lean.Meta.Simp.SimpM, Lean.Meta.Simp.Step, Lean.Elab.Tactic.Conv.mkConvGoalFor, ST.Ref.set, Option.some, ForIn.forIn, Lean.Meta.mkCongrFun, PUnit.unit, ForInStep.yield, Lean.Meta.Simp.Step.done, Lean.mkAppN, Lean.Meta.MetaM, Option, Prod, Lean.MVarId, Lean.Meta.Simp.Result, Prod.mk, Lean.Expr.mvarId!, Unit.unit, Lean.Elab.Tactic.TacticM, Unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Meta.Simp.Result.getProof, Lean.Elab.Tactic.Conv.updateLhs, Lean.Meta.Simp.Result.expr, Lean.Elab.Tactic.getMainGoal, Lean.Meta.applyRefl, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.nil, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Lsp.ServerInfo.mk.inj,[And.intro]]
[Lean.IR.UnreachableBranches.instReprValue,[Repr.mk]]
[Stream.forIn,[Stream.forIn.visit]]
[Lean.Parser.Parser.noConfusionType,[]]
[Lean.Name.quickCmpAux,[Unit.unit, Lean.Name.str, Lean.Name.num, Ordering, Ordering.eq, Ordering.lt, Ordering.gt, Ord.compare, PProd.fst]]
[Lean.NamingContext.openDecls,[]]
[Lean.Parser.Command.declVal.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.declValSimple.formatter, Lean.Parser.Command.declValEqns.formatter, Lean.Parser.Command.whereStructInst.formatter]]
[List.reverseAux,[List, PProd.fst, List.cons]]
[Lean.Server.Watchdog.handleRequest,[ite, Eq, BEq.beq, Bool.true, Bind.bind, Lean.Server.Watchdog.parseParams, Lean.Lsp.RpcConnectParams, Pure.pure, Lean.Lsp.FileSource.fileSource, liftM, Lean.Server.routeLspRequest, Lean.Server.Watchdog.ServerM, Unit, MonadReader.read, IO.FS.Stream.writeLspResponseError, Lean.Server.Watchdog.ServerContext.hOut, Lean.Server.RequestError.toLspResponseError, PUnit.unit]]
[Lean.Parser.Term.doTry.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.doSeq.formatter, Lean.Parser.many.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.doCatch.formatter, Lean.Parser.Term.doCatchMatch.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.doFinally.formatter]]
[Lean.PrettyPrinter.Delaborator.returnsPi,[Lean.Meta.lambdaTelescope, Pure.pure, Lean.Expr.isForall]]
[String.Iterator.prev,[String.Iterator, String.Iterator.mk, String.prev]]
[Lean.PrettyPrinter.Parenthesizer.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.PrettyPrinter.Parenthesizer.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Do.Code.noConfusionType,[]]
[Function.uncurry_def,[rfl]]
[Lean.Xml.instToStringContent,[ToString.mk]]
[Lean.Lsp.DiagnosticWith.relatedInformation?,[]]
[Lean.mkConst,[Lean.Expr.const, Lean.Expr.mkData, mixHash, OfNat.ofNat, Hashable.hash, Bool.false, List.any, Lean.Level.hasMVar, Lean.Level.hasParam]]
[Lean.Name.instAppendName,[Append.mk, Lean.Name.append]]
[Lean.Elab.WF.TerminationHint.find?,[Unit.unit, Option, Lean.Elab.WF.TerminationHintValue, Option.none, Option.some, Array.findSome?, Lean.NameMap.find?]]
[Lean.Elab.Term.Do.mkUnless,[Bind.bind, Lean.Elab.Term.Do.mkPureUnitAction, Lean.MonadRef.getRef, Pure.pure, Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.ite, Option.none, Lean.mkNullNode, List.toArray, List.nil, Lean.Elab.Term.Do.CodeBlock.code, Lean.Elab.Term.Do.CodeBlock.uvars]]
[Lean.Expr.updateProj!.proof_1,[rfl]]
[not_lt_of_gt,[lt_asymm]]
[Lean.Lsp.instFromJsonTextDocumentPositionParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.TextDocumentPositionParams.mk]]
[instDecidableEqUInt8,[UInt8.decEq]]
[Lean.KeyedDeclsAttribute.Def.valueTypeName,[]]
[Lean.Widget.MsgEmbed.instInhabitedRpcEncodingPacket,[Inhabited.mk, arbitrary]]
[Subtype.map.proof_1,[Subtype.val, Subtype.prop]]
[Lean.Parser.finishCommentBlock.eoi,[Lean.Parser.ParserState.mkUnexpectedError, List.nil]]
[Lean.Lsp.CompletionItem.noConfusionType,[]]
[plift.up.injEq,[Eq.propIntro, Eq.refl, plift.up, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.ExpandDeclIdResult.shortName,[]]
[Task.spawn,[Task.pure, Unit.unit]]
[Lean.Meta.getFunInfo,[Bind.bind, MonadState.get, Lean.Meta.getTransparency, Unit.unit, Lean.Meta.MetaM, Lean.Meta.FunInfo, Std.PersistentHashMap.find?, Lean.Meta.Cache.funInfo, Lean.Meta.State.cache, Lean.Meta.InfoCacheKey.mk, Pure.pure, modify, Lean.Meta.State.mk, Lean.Meta.State.mctx, Lean.Meta.Cache.mk, Lean.Meta.Cache.inferType, Std.PersistentHashMap.insert, Lean.Meta.Cache.synthInstance, Lean.Meta.Cache.whnfDefault, Lean.Meta.Cache.whnfAll, Lean.Meta.Cache.defEqDefault, Lean.Meta.Cache.defEqAll, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed, Lean.Meta.inferType, Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.default, Lean.Meta.forallBoundedTelescope, ForIn.forIn, Lean.Meta.getFVarLocalDecl, PUnit.unit, ForInStep.yield, Lean.Meta.FunInfo.mk, Option.none]]
[Lean.Server.RequestError.fileChanged,[Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.contentModified]]
[Std.AssocList.empty,[Std.AssocList.nil]]
[Nat.add_div_right,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HAdd.hAdd, Nat.succ, Nat.div_eq_sub_div, Nat.le_add_left, HSub.hSub, OfNat.ofNat, Nat.add_sub_cancel, rfl]]
[Lean.instToJsonUInt64,[Lean.ToJson.mk, Lean.bignumToJson, UInt64.toNat]]
[Int.natAbs_one,[rfl]]
[Lean.Parser.Term.doubleQuotedName.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.PrettyPrinter.Parenthesizer.rawCh.parenthesizer, Char.ofNat, Lean.Parser.Term.ident.parenthesizer]]
[Lean.Lsp.DidOpenTextDocumentParams.mk.inj,[]]
[Lean.Elab.Info.ofMacroExpansionInfo.inj,[]]
[Lean.Meta.SynthInstance.Waiter.isRoot,[Unit.unit, Bool, Bool.false, Bool.true]]
[Lean.Parser.Tactic.nthRwRHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Nat.succ_lt_succ,[Nat.succ_le_succ]]
[Lean.Parser.orelse,[Lean.Parser.Parser.mk, Lean.Parser.orelseInfo, Lean.Parser.Parser.info, Lean.Parser.orelseFn, Lean.Parser.Parser.fn]]
[Lean.Parser.Command.declModifiers.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.docComment.parenthesizer, Lean.Parser.Term.attributes.parenthesizer, Lean.PrettyPrinter.Parenthesizer.ite, Eq, Lean.PrettyPrinter.Parenthesizer.skip.parenthesizer, Lean.Parser.ppDedent.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.Parser.Command.visibility.parenthesizer, Lean.Parser.Command.noncomputable.parenthesizer, Lean.Parser.Command.unsafe.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.partial.parenthesizer, Lean.Parser.Command.nonrec.parenthesizer]]
[lt_asymm,[lt_irrefl, lt_trans]]
[Lean.Meta.ElimInfo.name,[]]
[Int.neg_add,[]]
[Lean.Lsp.ServerCapabilities.typeDefinitionProvider,[]]
[UInt16.instNegUInt16,[Neg.mk, UInt16.mk, Neg.neg, UInt16.val]]
[Lean.Lsp.ServerInfo.name,[]]
[Lean.getPPAnalyzeTrustOfScientific,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.trustOfScientific, Lean.Option.defValue]]
[Lean.MessageLog.mk.inj,[]]
[Semiring.npow_succ',[]]
[Lean.Macro.Methods.hasDecl,[]]
[Lean.Meta.MetaM,[ReaderT, Lean.Meta.Context, StateRefT', IO.RealWorld, Lean.Meta.State, Lean.Core.CoreM]]
[Lean.OptionDecl.group,[]]
[Lean.JsonRpc.ErrorCode.internalError.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.PrettyPrinter.ppExpr,[Bind.bind, Lean.MonadLCtx.getLCtx, Lean.MonadOptions.getOptions, Lean.Meta.withLCtx, List.toArray, List.nil, Lean.PrettyPrinter.delab, EmptyCollection.emptyCollection, liftM, Lean.PrettyPrinter.ppTerm]]
[Lean.Rat.normalize,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, HDiv.hDiv, Lean.Rat.num, Int.ofNat, Lean.Rat.den]]
[Lean.AttributeImpl.noConfusionType,[]]
[Std.shareCommon,[Std.ShareCommonM.run, Std.withShareCommon]]
[Function.on_fun,[]]
[Lean.Server.FileWorker.GoToKind.type.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.SMap.find!,[Unit.unit, Lean.SMap.find?, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Parser.Term.proj.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.fieldIdx.formatter, Lean.Parser.Term.ident.formatter]]
[Lean.Parser.ParserContext.forbiddenTk?,[]]
[Lean.PrettyPrinter.Parenthesizer.Context.noConfusionType,[]]
[Lean.Elab.Term.CollectPatternVars.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.CollectPatternVars.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[instOrElseEIO,[OrElse.mk, MonadExcept.orElse]]
[Std.PersistentArrayNode.noConfusionType,[]]
[Lean.EnvExtensionInterfaceUnsafe.Ext.mkInitial,[]]
[Lean.Level.toNat,[Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Option, Nat, Lean.Level.getLevelOffset, Option.some, Lean.Level.getOffset, Option.none]]
[Lean.Parser.Term.optIdent.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.Parser.symbol.parenthesizer]]
[Lean.Server.FileWorker.WorkerM,[ReaderT, Lean.Server.FileWorker.WorkerContext, StateRefT', IO.RealWorld, Lean.Server.FileWorker.WorkerState, IO]]
[Lean.ConstantVal.levelParams,[]]
[Lean.instToStringRat,[ToString.mk, ite, Eq, BEq.beq, Lean.Rat.den, OfNat.ofNat, Bool.true, ToString.toString, Lean.Rat.num, HAppend.hAppend]]
[Set.«term⋃₀_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Command.def.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declId.formatter, Lean.Parser.Command.optDeclSig.formatter, Lean.Parser.Command.declVal.formatter, Lean.Parser.Command.optDefDeriving.formatter, Lean.Parser.Command.terminationSuffix.formatter]]
[Lean.AxiomVal.isUnsafeEx,[Lean.AxiomVal.isUnsafe]]
[dite,[]]
[Lean.Parser.Term.pipeProj,[Lean.Parser.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.minPrec, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.checkNoWsBefore, HOrElse.hOrElse, Lean.Parser.fieldIdx, Lean.Parser.Term.ident, Lean.Parser.many, Lean.Parser.Term.argument]]
[Lean.Meta.tryUnificationHints,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Meta.tryUnificationHints.isDefEqPattern, Lean.Meta.tryUnificationHints.tryCandidate]]
[Lean.Parser.Command.print,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, HOrElse.hOrElse, Lean.Parser.ident, Lean.Parser.strLit]]
[IO.FS.Stream.noConfusionType,[]]
[Lean.Elab.Term.MutualClosure.Replacement,[Lean.FVarIdMap, Lean.Expr]]
[Lean.Elab.Command.MkInstanceName.append,[modify, HAppend.hAppend]]
[Std.PersistentArrayNode.leaf.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.isReadOnlyLevelMVar,[Bind.bind, Lean.Meta.getConfig, ite, Eq, Lean.Meta.Config.ignoreLevelMVarDepth, Bool.true, Pure.pure, Bool.false, Lean.Meta.getLevelMVarDepth, Lean.MonadMCtx.getMCtx, bne, Lean.MetavarContext.depth]]
[Lean.Elab.Deriving.DecEq.mkDecEqEnum,[Bind.bind, Lean.Elab.Command.liftTermElabM, Option.none, liftM, Lean.Elab.Deriving.DecEq.mkEnumOfNat, Lean.Elab.Deriving.DecEq.mkEnumOfNatThm, Lean.getConstInfoInduct, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, Lean.mkIdent, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, PUnit.unit]]
[Lean.Compiler.foldNatBinPred,[OptionM.run, Bind.bind, Lean.Compiler.getNumLit, Pure.pure, Lean.Compiler.toDecidableExpr]]
[Lean.Elab.Tactic.Conv.evalExt,[ite, Eq, Array.isEmpty, Bool.true, Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM, Lean.Meta.withMVarContext, Lean.Elab.Tactic.Conv.getLhsRhsCore, Lean.Meta.MetaM, Lean.MVarId, Lean.Meta.instantiateMVars, Lean.Expr.isForall, Lean.Meta.mkConstWithFreshMVarLevels, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.apply, List.nil, List.cons, Lean.Meta.introN, OfNat.ofNat, Bool.false, Lean.Elab.Tactic.Conv.markAsConvGoal, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.Meta.inferType, Lean.Meta.whnfD, Pure.pure, PUnit.unit, HAppend.hAppend, Lean.indentD, Lean.Elab.Tactic.replaceMainGoal, Option.none, ForIn.forIn, Lean.withRef, Option.some, Lean.Syntax.getId, ForInStep.yield]]
[String.take,[Substring.toString, Substring.take, String.toSubstring]]
[instShiftLeftUInt32,[ShiftLeft.mk, UInt32.shiftLeft]]
[Lean.Parser.Tactic.Conv.enterArg,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const]]
[Lean.IR.Borrow.InitParamMap.visitDecls,[Array.forM, Lean.IR.Decl.extern, StateM, Lean.IR.Borrow.ParamMap, PUnit, Bind.bind, modify, Std.HashMap.insert, Lean.IR.Borrow.ParamMap.Key.decl, Lean.IR.Borrow.InitParamMap.initBorrowIfNotExported, Lean.IR.Borrow.InitParamMap.visitFnBody, Pure.pure, Unit.unit, OfNat.ofNat, Array.size]]
[List.not_exists_mem_nil,[False, Eq.refl]]
[Lean.Parser.ParserModuleContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parsec.ParseResult.error.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parsec.ParseResult.error, Eq.symm, eq_of_heq, HEq.refl]]
[Std.ShareCommon.ObjectPersistentMap.insert,[Std.PersistentHashMap.insert]]
[USize.instRingUSize.proof_2,[congrArg, USize.mk, Ring.gsmul_zero', USize.val]]
[Lean.Parser.Term.bracketedBinder.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.PrettyPrinter.Formatter.evalInsideQuot.formatter, Lean.Parser.Term.bracketedBinder.formatter, Bool.false]]
[Lean.Meta.GeneralizeArg.xName?,[]]
[by_contradiction,[Decidable.by_contradiction]]
[Lean.Meta.modifyCache,[modify, Lean.Meta.State, Lean.Meta.State.mk]]
[Mathlib.Tactic.Lint.getLinters,[List.mapM, Mathlib.Tactic.Lint.getLinter]]
[Lean.LocalContext.pop,[Lean.LocalContext, ite, Eq, BEq.beq, Std.PersistentArray.size, OfNat.ofNat, Bool.true, Unit.unit, Std.PersistentArray.get!, HSub.hSub, Lean.LocalContext.mk, Std.PersistentHashMap.erase, Lean.LocalDecl.fvarId, Std.PersistentArray.pop]]
[exists_imp_exists,[Exists.elim, Exists.intro]]
[List.cons_bind,[of_eq_true, eq_self, HAppend.hAppend, List.join, List.map]]
[Lean.SimpleScopedEnvExtension.Descr.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.withoutPosition,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.Parser.fn, Lean.Parser.ParserContext.mk, Lean.Parser.ParserContext.toInputContext, Lean.Parser.ParserContext.toParserModuleContext, Lean.Parser.ParserContext.prec, Lean.Parser.ParserContext.tokens, Lean.Parser.ParserContext.quotDepth, Lean.Parser.ParserContext.suppressInsideQuot, Option.none, Lean.Parser.ParserContext.forbiddenTk?]]
[Nat.find_x,[WellFounded.fix', WellFounded.intro, Acc, And, Eq, HAdd.hAdd, OfNat.ofNat, Not, dite, Subtype.mk, Nat.find_x.proof_1, Nat.find_x.proof_3]]
[peirce,[Decidable.peirce]]
[IO.FS.Stream.ofBuffer,[IO.FS.Stream.mk, Bind.bind, ST.Ref.get, Pure.pure, Decidable.decide, GE.ge, IO.FS.Stream.Buffer.pos, ByteArray.size, IO.FS.Stream.Buffer.data, Unit.unit, ST.Ref.modifyGet, Prod.mk, IO.FS.Stream.Buffer.mk, HAdd.hAdd, ST.Ref.modify, ByteArray.copySlice, OfNat.ofNat, Bool.false, String.fromUTF8Unchecked, ByteArray.extract]]
[Lean.Lsp.instToJsonDocumentSymbolAux,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.DocumentSymbolAux.name, List.nil, Lean.Json.opt, Lean.Lsp.DocumentSymbolAux.detail?, Lean.Lsp.DocumentSymbolAux.kind, Lean.Lsp.DocumentSymbolAux.range, Lean.Lsp.DocumentSymbolAux.selectionRange, Lean.Lsp.DocumentSymbolAux.children?]]
[Lean.Elab.Term.elabBadCDot,[Lean.throwError, Lean.ToMessageData.toMessageData]]
[Lean.Meta.CasesSubgoal.noConfusionType,[]]
[Lean.Name.mapPrefix,[Id.run, Option.none, Id, Lean.Name, Pure.pure, Bind.bind, PUnit.unit]]
[Lean.ConstantInfo.isUnsafe,[Bool, BEq.beq, Lean.DefinitionVal.safety, Lean.DefinitionSafety.unsafe, Lean.AxiomVal.isUnsafe, Bool.false, Lean.OpaqueVal.isUnsafe, Lean.InductiveVal.isUnsafe, Lean.ConstructorVal.isUnsafe, Lean.RecursorVal.isUnsafe]]
[Lean.PrettyPrinter.Formatter.scientificLit.formatter,[Lean.Parser.Term.scientific.formatter]]
[Lean.Elab.Term.Quotation.MatchResult.noConfusionType,[]]
[instToStringSum,[ToString.mk, String, HAppend.hAppend, addParenHeuristic, ToString.toString]]
[Lean.Meta.Config.proofIrrelevance,[]]
[Lean.Lsp.HoverParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.HoverParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[instMonoidWithZero,[MonoidWithZero.mk, Semiring.zero_mul, Semiring.mul_zero]]
[Lean.PrettyPrinter.Delaborator.whenNotPPOption,[Bind.bind, Lean.PrettyPrinter.Delaborator.getPPOption, ite, Eq, Bool.true, Alternative.failure]]
[UInt16.div,[UInt16.mk, HDiv.hDiv, UInt16.val]]
[Lean.Parser.Term.fromTerm.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.Parser.Command.macroTailCommand.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.identEq.parenthesizer, Lean.Name.mkSimple, Lean.Parser.darrow.parenthesizer, Lean.Parser.Command.macroRhs.parenthesizer, Lean.PrettyPrinter.Parenthesizer.many1Unbox.parenthesizer, Lean.Parser.commandParser.parenthesizer, OfNat.ofNat]]
[Lean.Lsp.instFileSourceLocation,[Lean.Lsp.FileSource.mk, Lean.Lsp.Location.uri]]
[Lean.TraceElem.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.SimpLemmas.pre,[]]
[Lean.Compiler.foldUIntSub,[Lean.Compiler.foldBinUInt, HAdd.hAdd, HSub.hSub, Lean.Compiler.NumScalarTypeInfo.size]]
[Lean.Parser.Term.strictImplicitRightBracket,[HOrElse.hOrElse, Lean.Parser.atomic, Lean.Parser.group, HAndThen.hAndThen, Lean.Parser.symbol]]
[Not.elim,[absurd]]
[Lean.Elab.Command.InductiveView.noConfusionType,[]]
[instInhabited,[Inhabited.mk, Pure.pure, arbitrary]]
[Lean.NameMap,[Std.RBMap, Lean.Name, Lean.Name.quickCmp]]
[Lean.Elab.Command.mkNameFromParserSyntax.appendCatName,[Lean.Name.anonymous, Lean.Name.num, String, HAppend.hAppend]]
[Lean.Parser.Tactic.case,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary]]
[DecidablePred,[Decidable]]
[List.cons_subset,[Eq.mpr, congr, congrArg, Iff, Eq.trans, propext, List.subset_def, forall_congr, implies_congr, List.mem_cons_iff, Eq.refl, Mem.mem, or_imp_distrib, forall_and_distrib, congrFun, And, forall_eq, Iff.rfl]]
[List.repeat_succ,[rfl]]
[Mathlib.Tactic.Lint.Linter.test,[]]
[instMonadLiftT,[MonadLiftT.mk, MonadLift.monadLift, MonadLiftT.monadLift]]
[Lean.NamePart.cmp,[Lean.NamePart.str, Lean.NamePart.num, Ordering, Ord.compare, Ordering.lt, Ordering.gt]]
[ofBoolUsing_eq_true,[of_decide_eq_true]]
[seq_eq_bind,[Eq.mpr, Eq.refl, Eq, Seq.seq, Bind.bind, Functor.map, LawfulMonad.bind_map, rfl]]
[Lean.Elab.Structural.EqnInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Structural.EqnInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Widget.instFromJsonGetInteractiveDiagnosticsParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, Lean.Lsp.LineRange, Pure.pure, Lean.Widget.GetInteractiveDiagnosticsParams.mk]]
[ST.Ref.modify,[liftM, ST.Prim.Ref.modify]]
[Lean.IR.NormalizeIds.instMonadLiftMN,[MonadLift.mk, Pure.pure]]
[Lean.Parser.Tactic.«tacticNext___=>_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[ptrAddrUnsafe,[OfNat.ofNat]]
[Lean.Lsp.instFromJsonStaticRegistrationOptions,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, String, Pure.pure, Lean.Lsp.StaticRegistrationOptions.mk]]
[List.dropLast,[Unit.unit, List.cons, List, List.nil, PProd.fst]]
[Lean.PrettyPrinter.Formatter.interpolatedStr.formatter,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, Lean.PrettyPrinter.Formatter.visitArgs, Array.forM, Unit.unit, Lean.PrettyPrinter.FormatterM, PUnit, Lean.Syntax.isLit?, Lean.interpolatedStrLitKind, SeqRight.seqRight, Lean.PrettyPrinter.Formatter.push, Std.Format.text, Lean.Syntax.MonadTraverser.goLeft, Array.reverse, Lean.Syntax.getArgs, OfNat.ofNat, Array.size]]
[exists_eq_left',[of_eq_true, Eq.trans, congrFun, congrArg, Iff, Exists, funext, And, propext, eq_comm, exists_eq_left, iff_self]]
[Lean.PrettyPrinter.Formatter.rawIdentNoAntiquot.formatter,[Bind.bind, Lean.PrettyPrinter.Formatter.checkKind, Lean.identKind, Lean.Syntax.MonadTraverser.getCur, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.PrettyPrinter.FormatterM, Unit, Lean.PrettyPrinter.Formatter.pushToken, Lean.Name.toString, Bool.true, Lean.Syntax.MonadTraverser.goLeft, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Std.AssocList.contains,[Unit.unit, Bool, Bool.false, or, BEq.beq, PProd.fst]]
[Nat.pos_iff_ne_zero,[Iff.intro, absurd, of_decide_eq_false, Eq.refl, Decidable.decide, LT.lt, OfNat.ofNat, Nat.zero, Eq.symm, Nat.succ_ne_zero, Nat.pos_of_ne_zero]]
[instDecidableAnd,[Decidable, And, Decidable.isTrue, And.intro, Decidable.isFalse, instDecidableAnd.proof_1, instDecidableAnd.proof_2]]
[Lean.Meta.Closure.pushLocalDecl,[Bind.bind, Lean.Meta.Closure.collectExpr, modify, Lean.Meta.Closure.State.mk, Lean.Meta.Closure.State.visitedLevel, Lean.Meta.Closure.State.visitedExpr, Lean.Meta.Closure.State.levelParams, Lean.Meta.Closure.State.nextLevelIdx, Lean.Meta.Closure.State.levelArgs, Array.push, Lean.Meta.Closure.State.newLocalDecls, Lean.LocalDecl.cdecl, arbitrary, Lean.Meta.Closure.State.newLocalDeclsForMVars, Lean.Meta.Closure.State.newLetDecls, Lean.Meta.Closure.State.nextExprIdx, Lean.Meta.Closure.State.exprMVarArgs, Lean.Meta.Closure.State.exprFVarArgs, Lean.Meta.Closure.State.toProcess]]
[termS!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[Lean.Json.Parser.hexChar,[Bind.bind, Lean.Parsec.anyChar, ite, And, LE.le, Char.ofNat, Pure.pure, HSub.hSub, UInt32.toNat, Char.val, Lean.Parsec.fail]]
[exists_imp_exists',[Exists.elim, Exists.intro]]
[Lean.Expr.updateApp!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateApp, Lean.Expr.app, Lean.Expr.updateApp!.proof_1, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Parser.Term.nomatch,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat]]
[Monoid.noConfusionType,[]]
[Lean.Lsp.instToJsonDocumentHighlight,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.DocumentHighlight.range, List.nil, Lean.Json.opt, Lean.Lsp.DocumentHighlight.kind?]]
[Lean.Parser.Module.prelude,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[instReprChar,[Repr.mk, Std.Format.text, Char.quote]]
[Lean.Server.WithRpcRef.encodeUnsafe,[Lean.Server.MonadRpcSession.rpcStoreRef]]
[Lean.Parser.Term.doDbgTrace.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.interpolatedStr.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[Monoid.mul_one,[]]
[Lean.LocalContext.fvarIdToDecl,[]]
[UInt32.sub_def,[rfl]]
[Lean.Meta.Simp.getConfig,[Bind.bind, readThe, Lean.Meta.Simp.Context, Pure.pure, Lean.Meta.Simp.Context.config]]
[Lean.Rat.inv,[ite, LT.lt, Lean.Rat.num, OfNat.ofNat, Neg.neg, Int.ofNat, Lean.Rat.den, Int.natAbs, Eq, BEq.beq, Bool.true]]
[String.bsize,[String.utf8ByteSize]]
[Lean.IR.EmitC.emitMainFnIfNeeded,[Bind.bind, Lean.IR.EmitC.hasMainFn, ite, Eq, Bool.true, Lean.IR.EmitC.emitMainFn, Pure.pure, PUnit.unit]]
[Preorder.toLT,[]]
[Acc.brecOn,[Acc.below.intro]]
[Mathlib.Tactic.Lint.shouldBeLinted,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.ParametricAttribute.getParam, Mathlib.Tactic.Lint.nolintAttr, not, Array.contains, Option.getD, EmptyCollection.emptyCollection]]
[DecidableRel,[Decidable]]
[Lean.Parser.ppIndent,[id]]
[Nat.pred_zero,[rfl]]
[Lean.Meta.MatcherApp.discrs,[]]
[Lean.Meta.Match.Unify.isAltVar,[Bind.bind, MonadReader.read, Pure.pure, List.any, BEq.beq, Lean.LocalDecl.fvarId, Lean.Meta.Match.Unify.Context.altFVarDecls]]
[Nat.gcd_add_mul_self,[of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.gcd_rec, HAdd.hAdd, HMul.hMul, congrFun, Nat.gcd, Nat.add_mul_mod_self_right, eq_self, HMod.hMod]]
[Lean.Parser.priorityParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous]]
[instOfNatUInt8,[OfNat.mk, UInt8.ofNat]]
[Lean.IR.IndexSet,[Std.RBTree, Lean.IR.Index, Ord.compare]]
[Lean.Meta.Config.offsetCnstrs,[]]
[Lean.Server.FileWorker.handleReferences.findReferences,[Id.run, Bind.bind, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield]]
[instAppendSubarray,[Append.mk, Array.toSubarray, OfNat.ofNat, Array.size]]
[Lean.instInhabitedOpaqueVal,[Inhabited.mk, Lean.OpaqueVal.mk, arbitrary]]
[Std.HashMap.empty,[Std.mkHashMap, OfNat.ofNat]]
[Lean.ImportState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ImportState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Delaborator.SubExpr.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Trie.Node.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.Trie.Node, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Xml.Parser.NotationDecl,[SeqRight.seqRight, Lean.Parsec.skipString, Lean.Xml.Parser.S, Lean.Xml.Parser.Name, HOrElse.hOrElse, Lean.Xml.Parser.ExternalID, Lean.Xml.Parser.PublicID, optional, Lean.Parsec.skipChar, Char.ofNat]]
[Lean.Meta.instInhabitedSimpLemma,[Inhabited.mk, Lean.Meta.SimpLemma.mk, arbitrary]]
[List.Perm.Equivalence,[Equivalence.mk, List.Perm.refl, List.Perm.symm, List.Perm.trans]]
[Lean.Meta.SynthInstance.TableEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.SynthInstance.TableEntry.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.JsonRpc.instInhabitedRequest,[Inhabited.mk, Lean.JsonRpc.Request.mk, arbitrary]]
[Nat.coprime_mul_iff_right,[Eq.mpr, Eq.refl, Iff, Nat.coprime, HMul.hMul, And, propext, Nat.coprime_comm, Nat.coprime_mul_iff_left, Iff.rfl]]
[Std.HashMap.erase,[Std.HashMap, Subtype.mk, Std.HashMapImp.erase, Std.HashMapImp.WellFormed.eraseWff]]
[List.mapTR,[List.mapTRAux, List.nil]]
[USize.instRingUSize.proof_4,[congrArg, USize.mk, SubNegMonoid.gsmul_neg', USize.val]]
[Not.imp_symm,[Not.decidable_imp_symm]]
[Lean.Meta.ElimInfo.noConfusionType,[]]
[Lean.Elab.Term.StructInst.DefaultFields.Context.structs,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.maybeAddBlockImplicit,[Bind.bind, MonadReader.read, ite, Eq, not, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.parentIsApp, Bool.true, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, liftM, Lean.Meta.inferType, and, Lean.Expr.isForall, BEq.beq, Lean.Expr.bindingInfo!, Lean.BinderInfo.implicit, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.annotateBool, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, PUnit.unit]]
[EStateM.Backtrackable.restore,[]]
[List.erase_append_right,[Eq.mpr, Eq.refl, Eq, List.erase, HAppend.hAppend, List.erase_eq_erasep, List.erasep, List.erasep_append_right, Eq.mp, Not, Mem.mem, rfl]]
[Lean.Parser.atomicFn,[Lean.Parser.ParserState.mk, Option.none, Lean.Parser.ParserState, Option.some]]
[List.filterAuxM,[List, Pure.pure, Bind.bind, PProd.fst, cond, List.cons]]
[Array.sequenceMap,[Array.size, OfNat.ofNat, Array.empty, Array.sequenceMap.loop]]
[instToStringUnit,[ToString.mk]]
[UInt64.add,[UInt64.mk, HAdd.hAdd, UInt64.val]]
[Lean.Lsp.TextDocumentIdentifier.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Parser.fn,[]]
[Lean.Elab.Term.LValResolution.getOp.inj,[And.intro]]
[Lean.Meta.assert,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarTag, Lean.Meta.getMVarType, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.assignExprMVar, Lean.mkApp, Pure.pure, Lean.Expr.mvarId!]]
[Lean.Server.RequestError.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.RequestError.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Std.PersistentHashMap.findEntry?,[Option, Prod, Std.PersistentHashMap.findEntryAux, UInt64.toUSize, Hashable.hash]]
[Prod.swap,[Prod.mk, Prod.snd, Prod.fst]]
[Lean.Json.ibelow,[True, And]]
[Lean.Parser.Term.inaccessible.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[eqRec_heq,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, HEq]]
[true_iff,[propext, Iff.intro, Iff.mp, trivial]]
[Lean.instInhabitedRat,[Inhabited.mk, arbitrary]]
[Lean.Parser.ParserInfo.collectTokens,[]]
[Lean.Meta.Match.MatcherResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.MatcherResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.ensureHasTypeAux,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Pure.pure, Bind.bind, liftM, Lean.Meta.isDefEq, ite, Eq, Bool.true, Lean.Meta.instantiateMVars, Lean.Elab.Term.isTypeApp?, Option.none, Lean.Meta.isMonad?, MonadExcept.tryCatch, Lean.Meta.mkAppOptM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Option.some, List.nil, Lean.Meta.expandCoe, Lean.MonadOptions.getOptions, Lean.Option.get, Lean.Elab.Term.autoLift, Lean.Meta.mkAppM, Lean.Elab.Term.synthesizeInst, Lean.Meta.getDecLevel, Lean.Meta.inferType, DoResultPR.return, PUnit.unit, DoResultPR, PUnit, Lean.Meta.getLevel, Lean.mkAppN, Lean.mkConst, DoResultPR.pure]]
[Lean.Meta.SimpLemma.name?,[]]
[Lean.Elab.Term.Do.JPDecl.name,[]]
[Lean.Meta.isFinPatLit,[and, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.Expr.isNatLit, Lean.Expr.appArg!]]
[Lean.Parser.TokenCacheEntry.token,[]]
[Lean.Meta.CheckAssignment.State.cache,[]]
[Lean.Server.Watchdog.ServerEvent.workerEvent.inj,[And.intro]]
[ShiftLeft.shiftLeft,[]]
[Lean.Widget.InteractiveDiagnostic.toDiagnostic.prettyTt,[Lean.Widget.TaggedText.stripTags]]
[List.get!,[Nat.zero, List.nil, Nat.succ, PProd.fst, panicWithPosWithDecl, OfNat.ofNat]]
[Fin.noConfusionType,[]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withBindingDomain,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.PrettyPrinter.Delaborator.SubExpr.descend, Lean.Expr.bindingDomain!, OfNat.ofNat]]
[Lean.instInhabitedMetavarDecl,[Inhabited.mk, Lean.MetavarDecl.mk, arbitrary]]
[Lean.Parser.Tactic.tacticSeqBracketed.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.Parser.tacticParser.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.ppDedent.parenthesizer]]
[Std.RBMap.erase,[Std.RBMap, Subtype.mk, Std.RBNode.erase, Std.RBMap.erase.proof_1]]
[Decidable.imp_or_distrib',[Decidable.em, of_eq_true, Eq.trans, congr, congrArg, Iff, implies_congr, Eq.refl, congrFun, Or, eq_true, true_or, implies_true, eq_true_of_decide, Bool.true, Eq.symm, Eq.mpr, eq_false, False, false_or, Iff.symm, or_iff_right_of_imp, False.elim]]
[Lean.Expr.ne?,[Lean.Expr.app3?, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Elab.Term.LetRecDeclView.mk.inj,[And.intro]]
[Lean.Parser.Term.letDecl.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.notFollowedBy.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.letIdDecl.formatter, Lean.Parser.Term.letPatDecl.formatter, Lean.Parser.Term.letEqnsDecl.formatter]]
[Lean.Lsp.RpcConnected.mk.inj,[]]
[Lean.Compiler.CSimp.Entry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Compiler.CSimp.Entry.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.KVMap.getBool,[Option.none, Option.some, Lean.DataValue.ofString, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Bool, Lean.KVMap.find]]
[Lean.Expr.isConstructorApp?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.strVal, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.ConstructorVal, ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo, Lean.Environment.find?, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Expr.getAppFn, Unit.unit, HAdd.hAdd, Lean.ConstructorVal.numParams, Lean.ConstructorVal.numFields, Lean.Expr.getAppNumArgs]]
[Lean.Lsp.Ipc.stdin,[Bind.bind, MonadReader.read, Pure.pure, IO.FS.Stream.ofHandle, IO.Process.Child.stdin]]
[Array.split,[Array.foldl, Prod, Array, ite, Eq, Bool.true, Prod.mk, Array.push, List.toArray, List.nil, OfNat.ofNat, Array.size]]
[Lean.unbracketedExplicitBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.binderIdent, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat]]
[Tactic.instInhabitedCache,[inferInstanceAs, Inhabited, IO.Ref, Sum, Lean.Meta.MetaM, Task, Except, Lean.Exception]]
[Lean.Elab.Term.Do.Code.match.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Code.match, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Level.num.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.numLit.formatter]]
[IO.Error.timeExpired.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.timeExpired, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Server.Watchdog.forwardNotification,[Lean.Server.Watchdog.tryWriteMessage, Lean.Lsp.FileSource.fileSource, Lean.JsonRpc.Message.notification, Lean.JsonRpc.Notification.method, Lean.JsonRpc.Notification.mk, Except.toOption, Lean.Json.toStructured?, Lean.JsonRpc.Notification.param, Bool.true, Bool.false]]
[Lean.Compiler.hasInlineIfReduceAttribute,[Lean.Compiler.InlineAttributeKind.inlineIfReduce]]
[Lean.Elab.Term.Do.JPDecl.params,[]]
[Lean.Elab.Command.elabMacroRulesAux,[Bind.bind, Array.mapM, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, not, Lean.Syntax.isQuot, Lean.Elab.throwUnsupportedSyntax, Pure.pure, PUnit.unit, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Array.append, List.nil, Unit.unit, Array, Lean.Syntax, Array.empty, Lean.Syntax.atom, Lean.mkIdent, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.mkIdentFrom, Prod.mk, Array.push]]
[Lean.Parser.Tactic.unfold,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.Parser.Tactic.location]]
[Lean.Elab.Info.ofFieldInfo.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Info.ofFieldInfo, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.LocalContext.any,[Id.run, Lean.LocalContext.anyM]]
[Lean.Meta.smartUnfoldingSuffix,[]]
[Lean.Parser.Term.attr.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.attrParser.parenthesizer]]
[Lean.registerInternalExceptionId,[Bind.bind, ST.Ref.get, Lean.internalExceptionsRef, ite, Eq, Array.contains, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Pure.pure, PUnit.unit]]
[Lean.Parser.addParserTokens,[List.foldlM, ite, Eq, BEq.beq, Bool.true, MonadExcept.throw, Unit.unit, Except, String, Lean.Parser.TokenTable, Lean.Parser.Trie.find?, Pure.pure, Lean.Parser.Trie.insert]]
[Lean.Server.RequestError.toLspResponseError,[Lean.JsonRpc.ResponseError.mk, Lean.Server.RequestError.code, Lean.Server.RequestError.message]]
[List.bind_map,[Unit.unit, Eq, List.map, List.bind, rfl, of_eq_true, Eq.trans, congr, congrArg, List.cons_bind, List.map_append, HAppend.hAppend, PProd.fst, eq_self]]
[Nat.lcm_ne_zero,[]]
[Lean.Compiler.SpecArgKind.fixedHO.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Option.name,[]]
[le_of_not_lt,[LE.le, lt_trichotomy, le_of_lt, le_refl, absurd]]
[fixCore3,[bfix3, USize.size]]
[Lean.Elab.Term.Do.mkContinue,[Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.continue]]
[Lean.Lsp.ServerInfo.noConfusionType,[]]
[max_eq_left,[Eq.symm, eq_max, le_refl]]
[ofNat_add,[Eq, Numeric.ofNat, HAdd.hAdd, Eq.symm, add_zero, OfNat.ofNat, Trans.trans, Semiring.ofNat_succ, Nat.add, of_eq_true, Eq.trans, congr, congrArg, congrFun, Nat.add_eq, Nat.add_zero, PProd.fst, add_assoc, eq_self]]
[Lean.Widget.traverse,[Bind.bind, Lean.Meta.instantiateMVars, Lean.MonadLCtx.getLCtx, List.drop, OfNat.ofNat, List.nil, Lean.Widget.traverse.tritsLE, Lean.Widget.traverse.go]]
[Lean.Parser.Command.noncomputableSection.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.ident.formatter]]
[Lean.Meta.ToHide.State.hiddenInaccessibleProp,[]]
[Lean.Elab.Term.elabAppArgs,[Bind.bind, liftM, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Substring.dropRight,[Substring.mk, Substring, HAdd.hAdd, Substring.prevn, Substring.bsize]]
[Lean.mkProjectionInfoEx,[Lean.ProjectionFunctionInfo.mk]]
[ne_of_gt,[absurd, lt_irrefl]]
[lt_of_le_of_lt,[LT.lt, lt_of_le_not_le, le_trans]]
[Lean.mkNoConfusionEnum.mkToCtorIdx,[Bind.bind, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.Meta.MetaM, Unit, Lean.Meta.mkArrow, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Meta.withLocalDeclD, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.mkLambdaFVars, List.toArray, List.cons, List.nil, Bool.false, Bool.true, Lean.mkAppN, Lean.mkApp2, Lean.mkConst, Lean.mkCasesOnName, Lean.levelOne, Lean.addAndCompile, Lean.Declaration.defnDecl, Lean.DefinitionVal.mk, Lean.ConstantVal.mk, Lean.ReducibilityHints.abbrev, Lean.DefinitionSafety.safe, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Parser.Tactic.introNoMatch,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol]]
[Lean.Meta.SynthInstance.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PPFns.mk.inj,[And.intro]]
[Lean.Meta.SimpAll.Entry.proof,[]]
[Lean.Widget.Lean.Widget.MsgToInteractive.instFromJsonRpcEncodingPacket,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.RpcRef, Nat, Pure.pure]]
[Lean.IR.UnreachableBranches.getFunctionSummary?,[Lean.SMap.find?, Lean.SimplePersistentEnvExtension.getState, Lean.IR.UnreachableBranches.functionSummariesExt]]
[UInt16.instAddSemigroupUInt16.proof_1,[congrArg, UInt16.mk, AddSemigroup.add_assoc, UInt16.val]]
[Lean.Elab.applyVisibility,[Lean.Elab.Visibility.regular, Unit.unit, Lean.Name, Bind.bind, Lean.MonadEnv.getEnv, Lean.Elab.checkNotAlreadyDeclared, Pure.pure, Lean.setEnv]]
[Nat.sub.right_comm,[Eq.mpr, Eq.refl, Eq, HSub.hSub, Nat.sub_sub, HAdd.hAdd, Nat.add_comm, rfl]]
[Std.Format.isNil,[Unit.unit, Std.Format.line, Std.Format.text, Std.Format.nest, Std.Format.append, Std.Format.group, Std.Format.tag, Bool, Bool.true, Bool.false]]
[Lean.PrettyPrinter.Formatter.instCoeArrowFormatterFormatterFormatterAliasValue,[Coe.mk, Lean.Parser.AliasValue.unary]]
[Lean.Lsp.SymbolKind.function.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Export.exportName,[Bind.bind, MonadState.get, Unit.unit, Lean.ExportM, Nat, Std.HashMap.find?, Lean.Export.Alloc.map, Lean.Export.State.names, Pure.pure, OfNat.ofNat, Lean.Export.alloc, PProd.fst, liftM, IO.println, HAppend.hAppend, ToString.toString]]
[Lean.Parser.Command.variable.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.ppSpace.formatter, Lean.Parser.Term.bracketedBinder.formatter, Bool.false]]
[Lean.SCC.Data.onStack,[]]
[Lean.Elab.Term.elabType,[Bind.bind, liftM, Lean.Meta.mkFreshLevelMVar, Lean.Elab.Term.elabTerm, Option.some, Lean.mkSort, Bool.true, Lean.withRef, Lean.Elab.Term.ensureType]]
[Nat.lt_iff_le_not_le,[Iff.intro, And.intro, Nat.le_of_lt, Nat.not_le_of_gt, Nat.gt_of_not_le, And.right]]
[Lean.JsonRpc.ResponseError.message,[]]
[Lean.Parser.checkOutsideQuot,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.checkOutsideQuotFn]]
[instReprUInt8,[Repr.mk, repr, UInt8.toNat]]
[Lean.Parser.Command.genInjectiveTheorems.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer]]
[Except.ok.inj,[]]
[Lean.Elab.Term.getLevelNames,[Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Term.State.levelNames]]
[eq_false',[propext, Iff.intro, absurd, False.elim]]
[Lean.MetavarContext.depth,[]]
[Lean.JsonRpc.ResponseError.code,[]]
[instAddCommGroup.proof_5,[AddCommSemigroup.add_comm]]
[Lean.Parser.Syntax.numPrec.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.numLit.parenthesizer]]
[IO.AccessRight.noConfusionType,[]]
[Std.Format.text.inj,[]]
[Lean.Widget.Lean.Widget.InfoPopup.instToJsonRpcEncodingPacket,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil]]
[eq_true,[propext, Iff.intro, trivial]]
[Lean.Meta.ToHide.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.RpcCallParams.toTextDocumentPositionParams,[]]
[Lean.Meta.GeneralizeIndicesSubgoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Macro.instMonadRefMacroM,[Lean.MonadRef.mk, Bind.bind, MonadReader.read, Pure.pure, Lean.Macro.Context.ref, MonadWithReader.withReader, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth]]
[Lean.JsonRpc.Request.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MetavarContext.mvarCounter,[]]
[Lean.Declaration.inductDecl.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Declaration.inductDecl, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.MessageData.ofExpr.injEq,[Eq.propIntro, Eq.refl, Lean.MessageData.ofExpr, Eq.symm, eq_of_heq, HEq.refl]]
[Substring.contains,[Substring.any, BEq.beq]]
[System.instReprFilePath,[Repr.mk, Repr.addAppParen, HAppend.hAppend, Std.Format.text, repr, System.FilePath.toString]]
[Lean.Elab.Term.instToStringArg,[ToString.mk, String, ToString.toString]]
[Lean.IR.Borrow.getParamInfo,[Bind.bind, MonadState.get, Unit.unit, Lean.IR.Borrow.M, Array, Lean.IR.Param, Std.HashMap.find?, Lean.IR.Borrow.BorrowInfState.paramMap, Pure.pure, Lean.IR.Borrow.ParamMap.Key.jp, MonadReader.read, Lean.IR.findEnvDecl, Lean.IR.Borrow.BorrowInfCtx.env, Lean.IR.Decl.params, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Lsp.instToJsonDidOpenTextDocumentParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.DidOpenTextDocumentParams.textDocument, List.nil]]
[Mathlib.Tactic.Lint.instDecidableEqLintVerbosity.proof_1,[]]
[Lean.Parser.ppIndent.parenthesizer,[]]
[Lean.KVMap.mk.inj,[]]
[Lean.Elab.Term.SyntheticMVarDecl.stx,[]]
[ByteSlice.arr,[]]
[Nat.pos_of_dvd_of_pos,[Nat.pos_of_ne_zero, Nat.lt_irrefl, OfNat.ofNat, Eq.mp, Eq.refl, LT.lt, Nat.eq_zero_of_zero_dvd, Dvd.dvd]]
[Lean.Level.isIMax,[Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.param, Lean.Level.mvar, Bool, Bool.true, Bool.false]]
[Lean.Lsp.instFromJsonInitializationOptions,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, Nat, Pure.pure, Lean.Lsp.InitializationOptions.mk]]
[Lean.IR.EmitC.emitIsShared,[Bind.bind, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn]]
[instToStreamStringSubstring,[ToStream.mk, String.toSubstring]]
[Lean.PrettyPrinter.Formatter.instCoeFormatterFormatterAliasValue,[Coe.mk, Lean.Parser.AliasValue.const]]
[proof_irrel,[proofIrrel]]
[Lean.Parser.Token,[String]]
[Nat.div.inductionOn,[WellFounded.fix, WellFoundedRelation.wf, measure, id, dite, And, LT.lt, OfNat.ofNat, LE.le, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le]]
[Lean.Meta.Match.Extension.Entry.noConfusionType,[]]
[Lean.Elab.Tactic.mkTacticInfo,[Bind.bind, MonadReader.read, Lean.MonadMCtx.getMCtx, Lean.Elab.Tactic.getUnsolvedGoals, Pure.pure, Lean.Elab.Info.ofTacticInfo, Lean.Elab.TacticInfo.mk, Lean.Elab.ElabInfo.mk, Lean.Elab.Tactic.Context.elaborator]]
[List.elem,[Unit.unit, Bool, Bool.false, BEq.beq, Bool.true, PProd.fst]]
[Mathlib.Tactic.Lint.NamedLinter.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.EnvironmentHeader.mainModule,[]]
[WellFounded.fixFEq,[WellFounded.fixFEq.proof_1]]
[Lean.Parser.Term.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.PrettyPrinter.Parenthesizer.many1Unbox.parenthesizer, Lean.Parser.commandParser.parenthesizer]]
[Lean.IR.EmitC.emitUProj,[Bind.bind, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn]]
[Lean.Json.CompressWorkItem.objectField.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Json.CompressWorkItem.objectField, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.RecursorRule.ctor,[]]
[Lean.MVarIdMap,[Std.RBMap, Lean.MVarId, Lean.Name.quickCmp, Lean.MVarId.name]]
[Lean.Core.withIncRecDepth,[controlAt, Lean.Core.CoreM, Lean.withIncRecDepth]]
[Lean.PrettyPrinter.Delaborator.instMonadStateOfHoleIteratorDelabM,[MonadStateOf.mk, Functor.map, Lean.PrettyPrinter.Delaborator.State.holeIter, MonadState.get, modify, Lean.PrettyPrinter.Delaborator.State, Lean.PrettyPrinter.Delaborator.State.mk, MonadState.modifyGet, Prod, Prod.mk]]
[Array.anyM.loop,[dite, LT.lt, Unit.unit, Bool, Pure.pure, Bool.false, Bind.bind, Array.get, Fin.mk, Array.anyM.loop.proof_1, ite, Eq, Bool.true, PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[Lean.RecursorVal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.RecursorVal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.CompletionInfo.endSection.inj,[And.intro]]
[Lean.Elab.Term.Do.Code.ibelow,[And, True]]
[Lean.TraceState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.TraceState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[IO.FS.instLTSystemTime,[ltOfOrd]]
[IO.instInhabitedError,[Inhabited.mk, IO.Error.alreadyExists, arbitrary]]
[Nat.instShiftLeftNat,[ShiftLeft.mk, Nat.shiftLeft]]
[Lean.Elab.Command.ElabStructResult.decl,[]]
[Lean.PrettyPrinter.Parenthesizer.checkOutsideQuot.parenthesizer,[Pure.pure, Unit.unit]]
[Lean.Elab.Term.PatternElabException.patternIdx,[]]
[Lean.Elab.Tactic.Conv.evalNestedTacticCore,[Bind.bind, Lean.Elab.Tactic.evalTactic, Lean.Elab.Tactic.Conv.remarkAsConvGoal]]
[Function.right_inverse.comp,[Function.left_inverse.comp]]
[Lean.Parser.Command.terminationHint.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.terminationHintMany.formatter, Lean.Parser.Command.terminationHint1.formatter]]
[Lean.mkRecOnName,[Lean.Name.mkStr, Lean.recOnSuffix]]
[Lean.Elab.WF.instInhabitedTerminationHintValue,[Inhabited.mk, Lean.Elab.WF.TerminationHintValue.mk, arbitrary]]
[Lean.Elab.Command.StructFieldKind.newField.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.MVarRenaming.insert,[Lean.Meta.MVarRenaming.mk, Std.RBMap.insert, Lean.Meta.MVarRenaming.map]]
[Lean.Parser.Tactic.unfoldCoes,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.Lsp.VersionedTextDocumentIdentifier.noConfusionType,[]]
[Std.HashSetImp.mkIdx,[Subtype.mk, HMod.hMod, USize.modn_lt]]
[Lean.MetavarContext.lAssignment,[]]
[List.any,[List.foldr, or, Bool.false]]
[Lean.Xml.Element.noConfusionType,[]]
[Lean.Parser.andthenFn,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true]]
[Std.MonadShareCommon.noConfusionType,[]]
[Std.Format.defWidth,[OfNat.ofNat]]
[Lean.Parser.Tactic.inferAutoParam,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[List.ball_cons,[Iff.intro, And.intro, List.mem_cons_self, List.mem_cons_of_mem, Or.elim, Eq.mpr, Eq.refl]]
[List.subset_of_cons_subset,[List.mem_cons_of_mem]]
[Lean.IR.EmitC.emitDel,[Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn]]
[Lean.Expr.updateProj,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr, Lean.mkProj]]
[UInt32.instAddSemigroupUInt32.proof_1,[congrArg, UInt32.mk, AddSemigroup.add_assoc, UInt32.val]]
[Lean.registerSimplePersistentEnvExtension,[Lean.registerPersistentEnvExtension, Lean.PersistentEnvExtensionDescr.mk, Lean.SimplePersistentEnvExtensionDescr.name, Pure.pure, Prod.mk, List.nil, Lean.SimplePersistentEnvExtensionDescr.addImportedFn, List.toArray, Prod, List, List.cons, Lean.SimplePersistentEnvExtensionDescr.addEntryFn, Lean.SimplePersistentEnvExtensionDescr.toArrayFn, List.reverse, Prod.fst, HAppend.hAppend, Std.ToFormat.format, List.length]]
[Mathlib.Tactic.Lint.LintVerbosity.medium.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.FirstTokens.optTokens.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.FirstTokens.optTokens, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.ParserExtension.State.noConfusionType,[]]
[Lean.Parser.Command.openScoped.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer, Lean.Parser.ident.parenthesizer]]
[ite_congr,[Decidable.em, Eq.mpr, Eq.refl, Eq, ite, if_pos, Eq.symm, if_neg]]
[Lean.Elab.Command.elabSynth,[Lean.withoutModifyingEnv, Lean.Elab.Command.runTermElabM, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.Elab.Term.elabTerm, Option.none, Bool.true, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Bool.false, liftM, Lean.Meta.instantiateMVars, Lean.Meta.synthInstance, Lean.Elab.logInfo, Lean.MessageData.ofExpr, Pure.pure, Unit.unit]]
[prod_map,[rfl, Eq.symm, Eq.refl]]
[Lean.Unhygienic.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.UnreachableBranches.Value.ctor.inj,[And.intro]]
[Lean.Elab.Term.LetIdDeclView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.LetIdDeclView.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.le_of_succ_le,[Nat.le_trans, Nat.le_succ]]
[Lean.Expr.FoldConstsImpl.foldUnsafe,[StateT.run', Lean.Expr.FoldConstsImpl.fold, Lean.Expr.FoldConstsImpl.cacheSize, Lean.Expr.FoldConstsImpl.initCache]]
[Lean.Parser.ParserContext.toParserModuleContext,[]]
[List.decidablePairwise.proof_2,[]]
[Lean.Elab.withSaveInfoContext,[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, ite, Eq, Lean.Elab.InfoState.enabled, Bool.true, Lean.Elab.getResetInfoTrees, Functor.map, Prod.fst, MonadFinally.tryFinally', Std.PersistentArray.mapM, Lean.MonadEnv.getEnv, Lean.MonadFileMap.getFileMap, Lean.MonadMCtx.getMCtx, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, Lean.MonadOptions.getOptions, Pure.pure, Lean.Elab.InfoTree.context, Lean.Elab.ContextInfo.mk, Lean.Elab.InfoState.trees, Lean.Elab.MonadInfoTree.modifyInfoState, Lean.Elab.InfoState.mk, Lean.Elab.InfoState.assignment, HAppend.hAppend]]
[Array.foldlM,[dite, LE.le, Array.size, Array.foldlM.proof_1]]
[Lean.MetavarContext.eAssignment,[]]
[«term_×'_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.bracketedExplicitBinders, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.Match.Pattern.val.inj,[]]
[Lean.IR.Borrow.BorrowInfState.modified,[]]
[Lean.withRef,[Bind.bind, Lean.MonadRef.getRef, Lean.MonadRef.withRef]]
[Lean.Parser.Tactic.Conv.guardTarget,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.IR.push,[Array.push]]
[Lean.Lsp.VersionedTextDocumentIdentifier.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.VersionedTextDocumentIdentifier.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Delaborator.isNonConstFun,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Bool, PProd.fst, PProd.snd, Pure.pure, Lean.Expr.hasLooseBVars]]
[Lean.Meta.Simp.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Simp.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.add_sub_cancel',[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HSub.hSub, Nat.add_comm, Nat.sub_add_cancel, rfl]]
[Lean.Elab.Term.ElabAppArgs.M,[StateRefT', IO.RealWorld, Lean.Elab.Term.ElabAppArgs.State, Lean.Elab.Term.TermElabM]]
[Lean.Meta.withPPInaccessibleNamesImp,[withTheReader, Lean.Core.Context, Lean.Core.Context.mk, Lean.Option.setIfNotSet, Lean.Core.Context.options, Lean.Meta.pp.inaccessibleNames, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats]]
[Lean.Elab.Command.mkDefViewOfDef,[Lean.Elab.DefView, Lean.Elab.DefView.mk, Lean.Elab.DefKind.def, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Parser.nonReservedSymbol.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.tokenWithAntiquot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.nonReservedSymbolNoAntiquot.parenthesizer]]
[Lean.IR.DeclInfo.sorryDep?,[]]
[Lean.Meta.Simp.Step.noConfusionType,[]]
[EIO.asTask,[BaseIO.asTask, EIO.toBaseIO]]
[Nat.le_of_lt,[Nat.le_of_succ_le]]
[Lean.Parser.Tactic.tacticShow_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.getExternNameFor,[OptionM.run, Bind.bind, Lean.getExternAttrData, Lean.getExternEntryFor, Lean.ExternEntry.adhoc, Lean.ExternEntry.inline, OptionM, String, Pure.pure, Alternative.failure]]
[Lean.Lsp.WorkspaceFolder.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MonadNameGenerator.setNGen,[]]
[Lean.KVMap.Value.toDataValue,[]]
[Lean.JsonRpc.RequestID.num.injEq,[Eq.propIntro, Eq.refl, Lean.JsonRpc.RequestID.num, Eq.symm, eq_of_heq, HEq.refl]]
[UInt8.instSemigroupUInt8,[Semigroup.mk, UInt8.instSemigroupUInt8.proof_1]]
[Fin.sub_def,[Eq, HSub.hSub, Fin.mk, HMod.hMod, HAdd.hAdd, Fin.val, Nat.mod_lt, Fin.size_positive, rfl]]
[Lean.IR.Borrow.ApplyParamMap.visitDecls,[Array.map, Lean.IR.Decl.extern, Lean.IR.Decl, Unit.unit, Std.HashMap.find?, Lean.IR.Borrow.ParamMap.Key.decl, Lean.IR.Decl.fdecl, panicWithPosWithDecl, OfNat.ofNat]]
[Nat.div_mul_cancel,[Eq.mpr, Eq.refl, Eq, HMul.hMul, HDiv.hDiv, Nat.mul_comm, Nat.mul_div_cancel', rfl]]
[lt_or_eq_of_le,[Decidable.lt_or_eq_of_le]]
[Lean.instFromJsonUSize,[Lean.FromJson.mk, Bind.bind, Lean.bignumFromJson?, ite, GE.ge, USize.size, MonadExcept.throw, Pure.pure, PUnit.unit]]
[Lean.KernelException.unknownConstant.inj,[And.intro]]
[Lean.IR.CtorLayout.numUSize,[]]
[Nat.gcd_le_left,[Nat.le_of_dvd, Nat.gcd_dvd_left]]
[Lean.Parser.Command.reduce.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.Level.Data,[UInt64]]
[Lean.Parser.binNumberFn,[Lean.Parser.mkNodeToken, Lean.numLitKind]]
[implies_of_if_pos,[]]
[Lean.Syntax.modifyArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.node]]
[decide_eq_true_iff,[Iff.intro, of_decide_eq_true, decide_eq_true]]
[EStateM.Result.error.injEq,[Eq.propIntro, And.intro, Eq.refl, EStateM.Result.error, Eq.symm, eq_of_heq, HEq.refl]]
[prioLow,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[String.get,[Char, arbitrary, ite, Eq, PProd.fst, HAdd.hAdd, String.csize, OfNat.ofNat]]
[Lean.Elab.Tactic.deltaTarget,[Bind.bind, Lean.Elab.Tactic.getMainGoal, Lean.Elab.Tactic.getMainTarget, liftM, Lean.Meta.deltaExpand, BEq.beq, ite, Eq, Bool.true, Lean.Meta.throwTacticEx, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Syntax.missing, Pure.pure, PUnit.unit]]
[Lean.NamingContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.NamingContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Int.subNatNat_of_sub_eq_zero,[]]
[List.forIn,[List.forIn.loop]]
[iff_of_false,[Iff.intro, Not.elim]]
[Lean.Meta.instInhabitedUnificationHintEntry,[Inhabited.mk, Lean.Meta.UnificationHintEntry.mk, arbitrary]]
[Lean.Parser.Tactic.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.tacticParser.formatter]]
[Lean.Elab.Term.expandTermReturn,[Lean.withRef, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Nat.min_succ_succ,[]]
[List.anyM,[Unit.unit, Bool, Pure.pure, Bool.false, Bind.bind, Bool.true, PProd.fst]]
[Lean.NameMap.contains,[Std.RBMap.contains]]
[Lean.Lsp.instFromJsonTextDocumentSyncOptions,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Bool, Lean.Lsp.TextDocumentSyncKind, Option, Lean.Lsp.SaveOptions, Pure.pure, Lean.Lsp.TextDocumentSyncOptions.mk]]
[Lean.Meta.CongrLemma.mk.inj,[And.intro]]
[IO.AsyncList.instInhabitedAsyncList,[Inhabited.mk, IO.AsyncList.nil]]
[UInt8.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.doLet.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Term.letDecl.parenthesizer]]
[Lean.Server.RpcEncoding.DerivingParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Compiler.SpecArgKind.fixedInst.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[EStateM.seqRight,[EStateM.Result, Unit.unit, EStateM.Result.error]]
[Coe.noConfusionType,[]]
[Lean.Parser.Tactic.mono.side,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.IR.NormalizeIds.normDecl,[Lean.IR.Decl.extern, Lean.IR.NormalizeIds.N, Lean.IR.Decl, Lean.IR.NormalizeIds.withParams, Bind.bind, Lean.IR.NormalizeIds.normFnBody, Pure.pure, Lean.IR.Decl.updateBody!]]
[Lean.Widget.InfoPopup.doc,[]]
[Lean.LOption.undef.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[String.Iterator.next,[String.Iterator, String.Iterator.mk, String.next]]
[Lean.Core.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.AltVarNames.explicit,[]]
[Lean.Lsp.PlainGoalParams.mk.inj,[]]
[InvImage.wf,[InvImage.wf.proof_1]]
[Lean.Parser.Command.optNamedName.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.Parser.Command.namedName.parenthesizer]]
[Std.ShareCommon.Object.ptrHash,[USize.toUInt64, ptrAddrUnsafe]]
[Lean.InternalExceptionId.getName,[Bind.bind, ST.Ref.get, Lean.internalExceptionsRef, dite, LT.lt, Array.size, Pure.pure, Array.get, Fin.mk, MonadExcept.throw, IO.userError]]
[List.getLastD.proof_1,[]]
[Lean.instBEqData_1,[BEq.mk, BEq.beq]]
[IO.FS.instBEqSystemTime,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.NameGenerator.idx,[]]
[EStateM.fromStateM,[EStateM.Result, StateT.run, EStateM.Result.ok]]
[Char.utf8Size.proof_2,[of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Lsp.ProgressParams.token,[]]
[Lean.Json.null.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.ScopedEnvExtension.addImportedFn,[Bind.bind, liftM, Lean.ScopedEnvExtension.Descr.mkInitial, ForIn.forIn, MProd.mk, Lean.ImportM, ForInStep, MProd, Lean.ScopedEnvExtension.ScopedEntries, Lean.ScopedEnvExtension.Descr.ofOLeanEntry, Pure.pure, PUnit.unit, ForInStep.yield, Lean.ScopedEnvExtension.StateStack, Lean.ScopedEnvExtension.StateStack.mk, List.cons, Lean.ScopedEnvExtension.State.mk, List.nil]]
[Lean.Elab.Command.StructView.isClass,[]]
[Lean.PrettyPrinter.Parenthesizer.term.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.nullKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.throwBacktrack, Lean.PrettyPrinter.Parenthesizer.maybeParenthesize, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Unhygienic.run, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.PrettyPrinter.Parenthesizer.parenthesizeCategoryCore]]
[Lean.Macro.Context.mainModule,[]]
[Lean.Expr.Data.binderInfo,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Lean.BinderInfo.default, Lean.BinderInfo.implicit, Lean.BinderInfo.strictImplicit, Lean.BinderInfo.instImplicit, Lean.BinderInfo.auxDecl]]
[Lean.Parser.ParserExtension.State.tokens,[]]
[Prod.swap_prod_mk,[rfl]]
[Lean.MonadEnv.noConfusionType,[]]
[Lean.Elab.Term.StructInst.Field.noConfusionType,[]]
[Lean.IR.CtorLayout.mk.inj,[And.intro]]
[Lean.IR.EmitC.emitReuse,[Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitLn, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.emitAllocCtor, ite, Eq, Bool.true, Lean.IR.CtorInfo.cidx, Pure.pure, PUnit.unit]]
[Lean.Parser.checkInsideQuot,[Lean.Parser.Parser.mk, Lean.Parser.epsilonInfo, Lean.Parser.checkInsideQuotFn]]
[Lean.Parser.Command.mixfixKind.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Command.prefix.formatter, Lean.Parser.Command.infix.formatter, Lean.Parser.Command.infixl.formatter, Lean.Parser.Command.infixr.formatter, Lean.Parser.Command.postfix.formatter]]
[List.length_dropLast,[Unit.unit, Eq, List.length, List.dropLast, HSub.hSub, OfNat.ofNat, rfl]]
[Lean.IR.FnBody.mdata.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[congr_arg2,[rfl]]
[or_iff_left_iff_imp,[Iff.intro, Iff.mp, Or.inr, or_iff_left_of_imp]]
[Lean.Elab.Term.ExtractMonadResult.noConfusionType,[]]
[Lean.NamingContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Macro.hasDecl,[Bind.bind, Lean.Macro.getMethods, Lean.Macro.Methods.hasDecl]]
[Complement.complement,[]]
[Lean.AttributeImplCore.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.AttributeImplCore.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Syntax.ident.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Syntax.ident, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.SimpAll.Entry.noConfusionType,[]]
[Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer,[]]
[Lean.Elab.WF.instInhabitedTerminationHint,[Inhabited.mk, Lean.Elab.WF.TerminationHint.none]]
[Lean.SyntaxNode.getArgs,[Lean.SyntaxNode.withArgs]]
[Lean.IR.instInhabitedArg,[Inhabited.mk, Lean.IR.Arg.var, arbitrary]]
[Lean.Parser.Tactic.«tactic·._»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Std.HashMapImp.erase.proof_1,[Subtype.property]]
[Lean.Elab.Term.Do.Code.action.inj,[]]
[Lean.Elab.ContextInfo.env,[]]
[Lean.Elab.Tactic.instMonadTacticM,[Monad.mk]]
[Lean.Widget.InfoWithCtx.ctx,[]]
[Lean.Parser.Tactic.Conv.arg,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Lean.ScopedEnvExtension.Descr.ofOLeanEntry,[]]
[Lean.Expr.arrow?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Prod, Lean.Expr, ite, Eq, Lean.Expr.hasLooseBVars, Bool.true, Option.none, Option.some, Prod.mk]]
[Lean.Elab.MacroStackElem.before,[]]
[USize.instSemiringUSize.proof_4,[congrArg, USize.mk, AddMonoid.nsmul_succ', USize.val]]
[Lean.Elab.Term.Do.DoIfView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.DoIfView.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Do.Code.return.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Code.return, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.InductiveVal.numIndices,[]]
[Nat.exists_coprime',[Exists, And, LT.lt, OfNat.ofNat, Nat.coprime, Eq, HMul.hMul, Exists.intro, Nat.gcd, And.intro]]
[Lean.Parser.Command.derivingClasses.parenthesizer,[Lean.Parser.sepBy1.parenthesizer, Lean.Parser.group.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.structInst.parenthesizer, Bool.false]]
[ByteArray.set,[ByteArray, ByteArray.mk, Array.set]]
[Lean.Parser.Command.optDefDeriving,[Lean.Parser.optional, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.notSymbol, Lean.Parser.sepBy1, Lean.Parser.ident, Bool.false]]
[Lean.Elab.Term.precheckMatch,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Unit.unit, Lean.Elab.Term.Quotation.PrecheckM, Unit, OptionM.run, Array.sequenceMap, Array.getSepElems, Lean.Syntax.getArgs, Option.some, Option.none, OptionM, Prod, Array, Lean.Syntax, Prod.mk, Bind.bind, Array.forM, Lean.Elab.Term.Quotation.precheck, Array.size, ForIn.forIn, MProd.mk, PUnit.unit, ForInStep, MProd, Option, PUnit, MonadExcept.tryCatch, liftM, Lean.Elab.Term.getPatternsVars, Pure.pure, DoResultPR.pure, DoResultPR, Lean.Elab.Term.PatternVar, DoResultPR.return, ForInStep.done, MProd.fst, Lean.Elab.throwUnsupportedSyntax]]
[and_symm_right,[Iff.intro, And, Eq, And.intro, Eq.symm]]
[Lean.mkDecIsFalse,[Lean.mkAppB, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Lean.Elab.Term.Do.Alt.rhs,[]]
[xor_true,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, funext, congr, Or, true_and, Not, And, eq_false_of_decide, Eq.refl, Bool.false, and_false, or_false, eq_self]]
[IO.FS.SystemTime.noConfusionType,[]]
[Lean.Xml.instToStringAttributes,[ToString.mk, Std.RBMap.fold, HAppend.hAppend, ToString.toString]]
[String.utf16Length,[String.foldr, HAdd.hAdd, UInt32.toNat, Char.utf16Size, OfNat.ofNat]]
[Lean.Parser.Term.letEqnsDecl,[Lean.Parser.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, HAndThen.hAndThen, Lean.Parser.Term.letIdLhs, HOrElse.hOrElse, Lean.Parser.symbol, Lean.Parser.Term.matchAlts, Lean.Parser.termParser, OfNat.ofNat, Bool.false]]
[le_antisymm,[PartialOrder.le_antisymm]]
[Lean.Meta.Closure.State.levelArgs,[]]
[Mathlib.Tactic.Conv.convLHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.Conv.convSeq]]
[imp_congr_right,[Iff.intro, Iff.mp, Iff.mpr]]
[List.unzip,[Unit.unit, Prod, List, Prod.mk, List.nil, PProd.fst, List.cons]]
[Lean.Lsp.DidCloseTextDocumentParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DidCloseTextDocumentParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[PartialOrder.toPreorder,[]]
[Lean.Parser.Tactic.obviously,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Meta.getFunInfoNArgs,[Bind.bind, MonadState.get, Lean.Meta.getTransparency, Unit.unit, Lean.Meta.MetaM, Lean.Meta.FunInfo, Std.PersistentHashMap.find?, Lean.Meta.Cache.funInfo, Lean.Meta.State.cache, Lean.Meta.InfoCacheKey.mk, Pure.pure, modify, Lean.Meta.State.mk, Lean.Meta.State.mctx, Lean.Meta.Cache.mk, Lean.Meta.Cache.inferType, Std.PersistentHashMap.insert, Lean.Meta.Cache.synthInstance, Lean.Meta.Cache.whnfDefault, Lean.Meta.Cache.whnfAll, Lean.Meta.Cache.defEqDefault, Lean.Meta.Cache.defEqAll, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed, Lean.Meta.inferType, Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.default, Lean.Meta.forallBoundedTelescope, ForIn.forIn, Lean.Meta.getFVarLocalDecl, PUnit.unit, ForInStep.yield, Lean.Meta.FunInfo.mk, Option.some]]
[Lean.Elab.Structural.EqnsExtState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Match.Example.arrayLit.inj,[]]
[Lean.MessageData.ofExpr.inj,[]]
[Lean.Syntax.decodeScientificLitVal?.decodeExp,[ite, Eq, BEq.beq, Char.ofNat, Bool.true, Lean.Syntax.decodeScientificLitVal?.decodeAfterExp, String.next, OfNat.ofNat, Bool.false]]
[List.Perm.subset,[List.nil_subset, List.nil, List.cons_subset_cons, Eq.mpr, Eq.refl, Mem.mem, List.cons, propext, List.mem_cons, Or.inr, Or.inl, List.subset.trans]]
[Lean.Parser.Term.sufficesDecl,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.optIdent, Lean.Parser.termParser, HOrElse.hOrElse, Lean.Parser.Term.fromTerm, Lean.Parser.Term.byTactic]]
[Substring.foldr,[String.foldrAux]]
[Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parsec.unexpectedEndOfInput,[]]
[Lean.Lsp.SemanticTokenType.names,[List.toArray, List.cons, List.nil]]
[Nat.zero_ne_one,[]]
[Lean.EnvExtensionInterface.modifyState,[]]
[Lean.instInhabitedInductiveType,[Inhabited.mk, Lean.InductiveType.mk, arbitrary]]
[Lean.Parser.trailingNodeAux,[Lean.Parser.Parser.mk, Lean.Parser.nodeInfo, Lean.Parser.Parser.info, Lean.Parser.trailingNodeFn, Lean.Parser.Parser.fn]]
[Lean.ClassEntry.mk.inj,[And.intro]]
[Lean.Expr.getAppNumArgsAux,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Nat, PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.SemanticTokensRangeParams.mk.inj,[And.intro]]
[Lean.Meta.replaceLocalDecl,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.getLocalDecl, Lean.Meta.mkEqMP, Lean.mkFVar, StateRefT'.run, Lean.Meta.MetaM, Lean.Meta.AssertAfterResult, Lean.Meta.assertAfter, Lean.LocalDecl.fvarId, Lean.LocalDecl.userName, HOrElse.hOrElse, Lean.Meta.clear, Lean.Meta.AssertAfterResult.mvarId, Pure.pure, Lean.Meta.AssertAfterResult.mk, Lean.Meta.AssertAfterResult.fvarId, Lean.Meta.AssertAfterResult.subst, Lean.Meta.replaceLocalDecl.findMaxFVar]]
[Lean.Expr.const.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.const, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.strLitNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.strLitFn]]
[Lean.Lsp.StaticRegistrationOptions.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.StaticRegistrationOptions.mk, Eq.symm, eq_of_heq, HEq.refl]]
[or_congr_right,[or_congr, Iff.rfl]]
[Lean.FVarId.noConfusionType,[]]
[instInhabitedUSize.proof_1,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, OfNat.ofNat, HEq.refl, LT.lt, USize.size, usize_size_eq, of_decide_eq_true, Bool.true]]
[IO.Ref,[ST.Ref, IO.RealWorld]]
[Lean.instBEqLOption,[BEq.mk, Unit.unit, Lean.LOption.none, Lean.LOption.some, Lean.LOption.undef, Bool, Bool.true, and, BEq.beq, Bool.false]]
[System.FilePath.join,[ite, Eq, System.FilePath.isAbsolute, Bool.true, System.FilePath.mk, HAppend.hAppend, System.FilePath.toString, Char.toString, System.FilePath.pathSeparator]]
[Lean.NameTrie.empty,[Lean.PrefixTree.empty]]
[Lean.instFromJsonInt,[Lean.FromJson.mk, Lean.Json.getInt?]]
[Lean.instToExprProd,[Lean.ToExpr.mk, Lean.Expr, Lean.mkApp4, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.levelZero, List.nil, Lean.ToExpr.toExpr, Lean.mkApp2]]
[Lean.IR.CtorInfo.name,[]]
[Lean.Meta.Rewrite.Config.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.optKind,[Lean.Parser.optional, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.ident]]
[Lean.Meta.SynthInstance.SubgoalsResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.Delaborator.instInhabitedSubExpr,[Inhabited.mk, Lean.PrettyPrinter.Delaborator.SubExpr.mk, arbitrary]]
[Lean.Meta.AuxLemmas.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.AuxLemmas.mk, Eq.symm, eq_of_heq, HEq.refl]]
[false_iff_true,[iff_false_intro, Iff.mpr, trivial]]
[Bind.bind,[]]
[Lean.Elab.Structural.EqnsExtState.map,[]]
[Lean.Server.FileWorker.initAndRunWorker,[Bind.bind, Lean.Server.maybeTee, Bool.false, Bool.true, IO.FS.Stream.readLspRequestAs, Lean.Lsp.InitializeParams, IO, UInt32, IO.FS.Stream.readLspNotificationAs, Lean.Lsp.DidOpenTextDocumentParams, Pure.pure, IO.FS.Stream.withPrefix, HAppend.hAppend, ToString.toString, Lean.Lsp.TextDocumentItem.uri, Lean.Lsp.DidOpenTextDocumentParams.textDocument, liftM, IO.setStderr, MonadExcept.tryCatch, Lean.Server.FileWorker.initializeWorker, StateRefT'.run, ReaderT.run, Lean.Server.FileWorker.mainLoop, OfNat.ofNat, IO.eprintln, Lean.Server.publishDiagnostics, List.toArray, List.cons, Lean.Lsp.DiagnosticWith.mk, Lean.Lsp.Range.mk, Lean.Lsp.Position.mk, Option.some, Lean.Lsp.DiagnosticSeverity.error, IO.Error.toString, List.nil]]
[Std.instEmptyCollectionRBTree,[EmptyCollection.mk, Std.mkRBTree]]
[Lean.Server.publishProgress,[IO.FS.Stream.writeLspNotification, Lean.JsonRpc.Notification.mk, Lean.Lsp.LeanFileProgressParams.mk, Lean.Lsp.VersionedTextDocumentIdentifier.mk, Lean.Server.DocumentMeta.uri, Option.some, Lean.Server.DocumentMeta.version]]
[Lean.Compiler.NumScalarTypeInfo.mk.inj,[And.intro]]
[Lean.JsonRpc.instInhabitedResponseError,[Inhabited.mk, Lean.JsonRpc.ResponseError.mk, arbitrary]]
[Lean.Compiler.NumScalarTypeInfo.toNatFn,[]]
[Lean.Parser.Tactic.Conv.convRight,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Lsp.DiagnosticCode.string.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.DiagnosticCode.string, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.LocalInstances.erase,[Option.none, Lean.LocalInstances, Array.findIdx?, BEq.beq, Lean.Expr.fvarId!, Lean.LocalInstance.fvar, Array.eraseIdx]]
[Lean.Name.instBEqName,[BEq.mk, Lean.Name.beq]]
[Lean.Server.Snapshots.Snapshot.msgLog,[Lean.Elab.Command.State.messages, Lean.Server.Snapshots.Snapshot.cmdState]]
[Lean.Parser.Command.example,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.declSig, Lean.Parser.Command.declVal]]
[Eq.mpr_not,[Eq.symm]]
[List.eq_nil_of_subset_nil,[Eq, List.nil, rfl, False.elim, List.mem_cons_self]]
[Lean.JsonRpc.Request.method,[]]
[Lean.Syntax.setInfo,[Unit.unit, Lean.Syntax, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax.node, Lean.Syntax.missing]]
[Lean.Parser.Term.arrow.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.unicodeSymbol.formatter, Lean.Parser.termParser.formatter]]
[Nat.gcd_gcd_self_right_left,[Nat.dvd_antisymm, Nat.gcd_dvd_right, Nat.gcd, Nat.dvd_gcd, Nat.gcd_dvd_left, Nat.dvd_refl]]
[Lean.Parser.Tactic.Conv.convRepeat_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.Conv.convSeq]]
[List.reverseAux_reverseAux,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, List.cons, List.reverseAux, List.nil, eq_self]]
[Std.RBTree.erase,[Std.RBMap.erase]]
[Lean.Widget.MsgEmbed.instRpcEncodingMsgEmbedRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Pure.pure, ExceptT, String, Lean.Widget.MsgEmbed, Lean.Server.RpcEncoding.rpcDecode, Lean.Widget.MsgEmbed.expr, Lean.Widget.MsgEmbed.goal, Lean.Widget.MsgEmbed.lazyTrace]]
[Lean.Parser.charLitFn,[ite, Eq, and, not, Lean.Parser.ParserState.hasError, Lean.Syntax.isOfKind, Array.back, Lean.Parser.ParserState.stxStack, Lean.charLitKind, Bool.true, Lean.Parser.ParserState.mkErrorAt, Option.some]]
[Lean.Elab.Command.elabMacroRules,[Lean.Elab.Command.adaptExpander, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Option.some, Lean.Elab.throwUnsupportedSyntax]]
[Lean.IR.Borrow.BorrowInfState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Borrow.BorrowInfState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[mul_right_cancel,[IsMulRightCancel.mul_right_cancel]]
[Tactic.Ring.subst_into_pow,[Eq.mpr, Eq.refl, Eq, HPow.hPow, rfl]]
[Lean.PrettyPrinter.format,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Std.ToFormat.format, Pure.pure, PUnit.unit]]
[List.union_equiv_append,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, List.mem_union_iff, List.mem_append, iff_self, Or, Mem.mem]]
[Lean.DeclarationRanges.mk.inj,[And.intro]]
[Lean.Elab.Tactic.showTerm,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Lean.Parser.Command.docComment,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.ppDedent, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.commentBody, Lean.Parser.ppLine]]
[Mathlib.Tactic.Ext.«termExtIffType%__»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[and_self_right,[Iff.intro, And.intro, And.left, And.right]]
[Subarray.all,[Id.run, Subarray.allM]]
[Lean.Server.Watchdog.FileWorker.stdin,[IO.FS.Stream.ofHandle, IO.Process.Child.stdin, Lean.Server.Watchdog.FileWorker.proc]]
[Lean.PrettyPrinter.Formatter.parseToken,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, MonadReader.read, Pure.pure, Lean.Parser.andthenFn, Lean.Parser.whitespace, Lean.Parser.tokenFn, List.nil, Lean.Parser.ParserContext.mk, Lean.Parser.InputContext.mk, Lean.FileMap.ofString, Lean.Parser.ParserModuleContext.mk, OfNat.ofNat, Lean.PrettyPrinter.Formatter.Context.table, Lean.Parser.mkParserState]]
[Lean.Compiler.SpecInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[System.FilePath.isRelative,[not, System.FilePath.isAbsolute]]
[Lean.mkAtom,[Lean.Syntax.atom, Lean.SourceInfo.none]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.isConditional,[]]
[Quotient.ind,[Quot.ind]]
[Lean.Lsp.instToJsonDocumentHighlightParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.DocumentHighlightParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position]]
[«stx_<|>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.instToMessageDataMessageData,[Lean.ToMessageData.mk, id]]
[Command.simpsRule.erase,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[unsafeEIO,[unsafeBaseIO, EIO.toBaseIO]]
[Lean.Parser.Tactic.extractGoal!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Lean.Expr.FindImpl.findM?,[Lean.Expr.FindImpl.findM?.visit]]
[Lean.Parser.Syntax.nonReserved,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.strLit]]
[Std.PShareCommonM,[Std.PShareCommonT, Id]]
[IO.FS.instInhabitedStream,[Inhabited.mk, IO.FS.Stream.mk, arbitrary]]
[Prod.anyI,[Nat.anyAux, Prod.snd, HSub.hSub, Prod.fst]]
[Lean.Widget.TaggedText.noConfusionType,[]]
[String.all,[not, String.any]]
[Lean.instAddErrorMessageContext,[Lean.AddErrorMessageContext.mk, Bind.bind, Lean.AddMessageContext.addMessageContext, Pure.pure, Prod.mk]]
[Lean.ParametricAttributeImpl.afterImport,[]]
[Lean.Meta.ToHide.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.ToHide.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.optExprPrecedence.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec]]
[Lean.Meta.Match.State.mk.inj,[And.intro]]
[Lean.instInhabitedOptionDecl,[Inhabited.mk, Lean.OptionDecl.mk, arbitrary]]
[Lean.Meta.ApplyNewGoals.noConfusionType,[noConfusionTypeEnum, Lean.Meta.ApplyNewGoals.toCtorIdx]]
[Int.negSucc_ofNat_inj_iff,[Iff.intro, Int.negSucc.inj, of_eq_true, Eq.trans, congrFun, congrArg, Eq, Int.negSucc, eq_self]]
[Task.Priority.max,[OfNat.ofNat]]
[Lean.Parser.Tactic.rintro?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[decidable_of_bool.proof_1,[Iff.mp, rfl]]
[Lean.Meta.AbstractMVars.State.noConfusionType,[]]
[or_left_comm,[Eq.mpr, Eq.refl, Iff, Or, Eq.symm, propext, or_assoc, or_comm, Iff.rfl]]
[Lean.Parser.tacticParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous]]
[lt_or_le,[dite, LE.le, Or.inr, Or.inl, lt_of_not_ge]]
[Lean.Parser.addParser,[Except, String, Lean.Parser.ParserCategories, Lean.Parser.addLeadingParser, Lean.Parser.addTrailingParser]]
[Lean.Parser.Error.toString,[String.intercalate, HAppend.hAppend]]
[Lean.Elab.Command.StructCtorView.declName,[]]
[HXor.noConfusionType,[]]
[Lean.Elab.Term.Context.autoBoundImplicit,[]]
[Lean.Parser.Term.funImplicitBinder,[HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.lookahead, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.Term.binderIdent, HOrElse.hOrElse, Lean.Parser.Term.implicitBinder, Bool.false]]
[instStreamList,[Stream.mk, Unit.unit, Option, Prod, List, Option.none, Option.some, Prod.mk]]
[Nat.succ_sub_sub_succ,[Eq.mpr, Eq.refl, Eq, HSub.hSub, Nat.succ, Nat.sub_sub, HAdd.hAdd, Nat.add_succ, Nat.succ_sub_succ, rfl]]
[Lean.Elab.Deriving.mkLocalInstanceLetDecls,[Bind.bind, ForIn.forIn, Lean.Elab.Deriving.mkInductArgNames, Lean.Elab.Deriving.mkImplicitBinders, Array.ofSubarray, Lean.Elab.Deriving.mkInductiveApp, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkIdent, List.nil, Lean.Syntax.atom, liftM, Lean.Core.mkFreshUserName, Array.append, PUnit.unit, ForInStep.yield]]
[UInt16.shiftRight,[UInt16.mk, HShiftRight.hShiftRight, UInt16.val, UInt16.modn, OfNat.ofNat]]
[not_le,[Iff.symm, lt_iff_not_ge]]
[Lean.Parser.Tactic.squeezeScope,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser]]
[Lean.Parser.PrattParsingTables.noConfusionType,[]]
[Mathlib.ExtendedBinder.extBinder,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat]]
[Lean.IR.declToString,[Std.Format.pretty, Std.ToFormat.format, Std.Format.defWidth]]
[Nat.left_distrib,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Nat.zero, HAdd.hAdd, Nat.zero_mul, OfNat.ofNat, rfl, congr, congrArg, Eq.trans, Nat.succ_mul, congrFun, Nat.add_assoc, Nat.add_left_comm]]
[Lean.PrettyPrinter.Parenthesizer.many1Unbox.parenthesizer,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.nullKind, Bool.true, Lean.PrettyPrinter.Parenthesizer.manyNoAntiquot.parenthesizer]]
[Lean.Parser.Tactic.Conv.convSeq,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.Parser.Tactic.Conv.convSeq1Indented, Lean.Parser.Tactic.Conv.convSeqBracketed]]
[not_not_em,[Or.inr, Or.inl]]
[UInt32.instSemiringUInt32.proof_11,[Eq.mpr, congr, congrArg, Eq, Eq.trans, HMul.hMul, UInt32.add_def, UInt32.mul_def, UInt32.mk, HAdd.hAdd, UInt32.val, UInt32.eq_of_val_eq, Semiring.mul_add]]
[Lean.Widget.InteractiveHypothesis.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Widget.InteractiveHypothesis.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Mathlib.Tactic.Lint.sortResults,[Bind.bind, ForIn.forIn, Lean.Core.CoreM, ForInStep, Std.HashMap, Lean.Name, Nat, Lean.findDeclarationRanges?, Option.none, Pure.pure, PUnit.unit, ForInStep.yield, Array.qsort, Std.HashMap.toArray, Bool, Decidable.decide, LT.lt, Std.HashMap.findD, OfNat.ofNat, HSub.hSub, Array.size]]
[Lean.Elab.Command.StructFieldView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.StructFieldView.mk, Eq.symm, eq_of_heq, HEq.refl]]
[AddGroup.noConfusionType,[]]
[Lean.instMonadBacktrackExceptT,[Lean.MonadBacktrack.mk, ExceptT.lift, Lean.MonadBacktrack.saveState, Lean.MonadBacktrack.restoreState]]
[Lean.PrettyPrinter.Formatter.withForbidden.formatter,[]]
[Lean.KVMap.setBool,[Lean.KVMap.insert, Lean.DataValue.ofBool]]
[Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1]]
[Std.PersistentArray.mk.inj,[And.intro]]
[Lean.Server.DocumentMeta.text,[]]
[Lean.Expr.headBeta,[ite, Eq, Lean.Expr.isHeadBetaTargetFn, Bool.true, Lean.Expr.betaRev, Lean.Expr.getAppRevArgs]]
[Lean.Elab.liftMacroM,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, Lean.MonadRef.getRef, Lean.Elab.MonadMacroAdapter.getCurrMacroScope, Lean.MonadRecDepth.getRecDepth, Lean.MonadRecDepth.getMaxRecDepth, Lean.Elab.MonadMacroAdapter.getNextMacroScope, Lean.Macro.Context.mk, Lean.Environment.mainModule, Lean.Macro.State.mk, Lean.Elab.throwUnsupportedSyntax, Lean.throwErrorAt, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Elab.MonadMacroAdapter.setNextMacroScope, Lean.Macro.State.macroScope, List.forM, List.reverse, Lean.Macro.State.traceMsgs, PUnit, Lean.trace, Pure.pure]]
[Lean.instToJsonString,[Lean.ToJson.mk, Lean.Json.str]]
[Lean.Widget.InteractiveHypothesis.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.fromTerm,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser]]
[Lean.ScopedEnvExtension.Descr.name,[]]
[Lean.Elab.Tactic.withRWRulesSeq,[Bind.bind, Lean.Elab.Tactic.withTacticInfoContext, Lean.mkNullNode, List.toArray, List.cons, List.nil, Pure.pure, Unit.unit, ForIn.forIn, PUnit.unit, Lean.withRef, ForInStep.yield]]
[Lean.Lsp.SemanticTokensLegend.mk.inj,[And.intro]]
[Lean.Environment.registerNamespace,[ite, Eq, Lean.NameSSet.contains, Lean.SimplePersistentEnvExtension.getState, Lean.namespacesExt, Bool.true, Lean.PersistentEnvExtension.addEntry]]
[EStateM.Backtrackable.save,[]]
[Lean.Expr.FoldConstsImpl.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.FoldConstsImpl.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.numLitNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.numLitFn]]
[Lean.IR.Borrow.updateParamMap,[Bind.bind, Lean.IR.Borrow.getCurrFn, MonadState.get, Unit.unit, Lean.IR.Borrow.M, Unit, Std.HashMap.find?, Lean.IR.Borrow.BorrowInfState.paramMap, Array.mapM, ite, Eq, not, Lean.IR.Param.borrow, Bool.true, Pure.pure, Lean.IR.Borrow.isOwned, Lean.IR.Param.x, Lean.IR.Borrow.markModified, Lean.IR.Param.mk, Bool.false, Lean.IR.Param.ty, modify, Lean.IR.Borrow.BorrowInfState.mk, Lean.IR.Borrow.BorrowInfState.owned, Lean.IR.Borrow.BorrowInfState.modified, Std.HashMap.insert]]
[Lean.Json.arr.injEq,[Eq.propIntro, Eq.refl, Lean.Json.arr, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.ToHide.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.FileWorker.RpcSession.keptAlive,[Bind.bind, liftM, IO.monoMsNow, Pure.pure, Lean.Server.FileWorker.RpcSession.mk, Lean.Server.FileWorker.RpcSession.aliveRefs, Lean.Server.FileWorker.RpcSession.nextRef, HAdd.hAdd, Lean.Server.FileWorker.RpcSession.keepAliveTimeMs]]
[instModUInt32,[Mod.mk, UInt32.mod]]
[Lean.IR.ExplicitBoxing.BoxingContext.decls,[]]
[Lean.Meta.instToFormatUnificationHints,[Std.ToFormat.mk, Std.ToFormat.format, Lean.Meta.UnificationHints.discrTree]]
[iff_true,[propext, Iff.intro, Iff.mpr, trivial]]
[Lean.Widget.InteractiveGoals.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Widget.InteractiveGoals.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.getMVarTag,[Bind.bind, Lean.Meta.getMVarDecl, Pure.pure, Lean.MetavarDecl.userName]]
[Lean.Parser.Term.doFinally.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.doSeq.parenthesizer]]
[Lean.Meta.getMajorPos?,[Lean.ParametricAttribute.getParam, Lean.Meta.recursorAttribute]]
[Lean.Parsec.notFollowedBy,[Lean.Parsec.ParseResult, Unit, Lean.Parsec.ParseResult.error, Lean.Parsec.ParseResult.success, Unit.unit]]
[Lean.IR.instToFormatFnBody,[Std.ToFormat.mk, Lean.IR.formatFnBody, OfNat.ofNat]]
[Lean.Meta.instInhabitedInfoCacheKey,[Inhabited.mk, Lean.Meta.InfoCacheKey.mk, arbitrary]]
[Lean.Expr.FoldConstsImpl.visited.proof_1,[lcProof]]
[Lean.IR.Decl.resultType,[Lean.IR.IRType]]
[IO.Error.resourceVanished.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.resourceVanished, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.instInhabitedPrattParsingTables,[Inhabited.mk, Lean.Parser.PrattParsingTables.mk]]
[Lean.JsonRpc.instToJsonMessage,[Lean.ToJson.mk, Lean.Json.mkObj, List.cons, Prod.mk, Lean.Json.str, List, Prod, String, Lean.Json, HAppend.hAppend, Lean.ToJson.toJson, List.nil, Lean.Json.opt]]
[Lean.Elab.InfoTree.below,[PProd, PUnit]]
[EStateM.pure,[EStateM.Result.ok]]
[Lean.IR.UnreachableBranches.InterpContext.noConfusionType,[]]
[Function.comp,[]]
[IO.FileRight.user,[]]
[ShiftRight.shiftRight,[]]
[Lean.Elab.Command.instMonadResolveNameCommandElabM,[Lean.MonadResolveName.mk, Bind.bind, Lean.Elab.Command.getScope, Pure.pure, Lean.Elab.Command.Scope.currNamespace, Lean.Elab.Command.Scope.openDecls]]
[Lean.IR.CtorInfo.ssize,[]]
[Lean.Elab.Term.elabMutualDef.processDeriving,[Bind.bind, ForIn.forIn, Unit.unit, Lean.Elab.Term.TermElabM, ForInStep, Subarray, Lean.Elab.DefView, Stream.next?, Pure.pure, ForInStep.done, Option.none, Lean.Elab.DefView.deriving?, PUnit.unit, Lean.resolveGlobalConstNoOverload, Lean.withRef, Lean.Elab.Term.processDefDeriving, Lean.Elab.DefViewElabHeader.declName, ite, Eq, Bool.true, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, ForInStep.yield]]
[List.foldr,[Unit.unit, PProd.fst]]
[Tactic.TryThis.addExactSuggestion,[Bind.bind, liftM, Tactic.TryThis.delabToRefinableSyntax, ite, Eq, Lean.Expr.hasExprMVar, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[instInhabitedUInt32.proof_1,[of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Parser.Trie.ibelow,[And, True]]
[Lean.Parser.Tactic.clear!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[WellFoundedRelation.noConfusionType,[]]
[Lean.Meta.Simp.Config.noConfusionType,[]]
[Std.RBNode.below,[PUnit, PProd]]
[Lean.Meta.Match.MatchEqns.splitterAltNumParams,[]]
[GroupWithZero.zero_mul,[]]
[Lean.ConstructorVal.induct,[]]
[Lean.Parser.nodeInfo,[Lean.Parser.ParserInfo.mk, Lean.Parser.ParserInfo.collectTokens, Lean.Parser.SyntaxNodeKindSet.insert, Lean.Parser.ParserInfo.collectKinds, Lean.Parser.ParserInfo.firstTokens]]
[Lean.Syntax.mkApp,[dite, Eq, Array.size, Unit.unit, Eq.symm, Array.toArrayLit_eq, Eq.refl, Lean.Syntax, Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkNullNode, List.nil]]
[Lean.PrettyPrinter.Delaborator.delabOfNat,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPCoercions, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.strVal, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Pure.pure, Lean.Quote.quote, Alternative.failure]]
[ne_iff_lt_or_gt,[Iff.intro, lt_or_gt_of_ne, Ne, ne_of_lt, ne_of_gt]]
[Lean.MapDeclarationExtension.insert,[Lean.PersistentEnvExtension.addEntry, Prod.mk]]
[Lean.LocalDecl.isLet,[Bool, Bool.false, Bool.true]]
[Array.instAppendArray,[Append.mk, Array.append]]
[Tactic.LibrarySearch.librarySearch',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const]]
[Lean.Meta.assumptionCore,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType, Lean.Meta.findLocalDeclWithType?, Unit.unit, Lean.Meta.MetaM, Bool, Pure.pure, Bool.false, Lean.Meta.assignExprMVar, Lean.mkFVar, Bool.true]]
[Lean.Meta.IndPredBelow.Variables.noConfusionType,[]]
[Decidable.not_and_distrib',[Iff.intro, dite, Or.inl, And.intro, Or.inr, not_and_of_not_or_not]]
[Lean.SMap.insert,[Lean.SMap, Lean.SMap.mk, Bool.true, Std.HashMap.insert, Bool.false, Std.PersistentHashMap.insert]]
[Lean.Lsp.DiagnosticTag.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.DiagnosticTag.toCtorIdx]]
[Lean.Meta.mapErrorImp,[MonadExcept.tryCatch, Lean.Exception.internal, Lean.Meta.MetaM, MonadExcept.throw, Lean.Exception.error]]
[Lean.Elab.Tactic.ElabSimpArgsResult.starArg,[]]
[UInt64.modn,[UInt64.mk, HMod.hMod, UInt64.val]]
[Lean.MetavarContext.UnivMVarParamResult.newParamNames,[]]
[UInt16.instSemiringUInt16.proof_11,[Eq.mpr, congr, congrArg, Eq, Eq.trans, HMul.hMul, UInt16.add_def, UInt16.mul_def, UInt16.mk, HAdd.hAdd, UInt16.val, UInt16.eq_of_val_eq, Semiring.mul_add]]
[Lean.instInhabitedEnvExtensionEntry,[Inhabited.mk, PointedType.val, Lean.EnvExtensionEntrySpec]]
[Lean.Elab.Term.Do.mkReturn,[Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.return]]
[UInt32.toUInt64,[Nat.toUInt64, UInt32.toNat]]
[Std.RBTree.subset,[Std.RBTree.all, Option.toBool, Std.RBTree.find?]]
[Lean.StructureDescr.structName,[]]
[Lean.ConstantInfo.recInfo.inj,[]]
[Lean.Parser.Term.matchAltsWhereDecls.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.matchAlts.formatter, Lean.Parser.termParser.formatter, Lean.Parser.optional.formatter, Lean.Parser.Term.whereDecls.formatter]]
[Lean.Parser.ParserState.keepTop,[Array.push, Array.shrink]]
[Lean.Meta.appendParentTag,[Bind.bind, Lean.Meta.getMVarTag, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Meta.setMVarTag, Lean.Expr.mvarId!, Array.getOp, Lean.Name.isAnonymous, Pure.pure, PUnit.unit, Nat.forM, Lean.Meta.isExprMVarAssigned, Lean.BinderInfo.isInstImplicit, Lean.Meta.appendTag]]
[List.tailD,[List]]
[Lean.JsonRpc.ResponseError.noConfusionType,[]]
[Lean.Meta.Simp.synthesizeArgs.synthesizeInstance,[Bind.bind, liftM, Lean.Meta.trySynthInstance, Option.none, Lean.LOption.none, Lean.LOption.undef, Lean.Meta.Simp.SimpM, Bool, Lean.Meta.withReducibleAndInstances, Lean.Meta.isDefEq, ite, Eq, Bool.true, Pure.pure, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, PUnit.unit]]
[Lean.Lsp.instToJsonWaitForDiagnosticsParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.WaitForDiagnosticsParams.uri, List.nil, Lean.Lsp.WaitForDiagnosticsParams.version]]
[Lean.Elab.Command.elabSyntax,[Bind.bind, Pure.pure, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Option.some, Lean.Elab.throwUnsupportedSyntax]]
[boolToSort,[CoeSort.mk, Eq, Bool.true]]
[Lean.PrettyPrinter.Delaborator.delabForall,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, MonadExcept.tryCatch, liftM, Lean.Meta.isProp, Pure.pure, Bool.false, List.toArray, List.nil]]
[iff_of_eq,[Iff.rfl]]
[Lean.Elab.Tactic.evalRenameInaccessibles,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Tactic.getMainGoal, Lean.Elab.Tactic.renameInaccessibles, Lean.Elab.Tactic.replaceMainGoal, List.cons, List.nil, Lean.Elab.throwUnsupportedSyntax]]
[Lean.hasMatchPatternAttribute,[Lean.TagAttribute.hasTag, Lean.matchPatternAttr]]
[Lean.PrettyPrinter.Delaborator.getOptionsAtCurrPos,[Bind.bind, MonadReader.read, Lean.PrettyPrinter.Delaborator.SubExpr.getPos, Pure.pure, Std.RBMap.find?, Lean.PrettyPrinter.Delaborator.Context.optionsPerPos, Option.none, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Options, ForIn.forIn, ForInStep, PUnit.unit, ForInStep.yield]]
[Lean.Parser.Term.binderIdent,[HOrElse.hOrElse, Lean.Parser.Term.ident, Lean.Parser.Term.hole]]
[Lean.Level.updateSucc,[Lean.mkLevelSucc]]
[Lean.IR.Alt.isDefault,[Bool, Bool.false, Bool.true]]
[Lean.Lsp.DiagnosticRelatedInformation.noConfusionType,[]]
[Lean.IR.EmitC.emitSProj,[Bind.bind, Lean.IR.EmitC.emitLhs, Unit.unit, Lean.IR.IRType.usize, Lean.IR.IRType.irrelevant, Lean.IR.IRType.object, Lean.IR.IRType.tobject, Lean.IR.IRType.struct, Lean.IR.IRType.union, Lean.IR.EmitC.M, Unit, Lean.IR.EmitC.emit, MonadExcept.throw]]
[Std.HashMap.forM,[PUnit, Std.HashMapImp.forM]]
[List.erase_append_left,[Eq.mpr, congr, congrArg, Eq, List.erase_eq_erasep, HAppend.hAppend, congrFun, List.erasep_append_left, rfl]]
[Std.instToFormatFormat,[Std.ToFormat.mk]]
[Lean.Elab.Term.LetRecDeclView.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Subsingleton.elim,[Subsingleton.elim.proof_1]]
[Not.intro,[]]
[Lean.Meta.mkSizeOfFns,[Bind.bind, Lean.getConstInfoInduct, Lean.getConstInfoRec, Lean.mkRecName, ForIn.forIn, MProd.mk, Lean.Meta.mkSizeOfFn, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Meta.MetaM, Prod, Array, Lean.Name, Lean.NameMap, Prod.mk]]
[Lean.Elab.Term.hasElabWithoutExpectedType,[Lean.TagAttribute.hasTag, Lean.Elab.Term.elabWithoutExpectedTypeAttr]]
[Substring.dropWhile,[Substring, Substring.mk]]
[Function.bijective.of_comp_iff',[and_congr, Function.injective.of_comp_iff, Function.bijective.injective, Function.surjective.of_comp_iff']]
[implies_of_if_neg,[]]
[Std.RBMap.lowerBound,[Option, Sigma, Std.RBNode.lowerBound, Option.none]]
[Lean.Parser.TokenMap.instEmptyCollectionTokenMap,[EmptyCollection.mk, Std.RBMap.empty]]
[Semiring.mul_add,[]]
[Lean.IR.CtorFieldInfo.instToFormatCtorFieldInfo,[Std.ToFormat.mk, Lean.IR.CtorFieldInfo.format]]
[Lean.Meta.IndPredBelow.mkBelow,[Bind.bind, Lean.Meta.isInductivePredicate, ite, Eq, Bool.true, Lean.getConstInfoInduct, Lean.InductiveVal.isRec, Lean.Meta.IndPredBelow.mkContext, Lean.Meta.IndPredBelow.mkBelowDecl, Lean.addDecl, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.IndPredBelow.Context.belowNames, Pure.pure, PUnit.unit]]
[String.substrEq,[and, Decidable.decide, LE.le, HAdd.hAdd, String.bsize, String.substrEq.loop]]
[DoResultPRBC.break.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.instFromJsonDidChangeTextDocumentParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.VersionedTextDocumentIdentifier, Array, Lean.Lsp.TextDocumentContentChangeEvent, Pure.pure, Lean.Lsp.DidChangeTextDocumentParams.mk]]
[Lean.AttributeExtensionOLeanEntry.builder.inj,[And.intro]]
[UInt32.one_def,[rfl]]
[Lean.Parser.Command.export.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter, Lean.Parser.many1.formatter]]
[Lean.Meta.Match.AltLHS.mk.inj,[And.intro]]
[Lean.Parser.Tactic.rotateRight,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[Lean.Parser.precedence.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.precedenceParser.formatter, Lean.Parser.maxPrec]]
[Lean.Meta.forEachExpr',[Lean.MonadCacheT.run, Lean.Meta.ForEachExpr.visit]]
[Lean.MessageData.below,[PUnit, PProd]]
[Lean.Parser.scientificLit.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.scientificLitKind, Bool.true, Lean.PrettyPrinter.Formatter.scientificLitNoAntiquot.formatter]]
[UInt16.instRingUInt16.proof_5,[UInt16.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, UInt16.val, congrFun, HAdd.hAdd, UInt16.neg_def, UInt16.add_def, UInt16.mk, Neg.neg, add_left_neg, UInt16.zero_def, eq_true_of_decide, Eq.refl, Bool.true]]
[Lean.Elab.Structural.getEqnsFor?,[Bind.bind, Lean.MonadEnv.getEnv, Option.none, Lean.Meta.MetaM, Option, Array, Lean.Name, Std.PersistentHashMap.find?, Lean.Elab.Structural.EqnsExtState.map, Lean.EnvExtension.getState, Lean.Elab.Structural.eqnsExt, Pure.pure, Option.some, Lean.MapDeclarationExtension.find?, Lean.Elab.Structural.eqnInfoExt, Lean.Elab.Structural.mkEqns, Lean.MonadEnv.modifyEnv, Lean.EnvExtension.modifyState, Lean.Elab.Structural.EqnsExtState.mk, Std.PersistentHashMap.insert]]
[Lean.mkBInductionOnName,[Lean.Name.mkStr, Lean.binductionOnSuffix]]
[String.length_append,[Eq, String.length, HAppend.hAppend, HAdd.hAdd, Eq.mpr, Eq.refl, String.mk, String.congr_append, List.length_append]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Mathlib.Tactic.Lint.SimpLemmaInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.PatternVarDecl.localVar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.forInMacro.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec]]
[DivInvMonoid.noConfusionType,[]]
[Lean.Parser.peekTokenAux,[Option.none, Prod, Lean.Parser.ParserState, Except, Lean.Syntax, Lean.Parser.ParserState.errorMsg, Prod.mk, Lean.Parser.ParserState.restore, Except.error, Except.ok]]
[Std.mkPArray,[Std.mkPersistentArray]]
[Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat.lt_of_lt_of_le]]
[Lean.Elab.TermInfo.format,[Lean.Elab.TermInfo.runMetaM, Bind.bind, MonadExcept.tryCatch, Lean.Meta.ppExpr, Lean.Elab.TermInfo.expr, Lean.Meta.inferType, Pure.pure, HAppend.hAppend, Std.ToFormat.format, ite, Eq, Lean.Name.isAnonymous, Lean.Elab.ElabInfo.elaborator, Bool.true, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Std.Format, Lean.Elab.ElabInfo.stx, Lean.Elab.TermInfo.toElabInfo]]
[UInt8.instRingUInt8,[Ring.mk, UInt8.instRingUInt8.proof_1, UInt8.mk, Ring.gsmul, UInt8.val, UInt8.instRingUInt8.proof_2, UInt8.instRingUInt8.proof_3, UInt8.instRingUInt8.proof_4, UInt8.instRingUInt8.proof_5]]
[Lean.Level.updateIMax!,[Lean.Level.zero, Lean.Level.succ, Lean.Level.max, Lean.Level.param, Lean.Level.mvar, Lean.Level, Lean.Level.updateIMax, Lean.Level.imax, Lean.Level.updateIMax!.proof_1, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.isStructureLike,[Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, dite, Eq, Lean.ConstantInfo.inductInfo, Lean.InductiveVal.mk, Lean.ConstantVal.mk, List.nil, List.cons, Bool.true, Eq.symm, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Bool, Lean.Environment.find?, Bool.false]]
[Lean.Parser.trailingNodeFn,[Lean.Parser.ParserState.mkTrailingNode]]
[UInt64.instSemiringUInt64.proof_1,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt64.zero_def, UInt64.add_def, UInt64.mk, OfNat.ofNat, add_zero, UInt64.val, UInt64.mk_val_eq, eq_self, propext, forall_const, UInt64]]
[UInt16.instInhabitedFinSize,[Inhabited.mk, Fin.ofNat', OfNat.ofNat, UInt16.size_positive]]
[Lean.Lsp.ClientInfo.mk.inj,[And.intro]]
[Nat.mul_mod,[]]
[Lean.MonadBacktrack.saveState,[]]
[Lean.Parser.Priority.numPrio.formatter,[Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.checkPrec.formatter, Lean.Parser.numLit.formatter]]
[Lean.Server.Snapshots.compileNextCmd,[IO, Lean.Server.Snapshots.Snapshot, ite, Eq, or, Lean.Parser.isEOI, Lean.Parser.isExitCommand, Bool.true, Bind.bind, Pure.pure, liftM, IO.mkRef, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, IO.FS.withIsolatedStreams, Lean.Elab.Command.catchExceptions, SeqRight.seqRight, Lean.Elab.getResetInfoTrees, Lean.Elab.Command.elabCommandTopLevel, ST.Ref.get, not, String.isEmpty, PUnit.unit, Lean.Server.Snapshots.compileNextCmd.withNewInteractiveDiags]]
[PSigma.SkipLeft,[PSigma.RevLex, emptyRelation]]
[Lean.StructureDescr.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Compiler.SpecState.noConfusionType,[]]
[Lean.Meta.SynthInstance.GeneratorNode.mctx,[]]
[Decidable.em,[Decidable.byCases, Or.inl, Or.inr]]
[Array.insertionSort.swapLoop.proof_1,[Nat.lt_trans, Nat.lt_succ_self, Eq.symm]]
[Lean.PrettyPrinter.Parenthesizer.nonReservedSymbolNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken]]
[Lean.Elab.Term.SavedState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[and_congr_left',[and_congr, Iff.rfl]]
[if_true,[if_pos, trivial]]
[Lean.Parser.Tactic.traceState,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.IR.Borrow.OwnedSet.beq,[Bool, and, BEq.beq]]
[Lean.Option.Decl.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Subarray.toArray,[Array.ofSubarray]]
[Lean.mkBVar,[Lean.Expr.bvar, Lean.Expr.mkData, mixHash, OfNat.ofNat, Hashable.hash, HAdd.hAdd, Bool.false]]
[Lean.Widget.TaggedText.below,[PUnit, PProd]]
[Std.Range.stop,[]]
[Lean.IR.instToFormatJoinPointId,[Std.ToFormat.mk, Std.Format.text, ToString.toString]]
[Lean.Parser.Command.structSimpleBinder.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Command.declModifiers.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.inferMod.formatter, Lean.Parser.Command.optDeclSig.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.binderTactic.formatter, Lean.Parser.Term.binderDefault.formatter]]
[le_antisymm_iff,[Iff.intro, And.intro, le_of_eq, Eq.symm, Eq, le_antisymm]]
[Lean.IR.ExpandResetReuse.setFields,[Nat.fold, Lean.IR.FnBody.set, Array.get!, Array.size]]
[Lean.Elab.Term.Do.Alt.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.getDecl',[Bind.bind, Lean.IR.findDecl', Option.none, Lean.IR.CompilerM, Lean.IR.Decl, Pure.pure, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Array.toListLitAux,[List, PProd.fst, Array.toListLitAux.proof_1, List.cons, Array.getLit, Array.toListLitAux.proof_2]]
[Lean.Lsp.Trace.verbose.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Lsp.LeanFileProgressProcessingInfo.mk.inj,[]]
[add_left_comm,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Eq.symm, add_assoc, add_comm, rfl]]
[Nat.lt_of_le_of_ne,[LT.lt, Nat.lt_or_ge, absurd, Nat.le_antisymm]]
[Std.PersistentHashMap.foldlM,[Std.PersistentHashMap.foldlMAux, Std.PersistentHashMap.root]]
[Lean.Xml.Content.Character.injEq,[Eq.propIntro, Eq.refl, Lean.Xml.Content.Character, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.le_of_not_lt,[Or.resolve_left, Nat.lt_or_ge]]
[IO.Error.mkInvalidArgumentFile,[Function.comp, IO.Error.invalidArgument, Option.some]]
[Monoid.one_mul,[]]
[Lean.Export.instCoeNameEntry,[Coe.mk, Lean.Export.Entry.name]]
[Lean.LOption.none.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[List.pwFilter,[Unit.unit, List, List.nil, ite, List.cons]]
[Nat.coprime.gcd_left,[Nat.coprime.coprime_dvd_left, Nat.gcd_dvd_right]]
[Lean.Elab.Term.SyntheticMVarDecl.noConfusionType,[]]
[Lean.Parser.Command.notation3Item,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.parser, Lean.Parser.Command.bindersItem, Lean.ParserDescr.unary, Lean.Parser.Command.identScope]]
[le_of_lt_or_eq,[LE.le, le_of_lt, le_refl]]
[one_mul,[Monoid.one_mul]]
[Std.PersistentHashMap.Entry.null.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[String.isNat,[String.all, Char.isDigit]]
[Lean.Elab.Command.StructFieldInfo.fvar,[]]
[Lean.Server.Watchdog.handleCrash,[Bind.bind, Lean.Server.Watchdog.findFileWorker!, Lean.Server.Watchdog.updateFileWorkers, Lean.Server.Watchdog.FileWorker.mk, Lean.Server.Watchdog.FileWorker.doc, Lean.Server.Watchdog.FileWorker.proc, Lean.Server.Watchdog.FileWorker.commTask, Lean.Server.Watchdog.WorkerState.crashed, Lean.Server.Watchdog.FileWorker.pendingRequestsRef, Lean.Server.Watchdog.FileWorker.groupedEditsRef]]
[Std.PersistentHashMap.Node.entries.inj,[]]
[PSigma.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.getMVarDecl,[Bind.bind, Lean.MonadMCtx.getMCtx, Unit.unit, Lean.Meta.MetaM, Lean.MetavarDecl, Lean.MetavarContext.findDecl?, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MVarId.name]]
[Lean.Syntax.isIdOrAtom?,[Lean.Syntax.missing, Lean.Syntax.node, Option, String, Option.some, Substring.toString, Option.none]]
[Lean.KVMap.contains,[Option.isSome, Lean.KVMap.find]]
[Lean.Parser.Term.binderDefault.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter]]
[Lean.Meta.existsIntro,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType', Lean.matchConstStruct, Lean.Expr.getAppFn, Lean.Meta.throwTacticEx, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.Syntax.missing, ite, LT.lt, Lean.ConstructorVal.numFields, OfNat.ofNat, Pure.pure, PUnit.unit]]
[Lean.instReprReducibilityStatus,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone]]
[Lean.Parser.numLit,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.numLitKind, Bool.true, Lean.Parser.numLitNoAntiquot]]
[Lean.IR.Checker.CheckerContext.decls,[]]
[PSigma.lex.proof_1,[WellFounded.intro, Acc, PSigma.Lex, PSigma.lexAccessible, WellFounded.apply]]
[Lean.isLHSGoal?,[Unit.unit, Option, Lean.Expr, Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous, Option.none, ite, Eq, Lean.Expr.isAppOfArity, OfNat.ofNat, Bool.true, Option.some, Lean.Expr.appArg!, Lean.Expr.appFn!]]
[List.card_remove_of_mem,[Eq, List.card, HAdd.hAdd, List.remove, OfNat.ofNat, False.elim, List.not_mem_nil, Decidable.em, Eq.mpr, congrArg, List.cons, congrFun, if_pos, List, Mem.mem, Eq.symm, Eq.refl]]
[Bool.true.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.IR.EmitC.emitArgs,[Nat.forM, Array.size, ite, GT.gt, OfNat.ofNat, Bind.bind, Lean.IR.EmitC.emit, Pure.pure, PUnit.unit]]
[Lean.Elab.WF.TerminationHintValue.noConfusionType,[]]
[Lean.addSearchPathFromEnv,[Bind.bind, liftM, IO.getEnv, Unit.unit, IO, Lean.SearchPath, Pure.pure, HAppend.hAppend, System.SearchPath.parse]]
[Lean.Parser.Term.structInst.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ppHardSpace.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.termParser.parenthesizer, Bool.false, Lean.Parser.manyIndent.parenthesizer, Lean.Parser.group.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.structInstFieldAbbrev.parenthesizer, Lean.Parser.Term.structInstField.parenthesizer, Lean.Parser.Term.optEllipsis.parenthesizer]]
[Lean.Parser.Tactic.«tacticHave__:=_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Command.macroTailDefault.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.darrow.parenthesizer, Lean.Parser.Command.macroRhs.parenthesizer, Lean.PrettyPrinter.Parenthesizer.categoryParserOfStack.parenthesizer, OfNat.ofNat]]
[Lean.Meta.AssertAfterResult.mk.inj,[And.intro]]
[Lean.Parser.Tactic.squeezeDSimp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.Lsp.Range.start,[]]
[Mathlib.Tactic.Ext.tacticSubstEqs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.isStructure,[Option.isSome, Lean.getStructureInfo?]]
[Lean.ClosedTermCache.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ClosedTermCache.mk, Eq.symm, eq_of_heq, HEq.refl]]
[List.asString,[String.mk]]
[Lean.PrettyPrinter.Formatter.rawCh.formatter,[Lean.PrettyPrinter.Formatter.symbolNoAntiquot.formatter, Char.toString]]
[Lean.Parser.Term.termPpquoteₓ_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.checkWsBeforeFn,[ite, Eq, Lean.Parser.checkTailWs, Bool.true, Lean.Parser.ParserState.mkError]]
[Lean.Parser.termRegister_parser_alias___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[eq_false_of_ne_true,[Eq, Bool.false, False.elim, rfl]]
[Lean.Elab.DerivingClassView.args?,[]]
[Lean.Elab.Term.FunBinders.State.lctx,[]]
[Subset.subset,[]]
[Lean.KVMap.setName,[Lean.KVMap.insert, Lean.DataValue.ofName]]
[Lean.Meta.IndPredBelow.mkCtorType,[Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, Lean.Meta.IndPredBelow.Variables.mk, Array.ofSubarray, Array.toSubarray, OfNat.ofNat, Lean.Meta.IndPredBelow.Context.numParams, List.toArray, List.nil, Array.size, Lean.Meta.IndPredBelow.mkCtorType.addHeaderVars, Lean.Meta.IndPredBelow.mkCtorType.addMotives, Lean.Meta.IndPredBelow.mkCtorType.modifyBinders, Lean.Meta.IndPredBelow.mkCtorType.rebuild, Lean.Meta.IndPredBelow.mkCtorType.replaceTempVars, Lean.Meta.IndPredBelow.mkCtorType.checkCount, Lean.Meta.IndPredBelow.mkCtorType.mkBelowBinder, Lean.Meta.IndPredBelow.mkCtorType.mkMotiveBinder, Lean.Meta.IndPredBelow.mkCtorType.copyVarName]]
[IO.FS.FileType.dir.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[dbgTraceVal,[dbgTrace, ToString.toString]]
[String.Iterator.mk.inj,[And.intro]]
[Lean.Elab.Term.ElabAppArgs.State.expectedType?,[]]
[Std.Format.FlattenBehavior.toCtorIdx,[OfNat.ofNat]]
[Lean.Compiler.isToNat,[List.any, Lean.Compiler.numScalarTypes, BEq.beq, Lean.Compiler.NumScalarTypeInfo.toNatFn]]
[instReprDecidable,[Repr.mk, Std.Format, Repr.addAppParen, Std.Format.text]]
[Std.PersistentArrayNode.node.injEq,[Eq.propIntro, Eq.refl, Std.PersistentArrayNode.node, Eq.symm, eq_of_heq, HEq.refl]]
[Preorder.le_refl,[]]
[Lean.Meta.Simp.SimpLetCase.toCtorIdx,[OfNat.ofNat]]
[List.subset_append_left,[List.mem_append_left]]
[instDecidableEqFin,[Decidable, Eq, decEq, Fin.val, Decidable.isTrue, Fin.eq_of_val_eq, Decidable.isFalse, Fin.ne_of_val_ne]]
[Lean.IR.Checker.CheckerContext.mk.inj,[And.intro]]
[Lean.Parser.fieldIdx,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.fieldIdxFn]]
[add_right_comm,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, add_assoc, add_comm, rfl]]
[Lean.Meta.introNP,[Lean.Meta.introNCore, List.nil, Bool.false, Bool.true]]
[Lean.Parser.Tactic.tacticSeqBracketed,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many, Lean.Parser.group, Lean.Parser.ppLine, Lean.Parser.tacticParser, Lean.Parser.optional, Lean.Parser.ppDedent]]
[List.head!,[Unit.unit, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Meta.DefEqCache,[Std.PersistentHashMap, Prod, Lean.Expr, Unit]]
[Lean.IR.Decl.updateBody!,[Lean.IR.Decl.extern, Lean.IR.Decl, Lean.IR.Decl.fdecl, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.ImportM.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ImportM.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.typeAscription.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter]]
[Lean.Elab.Term.Do.CodeBlocl.toMessageData,[Lean.Elab.Term.Do.CodeBlock.code, Lean.Elab.Term.Do.CodeBlocl.toMessageData.loop]]
[Lean.PrettyPrinter.Delaborator.delabSort,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Lean.Level.succ, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Unit.unit, Lean.Level.dec, Lean.Level.quote, OfNat.ofNat, panicWithPosWithDecl]]
[Lean.Elab.Term.Do.mkBreak,[Lean.Elab.Term.Do.CodeBlock.mk, Lean.Elab.Term.Do.Code.break]]
[Lean.Elab.Tactic.MkSimpContextResult.ctx,[]]
[UInt16.noConfusionType,[]]
[ULift.up_down,[Eq, ULift.up, ULift.down, rfl]]
[Lean.Parser.antiquotExpr,[HOrElse.hOrElse, Lean.Parser.identNoAntiquot, Lean.Parser.antiquotNestedExpr]]
[Lean.Meta.Closure.Context.mk.inj,[]]
[Lean.Xml.Parser.Mixed,[HOrElse.hOrElse, Bind.bind, Lean.Parsec.skipChar, Char.ofNat, SeqRight.seqRight, optional, Lean.Xml.Parser.S, Lean.Parsec.skipString, Lean.Parsec.many, Lean.Xml.Parser.Name, SeqLeft.seqLeft]]
[Subtype.val,[]]
[USize.decLe,[Decidable, LE.le, inferInstanceAs]]
[Lean.Elab.Term.getPatternVars,[Bind.bind, Lean.Elab.liftMacroM, Lean.expandMacros, StateRefT'.run, Lean.Elab.Term.CollectPatternVars.collect, Lean.Elab.Term.CollectPatternVars.State.mk, Lean.Elab.Term.TermElabM, Array, Lean.Elab.Term.PatternVar, Pure.pure, Lean.Elab.Term.CollectPatternVars.State.vars]]
[Lean.MetavarContext.hasAssignableMVar,[Bool, List.any, Lean.MetavarContext.hasAssignableLevelMVar, or, and, Lean.Expr.hasMVar, PProd.fst, PProd.snd, Bool.false, Lean.MetavarContext.isExprAssignable]]
[Tactic.Ring.HornerExpr.xadd.injEq,[Eq.propIntro, And.intro, Eq.refl, Tactic.Ring.HornerExpr.xadd, Eq.symm, eq_of_heq, HEq.refl]]
[Std.Format.defUnicode,[Bool.true]]
[Lean.Lsp.DidOpenTextDocumentParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[lt_of_lt_of_le,[LT.lt, lt_of_le_not_le, le_trans]]
[instSubFloat,[Sub.mk, Float.sub]]
[StateRefT'.modifyGet,[ST.Ref.modifyGet]]
[Lean.Elab.addAndCompilePartialRec,[ite, Eq, Array.all, and, not, Lean.Elab.DefKind.isTheorem, Lean.Elab.PreDefinition.kind, Lean.Elab.Modifiers.isNoncomputable, Lean.Elab.PreDefinition.modifiers, OfNat.ofNat, Array.size, Bool.true, Lean.Elab.addAndCompileUnsafe, Array.map, Lean.Elab.PreDefinition.mk, Lean.Elab.PreDefinition.ref, Lean.Elab.PreDefinition.levelParams, Lean.Elab.Modifiers.mk, Lean.Compiler.mkUnsafeRecName, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.type, Lean.Expr.replace, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Expr, Array.any, BEq.beq, Option.some, Lean.mkConst, Option.none, Lean.Elab.PreDefinition.value, Lean.DefinitionSafety.partial, Pure.pure, PUnit.unit]]
[UInt16.size_positive,[of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Meta.SimpAll.Entry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.intro,[Bind.bind, Lean.Meta.introN, OfNat.ofNat, List.cons, List.nil, Bool.false, Lean.Meta.MetaM, Prod, Lean.FVarId, Lean.MVarId, Pure.pure, Prod.mk, Array.get!]]
[Function.left_inverse.right_inverse,[]]
[Lean.Meta.mkCongrFun,[ite, Eq, Lean.Expr.isAppOf, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Meta.mkEqRefl, Lean.mkApp, Lean.Expr.appArg!, Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Option.none, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.eq?, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.getLevel, Pure.pure, Lean.mkApp6, Lean.mkConst, List.cons, List.nil, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr]]
[instOrOpUInt8,[OrOp.mk, UInt8.lor]]
[Lean.Parser.Term.waitIfTypeMVar.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.termParser.formatter]]
[Lean.Meta.FVarSubst.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.Conv.dsimp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser]]
[Lean.PrettyPrinter.Parenthesizer.registerAlias,[Lean.Parser.registerAliasCore, Lean.PrettyPrinter.Parenthesizer.parenthesizerAliasesRef]]
[Lean.isIOUnitInitFn,[or, Lean.isIOUnitBuiltinInitFn, Lean.isIOUnitRegularInitFn]]
[Lean.ImportM.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Function.right_inverse.surjective,[Exists.intro]]
[Lean.Parser.ParserState.stackSize,[Array.size, Lean.Parser.ParserState.stxStack]]
[Lean.Meta.tryUnificationHints.isDefEqPattern,[Lean.Meta.withReducible, Lean.Meta.isExprDefEqAux]]
[Lean.ScopedEnvExtension.Descr.addEntry,[]]
[Nat.Up,[And, LT.lt]]
[Lean.Expr.replaceFVar,[Lean.Expr.instantiate1, Lean.Expr.abstract, List.toArray, List.cons, List.nil]]
[Lean.Elab.DefKind.noConfusion,[noConfusionEnum, Lean.Elab.DefKind.toCtorIdx]]
[Char.eq_of_val_eq,[Eq.symm, eq_of_heq, Eq.refl, Char.val, Char.mk, HEq.refl, Eq, rfl]]
[Nat.add_sub_assoc,[Eq, HSub.hSub, HAdd.hAdd, Eq.mpr, Eq.refl, Eq.symm, Nat.add_sub_cancel_left, Nat.add_comm, Nat.add_assoc, Nat.add_sub_cancel, rfl]]
[Lean.IR.EmitC.emitSimpleExternalCall,[Bind.bind, Lean.IR.EmitC.emit, Functor.discard, Nat.foldM, ite, Eq, Lean.IR.IRType.isIrrelevant, Lean.IR.Param.ty, Array.getOp, Bool.true, Pure.pure, PUnit.unit, Array.size, Lean.IR.EmitC.emitLn, Unit.unit]]
[Lean.Elab.Term.Context.sectionVars,[]]
[Lean.Parser.mkIdResult,[ite, Eq, Unit.unit, Bool, Bool.false, Decidable.decide, GE.ge, String.bsize, HSub.hSub, Bool.true, Lean.Parser.mkTokenAndFixPos, Lean.Parser.ParserState.pushSyntax]]
[true_or,[propext, Iff.intro, trivial, Or.inl]]
[ByteArray.data,[]]
[List.mapIdx.loop,[List, List.nil, List.cons, PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[and_congr,[Iff.intro, And.imp, Iff.mp, Iff.mpr]]
[Lean.PrettyPrinter.Delaborator.delabSigmaCore,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPNotation, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, guard, Eq, BEq.beq, Lean.Expr.getAppNumArgs, OfNat.ofNat, Bool.true, Lean.Expr.isLambda, Lean.Expr.appArg!, Lean.PrettyPrinter.Delaborator.SubExpr.withAppArg, Lean.PrettyPrinter.Delaborator.SubExpr.withBindingDomain, Lean.PrettyPrinter.Delaborator.delab, Lean.PrettyPrinter.Delaborator.withBindingBodyUnusedName, ite, Lean.Expr.hasLooseBVars, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Lean.instToStringNamePart,[ToString.mk, String, ToString.toString]]
[Lean.Lsp.SymbolKind.number.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[ReaderT.run_seqLeft,[Eq.mpr, Eq.refl, Eq, ReaderT.run, SeqLeft.seqLeft, seqLeft_eq_bind, rfl]]
[String.Pos,[Nat]]
[ByteArray.foldlM,[dite, LE.le, ByteArray.size, ByteArray.foldlM.proof_1]]
[Lean.Parser.Tactic.substs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[Lean.Meta.inferTypeImp.infer,[List.cons, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.proj, Lean.Meta.MetaM, Lean.Expr, Bind.bind, Lean.getConstInfo, ite, Eq, BEq.beq, List.length, Lean.ConstantInfo.levelParams, Bool.true, Pure.pure, Lean.ConstantInfo.instantiateTypeLevelParams, Lean.Meta.throwIncorrectNumberOfLevels, List.nil, MonadState.get, Unit.unit, Std.PersistentHashMap.find?, Lean.Meta.Cache.inferType, Lean.Meta.State.cache, Lean.ExprStructEq.mk, or, Lean.Expr.hasMVar, PUnit.unit, Lean.Meta.modifyInferTypeCache, Std.PersistentHashMap.insert, Lean.Meta.inferType, Lean.Meta.whnf, Lean.matchConstStruct, Lean.Expr.getAppFn, bne, Array.size, ForIn.forIn, MProd.mk, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lit, Lean.Expr.mdata, ForInStep, MProd, Nat, ForInStep.yield, Lean.Expr.instantiateBetaRevRange, Lean.Meta.throwFunctionExpected, Lean.mkAppRange, OfNat.ofNat, HAdd.hAdd, Lean.mkConst, Lean.ConstantVal.name, Lean.ConstructorVal.toConstantVal, Lean.Expr.hasLooseBVars, PUnit, Lean.Expr.getAppArgs, Lean.MonadMCtx.getMCtx, Lean.MetavarContext.findDecl?, Lean.MetavarDecl.type, Lean.Meta.throwUnknownMVar, Lean.MonadLCtx.getLCtx, Lean.LocalContext.find?, Lean.LocalDecl.type, Lean.Meta.throwUnknownFVar, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkBVar, PProd.fst, Lean.Literal.type, Lean.mkSort, Lean.mkLevelSucc, Lean.Meta.forallTelescope, Lean.Meta.getLevel, Array.foldrM, Lean.mkLevelIMax', Lean.Level.normalize, Lean.Meta.lambdaLetTelescope, Lean.Meta.mkForallFVars, Bool.false]]
[Equiv.symm_comp_self,[funext, Equiv.symm_apply_apply]]
[Lean.Syntax.identComponents.nameComps,[Option.none, List, Lean.Name, List.cons, List.drop, Lean.Name.components]]
[Lean.IR.UnreachableBranches.InterpState.assignments,[]]
[Lean.PrettyPrinter.Parenthesizer.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Std.RBTree.forM,[Std.RBTree.foldM, PUnit.unit]]
[Lean.Xml.Parser.AttDef,[SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Xml.Parser.Name, Lean.Xml.Parser.AttType, Lean.Xml.Parser.DefaultDecl]]
[Lean.Server.Watchdog.GroupedEdits.queuedMsgs,[]]
[Fin.instXorFin,[Xor.mk, Fin.xor]]
[String.Iterator.s,[]]
[Lean.Parser.Command.ctor.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.declModifiers.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.inferMod.formatter, Lean.Parser.Command.optDeclSig.formatter]]
[Lean.Elab.Attribute.kind,[]]
[Lean.Occurrences.pos.inj,[]]
[Lean.ClassEntry.noConfusionType,[]]
[IO.FS.instReprFileType,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone]]
[Lean.instToJsonFilePath,[Lean.ToJson.mk, Lean.Json.str, System.FilePath.toString]]
[Lean.IR.ExpandResetReuse.Context.mk.inj,[]]
[Int.decEq.proof_5,[]]
[Lean.IR.ExplicitBoxing.M,[ReaderT, Lean.IR.ExplicitBoxing.BoxingContext, StateT, Lean.IR.ExplicitBoxing.BoxingState, Id]]
[Lean.Server.RequestContext.hLog,[]]
[List.mem_map,[Unit.unit, Iff, Mem.mem, List.map, Exists, And, Eq, of_eq_true, Eq.trans, congr, congrArg, List.map_nil, propext, List.mem_nil_iff, funext, congrFun, false_and, eq_false, exists_false, eq_true_of_decide, Eq.refl, Bool.true, Eq.mpr, List.cons, List.map_cons, List.mem_cons, Or, PProd.fst, Iff.intro, Exists.intro, And.intro, Or.inl, rfl, Or.inr, Eq.symm, eq_of_heq, HEq.refl]]
[Int.fdiv,[Int.ofNat, Int.negSucc, Nat.succ, Int, OfNat.ofNat, HDiv.hDiv]]
[Lean.Parser.Attr.mkIff,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[Lean.MetavarContext.LevelMVarToParam.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.FileWorker.CancelToken.ref,[]]
[Lean.Elab.DefViewElabHeader.ref,[]]
[Equiv.coe_fn_mk,[rfl]]
[Lean.Meta.CasesSubgoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Match.Extension.State.mk.inj,[]]
[Squash.mk,[Quot.mk, True]]
[Lean.Elab.Command.mkDefViewOfTheorem,[Lean.Elab.DefView, Lean.Elab.DefView.mk, Lean.Elab.DefKind.theorem, Lean.Syntax.getOp, OfNat.ofNat, Option.some]]
[Lean.Parser.Level.addLit.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.numLit.formatter]]
[Lean.Json.CompressWorkItem.arrayElem.injEq,[Eq.propIntro, Eq.refl, Lean.Json.CompressWorkItem.arrayElem, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.instToJsonJson,[Lean.ToJson.mk, id]]
[Lean.Meta.Cache.synthInstance,[]]
[Lean.JsonRpc.ErrorCode.requestCancelled.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.PostponedEntry.lhs,[]]
[Lean.Meta.SynthInstance.getTop,[Bind.bind, MonadState.get, Pure.pure, Array.back, Lean.Meta.SynthInstance.State.generatorStack]]
[ulift.up.inj,[]]
[Std.HashMapImp.erase,[Std.HashMapImp, ite, Eq, Std.AssocList.contains, Bool.true, Std.HashMapImp.mk, HSub.hSub, OfNat.ofNat, Std.HashMapBucket.update, Std.AssocList.erase]]
[Lean.Elab.Term.PatternVar.localVar.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.PatternVar.localVar, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Expr.isStringLit,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.natVal, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[Lean.Elab.Term.SyntheticMVarKind.tactic.inj,[And.intro]]
[Lean.Server.MonadRpcSession.rpcReleaseRef,[]]
[Lean.IR.mkRet,[Lean.IR.FnBody.ret]]
[Lean.Lsp.DocumentSymbolAux.name,[]]
[Lean.Compiler.SpecState.switch,[Lean.Compiler.SpecState, Lean.Compiler.SpecState.mk, Lean.SMap.switch]]
[Lean.PrettyPrinter.Formatter.withPosition.formatter,[]]
[Lean.Name.append,[Lean.Name, Lean.Name.mkStr, PProd.fst, Lean.Name.mkNum]]
[Nat.lt_succ_of_le,[Nat.succ_le_succ]]
[Lean.Elab.Term.CollectPatternVars.Context.funId,[]]
[Lean.getPPAnalyzeTrustOfNat,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.trustOfNat, Lean.Option.defValue]]
[Lean.Elab.ContextInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.ContextInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[implies_congr_ctx,[propext, Iff.intro]]
[Lean.Parsec.many1Chars,[Bind.bind, Lean.Parsec.manyCharsCore, Char.toString]]
[Lean.Parser.Term.noImplicitLambda,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, Lean.Parser.maxPrec]]
[StateRefT'.instMonadStateOfStateRefT',[MonadStateOf.mk, StateRefT'.get, StateRefT'.set, StateRefT'.modifyGet]]
[decidableLt_of_decidableLe,[Decidable, LT.lt, dite, LE.le, Decidable.isFalse, decidableLt_of_decidableLe.proof_1, Decidable.isTrue, lt_of_le_not_le, decidableLt_of_decidableLe.proof_2]]
[Lean.Parser.Term.doReassign.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.notFollowedByRedefinedTermToken.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.letIdDeclNoBinders.parenthesizer, Lean.Parser.Term.letPatDecl.parenthesizer]]
[List.partitionAux,[Prod, List, Prod.mk, List.reverse, Unit.unit, PProd.fst, List.cons]]
[Lean.Elab.Term.Do.ToTerm.Kind.forInWithReturn.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Function.injective2.eq_iff,[Iff.intro, Eq, congr_arg2]]
[Int.instAddInt,[Add.mk, Int.add]]
[IsMulLeftCancel.mul_left_cancel,[]]
[Lean.Meta.SynthInstance.ConsumerNode.noConfusionType,[]]
[Lean.Export.Entry.level.injEq,[Eq.propIntro, Eq.refl, Lean.Export.Entry.level, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Expr.instBEqExpr,[BEq.mk, Lean.Expr.eqv]]
[Lean.IR.CtorFieldInfo.scalar.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.Watchdog.WorkerEvent.crashed.inj,[]]
[Lean.Lsp.Hover.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.Hover.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Or.neg_resolve_left,[Or.elim, absurd, id]]
[not_iff_not,[Decidable.not_iff_not]]
[IO.Process.Output.stderr,[]]
[Or.imp,[Or.elim, Function.comp, Or.inl, Or.inr]]
[Lean.Server.Watchdog.WorkerEvent.crashed.injEq,[Eq.propIntro, Eq.refl, Lean.Server.Watchdog.WorkerEvent.crashed, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Delaborator.Context.inPattern,[]]
[USize.land,[USize.mk, Fin.land, USize.val]]
[ST.Ref.modifyGet,[liftM, ST.Prim.Ref.modifyGet]]
[instDecidableEqChar,[Decidable, Eq, decEq, Char.val, Decidable.isTrue, Char.eq_of_val_eq, Decidable.isFalse, Char.ne_of_val_ne]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.f,[]]
[Lean.ScopedEnvExtension.Entry.scoped.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.isDefEqNat,[ite, Eq, or, Lean.Expr.hasFVar, Lean.Expr.hasMVar, Bool.true, Pure.pure, Lean.LBool.undef, Bind.bind, Lean.Meta.reduceNat?, Unit.unit, Lean.Meta.MetaM, Lean.LBool]]
[instXorUInt16,[Xor.mk, UInt16.xor]]
[Lean.Parser.Term.doFinally,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.doSeq]]
[Array.swapAt,[Prod.mk]]
[Lean.Parser.Tactic.tacticSeq1Indented,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.many1Indent, Lean.Parser.group, HAndThen.hAndThen, Lean.Parser.ppLine, Lean.Parser.tacticParser, Lean.Parser.optional, Lean.Parser.symbol]]
[Std.PShareCommonT.withShareCommon,[MonadState.modifyGet, Std.ShareCommon.PersistentState.shareCommon]]
[Lean.Meta.SynthInstance.MkTableKey.M,[ReaderT, Lean.MetavarContext, StateM, Lean.Meta.SynthInstance.MkTableKey.State]]
[Lean.Level.instToFormatLevel,[Std.ToFormat.mk, Lean.Level.format]]
[Lean.Level.Data.hash,[UInt32.toUInt64, UInt64.toUInt32]]
[Attr.simps,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.const]]
[Lean.IR.mkUnreachable,[Lean.IR.FnBody.unreachable]]
[Lean.mkAnnotation,[Lean.mkMData, Lean.KVMap.insert, Lean.KVMap.empty, Lean.DataValue.ofBool, Bool.true]]
[Lean.Meta.Closure.State.newLetDecls,[]]
[Lean.EnvironmentHeader.imports,[]]
[gt_of_ge_of_gt,[lt_of_lt_of_le]]
[Array.shrink.loop,[Array, PProd.fst, Array.pop]]
[mul_left_comm,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Eq.symm, mul_assoc, mul_comm, rfl]]
[Lean.PersistentEnvExtension.addImportedFn,[]]
[Lean.Elab.Tactic.elabSimpConfigCtxCore,[ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, Lean.Meta.Simp.ConfigCtx.mk, Lean.Meta.Simp.Config.mk, Lean.withoutModifyingState, Lean.Meta.withLCtx, Lean.LocalContext.mk, EmptyCollection.emptyCollection, Lean.Elab.Term.withSynthesize, Bind.bind, Lean.Elab.Term.elabTermEnsuringType, Lean.Syntax.getOp, OfNat.ofNat, Option.some, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Option.none, liftM, Lean.Meta.instantiateMVars, Bool.false]]
[Lean.Elab.Term.LetRecDeclView.valStx,[]]
[instMonadControlExceptT,[MonadControl.mk, Except, liftM, ExceptT.run]]
[Lean.MessageLog.msgs,[]]
[withPtrAddrUnsafe,[ptrAddrUnsafe]]
[Lean.Server.FileWorker.WorkerState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.FileWorker.WorkerState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Std.HashMapImp.findEntry?.proof_1,[Subtype.property]]
[MonadControlT.restoreM,[]]
[Mathlib.ExtendedBinder.«term∃___,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[MonadState.modifyGet,[]]
[Lean.Parser.ident.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.identKind, Bool.true, Lean.PrettyPrinter.Formatter.identNoAntiquot.formatter]]
[Lean.mkLambdaEx,[Lean.mkLambda]]
[not_and_of_not_or_not,[False, Or.elim, absurd]]
[Prod.map_map,[of_eq_true, Eq.trans, congr, congrArg, Eq, Prod.map, prod_map, Prod.mk, Prod.fst, Prod.snd, Function.comp, Function.comp_apply, eq_self]]
[Lean.ResolveName.resolveGlobalName,[Lean.MacroScopesView.name, List.nil, Lean.ResolveName.resolveGlobalName.loop]]
[ExceptCpsT.run,[Except, Pure.pure, Except.ok, Except.error]]
[Lean.IR.instInhabitedIRType,[Inhabited.mk, Lean.IR.IRType.float]]
[Lean.Elab.Term.MutualClosure.LetRecClosure.mk.inj,[And.intro]]
[withPtrEq,[Unit.unit]]
[Lean.Parser.Tactic.choose!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Server.Watchdog.workerCfg,[IO.Process.StdioConfig.mk, IO.Process.Stdio.piped, IO.Process.Stdio.inherit]]
[Array.findSomeRevM?.find,[Option, Pure.pure, Option.none]]
[Lean.Server.FileWorker.EditableDocument.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Std.RBNode.node.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Std.PersistentArray.forIn,[Bind.bind, Std.PersistentArray.forInAux, Std.PersistentArray.root, Pure.pure, ForIn.forIn, MProd.mk, Option.none, ForInStep, MProd, Option, ForInStep.done, Option.some, PUnit.unit, ForInStep.yield, Unit.unit, MProd.fst]]
[Mathlib.Tactic.Lint.decorateError,[MonadExcept.tryCatch, MonadExcept.throw]]
[UInt16.instSemiringUInt16.proof_8,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt16.one_def, UInt16.mul_def, UInt16.mk, OfNat.ofNat, mul_one, UInt16.val, UInt16.mk_val_eq, eq_self, propext, forall_const, UInt16]]
[Int.decEq,[Decidable, Eq, Int.ofNat, decEq, Decidable.isTrue, Int.decEq.proof_1, Decidable.isFalse, Int.decEq.proof_2, Int.negSucc, Int.decEq.proof_3, Int.decEq.proof_4, Int.decEq.proof_5, Int.decEq.proof_6]]
[Lean.instInhabitedNameTrie,[Inhabited.mk, Lean.NameTrie.empty]]
[Lean.Parser.Command.inferMod,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.atomic, HAndThen.hAndThen, Lean.Parser.symbol]]
[Lean.IR.Borrow.BorrowInfState.noConfusionType,[]]
[Nat.add_mod_right,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, Nat.mod_eq_sub_mod, Nat.le_add_left, HSub.hSub, Nat.add_sub_cancel, rfl]]
[Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter,[modify, Lean.PrettyPrinter.Formatter.State.mk, Lean.PrettyPrinter.Formatter.State.stxTrav, Lean.PrettyPrinter.Formatter.State.stack]]
[Lean.Elab.Term.toParserDescr.processNonReserved,[Unit.unit, Lean.Elab.Term.ToParserDescrM, Lean.Syntax, Lean.Syntax.isStrLit?, Lean.Syntax.getOp, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Quote.quote, Lean.Elab.throwUnsupportedSyntax]]
[HShiftLeft.noConfusionType,[]]
[Lean.Elab.Term.elabNoMatch',[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Array.findIdxM?, Lean.Elab.Term.isAtomicDiscr?, Pure.pure, Option.isNone, Option.none, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, List.nil, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, Lean.Syntax.SepArray.elemsAndSeps, Lean.Syntax.SepArray.ofElems, Lean.Elab.Term.elabTerm, PUnit.unit, Lean.Elab.throwUnsupportedSyntax]]
[Lean.IR.FreeIndices.instAndThenCollector,[AndThen.mk, Unit.unit]]
[Lean.EnvExtensionInterfaceUnsafe.mkInitialExtStates,[Bind.bind, ST.Ref.get, Array.mapM, Lean.EnvExtensionInterfaceUnsafe.Ext.mkInitial]]
[Lean.Parser.Tactic.Conv.first,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq]]
[Subtype.mk.injEq,[Eq.propIntro, Eq.refl, Subtype.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.ClosedTermCache.constNames,[]]
[Lean.Expr.lit.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.lit, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Do.Code.ite.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Do.Code.ite, Eq.symm, eq_of_heq, HEq.refl]]
[IO.Process.Stdio.noConfusion,[noConfusionEnum, IO.Process.Stdio.toCtorIdx]]
[Lean.MetavarContext.LevelMVarToParam.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MetavarContext.LevelMVarToParam.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Attribute.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Widget.TaggedText.appendText,[Lean.Widget.TaggedText.tag, Lean.Widget.TaggedText, Lean.Widget.TaggedText.text, HAppend.hAppend, Lean.Widget.TaggedText.append, Array.back, Array.set!, HSub.hSub, Array.size, OfNat.ofNat, Array.push, List.toArray, List.cons, List.nil]]
[Lean.Elab.Term.finalizePatternDecls,[Bind.bind, ForIn.forIn, Lean.Elab.Term.TermElabM, ForInStep, Array, Lean.LocalDecl, liftM, Lean.Meta.getLocalDecl, Lean.Meta.instantiateLocalDeclMVars, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Meta.instantiateMVars, Lean.mkMVar, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MVarId.name, Lean.mkFVar, Lean.Meta.sortLocalDecls]]
[Lean.Elab.Term.resolveName.process,[ite, Eq, List.isEmpty, Bool.true, Bind.bind, MonadReader.read, and, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.isValidAutoBoundImplicitName, Lean.Elab.throwAutoBoundImplicitLocal, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkConst, List.nil, Pure.pure, PUnit.unit]]
[Lean.Lsp.CompletionItem.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.CompletionItem.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.TextDocumentPositionParams.mk.inj,[And.intro]]
[ExceptT.adapt,[ExceptT.mk, Functor.map, Except.mapError]]
[Lean.Meta.IndPredBelow.mkBelowMatcher.newMotive,[Lean.Meta.lambdaTelescope, Lean.Meta.MatcherApp.motive, Bind.bind, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Lean.Expr.replaceFVars, Lean.Meta.withLocalDeclD, Lean.Meta.mkLambdaFVars, HAppend.hAppend, Array.ofSubarray, Array.toSubarray, OfNat.ofNat, List.toArray, List.cons, List.nil, Array.size, Bool.false, Bool.true, Lean.isTracingEnabledFor, ite, Eq, Lean.addTrace, Lean.ToMessageData.toMessageData, PUnit.unit]]
[Lean.IR.CtorInfo.cidx,[]]
[Lean.Server.Completion.State.mk.inj,[And.intro]]
[Lean.Meta.InductionSubgoal.noConfusionType,[]]
[Function.left_inverse.id,[funext]]
[Lean.Elab.Term.synthesizeInstMVarCore,[Bind.bind, Lean.Elab.Term.getMVarDecl, liftM, Lean.Meta.instantiateMVars, Lean.Meta.trySynthInstance, Unit.unit, Lean.Elab.Term.TermElabM, Bool, Lean.Elab.Term.isExprMVarAssigned, ite, Eq, Bool.true, Lean.mkMVar, Lean.Meta.isDefEq, Pure.pure, PUnit.unit, orM, Lean.Elab.Term.containsPendingMVar, Bool.false, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr]]
[Lean.LocalInstances,[Array, Lean.LocalInstance]]
[Lean.Elab.Term.elabExplicitUnivs,[Array.foldrM, Bind.bind, Lean.Elab.Term.elabLevel, Pure.pure, List.cons, List.nil, Array.size, OfNat.ofNat]]
[Lean.Export.Entry.expr.inj,[]]
[Lean.Level.hasMVarEx,[Lean.Level.hasMVar]]
[IO.Process.Output.noConfusionType,[]]
[fix6,[fixCore6, arbitrary]]
[Lean.IR.UnreachableBranches.Value.choice.inj,[]]
[Bool.toLBool,[Unit.unit, Lean.LBool, Lean.LBool.true, Lean.LBool.false]]
[Lean.Elab.Command.modifyScope,[modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, Unit.unit, List, Lean.Elab.Command.Scope, Lean.Elab.Command.State.scopes, List.cons, panicWithPosWithDecl, OfNat.ofNat, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState]]
[Nat.succ.injEq,[Eq.propIntro, Eq.refl, Nat.succ, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Command.elabPrintAxioms,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.withRef, Bind.bind, Lean.Elab.resolveGlobalConstWithInfos, Option.none, List.forM, Lean.MonadEnv.getEnv, Lean.Elab.Command.CommandElabM, Unit, Array.isEmpty, Lean.Elab.Command.CollectAxioms.State.axioms, Lean.Elab.logInfo, HAppend.hAppend, Lean.ToMessageData.toMessageData, Array.toList, Lean.Elab.throwUnsupportedSyntax]]
[PLift.up_down,[Eq, PLift.up, PLift.down, rfl]]
[implies,[]]
[EqIffBeqTrue,[Iff.intro, decide_eq_true, of_decide_eq_true]]
[Lean.Meta.Closure.MkValueTypeClosureResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Closure.MkValueTypeClosureResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Structural.RecArgInfo.reflexive,[]]
[DoResultBC.break.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.instInhabitedConstantVal,[Inhabited.mk, Lean.ConstantVal.mk, arbitrary]]
[randBool,[Prod, Bool, Prod.mk, Decidable.decide, Eq, OfNat.ofNat]]
[Lean.instMonadRef,[Lean.MonadRef.mk, liftM, Lean.MonadRef.getRef, MonadFunctorT.monadMap, Lean.MonadRef.withRef]]
[Lean.Parsec.skipString,[SeqRight.seqRight, Lean.Parsec.pstring, Pure.pure, Unit.unit]]
[Lean.Elab.Term.Do.Alt.ref,[]]
[Lean.getPPAnalyzeTrustId,[Lean.KVMap.get, Lean.Option.name, Lean.pp.analyze.trustId, Lean.Option.defValue]]
[Lean.Lsp.PlainGoalParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.TransformStep.noConfusionType,[]]
[Lean.Lsp.HoverParams.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Simp.Methods.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Simp.Methods.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Server.FileWorker.WorkerContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.FileWorker.WorkerContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.termQuoteₓ_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.wfRecursion,[Bind.bind, Lean.withoutModifyingEnv, ForIn.forIn, PUnit.unit, liftM, Lean.Elab.addAsAxiom, Pure.pure, ForInStep.yield, Lean.Elab.WF.packDomain, Lean.Elab.WF.packMutual, Lean.Elab.WF.elabWFRel, Lean.Elab.WF.mkFix, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.PreDefinition.declName]]
[Std.AssocList.ibelow,[True, And]]
[Lean.setTraceState,[Lean.MonadTrace.modifyTraceState]]
[Lean.Elab.Term.Quotation.HeadCheck.other.inj,[]]
[Function.comp_right,[]]
[Lean.Compiler.SpecState.addEntry,[Lean.Compiler.SpecState, Lean.Compiler.SpecState.mk, Lean.SMap.insert, Lean.Compiler.SpecState.specInfo, Lean.Compiler.SpecState.cache]]
[Lean.PPContext.openDecls,[]]
[Array.toArrayLit_eq',[Array.toArrayLit_eq'.aux]]
[Lean.Lsp.WorkDoneProgressEnd.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.WorkDoneProgressEnd.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Function.partial_inv_of_injective,[Iff, Eq, Function.partial_inv, Option.some, Iff.intro]]
[Lean.Xml.Parser.STag,[SeqRight.seqRight, Lean.Parsec.skipChar, Char.ofNat, Pure.pure]]
[Lean.expandExplicitBindersAux.loop,[Unit.unit, Lean.MacroM, Lean.Syntax, Pure.pure, Lean.Syntax.isIdent, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Lean.Elab.Term.elabSetOption,[Bind.bind, Lean.Elab.elabSetOption, Lean.Syntax.getOp, OfNat.ofNat, withTheReader, Lean.Core.Context, Lean.Core.Context.mk, Lean.Core.Context.currRecDepth, Lean.Option.get, Lean.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats, Lean.Elab.Term.elabTerm, Bool.true]]
[Lean.LocalDecl.ldecl.inj,[And.intro]]
[Lean.Parser.Term.doElem.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.doElemParser.parenthesizer]]
[Lean.ModuleData.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ModuleData.mk, Eq.symm, eq_of_heq, HEq.refl]]
[ShiftRight.noConfusionType,[]]
[Lean.Meta.throwFunctionExpected,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr]]
[Lean.IR.IRType.union.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.IRType.union, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Level.mkData,[ite, GT.gt, HSub.hSub, Nat.pow, OfNat.ofNat, panicWithPosWithDecl]]
[Lean.Lsp.ReferenceContext.noConfusionType,[]]
[Lean.Parser.Term.letRecDecls.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.Term.letRecDecl.parenthesizer, Lean.Parser.symbol.parenthesizer, Bool.false]]
[Lean.InductiveType.name,[]]
[Lean.Parser.Attr.ext,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[IO.Error.protocolError.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.hexDigitFn,[ite, Eq, String.atEnd, Bool.true, Lean.Parser.ParserState.mkEOIError, List.nil, or, Char.isDigit, and, Decidable.decide, LE.le, Char.ofNat, Lean.Parser.ParserState.setPos, Lean.Parser.ParserState.mkUnexpectedError]]
[Lean.IR.ResetReuse.M,[ReaderT, Lean.IR.LocalContext, StateT, Lean.IR.Index, Id]]
[instReprAtomNat,[ReprAtom.mk]]
[Lean.Elab.Term.LVal.noConfusionType,[]]
[Lean.Elab.Tactic.SavedState.noConfusionType,[]]
[Lean.PrettyPrinter.mkParenthesizerAttribute,[Lean.KeyedDeclsAttribute.init, Lean.KeyedDeclsAttribute.Def.mk, Lean.Name.mkStr, Lean.Name.anonymous, Bind.bind, Lean.MonadEnv.getEnv, Lean.Attribute.Builtin.getId, ite, Eq, or, and, Option.isSome, Lean.Environment.find?, Lean.Parser.isValidSyntaxNodeKind, Bool.true, Pure.pure, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.Elab.Info.ofCompletionInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Closure.MkValueTypeClosureResult.type,[]]
[Lean.AttributeExtensionOLeanEntry.builder.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Set.subset,[Mem.mem]]
[Lean.Elab.addAuxDeclarationRanges,[Bind.bind, Lean.Elab.getDeclarationRange, Lean.addDeclarationRanges, Lean.DeclarationRanges.mk]]
[Lean.Elab.Tactic.rewriteTarget,[Lean.Elab.Term.withSynthesize, Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.elabTerm, Option.none, Bool.true, Lean.Elab.Tactic.getMainGoal, Lean.Elab.Tactic.getMainTarget, liftM, Lean.Meta.rewrite, Lean.Occurrences.all, Lean.Meta.replaceTargetEq, Lean.Meta.RewriteResult.eNew, Lean.Meta.RewriteResult.eqProof, Lean.Elab.Tactic.replaceMainGoal, List.cons, Lean.Meta.RewriteResult.mvarIds, Bool.false]]
[Lean.Meta.mkExpectedTypeHint,[Bind.bind, Lean.Meta.getLevel, Pure.pure, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil]]
[instDecidableEqQuotient,[Quotient.recOnSubsingleton₂, Decidable, Eq, Quotient.mk, Decidable.isTrue, Quotient.sound, Decidable.isFalse, instDecidableEqQuotient.proof_2]]
[Lean.PrettyPrinter.Parenthesizer.rawCh.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken]]
[Lean.Elab.Term.SavedState.restore,[Bind.bind, Lean.MonadTrace.getTraceState, MonadState.get, liftM, Lean.Meta.SavedState.restore, Lean.Elab.Term.SavedState.meta, MonadStateOf.set, Lean.Elab.Term.SavedState.elab, Lean.setTraceState, ite, Eq, Bool.true, Pure.pure, PUnit.unit, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift]]
[instInhabitedUInt8,[Inhabited.mk, UInt8.ofNatCore, OfNat.ofNat, instInhabitedUInt8.proof_1]]
[Tactic.Ring.Cache.noConfusionType,[]]
[Lean.Meta.mapMetaM,[controlAt, Lean.Meta.MetaM, MonadControlT.stM]]
[Lean.Elab.Term.tryPostpone,[Bind.bind, MonadReader.read, ite, Eq, Lean.Elab.Term.Context.mayPostpone, Bool.true, Lean.Elab.throwPostpone, Pure.pure, PUnit.unit]]
[Lean.Parser.runParserCategory,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Except.error, Lean.Parser.ParserState.toErrorMsg, String.atEnd, Lean.Parser.ParserState.pos, Except.ok, Array.back, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.mkError]]
[Lean.Parser.Term.type.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkWsBefore.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.leadPrec, Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer, Lean.Parser.levelParser.parenthesizer, Lean.Parser.maxPrec]]
[Nat.dvd_of_mod_eq_zero,[Exists.intro, HDiv.hDiv]]
[Lean.Lsp.TextDocumentSyncKind.full.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Term.Command.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.commandParser.formatter]]
[Lean.Lsp.instToJsonTextDocumentEdit,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentEdit.textDocument, List.nil, Lean.Lsp.TextDocumentEdit.edits]]
[List.join_cons,[rfl]]
[Lean.Parser.Term.waitIfTypeContainsMVar,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.termParser]]
[instHashableProd,[Hashable.mk, UInt64, mixHash, Hashable.hash]]
[Lean.Syntax.prettyPrint,[Unit.unit, Std.Format, Lean.Syntax.reprint, Lean.Syntax.unsetTrailing, Std.ToFormat.format, String.toFormat]]
[List.forall_mem_append,[Eq.mpr, congrFun, congrArg, Iff, Eq.trans, forall_congr, implies_congr, propext, List.mem_append, Eq.refl, or_imp_distrib, forall_and_distrib, And, Iff.rfl]]
[Std.PersistentArrayNode.ibelow,[And, True]]
[WellFoundedRelation.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.toArray_data,[List.toArrayAux_data, Array.mkEmpty, List.redLength]]
[Lean.Parser.Term.prio.quot.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.incQuotDepth.formatter, Lean.Parser.priorityParser.formatter]]
[Lean.BinderInfo.implicit.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.appendTag,[Lean.Name.modifyBase, HAppend.hAppend, Lean.Name.eraseMacroScopes]]
[Lean.Elab.Structural.RecArgInfo.indLevels,[]]
[Lean.Parser.ModuleParserState.mk.inj,[And.intro]]
[instHPow,[HPow.mk, Pow.pow]]
[Lean.Lsp.Location.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.ExprStructEq.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.elseIf.formatter,[Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.group.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.checkLineEq.formatter]]
[Tactic.Ring.Cache.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.withoutMacroStackAtErr,[withTheReader, Lean.Core.Context, Lean.Core.Context.mk, Lean.Option.set, Lean.Core.Context.options, Lean.Elab.pp.macroStack, Bool.false, Lean.Core.Context.currRecDepth, Lean.Core.Context.maxRecDepth, Lean.Core.Context.ref, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, Lean.Core.Context.initHeartbeats, Lean.Core.Context.maxHeartbeats]]
[Lean.HeadIndex.instHashableHeadIndex,[Hashable.mk, Lean.HeadIndex.HeadIndex.hash]]
[Lean.Syntax.isScientificLit?,[Option.none, Option, Prod, Nat, Bool, Lean.Syntax.isLit?, Lean.scientificLitKind, Lean.Syntax.decodeScientificLitVal?]]
[Lean.Elab.Term.StructInst.FieldLHS.fieldName.inj,[And.intro]]
[Lean.Expr.not?,[Lean.Expr.app1?, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Elab.instInhabitedVisibility,[Inhabited.mk, Lean.Elab.Visibility.regular]]
[Lean.Elab.Term.LValResolution.localRec.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Match.AltLHS.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.AltLHS.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.instFileSourceSemanticTokensRangeParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.FileSource.fileSource, Lean.Lsp.SemanticTokensRangeParams.textDocument]]
[HasEquiv.noConfusionType,[]]
[Lean.Expr.updateLambdaE!.proof_1,[rfl]]
[Lean.Parser.Tactic.ringMode,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Meta.CongrTheorem.mk.inj,[And.intro]]
[Lean.Parser.Tactic.have'',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser]]
[Lean.Elab.Term.StructInst.Fields,[List, Lean.Elab.Term.StructInst.Field, Lean.Elab.Term.StructInst.Struct]]
[Lean.Elab.Term.Do.Code.seq.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.ParserContext.quotDepth,[]]
[Lean.Meta.mkInjectiveTheorems,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, Lean.Meta.isInductivePredicate, ite, Eq, and, Lean.Environment.contains, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Option.get, Lean.Meta.genInjectivity, not, Bool.true, Lean.getConstInfoInduct, Lean.InductiveVal.isUnsafe, Pure.pure, PUnit.unit, ForIn.forIn, Lean.getConstInfoCtor, GT.gt, Lean.ConstructorVal.numFields, OfNat.ofNat, liftM, Lean.Meta.elimOptParam, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, Lean.Meta.forallBoundedTelescope, Option.some, Lean.ConstructorVal.numParams, Lean.Meta.forallTelescope, List.toArray, List.nil, Lean.Meta.withNewBinderInfos, Array.map, Prod.mk, Lean.Expr.fvarId!, Lean.BinderInfo.implicit, Bool.false, Option.none, Lean.Meta.MetaM, Unit, Lean.Meta.forallTelescopeReducing, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.injection, Unit.unit, panicWithPosWithDecl, Lean.Meta.splitAnd, List.forM, Lean.Meta.assumptionCore, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentD, Lean.MessageData.ofGoal, Lean.Expr.mvarId!, Array.back, Lean.Meta.mkLambdaFVars, Lean.ConstantVal.name, Lean.Meta.instantiateMVars, Lean.addDecl, Lean.Declaration.thmDecl, Lean.TheoremVal.mk, Lean.ConstantVal.mk, Lean.Meta.mkInjectiveTheoremNameFor, Lean.ConstantVal.levelParams, Lean.Meta.apply, Lean.mkConst, List.cons, Lean.Expr, Lean.Meta.intro1, Lean.Meta.casesAnd, Lean.Meta.substEqs, Lean.Meta.applyRefl, Lean.Meta.addSimpLemma, Lean.Meta.simpExtension, Lean.AttributeKind.global, ForInStep.yield]]
[Lean.KernelException.letTypeMismatch.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.letTypeMismatch, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.ToHide.hasVisibleDep,[Bind.bind, MonadState.get, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.findLocalDeclDependsOn, not, Std.RBTree.contains, Lean.Meta.ToHide.State.hiddenInaccessible]]
[Lean.Parser.Module.module.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Module.header.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.commandParser.parenthesizer, Lean.Parser.ppLine.parenthesizer]]
[Lean.Syntax.isIdent,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Bool, Bool.true, Bool.false]]
[IO.FS.Stream.writeResponse,[IO.FS.Stream.writeMessage, Lean.JsonRpc.Message.response, Lean.JsonRpc.Response.id, Lean.ToJson.toJson, Lean.JsonRpc.Response.result]]
[Lean.Elab.Term.mkMatcher,[liftM, Lean.Meta.Match.mkMatcher]]
[Lean.Elab.Term.StructInst.Field.ref,[]]
[Lean.instBEqDefinitionSafety,[BEq.mk, BEq.beq, Lean.DefinitionSafety.toCtorIdx]]
[Std.ShareCommon.State.inhabited,[Inhabited.mk, Std.ShareCommon.State.empty]]
[IO.FS.Metadata.mk.inj,[And.intro]]
[Subrelation.wf.proof_1,[WellFounded.intro, Subrelation.accessible, WellFounded.apply]]
[Std.HashSetImp.insert,[Std.HashSetImp, ite, Eq, List.contains, Bool.true, Std.HashSetImp.mk, Std.HashSetBucket.update, List.replace, LE.le, Array.size, Subtype.val, Std.HashSetImp.expand]]
[Nat.add_mul_div_left,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HAdd.hAdd, HMul.hMul, Nat.zero, Nat.mul_zero, OfNat.ofNat, Nat.add_zero, rfl, Nat.succ, Nat.mul_succ, Eq.symm, Nat.add_assoc, Nat.add_div_right]]
[Lean.Rat.mul,[HMul.hMul, HDiv.hDiv, Lean.Rat.num, Int.ofNat, Lean.Rat.den]]
[LawfulFunctor.noConfusionType,[]]
[Lean.Parser.Tactic.extractGoal,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Array.zip,[Array.zipWith, Prod.mk]]
[Lean.Syntax.getTrailingSize,[Option.none, Option.some, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Nat, Lean.Syntax.getTailInfo?, Substring.bsize, OfNat.ofNat]]
[Lean.Meta.NormNum.instLawfulOfNatNat.proof_1,[Lean.Meta.NormNum.LawfulOfNat.mk, rfl]]
[instZero,[Zero.mk, OfNat.ofNat]]
[Lean.DelayedMetavarAssignment.val,[]]
[commutative,[Eq]]
[pow_zero,[Monoid.npow_zero']]
[Lean.Elab.Term.State.syntheticMVars,[]]
[Nat.lt_irrefl,[Nat.not_succ_le_self]]
[ByteArray.append,[ByteArray.copySlice, OfNat.ofNat, ByteArray.size, Bool.false]]
[instReprAtomUInt16,[ReprAtom.mk]]
[Semiring.npow_zero',[]]
[Lean.Elab.Term.MVarErrorInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.MVarErrorInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[«term_⊕_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.Command.StructView.allUserLevelNames,[]]
[Lean.Parser.Tactic.tacticTry_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Lean.Parser.longestMatchMkResult,[ite, Eq, and, not, Lean.Parser.ParserState.hasError, Decidable.decide, GT.gt, Lean.Parser.ParserState.stackSize, HAdd.hAdd, OfNat.ofNat, Bool.true, Lean.Parser.ParserState.mkNode, Lean.choiceKind]]
[Lean.Lsp.Ipc.writeRequest,[Bind.bind, Lean.Lsp.Ipc.stdin, liftM, IO.FS.Stream.writeLspRequest]]
[Int.add_assoc_aux1,[Eq, HAdd.hAdd, Int.ofNat, of_eq_true, Eq.trans, congr, congrArg, congrFun, Int.ofNat_add_ofNat, Nat.add_assoc, eq_self, Int.negSucc, Int.ofNat_add_negSucc_ofNat, Int.subNatNat_add, Nat.succ, Int.subNatNat]]
[instToStringSubarray,[ToString.mk, ToString.toString, Subarray.toArray]]
[Nat.not_succ_le_self,[Unit.unit, Not, LE.le, Nat.succ, Nat.not_succ_le_zero, OfNat.ofNat, absurd, Nat.le_of_succ_le_succ, PProd.fst]]
[Nat.one_pos,[Nat.zero_lt_one]]
[Nat.eq_of_mul_eq_mul_right,[Nat.eq_of_mul_eq_mul_left, Eq.mp, Eq.refl, Eq, HMul.hMul, Nat.mul_comm]]
[Lean.PrefixTreeNode.Node.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.refl, Std.RBNode.leaf, Eq.trans, congr, congrFun, Eq.symm, Std.RBNode.node.sizeOf_spec]]
[Std.RBMap.find!,[Unit.unit, Std.RBMap.find?, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Elab.Term.MVarErrorInfo.noConfusionType,[]]
[Lean.Meta.Simp.throwCongrHypothesisFailed,[MonadExcept.throw, Lean.Exception.internal, Lean.Meta.Simp.congrHypothesisExceptionId, Lean.KVMap.mk]]
[Lean.IR.VarIdSet,[Std.RBTree, Lean.IR.VarId, Ord.compare, Lean.IR.VarId.idx]]
[Lean.Meta.NormNum.isNat_pow,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, OfNat.ofNat, Lean.Meta.NormNum.isNat, HPow.hPow, ofNat_pow]]
[Lean.Json.obj.sizeOf_spec,[congrArg, Nat.add, OfNat.ofNat, Eq.refl, SizeOf.sizeOf, Std.RBNode.leaf, Eq.trans, congr, congrFun, HAdd.hAdd, Eq.symm, Std.RBNode.node.sizeOf_spec]]
[List.nil_bind,[of_eq_true, eq_self, List.nil]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[ByteSlice.instForInByteSliceUInt8,[ForIn.mk, ByteSlice.forIn.loop, HAdd.hAdd]]
[EStateM.nonBacktrackable,[EStateM.Backtrackable.mk, EStateM.dummySave, EStateM.dummyRestore]]
[Lean.TagAttribute.hasTag,[Unit.unit, Bool, Lean.Environment.getModuleIdxFor?, Array.binSearchContains, Lean.PersistentEnvExtension.getModuleEntries, Lean.TagAttribute.ext, Lean.Name.quickLt, OfNat.ofNat, HSub.hSub, Array.size, Lean.NameSet.contains, Lean.PersistentEnvExtension.getState]]
[Lean.mkBRecOnName,[Lean.Name.mkStr, Lean.brecOnSuffix]]
[Lean.Meta.IndPredBelow.instInhabitedVariables,[Inhabited.mk, Lean.Meta.IndPredBelow.Variables.mk, arbitrary]]
[UInt32.decEq.proof_2,[absurd]]
[Lean.Parser.Term.prec.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.precedenceParser]]
[Lean.Expr.FindImpl.State.mk.inj,[]]
[Lean.LocalContext.numIndices,[Std.PersistentArray.size, Lean.LocalContext.decls]]
[Lean.Parser.Attr.instance,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.priorityParser]]
[Lean.Parser.Attr.reassoc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[Lean.Elab.Term.Do.ToTerm.actionTerminalToTerm,[Lean.withRef, Lean.MonadQuotation.withFreshMacroScope, Bind.bind, MonadReader.read, Lean.Elab.Term.Do.ToTerm.mkUVarTuple, Unit.unit, Lean.Elab.Term.Do.ToTerm.M, Lean.Syntax, Lean.Elab.Term.Do.ToTerm.Context.kind, ite, Eq, Array.isEmpty, Lean.Elab.Term.Do.ToTerm.Context.uvars, Bool.true, Pure.pure, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Lsp.CompletionList.noConfusionType,[]]
[Lean.MessageData.joinSep,[List.cons, Lean.MessageData, Lean.MessageData.ofFormat, Std.Format.nil, HAppend.hAppend, PProd.fst]]
[Lean.Meta.Closure.mkForall,[Lean.Meta.Closure.mkBinding, Bool.false]]
[Lean.Elab.instInhabitedElabInfo,[Inhabited.mk, Lean.Elab.ElabInfo.mk, arbitrary]]
[AddGroup.toSubNegMonoid,[]]
[Lean.Meta.Simp.instInhabitedResult,[Inhabited.mk, Lean.Meta.Simp.Result.mk, arbitrary]]
[PSigma.revLex,[PSigma.revLex.proof_1]]
[Lean.addTrace.addTraceOptions,[Lean.MessageData.ofFormat, Lean.MessageData.ofSyntax, Lean.MessageData.ofExpr, Lean.MessageData.ofLevel, Lean.MessageData.ofName, Lean.MessageData.ofGoal, Lean.MessageData.withNamingContext, Lean.MessageData.nest, Lean.MessageData.group, Lean.MessageData.compose, Lean.MessageData.tagged, Lean.MessageData.node, Lean.MessageData, Lean.MessageData.withContext, Lean.MessageDataContext.mk, Lean.MessageDataContext.env, Lean.MessageDataContext.mctx, Lean.MessageDataContext.lctx, Lean.KVMap.setBool, Lean.MessageDataContext.opts, Lean.Name.mkStr, Lean.Name.anonymous, Bool.false]]
[Lean.Elab.Tactic.getGoals,[Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Tactic.State.goals]]
[Lean.FindLevelMVar.Visitor,[Option, Lean.MVarId]]
[Std.PersistentArray.Stats.toString,[HAppend.hAppend, ToString.toString, Std.PersistentArray.Stats.numNodes, Std.PersistentArray.Stats.depth, Std.PersistentArray.Stats.tailSize]]
[Int.neg_neg_ofNat_succ,[rfl]]
[Lean.Lsp.RpcConnected.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.RpcConnected.mk, Eq.symm, eq_of_heq, HEq.refl]]
[UInt16.mul_def,[rfl]]
[Std.RBMap.forM,[Std.RBMap.foldM, PUnit.unit]]
[Lean.IR.CtorLayout.fieldInfo,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.instMonadWithReaderOfSubExprAnalyzeM,[MonadWithReaderOf.mk, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.mk, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.knowsType, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.knowsLevel, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.inBottomUp, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.parentIsApp, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.subExpr]]
[List.dropWhile,[Unit.unit, List, List.nil, PProd.fst, List.cons]]
[Lean.FindMVar.Visitor,[Option, Lean.MVarId]]
[And.congr_right_iff,[Iff.intro, Eq.mp, congr, congrArg, Iff, Eq.trans, congrFun, And, eq_true, true_and, and_congr_right]]
[Lean.QuotKind.ctor.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[instRingFin.proof_4,[of_eq_true, Eq.trans, forall_congr, eq_self, Neg.neg, HMul.hMul, Fin.ofNat', Nat.succ, Fin.size_positive, propext, forall_const, Fin, Nat]]
[Lean.Lsp.TypeDefinitionParams.noConfusionType,[]]
[Array.findSomeRevM?.find.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self]]
[min_eq_right,[Eq.mpr, Eq.refl, Eq, min, min_comm, min_eq_left]]
[Lean.MessageData.instCoeExprMessageData,[Coe.mk, Lean.MessageData.ofExpr]]
[Lean.Core.State.noConfusionType,[]]
[Lean.Elab.Tactic.ElimApp.Result.others,[]]
[UInt8.instSemiringUInt8.proof_8,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt8.one_def, UInt8.mul_def, UInt8.mk, OfNat.ofNat, mul_one, UInt8.val, UInt8.mk_val_eq, eq_self, propext, forall_const, UInt8]]
[add_left_cancel_iff,[Iff.intro, add_left_cancel, congrArg, HAdd.hAdd]]
[Lean.instInhabitedTraceState,[Inhabited.mk, Lean.TraceState.mk, arbitrary]]
[Lean.ClassState.noConfusionType,[]]
[ByteArray.set!,[ByteArray, ByteArray.mk, Array.set!]]
[Lean.Widget.CodeWithInfos.pretty,[Lean.Widget.TaggedText.stripTags]]
[One.noConfusionType,[]]
[Std.PersistentArray.root,[]]
[Lean.Elab.Term.ensureType,[Bind.bind, liftM, Lean.Meta.isType, ite, Eq, Bool.true, Pure.pure, Lean.Meta.inferType, Lean.Meta.mkFreshLevelMVar, Lean.Meta.isDefEq, Lean.mkSort, Lean.Meta.mkFreshTypeMVar, Lean.MetavarKind.natural, Lean.Name.anonymous, Lean.Meta.getLevel, Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.synthetic, MonadExcept.tryCatch, Lean.Elab.Term.withoutMacroStackAtErr, Lean.Elab.Term.synthesizeCoeInstMVarCore, Lean.Meta.expandCoe, Lean.mkAppN, Lean.mkConst, Lean.Name.mkStr, List.cons, List.nil, List.toArray, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Lean.Exception.internal, Lean.Elab.Term.TermElabM, Lean.Expr]]
[Lean.Parser.Tactic.open.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.openDecl.formatter, Lean.PrettyPrinter.Formatter.withOpenDecl.formatter, Lean.Parser.Tactic.tacticSeq.formatter]]
[Lean.MacroScopesView.mainModule,[]]
[Lean.Elab.GoalsAtResult.mk.inj,[And.intro]]
[List.mapTRAux_eq,[of_eq_true, Eq.trans, congrArg, Eq, List.reverse, List.append_nil, eq_self, Eq.mpr, Eq.refl, List.mapTRAux, List.cons, HAppend.hAppend, List.map, List.reverse_cons, List.nil, List.append_assoc, rfl]]
[Lean.Lsp.ReferenceParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.ReferenceParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[instSubsingletonSquash,[instSubsingletonSquash.proof_1]]
[Lean.Elab.Term.StructInst.FieldVal.term.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.Parenthesizer.withoutPosition.parenthesizer,[]]
[Lean.Elab.Structural.RecArgInfo.noConfusionType,[]]
[Lean.Lsp.ServerCapabilities.hoverProvider,[]]
[Lean.MonadCacheT.instMonadLiftMonadCacheT,[inferInstanceAs, MonadLift, StateRefT', Std.HashMap]]
[Lean.Expr.ReplaceLevelImpl.cache.proof_1,[lcProof]]
[Lean.mkRawNatLit,[Lean.mkLit, Lean.Literal.natVal]]
[Lean.IR.ExplicitBoxing.BoxingState.auxDecls,[]]
[Lean.EnumAttributes.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.EnumAttributes.mk, Eq.symm, eq_of_heq, HEq.refl]]
[ByteArray.foldlM.loop,[dite, LT.lt, Unit.unit, Pure.pure, Bind.bind, ByteArray.get, Fin.mk, ByteArray.foldlM.loop.proof_1, PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[Lean.Server.Watchdog.eraseFileWorker,[Bind.bind, MonadReader.read, ST.Ref.modify, Lean.Server.Watchdog.ServerContext.fileWorkersRef, Std.RBMap.erase]]
[imp_iff_not_or,[Decidable.imp_iff_not_or]]
[Lean.Parser.declareTrailingBuiltinParser,[Lean.Parser.declareBuiltinParser, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Elab.Term.elabMatch,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.Elab.Term.resolveId?, Bool.false, Unit.unit, Lean.Elab.Term.TermElabM, Bool, Pure.pure, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.MonadEnv.getEnv, Option.none, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo, Lean.Environment.find?, not, Lean.hasMatchPatternAttribute, and, Lean.Syntax.isIdent, Lean.Name.isAtomic, Lean.Name.eraseMacroScopes, Lean.Syntax.getId, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Elab.Term.withMacroExpansion, Lean.Elab.Term.elabTerm, Lean.Elab.Term.elabMatch.elabMatchDefault]]
[List.toArrayAux_data,[Eq, Array.data, List.toArrayAux, HAppend.hAppend, Eq.symm, List.append_nil, List.nil, Eq.trans, PProd.fst, Array.push, of_eq_true, congrFun, congrArg, Array.mk, List.concat_eq_append, List.append_assoc, List.cons, List.singleton_append, eq_self]]
[Lean.Meta.ElimAltInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.ElimAltInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.instInhabitedName,[Inhabited.mk, Lean.Name.anonymous]]
[Lean.HeadIndex.proj.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.HeadIndex.proj, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.noncomputable,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[instDecidableEqNat,[Nat.decEq]]
[List.cons_subset_of_subset_of_mem,[Iff.mpr, List.cons_subset, And.intro]]
[RandomGen.range,[]]
[Lean.getPPMatch,[Lean.KVMap.get, Lean.Option.name, Lean.pp.match, not, Lean.getPPAll]]
[Std.HashSet.empty,[Std.mkHashSet, OfNat.ofNat]]
[Lean.Elab.GoalsAtResult.ctxInfo,[]]
[Lean.MetavarContext.assignDelayed,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Lean.MetavarContext.decls, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Lean.MetavarContext.eAssignment, Std.PersistentHashMap.insert, Lean.MetavarContext.dAssignment, Lean.DelayedMetavarAssignment.mk]]
[Lean.IR.ExplicitRC.VarInfo.persistent,[]]
[Lean.LocalContext.all,[Id.run, Lean.LocalContext.allM]]
[Std.RBMap.ofList,[Unit.unit, Std.RBMap, Std.mkRBMap, Std.RBMap.insert, PProd.fst]]
[Lean.Lsp.CompletionItem.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.hasOutParams,[Unit.unit, Bool, Lean.SMap.find?, Lean.ClassState.hasOutParam, Lean.SimplePersistentEnvExtension.getState, Lean.classExtension, Bool.false]]
[Lean.Meta.Match.Problem.mvarId,[]]
[instPowNatNat,[Pow.mk, Nat.pow]]
[ExceptT.run,[]]
[Lean.LocalDecl.setType,[Lean.LocalDecl, Lean.LocalDecl.cdecl, Lean.LocalDecl.ldecl]]
[Lean.MetavarContext.MkBinding.instToStringException,[ToString.mk, String, HAppend.hAppend, ToString.toString, Array.map, Lean.LocalDecl.userName, Lean.LocalContext.getFVar!]]
[Lean.PrettyPrinter.Delaborator.addFieldInfo,[Bind.bind, modify, Lean.PrettyPrinter.Delaborator.State.mk, Std.RBMap.insert, Lean.PrettyPrinter.Delaborator.State.infos, Lean.PrettyPrinter.Delaborator.State.holeIter, Lean.PrettyPrinter.Delaborator.addFieldInfo.mkFieldInfo]]
[Function.right_inverse_of_injective_of_left_inverse,[]]
[Lean.PersistentEnvExtensionState.mk.inj,[And.intro]]
[Lean.JsonRpc.Response.id,[]]
[Acc.noConfusionType,[]]
[Int.add_left_neg,[Unit.unit, Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat, rfl, of_eq_true, Eq.trans, congrFun, congrArg, Int.neg_ofNat_of_succ, Int.ofNat, Nat.succ, Int.negSucc_ofNat_add_ofNat, Int.sub_nat_self, eq_true_of_decide, Eq.refl, Bool.true, Int.neg_neg_ofNat_succ, Int.negSucc, Int.ofNat_add_negSucc_ofNat]]
[Lean.MonadStateCacheT.instMonadFinallyMonadStateCacheT,[inferInstanceAs, MonadFinally, StateT, Std.HashMap]]
[Lean.Parser.Command.syntaxAbbrev.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.docComment.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.syntaxParser.parenthesizer]]
[Lean.Name.eraseMacroScopes,[Unit.unit, Lean.Name, Lean.Name.hasMacroScopes, BEq.beq, PProd.fst, Lean.Name.anonymous]]
[Lean.PrettyPrinter.Formatter.evalInsideQuot.formatter,[]]
[ByteSlice.toString,[Id.run, Bind.bind, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield]]
[Lean.Widget.Lean.Widget.CodeToken.instRpcEncodingCodeTokenRpcEncodingPacket,[Lean.Server.RpcEncoding.mk, Bind.bind, Lean.Server.RpcEncoding.rpcEncode, Lean.Widget.CodeToken.info, Pure.pure, Lean.Server.RpcEncoding.rpcDecode, Lean.Widget.CodeToken.mk]]
[coeOfTail,[CoeHTCT.mk, coeTail]]
[Lean.ScopedEnvExtension.State.noConfusionType,[]]
[Lean.IR.ExplicitBoxing.mkBoxedVersionAux,[Bind.bind, Array.mapM, MonadState.modifyGet, Prod.mk, Lean.IR.VarId.mk, HAdd.hAdd, OfNat.ofNat, Pure.pure, Lean.IR.Param.mk, Bool.false, Lean.IR.IRType.object, Nat.foldM, Lean.IR.ExplicitBoxing.N, Prod, Array, Lean.IR.FnBody, Lean.IR.Arg, ite, Eq, not, Lean.IR.IRType.isScalar, Lean.IR.Param.ty, Bool.true, Array.push, Lean.IR.Arg.var, Lean.IR.Param.x, Lean.IR.FnBody.vdecl, Lean.IR.Expr.unbox, arbitrary, List.toArray, List.nil, Array.size, Lean.IR.Decl, Lean.IR.Decl.resultType, Lean.IR.reshape, Lean.IR.FnBody.ret]]
[Nat.gcd_mul_left_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.gcd_comm, Nat.gcd_mul_left_left, rfl]]
[Lean.Parser.Term.have.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.haveDecl.formatter, Lean.Parser.Term.optSemicolon.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Lean.Expr.noConfusionType,[]]
[Functor.map_equiv.proof_2,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Functor.map_map, Equiv.toFun, Equiv.symm, Functor.map, Equiv.self_comp_symm, LawfulFunctor.id_map, eq_self]]
[Lean.instInhabitedStructureInfo,[Inhabited.mk, Lean.StructureInfo.mk, arbitrary]]
[Lean.PrettyPrinter.parenthesizeTactic,[Lean.PrettyPrinter.parenthesize, Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat]]
[Lean.MData,[Lean.KVMap]]
[Lean.PrettyPrinter.Formatter.registerAlias,[Lean.Parser.registerAliasCore, Lean.PrettyPrinter.Formatter.formatterAliasesRef]]
[Lean.IR.mkVDecl,[Lean.IR.FnBody.vdecl]]
[Lean.Meta.IndPredBelow.mkBrecOnDecl.mkType,[Lean.Meta.forallTelescopeReducing, Array.getOp, Lean.Meta.IndPredBelow.Context.headers, Bind.bind, Array.mapIdxM, Lean.Meta.IndPredBelow.Context.motives, Lean.Meta.IndPredBelow.mkBrecOnDecl.mkIH, Array.ofSubarray, Lean.Meta.withLocalDeclsD, Lean.Meta.mkForallFVars, HAppend.hAppend, Lean.mkAppN, Bool.false, Bool.true]]
[Lean.Elab.Term.ElabAppArgs.State.f,[]]
[Lean.Parser.Command.namedPrio.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.priorityParser.formatter]]
[Lean.Meta.instInhabitedCongrLemma,[Inhabited.mk, Lean.Meta.CongrLemma.mk, arbitrary]]
[StateCpsT.runK_set,[rfl]]
[Lean.ScopedEnvExtension.State.activeScopes,[]]
[Lean.Elab.getInfoHoleIdAssignment?,[Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, Pure.pure, Std.PersistentHashMap.getOp, Lean.Elab.InfoState.assignment]]
[Lean.instInhabitedDeclarationRange,[Inhabited.mk, Lean.DeclarationRange.mk, arbitrary]]
[Lean.Parser.Tactic.squeezeSimp?!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.Environment.add,[Lean.Environment.addAux]]
[Lean.IR.CtorLayout.numObjs,[]]
[Nat.mod_add_div,[Nat.mod.inductionOn, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HMod.hMod, HMul.hMul, HDiv.hDiv, Nat.div_eq, ite, And, LT.lt, OfNat.ofNat, LE.le, HSub.hSub, Nat.mod_eq, congrFun, congrArg, congr, Eq.trans, ite_congr, eq_true, eq_true_of_decide, Bool.true, ite_true, Nat.mul_succ, Eq.symm, Nat.add_assoc, Nat.sub_add_cancel, And.right, rfl, of_eq_true, eq_false, ite_false, Nat.mul_zero, Nat.add_zero, eq_self]]
[Lean.Elab.Tactic.Conv.changeLhs,[Bind.bind, Lean.Elab.Tactic.Conv.getRhs, Lean.Elab.Tactic.liftMetaTactic1, Lean.Meta.mkEq, coeM, Lean.Meta.replaceTargetDefEq, Lean.mkLHSGoal]]
[Lean.instQuoteSubstring,[Lean.Quote.mk, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Quote.quote, Substring.toString, List.nil]]
[Lean.Environment.getModuleIdx?,[Array.findIdx?, Lean.EnvironmentHeader.moduleNames, Lean.Environment.header, BEq.beq]]
[Lean.Elab.Tactic.getMainGoal.loop,[Unit.unit, Lean.Elab.Tactic.TacticM, Lean.MVarId, Lean.Elab.Tactic.throwNoGoalsToBeSolved, Bind.bind, liftM, Lean.Meta.isExprMVarAssigned, ite, Eq, Bool.true, PProd.fst, Lean.Elab.Tactic.setGoals, List.cons, Pure.pure]]
[String.instDecidableEqIterator,[Decidable, Eq, dite, Decidable.isTrue, rfl, Decidable.isFalse]]
[Lean.JsonRpc.instBEqRequest,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.JsonRpc.Notification.noConfusionType,[]]
[Lean.Server.FileWorker.handleReferences.combineFvars,[Prod, Array, Lean.Server.FileWorker.Reference, Std.HashMap, Lean.FVarId, Prod.mk]]
[Lean.registerEnumAttributes,[Bind.bind, Lean.registerPersistentEnvExtension, Lean.PersistentEnvExtensionDescr.mk, Pure.pure, EmptyCollection.emptyCollection, Lean.NameMap.insert, Prod.fst, Prod.snd, Array.qsort, Lean.Name.quickLt, OfNat.ofNat, HSub.hSub, Array.size, HAppend.hAppend, Std.Format.text, Std.Format.line, Std.ToFormat.format, Std.RBMap.size, List.forM, Lean.registerBuiltinAttribute, Lean.EnumAttributes.mk]]
[Std.Rbcolor.toCtorIdx,[OfNat.ofNat]]
[Lean.TagDeclarationExtension.tag,[Lean.PersistentEnvExtension.addEntry]]
[Lean.PrettyPrinter.Formatter.identNoAntiquot.formatter,[Bind.bind, Lean.PrettyPrinter.Formatter.checkKind, Lean.identKind, Lean.Syntax.MonadTraverser.getCur, Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.PrettyPrinter.FormatterM, Unit, Lean.PrettyPrinter.Formatter.pushToken, Lean.Name.toString, Bool.true, Lean.Syntax.MonadTraverser.goLeft, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[instCoeTail_1,[CoeTail.mk, coeSort]]
[Lean.Meta.NormNum.eval_eq_of_isNat,[Eq.symm, eq_of_heq, Eq.refl, OfNat.ofNat, HEq.refl, Eq, rfl]]
[elabVariables,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.logWarningAt, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Option.getD, Lean.Syntax.getHeadInfo?, Array.append, List.nil, Lean.Elab.Command.elabVariable, Lean.Elab.throwUnsupportedSyntax]]
[Std.PersistentHashSet.mk.injEq,[Eq.propIntro, Eq.refl, Std.PersistentHashSet.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.version.major,[Unit.unit]]
[Lean.Elab.Term.StructInst.DefaultFields.Context.mk.inj,[And.intro]]
[CoeHead.coe,[]]
[Lean.Elab.Level.State.levelNames,[]]
[Function.injective_id,[id]]
[Decidable.not_and,[Decidable.not_and_iff_or_not]]
[Lean.Parser.Command.elabTail.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.darrow.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.Parser.termParser.formatter]]
[Nat.ne_of_lt,[Nat.not_le_of_lt, Nat.le_refl, Eq.symm]]
[Lean.Elab.Term.Do.ToTerm.Kind.forIn.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.withBindingBodyUnusedName,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.PrettyPrinter.Delaborator.getUnusedName, Lean.Expr.bindingName!, Lean.Expr.bindingBody!, Lean.PrettyPrinter.Delaborator.annotateCurPos, Lean.mkIdent, Lean.PrettyPrinter.Delaborator.SubExpr.withBindingBody]]
[Lean.Elab.RecKind.nonrec.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.instInhabitedClassState,[Inhabited.mk, Lean.ClassState.mk, arbitrary]]
[Std.PersistentArray.instForInPersistentArray,[ForIn.mk, Std.PersistentArray.forIn]]
[String.instInhabitedString,[Inhabited.mk]]
[IO.Error.mkInappropriateTypeFile,[Function.comp, IO.Error.inappropriateType, Option.some]]
[List.replace,[List, List.nil, Unit.unit, BEq.beq, List.cons, PProd.fst]]
[Lean.Elab.Term.isExprMVarAssigned,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.isExprAssigned]]
[Std.ShareCommonM,[Std.ShareCommonT, Id]]
[Lean.Parser.Syntax.paren.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.syntaxParser.parenthesizer]]
[Lean.Parser.Tactic.simpa,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser]]
[StateT.run_bind,[of_eq_true, eq_self, Bind.bind]]
[Std.PersistentHashMap.instToStringStats,[ToString.mk, Std.PersistentHashMap.Stats.toString]]
[Lean.ProjectionFunctionInfo.fromClassEx,[Lean.ProjectionFunctionInfo.fromClass]]
[Lean.Elab.Term.SavedContext.errToSorry,[]]
[Lean.Lsp.TextDocumentContentChangeEvent.rangeChange.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PExprSet,[Lean.PersistentExprSet]]
[Lean.Elab.Term.elabForIn.getMonad,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.throwError, Lean.ToMessageData.toMessageData, Bind.bind, Lean.Elab.Term.isTypeApp?, Pure.pure, HAppend.hAppend, Lean.indentExpr]]
[OptionT.lift,[OptionT.mk, Bind.bind, Pure.pure, Option.some]]
[Lean.Parser.commandParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.PrettyPrinter.Delaborator.AppMatchState.varNames,[]]
[Lean.Elab.Tactic.saveTacticInfoForToken,[ite, Eq, Option.isNone, Lean.Syntax.getPos?, Bool.false, Bool.true, Pure.pure, PUnit.unit, Lean.Elab.Tactic.withTacticInfoContext, Unit.unit]]
[Lean.LocalContext.decls,[]]
[Lean.Parser.getSyntaxNodeKinds,[Std.PersistentHashMap.foldl, List.cons, List.nil]]
[Lean.Parser.Term.strictImplicitRightBracket.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.group.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer]]
[Function.inv_fun,[Function.inv_fun_on, Set.univ]]
[Std.RBMap,[Subtype, Std.RBNode.WellFormed]]
[instHOr,[HOr.mk, OrOp.or]]
[Lean.Elab.Tactic.getFVarIds,[Lean.Elab.Tactic.withMainContext, Array.mapM, Lean.Elab.Tactic.getFVarId]]
[Lean.RecursorVal.getMajorIdx,[HAdd.hAdd, Lean.RecursorVal.numParams, Lean.RecursorVal.numMotives, Lean.RecursorVal.numMinors, Lean.RecursorVal.numIndices]]
[readThe,[MonadReaderOf.read]]
[Lean.Elab.Term.instInhabitedArg,[Inhabited.mk, Lean.Elab.Term.Arg.stx, arbitrary]]
[Lean.getReducibilityStatusImp,[Unit.unit, Lean.ReducibilityStatus, Lean.EnumAttributes.getValue, Lean.reducibilityAttrs, Lean.ReducibilityStatus.semireducible]]
[Lean.Meta.getFVarLocalDecl,[Lean.Meta.getLocalDecl, Lean.Expr.fvarId!]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.noConfusionType,[]]
[Lean.PrettyPrinter.Delaborator.unresolveNameGlobal,[ite, Eq, Lean.Name.hasMacroScopes, Bool.true, Pure.pure, Bind.bind, PUnit.unit, Lean.PrettyPrinter.Delaborator.unresolveNameGlobal.unresolveNameCore]]
[Lean.PrefixTree.empty,[Subtype.mk, Lean.PrefixTreeNode.empty, Lean.PrefixTreeNode.WellFormed.emptyWff]]
[Lean.Lsp.TextDocumentPositionParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.TextDocumentPositionParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.doReassign,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.notFollowedByRedefinedTermToken, HOrElse.hOrElse, Lean.Parser.Term.letIdDeclNoBinders, Lean.Parser.Term.letPatDecl]]
[Lean.Meta.instInhabitedSimpLemmas,[Inhabited.mk, Lean.Meta.SimpLemmas.mk, arbitrary]]
[String.isPrefix,[List.isPrefix]]
[Lean.Server.FileWorker.CancelToken.new,[Functor.map, Lean.Server.FileWorker.CancelToken.mk, liftM, IO.mkRef, Bool.false]]
[exists_and_distrib_left,[Iff.intro, And, Exists, And.intro, Exists.intro]]
[Lean.isIOUnitInitFnCore,[Option.none, Unit.unit, Option.some, Lean.Name.str, Lean.Name.num, Bool, Lean.ParametricAttribute.getParam, Bool.true, Bool.false]]
[Lean.Xml.Parser.CData,[Lean.Parsec.manyChars, SeqRight.seqRight, Lean.Parsec.notFollowedBy, Lean.Parsec.skipString, Lean.Parsec.anyChar]]
[Lean.termThis,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Or.swap,[Or.inr, Or.inl]]
[Lean.Expr.consumeMData,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.proj, Lean.Expr, PProd.fst]]
[Decidable.byContradiction,[Decidable.byCases, id, False.elim]]
[RandomGen.noConfusionType,[]]
[Lean.FileMap.lspPosToUtf8Pos,[String.codepointPosToUtf8PosFrom, Lean.FileMap.source]]
[Lean.NameHashSet.instEmptyCollectionNameHashSet,[EmptyCollection.mk, Lean.NameHashSet.empty]]
[Nat.lt_or_eq_of_le,[Or.imp_right, Nat.le_antisymm, Nat.lt_or_ge]]
[Lean.Parser.Tactic.quotSeq,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.Tactic.seq1]]
[Lean.Lsp.instFromJsonCompletionOptions,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, Array, String, Bool, Pure.pure, Lean.Lsp.CompletionOptions.mk]]
[Lean.Expr.Data,[UInt64]]
[Lean.Meta.ParamInfo.backDeps,[]]
[StateRefT'.instMonadExceptOfStateRefT',[MonadExceptOf.mk, Function.comp, StateRefT'.lift, throwThe, tryCatchThe]]
[Quot.liftBeta,[rfl]]
[Lean.Parser.Term.letPatDecl.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.pushNone.parenthesizer, Lean.Parser.Term.optType.parenthesizer, Lean.Parser.symbol.parenthesizer, Bool.false]]
[Lean.Option.«commandRegister_option__:_:=_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Lean.Parser.runParserAttributeHooks,[Bind.bind, ST.Ref.get, Lean.Parser.parserAttributeHooks, List.forM, Lean.Parser.ParserAttributeHook.postAdd]]
[Array.filterM,[Array.foldlM, Bind.bind, ite, Eq, Bool.true, Pure.pure, Array.push, List.toArray, List.nil]]
[Lean.isLetterLike,[or, and, Decidable.decide, LE.le, OfNat.ofNat, Char.val, Ne]]
[Decidable.iff_not_comm,[Eq.mpr, Eq.refl, Iff, Not, propext, iff_def, And, and_congr, imp_not_comm, Decidable.not_imp_comm]]
[Lean.mkLitEx,[Lean.mkLit]]
[instDecidableOr.proof_1,[False]]
[And.left,[]]
[Lean.PrettyPrinter.Delaborator.delabLit,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Pure.pure, Lean.Quote.quote, panicWithPosWithDecl, OfNat.ofNat]]
[strictOr,[or]]
[Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp,[Trans.mk, Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp.proof_1]]
[Lean.Lsp.WorkspaceFolder.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.WorkspaceFolder.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.add_le_of_le_sub_left,[Iff.mp, Nat.not_lt, Iff.mpr, Nat.sub_lt_left_of_lt_add]]
[Lean.MonadStateCacheT.instMonadExceptOfMonadStateCacheT,[inferInstanceAs, MonadExceptOf, StateT, Std.HashMap]]
[Lean.MonadRef.withRef,[]]
[Lean.Meta.isProof,[Bind.bind, Lean.Meta.isProofQuick, Unit.unit, Lean.Meta.MetaM, Bool, Pure.pure, Bool.true, Bool.false, Lean.Meta.inferType, Lean.Meta.isProp]]
[Lean.mkEM,[Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Lean.JsonRpc.ResponseError.id,[]]
[Lean.Server.maybeTee,[Bind.bind, liftM, IO.getEnv, Unit.unit, IO, IO.FS.Stream, Pure.pure, IO.FS.createDirAll, System.FilePath.mk, IO.FS.Handle.mk, System.mkFilePath, List.cons, List.nil, IO.FS.Mode.write, Bool.true, ite, Eq, IO.FS.Stream.chainLeft, IO.FS.Stream.chainRight]]
[Lean.Meta.Simp.Step.done.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[IO.Error.mkInappropriateType,[IO.Error.inappropriateType, Option.none]]
[DoResultSBC.continue.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt32.instRingUInt32.proof_2,[congrArg, UInt32.mk, Ring.gsmul_zero', UInt32.val]]
[instDecidableArrow.proof_1,[]]
[liftExcept,[Pure.pure, MonadExcept.throw]]
[Lean.Elab.Command.InductiveView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.InductiveView.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Prod.lex.proof_1,[WellFounded.intro, Acc, Prod.Lex, WellFoundedRelation.rel, Prod.lexAccessible, WellFounded.apply, WellFoundedRelation.wf]]
[Lean.Meta.SimpAll.Entry.type,[]]
[Lean.Elab.InfoTree.ofJson.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.InfoTree.ofJson, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Widget.TaggedText.instInhabitedTaggedState,[Inhabited.mk, arbitrary]]
[Lean.JsonRpc.instCoeJsonNumberRequestID,[Coe.mk, Lean.JsonRpc.RequestID.num]]
[Nat.sub_self_add,[]]
[Lean.Parser.Term.attrInstance.formatter,[Lean.ppGroup.formatter, Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.attrParser.formatter]]
[Lean.Meta.mkRecursorInfo,[Bind.bind, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.Meta.MetaM, Lean.Meta.RecursorInfo, Lean.getConstInfoInduct, Lean.RecursorVal.getInduct, Pure.pure, Lean.Meta.RecursorInfo.mk, Bool.true, Lean.InductiveVal.isRec, Lean.RecursorVal.getMajorIdx, Unit.unit, Option.some, Lean.MonadEnv.getEnv, ite, Eq, Option.isSome, not, Lean.isAuxRecursor, Option.none, Lean.Name.anonymous, Lean.Name.num, Option, Nat, and, bne, Lean.recOnSuffix, Lean.casesOnSuffix, Lean.brecOnSuffix, Lean.getConstInfoRec, Lean.mkRecName, HAdd.hAdd, Lean.RecursorVal.numParams, Lean.RecursorVal.numIndices, BEq.beq, OfNat.ofNat, Lean.RecursorVal.numMotives, Lean.Meta.forallTelescopeReducing, Lean.ConstantInfo.type, Lean.Expr.withApp, Lean.Expr.isFVar, Array.all, Array.size, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Prod, Lean.Expr, Bool, dite, LT.lt, Prod.mk, Array.isEmpty, Lean.Meta.getMajorPos?]]
[Lean.IR.Decl.extern.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Decl.extern, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.RpcCallParams.noConfusionType,[]]
[subtypeCoe,[CoeHead.mk, Subtype.val]]
[instAddUInt64,[Add.mk, UInt64.add]]
[Lean.IR.CtorFieldInfo.scalar.inj,[And.intro]]
[Lean.IR.ExplicitRC.getJPLiveVars,[Unit.unit, Lean.IR.LiveVarSet, Std.RBMap.find?, Lean.IR.ExplicitRC.Context.jpLiveVarMap, EmptyCollection.emptyCollection]]
[Lean.IR.EmitC.emitFnDeclAux,[Bind.bind, Lean.IR.EmitC.getEnv, ite, Eq, Array.isEmpty, Bool.true, Lean.isClosedTermName, Lean.IR.Decl.name, Lean.IR.EmitC.emit, not, Pure.pure, PUnit.unit]]
[Lean.IR.Expr.uproj.inj,[And.intro]]
[Lean.Parser.anyOfFn,[List.cons, Lean.Parser.ParserState, Lean.Parser.ParserState.mkError, Lean.Parser.Parser.fn, Lean.Parser.orelseFn, PProd.fst]]
[Lean.Parser.Command.catBehaviorSymbol,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.nonReservedSymbol, Bool.false]]
[Std.PersistentHashMap.empty,[Std.PersistentHashMap.mk]]
[List.length_append,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.length, List.nil_append, congrFun, HAdd.hAdd, List.length_nil, Nat.zero_add, eq_self, List.cons_append, List.length_cons, HAppend.hAppend, Nat.succ, Nat.succ_add]]
[instSubsingleton,[instSubsingleton.proof_1]]
[Lean.Options.empty,[Lean.KVMap.mk]]
[Lean.Elab.instInhabitedRecKind,[Inhabited.mk, Lean.Elab.RecKind.partial]]
[Lean.Parser.Tactic.Conv.«conv·._»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq]]
[Lean.Expr.Data.nonDepLet,[BEq.beq, UInt64.land, UInt64.shiftRight, OfNat.ofNat]]
[IO.FS.Mode.read.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Term.PatternVarDecl.localVar.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.PatternVarDecl.localVar, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Syntax.ifNodeKind,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, ite, Eq, BEq.beq, Bool.true, Subtype.mk, Lean.Syntax.node, Lean.IsNode.mk, Unit.unit]]
[heq_self_iff_true,[iff_true_intro, HEq.rfl]]
[Lean.Meta.DefaultInstanceEntry.instanceName,[]]
[Int.instSubInt,[Sub.mk, Int.sub]]
[Lean.MetavarContext.assignExpr,[Lean.MetavarContext.mk, Lean.MetavarContext.depth, Lean.MetavarContext.mvarCounter, Lean.MetavarContext.lDepth, Lean.MetavarContext.decls, Lean.MetavarContext.userNames, Lean.MetavarContext.lAssignment, Std.PersistentHashMap.insert, Lean.MetavarContext.eAssignment, Lean.MetavarContext.dAssignment]]
[Lean.Widget.InfoWithCtx.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Widget.InfoWithCtx.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.moduleDoc.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.ppDedent.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.commentBody.formatter, Lean.ppLine.formatter]]
[List.eq_or_mem_of_mem_cons,[]]
[Lean.Elab.Term.StructInst.instToFormatStruct,[Std.ToFormat.mk, Lean.Elab.Term.StructInst.formatStruct]]
[Nat.instLinearOrderNat,[LinearOrder.mk, Nat.le_total, inferInstance]]
[Lean.Parser.Command.terminationSuffix.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.terminationBy.parenthesizer, Lean.Parser.Command.decreasingBy.parenthesizer]]
[Lean.Parser.Tactic.introMatch.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false, Lean.Parser.Tactic.matchAlts.formatter]]
[Lean.Parser.Tactic.ringNF!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.ringMode, Lean.Parser.Tactic.location]]
[Lean.Meta.solveByElim,[Lean.Meta.MetaM, Unit, Lean.throwError, Lean.ToMessageData.toMessageData, Bind.bind, Lean.MonadLCtx.getLCtx, Lean.LocalContext.firstDeclM, guard, Not, Eq, Lean.LocalDecl.isAuxDecl, Bool.true, Lean.Meta.apply, Lean.LocalDecl.toExpr, ForIn.forIn, PUnit.unit, PProd.fst, Pure.pure, ForInStep.yield]]
[ByteArray.forInUnsafe.loop,[ite, LT.lt, Bind.bind, Pure.pure, ByteArray.forInUnsafe.loop, HAdd.hAdd, OfNat.ofNat]]
[Lean.Lsp.SemanticTokensRangeParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.SemanticTokensRangeParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[IO.FS.Stream.writeLspResponseErrorWithData,[IO.FS.Stream.writeLspMessage, Lean.JsonRpc.Message.responseError, Lean.JsonRpc.ResponseError.id, Lean.JsonRpc.ResponseError.code, Lean.JsonRpc.ResponseError.message, Option.map, Lean.ToJson.toJson, Lean.JsonRpc.ResponseError.data?]]
[Lean.PrettyPrinter.Parenthesizer.throwBacktrack,[MonadExcept.throw, Lean.Exception.internal, Lean.PrettyPrinter.backtrackExceptionId, Lean.KVMap.mk]]
[Std.PersistentHashMap.insert,[Std.PersistentHashMap, Std.PersistentHashMap.mk, Std.PersistentHashMap.insertAux, UInt64.toUSize, Hashable.hash, OfNat.ofNat, HAdd.hAdd]]
[Lean.Meta.mkEqOfHEq,[Bind.bind, Lean.Meta.inferType, Lean.Meta.whnfD, Option.none, Lean.Meta.MetaM, Lean.Expr, Lean.Expr.heq?, Lean.Meta.isDefEq, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Name.mkStr, Lean.Name.anonymous, Lean.indentExpr]]
[Function.left_id,[rfl]]
[Array.setD,[dite, LT.lt, Array.size, Array.set, Fin.mk]]
[Lean.Meta.DiscrTree.getMatchWithExtra,[Lean.Meta.withReducible, Bind.bind, ite, Eq, Bool.true, Lean.Expr.bvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.mdata, Lean.Meta.MetaM, Prod, Lean.Meta.DiscrTree.Key, Array, Lean.Expr, Lean.Expr.getAppFn, Pure.pure, Prod.mk, Lean.Meta.DiscrTree.Key.lit, List.toArray, List.nil, Lean.Meta.DiscrTree.Key.const, Lean.Expr.getAppRevArgs, Lean.Meta.DiscrTree.Key.fvar, Lean.Meta.DiscrTree.Key.other, MonadReader.read, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Context.config, Lean.Meta.DiscrTree.Key.star, Lean.Meta.isReadOnlyOrSyntheticOpaqueExprMVar, Lean.Meta.DiscrTree.Key.proj, List.cons, Lean.Expr.hasLooseBVars, Lean.Meta.DiscrTree.Key.arrow, Nat, Unit.unit, Array.toSubarray, OfNat.ofNat, Array.size, Lean.Meta.DiscrTree.getMatchWithExtra.process]]
[Lean.Json.getArrVal?,[Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Lean.Json.obj, Except, String, Lean.Json, Unit.unit, Array.get?, Pure.pure, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Int.instCommRingInt.proof_5,[Int.sub_eq_add_neg]]
[Ne.intro,[]]
[Lean.MetavarContext.MkBinding.mkBinding,[Bind.bind, Lean.MetavarContext.MkBinding.abstractRange, Array.size, Nat.foldRevM, Lean.MetavarContext.MkBinding.M, Prod, Lean.Expr, Nat, Lean.LocalContext.getFVar!, ite, Eq, or, not, Lean.Expr.hasLooseBVar, OfNat.ofNat, Bool.true, Pure.pure, Prod.mk, Lean.mkLambda, HAdd.hAdd, Lean.mkForall, Lean.Expr.lowerLooseBVars, Lean.mkLet]]
[instInhabitedUInt16.proof_1,[of_decide_eq_true, Eq.refl, Bool.true]]
[or_of_or_of_imp_left,[Or.imp_left]]
[Lean.Elab.Term.Quotation.HeadInfo.noConfusionType,[]]
[Lean.Elab.Command.elabUniverse,[Lean.Syntax.forArgsM, Lean.Syntax.getOp, OfNat.ofNat, Lean.Elab.Command.addUnivLevel]]
[Lean.Meta.SynthInstance.TableEntry.noConfusionType,[]]
[Lean.IR.EmitC.declareVar,[Bind.bind, Lean.IR.EmitC.emit, Lean.IR.EmitC.toCType]]
[Lean.Core.Context.mk.inj,[And.intro]]
[Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat.lt_trans]]
[charToHex,[HAppend.hAppend, hexDigitRepr]]
[Dvd.dvd,[]]
[BaseIO.toEIO,[EStateM.Result.error, EStateM.Result, IO.RealWorld, EStateM.Result.ok]]
[Lean.MonadRecDepth.noConfusionType,[]]
[Quotient.lift₂,[Quotient.lift, Quotient.lift₂.proof_1, Quotient.lift₂.proof_2]]
[Lean.Elab.Tactic.ElimApp.Result.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.MVarErrorKind.implicitArg.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Term.MVarErrorKind.implicitArg, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Do.JPDecl.noConfusionType,[]]
[Lean.Elab.MonadMacroAdapter.getNextMacroScope,[]]
[Lean.Server.FileWorker.updateDocument,[Bind.bind, MonadReader.read, MonadState.get, liftM, Lean.Server.Snapshots.reparseHeader, Lean.FileMap.source, Lean.Server.DocumentMeta.text, Lean.Server.FileWorker.EditableDocument.headerSnap, Lean.KVMap.mk, ite, Eq, bne, Lean.Server.Snapshots.Snapshot.stx, Bool.true, IO.throwServerError, Pure.pure, PUnit.unit]]
[Semiring.mul_one,[]]
[Lean.numLitKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Meta.forallBoundedTelescope,[Lean.Meta.map2MetaM]]
[Lean.Compiler.atMostOnce.AtMostOnceData.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.SymbolKind.event.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Json.getNum?,[Lean.Json.null, Lean.Json.bool, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Except, String, Lean.JsonNumber, Pure.pure, MonadExcept.throw]]
[Lean.Elab.Command.State.messages,[]]
[Array.findSomeRevM?,[Array.size, Nat.le_refl, Array.findSomeRevM?.find]]
[Lean.Meta.FunInfo.paramInfo,[]]
[List.findSomeM?,[Unit.unit, Option, Pure.pure, Option.none, Bind.bind, Option.some, PProd.fst]]
[Lean.Meta.synthInstance?,[Bind.bind, Lean.MonadOptions.getOptions, Lean.profileitM, Lean.Exception, Lean.Meta.getConfig, Lean.Meta.withConfig, Lean.Meta.Config.mk, Bool.true, Lean.Meta.Config.quasiPatternApprox, Bool.false, Lean.Meta.TransparencyMode.instances, Lean.Meta.Config.zetaNonDep, Lean.Meta.Config.trackZeta, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct, Lean.Meta.instantiateMVars, Lean.Meta.forallTelescopeReducing, Lean.Meta.whnf, Lean.Meta.mkForallFVars, MonadState.get, Unit.unit, Lean.Meta.MetaM, Option, Lean.Expr, Std.PersistentHashMap.find?, Lean.Meta.Cache.synthInstance, Lean.Meta.State.cache, Pure.pure, Lean.Meta.withNewMCtxDepth, Lean.Meta.forallTelescope, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr.getAppFn, Lean.MonadEnv.getEnv, ite, Eq, not, Lean.hasOutParams, Lean.Meta.inferType, OfNat.ofNat, Lean.mkAppN, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, PUnit.unit, Option.none, Lean.Meta.openAbstractMVarsResult]]
[Lean.Parser.Command.docComment.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.ppDedent.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.commentBody.parenthesizer, Lean.Parser.ppLine.parenthesizer]]
[Lean.Export.OfState.noConfusionType,[]]
[Lean.MetavarContext.MkBinding.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MetavarContext.MkBinding.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.optional,[Lean.Parser.optionalNoAntiquot, Lean.Parser.withAntiquotSpliceAndSuffix, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol]]
[Lean.IR.mkStrExpr,[Lean.IR.Expr.lit, Lean.IR.LitVal.str]]
[Lean.Elab.logWarningAt,[Lean.Elab.logAt, Lean.MessageSeverity.warning]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.noConfusionType,[]]
[Lean.SimpleScopedEnvExtension.Descr.addEntry,[]]
[Lean.Lsp.instBEqCancelParams,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Server.Snapshots.reparseHeader,[Bind.bind, Lean.Parser.parseHeader, IO, Lean.Server.Snapshots.Snapshot, Pure.pure, Lean.Server.Snapshots.Snapshot.mk, Lean.Server.Snapshots.Snapshot.beginPos, Lean.Server.Snapshots.Snapshot.cmdState, Lean.Server.Snapshots.Snapshot.interactiveDiags]]
[Task.noConfusionType,[]]
[UInt8.toUInt16,[Nat.toUInt16, UInt8.toNat]]
[Lean.Parser.Term.letEqnsDecl.parenthesizer,[Lean.Parser.nodeWithAntiquot.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.letIdLhs.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.matchAlts.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat, Bool.false]]
[Lean.Lsp.instToJsonHover,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.Hover.contents, List.nil, Lean.Json.opt, Lean.Lsp.Hover.range?]]
[Lean.Server.FileWorker.RpcSession.release,[Prod.mk, Lean.Server.FileWorker.RpcSession.mk, Std.PersistentHashMap.erase, Lean.Server.FileWorker.RpcSession.aliveRefs, Lean.Server.FileWorker.RpcSession.nextRef, Lean.Server.FileWorker.RpcSession.expireTime]]
[Lean.ScopedEnvExtension.Descr.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ScopedEnvExtension.Descr.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Contradiction.Config.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Contradiction.Config.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Rat.noConfusionType,[]]
[Lean.Parser.Module.import,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.ident]]
[Lean.Elab.withInfoContext,[Lean.Elab.withInfoTreeContext, Bind.bind, Pure.pure, Lean.Elab.InfoTree.node]]
[Lean.Parser.Term.doReassignArrow.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.Term.notFollowedByRedefinedTermToken.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.doIdDecl.parenthesizer, Lean.Parser.Term.doPatDecl.parenthesizer]]
[Lean.MonadWithOptions.withOptions,[]]
[Fin.mod_eq,[Fin.eq_of_val_eq, Eq.mpr, congrFun, congrArg, Eq, Eq.trans, Fin.val, Fin.modn_def, Nat.mod_mod, Nat.mod_eq_of_lt, Fin.isLt]]
[Lean.Meta.appendTagSuffix,[Bind.bind, Lean.Meta.getMVarTag, Lean.Meta.setMVarTag, Lean.Meta.appendTag]]
[Lean.Compiler.instInhabitedSpecializeAttributeKind,[Inhabited.mk, Lean.Compiler.SpecializeAttributeKind.specialize]]
[Int.natAbs_neg,[Unit.unit, Eq, Int.natAbs, Neg.neg, rfl]]
[Subtype.heq_iff_coe_eq,[Iff.trans, heq_iff_eq, Subtype.ext_iff, funext, propext]]
[Lean.Syntax.splitNameLit,[List.reverse, List.nil]]
[Lean.Parser.Tactic.assocRw,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.Parser.Tactic.location]]
[Lean.Parser.Command.genInjectiveTheorems.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.ident.formatter]]
[UInt16.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd]]
[Lean.PrettyPrinter.Delaborator.SubExpr.nextExtraPos,[Bind.bind, getThe, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator, modifyThe, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.next, Pure.pure]]
[Lean.Elab.OpenDecl.resolveOpenDeclId,[Bind.bind, Lean.MonadResolveName.getOpenDecls, Lean.MonadResolveName.getCurrNamespace, StateRefT'.run', Lean.Elab.OpenDecl.resolveId, Lean.Elab.OpenDecl.State.mk]]
[Lean.Server.Watchdog.ServerContext.noConfusionType,[]]
[Lean.Expr.ReplaceLevelImpl.ReplaceM,[StateM, Lean.Expr.ReplaceLevelImpl.State]]
[Lean.Option.hasQuote,[Lean.Quote.mk, Unit.unit, Lean.Syntax, Lean.mkIdent, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.mkCApp, List.toArray, List.cons, Lean.Quote.quote, List.nil]]
[instLTUInt16,[LT.mk, UInt16.lt]]
[Char.isValidChar_zero,[Or.inl, of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Parser.ParserExtension.OLeanEntry.token.inj,[]]
[Lean.PrettyPrinter.Formatter.numLit.formatter,[Lean.Parser.Term.num.formatter]]
[Lean.IR.Decl.fdecl.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Decl.fdecl, Eq.symm, eq_of_heq, HEq.refl]]
[«term_>=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instMonadBaseIO,[inferInstanceAs, Monad, EIO, Empty]]
[Decidable.decide,[Bool.false, Bool.true]]
[Int.sign_one,[rfl]]
[Lean.Elab.Command.State.infoState,[]]
[Lean.Elab.Command.instInhabitedStructFieldInfo,[Inhabited.mk, Lean.Elab.Command.StructFieldInfo.mk, arbitrary]]
[Lean.Elab.Term.MutualClosure.pushMain,[Nat.foldM, Bind.bind, liftM, Lean.Meta.mkLambdaFVars, Array.getOp, Bool.false, Bool.true, Lean.Meta.mkForallFVars, Lean.Elab.DefViewElabHeader.type, Pure.pure, Array.push, Lean.Elab.PreDefinition.mk, Lean.Elab.getDeclarationSelectionRef, Lean.Elab.DefViewElabHeader.ref, Lean.Elab.DefViewElabHeader.kind, List.nil, Lean.Elab.DefViewElabHeader.modifiers, Lean.Elab.DefViewElabHeader.declName, Array.size]]
[Lean.CollectFVars.State.visitedExpr,[]]
[Lean.Parser.Tactic.revertAfter,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser]]
[Ring.toSemiring,[]]
[Lean.Elab.Deriving.mkContext,[Bind.bind, Lean.getConstInfoInduct, ForIn.forIn, Pure.pure, Array.push, PUnit.unit, ForInStep.yield, Lean.Name.anonymous, Lean.Name.num, Lean.Elab.Term.TermElabM, ForInStep, Array, Lean.Name, Lean.Name.eraseMacroScopes, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkSimple, HAppend.hAppend, Lean.Name.mkStr, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, Lean.ToMessageData.toMessageData]]
[String.foldlAux,[String.foldlAux.loop]]
[Lean.IR.ExplicitBoxing.BoxingContext.resultType,[]]
[Lean.Elab.Term.BinderView.bi,[]]
[Fin.instMulFin,[Mul.mk, Fin.mul]]
[Lean.Lsp.DocumentHighlightKind.noConfusionType,[noConfusionTypeEnum, Lean.Lsp.DocumentHighlightKind.toCtorIdx]]
[Nat.lt_or_ge,[Unit.unit, Or, LT.lt, GE.ge, Or.inr, Nat.zero_le, Nat.succ, PProd.fst, Or.inl, Nat.le_succ_of_le, Nat.eq_or_lt_of_le, Nat.le_refl]]
[Lean.Parser.ParserExtension.Entry.kind.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Tactic.evalCases,[Lean.Elab.Tactic.focus, Bind.bind, Lean.Elab.Tactic.elabCasesTargets, Lean.Syntax.getSepArgs, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, Lean.Syntax.isNone, Bool.true, BEq.beq, Array.size, Pure.pure, PUnit.unit, Lean.throwError, Lean.ToMessageData.toMessageData, Lean.withRef, Lean.Elab.resolveGlobalConstNoOverloadWithInfo, Option.none, liftM, Lean.Meta.getElimInfo, Prod.mk, Bool.false, Lean.Elab.Tactic.TacticM, Unit, Lean.Elab.Tactic.getMainGoal, Lean.MonadMCtx.getMCtx, Lean.Elab.Tactic.getUnsolvedGoals, Lean.MonadRef.getRef, Lean.Elab.Tactic.mkTacticInfo, Lean.Meta.getMVarTag, Lean.Meta.withMVarContext, Lean.Meta.addImplicitTargets, Lean.Elab.Tactic.ElimApp.mkElimApp, Array.mapM, Lean.Meta.instantiateMVars, Array.getOp, Lean.Meta.ElimInfo.targetsPos, Lean.Meta.inferType, Lean.Meta.ElimInfo.motivePos, Lean.Meta.generalizeTargetsEq, Lean.Meta.introN, List.nil, Lean.Elab.Tactic.ElimApp.setMotiveArg, Lean.Expr.mvarId!, Lean.Meta.assignExprMVar, Lean.Elab.Tactic.ElimApp.Result.elimApp, Lean.Elab.Tactic.ElimApp.evalAlts, Lean.Elab.Tactic.ElimApp.Result.alts]]
[Lean.Elab.Command.MkInstanceName.M,[StateRefT', IO.RealWorld, String, Lean.Elab.Command.CommandElabM]]
[Lean.Syntax.getSubstring?,[Lean.SourceInfo.original, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Option, Substring, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo, Option.some, Substring.mk, Substring.str, ite, Eq, Bool.true, Substring.startPos, Substring.stopPos, Option.none]]
[Lean.IR.Borrow.ParamMap.instHashableKey,[Hashable.mk, Lean.IR.Borrow.ParamMap.getHash]]
[Lean.AttributeApplicationTime.afterTypeChecking.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.IR.compile,[Prod, Lean.IR.Log, Except, String, Lean.Environment, EStateM.run, Bind.bind, Lean.IR.logDecls, Lean.Name.mkStr, Lean.Name.anonymous, Lean.IR.checkDecls, Lean.IR.elimDeadBranches, MonadReader.read, ite, Eq, Lean.Option.get, Lean.IR.compiler.reuse, Bool.true, Pure.pure, PUnit.unit, Lean.IR.CompilerState.mk, Prod.mk, Lean.IR.CompilerState.log, Except.ok, Lean.IR.CompilerState.env, Except.error]]
[StateRefT'.run',[Bind.bind, StateRefT'.run, Pure.pure]]
[Lean.Expr.const.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.checkInsideQuotFn,[ite, Eq, and, Decidable.decide, GT.gt, Lean.Parser.ParserContext.quotDepth, OfNat.ofNat, not, Lean.Parser.ParserContext.suppressInsideQuot, Bool.true, Lean.Parser.ParserState.mkUnexpectedError, List.nil]]
[Lean.Elab.Frontend.getParserState,[Bind.bind, MonadState.get, Pure.pure, Lean.Elab.Frontend.State.parserState]]
[Lean.Meta.Match.instInhabitedProblem,[Inhabited.mk, Lean.Meta.Match.Problem.mk, arbitrary]]
[Lean.withHeadRefOnly,[Bind.bind, Lean.MonadRef.getRef, Unit.unit, Lean.Syntax.getHead?, Lean.withRef]]
[Lean.PrettyPrinter.Formatter.setStack,[modify, Lean.PrettyPrinter.Formatter.State.mk, Lean.PrettyPrinter.Formatter.State.stxTrav, Lean.PrettyPrinter.Formatter.State.leadWord]]
[Lean.Parser.Command.universe.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.ident.parenthesizer]]
[Lean.Lsp.ClientInfo.version?,[]]
[instSemiringFin.proof_5,[Fin.eq_of_val_eq, Eq.mpr, congrFun, congrArg, Eq, Eq.trans, Fin.val, Fin.mul_def, OfNat.ofNat, HMod.hMod, HMul.hMul, Fin.one_def, False.elim, Fin.elim0, Eq.symm, Nat.succ, Nat.lt_or_eq_of_le, Nat.mod_le, of_eq_true, Nat.mul_one, Nat.mod_eq_of_lt, Fin.isLt, eq_self, Eq.refl]]
[Lean.Elab.Term.Quotation.getAntiquotationIds,[Bind.bind, ForIn.forIn, ite, Eq, and, or, Lean.Syntax.isAntiquot, Lean.Syntax.isTokenAntiquot, not, Lean.Syntax.isEscapedAntiquot, Bool.true, Lean.Syntax.isIdent, Pure.pure, PUnit.unit, ForInStep.yield, Lean.throwErrorAt, Lean.ToMessageData.toMessageData]]
[Lean.Lsp.ReferenceParams.toTextDocumentPositionParams,[]]
[Lean.Syntax.mkStrLit,[Lean.Syntax.mkLit, Lean.strLitKind, String.quote]]
[Lean.IR.NormalizeIds.normIndex,[Unit.unit, Id, Lean.IR.Index, Std.RBMap.find?]]
[Monoid.HPow,[HPow.mk, Monoid.npow]]
[Lean.Elab.Info.ofFieldInfo.inj,[]]
[instDecidableEqSum.proof_1,[rfl]]
[Lean.Compiler.foldBinOp,[OptionM.run, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, OptionM, Lean.Expr, Bind.bind, Lean.Compiler.findBinFoldFn, Alternative.failure]]
[List.disjoint,[False]]
[Lean.Server.Watchdog.WorkerEvent.ioError.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Function.has_right_inverse,[Exists, Function.right_inverse]]
[EStateM.instMonadFinallyEStateM,[MonadFinally.mk, EStateM.Result, Prod, Option.some, EStateM.Result.ok, Prod.mk, EStateM.Result.error, Option.none]]
[UInt16.ofNatCore,[UInt16.mk, Fin.mk]]
[Nat.lt_add_right,[lt_of_lt_of_le, Nat.le_add_right]]
[Lean.KernelException.invalidProj.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.isClass,[Lean.SMap.contains, Lean.ClassState.hasOutParam, Lean.SimplePersistentEnvExtension.getState, Lean.classExtension]]
[IO.eprint,[Bind.bind, liftM, IO.getStderr, IO.FS.Stream.putStr, ToString.toString]]
[Lean.Meta.mkSizeOfSpecLemmaInstance,[Lean.matchConstCtor, Lean.Expr.getAppFn, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Bind.bind, Lean.getConstInfo, Lean.Meta.forallTelescopeReducing, Lean.ConstantInfo.type, Pure.pure, Array.size, Lean.Meta.mkAppOptM]]
[Lean.PrettyPrinter.Parenthesizer.checkWsBefore.parenthesizer,[Pure.pure, Unit.unit]]
[Lean.Syntax.modifyArg,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.node, Array.modify]]
[Lean.Meta.withReducible,[Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.reducible]]
[Lean.MetavarContext.getExprAssignmentDomain,[Std.PersistentHashMap.foldl, Lean.MetavarContext.eAssignment, Array.push, List.toArray, List.nil]]
[Char.utf8Size.proof_1,[of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Expr.forallE.inj,[And.intro]]
[IO.FS.writeBinFile,[Bind.bind, IO.FS.Handle.mk, IO.FS.Mode.write, Bool.true, IO.FS.Handle.write]]
[Lean.Compiler.hasSpecializeAttribute,[Lean.Compiler.SpecializeAttributeKind.specialize]]
[Lean.Elab.getRefPos,[Bind.bind, Lean.Elab.MonadLog.getRef, Pure.pure, Option.getD, Lean.Syntax.getPos?, Bool.false, OfNat.ofNat]]
[Lean.IR.Expr.fap.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.fap, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.InstanceEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.structExplicitBinder,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.Command.declModifiers, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.ident, Lean.Parser.optional, Lean.Parser.Command.inferMod, Lean.Parser.Command.optDeclSig, HOrElse.hOrElse, Lean.Parser.Term.binderTactic, Lean.Parser.Term.binderDefault]]
[IO.FS.DirEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.instToExprDeclarationRanges,[Lean.ToExpr.mk, Lean.mkAppN, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, List.toArray, List.cons, Lean.ToExpr.toExpr, Lean.DeclarationRanges.range, Lean.DeclarationRanges.selectionRange]]
[Lean.InductiveVal.all,[]]
[Lean.Elab.Term.tryPostponeIfHasMVars,[Bind.bind, Lean.Elab.Term.tryPostponeIfNoneOrMVar, Pure.pure, Option.none, Lean.Elab.Term.TermElabM, Lean.Expr, liftM, Lean.Meta.instantiateMVars, ite, Eq, Lean.Expr.hasExprMVar, Bool.true, Lean.Elab.Term.tryPostpone, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, PUnit.unit]]
[Lean.Elab.Term.StructInst.Field.val,[]]
[Lean.checkCache,[Bind.bind, Lean.MonadCache.findCached?, Unit.unit, Pure.pure, Lean.MonadCache.cache]]
[Lean.Meta.CongrLemma.funName,[]]
[ST.Prim.Ref.modifyGetUnsafe,[Bind.bind, ST.Prim.Ref.take, ST, ST.Prim.Ref.set, Pure.pure]]
[Lean.Parser.mkNodeToken,[Lean.Parser.ParserState.pushSyntax, Lean.Syntax.mkLit]]
[Bool.or_true,[rfl, Eq.symm, Eq.refl]]
[Lean.Elab.Command.InductiveView.modifiers,[]]
[Int.negSucc.injEq,[Eq.propIntro, Eq.refl, Int.negSucc, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.CollectUsedDecls.collectInitDecl,[Bind.bind, MonadReader.read, Option.none, Lean.IR.CollectUsedDecls.M, Unit, Lean.getInitFnNameFor?, Lean.IR.CollectUsedDecls.collect, Pure.pure, Unit.unit]]
[IO.Error.mkEofError,[IO.Error.unexpectedEof]]
[Lean.JsonRpc.Notification.method,[]]
[lt_iff_not_ge,[Iff.intro, not_le_of_gt, lt_of_not_ge]]
[Lean.Meta.instInhabitedCaseArraySizesSubgoal,[Inhabited.mk, Lean.Meta.CaseArraySizesSubgoal.mk, arbitrary]]
[Lean.Meta.Instances.noConfusionType,[]]
[Lean.Expr.ReplaceImpl.ReplaceM,[StateM, Lean.Expr.ReplaceImpl.State]]
[Lean.Meta.addGlobalInstance,[Lean.ScopedEnvExtension.add, Lean.Meta.globalInstanceExtension]]
[Lean.Macro.addMacroScope,[Bind.bind, MonadReader.read, Pure.pure, Lean.addMacroScope, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope]]
[Lean.IR.CollectUsedDecls.M,[ReaderT, Lean.Environment, StateM, Lean.NameSet]]
[System.FilePath.fileStem,[Option.map, Unit.unit, dite, Eq, Eq.symm, String, String.revPosOf, Char.ofNat, String.extract, OfNat.ofNat, System.FilePath.fileName]]
[Function.left_inverse,[Eq]]
[Function.bijective_id,[And.intro, Function.injective_id, Function.surjective_id]]
[FloatArray.get?,[dite, LT.lt, FloatArray.size, Option.some, FloatArray.get, Fin.mk, Option.none]]
[List.replicate.loop,[List, PProd.fst, List.cons]]
[Lean.Compiler.foldToNat,[OptionM.run, Bind.bind, Lean.Compiler.getNumLit, Pure.pure, Lean.mkRawNatLit]]
[Lean.Parser.Tactic.tacticRepeat_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Std.Range.instForInRangeNat,[ForIn.mk, Std.Range.forIn]]
[Lean.Widget.MsgEmbed.lazyTrace.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Widget.MsgEmbed.lazyTrace, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Tactic.Conv.evalFirst,[Lean.Elab.Tactic.evalFirst]]
[Lean.Parser.Term.macroArg.formatter,[Lean.Parser.termParser.formatter, Lean.Parser.maxPrec]]
[Lean.Elab.Term.Do.instInhabitedAlt,[Inhabited.mk, Lean.Elab.Term.Do.Alt.mk, arbitrary]]
[or_self_left,[Iff.intro, Or.elim, Or.inl, id, Function.comp, Or.inr]]
[Lean.Name.isInaccessibleUserName,[Lean.Name.anonymous, Bool, or, String.contains, Char.ofNat, BEq.beq, PProd.fst, Bool.false]]
[Lean.BinderInfo.brackets,[Lean.BinderInfo.default, Unit.unit, Lean.BinderInfo.auxDecl, Prod, String, Prod.mk]]
[Lean.Server.Watchdog.GroupedEdits.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MonadTrace.getTraceState,[]]
[Lean.Parser.Attr.simple.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.priorityParser.formatter]]
[Inv.inv,[]]
[toLOptionM,[Bind.bind, Pure.pure, Option.toLOption]]
[EStateM.instToStringResult,[ToString.mk, String, HAppend.hAppend, ToString.toString]]
[Lean.IR.JoinPointId.noConfusionType,[]]
[Std.HashSetImp.contains,[Bool, List.contains, Array.uget, Subtype.val]]
[Lean.Elab.RecKind.toCtorIdx,[OfNat.ofNat]]
[Lean.LeanPaths.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.LeanPaths.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Name.appendAfter,[Lean.Name.modifyBase, Lean.Name.anonymous, Lean.Name.num, Lean.Name, Lean.Name.mkStr, HAppend.hAppend]]
[Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.discrs,[]]
[List.erase_subset,[Eq.mpr, Eq.refl, Subset.subset, List.erase, List.erase_eq_erasep, List.erasep_subset]]
[Lean.IR.HasIndex.visitParams,[Array.any, BEq.beq, Lean.IR.VarId.idx, Lean.IR.Param.x, OfNat.ofNat, Array.size]]
[Lean.Level.zero.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Syntax.Traverser.right,[ite, GT.gt, Array.size, Lean.Syntax.Traverser.parents, OfNat.ofNat, Lean.Syntax.Traverser.down, Lean.Syntax.Traverser.up, HAdd.hAdd, Array.back, Lean.Syntax.Traverser.idxs]]
[Lean.Meta.CasesSubgoal.ctorName,[]]
[Lean.Meta.Match.Extension.State.addEntry,[Lean.Meta.Match.Extension.State.mk, Lean.SMap.insert, Lean.Meta.Match.Extension.State.map, Lean.Meta.Match.Extension.Entry.name, Lean.Meta.Match.Extension.Entry.info]]
[Lean.MonadBacktrack.noConfusionType,[]]
[«term_≃_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.ParametricAttributeImpl.getParam,[]]
[Lean.Lsp.MarkupKind.toCtorIdx,[OfNat.ofNat]]
[Lean.Meta.SimpLemma.priority,[]]
[Lean.IR.EmitC.Context.noConfusionType,[]]
[Lean.Server.RpcEncoding.rpcEncode,[]]
[Lean.Elab.Term.StructInst.instInhabitedField,[Inhabited.mk, Lean.Elab.Term.StructInst.Field.mk, arbitrary]]
[AddSemigroup.noConfusionType,[]]
[Lean.JsonRpc.ResponseError.data?,[]]
[Lean.Lsp.SymbolKind.enumMember.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.PrettyPrinter.Parenthesizer.checkLinebreakBefore.parenthesizer,[Pure.pure, Unit.unit]]
[HMod.noConfusionType,[]]
[UInt32.instSemiringUInt32,[Semiring.mk, UInt32.instSemiringUInt32.proof_1, UInt32.instSemiringUInt32.proof_2, UInt32.mk, Semiring.nsmul, UInt32.val, UInt32.instSemiringUInt32.proof_3, UInt32.instSemiringUInt32.proof_4, UInt32.instSemiringUInt32.proof_5, UInt32.instSemiringUInt32.proof_6, UInt32.instSemiringUInt32.proof_7, UInt32.instSemiringUInt32.proof_8, UInt32.instSemiringUInt32.proof_9, UInt32.instSemiringUInt32.proof_10, UInt32.instSemiringUInt32.proof_11, UInt32.instSemiringUInt32.proof_12, UInt32.instSemiringUInt32.proof_13]]
[String.noConfusionType,[]]
[Lean.IR.FunId,[Lean.Name]]
[Lean.Lsp.CompletionItem.documentation?,[]]
[Equivalence.symm,[]]
[Lean.Elab.Term.elabWaitIfTypeMVar,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, liftM, Lean.MonadMCtx.getMCtx, Unit.unit, Lean.Meta.MetaM, Lean.Expr, Lean.MetavarContext.findUserName?, Lean.Syntax.getId, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Meta.instantiateMVars, Lean.mkMVar, Lean.Meta.inferType, Lean.Elab.Term.tryPostponeIfMVar, Lean.Elab.Term.elabTerm, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Meta.Cases.Context.inductiveVal,[]]
[Lean.Meta.getMVarType',[Bind.bind, Lean.Meta.getMVarDecl, Lean.Meta.instantiateMVars, Lean.MetavarDecl.type, Lean.Meta.whnf]]
[Lean.PrettyPrinter.Parenthesizer.ite,[ite]]
[IO.FS.instReprDirEntry,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, IO.FS.DirEntry.root, Std.Format.line, IO.FS.DirEntry.fileName]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withNaryArg,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.PrettyPrinter.Delaborator.SubExpr.getPos, withTheReader, Lean.PrettyPrinter.Delaborator.SubExpr, Lean.PrettyPrinter.Delaborator.SubExpr.mk, Array.getOp]]
[Lean.Parser.AliasValue.binary.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.mkOpaqueValEx,[Lean.OpaqueVal.mk, Lean.ConstantVal.mk]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.collectBottomUps,[Bind.bind, MonadReader.read, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit, ForIn.forIn, PUnit.unit, ite, Eq, BEq.beq, Array.getOp, Lean.BinderInfo.default, Bool.true, andM, liftM, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.hasMVarAtCurrDepth, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.canBottomUp, OfNat.ofNat, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.tryUnify, modify, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.mk, Array.set!, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.bottomUps, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.higherOrders, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.funBinders, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.provideds, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.namedArgs, Pure.pure, ForInStep.yield]]
[Lean.resolveNamespace,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadResolveName.getCurrNamespace, Lean.MonadResolveName.getOpenDecls, Unit.unit, Lean.Name, Lean.ResolveName.resolveNamespace?, Pure.pure, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, HAppend.hAppend, ToString.toString]]
[Lean.Lsp.instToJsonInitializedParams,[Lean.ToJson.mk, Lean.Json.null]]
[Lean.Elab.Term.elabLetFunDecl,[Lean.Elab.Term.elabLetDeclCore, Bool.false]]
[Lean.ConstantInfo.type,[Lean.ConstantVal.type, Lean.ConstantInfo.toConstantVal]]
[Lean.MessageData.isNest,[Lean.MessageData.ofFormat, Lean.MessageData.ofSyntax, Lean.MessageData.ofExpr, Lean.MessageData.ofLevel, Lean.MessageData.ofName, Lean.MessageData.ofGoal, Lean.MessageData.withContext, Lean.MessageData.withNamingContext, Lean.MessageData.group, Lean.MessageData.compose, Lean.MessageData.tagged, Lean.MessageData.node, Bool, Bool.true, Bool.false]]
[Lean.PrettyPrinter.Formatter.andthen.formatter,[SeqRight.seqRight]]
[Lean.Elab.ExpandDeclIdResult.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.ExpandDeclIdResult.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.DefView.mk.inj,[And.intro]]
[IO.AsyncList.finishedPrefix,[Function.comp, List.reverse, List.nil]]
[PSum.inr.injEq,[Eq.propIntro, Eq.refl, PSum.inr, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.DefView.declId,[]]
[Lean.Elab.Command.liftIO,[Bind.bind, MonadReader.read, liftM, IO.toEIO, Lean.Exception.error, Lean.Elab.Command.Context.ref, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, IO.Error.toString]]
[Lean.KeyedDeclsAttribute.OLeanEntry.key,[]]
[UInt8.instInhabitedFinSize,[Inhabited.mk, Fin.ofNat', OfNat.ofNat, UInt8.size_positive]]
[Lean.LocalContext.erase,[Lean.LocalContext, Unit.unit, Std.PersistentHashMap.find?, Lean.LocalContext.mk, Std.PersistentHashMap.erase, Std.PersistentArray.set, Lean.LocalDecl.index, Option.none]]
[Lean.Meta.getInductiveUniverseAndParams,[Bind.bind, Lean.Meta.whnfD, Lean.matchConstInduct, Lean.Expr.getAppFn, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Pure.pure, Prod.mk]]
[Lean.EnvExtensionInterface.setState,[]]
[Lean.Meta.Match.Pattern.below,[PUnit, PProd]]
[Lean.PrettyPrinter.Formatter.pushNone.formatter,[Lean.Syntax.MonadTraverser.goLeft]]
[Lean.PPFns.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.PPFns.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Command.instBEqStructFieldKind,[BEq.mk, BEq.beq, Lean.Elab.Command.StructFieldKind.toCtorIdx]]
[Nat.min_eq_right,[Eq.mpr, Eq.refl, Eq, Nat.min, Nat.min_comm, Nat.min_eq_left]]
[Lean.Server.RpcEncoding.DerivingParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Server.RpcEncoding.DerivingParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.StructInst.FieldLHS.noConfusionType,[]]
[Lean.Parser.Command.terminationHint.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Command.terminationHintMany.parenthesizer, Lean.Parser.Command.terminationHint1.parenthesizer]]
[Lean.Compiler.SpecState.cache,[]]
[Lean.Meta.sortLocalDecls,[StateRefT'.run', ReaderT.run, Lean.Meta.SortLocalDecls.Context.mk, Array.foldl, Lean.NameMap.insert, Lean.FVarId.name, Lean.LocalDecl.fvarId, EmptyCollection.emptyCollection, OfNat.ofNat, Array.size, Lean.Meta.SortLocalDecls.State.mk]]
[List.concat,[List, List.cons, List.nil, PProd.fst]]
[Lean.Parser.Term.instBinder.parenthesizer,[Lean.Parser.ppGroup.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.optIdent.parenthesizer, Lean.Parser.termParser.parenthesizer]]
[Lean.Parser.Command.eval,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser]]
[Lean.Elab.Term.withAutoBoundImplicit,[Bind.bind, Lean.MonadOptions.getOptions, ite, Eq, Bool.true, MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.Context.declName?, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.currMacroScope, Lean.Elab.Term.Context.mayPostpone, Lean.Elab.Term.Context.errToSorry, Std.PersistentArray.mk, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection, Lean.MonadBacktrack.saveState, Lean.Elab.Term.withAutoBoundImplicit.loop]]
[Lean.Meta.Simp.Methods.discharge?,[]]
[Lean.Elab.Command.InductiveView.ctors,[]]
[Lean.Parser.Term.doCatchMatch.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.doMatchAlts.formatter]]
[Lean.PrettyPrinter.Parenthesizer.State.noConfusionType,[]]
[Lean.instLTLiteral,[LT.mk, Eq, Lean.Literal.lt, Bool.true]]
[Lean.Elab.Command.expandMacroArg,[Bind.bind, Lean.expandMacros, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Pure.pure, Prod.mk, Option.some, Lean.Macro.throwUnsupported, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, List.nil, Option.none, Lean.Elab.Command.expandMacroArg.mkSplicePat]]
[String.decLt,[List.hasDecidableLt, String.data]]
[Lean.Parser.Command.partial,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Lean.Server.FileWorker.EditableDocument.cmdSnaps,[]]
[Array.toPArray,[Array.toPersistentArray]]
[Lean.Rat.instOfNatRat,[OfNat.mk, Int.ofNat]]
[Lean.termM!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[Lean.Parser.Level.hole,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Nat.le_total,[Or, LE.le, Nat.lt_or_ge, Or.inl, Nat.le_of_lt, Or.inr]]
[Lean.IR.Decl.fdecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.FnBody.del.inj,[And.intro]]
[Lean.Parser.many1Indent,[Lean.Parser.withPosition, Lean.Parser.many1, HAndThen.hAndThen, Lean.Parser.checkColGe]]
[EIO.toIO,[EStateM.adaptExcept]]
[Lean.Lsp.InitializeParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.InitializeParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.WF.TerminationStrategy.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.WF.TerminationStrategy.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.ParserModuleContext.noConfusionType,[]]
[Lean.Elab.Tactic.ElimApp.State.alts,[]]
[Lean.Meta.deltaTarget,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarType, liftM, Lean.Meta.deltaExpand, Lean.Meta.change, Bool.false]]
[Lean.CollectFVars.Visitor,[Lean.CollectFVars.State]]
[Lean.Elab.Command.InductiveView.levelNames,[]]
[Classical.«tacticByCases__:_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.IR.Expr.isTaggedPtr.inj,[]]
[Lean.Parser.instCoeArrowParserArrowParserParserParserAliasValue,[Coe.mk, Lean.Parser.AliasValue.binary]]
[Eq.symm,[rfl]]
[Lean.Declaration.mutualDefnDecl.inj,[]]
[IO.Error.mkNoSuchThing,[IO.Error.noSuchThing, Option.none]]
[List.get,[absurd, Nat.not_lt_zero]]
[Lean.Parser.withOpen,[Lean.Parser.Parser.mk, Lean.Parser.Parser.info, Lean.Parser.withOpenFn, Lean.Parser.Parser.fn]]
[Lean.Parser.nameLit.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.nameLitKind, Bool.true, Lean.PrettyPrinter.Formatter.nameLitNoAntiquot.formatter]]
[Quot.recOnSubsingleton,[Quot.rec, Quot.recOnSubsingleton.proof_1]]
[Lean.Meta.instMonadBacktrackSavedStateMetaM,[Lean.MonadBacktrack.mk, Lean.Meta.saveState, Lean.Meta.SavedState.restore]]
[instInhabitedReaderT,[Inhabited.mk, arbitrary]]
[List.toArray,[List.toArrayAux, Array.mkEmpty, List.redLength]]
[Std.HashSetImp.size,[]]
[Lean.Parser.ParserContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.defReplacer,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser]]
[and_iff_left_of_imp,[Iff.intro, And.left, And.intro]]
[Lean.Elab.Tactic.evalExact,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.Tactic.closeMainGoalUsing, Bind.bind, Lean.MonadMCtx.getMCtx, Lean.Elab.Tactic.elabTermEnsuringType, Option.some, Bool.false, liftM, Lean.Meta.getMVars, Lean.Elab.Tactic.filterOldMVars, Lean.Elab.Tactic.logUnassignedAndAbort, Pure.pure, Lean.Elab.throwUnsupportedSyntax]]
[Lean.Elab.Term.isTypeApp?,[Bind.bind, Lean.Meta.withReducible, liftM, Lean.Meta.whnf, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Elab.Term.TermElabM, Option, Prod, Lean.Expr, Lean.Meta.instantiateMVars, Pure.pure, Option.some, Prod.mk, Option.none]]
[Lean.Parsec.pstring,[ite, Eq, Lean.Parsec.ParseResult.success, String.Iterator.forward, String.length, Lean.Parsec.ParseResult.error, HAppend.hAppend, ToString.toString]]
[Int.instDivInt,[Div.mk, Int.div]]
[Lean.Meta.PostponedEntry.ctx?,[]]
[USize.toUInt32,[Nat.toUInt32, USize.toNat]]
[Lean.DataValue.ofNat.injEq,[Eq.propIntro, Eq.refl, Lean.DataValue.ofNat, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.TrailingParserDescr,[Lean.ParserDescr]]
[Lean.ScopedEnvExtension.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Syntax.isToken,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Bool, BEq.beq, String.trim, Bool.false]]
[Lean.MessageData.group.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.annotateBoolAt,[Bind.bind, MonadState.get, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.Elab.Info.ofTacticInfo.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Info.ofTacticInfo, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.addDecl,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.Environment.addDecl, Lean.setEnv, Lean.throwKernelException]]
[Lean.DefinitionVal.value,[]]
[Lean.Meta.withLocalDecls,[List.toArray, List.nil, Lean.Meta.withLocalDecls.loop]]
[Lean.Parser.Command.unsafe.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Nat.eq_one_of_dvd_one,[Nat.le_antisymm, Nat.le_of_dvd, of_decide_eq_true, rfl, Nat.pos_of_dvd_of_pos]]
[Lean.Name.capitalize,[Lean.Name.anonymous, Lean.Name.num, Lean.Name, Lean.Name.mkStr, String.capitalize]]
[Lean.JsonRpc.instFromJsonMessage,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjVal?, Lean.Json.null, Lean.Json.bool, Lean.Json.num, dite, Eq, Unit.unit, Eq.symm, Lean.Json.str, Lean.Json.arr, Lean.Json.obj, Except, String, Lean.JsonRpc.Message, HOrElse.hOrElse, Lean.Json.getObjValAs?, Lean.JsonRpc.RequestID, Pure.pure, Lean.JsonRpc.Message.request, Except.toOption, Lean.JsonRpc.Message.notification, Lean.JsonRpc.Message.response, Lean.JsonRpc.ErrorCode, Lean.JsonRpc.Message.responseError, MonadExcept.throw]]
[Lean.ScopedEnvExtension.instInhabitedStateStack,[Inhabited.mk, Lean.ScopedEnvExtension.StateStack.mk, arbitrary]]
[Lean.Parser.Tactic.Conv.ext,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[SubNegMonoid.sub_eq_add_neg,[]]
[Lean.Widget.msgToInteractive,[Bind.bind, Lean.NamingContext.mk, Lean.Name.anonymous, List.nil, Option.none, List.toArray, MonadState.modifyGet, Prod.mk, Array.size, Array.push, Pure.pure, Std.Format.tag, IO, Lean.Widget.TaggedText, Lean.Widget.MsgEmbed, Lean.Widget.TaggedText.rewriteM, Unit.unit, Array.get!, Lean.Widget.TaggedText.tag, Lean.Widget.MsgEmbed.expr, Lean.Widget.TaggedText.text, Lean.Widget.TaggedText.stripTags, panicWithPosWithDecl, OfNat.ofNat, Lean.Widget.MsgEmbed.lazyTrace, Lean.Server.WithRpcRef.mk]]
[Lean.SCC.State.stack,[]]
[Nat.add_mul_div_right,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HAdd.hAdd, HMul.hMul, Nat.mul_comm, Nat.add_mul_div_left, rfl]]
[Lean.Elab.Term.elabMutualDef,[ite, Eq, Array.any, Lean.Elab.DefKind.isExample, Lean.Elab.DefView.kind, OfNat.ofNat, Array.size, Bool.true, Lean.withoutModifyingEnv, Lean.Elab.Term.elabMutualDef.go, Lean.Elab.Term.elabMutualDef.processDeriving]]
[UInt8.instAddSemigroupUInt8,[AddSemigroup.mk, UInt8.instAddSemigroupUInt8.proof_1]]
[instSTWorldEST,[STWorld.mk]]
[Std.RBNode.findCore,[Option, Sigma, Option.none, Unit.unit, PProd.fst, PProd.snd, Option.some, Sigma.mk]]
[Std.ShareCommon.State,[PointedType.type, Std.ShareCommon.StatePointed]]
[Nat.mod.proof_1,[WellFoundedRelation.wf, measure, id]]
[Lean.Lsp.WaitForDiagnostics.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.Term.generalizingParam,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.symbol, Lean.Parser.nonReservedSymbol, Bool.false, HOrElse.hOrElse, Lean.Parser.Term.trueVal, Lean.Parser.Term.falseVal]]
[Lean.Parser.Tactic.noncommRing,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Parser.Term.unreachable,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, Lean.Parser.symbol]]
[Std.Format.getIndent,[Lean.KVMap.get, Lean.Name.mkStr, Lean.Name.anonymous, Std.Format.defIndent]]
[Lean.KeyedDeclsAttribute.Def.builtinName,[]]
[Lean.instToExprList,[Lean.ToExpr.mk, Lean.List.toExprAux, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.levelZero, List.nil]]
[Lean.Parser.Term.whereDecls,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1Indent, Lean.Parser.group, Lean.Parser.Term.letRecDecl, Lean.Parser.optional]]
[Lean.Widget.InfoPopup.mk.inj,[And.intro]]
[String.Range.contains,[and, Decidable.decide, LE.le, String.Range.start, LT.lt, String.Range.stop]]
[Lean.Elab.Term.MatchAltView.noConfusionType,[]]
[Lean.FileMap.noConfusionType,[]]
[Lean.Meta.RecursorInfo.paramsPos,[]]
[Lean.Meta.contradictionCore,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.MonadLCtx.getLCtx, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, Unit.unit, Lean.Meta.MetaM, Bool, MProd.fst, Pure.pure]]
[Lean.DataValue.ofInt.inj,[]]
[Lean.Elab.CompletionInfo.namespaceId.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.CompletionInfo.namespaceId, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Term.argument,[HAndThen.hAndThen, Lean.Parser.checkWsBefore, Lean.Parser.checkColGt, HOrElse.hOrElse, Lean.Parser.Term.namedArgument, Lean.Parser.Term.ellipsis, Lean.Parser.termParser, Lean.Parser.argPrec]]
[Lean.instAddMessageContext,[Lean.AddMessageContext.mk, liftM, Lean.AddMessageContext.addMessageContext]]
[Lean.Parser.Tactic.ringExpEq,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[IO.Error.unexpectedEof.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.MetavarContext.LevelMVarToParam.State.paramNames,[]]
[Lean.Meta.NormNum.instLawfulOfNat_1.proof_1,[Lean.Meta.NormNum.LawfulOfNat.mk, rfl]]
[Lean.Elab.Frontend.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.syntheticHole.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.Term.hole.formatter]]
[Nat.foldRevM,[Nat.foldRevM.loop]]
[Lean.Elab.Term.mkExplicitBinder,[Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkAtom, Lean.mkNullNode, List.nil]]
[Lean.Parser.Tactic.guardHypNums,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Lean.Expr.hasMVar,[or, Lean.Expr.Data.hasExprMVar, Lean.Expr.Data.hasLevelMVar]]
[Lean.Parser.Term.pipeCompletion.formatter,[Lean.PrettyPrinter.Formatter.trailingNode.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.minPrec, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.Meta.Closure.State.noConfusionType,[]]
[Lean.Xml.Parser.CDEnd,[Lean.Parsec.skipString]]
[Lean.Meta.SynthInstance.Context.noConfusionType,[]]
[Lean.Parser.instOrElseParser,[OrElse.mk, Lean.Parser.orelse, Unit.unit]]
[Lean.Elab.mkMessageCore,[Lean.Message.mk]]
[SubNegMonoid.toNeg,[]]
[Std.mkRBTree,[Std.mkRBMap, Unit]]
[List.eraseIdx,[List, List.nil, List.cons, PProd.fst]]
[Lean.Option.Decl.group,[]]
[Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp.proof_1,[Nat.le_trans]]
[IO.println,[IO.print, String.push, ToString.toString, Char.ofNat]]
[Lean.Elab.Command.Context.fileName,[]]
[Int.ofNat.injEq,[Eq.propIntro, Eq.refl, Int.ofNat, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.instBEqFnBody,[BEq.mk, Lean.IR.FnBody.beq]]
[Lean.Meta.MVarRenaming.map,[]]
[Lean.Parser.Term.prop.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.IR.UnreachableBranches.Value.ctor.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.UnreachableBranches.Value.ctor, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.JsonRpc.instCoeResponseMessage,[Coe.mk, Lean.JsonRpc.Message.response, Lean.JsonRpc.Response.id, Lean.ToJson.toJson, Lean.JsonRpc.Response.result]]
[UInt32.toNat,[Fin.val, UInt32.val]]
[Lean.ParserCompiler.registerParserCompiler,[Lean.Parser.registerParserAttributeHook, Lean.Parser.ParserAttributeHook.mk, Bind.bind, Lean.getConstInfo, ite, Eq, or, Lean.Expr.isConstOf, Lean.ConstantInfo.type, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, HOrElse.hOrElse, Lean.evalConstCheck, Lean.ParserDescr, Lean.TrailingParserDescr, Lean.Meta.MetaM.run', Lean.ParserCompiler.compileEmbeddedParsers, Lean.Meta.Context.mk, Lean.Meta.State.mk, Functor.discard, Lean.ParserCompiler.compileParserExpr, Lean.mkConst, List.nil]]
[Lean.Elab.Tactic.ElimApp.Context.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Tactic.ElimApp.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.PrettyPrinter.Formatter.withoutPosition.formatter,[]]
[Lean.IR.CtorFieldInfo.usize.inj,[]]
[Subtype.existsOfSubtype.proof_1,[Exists, Exists.intro]]
[Lean.Elab.Tactic.Simp.DischargeWrapper.noConfusionType,[]]
[Lean.Xml.Parser.elementDecl,[Bind.bind, Lean.Parsec.skipString, SeqRight.seqRight, Lean.Xml.Parser.S, Lean.Xml.Parser.Name, Lean.Xml.Parser.contentspec, optional, Lean.Parsec.skipChar, Char.ofNat]]
[Lean.Parser.Command.section.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.ident.formatter]]
[Lean.Parser.Tactic.inferOptParam,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[«term_∘_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[not_or,[Iff.intro, And.intro, mt, Or.inl, Or.inr, False, Or.elim]]
[Lean.PrefixTreeNode.WellFormed.brecOn,[Lean.PrefixTreeNode.WellFormed.below.emptyWff, Lean.PrefixTreeNode.WellFormed.below.insertWff]]
[Lean.Elab.Term.StructInst.Struct.structName,[Lean.Name]]
[Lean.Meta.Match.Example.below,[PUnit, PProd]]
[Lean.Parser.Tactic.withCases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser]]
[instHashableOption,[Hashable.mk, Unit.unit, UInt64, OfNat.ofNat, mixHash, Hashable.hash]]
[Lean.Elab.Term.reportUnsolvedGoals,[Lean.Meta.withPPInaccessibleNames, Bind.bind, Lean.Elab.logError, Lean.MessageData.tagged, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Elab.goalsToMessageData, List.forM, liftM, Lean.Elab.admitGoal, Bool.true]]
[Lean.Parser.Tactic.tacticSeq1Indented.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.many1Indent.formatter, Lean.Parser.group.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.ppLine.formatter, Lean.Parser.tacticParser.formatter, Lean.Parser.optional.formatter, Lean.Parser.symbol.formatter]]
[Lean.Elab.enableInfoTree,[Lean.Elab.MonadInfoTree.modifyInfoState, Lean.Elab.InfoState.mk, Lean.Elab.InfoState.assignment, Lean.Elab.InfoState.trees]]
[UInt32.size_positive,[of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Lsp.DocumentHighlight.noConfusionType,[]]
[Lean.Parser.Term.let_fun.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.letDecl.formatter, Lean.Parser.Term.optSemicolon.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Lean.PrettyPrinter.Delaborator.addFieldInfo.mkFieldInfo,[Bind.bind, Lean.MonadLCtx.getLCtx, Pure.pure, Lean.Elab.Info.ofFieldInfo, Lean.Elab.FieldInfo.mk]]
[Std.PersistentHashMap.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.PersistentHashMap.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.instInhabitedMetaM,[Inhabited.mk, arbitrary]]
[List.enum,[List.enumFrom, OfNat.ofNat]]
[Nat.eq_zero_of_add_eq_zero_left,[Nat.eq_zero_of_add_eq_zero_right, Nat.add_comm]]
[Lean.Level.getLevelOffset,[Lean.Level.zero, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Level, PProd.fst]]
[Option.lt,[Option.none, Option.some, True, False]]
[Lean.Elab.Deriving.FromToJson.mkJsonField,[Prod.mk, bne, Lean.Syntax.mkStrLit, Lean.SourceInfo.none]]
[Array.findRevM?,[Array.findSomeRevM?, Bind.bind, Pure.pure, ite, Eq, Bool.true, Option.some, Option.none]]
[Lean.Expr.appArg!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Parser.leadingParser,[Lean.Parser.withAntiquotFn, Lean.Parser.leadingParserAux]]
[Lean.Parser.Term.paren.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.ppDedent.formatter, Lean.PrettyPrinter.Formatter.withoutPosition.formatter, Lean.PrettyPrinter.Formatter.withoutForbidden.formatter, Lean.Parser.optional.formatter, Lean.Parser.termParser.formatter, Lean.Parser.Term.parenSpecial.formatter]]
[Lean.Meta.SynthInstance.newSubgoal,[Lean.Meta.withMCtx, Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, Lean.MessageData.ofExpr, Pure.pure, PUnit.unit]]
[Lean.Parser.Term.letIdDeclNoBinders.formatter,[Lean.PrettyPrinter.Formatter.node.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Term.ident.formatter, Lean.PrettyPrinter.Formatter.pushNone.formatter, Lean.Parser.Term.optType.formatter, Lean.Parser.symbol.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Nat.succ_le_of_lt,[]]
[Lean.Parser.Command.declModifiers,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.docComment, Lean.Parser.Term.attributes, ite, Eq, Lean.Parser.skip, Lean.Parser.ppDedent, Lean.Parser.ppLine, Lean.Parser.Command.visibility, Lean.Parser.Command.noncomputable, Lean.Parser.Command.unsafe, HOrElse.hOrElse, Lean.Parser.Command.partial, Lean.Parser.Command.nonrec]]
[Lean.Meta.isEtaUnassignedMVar,[Option.none, Option.some, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.MetaM, Bool, Lean.Expr.etaExpanded?, Bind.bind, Lean.Meta.isReadOnlyOrSyntheticOpaqueExprMVar, ite, Eq, Bool.true, Pure.pure, Bool.false, Lean.Meta.isExprMVarAssigned]]
[Lean.Elab.Term.PatternVarDecl.localVar.inj,[]]
[Lean.IR.EmitC.M,[ReaderT, Lean.IR.EmitC.Context, EStateM, String]]
[Lean.Parser.Term.structInstLVal.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.fieldIdx.parenthesizer, Lean.Parser.Term.structInstArrayRef.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.symbol.parenthesizer]]
[Std.ShareCommonT.withShareCommon,[MonadState.modifyGet, Std.ShareCommon.State.shareCommon]]
[List.not_mem_nil,[not_false]]
[Lean.IR.elimDeadBranches,[Bind.bind, MonadState.get, Lean.IR.CompilerM, Array, Lean.IR.Decl, modify, Lean.IR.CompilerState.mk, Lean.IR.CompilerState.log, Pure.pure, Array.mapIdx, Lean.IR.UnreachableBranches.elimDead, Array.getOp, Fin.val]]
[Lean.instInhabitedTheoremVal,[Inhabited.mk, Lean.TheoremVal.mk, arbitrary]]
[Nat.dvd_add,[Exists.elim, Exists.intro, HAdd.hAdd, of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.left_distrib, eq_self, HMul.hMul]]
[Id.instLawfulMonadId.proof_1,[LawfulMonad.mk, rfl]]
[Lean.IR.HasIndex.visitExpr,[Bool, Lean.IR.HasIndex.visitArgs, Lean.IR.HasIndex.visitVar, or, Bool.false]]
[instRandomGenStdGen,[RandomGen.mk, stdRange, stdNext, stdSplit]]
[Lean.IR.Decl.normalizeIds,[StateT.run', Lean.IR.NormalizeIds.normDecl, EmptyCollection.emptyCollection, OfNat.ofNat]]
[Subtype.instInhabitedSubtype,[Inhabited.mk, Subtype.mk]]
[Lean.Meta.Simp.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.toArrayAux,[Array, PProd.fst, Array.push]]
[Lean.NameSet,[Std.RBTree, Lean.Name, Lean.Name.quickCmp]]
[List.ne_nil_of_length_eq_succ,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isHBinOp,[Id.run, ite, Eq, bne, Lean.Expr.getAppNumArgs, OfNat.ofNat, Bool.true, Pure.pure, Bool.false, Bind.bind, PUnit.unit]]
[pow_mul_comm,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HMul.hMul, HPow.hPow, Nat.zero_eq, pow_zero, one_mul, mul_one, eq_self, pow_succ', mul_assoc]]
[Lean.Parser.Term.matchAlt.formatter,[Lean.Parser.nodeWithAntiquot.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.ppIndent.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat, Bool.false, Lean.Parser.darrow.formatter, Lean.PrettyPrinter.Formatter.checkColGe.formatter]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context.parentIsApp,[]]
[Lean.Parser.chFn,[Lean.Parser.rawFn, Lean.Parser.satisfyFn, BEq.beq, HAppend.hAppend, ToString.toString]]
[Lean.mkCasesOn,[Bind.bind, Lean.MonadEnv.getEnv, Unit, Lean.MonadEnv.modifyEnv, Lean.throwKernelException, Lean.mkCasesOnImp]]
[Lean.Parser.syntaxParser.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous]]
[Subtype.forall',[Iff.symm, Subtype.forall]]
[Lean.isInductive,[Bind.bind, Lean.MonadEnv.getEnv, Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Bool, Lean.Environment.find?, Pure.pure, Bool.true, Bool.false]]
[Nat.mul_mod_mul_left,[dite, Eq, OfNat.ofNat, Eq.mpr, Eq.refl, HMod.hMod, HMul.hMul, Nat.mul_zero, Nat.mod_zero, rfl, Nat.zero_mul, Nat.strong_rec_on]]
[Lean.Meta.ParamInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.LetRecDeclView.declName,[]]
[Lean.Elab.InfoTree.context.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.SyntheticMVarKind.typeClass.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[IO.Process.Child.noConfusionType,[]]
[Lean.Elab.Command.Scope.levelNames,[]]
[Lean.Elab.Term.Do.ToCodeBlock.withFor,[MonadWithReader.withReader, Lean.Elab.Term.Do.ToCodeBlock.Context.mk, Lean.Elab.Term.Do.ToCodeBlock.Context.ref, Lean.Elab.Term.Do.ToCodeBlock.Context.m, Lean.Elab.Term.Do.ToCodeBlock.Context.mutableVars, Bool.true]]
[Lean.Parser.Term.termBeforeDo.formatter,[Lean.PrettyPrinter.Formatter.withForbidden.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Lean.StructureInfo.noConfusionType,[]]
[Lean.AttributeApplicationTime.afterCompilation.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Lsp.instHashablePosition,[Hashable.mk, UInt64, mixHash, OfNat.ofNat, Hashable.hash]]
[Lean.Meta.instBEqAbstractMVarsResult,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Parser.ParserContext.savedPos?,[]]
[xor_self,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, congr, Or, eq_false, and_not_self, eq_false_of_decide, Eq.refl, Bool.false, False, eq_true_of_decide, Bool.true]]
[Lean.Parser.ParserAliasValue,[Lean.Parser.AliasValue, Lean.Parser.Parser]]
[Lean.Elab.Term.expandApp,[Bind.bind, Lean.Elab.Term.expandArgs, Lean.Syntax.getArgs, Lean.Syntax.getOp, OfNat.ofNat, Bool.false, Lean.Elab.Term.TermElabM, Prod, Lean.Syntax, Array, Lean.Elab.Term.NamedArg, Lean.Elab.Term.Arg, Bool, Pure.pure, Prod.mk]]
[iff_def',[Iff.trans, iff_def, And.comm]]
[Lean.Parser.Tactic.symm,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Parser.Term.trailing_parser,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.optExprPrecedence, Lean.Parser.termParser, OfNat.ofNat]]
[List.isSuffix,[Exists, Eq, HAppend.hAppend]]
[Int.instCommRingInt.proof_7,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Int.negSucc, Int.ofNat, Neg.neg, Nat.succ, Int.negSucc_ofNat_ofNat, Int.negOfNat, Int.ofNat_mul_ofNat, rfl, Eq.symm, Int.mul_negSucc_ofNat_negSucc_ofNat, Int.ofNat_mul_negSucc_ofNat]]
[Fin.mul.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[bind_pure_unit,[Eq.mpr, Eq.refl, Eq, Bind.bind, Pure.pure, PUnit.unit, bind_pure, rfl]]
[Lean.instForInFVarIdSetFVarId,[inferInstanceAs, ForIn, Std.RBTree, Lean.FVarId, Lean.Name.quickCmp, Lean.FVarId.name]]
[Lean.MonadHashMapCacheAdapter.modifyCache,[]]
[Lean.Meta.Context.synthPendingDepth,[]]
[Lean.ParametricAttributeImpl.mk.inj,[And.intro]]
[Lean.Elab.Term.Quotation.HeadInfo.mk.inj,[And.intro]]
[instHModUInt16NatUInt16,[HMod.mk, UInt16.modn]]
[instMulUInt16,[Mul.mk, UInt16.mul]]
[Lean.Elab.Term.Arg.stx.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Attr.toAdditive!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const]]
[Lean.IR.FnBody.jmp.inj,[And.intro]]
[Nat.lt_wfRel,[WellFoundedRelation.mk, Nat.lt, Nat.lt_wfRel.proof_1]]
[implies_congr,[rfl]]
[Lean.Parser.AliasValue.const.inj,[]]
[Lean.Meta.mkAuxMVar,[Lean.Meta.mkFreshExprMVarAt, Lean.MetavarKind.natural, Lean.Name.anonymous]]
[Lean.Expr.sort.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Expr.sort, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.«termλ.»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol]]
[Nat.coprime,[Eq, Nat.gcd, OfNat.ofNat]]
[Lean.IR.Borrow.ownArgsIfParam,[Bind.bind, MonadReader.read, Array.forM, Lean.IR.Arg.irrelevant, Lean.IR.Borrow.M, PUnit, ite, Eq, Std.RBTree.contains, Lean.IR.Borrow.BorrowInfCtx.paramSet, Lean.IR.VarId.idx, Bool.true, Lean.IR.Borrow.ownVar, Pure.pure, PUnit.unit, Unit.unit, OfNat.ofNat, Array.size]]
[Lean.Parser.Term.have,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.withPosition, Lean.Parser.symbol, Lean.Parser.Term.haveDecl, Lean.Parser.Term.optSemicolon, Lean.Parser.termParser, OfNat.ofNat]]
[instInhabitedProp,[Inhabited.mk, True]]
[Fin.lor.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[USize.instSemiringUSize,[Semiring.mk, USize.instSemiringUSize.proof_1, USize.instSemiringUSize.proof_2, USize.mk, Semiring.nsmul, USize.val, USize.instSemiringUSize.proof_3, USize.instSemiringUSize.proof_4, USize.instSemiringUSize.proof_5, USize.instSemiringUSize.proof_6, USize.instSemiringUSize.proof_7, USize.instSemiringUSize.proof_8, USize.instSemiringUSize.proof_9, USize.instSemiringUSize.proof_10, USize.instSemiringUSize.proof_11, USize.instSemiringUSize.proof_12, USize.instSemiringUSize.proof_13]]
[Lean.IR.FnBody.jmp.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.MarkupKind.noConfusion,[noConfusionEnum, Lean.Lsp.MarkupKind.toCtorIdx]]
[StateT.run_modify,[rfl]]
[Quotient.hrecOn,[Quot.hrecOn]]
[Lean.instInhabitedPrefixTreeNode,[Inhabited.mk, Lean.PrefixTreeNode.Node, Option.none, Std.RBNode.leaf]]
[instMonadWithReaderOfReaderT,[MonadWithReaderOf.mk]]
[Lean.instInhabitedAttributeImpl,[Inhabited.mk, Lean.AttributeImpl.mk, arbitrary]]
[Lean.Meta.getMVarsAtDecl,[Bind.bind, StateRefT'.run, Lean.Meta.collectMVarsAtDecl, Lean.CollectMVars.State.mk, Lean.Meta.MetaM, Array, Lean.MVarId, Pure.pure, Lean.CollectMVars.State.result]]
[Nat.mod_le,[LE.le, HMod.hMod, Nat.lt_or_ge, Eq.mpr, Eq.refl, Nat.mod_eq_of_lt, Nat.le_refl, Nat.eq_zero_or_pos, OfNat.ofNat, Nat.mod_zero, Nat.le_trans, Nat.le_of_lt, Nat.mod_lt]]
[Lean.IR.UnreachableBranches.Value.truncate,[Lean.IR.UnreachableBranches.Value.truncateMaxDepth, Lean.IR.UnreachableBranches.Value.truncate.go]]
[Lean.IR.EmitC.emitCName,[Bind.bind, Lean.IR.EmitC.toCName, Lean.IR.EmitC.emit]]
[Lean.Parser.Command.structImplicitBinder.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Command.declModifiers.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.ident.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.inferMod.formatter, Lean.Parser.Command.declSig.formatter]]
[Lean.Parser.Tactic.guardTarget',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Int.negOfNat,[Unit.unit, Int, OfNat.ofNat, Int.negSucc]]
[instDecidableLe_1,[UInt8.decLe]]
[Lean.Elab.Term.StructInst.ExplicitSourceInfo.noConfusionType,[]]
[Lean.Elab.ContextInfo.mk.inj,[And.intro]]
[Lean.Parser.ParserState.popSyntax,[Lean.Parser.ParserState.mk, Array.pop, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.pos, Lean.Parser.ParserState.cache, Lean.Parser.ParserState.errorMsg]]
[Lean.IR.AlphaEqv.noConfusionType,[]]
[Lean.mkAttributeImplOfConstantUnsafe,[Unit.unit, Except, String, Lean.AttributeImpl, Lean.Environment.find?, MonadExcept.throw, HAppend.hAppend, ToString.toString, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Name.anonymous, Lean.Name.str, dite, Eq, Eq.symm, Lean.Name.num, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.ConstantInfo.type, Lean.Environment.evalConst]]
[Lean.Elab.Command.StructFieldInfo.inferMod,[]]
[Lean.ConstantInfo.quotInfo.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Int.distrib_right,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Int.mul_comm, HAdd.hAdd, Int.distrib_left, congr, HMul.hMul, eq_self]]
[Lean.Meta.Simp.simp.simpConst,[Bind.bind, liftM, Pure.pure, Lean.Meta.Simp.Result.mk]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.mk.inj,[And.intro]]
[Lean.KeyedDeclsAttribute.AttributeEntry.mk.inj,[And.intro]]
[Lean.Meta.Match.Alt.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Match.Alt.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.Checker.checkExpr,[Lean.IR.LitVal.num, Lean.IR.Checker.M, Unit, SeqRight.seqRight, Lean.IR.Checker.checkPartialApp, Lean.IR.Checker.checkObjType, Lean.IR.Checker.checkObjVar, Lean.IR.Checker.checkArgs, Lean.IR.Checker.checkFullApp, ite, GT.gt, Lean.IR.CtorInfo.size, Lean.IR.Checker.maxCtorFields, Bind.bind, MonadExcept.throw, HAppend.hAppend, ToString.toString, Lean.IR.CtorInfo.name, Pure.pure, PUnit.unit, Lean.IR.Checker.checkScalarVar, Lean.IR.Checker.checkVarType, BEq.beq, Lean.IR.Checker.checkScalarType, Lean.IR.Checker.getType, Lean.IR.IRType.float, Lean.IR.IRType.uint8, Lean.IR.IRType.uint16, Lean.IR.IRType.uint32, Lean.IR.IRType.uint64, Lean.IR.IRType.usize, Lean.IR.IRType.irrelevant, Unit.unit, dite, LT.lt, Array.size, Lean.IR.Checker.checkEqTypes, Array.get, Fin.mk, Lean.IR.Checker.checkType]]
[Std.Format.MonadPrettyFormat.pushNewline,[]]
[Lean.mkForallEx,[Lean.mkForall]]
[Lean.Syntax.Traverser.cur,[]]
[Lean.Expr.isAtomic,[Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[Lean.Elab.Info.fmtHover?.isAtomicFormat,[Std.Format.nil, Std.Format.line, Std.Format.append, Bool, Bool.true, PProd.fst, Bool.false]]
[Set.inter,[setOf, And, Mem.mem]]
[Lean.IR.UnreachableBranches.addFunctionSummary,[Lean.PersistentEnvExtension.addEntry, Lean.IR.UnreachableBranches.functionSummariesExt, Prod.mk]]
[Array.get?,[dite, LT.lt, Array.size, Option.some, Array.get, Fin.mk, Option.none]]
[Lean.IR.mkCtorExpr,[Lean.IR.Expr.ctor, Lean.IR.CtorInfo.mk]]
[Lean.Elab.Term.SyntheticMVarDecl.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.SyntheticMVarDecl.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.Checker.markVar,[Lean.IR.Checker.markIndex, Lean.IR.VarId.idx]]
[Lean.Expr.isSort,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, Bool.true, Bool.false]]
[ExceptCpsT.run_lift,[rfl]]
[Lean.IR.UnreachableBranches.Value.choice.injEq,[Eq.propIntro, Eq.refl, Lean.IR.UnreachableBranches.Value.choice, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.getOptionDescr,[Bind.bind, Lean.getOptionDecl, Pure.pure, Lean.OptionDecl.descr]]
[Lean.MapDeclarationExtension.instInhabitedMapDeclarationExtension,[inferInstanceAs, Inhabited, Lean.SimplePersistentEnvExtension, Prod, Lean.Name, Lean.NameMap]]
[Lean.Meta.DiscrTree.Key.lit.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.DiscrTree.Key.lit, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.AltVarNames.varNames,[]]
[Lean.Meta.AssertAfterResult.noConfusionType,[]]
[Lean.Meta.InjectionResult.solved.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.FindOptions.mk.inj,[And.intro]]
[Lean.mkLetEx,[Lean.mkLet, Bool.false]]
[Lean.IR.addBoxedVersion,[Except, String, Lean.Environment, EStateM.run, Lean.IR.addBoxedVersionAux, Lean.Options.empty, Lean.IR.CompilerState.mk, Except.ok, Lean.IR.CompilerState.env, Except.error]]
[Lean.ppLine.formatter,[Lean.PrettyPrinter.Formatter.push, Std.Format.text]]
[Std.mkHashMap,[Subtype.mk, Std.mkHashMapImp, Std.HashMapImp.WellFormed.mkWff]]
[Lean.instBEqBinderInfo,[BEq.mk, BEq.beq, Lean.BinderInfo.toCtorIdx]]
[Lean.Parser.Tactic.Conv.ringExp!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[USize.div,[USize.mk, HDiv.hDiv, USize.val]]
[Lean.Parser.Term.implicitBinder.parenthesizer,[Lean.Parser.ppGroup.parenthesizer, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.many1.parenthesizer, Lean.Parser.Term.binderIdent.parenthesizer, Lean.Parser.Term.binderType.parenthesizer]]
[instHashableString,[Hashable.mk, String.hash]]
[IO.FS.SystemTime.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Info.ofTermInfo.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.Info.ofTermInfo, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.isProtected,[Lean.TagDeclarationExtension.isTagged, Lean.protectedExt]]
[Lean.mkSort,[Lean.Expr.sort, Lean.Expr.mkData, mixHash, OfNat.ofNat, Hashable.hash, Bool.false, Lean.Level.hasMVar, Lean.Level.hasParam]]
[exists_and_distrib_right,[of_eq_true, Eq.trans, congr, congrArg, Iff, Exists, funext, propext, and_comm, exists_and_distrib_left, iff_self, And]]
[Lean.Meta.DefaultInstances.defaultInstances,[]]
[Lean.Expr.getAppNumArgs,[Lean.Expr.getAppNumArgsAux, OfNat.ofNat]]
[Lean.ClassState.hasOutParam,[]]
[Lean.Syntax.mkSep,[Lean.mkNullNode, Lean.mkSepArray]]
[Lean.IR.JPParamsMap,[Std.HashMap, Lean.IR.JoinPointId, Array, Lean.IR.Param]]
[GroupWithZero.exists_pair_ne,[]]
[USize.val_eq_of_lt,[Fin.val_eq_of_lt]]
[Lean.Meta.InjectionResultCore.subgoal.inj,[And.intro]]
[Lean.JsonRpc.instToJsonRequestID,[Lean.ToJson.mk, Unit.unit, Lean.Json, Lean.Json.str, Lean.Json.num, Lean.Json.null]]
[StateT.instMonadStateT,[Monad.mk]]
[Lean.Parser.Tactic.replace,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser]]
[Lean.PrettyPrinter.Delaborator.liftMetaM,[liftM]]
[Lean.Meta.addInstance,[Bind.bind, Lean.mkConstWithLevelParams, Lean.Meta.inferType, Lean.Meta.withNewMCtxDepth, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.MetaM, Array, Lean.Meta.DiscrTree.Key, Lean.Meta.DiscrTree.mkPath, Lean.Meta.addGlobalInstance, Lean.ScopedEnvExtension.add, Lean.Meta.instanceExtension, Lean.Meta.InstanceEntry.mk, Option.some]]
[and_symm_left,[Iff.intro, And, Eq, And.intro, Eq.symm]]
[Lean.Server.Watchdog.WorkerState.crashed.injEq,[Eq.propIntro, Eq.refl, Lean.Server.Watchdog.WorkerState.crashed, Eq.symm, eq_of_heq, HEq.refl]]
[instInhabitedOption,[Inhabited.mk, Option.none]]
[Lean.Elab.Term.mkInstMVar,[Bind.bind, liftM, Lean.Meta.mkFreshExprMVar, Option.some, Lean.MetavarKind.synthetic, Lean.Name.anonymous, Lean.Elab.Term.synthesizeInstMVarCore, Option.none, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Elab.Term.registerSyntheticMVarWithCurrRef, Lean.Elab.Term.SyntheticMVarKind.typeClass]]
[Lean.Elab.Tactic.SavedState.restore,[Bind.bind, liftM, Lean.Elab.Term.SavedState.restore, Lean.Elab.Tactic.SavedState.term, Bool.false, MonadStateOf.set, Lean.Elab.Tactic.SavedState.tactic]]
[Lean.Meta.IndPredBelow.Variables.target,[]]
[Lean.PPContext.runMetaM,[Lean.PPContext.runCoreM, Lean.Meta.MetaM.run', Lean.Meta.Context.mk, Lean.PPContext.lctx, Lean.Meta.State.mk, Lean.PPContext.mctx]]
[Lean.Expr.etaExpanded?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Expr, PProd.fst, PProd.snd, HAdd.hAdd, OfNat.ofNat, Lean.Expr.lam, ite, Eq, BEq.beq, Bool.true, Option.none, Lean.Expr.hasLooseBVars, Option.some]]
[Lean.MonadHashMapCacheAdapter.cache,[Lean.MonadHashMapCacheAdapter.modifyCache, Std.HashMap.insert]]
[Lean.Server.FileWorker.SemanticTokensContext.endPos,[]]
[IO.AsyncList.ibelow,[And, True]]
[Lean.Elab.Command.expandInitialize,[Lean.Elab.Command.expandInitCmd, Bool.false]]
[Lean.Meta.SimpAll.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.withMacroExpansion,[Lean.Elab.withMacroExpansionInfo, MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.Context.declName?, List.cons, Lean.Elab.MacroStackElem.mk, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.currMacroScope, Lean.Elab.Term.Context.mayPostpone, Lean.Elab.Term.Context.errToSorry, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.Term.Context.autoBoundImplicits, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection]]
[Int.sub,[HAdd.hAdd, Neg.neg]]
[Lean.LocalDecl.binderInfoEx,[Lean.LocalDecl.ldecl, Lean.BinderInfo, Lean.BinderInfo.default]]
[UInt16.instSemiringUInt16.proof_9,[rfl]]
[Lean.Elab.OpenDecl.State.currNamespace,[]]
[Lean.Elab.Command.liftTermElabM,[Bind.bind, MonadReader.read, MonadState.get, liftM, IO.getNumHeartbeats, Lean.Elab.Command.liftEIO, Lean.Elab.Command.CommandElabM, modify, Lean.Elab.Command.State.mk, Lean.Core.State.env, Std.PersistentArray.foldl, Lean.TraceState.traces, Lean.MessageLog.add, Lean.Elab.mkMessageCore, Lean.Elab.Command.Context.fileName, Lean.Elab.Command.Context.fileMap, Lean.TraceElem.msg, Lean.MessageSeverity.information, OfNat.ofNat, HAppend.hAppend, Lean.Elab.Command.State.messages, Lean.Elab.Term.State.messages, Lean.Core.State.traceState, Lean.Elab.Command.State.scopes, Lean.Core.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Core.State.ngen, Lean.Elab.InfoState.mk, Lean.Elab.InfoState.enabled, Lean.Elab.InfoState.assignment, Std.PersistentArray.append, Lean.Elab.InfoState.trees, Lean.Elab.Command.State.infoState, Lean.Elab.Term.State.infoState, Lean.Elab.Command.State.traceState, Pure.pure, MonadExcept.throw]]
[Nat.lt_wfRel.proof_1,[WellFounded.intro, Acc.intro, OfNat.ofNat, absurd, Nat.not_lt_zero, Nat.succ]]
[inv_mul_cancel_left,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Inv.inv, Eq.symm, mul_assoc, mul_left_inv, OfNat.ofNat, one_mul, rfl]]
[Lean.Compiler.isUnsafeRecName?,[Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Option, Lean.Name, Option.some, Option.none]]
[Lean.Meta.Contradiction.Config.mk.inj,[And.intro]]
[Lean.Lsp.TextDocumentSyncOptions.save?,[]]
[Std.RBMap.contains,[Option.isSome, Std.RBMap.find?]]
[Function.injective_of_partial_inv_right,[Eq.trans, Eq.symm, Iff.mp]]
[Lean.Meta.IndPredBelow.mkCtorType.checkCount,[Bind.bind, Lean.Meta.transform, Option.none, StateRefT', IO.RealWorld, Nat, Lean.Meta.MetaM, Lean.TransformStep, Lean.Expr.constName?, Array.findIdx?, Lean.Meta.IndPredBelow.Context.typeInfos, BEq.beq, Lean.ConstantVal.name, Lean.InductiveVal.toConstantVal, modify, HAdd.hAdd, OfNat.ofNat, Pure.pure, PUnit.unit, Lean.TransformStep.done, Bool, ite, GT.gt, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr]]
[Std.Range.«term[:_:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.Deriving.Context.usePartial,[]]
[Lean.Server.applyDocumentChange,[Lean.FileMap, Lean.Server.replaceLspRange, String.toFileMap]]
[Lean.Elab.Command.elabElabRules,[Lean.Elab.Command.adaptExpander, ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Option.some, Lean.Elab.throwUnsupportedSyntax]]
[Lean.matchConstRec,[Lean.matchConst, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Unit.unit]]
[List.append_eq_has_append,[rfl]]
[Command.simpsRule,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Command.simpsRule.rename, Command.simpsRule.erase, Lean.ParserDescr.unary, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Meta.ToHide.isMarked,[Bind.bind, MonadState.get, Pure.pure, or, Std.RBTree.contains, Lean.Meta.ToHide.State.hiddenInaccessible, Lean.Meta.ToHide.State.hiddenInaccessibleProp]]
[Lean.Parser.commandParser,[Lean.Parser.categoryParser, Lean.Name.mkStr, Lean.Name.anonymous]]
[Subtype.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.instToJsonRange,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.Range.start, List.nil, Lean.Lsp.Range.end]]
[Mathlib.Tactic.Lint.simpVarHead,[Mathlib.Tactic.Lint.Linter.mk, Bind.bind, Mathlib.Tactic.Lint.isSimpLemma, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Option.none, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[Lean.Lsp.instFromJsonLocation,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, Lean.Lsp.Range, Pure.pure, Lean.Lsp.Location.mk]]
[Alternative.noConfusionType,[]]
[Lean.Lsp.SymbolKind.package.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.IR.ExplicitBoxing.eqvTypes,[and, BEq.beq, Lean.IR.IRType.isScalar, or, not]]
[Lean.Lsp.DocumentHighlightKind.toCtorIdx,[OfNat.ofNat]]
[Lean.MapDeclarationExtension.contains,[Unit.unit, Bool, Lean.Environment.getModuleIdxFor?, Array.binSearchContains, Lean.PersistentEnvExtension.getModuleEntries, Prod.mk, arbitrary, Lean.Name.quickLt, Prod.fst, OfNat.ofNat, HSub.hSub, Array.size, Lean.NameMap.contains, Lean.SimplePersistentEnvExtension.getState]]
[IO.Process.SpawnArgs.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Process.SpawnArgs.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Int.subNatNat_add_left,[]]
[Fin.decLt,[Nat.decLt, Fin.val]]
[Lean.Parser.Tactic.nestedTactic.formatter,[Lean.Parser.Tactic.tacticSeqBracketed.formatter]]
[Lean.Parsec.ws,[Lean.Parsec.ParseResult.success, Lean.Parsec.skipWs, Unit.unit]]
[not_imp_comm,[Decidable.not_imp_comm]]
[Lean.SMap.toList,[Lean.SMap.fold, List.cons, Prod.mk, List.nil]]
[Std.instToFormatString,[Std.ToFormat.mk, Std.Format.text]]
[Lean.KVMap.find,[Option, Lean.DataValue, Lean.KVMap.findCore]]
[ST.Ref.swap,[liftM, ST.Prim.Ref.swap]]
[Lean.Meta.CaseArraySizesSubgoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.rwSearch,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.Parser.Tactic.rwRuleSeq]]
[Subarray.allM,[Array.allM, Subarray.as, Subarray.start, Subarray.stop]]
[lt_or_gt_of_ne,[Or, LT.lt, GT.gt, lt_trichotomy, Or.inl, absurd, Or.inr]]
[Lean.Elab.Deriving.mkDiscr,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil, Lean.mkIdent]]
[Lean.Compiler.getNumLit,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Literal.strVal, Option, Nat, Option.some, ite, Eq, Lean.Compiler.isOfNat, Bool.true, PProd.fst, PProd.snd, Option.none]]
[Lean.Occurrences.neg.inj,[]]
[Lean.IR.Borrow.ParamMap,[Std.HashMap, Lean.IR.Borrow.ParamMap.Key, Array, Lean.IR.Param]]
[instDivUInt64,[Div.mk, UInt64.div]]
[Lean.Parsec.ParseResult.success.inj,[And.intro]]
[IO.FS.DirEntry.noConfusionType,[]]
[Quotient.ind₂,[Quotient.ind]]
[Lean.IR.FnBody.jmp.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.FnBody.jmp, Eq.symm, eq_of_heq, HEq.refl]]
[UInt16.decLt,[Decidable, LT.lt, inferInstanceAs]]
[Lean.Parser.errorAtSavedPos,[Lean.Parser.Parser.mk, Lean.Parser.errorAtSavedPosFn]]
[Lean.JsonRpc.Response.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.LocalContext.addParam,[Std.RBMap.insert, Lean.IR.VarId.idx, Lean.IR.Param.x, Lean.IR.LocalContextEntry.param, Lean.IR.Param.ty]]
[Lean.Meta.instMonadMCtxMetaM,[Lean.MonadMCtx.mk, Bind.bind, MonadState.get, Pure.pure, Lean.Meta.State.mctx, modify, Lean.Meta.State.mk, Lean.Meta.State.cache, Lean.Meta.State.zetaFVarIds, Lean.Meta.State.postponed]]
[Nonempty.elim,[Nonempty.elim.proof_1]]
[Lean.PrettyPrinter.Parenthesizer.parenthesizeCategoryCore,[MonadWithReader.withReader, Lean.PrettyPrinter.Parenthesizer.Context.mk, Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.visitArgs, Nat.forM, Array.size, Lean.Syntax.getArgs, Lean.PrettyPrinter.Parenthesizer.parenthesizerForKind, Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.PrettyPrinter.Parenthesizer.mkAntiquot.parenthesizer', Lean.Name.toString, Option.none]]
[Lean.instToStringDataValue,[ToString.mk, Lean.DataValue.str]]
[instCommMonoid_1,[CommMonoid.mk, CommSemiring.mul_comm]]
[Lean.Parser.Command.openHiding.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.ident.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.PrettyPrinter.Formatter.checkColGt.formatter]]
[StateCpsT.instMonadStateCpsT,[Monad.mk]]
[Lean.Parser.Term.attributes,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.sepBy1, Lean.Parser.Term.attrInstance, Bool.false]]
[Lean.Elab.Command.instInhabitedInductiveView,[Inhabited.mk, Lean.Elab.Command.InductiveView.mk, arbitrary]]
[Iff.elim.proof_1,[Iff.mp, Iff.mpr]]
[Std.Format.joinSuffix,[Std.Format, Std.Format.nil, HAppend.hAppend, Std.ToFormat.format, PProd.fst]]
[Array.instForInArray,[ForIn.mk, Array.forIn]]
[Lean.Elab.expandDeclId,[Lean.Elab.ExpandDeclIdResult, ite, Eq, Lean.Syntax.isNone, Bool.true, Bind.bind, Pure.pure, Array.foldlM, OfNat.ofNat, Array.size]]
[Lean.Parser.Term.prop.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[ExceptT,[Except]]
[Lean.Parser.Tactic.changeWith,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.Parser.Tactic.location]]
[Mul.noConfusionType,[]]
[ShiftLeft.noConfusionType,[]]
[Lean.ExternEntry.standard.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.Match.Unify.occurs,[Option.isSome, Lean.Expr.find?, Lean.Expr.bvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Bool, BEq.beq, Bool.false]]
[Functor.discard,[Functor.mapConst, PUnit.unit]]
[Lean.Meta.splitTarget?,[Lean.commitWhenSome?, Bind.bind, Lean.MonadEnv.getEnv, Lean.Meta.getMVarType, Lean.Meta.instantiateMVars, Option.none, Lean.Meta.MetaM, Option, List, Lean.MVarId, Lean.Meta.Split.findSplit?, ite, Eq, or, Lean.Expr.isIte, Lean.Expr.isDIte, Bool.true, Lean.Meta.splitIfTarget?, Pure.pure, Option.map, List.cons, Lean.Meta.ByCasesSubgoal.mvarId, List.nil, coeM, Lean.Meta.Split.splitMatch, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.MessageData.ofGoal, PUnit.unit]]
[Lean.mkHole,[Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkAtomFrom, List.nil]]
[Function.update_comp_eq_of_forall_ne',[funext, Function.update_noteq]]
[Lean.Elab.Term.SavedContext.mk.inj,[And.intro]]
[Lean.Parser.Tactic.mapply',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Fin.modn.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[Lean.MessageDataContext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.MessageDataContext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Expr.FoldConstsImpl.fold,[Lean.Expr.FoldConstsImpl.fold.visit]]
[Substring.bsize,[Nat, Nat.sub]]
[Lean.Elab.Term.ToParserDescrContext.mk.inj,[And.intro]]
[plift.down_up,[rfl]]
[Lean.profileitIOUnsafe,[EIO, Lean.profileit, unsafeEIO, Pure.pure, MonadExcept.throw]]
[Fin.decLe,[Nat.decLe, Fin.val]]
[lt_iff_le_not_le,[Preorder.lt_iff_le_not_le]]
[Lean.Parser.Term.attrKind.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.scoped.formatter, Lean.Parser.Term.local.formatter]]
[Lean.Elab.Term.ToParserDescrContext.leftRec,[]]
[Lean.IR.Borrow.ownParamsUsingArgs,[Nat.forM, Array.size, Lean.IR.Arg.irrelevant, Lean.IR.Borrow.M, Unit, Bind.bind, Lean.IR.Borrow.isOwned, ite, Eq, Bool.true, Lean.IR.Borrow.ownVar, Lean.IR.Param.x, Pure.pure, PUnit.unit, Unit.unit]]
[UInt32.mul_def,[rfl]]
[Lean.Parser.Term.unreachable.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.Parser.symbol.formatter]]
[UInt16.neg_def,[rfl]]
[Lean.OpaqueVal.isUnsafeEx,[Lean.OpaqueVal.isUnsafe]]
[Lean.Elab.Command.instMonadTraceCommandElabM,[Lean.MonadTrace.mk, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Bind.bind, MonadState.get, Pure.pure]]
[Lean.Parser.Command.addTacticDoc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[List.length,[Unit.unit, Nat, OfNat.ofNat, HAdd.hAdd, PProd.fst]]
[Lean.Server.FileWorker.SemanticTokensState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Substring.noConfusionType,[]]
[Lean.Lsp.RpcReleaseParams.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.RpcReleaseParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[non_contradictory_intro,[absurd]]
[StateRefT'.set,[ST.Ref.set]]
[Array.forIn,[Array.size, Nat.le_refl, Array.forIn.loop]]
[Lean.Elab.MacroStackElem.noConfusionType,[]]
[Lean.Elab.Frontend.State.noConfusionType,[]]
[Lean.Elab.Tactic.evalIntro.introStep,[Lean.Elab.Tactic.liftMetaTactic, Bind.bind, Lean.Meta.intro, Lean.Meta.MetaM, List, Lean.MVarId, Pure.pure, List.cons, List.nil]]
[instInhabitedUInt8.proof_1,[of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Elab.MacroStackElem.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.PrettyPrinter.Delaborator.delabDo,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPNotation, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, guard, Eq, Lean.Expr.isAppOfArity, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Bool.true, Lean.PrettyPrinter.Delaborator.delabDoElems, Array.mapM, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, List.nil, Lean.Syntax.atom, Array.append]]
[Std.HashSet,[Subtype, Std.HashSetImp.WellFormed]]
[Lean.Elab.Command.StructFieldInfo.isFromParent,[Lean.Elab.Command.StructFieldKind.newField, Lean.Elab.Command.StructFieldKind.copiedField, Unit.unit, Lean.Elab.Command.StructFieldKind.subobject, Bool, Lean.Elab.Command.StructFieldInfo.kind, Bool.true, Bool.false]]
[Lean.Parser.Term.doReassign.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.notFollowedByRedefinedTermToken.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.letIdDeclNoBinders.formatter, Lean.Parser.Term.letPatDecl.formatter]]
[Lean.EnvExtensionInterfaceUnsafe.Ext.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.EnvExtensionInterfaceUnsafe.Ext.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Lsp.instToJsonRpcCallParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.RpcCallParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position, Lean.Lsp.RpcCallParams.sessionId, Lean.Lsp.RpcCallParams.method, Lean.Lsp.RpcCallParams.params]]
[exists₃_congr,[exists_congr, exists₂_congr]]
[Lean.DeclarationRange.mk.inj,[And.intro]]
[Lean.Meta.instReprCongrLemma,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.Meta.CongrLemma.theoremName, Std.Format.line, Lean.Meta.CongrLemma.funName, Lean.Meta.CongrLemma.hypothesesPos, Lean.Meta.CongrLemma.priority]]
[IO.Error.otherError.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Exception.internal.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Exception.internal, Eq.symm, eq_of_heq, HEq.refl]]
[Array.instInhabitedArray,[Inhabited.mk, Array.empty]]
[Lean.Parser.leadingIdentBehavior,[Unit.unit, Lean.Parser.LeadingIdentBehavior, Lean.Parser.getCategory, Lean.Parser.ParserExtension.State.categories, Lean.ScopedEnvExtension.getState, Lean.Parser.parserExtension, Lean.Parser.LeadingIdentBehavior.default, Lean.Parser.ParserCategory.behavior]]
[Array.filterSepElemsM,[OfNat.ofNat, List.toArray, List.nil]]
[Lean.Elab.WF.TerminationStrategy.mk.inj,[And.intro]]
[UInt64.neg_def,[rfl]]
[Lean.Server.FileWorker.CancelToken.mk.inj,[]]
[Lean.Meta.DefaultInstanceEntry.priority,[]]
[not_imp_not,[Decidable.not_imp_not]]
[Lean.Meta.SortLocalDecls.State.mk.inj,[And.intro]]
[coeFun,[CoeFun.coe]]
[Lean.Server.Snapshots.Snapshot.noConfusionType,[]]
[Lean.PrettyPrinter.Formatter.withAntiquotSuffixSplice.formatter,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, Lean.Syntax.isAntiquotSuffixSplice, Bool.true, Lean.PrettyPrinter.Formatter.visitArgs, SeqRight.seqRight]]
[Lean.Lsp.instFromJsonCompletionList,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Bool, Array, Lean.Lsp.CompletionItem, Pure.pure, Lean.Lsp.CompletionList.mk]]
[Fin.mod,[Fin, Fin.mk, HMod.hMod, Fin.mod.proof_1]]
[Lean.Parser.Term.elseIf,[Lean.Parser.atomic, Lean.Parser.group, Lean.Parser.withPosition, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.checkLineEq]]
[Lean.Elab.Command.StructView.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Command.StructView.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.NamePart.num.inj,[]]
[instDecidableEqProd.proof_1,[rfl]]
[Lean.Elab.Command.elbChoice,[Lean.Syntax.getArgs, OfNat.ofNat]]
[Lean.Parser.Command.sample,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.IR.Checker.maxCtorScalarsSize,[Lean.IR.Checker.getMaxCtorScalarsSize, Unit.unit]]
[Lean.Syntax.isAntiquot,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Syntax.atom, Lean.Syntax.ident, Bool, Bool.true, Bool.false]]
[Nat.sub_lt_of_pos_le,[Nat.sub_lt, lt_of_lt_of_le]]
[ByteArray.toList,[OfNat.ofNat, List.nil, ByteArray.toList.loop]]
[Lean.PrettyPrinter.Delaborator.whenPPOption,[Bind.bind, Lean.PrettyPrinter.Delaborator.getPPOption, ite, Eq, Bool.true, Alternative.failure]]
[Lean.Meta.getDefaultInstances,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Option.getD, Lean.NameMap.find?, Lean.Meta.DefaultInstances.defaultInstances, Lean.SimplePersistentEnvExtension.getState, Lean.Meta.defaultInstanceExtension, List.nil]]
[Lean.IR.VarId.idx,[]]
[Lean.Parser.Term.strictImplicitRightBracket.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.group.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter]]
[Lean.Elab.Command.MkInstanceName.mkFreshInstanceName,[Bind.bind, MonadState.get, modify, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.messages, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, HAdd.hAdd, Lean.Elab.Command.State.nextInstIdx, OfNat.ofNat, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Pure.pure, Lean.Elab.mkFreshInstanceName]]
[Lean.Widget.TaggedText.appendTag,[dite, Eq, Unit.unit, Eq.symm, Lean.Widget.TaggedText.text, Lean.Widget.TaggedText.tag, Lean.Widget.TaggedText, Lean.Widget.TaggedText.append, Array.push, List.toArray, List.cons, List.nil]]
[Lean.Elab.Term.applyAttributesAt,[Bind.bind, ForIn.forIn, PUnit.unit, Lean.MonadEnv.getEnv, Lean.Elab.Term.TermElabM, ForInStep, PUnit, Lean.getAttributeImpl, Lean.Elab.Attribute.name, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Pure.pure, ForInStep.yield, Unit.unit, liftM, Lean.AttributeImpl.add, Lean.Elab.Attribute.stx, Lean.Elab.Attribute.kind, ite, Eq, BEq.beq, Lean.AttributeImplCore.applicationTime, Lean.AttributeImpl.toAttributeImplCore, Bool.true, Option.some]]
[Array.getEvenElems,[Prod.snd, Array.foldl, Prod, Bool, Array, ite, Eq, Bool.true, Prod.mk, Bool.false, Array.push, Array.empty, OfNat.ofNat, Array.size]]
[List.mem_reverseAux,[Iff, Mem.mem, List.reverseAux, Or, of_eq_true, Eq.trans, congrArg, congrFun, propext, List.mem_nil_iff, false_or, iff_self, Eq.mpr, congr, PProd.fst, List.cons, List.mem_cons_iff, Eq.refl, Eq, Eq.symm, or_assoc, or_comm, Iff.rfl]]
[IO.Error.interrupted.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.interrupted, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.QuotVal.kindEx,[Lean.QuotVal.kind]]
[Lean.LocalContext.foldrM,[Std.PersistentArray.foldrM, Lean.LocalContext.decls, Unit.unit, Pure.pure]]
[Lean.Expr.mdata.inj,[And.intro]]
[Nat.mul_div_right,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HDiv.hDiv, HMul.hMul, Nat.zero_eq, Nat.mul_zero, Nat.zero_div, eq_true_of_decide, Eq.refl, Bool.true, Nat.mul_succ, Nat.add_div_right, eq_true, Nat.succ, eq_self]]
[Std.termF!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[Lean.profileitM,[MonadFunctorT.monadMap, Lean.profileitIO]]
[Lean.Meta.Simp.getSimpLemmas,[Bind.bind, readThe, Lean.Meta.Simp.Context, Pure.pure, Lean.Meta.Simp.Context.simpLemmas]]
[Lean.MacroScope,[Nat]]
[Lean.Meta.NormNum.instLawfulOfNatInt.proof_1,[Lean.Meta.NormNum.LawfulOfNat.mk, rfl]]
[Lean.Meta.Simp.getSimpLetCase,[Lean.Meta.withLocalDeclD, Bind.bind, Lean.Meta.isTypeCorrect, ite, Eq, Bool.true, Lean.Meta.inferType, Lean.Meta.whnf, Lean.Meta.dependsOn, Lean.Expr.fvarId!, Pure.pure, Lean.Meta.Simp.SimpLetCase.nondepDepVar, Lean.Meta.Simp.SimpLetCase.nondep, Lean.Meta.Simp.SimpLetCase.dep]]
[Lean.Elab.Command.Context.mk.inj,[And.intro]]
[Lean.Parser.Command.macro,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.suppressInsideQuot, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.docComment, Lean.Parser.Term.attrKind, Lean.Parser.symbol, Lean.Parser.optPrecedence, Lean.Parser.Command.optNamedName, Lean.Parser.Command.optNamedPrio, Lean.Parser.many1, Lean.Parser.Command.macroArg, Lean.Parser.Command.macroTail]]
[IO.Process.Output.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Process.Output.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.withTrackingZeta,[Lean.Meta.withConfig, Lean.Meta.Config.mk, Lean.Meta.Config.foApprox, Lean.Meta.Config.ctxApprox, Lean.Meta.Config.quasiPatternApprox, Lean.Meta.Config.constApprox, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Config.transparency, Lean.Meta.Config.zetaNonDep, Bool.true, Lean.Meta.Config.unificationHints, Lean.Meta.Config.proofIrrelevance, Lean.Meta.Config.assignSyntheticOpaque, Lean.Meta.Config.ignoreLevelMVarDepth, Lean.Meta.Config.offsetCnstrs, Lean.Meta.Config.etaStruct]]
[Lean.Elab.Term.Do.ToCodeBlock.M,[ReaderT, Lean.Elab.Term.Do.ToCodeBlock.Context, Lean.Elab.Term.TermElabM]]
[Lean.Widget.msgToInteractiveDiagnostic,[Bind.bind, MonadExcept.tryCatch, Lean.Widget.msgToInteractive, Lean.Message.data, OfNat.ofNat, Pure.pure, Lean.Widget.TaggedText.text, HAppend.hAppend, ToString.toString, IO.Error.toString]]
[System.FilePath.toString,[]]
[Lean.Lsp.DefinitionParams.toTextDocumentPositionParams,[]]
[instToStringFloatArray,[ToString.mk, List.toString, FloatArray.toList]]
[Lean.Meta.Match.mkMatcherAuxDefinition,[Bind.bind, Lean.isTracingEnabledFor, ite, Eq, Bool.true, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.AttributeExtension,[Lean.PersistentEnvExtension, Lean.AttributeExtensionOLeanEntry, Prod, Lean.AttributeImpl, Lean.AttributeExtensionState]]
[List.removeAll,[List.filter, List.notElem]]
[Lean.Parser.getCategory,[Std.PersistentHashMap.find?]]
[Lean.Lsp.StaticRegistrationOptions.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[apply_ite,[apply_dite]]
[Lean.IR.EmitC.emitArg,[Lean.IR.EmitC.emit, Lean.IR.EmitC.argToCString]]
[Lean.Parser.Command.reassoc_axiom,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser]]
[Lean.Meta.SynthInstance.isNewAnswer,[Array.all, bne, Lean.Meta.SynthInstance.Answer.resultType, OfNat.ofNat, Array.size]]
[Lean.PrettyPrinter.Formatter.visitAtom,[Bind.bind, Lean.Syntax.MonadTraverser.getCur, ite, Eq, bne, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Formatter.checkKind, Pure.pure, PUnit.unit]]
[NeqIffBeqFalse,[Iff.intro, decide_eq_false, of_decide_eq_false]]
[Lean.instToFormatDataValue,[Std.ToFormat.mk, Std.Format, Std.ToFormat.format, repr, HAppend.hAppend, Std.Format.text]]
[Lean.Elab.Term.StructInst.elabStructInst,[Bind.bind, ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, Option.none, Lean.Syntax.isMissing, Lean.Elab.throwAbortTerm, PUnit.unit, Unit.unit, Lean.Elab.Term.TermElabM, Lean.Syntax, Lean.Syntax.setArg, OfNat.ofNat, Lean.Syntax.getOp, Lean.Elab.Term.isLocalIdent?, Option.isSome, PProd.fst, Array.push, Lean.MonadQuotation.withFreshMacroScope, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Lean.Expr, Lean.Elab.Term.withMacroExpansion, Lean.Elab.Term.elabTerm, Lean.withRef, and, Lean.Elab.Term.StructInst.Source.none, Lean.Elab.Term.StructInst.Source.implicit, Array.mapM, Lean.Elab.Term.StructInst.ExplicitSourceInfo, liftM, Lean.Meta.inferType, Lean.Meta.whnf, Lean.Elab.Term.tryPostponeIfMVar, Lean.Meta.getStructureName, Lean.Elab.Term.StructInst.ExplicitSourceInfo.mk, panicWithPosWithDecl, Lean.Syntax.getSepArgs, Lean.Elab.Term.StructInst.Source.explicit, Lean.throwError, Lean.ToMessageData.toMessageData, Array.foldlM, BEq.beq, Lean.Syntax.getKind, Option, Option.some, Lean.throwErrorAt, Lean.Syntax.getArgs, Array.size, GT.gt, Lean.Elab.Term.tryPostponeIfNoneOrMVar, Lean.Name, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr.getAppFn, Lean.MonadEnv.getEnv, Lean.isStructure, HAppend.hAppend, Lean.indentExpr, Lean.Meta.instantiateMVars, Lean.Expr.isMVar, Lean.Elab.liftMacroM, List.mapM, Lean.Elab.Term.StructInst.FieldLHS.modifyOp, Lean.Syntax.isIdent, Lean.Elab.Term.StructInst.FieldLHS.fieldName, Lean.Name.eraseMacroScopes, Lean.Syntax.getId, Lean.MacroM, Lean.Elab.Term.StructInst.FieldLHS, Lean.Syntax.isFieldIdx?, Lean.Elab.Term.StructInst.FieldLHS.fieldIndex, Lean.Macro.throwError, Array.toList, Lean.Elab.Term.StructInst.Field.mk, Lean.Elab.Term.StructInst.FieldVal.term, Lean.Elab.Term.StructInst.Struct.mk, Lean.isTracingEnabledFor, Lean.addTrace]]
[instDecidableAnd.proof_1,[And.right]]
[Lean.Expr.hasSorry,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.lit, Bool, BEq.beq, Lean.Name.mkStr, Lean.Name.anonymous, or, PProd.fst, PProd.snd, Bool.false]]
[Lean.Elab.Attribute.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Attribute.mk, Eq.symm, eq_of_heq, HEq.refl]]
[instSemiringFin.proof_6,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, OfNat.ofNat, add_comm, instSemiringFin.proof_1]]
[Lean.Parser.Term.completion.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer, Lean.Parser.symbol.parenthesizer]]
[instBEqOrdering,[BEq.mk, BEq.beq, Ordering.toCtorIdx]]
[Lean.Server.FileWorker.handleReferences.referencesTo,[Array, Lean.Lsp.Location, List.toArray, List.eraseDups, Array.toList]]
[Lean.instInhabitedReducibilityStatus,[Inhabited.mk, Lean.ReducibilityStatus.reducible]]
[Array.eraseIdx,[ite, LT.lt, Array.size, Array.eraseIdxAux, HAdd.hAdd, OfNat.ofNat]]
[Lean.profileit,[Unit.unit]]
[Quotient.recOnSubsingleton₂.proof_1,[Quot.recOnSubsingleton]]
[Command.simpsRule.rename,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[Lean.IR.FnBody.mapVars,[Lean.IR.MapVars.mapFnBody]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.analyzeFVar,[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.maybeAddBlockImplicit]]
[Lean.Syntax.formatStx,[Lean.Syntax.formatStxAux, OfNat.ofNat]]
[bne,[not, BEq.beq]]
[IO.print,[Bind.bind, liftM, IO.getStdout, IO.FS.Stream.putStr, ToString.toString]]
[Lean.PrettyPrinter.Formatter.mkAntiquot.formatter,[Lean.Parser.mkAntiquot.formatter]]
[Lean.Meta.FunInfo.mk.inj,[And.intro]]
[Lean.Elab.Term.toParserDescr.processAtom,[Unit.unit, Lean.Elab.Term.ToParserDescrM, Lean.Syntax, Lean.Syntax.isStrLit?, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, Lean.Elab.Term.toParserDescr.isValidAtom, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, Lean.Elab.throwUnsupportedSyntax]]
[AddCommGroup.add_comm,[]]
[Lean.Parser.Command.genInjectiveTheorems,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.ident]]
[IO.Process.Output.exitCode,[]]
[Lean.Parser.Term.hole,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[Int.mul_comm,[Eq, HMul.hMul, of_eq_true, Eq.trans, congr, congrArg, Int.ofNat_mul_ofNat, Int.ofNat, Nat.mul_comm, eq_self, Eq.symm, Int.ofNat_mul_negSucc_ofNat, Int.negSucc_ofNat_ofNat, Int.negOfNat, Nat.succ, Eq.refl, Int.mul_negSucc_ofNat_negSucc_ofNat]]
[Lean.Lsp.instToJsonClientInfo,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.ClientInfo.name, List.nil, Lean.Json.opt, Lean.Lsp.ClientInfo.version?]]
[Lean.Elab.Command.Linter,[Lean.Elab.Command.CommandElabM, Unit]]
[forall_congr',[Iff.intro, Iff.mp, Iff.mpr]]
[MonadLiftT.monadLift,[]]
[HEq.noConfusionType,[]]
[Lean.Expr.findMVar?,[Lean.FindMVar.main, Option.none]]
[Lean.Elab.Term.MutualClosure.LetRecClosure.localDecls,[]]
[Inv.noConfusionType,[]]
[Lean.ParserCompiler.Context.tyName,[Lean.KeyedDeclsAttribute.Def.valueTypeName, Lean.KeyedDeclsAttribute.defn, Lean.ParserCompiler.Context.categoryAttr]]
[Lean.JsonRpc.Message.request.inj,[And.intro]]
[Lean.PrettyPrinter.Delaborator.delabOfScientific,[Lean.PrettyPrinter.Delaborator.whenPPOption, Lean.getPPCoercions, Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, guard, Eq, BEq.beq, Lean.Expr.getAppNumArgs, OfNat.ofNat, Bool.true, Pure.pure, Lean.Expr.getArg!, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Literal.strVal, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.DelabM, Lean.Syntax, Lean.Name.anonymous, Lean.Name.str, dite, Eq.symm, Lean.Name.num, Bool.false, Alternative.failure]]
[Lean.Lsp.TextDocumentRegistrationOptions.noConfusionType,[]]
[Lean.Parser.ParserExtension.State.kinds,[]]
[Lean.IR.DeclMap,[Lean.SMap, Lean.Name, Lean.IR.Decl]]
[Lean.Lsp.instFromJsonDefinitionParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.DefinitionParams.mk, Lean.Lsp.TextDocumentPositionParams.mk]]
[Lean.IR.IRType.uint32.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Fin.lor,[Fin, Fin.mk, HMod.hMod, Nat.lor, Fin.lor.proof_1]]
[Lean.Elab.Term.StructInst.instToFormatFieldLHS,[Std.ToFormat.mk, Std.Format, Std.ToFormat.format, HAppend.hAppend, Std.Format.text, Lean.Syntax.prettyPrint]]
[Lean.Meta.Closure.collectLevel,[Lean.Meta.Closure.visitLevel, Lean.Meta.Closure.collectLevelAux]]
[Prod.fst_surjective,[Nonempty.elim, Exists.intro, Prod.mk, rfl]]
[Lean.Parser.Term.quotedName.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.nameLit.formatter]]
[Or.resolve_left,[Or.elim, absurd, id]]
[Lean.BinderInfo.noConfusionType,[noConfusionTypeEnum, Lean.BinderInfo.toCtorIdx]]
[Lean.PrettyPrinter.Formatter.many1NoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.manyNoAntiquot.formatter]]
[«termΣ'_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
[Lean.QuotVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Subtype.property,[]]
[Prod.mk.inj,[And.intro]]
[Lean.getPPMotivesNonConst,[Lean.KVMap.get, Lean.Option.name, Lean.pp.motives.nonConst, Lean.Option.defValue]]
[Lean.Environment.addAndCompile,[Bind.bind, Lean.Environment.addDecl, Lean.Environment.compileDecl]]
[Lean.Elab.addCompletionInfo,[Lean.Elab.pushInfoLeaf, Lean.Elab.Info.ofCompletionInfo]]
[Lean.instInhabitedJson,[Inhabited.mk, Lean.Json.null]]
[String.Iterator.hasNext,[Bool, Decidable.decide, LT.lt, String.utf8ByteSize]]
[PSigma.fst,[]]
[Lean.Elab.Deriving.DecEq.mkEnumOfNatThm,[Bind.bind, Lean.getConstInfoInduct, Lean.Meta.withLocalDeclD, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.mkLambdaFVars, List.toArray, List.cons, List.nil, Bool.false, Bool.true, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Meta.mkForallFVars, Lean.addAndCompile, Lean.Declaration.thmDecl, Lean.TheoremVal.mk, Lean.ConstantVal.mk]]
[«term_∨_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.Term.Do.ToCodeBlock.Context.noConfusionType,[]]
[Lean.Meta.CongrLemma.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.CongrLemma.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parsec.manyChars,[Lean.Parsec.manyCharsCore]]
[Lean.Server.Watchdog.OpenDocument.headerAst,[]]
[Lean.Meta.Closure.ToProcessElement.fvarId,[]]
[Array.foldrM.fold.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self]]
[Lean.Parser.Tactic.swap,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const]]
[instMonadWithReaderOf,[MonadWithReaderOf.mk, MonadFunctorT.monadMap, withTheReader]]
[Nat.add_mul_mod_self_right,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, HMul.hMul, Nat.mul_comm, Nat.add_mul_mod_self_left, rfl]]
[Lean.Lsp.InitializeParams.rootUri?,[]]
[Lean.Elab.Term.ExtractMonadResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Server.RequestM.readDoc,[Pure.pure, Lean.Server.RequestContext.doc]]
[add_assoc,[AddSemigroup.add_assoc]]
[Nat.le_of_sub_eq_zero,[Nat.zero, Nat.succ, LE.le, of_eq_true, Eq.trans, congrFun, congrArg, Eq.mp, Eq.refl, Eq, HSub.hSub, OfNat.ofNat, Nat.sub_zero, eq_true_of_decide, Bool.true, Nat.zero_le, HAdd.hAdd, Nat.add_le_add_right, PProd.fst, Nat.add_sub_add_right]]
[Lean.Syntax.getQuotContent,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Environment.declsInModuleIdx,[Std.HashMap.fold, ite, Eq, List.cons, List.nil, Lean.Environment.const2ModIdx]]
[Lean.Json.escape,[String.foldl, ite, Eq, Char.ofNat, HAppend.hAppend, And, LE.le, OfNat.ofNat, Char.val, String.singleton, List.asString, List.cons, Nat.digitChar, HDiv.hDiv, HMod.hMod, List.nil]]
[Nat.dvd_iff_mod_eq_zero,[Iff.intro, Nat.mod_eq_zero_of_dvd, Nat.dvd_of_mod_eq_zero]]
[Lean.ClassEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ClassEntry.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.isBuiltinAttribute,[Bind.bind, ST.Ref.get, Lean.attributeMapRef, Pure.pure, Std.PersistentHashMap.contains]]
[le_refl,[Preorder.le_refl]]
[Lean.Lsp.instToJsonSemanticTokensOptions,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.SemanticTokensOptions.legend, List.nil, Lean.Lsp.SemanticTokensOptions.range, Lean.Lsp.SemanticTokensOptions.full]]
[Bool.true_and,[rfl, Eq.symm, Eq.refl]]
[Lean.IR.FnBody.vdecl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.doIdDecl.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.Term.optType.formatter, Lean.Parser.Term.leftArrow.formatter, Lean.Parser.doElemParser.formatter]]
[IO.FS.Stream.writeLspRequest,[IO.FS.Stream.writeLspMessage, Lean.JsonRpc.Message.request, Lean.JsonRpc.Request.id, Lean.JsonRpc.Request.method, Except.toOption, Lean.Json.toStructured?, Lean.JsonRpc.Request.param]]
[Nat.gcd_eq_left_iff_dvd,[Iff.intro, Eq.mpr, Eq.refl, Eq, Nat.gcd, Nat.gcd_rec, HMod.hMod, Nat.mod_eq_zero_of_dvd, OfNat.ofNat, Nat.gcd_zero_left, rfl, Nat.gcd_dvd_right]]
[EIO.toIO',[liftM, EIO.toBaseIO]]
[Lean.Parser.Term.funStrictImplicitBinder,[HAndThen.hAndThen, Lean.Parser.atomic, Lean.Parser.lookahead, Lean.Parser.Term.strictImplicitLeftBracket, Lean.Parser.many1, Lean.Parser.Term.binderIdent, HOrElse.hOrElse, Lean.Parser.symbol, Lean.Parser.Term.strictImplicitRightBracket, Lean.Parser.Term.strictImplicitBinder, Bool.false]]
[Lean.Lsp.Range.end,[]]
[Lean.Parser.rawIdentFn,[ite, Eq, String.atEnd, Bool.true, Lean.Parser.ParserState.mkEOIError, List.nil, Lean.Parser.identFnAux, Option.none, Lean.Name.anonymous]]
[Lean.instInhabitedData,[inferInstanceAs, Inhabited, UInt64]]
[Lean.SimpleScopedEnvExtension.Descr.mk.inj,[And.intro]]
[Nat.gcd.induction,[WellFounded.induction, WellFoundedRelation.wf, Nat.lt_wfRel, HAdd.hAdd, OfNat.ofNat, Nat.succ_pos, HMod.hMod, Nat.mod_lt]]
[Lean.NameHashSet.insert,[Std.HashSet.insert]]
[Lean.Expr.data,[Lean.Expr.Data]]
[Lean.Parser.Term.macroLastArg.formatter,[Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.macroDollarArg.formatter, Lean.Parser.Term.macroArg.formatter]]
[Lean.Meta.GeneralizeArg.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.GeneralizeArg.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.tacticSeq1Indented.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.many1Indent.parenthesizer, Lean.Parser.group.parenthesizer, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.ppLine.parenthesizer, Lean.Parser.tacticParser.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.symbol.parenthesizer]]
[Array.findSomeRevM?.find.proof_1,[Nat.lt_of_lt_of_le, Nat.lt_succ_self]]
[DoResultPRBC.return.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.symbolInfo,[Lean.Parser.ParserInfo.mk, List.cons, Lean.Parser.FirstTokens.tokens, List.nil]]
[UInt32.instSemiringUInt32.proof_10,[rfl]]
[Lean.Elab.Level.Context.mk.inj,[And.intro]]
[Lean.Lsp.DefinitionParams.noConfusionType,[]]
[Std.Format.prefixJoin,[Unit.unit, Std.Format, Std.Format.nil, HAppend.hAppend, Std.ToFormat.format, PProd.fst]]
[Lean.IR.ExpandResetReuse.Mask,[Array, Option, Lean.IR.VarId]]
[Function.right_inverse.injective,[Function.left_inverse.injective, Function.right_inverse.left_inverse]]
[Lean.MonadQuotation.addMacroScope,[Bind.bind, Lean.MonadQuotation.getMainModule, Lean.MonadQuotation.getCurrMacroScope, Pure.pure, Lean.addMacroScope]]
[Classical.byCases,[Decidable.byCases]]
[Lean.Constructor.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Constructor.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.elementwise,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const]]
[Lean.Server.FileWorker.GoToKind.definition.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Std.PersistentHashMap.isUnaryNode,[Option, Prod, Std.PersistentHashMap.isUnaryEntries, OfNat.ofNat, Option.none, dite, Eq, Array.size]]
[Nat.min_zero,[min_eq_right, Nat.zero_le]]
[Lean.Parser.Attr.higherOrder,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[Lean.Json.arr.inj,[]]
[instDecidableEqProd.proof_3,[absurd]]
[iff_def,[iff_iff_implies_and_implies]]
[IO.Error.mkAlreadyExists,[IO.Error.alreadyExists, Option.none]]
[Array.ext.extAux,[rfl, Eq.symm, Eq.mp, Eq.refl, Eq, List.length, List.nil, List.cons, List.length_cons]]
[Lean.Parser.ParserExtension.Entry.parser.inj,[And.intro]]
[Lean.IR.UnreachableBranches.InterpContext.env,[]]
[Lean.Meta.SortLocalDecls.State.noConfusionType,[]]
[Lean.IR.UnboxResult.hasUnboxAttr,[Lean.TagAttribute.hasTag, Lean.IR.UnboxResult.unboxAttr]]
[Std.instInhabitedPersistentArray,[Inhabited.mk, Std.PersistentArray.mk, arbitrary]]
[Lean.Parser.Command.classInductive.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.group.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Command.declId.parenthesizer, Lean.Parser.Command.optDeclSig.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.many.parenthesizer, Lean.Parser.Command.ctor.parenthesizer, Lean.Parser.Command.optDeriving.parenthesizer]]
[Lean.Meta.Simp.Config.maxSteps,[]]
[HasEquiv.Equiv,[]]
[MonadControl.noConfusionType,[]]
[Lean.Elab.Term.StructInst.FieldLHS.fieldIndex.inj,[And.intro]]
[Ordering.eq.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Tactic.liftMetaMAtMain,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.getMainGoal, liftM]]
[Lean.Level.updateIMax,[Lean.mkLevelIMax']]
[gt_of_gt_of_ge,[lt_of_le_of_lt]]
[BaseIO,[EIO, Empty]]
[Nat.gcd_gcd_self_left_left,[Eq.mpr, Eq.refl, Eq, Nat.gcd, Nat.gcd_comm, Nat.gcd_gcd_self_left_right, rfl]]
[Lean.Parser.doElemParser.formatter,[Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous]]
[Nat.forRevM.loop,[Unit.unit, Unit, Pure.pure, Bind.bind, PProd.fst]]
[Lean.Parser.Term.ensureTypeOf.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.strLit.parenthesizer]]
[Lean.Level.depthEx,[Lean.Level.Data.depth, Lean.Level.data]]
[Lean.PrettyPrinter.Parenthesizer.numLitNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken]]
[ne_true_of_not,[]]
[Lean.catchInternalId,[MonadExcept.tryCatch, MonadExcept.throw, ite, Eq, BEq.beq, Bool.true]]
[Lean.MetavarContext.isLevelAssigned,[Std.PersistentHashMap.contains, Lean.MetavarContext.lAssignment]]
[Lean.MetavarContext.isAnonymousMVar,[Unit.unit, Bool, Lean.MetavarContext.findDecl?, Bool.false, Lean.Name.isAnonymous, Lean.MetavarDecl.userName]]
[Lean.Position.instToStringPosition,[ToString.mk, String, HAppend.hAppend, ToString.toString]]
[Lean.Meta.Contradiction.Config.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MessageLog.toList,[List.reverse, Std.PersistentArray.foldl, Lean.MessageLog.msgs, List.cons, List.nil, OfNat.ofNat]]
[Lean.Server.FileWorker.CancelToken.set,[ST.Ref.set, Lean.Server.FileWorker.CancelToken.ref, Bool.true]]
[Lean.Elab.PreDefinition.ref,[]]
[Lean.EnvExtension.setState,[Lean.EnvExtensionInterface.setState, Lean.EnvExtensionInterfaceImp]]
[Lean.Meta.DiscrTree.getUnify,[Lean.Meta.withReducible, Bind.bind, ite, Eq, Bool.true, Lean.Expr.bvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.letE, Lean.Expr.mdata, Lean.Meta.MetaM, Prod, Lean.Meta.DiscrTree.Key, Array, Lean.Expr, Lean.Expr.getAppFn, Pure.pure, Prod.mk, Lean.Meta.DiscrTree.Key.lit, List.toArray, List.nil, Lean.Meta.DiscrTree.Key.const, Lean.Expr.getAppRevArgs, Lean.Meta.DiscrTree.Key.fvar, Lean.Meta.DiscrTree.Key.other, MonadReader.read, Lean.Meta.Config.isDefEqStuckEx, Lean.Meta.Context.config, Lean.Meta.DiscrTree.Key.star, Lean.Meta.isReadOnlyOrSyntheticOpaqueExprMVar, Lean.Meta.DiscrTree.Key.proj, List.cons, Lean.Expr.hasLooseBVars, Lean.Meta.DiscrTree.Key.arrow, Bool.false, Unit.unit, Std.PersistentHashMap.foldlM, Lean.Meta.DiscrTree.root, Lean.Meta.DiscrTree.Key.arity, Std.PersistentHashMap.find?, OfNat.ofNat, Lean.Meta.DiscrTree.getUnify.process]]
[mul_right_cancel_iff,[Iff.intro, mul_right_cancel, rfl]]
[Lean.Elab.DefKind.def.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Term.tryCoeThunk?,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Name.anonymous, dite, Eq, Eq.symm, Lean.Name.str, Lean.Name.num, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Elab.Term.TermElabM, Option, Lean.Expr, Bind.bind, liftM, Lean.Meta.isDefEq, ite, Bool.true, Pure.pure, Option.some, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.mkSimpleThunk, Option.none]]
[Lean.BinderInfo.isExplicit,[Lean.BinderInfo.default, Unit.unit, Lean.BinderInfo.auxDecl, Bool, Bool.false, Bool.true]]
[Lean.ScopedEnvExtension.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.ScopedEnvExtension.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.ExplicitBoxing.visitVDeclExpr,[Lean.IR.Expr.reset, Lean.IR.Expr.proj, Lean.IR.Expr.uproj, Lean.IR.Expr.sproj, Lean.IR.Expr.box, Lean.IR.Expr.unbox, Lean.IR.Expr.lit, Lean.IR.Expr.isShared, Lean.IR.Expr.isTaggedPtr, Lean.IR.ExplicitBoxing.M, Lean.IR.FnBody, ite, Eq, and, Lean.IR.CtorInfo.isScalar, Lean.IR.IRType.isScalar, Bool.true, Pure.pure, Lean.IR.FnBody.vdecl, Lean.IR.LitVal.num, Lean.IR.CtorInfo.cidx, Lean.IR.ExplicitBoxing.boxArgsIfNeeded, Lean.IR.Expr.ctor, Lean.IR.Expr.reuse, Bind.bind, Lean.IR.ExplicitBoxing.getDecl, Lean.IR.ExplicitBoxing.castArgsIfNeeded, Lean.IR.Decl.params, Lean.IR.ExplicitBoxing.castResultIfNeeded, Lean.IR.Expr.fap, Lean.IR.Decl.resultType, Lean.IR.ExplicitBoxing.getEnv, Lean.IR.Expr.pap, Lean.IR.ExplicitBoxing.unboxResultIfNeeded, Lean.IR.Expr.ap]]
[instDecidableEqProd,[Decidable, Eq, Prod.mk, decEq, Decidable.isTrue, instDecidableEqProd.proof_1, Decidable.isFalse, instDecidableEqProd.proof_2, instDecidableEqProd.proof_3]]
[Lean.Elab.Term.MVarErrorKind.hole.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[List.format,[Unit.unit, List.cons, Std.Format, Std.Format.text, Std.Format.sbracket, Std.Format.joinSep, HAppend.hAppend, Std.Format.line]]
[Int.add_right_neg,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat, Int.add_comm, Int.add_left_neg, rfl]]
[Lean.Elab.Term.LetRecToLift.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Compiler.CSimp.State,[Lean.SMap, Lean.Name]]
[Lean.Elab.Term.StructInst.FieldVal.nested.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.SortLocalDecls.Context.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.SortLocalDecls.Context.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.checkSyntaxNodeKindAtCurrentNamespaces,[Bind.bind, MonadReader.read, Lean.Elab.checkSyntaxNodeKindAtNamespaces, Lean.Core.Context.currNamespace]]
[IO.AsyncList.instCoeListAsyncList,[Coe.mk, IO.AsyncList.ofList]]
[Lean.Parser.withAntiquotSpliceAndSuffix.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquotSplice.formatter, Lean.PrettyPrinter.Formatter.withoutInfo.formatter, Lean.PrettyPrinter.Formatter.withAntiquotSuffixSplice.formatter]]
[Lean.Parser.Tactic.equivRwType,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Command.terminationBy,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Command.terminationHint, Lean.Parser.termParser]]
[StateCpsT.runK_bind_lift,[rfl]]
[Lean.PrettyPrinter.Parenthesizer.fieldIdx.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken]]
[Lean.IR.CtorInfo.isScalar,[not, Lean.IR.CtorInfo.isRef]]
[UInt64.decEq.proof_2,[absurd]]
[Nat.mul_dvd_mul_left,[Nat.mul_dvd_mul, Nat.dvd_refl]]
[Prod.fst_injective,[Prod.ext', Subsingleton.elim, Prod.snd]]
[Lean.Server.Watchdog.ServerContext.args,[]]
[Lean.Elab.Term.LetRecToLift.ref,[]]
[List.forM_nil,[rfl]]
[Lean.Elab.Term.StructInst.Source.none.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Meta.SynthInstance.getInstances,[Bind.bind, Lean.Meta.getLocalInstances, Lean.Meta.forallTelescopeReducing, Lean.Meta.isClass?, Unit.unit, Lean.Meta.MetaM, Array, Lean.Expr, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, liftM, Lean.Meta.getGlobalInstancesIndex, Lean.Meta.DiscrTree.getUnify, Lean.Meta.getErasedInstances, Array.filterMapM, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Option, Lean.Meta.InstanceEntry.val, ite, Eq, Std.PersistentHashSet.contains, Bool.true, Pure.pure, Option.none, List.mapM, Lean.Meta.mkFreshLevelMVar, Option.some, Lean.Expr.updateConst!, panicWithPosWithDecl, OfNat.ofNat, Array.size, Lean.isTracingEnabledFor, Lean.addTrace, PUnit.unit]]
[Std.Format.MonadPrettyFormat.endTags,[]]
[Lean.Elab.Term.SavedState.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.SavedState.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.ensureHasType,[Unit.unit, Option.some, Lean.Elab.Term.TermElabM, Lean.Expr, Pure.pure, Bind.bind, liftM, Lean.Meta.inferType, Lean.Elab.Term.ensureHasTypeAux, Option.none]]
[Lean.Lsp.TextEdit.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.TextEdit.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.LiveVars.Collector,[Lean.IR.LiveVarSet]]
[Lean.MetavarContext.revert,[Lean.MetavarContext.MkBinding.revert]]
[Std.RBTree.forIn,[Std.RBNode.forIn, Subtype.val]]
[instSubsingletonPUnit,[Subsingleton.intro, PUnit.subsingleton]]
[Lean.Elab.instMonadLog,[Lean.Elab.MonadLog.mk, liftM, Lean.Elab.MonadLog.getRef, Lean.Elab.MonadLog.getFileName, Lean.Elab.MonadLog.logMessage]]
[Lean.Meta.Context.lctx,[]]
[Lean.Server.Watchdog.WorkerState.noConfusionType,[]]
[Lean.Lsp.instToJsonDiagnosticSeverity,[Lean.ToJson.mk, Unit.unit, Lean.Json, OfNat.ofNat]]
[Lean.getRevAliases,[Lean.SMap.fold, ite, Eq, List.contains, Bool.true, List.cons, List.nil, Lean.SimplePersistentEnvExtension.getState, Lean.aliasExtension]]
[USize.lt,[LT.lt, USize.val]]
[add_right_eq_self,[Eq.mpr, Eq.refl, Iff, Eq, HAdd.hAdd, OfNat.ofNat, Eq.symm, propext, add_left_cancel_iff, add_zero, Iff.rfl]]
[Lean.IR.EmitC.throwInvalidExportName,[MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Lean.Parser.Module.module,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Module.header, Lean.Parser.many, Lean.Parser.commandParser, Lean.Parser.ppLine]]
[Lean.Parser.setExpectedFn,[Lean.Parser.ParserState.mk, Option.none, Option.some, Lean.Parser.ParserState, Lean.Parser.ParserState.stxStack, Lean.Parser.ParserState.lhsPrec, Lean.Parser.ParserState.pos, Lean.Parser.ParserState.cache, Lean.Parser.Error.mk, Lean.Parser.Error.unexpected, List.nil]]
[Lean.RecursorVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.JsonNumber.instOrdJsonNumber,[Ord.mk, ite, LT.lt, Ordering.lt, GT.gt, Ordering.gt, Ordering.eq]]
[Lean.Parser.Term.letIdDeclNoBinders.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.Name.mkStr, Lean.Name.anonymous, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Term.ident.parenthesizer, Lean.PrettyPrinter.Parenthesizer.pushNone.parenthesizer, Lean.Parser.Term.optType.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.termParser.parenthesizer, OfNat.ofNat]]
[List.decidableMem.proof_2,[Or.inr]]
[Lean.Parser.Term.doAssert,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser, OfNat.ofNat]]
[instSubsingletonStateM,[instSubsingletonStateM.proof_1]]
[Function.surjective,[Exists, Eq]]
[Lean.DataValue.str,[String, ToString.toString]]
[Lean.mkLevelIMax',[ite, Eq, Lean.Level.isNeverZero, Bool.true, Lean.mkLevelMax', Lean.Level.isZero, BEq.beq, Lean.mkLevelIMax]]
[Lean.Meta.SizeOfSpecNested.Context.ctorName,[]]
[Lean.Lsp.instFromJsonRpcKeepAliveParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.DocumentUri, UInt64, Pure.pure, Lean.Lsp.RpcKeepAliveParams.mk]]
[Lean.Elab.Command.checkValidCtorModifier,[ite, Eq, Lean.Elab.Modifiers.isNoncomputable, Bool.true, Bind.bind, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.OptionDecls,[Lean.NameMap, Lean.OptionDecl]]
[Function.const_apply,[rfl]]
[Tactic.Ring.evalHorner,[Tactic.Ring.HornerExpr.const, Tactic.Ring.HornerExpr.xadd, Tactic.Ring.RingM, Prod, Tactic.Ring.HornerExpr, Lean.Expr, ite, Eq, OfNat.ofNat, Bind.bind, Tactic.Ring.mkAppCS, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Prod.fst, Tactic.Ring.HornerExpr.e, List.nil, Pure.pure, Prod.mk, Tactic.Ring.HornerExpr.xadd', Tactic.Ring.HornerExpr.reflConv, And, Prod.snd, Lean.Expr.numeral?, Option.some, Lean.mkRawNatLit, HAdd.hAdd, liftM, Lean.Meta.mkEqRefl]]
[AndThen.noConfusionType,[]]
[Lean.Server.handleLspRequest,[Bind.bind, liftM, ST.Ref.get, Lean.Server.requestHandlers, Pure.pure, Std.PersistentHashMap.find?, Unit.unit, Lean.Server.RequestM, Lean.Server.RequestTask, Lean.Json, MonadExcept.throw, Lean.Server.RequestError.mk, Lean.JsonRpc.ErrorCode.internalError, ToString.toString, IO.userError, HAppend.hAppend]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context.bInfos,[]]
[Lean.Parser.Term.doFinally.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.doSeq.formatter]]
[OptionT.instAlternativeOptionT,[Alternative.mk, OptionT.fail, OptionT.orElse]]
[decidable_eq_inl_refl,[Eq, Decidable.isTrue, Eq.refl, rfl, absurd]]
[Fin.mul,[Fin, Fin.mk, HMod.hMod, HMul.hMul, Fin.mul.proof_1]]
[Lean.Meta.AbstractMVars.mkFreshId,[Bind.bind, MonadState.get, modify, Lean.Meta.AbstractMVars.State.mk, Lean.NameGenerator.next, Lean.Meta.AbstractMVars.State.ngen, Lean.Meta.AbstractMVars.State.lctx, Lean.Meta.AbstractMVars.State.mctx, Lean.Meta.AbstractMVars.State.nextParamIdx, Lean.Meta.AbstractMVars.State.paramNames, Lean.Meta.AbstractMVars.State.fvars, Lean.Meta.AbstractMVars.State.lmap, Lean.Meta.AbstractMVars.State.emap, Pure.pure]]
[Lean.Syntax.Traverser.left,[ite, GT.gt, Array.size, Lean.Syntax.Traverser.parents, OfNat.ofNat, Lean.Syntax.Traverser.down, Lean.Syntax.Traverser.up, HSub.hSub, Array.back, Lean.Syntax.Traverser.idxs]]
[Lean.PrettyPrinter.Parenthesizer.rawIdentNoAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.visitToken]]
[Lean.PrettyPrinter.Delaborator.ParamKind.isAutoParam,[]]
[Lean.EnvExtensionInterface.mkInitialExtStates,[]]
[Lean.IR.Borrow.instToFormatParamMap,[Std.ToFormat.mk, Lean.IR.Borrow.ParamMap.fmt]]
[Lean.Meta.mkFalseElim,[Bind.bind, Lean.Meta.getLevel, Pure.pure, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil]]
[Lean.Elab.Term.BinOp.elabBinOp,[Bind.bind, Lean.Elab.liftMacroM, Lean.expandMacros, Lean.Elab.Term.synthesizeSyntheticMVars, Bool.true, Bool.false, Pure.pure, Unit.unit, Lean.Elab.Term.TermElabM, Option.none, liftM, Lean.Meta.instantiateMVars, ite, Eq, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.proj, Bool, PProd.fst, PProd.snd, Option.some, MonadState.get, PUnit.unit, StateRefT', IO.RealWorld, Unit, Lean.Meta.inferType, modify, Lean.Meta.withNewMCtxDepth, Lean.Meta.isDefEqGuarded, Lean.MonadEnv.getEnv, Lean.Environment.contains, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getLevel, Lean.MonadOptions.getOptions, Lean.Meta.trySynthInstance, Lean.Option.get, Lean.Elab.Term.maxCoeSize, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Command.initializeSimpsProjections,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const, Command.simpsProj]]
[Lean.Parser.Term.structInst.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.ppHardSpace.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.sepBy1.formatter, Lean.Parser.termParser.formatter, Bool.false, Lean.Parser.manyIndent.formatter, Lean.Parser.group.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.Term.structInstFieldAbbrev.formatter, Lean.Parser.Term.structInstField.formatter, Lean.Parser.Term.optEllipsis.formatter]]
[Lean.Lsp.instFromJsonCompletionParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, Pure.pure, Lean.Lsp.CompletionParams.mk, Lean.Lsp.TextDocumentPositionParams.mk]]
[Lean.Meta.orelseMergeErrors,[controlAt, Lean.Meta.MetaM, Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadMCtx.getMCtx, MonadExcept.tryCatch, Lean.setEnv, Lean.Meta.setMCtx, Lean.Exception.internal, MonadExcept.throw, Lean.Exception.error]]
[Lean.KernelException.funExpected.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.funExpected, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.setReducibilityStatus,[Lean.MonadEnv.modifyEnv, Lean.setReducibilityStatusImp]]
[Lean.Server.FileWorker.instInhabitedEditableDocument,[Inhabited.mk, Lean.Server.FileWorker.EditableDocument.mk, arbitrary]]
[instReprNat,[Repr.mk, Std.Format.text, Nat.repr]]
[Lean.IR.instBEqLitVal,[BEq.mk, Lean.IR.LitVal.beq]]
[Tactic.Ring.const_add_horner,[of_eq_true, Eq.trans, congr, congrArg, Eq, add_comm, HAdd.hAdd, HMul.hMul, HPow.hPow, add_assoc, Eq.symm, eq_self]]
[Lean.Lsp.TextDocumentSyncOptions.noConfusionType,[]]
[Lean.Elab.Term.CollectPatternVars.State.vars,[]]
[Lean.Parser.Term.prec.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.precedenceParser.parenthesizer]]
[Lean.Attribute.Builtin.getId,[Bind.bind, Lean.Attribute.Builtin.getIdent, Pure.pure, Lean.Syntax.getId]]
[Lean.Compiler.toDecidableExpr,[Unit.unit, Lean.Expr, Lean.mkDecIsTrue, Lean.Compiler.neutralExpr, Lean.mkDecIsFalse, Lean.Compiler.mkLcProof]]
[Lean.OpenDecl.instInhabitedOpenDecl,[Inhabited.mk, Lean.OpenDecl.simple, Lean.Name.anonymous, List.nil]]
[Lean.Parser.checkTailNoWs,[Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Bool, Lean.Syntax.getTailInfo, BEq.beq, Substring.stopPos, Substring.startPos, Bool.false]]
[Lean.Parser.instInhabitedParserCategory,[Inhabited.mk, Lean.Parser.ParserCategory.mk, arbitrary]]
[Lean.Elab.Info.size?,[OptionM.run, Bind.bind, Lean.Elab.Info.pos?, Lean.Elab.Info.tailPos?, Pure.pure, HSub.hSub]]
[StateT.run_seqRight,[]]
[ReaderT.run_map,[rfl]]
[Lean.Parser.instCoeArrowParserParserParserAliasValue,[Coe.mk, Lean.Parser.AliasValue.unary]]
[instHashableUInt64,[Hashable.mk]]
[Lean.Widget.InteractiveGoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Widget.InteractiveGoal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Expr.instantiateBetaRevRange,[ite, Eq, and, Lean.Expr.hasLooseBVars, Decidable.decide, GT.gt, Bool.true, LE.le, Array.size, Lean.MonadStateCacheT.run, OfNat.ofNat, panicWithPosWithDecl, HAppend.hAppend, Lean.Expr.instantiateBetaRevRange.visit]]
[Lean.Meta.RewriteResult.mk.inj,[And.intro]]
[Lean.Elab.InfoState.assignment,[]]
[CommRing.toRing,[]]
[Std.HashMap.foldM,[Std.HashMapImp.foldM]]
[Lean.catchInternalIds,[MonadExcept.tryCatch, MonadExcept.throw, ite, Eq, List.contains, Bool.true]]
[Lean.Parser.Term.scientific.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer, Lean.Parser.maxPrec, Lean.Parser.scientificLit.parenthesizer]]
[Lean.SyntaxNode,[Subtype, Lean.IsNode]]
[Lean.Parser.symbolNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.symbolInfo, Lean.Parser.symbolFn]]
[Subtype.ext_iff,[Iff.intro, congrArg, Subtype.val, Subtype.ext]]
[Lean.ParserCompiler.CombinatorAttribute.ext,[]]
[IO.ofExcept,[IO, Pure.pure, MonadExcept.throw, IO.userError, ToString.toString]]
[Lean.Meta.SimpEntry.noConfusionType,[]]
[UInt8.toNat,[Fin.val, UInt8.val]]
[Lean.PrettyPrinter.Formatter.push,[modify, Lean.PrettyPrinter.Formatter.State.mk, Lean.PrettyPrinter.Formatter.State.stxTrav, Lean.PrettyPrinter.Formatter.State.leadWord, Array.push, Lean.PrettyPrinter.Formatter.State.stack]]
[Lean.Parser.prattParser,[ite, Eq, Lean.Parser.ParserState.hasError, Bool.true, Lean.Parser.trailingLoop]]
[Tactic.Ring.addAtom,[Bind.bind, MonadState.get, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, liftM, Lean.Meta.isDefEq, Array.getOp, Tactic.Ring.State.atoms, ite, Eq, Bool.true, Pure.pure, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, Tactic.Ring.RingM, Nat, MProd.fst]]
[Lean.Parser.Term.open.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, Lean.Parser.leadPrec, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.openDecl.formatter, Lean.PrettyPrinter.Formatter.withOpenDecl.formatter, Lean.Parser.termParser.formatter, OfNat.ofNat]]
[Nat.case_strong_rec_on,[Nat.strong_rec_on, Nat.lt_succ_of_le]]
[throwThe,[MonadExceptOf.throw]]
[Lean.PrettyPrinter.Formatter.dbgTraceState.formatter,[]]
[List.mem_insert_of_mem,[Iff.mpr, List.mem_insert_iff, Or.inr]]
[Lean.Parser.Tactic.ringExpEq!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.IR.Expr.ctor.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.IR.Expr.ctor, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.Borrow.ParamMap.Key.noConfusionType,[]]
[Prod.map_def,[funext, of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, prod_map, Prod.mk, Prod.fst, Prod.snd, eq_self, propext, implies_true_iff, Prod]]
[Fin.instDivFin,[Div.mk, Fin.div]]
[List.toAssocList,[Unit.unit, Std.AssocList, Std.AssocList.nil, Std.AssocList.cons, PProd.fst]]
[Lean.Elab.Command.elabDeclareSyntaxCat,[Bind.bind, Lean.MonadEnv.getEnv, liftM, Lean.Parser.registerParserCategory, Lean.setEnv, Lean.Name.anonymous, Lean.Name.num, Lean.Elab.Command.CommandElabM, Unit, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, List.toArray, List.cons, List.nil, Lean.Syntax.atom, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Lean.mkIdent, Prod.mk, Lean.Quote.quote, Lean.Parser.maxPrec, Lean.Elab.Command.elabCommand, PUnit.unit]]
[Lean.Elab.Term.Do.ToCodeBlock.Catch.codeBlock,[]]
[Lean.Elab.Term.Do.ToTerm.seqToTerm,[Lean.withRef, Lean.MonadQuotation.withFreshMacroScope, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadReader.read, Lean.Elab.Term.Do.ToTerm.Context.m, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk]]
[Std.PersistentHashMap.Stats.noConfusionType,[]]
[Lean.KernelException.invalidProj.inj,[And.intro]]
[Lean.OpaqueVal.isUnsafe,[]]
[Semiring.ofNat_succ,[]]
[Lean.Elab.Term.Context.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.fixLevelParams,[Bind.bind, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Elab.Term.TermElabM, List, Lean.Name, Lean.Elab.sortDeclLevelParams, Lean.CollectLevelParams.State.params, Lean.throwError, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Array.map, Lean.Elab.PreDefinition.mk, Lean.Elab.PreDefinition.ref, Lean.Elab.PreDefinition.kind, Lean.Elab.PreDefinition.modifiers, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.type, Lean.Elab.PreDefinition.value]]
[Lean.NameSanitizerState.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.elabLetDecl,[Lean.Elab.Term.elabLetDeclCore, Bool.true, Bool.false]]
[Monoid.npow,[]]
[Nat.sub_lt_succ,[Nat.lt_succ_of_le, Nat.sub_le]]
[Lean.Parser.Tactic.match,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.Term.generalizingParam, Lean.Parser.sepBy1, Lean.Parser.Term.matchDiscr, Bool.false, Lean.Parser.Term.optType, Lean.Parser.Tactic.matchAlts]]
[UInt32.mod,[UInt32.mk, HMod.hMod, UInt32.val]]
[Lean.InternalExceptionId.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Command.classTk.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Lean.mkFreshMVarId,[Bind.bind, Lean.mkFreshId, Pure.pure, Lean.MVarId.mk]]
[Lean.Export.instCoeLevelEntry,[Coe.mk, Lean.Export.Entry.level]]
[Lean.Meta.SynthInstance.State.noConfusionType,[]]
[Lean.Position.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[PSigma.mkSkipLeft,[PSigma.mkSkipLeft.proof_1]]
[Bool.true_or,[rfl, Eq.symm, Eq.refl]]
[Lean.Xml.Parser.prolog,[SeqRight.seqRight, optional, Lean.Xml.Parser.XMLdecl, Lean.Parsec.many, Lean.Xml.Parser.Misc, SeqLeft.seqLeft, Lean.Xml.Parser.doctypedecl, Pure.pure, Unit.unit]]
[Lean.Meta.MatcherApp.addArg,[Lean.Meta.lambdaTelescope, Lean.Meta.MatcherApp.motive, ite, Eq, BEq.beq, Array.size, Lean.Meta.MatcherApp.discrs, Bool.true, Bind.bind, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.Parser.Tactic.rcasesPat.clear,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Lean.TheoremVal.toConstantVal,[]]
[EST,[EStateM]]
[Lean.ScopedEnvExtension.ScopedEntries.map,[]]
[Lean.Server.Watchdog.FileWorker.pendingRequestsRef,[]]
[Function.update,[dite, Eq, Eq.symm]]
[Std.HashMapImp.foldBuckets,[Id.run, Std.HashMapImp.foldBucketsM]]
[Lean.PrefixTreeNode.foldMatchingM,[Lean.PrefixTreeNode.foldMatchingM.find, Lean.PrefixTreeNode.foldMatchingM.fold]]
[Lean.Parser.Command.mkIffOfInductiveProp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser]]
[Std.PersistentHashMap.CollisionNode,[Subtype, Std.PersistentHashMap.IsCollisionNode]]
[Lean.IR.containsDecl',[ite, Eq, Array.any, BEq.beq, Lean.IR.Decl.name, OfNat.ofNat, Array.size, Bool.true, Pure.pure, Bind.bind, MonadState.get, Lean.SMap.contains, Lean.SimplePersistentEnvExtension.getState, Lean.IR.declMapExt, Lean.IR.CompilerState.env]]
[USize.shiftRight,[USize.mk, HShiftRight.hShiftRight, USize.val, USize.modn, System.Platform.numBits]]
[Lean.instBEqDataValue,[BEq.mk, Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofName, Lean.DataValue.ofNat, Lean.DataValue.ofInt, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.PPContext.mk.inj,[And.intro]]
[Nat.coprime.pow_right,[Nat.coprime.symm, Nat.coprime.pow_left]]
[Lean.Core.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Core.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.prefix.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.Parser.symbol.parenthesizer]]
[Nat.mod.inductionOn,[Nat.div.inductionOn]]
[Except.error.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Export.State.noConfusionType,[]]
[eq_true_of_ne_false,[Eq, Bool.true, rfl, False.elim]]
[Lean.PPContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Tactic.Ring.RingM,[ReaderT, Tactic.Ring.Cache, StateRefT', IO.RealWorld, Tactic.Ring.State, Lean.Meta.MetaM]]
[Std.PersistentArray.instToStringStats,[ToString.mk, Std.PersistentArray.Stats.toString]]
[Lean.Elab.Term.SyntheticMVarDecl.kind,[]]
[Lean.Parser.Term.bracketedBinder.quot,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.incQuotDepth, Lean.Parser.evalInsideQuot, Lean.Parser.Term.bracketedBinder, Bool.false]]
[Lean.FromJson.fromJson?,[]]
[Lean.Meta.Closure.visitLevel,[ite, Eq, and, not, Lean.Level.hasMVar, Lean.Level.hasParam, Bool.true, Pure.pure, Bind.bind, MonadState.get, Unit.unit, Lean.Meta.Closure.ClosureM, Lean.Level, Std.HashMap.find?, Lean.Meta.Closure.State.visitedLevel, modify, Lean.Meta.Closure.State.mk, Std.HashMap.insert, Lean.Meta.Closure.State.visitedExpr, Lean.Meta.Closure.State.levelParams, Lean.Meta.Closure.State.nextLevelIdx, Lean.Meta.Closure.State.levelArgs, Lean.Meta.Closure.State.newLocalDecls, Lean.Meta.Closure.State.newLocalDeclsForMVars, Lean.Meta.Closure.State.newLetDecls, Lean.Meta.Closure.State.nextExprIdx, Lean.Meta.Closure.State.exprMVarArgs, Lean.Meta.Closure.State.exprFVarArgs, Lean.Meta.Closure.State.toProcess]]
[Lean.IR.FnBody.setTag.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Syntax.mkLit,[Lean.mkNode, List.toArray, List.cons, List.nil]]
[Lean.Elab.Term.addTermInfo,[Functor.discard, Lean.Elab.withInfoContext', Pure.pure, Unit.unit, Lean.Elab.Term.mkTermInfo]]
[Nat.instCommSemiringNat.proof_2,[of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.pow_succ, Nat.mul_comm, HPow.hPow, eq_self, HMul.hMul]]
[Subset.noConfusionType,[]]
[Lean.Lsp.instFromJsonTextDocumentChangeRegistrationOptions,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, Lean.Lsp.DocumentSelector, Lean.Lsp.TextDocumentSyncKind, Pure.pure, Lean.Lsp.TextDocumentChangeRegistrationOptions.mk]]
[Lean.Parser.Tactic.contrapose,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol]]
[Lean.Meta.withIncRecDepth,[Lean.Meta.mapMetaM, Lean.withIncRecDepth]]
[String.Range.toLspRange,[Lean.Lsp.Range.mk, Lean.FileMap.utf8PosToLspPos, String.Range.start, String.Range.stop]]
[instDecidableEqQuotient.proof_2,[absurd, Quotient.exact]]
[Lean.Elab.Tactic.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.charLitFnAux,[ite, Eq, String.atEnd, Bool.true, Lean.Parser.ParserState.mkEOIError, List.nil, Lean.Parser.ParserState.hasError, BEq.beq, Char.ofNat, Lean.Parser.mkNodeToken, Lean.charLitKind, Lean.Parser.ParserState.mkUnexpectedError]]
[Lean.Expr.ReplaceImpl.initCache,[Lean.Expr.ReplaceImpl.State.mk, Array.mkArray, USize.toNat, Lean.Expr.ReplaceImpl.cacheSize, cast, Lean.Expr.ReplaceImpl.initCache.proof_1, Unit.unit, arbitrary]]
[Lean.Elab.Command.instMonadLiftTIOCommandElabM,[MonadLiftT.mk, Lean.Elab.Command.liftIO]]
[Lean.Parser.Term.letMVar.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.termParser.formatter]]
[Lean.Meta.delta?,[Lean.matchConst, Lean.Expr.getAppFn, Pure.pure, Option.none, ite, Eq, and, Lean.ConstantInfo.name, Lean.ConstantInfo.hasValue, BEq.beq, List.length, Lean.ConstantInfo.levelParams, Bool.true, Option.some, Lean.Expr.betaRev, Lean.Expr.getAppRevArgs]]
[Lean.IR.ExplicitBoxing.getResultType,[Functor.map, Lean.IR.ExplicitBoxing.BoxingContext.resultType, MonadReader.read]]
[Lean.Parser.checkColGeFn,[Unit.unit, Lean.Parser.ParserState, Lean.Parser.ParserContext.savedPos?, ite, GE.ge, Lean.Position.column, Lean.Parser.ParserState.mkError]]
[Lean.Meta.assertAfter,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarTag, Lean.Meta.getMVarType, Lean.Meta.getLocalDecl, Lean.MonadLCtx.getLCtx, Lean.Meta.getLocalInstances, Lean.Meta.mkForallFVars, Bool.false, Lean.Meta.mkFreshExprMVarAt, Lean.MetavarKind.syntheticOpaque, OfNat.ofNat, Lean.Meta.assignExprMVar, Lean.mkAppN, Lean.Meta.intro1P, Lean.Expr.mvarId!, Lean.Meta.MetaM, Lean.Meta.AssertAfterResult, Lean.Meta.introNP, Array.size, Pure.pure, Lean.Meta.AssertAfterResult.mk]]
[AddMonoid.toZero,[]]
[Lean.Parser.Tactic.Conv.conv.quot,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[Array.getIdx?,[Array.findIdx?, BEq.beq]]
[Lean.Meta.TransparencyMode.noConfusion,[noConfusionEnum, Lean.Meta.TransparencyMode.toCtorIdx]]
[Lean.registerPersistentEnvExtensionUnsafe,[Bind.bind, ST.Ref.get, Lean.persistentEnvExtensionsRef, ite, Eq, Array.any, BEq.beq, Lean.PersistentEnvExtension.name, Lean.PersistentEnvExtensionDescr.name, OfNat.ofNat, Array.size, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString, Pure.pure, PUnit.unit]]
[Lean.Parser.Term.haveIdLhs,[HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Term.ident, Lean.Parser.many, Lean.Parser.ppSpace, HOrElse.hOrElse, Lean.Parser.Term.simpleBinderWithoutType, Lean.Parser.Term.bracketedBinder, Bool.false, Lean.Parser.Term.optType]]
[Lean.mkMDataEx,[Lean.mkMData]]
[Lean.Elab.Command.expandDeclId,[Bind.bind, Lean.MonadResolveName.getCurrNamespace, Lean.Elab.Command.getLevelNames, Lean.Elab.expandDeclId]]
[Std.ShareCommon.State.empty,[Std.ShareCommon.mkState, Unit.unit]]
[forall_prop_decidable.proof_2,[absurd]]
[UInt16.instSemiringUInt16.proof_13,[UInt16.eq_of_val_eq, Eq.mpr, congrArg, Eq, Fin.ofNat', HAdd.hAdd, OfNat.ofNat, Fin.size_positive', UInt16.val, Eq.trans, UInt16.mk, UInt16.one_def, UInt16.add_def]]
[Std.HashMapImp.find?.proof_1,[Subtype.property]]
[Lean.HeadIndex.lit.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[rawNatLit,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Lean.Elab.Term.Do.DoIfView.elseBranch,[]]
[List.headD,[]]
[Lean.Lsp.Range.mk.inj,[And.intro]]
[Lean.MetavarContext.exprDependsOn,[Lean.MetavarContext.findExprDependsOn, BEq.beq]]
[Std.AssocList.erase,[Unit.unit, Std.AssocList, Std.AssocList.nil, BEq.beq, Std.AssocList.cons, PProd.fst]]
[UInt8.instRingUInt8.proof_5,[UInt8.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, UInt8.val, congrFun, HAdd.hAdd, UInt8.neg_def, UInt8.add_def, UInt8.mk, Neg.neg, add_left_neg, UInt8.zero_def, eq_true_of_decide, Eq.refl, Bool.true]]
[Lean.PrettyPrinter.Formatter.checkNoImmediateColon.formatter,[Pure.pure, Unit.unit]]
[Lean.Server.FileWorker.handleDidChange,[Bind.bind, MonadState.get, Pure.pure, Lean.Lsp.VersionedTextDocumentIdentifier.version?, Option.none, Lean.Server.FileWorker.WorkerM, Unit, ite, LE.le, Lean.Server.DocumentMeta.version, Lean.Server.FileWorker.EditableDocument.meta, liftM, IO.eprintln, HAppend.hAppend, ToString.toString, Not, Eq, Array.isEmpty, Bool.true, Lean.Server.FileWorker.updateDocument, Lean.Server.DocumentMeta.mk, Lean.Lsp.VersionedTextDocumentIdentifier.uri, PUnit.unit, IO.throwServerError]]
[Nat.sub_succ,[rfl]]
[ST.Ref.get,[liftM, ST.Prim.Ref.get]]
[List.mapIdxM.loop,[List, Pure.pure, List.nil, Seq.seq, Functor.map, List.cons, PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[Lean.MessageLog.mk.injEq,[Eq.propIntro, Eq.refl, Lean.MessageLog.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.Expr.unbox.injEq,[Eq.propIntro, Eq.refl, Lean.IR.Expr.unbox, Eq.symm, eq_of_heq, HEq.refl]]
[Std.HashMapImp.size,[]]
[Lean.Elab.Term.SavedContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Tactic.evalTacticAt,[Bind.bind, Lean.Elab.Tactic.getGoals, tryFinally, Lean.Elab.Tactic.setGoals, List.cons, List.nil, Lean.Elab.Tactic.evalTactic, Lean.Elab.Tactic.pruneSolvedGoals]]
[Lean.Meta.reduceRecMatcher?,[ite, Eq, not, Lean.Expr.isApp, Bool.true, Pure.pure, Option.none, Bind.bind, Lean.Meta.reduceMatcher?, Lean.Meta.ReduceMatcherResult.stuck, Lean.Meta.ReduceMatcherResult.notMatcher, Lean.Meta.ReduceMatcherResult.partialApp, Lean.Meta.MetaM, Option, Lean.Expr, Option.some, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Meta.getConst?, Unit.unit, Lean.Expr.getAppFn, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, dite, LT.lt, Array.size, Lean.Meta.whnf, Lean.RecursorVal.k, Lean.Meta.inferType, Lean.Meta.instantiateMVars, Lean.Expr.isConstOf, Lean.RecursorVal.getInduct, and, Lean.Expr.hasExprMVar, Subarray.any, Array.toSubarray, Lean.RecursorVal.numParams, Lean.Meta.getConstNoEx?, Lean.ConstantInfo.quotInfo, Lean.InductiveVal.mk, Lean.ConstantVal.mk, List.nil, Lean.ConstantInfo.recInfo, Lean.Name, Lean.mkAppN, Lean.mkConst, Array.shrink, Lean.Expr.getAppArgs, Lean.Meta.isDefEq, PUnit.unit, Lean.QuotKind.type, Lean.QuotKind.ctor, Lean.QuotVal.kind, OfNat.ofNat, Lean.Meta.isAuxDef, Lean.ConstantInfo.name, bne, List.length, Lean.ConstantInfo.levelParams, Lean.Expr.getAppRevArgs]]
[Lean.Elab.Command.getMainModule,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Environment.mainModule]]
[instToStringFormat,[ToString.mk, Std.Format.pretty, Std.Format.defWidth]]
[Lean.Lsp.instBEqPublishDiagnosticsParams,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Meta.Simp.instInhabitedMethods,[Inhabited.mk, Lean.Meta.Simp.Methods.mk, arbitrary]]
[Lean.IR.ExplicitBoxing.castVarIfNeeded,[Bind.bind, Lean.IR.ExplicitBoxing.getVarType, ite, Eq, Lean.IR.ExplicitBoxing.eqvTypes, Bool.true, getModify, Lean.IR.ExplicitBoxing.BoxingState.mk, HAdd.hAdd, Lean.IR.ExplicitBoxing.BoxingState.nextIdx, OfNat.ofNat, Lean.IR.ExplicitBoxing.BoxingState.auxDecls, Lean.IR.ExplicitBoxing.BoxingState.auxDeclCache, Lean.IR.ExplicitBoxing.BoxingState.nextAuxId, Pure.pure, Lean.IR.VarId.mk, Lean.IR.ExplicitBoxing.mkCast, Functor.map, Lean.IR.FnBody.vdecl]]
[List.product_spec,[Iff.intro, Eq.mpr, Eq.trans, implies_congr, propext, List.mem_bind, congrArg, Exists, funext, And, Mem.mem, List.mem_map, Prod.mk.injEq, exists_eq_right_right', Eq.refl, and_imp, And.intro, id]]
[List.isPrefixOf,[List.nil, List.cons, Bool, Bool.true, Bool.false, and, BEq.beq, PProd.fst]]
[instInhabitedPUnit,[Inhabited.mk, PUnit.unit]]
[List.mem_append_left,[Iff.mpr, List.mem_append, Or.inl]]
[Lean.Compiler.SpecializeAttributeKind.specialize.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Server.Watchdog.OpenDocument.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Server.Watchdog.OpenDocument.mk, Eq.symm, eq_of_heq, HEq.refl]]
[instSubUInt64,[Sub.mk, UInt64.sub]]
[Lean.Widget.TaggedText.append.injEq,[Eq.propIntro, Eq.refl, Lean.Widget.TaggedText.append, Eq.symm, eq_of_heq, HEq.refl]]
[Std.MonadShareCommon.withShareCommon,[]]
[CommMonoid.toMonoid,[]]
[Fin.instSubFin,[Sub.mk, Fin.sub]]
[Lean.Parser.Term.optIdent.formatter,[Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.ident.formatter, Lean.Parser.symbol.formatter]]
[Lean.Meta.IndPredBelow.BrecOnVariables.witness,[]]
[Lean.Elab.defaultHandler,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.instToJsonOption,[Lean.ToJson.mk, Unit.unit, Lean.Json, Lean.Json.null, Lean.ToJson.toJson]]
[Lean.Parser.registerBuiltinNodeKind,[ST.Ref.modify, Lean.Parser.builtinSyntaxNodeKindSetRef, Lean.Parser.SyntaxNodeKindSet.insert]]
[Lean.Meta.AbstractNestedProofs.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Lsp.instToJsonServerCapabilities,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Lean.Json.opt, Lean.Lsp.ServerCapabilities.textDocumentSync?, Lean.Lsp.ServerCapabilities.completionProvider?, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.ServerCapabilities.hoverProvider, List.nil, Lean.Lsp.ServerCapabilities.documentHighlightProvider, Lean.Lsp.ServerCapabilities.documentSymbolProvider, Lean.Lsp.ServerCapabilities.definitionProvider, Lean.Lsp.ServerCapabilities.declarationProvider, Lean.Lsp.ServerCapabilities.typeDefinitionProvider, Lean.Lsp.ServerCapabilities.referencesProvider, Lean.Lsp.ServerCapabilities.semanticTokensProvider?]]
[Nat.add_right_cancel,[Nat.add_left_cancel, Eq.mp, Eq.refl, Eq, HAdd.hAdd, Nat.add_comm]]
[Lean.inaccessible?,[Lean.annotation?, Lean.Name.mkStr, Lean.Name.anonymous]]
[DoResultSBC.pureReturn.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Array.map,[Id.run, Array.mapM]]
[IO.Process.Child.stderr,[]]
[Lean.Meta.Match.CounterExample,[List, Lean.Meta.Match.Example]]
[Lean.instToExprDeclarationRange,[Lean.ToExpr.mk, Lean.mkAppN, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, List.toArray, List.cons, Lean.ToExpr.toExpr, Lean.DeclarationRange.pos, Lean.DeclarationRange.charUtf16, Lean.DeclarationRange.endPos, Lean.DeclarationRange.endCharUtf16]]
[Lean.Meta.InferTypeCache,[Lean.PersistentExprStructMap, Lean.Expr]]
[Lean.Elab.Term.State.infoState,[]]
[Lean.Parser.optionaInfo,[Lean.Parser.ParserInfo.mk, Lean.Parser.ParserInfo.collectTokens, Lean.Parser.ParserInfo.collectKinds, Lean.Parser.FirstTokens.toOptional, Lean.Parser.ParserInfo.firstTokens]]
[Nat.zero_min,[min_eq_left, Nat.zero_le]]
[Lean.Elab.Term.LetRecView.body,[]]
[UInt8.instSemiringUInt8.proof_5,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, congrFun, HMul.hMul, UInt8.zero_def, UInt8.mul_def, UInt8.mk, OfNat.ofNat, MonoidWithZero.zero_mul, UInt8.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt8]]
[Lean.Parser.group,[Lean.Parser.node, Lean.groupKind]]
[Lean.Parser.Level.num,[HAndThen.hAndThen, Lean.Parser.checkPrec, Lean.Parser.maxPrec, Lean.Parser.numLit]]
[Lean.IR.LocalContext.isLocalVar,[Option.none, Option.some, Lean.IR.LocalContextEntry.param, Lean.IR.LocalContextEntry.joinPoint, Bool, Std.RBMap.find?, Bool.true, Bool.false]]
[Lean.Meta.SynthInstance.instInhabitedAnswer,[Inhabited.mk, Lean.Meta.SynthInstance.Answer.mk, arbitrary, OfNat.ofNat]]
[Lean.Lsp.instToJsonDidCloseTextDocumentParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.DidCloseTextDocumentParams.textDocument, List.nil]]
[Lean.Syntax.mkAntiquotNode,[Lean.mkNode, HAppend.hAppend, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkAtom, List.nil]]
[Lean.Lsp.instToJsonTextEditBatch,[Lean.ToJson.mk, Lean.ToJson.toJson]]
[Repr.noConfusionType,[]]
[Lean.Meta.FVarSubst.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.FVarSubst.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.CollectPatternVars.Context.noConfusionType,[]]
[Lean.Parser.Parser.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.MkInstResult.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[String.Range.noConfusionType,[]]
[Lean.Rat.add,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, HAdd.hAdd, HMul.hMul, Lean.Rat.num, Int.ofNat, Lean.Rat.den, HDiv.hDiv]]
[Lean.Parser.Command.openRenaming.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.sepBy1.parenthesizer, Lean.Parser.Command.openRenamingItem.parenthesizer, Bool.false]]
[Lean.instMonadTrace,[Lean.MonadTrace.mk, liftM, Lean.MonadTrace.modifyTraceState, Lean.MonadTrace.getTraceState]]
[instShiftLeftUInt8,[ShiftLeft.mk, UInt8.shiftLeft]]
[Nat.coprime.gcd_mul,[Nat.dvd_antisymm, Nat.gcd_mul_dvd_mul_gcd, Nat.coprime.mul_dvd_of_dvd_of_dvd, Nat.coprime.gcd_both, Nat.gcd_dvd_gcd_mul_right_right, Nat.gcd_dvd_gcd_mul_left_right]]
[Lean.Name.hasMacroScopes,[Lean.Name.anonymous, Bool, BEq.beq, PProd.fst, Bool.false]]
[Subarray.popFront,[dite, LT.lt, Subarray.start, Subarray.stop, Subarray.mk, Subarray.as, HAdd.hAdd, OfNat.ofNat, Subarray.popFront.proof_1, Subarray.h₂]]
[Lean.Elab.Term.elabDoubleQuotedName,[Bind.bind, Lean.Elab.resolveGlobalConstNoOverloadWithInfo, Lean.Syntax.getOp, OfNat.ofNat, Option.none, Pure.pure, Lean.ToExpr.toExpr]]
[Lean.Lsp.instFromJsonRpcCallParams,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Lean.Lsp.TextDocumentIdentifier, Lean.Lsp.Position, UInt64, Lean.Name, Lean.Json, Pure.pure, Lean.Lsp.RpcCallParams.mk, Lean.Lsp.TextDocumentPositionParams.mk]]
[Lean.Elab.Term.MutualClosure.FixPoint.run,[Lean.Elab.Term.MutualClosure.UsedFVarsMap, Lean.Elab.Term.MutualClosure.FixPoint.State.usedFVarsMap]]
[Lean.Server.RpcEncoding.DerivingParams.noConfusionType,[]]
[Lean.Meta.ToHide.State.mk.inj,[And.intro]]
[or_iff_not_imp_right,[Decidable.or_iff_not_imp_right]]
[Lean.Environment.allImportedModuleNames,[Lean.EnvironmentHeader.moduleNames, Lean.Environment.header]]
[Lean.Parser.Tactic.continue,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser]]
[Lean.Rat.instLTRat,[LT.mk, Eq, Lean.Rat.lt, Bool.true]]
[Lean.SSet.contains,[Lean.SMap.contains]]
[Lean.Server.publishDiagnostics,[IO.FS.Stream.writeLspNotification, Lean.JsonRpc.Notification.mk, Lean.Lsp.PublishDiagnosticsParams.mk, Lean.Server.DocumentMeta.uri, Option.some, Int.ofNat, Lean.Server.DocumentMeta.version]]
[Lean.Environment.getNamespaceSet,[Lean.SimplePersistentEnvExtension.getState, Lean.namespacesExt]]
[Lean.MetavarDecl.localInstances,[]]
[Lean.Meta.SynthInstance.GeneratorNode.mk.inj,[And.intro]]
[Array.mapIdxM.map.proof_2,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, OfNat.ofNat, Array.size, Eq.symm, Nat.add_comm, Nat.add_assoc, rfl]]
[Lean.Elab.Term.StructInst.FieldLHS.fieldIndex.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.byCases',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.IR.mkExternDecl,[Lean.IR.Decl.extern]]
[Lean.Meta.Simp.preDefault,[Lean.Meta.Simp.tryRewriteCtorEq, Lean.Meta.Simp.rewritePre]]
[Lean.Meta.mkHCongrWithArity.withNewEqs,[OfNat.ofNat, List.toArray, List.nil, Lean.Meta.mkHCongrWithArity.withNewEqs.loop]]
[Lean.Attribute.Builtin.getIdent?,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, and, not, Lean.Syntax.isNone, Lean.Syntax.getOp, OfNat.ofNat, Lean.Syntax.isIdent, Pure.pure, Option.some, Option.none, or, Lean.throwErrorAt, Lean.ToMessageData.toMessageData]]
[Lean.Parser.Tactic.skip,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.instReprDeclarationRange,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.DeclarationRange.pos, Std.Format.line, Lean.DeclarationRange.charUtf16, Lean.DeclarationRange.endPos, Lean.DeclarationRange.endCharUtf16]]
[Lean.Meta.exfalso,[Lean.Meta.withMVarContext, Bind.bind, Lean.observing?, Lean.Meta.mkFreshLevelMVar, Lean.Meta.apply, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil, Option.none, Option.some, Lean.Meta.MetaM, Lean.MVarId, Pure.pure, Lean.Meta.throwTacticEx, Lean.Syntax.missing]]
[Lean.Parser.group.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.node.parenthesizer, Lean.groupKind]]
[Lean.Server.FileWorker.EditableDocument.headerSnap,[]]
[Lean.KVMap.instValueNat,[Lean.KVMap.Value.mk, Lean.DataValue.ofNat, Lean.DataValue.ofString, Lean.DataValue.ofBool, Lean.DataValue.ofName, Lean.DataValue.ofInt, Option, Nat, Option.some, Option.none]]
[List.ibelow,[True, And]]
[Lean.MonadResolveName.getOpenDecls,[]]
[Lean.Meta.AltVarNames.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.AltVarNames.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Do.ToCodeBlock.getTryCatchUpdatedVars,[]]
[Lean.instInhabitedFVarIdMap,[Inhabited.mk, EmptyCollection.emptyCollection]]
[Lean.Parser.Term.optSemicolon.formatter,[Lean.ppDedent.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.symbol.formatter, Lean.ppLine.formatter]]
[Int.negSucc.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Command.withLogging,[MonadExcept.tryCatch, Lean.Elab.Command.CommandElabM, Unit, Lean.Elab.logException, ite, Eq, Lean.Elab.isAbortExceptionId, Bool.true, Pure.pure, Unit.unit, Bind.bind, Lean.Elab.Command.liftIO, Lean.InternalExceptionId.getName, Lean.Elab.logError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Nat.zero_lt_succ,[Nat.succ_le_succ, Nat.zero_le]]
[Lean.Parser.Command.whereStructField,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.Term.letDecl]]
[Lean.Elab.Command.elabClassInductive,[Bind.bind, Lean.Elab.Command.checkValidInductiveModifier, Lean.Elab.Command.CommandElabM, Lean.Elab.Command.InductiveView, Lean.Elab.Command.expandDeclId, Lean.Elab.addDeclarationRanges, Array.mapM, Lean.withRef, Lean.Elab.elabModifiers, Lean.Syntax.getOp, OfNat.ofNat, ite, Eq, and, Lean.Elab.Modifiers.isPrivate, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Syntax.getArgs, Lean.Elab.getOptDerivingClasses, Lean.Elab.Command.InductiveView.mk, Lean.Elab.Command.elabInductiveViews, List.toArray, List.cons, List.nil]]
[Lean.MetavarContext.MkBinding.reduceLocalContext,[Array.foldr, Lean.LocalContext.erase, Lean.Expr.fvarId!, Array.size, OfNat.ofNat]]
[Lean.Elab.Term.elabBorrowed,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.Term.elabTerm, Pure.pure, Lean.markBorrowed, Lean.Elab.throwUnsupportedSyntax]]
[OptionT.pure,[OptionT.mk, Pure.pure, Option.some]]
[Lean.Elab.Term.StructInst.Struct.modifyFieldsM,[Lean.Elab.Term.StructInst.Struct, Bind.bind, Pure.pure, Lean.Elab.Term.StructInst.Struct.mk]]
[Lean.Json.CompressWorkItem.objectEnd.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.CommandInfo.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Elab.CommandInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Exception.toMessageData,[Lean.MessageData, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.InternalExceptionId.toString]]
[Lean.Core.instMetaEvalCoreM,[Lean.MetaEval.mk, Bind.bind, Lean.Core.CoreM.toIO, Lean.Core.Context.mk, Lean.Option.get, Lean.maxRecDepth, Lean.Core.State.mk, IO, Lean.Environment, Lean.MetaEval.eval, Lean.Core.State.env, Bool.true]]
[Lean.registerTagAttribute,[Bind.bind, Lean.registerPersistentEnvExtension, Lean.PersistentEnvExtensionDescr.mk, Pure.pure, EmptyCollection.emptyCollection, Lean.NameSet.insert, Array.qsort, Lean.Name.quickLt, OfNat.ofNat, HSub.hSub, Array.size, HAppend.hAppend, Std.Format.text, Std.Format.line, Std.ToFormat.format, Std.RBMap.size, Lean.registerBuiltinAttribute, Lean.TagAttribute.mk]]
[Lean.Meta.GetUnfoldEqnFn,[Lean.Meta.MetaM, Option, Lean.Name]]
[Lean.instToJsonBool,[Lean.ToJson.mk, Lean.Json.bool]]
[Lean.Parser.Command.elab_rules.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.suppressInsideQuot.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.Parser.Command.docComment.formatter, Lean.Parser.Term.attrKind.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.optKind.formatter, Lean.Parser.ident.formatter, Lean.Parser.Term.matchAlts.formatter, Lean.Parser.termParser.formatter]]
[Lean.Meta.ToHide.collect,[Bind.bind, Lean.MonadOptions.getOptions, ite, Eq, Lean.Option.get, Lean.Meta.pp.inaccessibleNames, Bool.true, Pure.pure, Prod.mk, EmptyCollection.emptyCollection, Lean.MonadLCtx.getLCtx, StateRefT'.run, ReaderT.run, Lean.Meta.ToHide.fixpoint, Lean.Meta.ToHide.Context.mk, Lean.Meta.ToHide.State.mk, Lean.Meta.MetaM, Prod, Lean.FVarIdSet, Lean.Meta.ToHide.State.hiddenInaccessible, Lean.Meta.ToHide.State.hiddenInaccessibleProp]]
[«term_<=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Term.ellipsis.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.Parser.symbol.formatter]]
[Lean.mkDecIsTrue,[Lean.mkAppB, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Lean.Syntax.getAntiquotSuffixSpliceInner,[Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.Parser.Syntax.sepBy1.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.many1.formatter, Lean.Parser.syntaxParser.formatter, Lean.Parser.strLit.formatter, Lean.Parser.optional.formatter, Lean.Parser.nonReservedSymbol.formatter, Bool.false]]
[Lean.Lsp.Range.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instDecidableTrue,[Decidable.isTrue, trivial]]
[Lean.Expr.lam.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.assignExprMVar,[Lean.MonadMCtx.modifyMCtx, Lean.MetavarContext.assignExpr]]
[Char.ofNat.proof_2,[Or.inl, of_decide_eq_true, Eq.refl, Bool.true]]
[Lean.Meta.DiscrTree.format,[Std.Format, Std.Format.group, Std.Format.FlattenBehavior.allOrNone]]
[precMax,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[List.eq_of_mem_singleton,[Or.elim, List.eq_or_mem_of_mem_cons, absurd, List.not_mem_nil]]
[List.map_append,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.map, List.nil_append, congrFun, HAppend.hAppend, List.map_nil, eq_self, List.cons_append, List.map_cons, List.cons]]
[Lean.PrettyPrinter.instOrElseParenthesizerM,[OrElse.mk, Lean.PrettyPrinter.ParenthesizerM.orElse]]
[StdGen.s1,[]]
[Std.RBNode.fold,[PProd.fst, PProd.snd]]
[Lean.Meta.CongrLemmas.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.CongrLemmas.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Json.toStructured?,[Lean.FromJson.fromJson?, Lean.ToJson.toJson]]
[Lean.JsonRpc.Request.param,[]]
[instHashableUInt16,[Hashable.mk, UInt16.toUInt64]]
[Lean.Elab.Tactic.ElimApp.Context.targets,[]]
[Lean.Parser.Tactic.measurability!?,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.MetavarContext.MkBinding.Exception.revertFailure.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.mkBaseNameFor,[ite, Eq, not, Lean.Environment.contains, HAppend.hAppend, Bool.true, OfNat.ofNat, Lean.mkBaseNameFor.go]]
[Array.findSome?,[Id.run, Array.findSomeM?]]
[Lean.Parsec.pchar,[Lean.Parsec.attempt, Bind.bind, Lean.Parsec.anyChar, ite, Eq, Pure.pure, Lean.Parsec.fail, HAppend.hAppend, ToString.toString]]
[Lean.Parser.Command.open.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.withPosition.formatter, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Command.openDecl.formatter]]
[Lean.Lsp.ClientCapabilities.noConfusion,[noConfusionEnum, Lean.Lsp.ClientCapabilities.toCtorIdx]]
[Lean.Elab.Term.MatchAltView.mk.inj,[And.intro]]
[Lean.SimplePersistentEnvExtension.modifyState,[Lean.PersistentEnvExtension.modifyState, Prod, List, Prod.mk]]
[Lean.Meta.instBEqInfoCacheKey,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false]]
[Lean.Elab.Command.StructView.modifiers,[]]
[Lean.registerParametricAttribute,[Bind.bind, Lean.registerPersistentEnvExtension, Lean.PersistentEnvExtensionDescr.mk, Lean.AttributeImplCore.name, Lean.ParametricAttributeImpl.toAttributeImplCore, Pure.pure, EmptyCollection.emptyCollection, SeqRight.seqRight, Lean.ParametricAttributeImpl.afterImport, Lean.NameMap.insert, Prod.fst, Prod.snd, Array.qsort, Lean.Name.quickLt, OfNat.ofNat, HSub.hSub, Array.size, HAppend.hAppend, Std.Format.text, Std.Format.line, Std.ToFormat.format, Std.RBMap.size, Lean.registerBuiltinAttribute, Lean.ParametricAttribute.mk]]
[Lean.ScopedEnvExtension.instInhabitedDescr,[Inhabited.mk, Lean.ScopedEnvExtension.Descr.mk, arbitrary]]
[ReaderT.run_bind,[rfl]]
[Lean.ConstructorVal.mk.inj,[And.intro]]
[Lean.mkSimpleFnCall,[HAppend.hAppend, List.foldl, List.intersperse]]
[Lean.Meta.Match.Alt.checkAndReplaceFVarId,[Unit.unit, Lean.Meta.MetaM, Lean.Meta.Match.Alt, List.find?, BEq.beq, Lean.LocalDecl.fvarId, Lean.Meta.Match.Alt.fvarDecls, Lean.throwErrorAt, Lean.Meta.Match.Alt.ref, Lean.ToMessageData.toMessageData, Bind.bind, Lean.Meta.inferType, Lean.Meta.isDefEqGuarded, Lean.LocalDecl.type, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.Meta.withExistingLocalDecls, Lean.Meta.addPPExplicitToExposeDiff, PUnit, HAppend.hAppend, Lean.mkFVar, Lean.indentExpr]]
[Int.ofNat_mul,[rfl]]
[Lean.Parser.FirstTokens.optTokens.inj,[]]
[Lean.Meta.Simp.SimpLetCase.noConfusion,[noConfusionEnum, Lean.Meta.Simp.SimpLetCase.toCtorIdx]]
[Lean.Elab.Term.Do.getDoLetVars,[Lean.Elab.Term.Do.getLetDeclVars, Lean.Syntax.getOp, OfNat.ofNat]]
[Lean.IR.CtorLayout.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.LeadingIdentBehavior.both.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.KeyedDeclsAttribute.Def.noConfusionType,[]]
[Lean.Lsp.instFromJsonDocumentFilter,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, Option, String, Pure.pure, Lean.Lsp.DocumentFilter.mk]]
[Lean.Meta.Match.mkMatcher,[Lean.Meta.MetaM, Lean.Meta.Match.MatcherResult, Lean.Meta.forallBoundedTelescope, Option.some, Bind.bind, ite, Eq, List.any, bne, List.length, Lean.Meta.Match.AltLHS.patterns, Bool.true, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Meta.getLevel, BEq.beq, Lean.levelZero, Lean.Meta.mkFreshLevelMVar]]
[Lean.Elab.CompletionInfo.dot.inj,[And.intro]]
[Lean.IR.instToStringDecl,[ToString.mk, Lean.IR.declToString]]
[Lean.Parser.Attr.simple,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.ident, Lean.Parser.optional, HOrElse.hOrElse, Lean.Parser.priorityParser]]
[Lean.Meta.RecursorUnivLevelPos.majorType.inj,[]]
[Lean.ConstantInfo.isCtor,[Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.recInfo, Bool, Bool.true, Bool.false]]
[IO.FS.Handle.putStrLn,[IO.FS.Handle.putStr, String.push, Char.ofNat]]
[fix1,[fixCore1, arbitrary]]
[Lean.Widget.MsgEmbed.instToJsonRpcEncodingPacket,[Lean.ToJson.mk, Lean.Json, Lean.Json.mkObj, List.cons, Prod.mk, Lean.ToJson.toJson, List.nil, Lean.Json.arr, List.toArray]]
[Lean.Elab.Term.withoutErrToSorry,[MonadWithReader.withReader, Lean.Elab.Term.Context.mk, Lean.Elab.Term.Context.fileName, Lean.Elab.Term.Context.fileMap, Lean.Elab.Term.Context.declName?, Lean.Elab.Term.Context.macroStack, Lean.Elab.Term.Context.currMacroScope, Lean.Elab.Term.Context.mayPostpone, Bool.false, Lean.Elab.Term.Context.autoBoundImplicit, Lean.Elab.Term.Context.autoBoundImplicits, Lean.Elab.Term.Context.sectionVars, Lean.Elab.Term.Context.sectionFVars, Lean.Elab.Term.Context.implicitLambda, Lean.Elab.Term.Context.isNoncomputableSection]]
[instMonadExceptOfExceptT_1,[MonadExceptOf.mk, ExceptT.mk, Pure.pure, Except.error, ExceptT.tryCatch]]
[Std.RBTree.fromList,[List.foldl, Std.RBTree.insert, Std.mkRBTree]]
[Lean.Lsp.SymbolKind.module.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.MonadNameGenerator.noConfusionType,[]]
[Array.all,[Id.run, Array.allM]]
[fixCore,[fixCore1]]
[Lean.Parser.Term.structInstFieldAbbrev,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.atomic, HAndThen.hAndThen, Lean.Parser.Term.ident, Lean.Parser.notFollowedBy, HOrElse.hOrElse, Lean.Parser.symbol]]
[Lean.getNumBuiltiAttributesImpl,[Bind.bind, ST.Ref.get, Lean.attributeMapRef, Pure.pure, Std.PersistentHashMap.size]]
[«term_↔_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.AbstractNestedProofs.Context.mk.inj,[]]
[Lean.Parser.Tactic.simpa!,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const, Lean.ParserDescr.parser]]
[ExceptT.run_throw,[rfl]]
[Lean.Elab.Deriving.FromToJson.mkFromJsonInstanceHandler.mkAlts,[Bind.bind, Array.mapM, Lean.getConstInfoCtor, Lean.Meta.forallTelescopeReducing, Lean.ConstantVal.type, Lean.ConstructorVal.toConstantVal, ForIn.forIn, MProd.mk, liftM, Lean.Meta.getLocalDecl, Lean.Expr.fvarId!, ite, Eq, not, Lean.Name.hasMacroScopes, Lean.LocalDecl.userName, Bool.true, Pure.pure, PUnit.unit, Lean.Elab.Term.TermElabM, Prod, Lean.Syntax, Nat, Array.mapIdxM, Fin.val, BEq.beq, Array.size, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.ident, String.toSubstring, Lean.addMacroScope, Prod.mk, List.nil, Lean.Syntax.atom, Array.append, Lean.mkSepArray, Array.map, Lean.mkAtom, Lean.InductiveVal.ctors, Prod.fst]]
[Lean.Meta.RewriteResult.eNew,[]]
[Lean.Syntax.find?,[Lean.Syntax.findAux]]
[Lean.Meta.Simp.instInhabitedConfig,[Inhabited.mk, Lean.Meta.Simp.Config.mk, arbitrary]]
[Lean.Meta.PostponedEntry.mk.inj,[And.intro]]
[Lean.Lsp.instFromJsonServerInfo,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, String, Option, Pure.pure, Lean.Lsp.ServerInfo.mk]]
[Std.Range.«term[:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[termPrintln!__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[ByteArray.toSlice,[ByteSlice.mk, OfNat.ofNat, ByteArray.size]]
[Lean.Meta.Context.mk.inj,[And.intro]]
[Lean.Meta.Match.examplesToMessageData,[Lean.MessageData.joinSep, List.map, Function.comp, Lean.Meta.Match.Example.toMessageData, Lean.Meta.Match.Example.varsToUnderscore, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[Lean.Parser.Term.binop_lazy.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.Term.ident.formatter, Lean.ppSpace.formatter, Lean.Parser.termParser.formatter, Lean.Parser.maxPrec]]
[instOrdNat,[Ord.mk, compareOfLessAndEq]]
[Lean.Parser.Error.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Parser.Error.mk, Eq.symm, eq_of_heq, HEq.refl]]
[IO.FileRight.noConfusionType,[]]
[Std.RBTree.depth,[Std.RBMap.depth]]
[Lean.Lsp.DiagnosticWith.severity?,[]]
[panicWithPos,[panic, HAppend.hAppend, ToString.toString]]
[Nat.coprime.coprime_div_right,[Nat.coprime.symm, Nat.coprime.coprime_div_left]]
[Lean.Meta.ToHide.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.ToHide.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.DataValue.ofBool.inj,[]]
[Lean.Elab.Term.Do.ToCodeBlock.Context.mk.inj,[And.intro]]
[Std.PersistentHashSet.fold,[Id.run, Std.PersistentHashSet.foldM]]
[UInt8.instSemiringUInt8.proof_6,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, HMul.hMul, UInt8.zero_def, UInt8.mul_def, UInt8.mk, OfNat.ofNat, MonoidWithZero.mul_zero, UInt8.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt8]]
[Subsingleton.allEq,[]]
[ByteArray.forInUnsafe,[OfNat.ofNat, ByteArray.forInUnsafe.loop]]
[Lean.getPPNotation,[Lean.KVMap.get, Lean.Option.name, Lean.pp.notation, not, Lean.getPPAll]]
[Except.bind,[Except, Except.error]]
[Lean.IR.EmitC.emitNumLit,[ite, Eq, Lean.IR.IRType.isObj, Bool.true, LT.lt, UInt32.size, Bind.bind, Lean.IR.EmitC.emit]]
[Lean.Parser.Command.reduce,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.termParser]]
[Lean.Expr.ReplaceLevelImpl.State.keys,[]]
[Lean.KernelException.toMessageData,[Lean.MessageData, Lean.MessageData.withContext, Lean.MessageDataContext.mk, Lean.MetavarContext.mk, Lean.LocalContext.mk, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Declaration.axiomDecl, Lean.Declaration.opaqueDecl, Lean.Declaration.quotDecl, Lean.Declaration.mutualDefnDecl, Lean.Declaration.inductDecl, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.indentExpr]]
[Lean.Xml.Parser.Eq,[SeqLeft.seqLeft, SeqRight.seqRight, optional, Lean.Xml.Parser.S, Lean.Parsec.skipChar, Char.ofNat]]
[PProd.mk.inj,[And.intro]]
[List.mapIdx,[OfNat.ofNat, List.mapIdx.loop]]
[Nat.lt_le_antisymm,[Nat.le_lt_antisymm]]
[Lean.Parser.Term.doCatchMatch.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.Term.doMatchAlts.parenthesizer]]
[Lean.Meta.isReadOnlyExprMVar,[Bind.bind, Lean.Meta.getMVarDecl, Lean.MonadMCtx.getMCtx, Pure.pure, bne, Lean.MetavarDecl.depth, Lean.MetavarContext.depth]]
[Lean.IR.IRType.union.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, Eq.refl, List.nil, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec]]
[Lean.Elab.CommandInfo.toElabInfo,[]]
[Lean.Macro.instMonadQuotationMacroM,[Lean.MonadQuotation.mk, Pure.pure, Lean.Macro.Context.currMacroScope, Lean.Macro.Context.mainModule, Lean.Macro.withFreshMacroScope]]
[Lean.Parser.optPrecedence.parenthesizer,[Lean.Parser.optional.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.precedence.parenthesizer]]
[Lean.Parser.Tactic.existsi,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[Sigma.noConfusionType,[]]
[Lean.Elab.Term.elabBinders,[Lean.Elab.Term.elabBindersEx, Array.map, Prod.snd]]
[Lean.JsonRpc.instDecidableLt,[inferInstanceAs, Decidable, Eq, Lean.JsonRpc.RequestID.str, Lean.JsonRpc.RequestID.num, Lean.JsonRpc.RequestID.null, Bool, Decidable.decide, LT.lt, Bool.true, Bool.false]]
[Mathlib.Tactic.Ext.commandDeclareExtTheoremsFor__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Lean.Meta.mkLetBodyCongr,[Lean.Meta.mkAppM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, List.nil]]
[Lean.Compiler.atMostOnce,[Bool]]
[Lean.PrefixTree.foldM,[Lean.PrefixTree.foldMatchingM, List.nil]]
[Lean.Meta.cleanup,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, StateRefT'.run', Prod.mk, Bool.false, EmptyCollection.emptyCollection, Lean.MonadLCtx.getLCtx, ForIn.forIn, ite, Eq, Std.RBTree.contains, Lean.LocalDecl.fvarId, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, Lean.Meta.getLocalInstances, Lean.Meta.getMVarType, Lean.Meta.instantiateMVars, Lean.Meta.getMVarTag, Lean.Meta.mkFreshExprMVarAt, Lean.MetavarKind.syntheticOpaque, OfNat.ofNat, Lean.Meta.assignExprMVar, Lean.Expr.mvarId!, Lean.Meta.cleanup.addUsedFVars, Lean.Meta.cleanup.addDeps, Lean.Meta.cleanup.addUsedFVar, Lean.Meta.cleanup.collectPropsStep, Lean.Meta.cleanup.collectProps, Lean.Meta.cleanup.collectUsed]]
[IO.Error.noFileOrDirectory.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.noFileOrDirectory, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Term.Context.fileMap,[]]
[Lean.Elab.throwAlreadyDeclaredUniverseLevel,[Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Lean.Xml.Parser.Nmtoken,[Lean.Parsec.many1Chars, Lean.Xml.Parser.NameChar]]
[Lean.Lsp.SymbolKind.namespace.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Elab.Term.elabBinRelNoProp,[Lean.Elab.Term.elabBinRelCore, Bool.true]]
[Lean.Meta.DiscrTree.Trie.below,[PProd, PUnit]]
[Lean.MessageData.ofName.injEq,[Eq.propIntro, Eq.refl, Lean.MessageData.ofName, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Command.noncomputableSection.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.ident.parenthesizer]]
[Lean.KernelException.declTypeMismatch.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.KernelException.declTypeMismatch, Eq.symm, eq_of_heq, HEq.refl]]
[congr_fun,[congrFun]]
[Lean.PrettyPrinter.Parenthesizer.ident.parenthesizer,[Lean.Parser.Term.ident.parenthesizer]]
[Lean.Elab.CompletionInfo.id.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.CompletionInfo.id, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.IR.EmitC.emitFullApp,[Bind.bind, Lean.IR.EmitC.emitLhs, Lean.IR.EmitC.getDecl, Lean.IR.Decl.fdecl, Lean.IR.EmitC.M, Unit, Lean.IR.EmitC.emitExternCall, Lean.IR.EmitC.emitCName, ite, GT.gt, Array.size, OfNat.ofNat, Lean.IR.EmitC.emit, Lean.IR.EmitC.emitArgs, Pure.pure, PUnit.unit]]
[String.revFind,[ite, Eq, BEq.beq, String.bsize, OfNat.ofNat, Bool.true, Option.none, String.revFindAux, String.prev]]
[Lean.Meta.Match.Example.val.inj,[]]
[Lean.PPFns.ppTerm,[]]
[Lean.Meta.Cases.Context.majorTypeFn,[]]
[Lean.Lsp.instFileSourceRpcConnectParams,[Lean.Lsp.FileSource.mk, Lean.Lsp.RpcConnectParams.uri]]
[Lean.Meta.Match.Unify.Context.altFVarDecls,[]]
[Lean.Parser.Term.match,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, Lean.Parser.leadPrec, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.optional, Lean.Parser.Term.generalizingParam, Lean.Parser.sepBy1, Lean.Parser.Term.matchDiscr, Bool.false, Lean.Parser.Term.optType, Lean.Parser.Term.matchAlts, Lean.Parser.termParser, OfNat.ofNat]]
[Lean.Meta.PostponedEntry.noConfusionType,[]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State.funBinders,[]]
[Lean.Expr.instHashableExpr,[Hashable.mk, Lean.Expr.hash]]
[Lean.Elab.Term.Context.errToSorry,[]]
[Lean.Parser.Term.matchAltsWhereDecls,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.matchAlts, Lean.Parser.termParser, Lean.Parser.optional, Lean.Parser.Term.whereDecls]]
[Lean.Meta.ToHide.Context.noConfusionType,[]]
[Lean.AxiomVal.noConfusionType,[]]
[USize.one_def,[rfl]]
[Lean.termEval_prec_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Elab.Tactic.closeMainGoalUsing,[Lean.Elab.Tactic.withMainContext, Bind.bind, Lean.Elab.Tactic.getMainTarget, Lean.Elab.Tactic.closeMainGoal]]
[ExceptT.run_pure,[rfl]]
[Std.RBNode.max,[Unit.unit, Std.RBNode.node, Option, Sigma, Option.none, Option.some, Sigma.mk, PProd.fst, PProd.snd]]
[instSizeOfName,[SizeOf.mk, Lean.Name.sizeOf]]
[Lean.Lsp.instToStringPosition,[ToString.mk, HAppend.hAppend, ToString.toString, Lean.Lsp.Position.line, Lean.Lsp.Position.character]]
[Lean.Lsp.SemanticTokensLegend.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Compiler.natFoldFns,[List.cons, Prod.mk, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Compiler.foldNatAdd, Lean.Compiler.foldNatMul, Lean.Compiler.foldNatDiv, Lean.Compiler.foldNatMod, Lean.Compiler.foldNatPow, Lean.Compiler.foldNatDecEq, Lean.Compiler.foldNatDecLt, Lean.Compiler.foldNatDecLe, List.nil]]
[Lean.Elab.Command.mkCommandElabAttributeUnsafe,[Lean.Elab.mkElabAttribute, Lean.Elab.Command.CommandElab, Lean.Name.mkStr, Lean.Name.anonymous]]
[instMonadEIO,[inferInstanceAs, Monad, EStateM, IO.RealWorld]]
[Lean.Elab.CompletionInfo.namespaceId.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.IR.ExplicitBoxing.mkBoxedName,[Lean.Name.mkStr]]
[dbgTraceIfShared,[]]
[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.next,[ite, Eq, BEq.beq, HAdd.hAdd, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.curr, OfNat.ofNat, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.top, Bool.true, Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.mk, HMul.hMul, Lean.PrettyPrinter.Delaborator.SubExpr.maxChildren]]
[Lean.Meta.Match.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[HDiv.noConfusionType,[]]
[Lean.Meta.mkId,[Bind.bind, Lean.Meta.inferType, Lean.Meta.getLevel, Pure.pure, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil]]
[Std.RBMap.insert,[Std.RBMap, Subtype.mk, Std.RBNode.insert, Std.RBMap.insert.proof_1]]
[Lean.Elab.abstractNestedProofs,[ite, Eq, or, Lean.Elab.DefKind.isTheorem, Lean.Elab.PreDefinition.kind, Lean.Elab.DefKind.isExample, Bool.true, Pure.pure, Bind.bind, Lean.Meta.abstractNestedProofs, Lean.Elab.PreDefinition.declName, Lean.Elab.PreDefinition.value, Lean.Elab.PreDefinition.mk, Lean.Elab.PreDefinition.ref, Lean.Elab.PreDefinition.levelParams, Lean.Elab.PreDefinition.modifiers, Lean.Elab.PreDefinition.type]]
[Lean.Json.instFromJsonStructured,[Lean.FromJson.mk, Lean.Json.null, Lean.Json.bool, Lean.Json.num, Lean.Json.str, Except, String, Lean.Json.Structured, Pure.pure, Lean.Json.Structured.arr, Lean.Json.Structured.obj, MonadExcept.throw, HAppend.hAppend, ToString.toString]]
[Lean.Elab.checkNotAlreadyDeclared,[Bind.bind, Lean.MonadEnv.getEnv, ite, Eq, Lean.Environment.contains, Bool.true, Unit.unit, Unit, Lean.privateToUserName?, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.DeclarationRanges.range,[]]
[Lean.Elab.Term.StructInst.mkProjStx?,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.findField?, ite, Eq, Option.isNone, Bool.true, Option.none, PUnit.unit]]
[Lean.Parser.Command.attribute,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.sepBy1, HOrElse.hOrElse, Lean.Parser.Command.eraseAttr, Lean.Parser.Term.attrInstance, Bool.false, Lean.Parser.many1, Lean.Parser.ident]]
[Sum.inl.injEq,[Eq.propIntro, Eq.refl, Sum.inl, Eq.symm, eq_of_heq, HEq.refl]]
[Std.HashSetImp.find?.proof_1,[Subtype.property]]
[Lean.ppGroup.formatter,[Lean.PrettyPrinter.Formatter.group, Lean.PrettyPrinter.Formatter.indent, Option.none]]
[Lean.IR.ExplicitBoxing.BoxingContext.noConfusionType,[]]
[Lean.Elab.Deriving.Repr.mkAuxFunction,[Bind.bind, Pure.pure, Array.getOp, Lean.Elab.Deriving.Context.auxFunNames, Lean.Elab.Deriving.Context.typeInfos, Lean.Elab.Deriving.Repr.mkReprHeader, Lean.Elab.Deriving.Repr.mkBody, ite, Eq, Lean.Elab.Deriving.Context.usePartial, Bool.true, Lean.Elab.Deriving.mkLocalInstanceLetDecls, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Elab.Deriving.Header.argNames, Lean.Elab.Deriving.mkLet, PUnit.unit]]
[Lean.Meta.abstractMVars,[Bind.bind, Lean.Meta.instantiateMVars, Lean.MonadMCtx.getMCtx, Lean.MonadLCtx.getLCtx, Lean.MonadNameGenerator.getNGen, Lean.Meta.MetaM, Lean.Meta.AbstractMVarsResult, Lean.MonadNameGenerator.setNGen, Lean.Meta.AbstractMVars.State.ngen, Lean.Meta.setMCtx, Lean.Meta.AbstractMVars.State.mctx, Pure.pure, Lean.Meta.AbstractMVarsResult.mk, Lean.Meta.AbstractMVars.State.paramNames, Array.size, Lean.Meta.AbstractMVars.State.fvars]]
[Lean.IR.Checker.checkArgs,[Array.forM, Lean.IR.Checker.checkArg, OfNat.ofNat, Array.size]]
[Lean.Meta.whnfForall,[Bind.bind, Lean.Meta.whnf, ite, Eq, Lean.Expr.isForall, Bool.true, Pure.pure]]
[Lean.Lsp.TextDocumentChangeRegistrationOptions.syncKind,[]]
[Set,[]]
[Lean.BinderInfo.isAuxDecl,[Lean.BinderInfo.default, Lean.BinderInfo.implicit, Lean.BinderInfo.strictImplicit, Lean.BinderInfo.instImplicit, Unit.unit, Bool, Bool.true, Bool.false]]
[Lean.Elab.Frontend.elabCommandAtFrontend,[Lean.Elab.Frontend.runCommandElabM, Bind.bind, Lean.Elab.MonadInfoTree.getInfoState, Lean.MonadOptions.getOptions, ite, Eq, Lean.checkTraceOption, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Elab.enableInfoTree, Pure.pure, PUnit.unit]]
[Subrelation.accessible,[Subrelation.accessible.proof_1]]
[Lean.LocalDecl.binderInfo,[Lean.BinderInfo, Lean.BinderInfo.default]]
[Lean.MetavarContext.LevelMVarToParam.State.mctx,[]]
[Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.top,[]]
[Lean.Expr.looseBVarRange,[UInt32.toNat, Lean.Expr.Data.looseBVarRange, Lean.Expr.data]]
[HSub.noConfusionType,[]]
[Array.unzip,[Array.foldl, Prod, Array, Prod.mk, Array.push, List.toArray, List.nil, OfNat.ofNat, Array.size]]
[Prod.swap_left_inverse,[Prod.swap_swap]]
[Lean.Lsp.PlainTermGoal.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Lsp.PlainTermGoal.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.InductiveVal.isNestedEx,[Lean.InductiveVal.isNested]]
[MonadExcept.noConfusionType,[]]
[Std.AssocList.foldl,[Id.run, Std.AssocList.foldlM]]
[Lean.Meta.withReducibleAndInstances,[Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.instances]]
[Lean.Elab.Term.processDefDeriving,[Bind.bind, MonadExcept.tryCatch, Lean.getConstInfo, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Lean.ConstantInfo.recInfo, Lean.Elab.Term.TermElabM, Bool, liftM, Lean.Meta.mkConstWithFreshMVarLevels, Lean.Meta.inferType, List.toArray, List.nil, Lean.DefinitionVal.value, Option.none, Lean.Meta.check, Lean.Elab.liftMacroM, Lean.Elab.mkUnusedBaseName, Lean.Name.appendAfter, Lean.Name.appendBefore, Lean.Name.getString!, Lean.Meta.instantiateMVars, Lean.Elab.Term.MkInstResult.instVal, Lean.addAndCompile, Lean.Declaration.defnDecl, Lean.DefinitionVal.mk, Lean.ConstantVal.mk, Lean.ConstantVal.levelParams, Lean.DefinitionVal.toConstantVal, Lean.DefinitionVal.hints, Lean.DefinitionVal.safety, Lean.Meta.addInstance, Lean.AttributeKind.global, OfNat.ofNat, Pure.pure, Bool.true, Bool.false]]
[Lean.Parser.Tactic.simp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpStar, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma, Lean.Parser.Tactic.location]]
[Lean.Parser.Term.waitIfTypeMVar,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.ident, Lean.Parser.termParser]]
[USize.toNat,[Fin.val, USize.val]]
[Lean.EnvExtensionInterfaceUnsafe.Ext.idx,[]]
[Lean.Parser.Term.structInstField,[Lean.Parser.ppGroup, Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.Term.structInstLVal, Lean.Parser.symbol, Lean.Parser.termParser]]
[Lean.Elab.Tactic.ElimApp.Context.mk.inj,[And.intro]]
[UInt32.instCommRingUInt32.proof_1,[UInt32.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, UInt32.val, UInt32.mul_def, CommSemiring.mul_comm]]
[Lean.HeadIndex.mvar.inj,[]]
[set.piecewise,[ite, Mem.mem]]
[Lean.Parser.charLitNoAntiquot,[Lean.Parser.Parser.mk, Lean.Parser.mkAtomicInfo, Lean.Parser.charLitFn]]
[Lean.Compiler.getInfoFromFn,[Unit.unit, Option, Lean.Compiler.NumScalarTypeInfo, Option.none, ite, Eq, BEq.beq, Lean.Compiler.NumScalarTypeInfo.ofNatFn, Bool.true, Option.some, PProd.fst]]
[exists₄_congr,[exists_congr, exists₃_congr]]
[Subtype.ext,[Eq, of_eq_true, Eq.trans, Subtype.mk.injEq, congrFun, congrArg, eq_self]]
[Lean.Lsp.PlainTermGoalParams.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Lsp.PlainTermGoalParams.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.gcd_pos_of_pos_right,[Nat.pos_of_dvd_of_pos, Nat.gcd_dvd_right]]
[ite,[]]
[Monad.toApplicative,[]]
[Lean.Elab.Term.MutualClosure.ClosureState.noConfusionType,[]]
[Tactic.Ring.HornerExpr.const.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Meta.State.cache,[]]
[LawfulMonad.noConfusionType,[]]
[Lean.Elab.Tactic.ElimApp.mkElimApp,[Bind.bind, Lean.Elab.Term.mkConst, List.nil, liftM, Lean.Meta.inferType, StateRefT'.run, ReaderT.run, Lean.Elab.Tactic.ElimApp.Context.mk, Lean.Elab.Tactic.ElimApp.State.mk, Lean.Elab.Term.TermElabM, Lean.Elab.Tactic.ElimApp.Result, ForIn.forIn, MonadExcept.tryCatch, Lean.Elab.Term.synthesizeInstMVarCore, Option.none, ite, Eq, Bool.true, Pure.pure, PUnit.unit, MProd.mk, Lean.Meta.setMVarKind, Lean.MetavarKind.syntheticOpaque, MProd.fst, ForInStep.yield, Lean.Meta.instantiateMVars, Lean.Elab.Tactic.ElimApp.State.f, Lean.Elab.Tactic.ElimApp.Result.mk, Lean.Elab.Tactic.ElimApp.State.alts, Lean.Elab.Tactic.ElimApp.mkElimApp.loop]]
[Lean.Meta.mkSyntheticSorry,[Bind.bind, Lean.Meta.getLevel, Pure.pure, Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil]]
[List.nil.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Lean.Parser.darrow.formatter,[Lean.Parser.symbol.formatter]]
[Subarray.foldl,[Id.run, Subarray.foldlM]]
[Lean.Meta.whenUndefDo,[Bind.bind, Unit.unit, Lean.Meta.MetaM, Bool, Pure.pure, Bool.true, Bool.false]]
[Lean.Parser.precedence,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.precedenceParser, Lean.Parser.maxPrec]]
[Lean.Meta.Match.instantiateAltLHSMVars,[Bind.bind, List.mapM, Lean.Meta.instantiateLocalDeclMVars, Lean.Meta.Match.AltLHS.fvarDecls, Lean.Meta.Match.instantiatePatternMVars, Lean.Meta.Match.AltLHS.patterns, Pure.pure, Lean.Meta.Match.AltLHS.mk, Lean.Meta.Match.AltLHS.ref]]
[Lean.PrettyPrinter.Delaborator.SubExpr.withLetValue,[Bind.bind, Lean.PrettyPrinter.Delaborator.SubExpr.getExpr, Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.sort, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.PrettyPrinter.Delaborator.SubExpr.descend, OfNat.ofNat, panicWithPosWithDecl]]
[Lean.Elab.Command.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[String.firstDiffPos,[OfNat.ofNat, String.firstDiffPos.loop]]
[Lean.IR.LogEntry.message.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MonadError.toMonadExceptOf,[]]
[Lean.mkMVarEx,[Lean.mkMVar]]
[Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.collectHigherOrders,[Bind.bind, MonadReader.read, Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM, PUnit, ForIn.forIn, PUnit.unit, ite, Eq, not, or, BEq.beq, Array.getOp, Lean.BinderInfo.implicit, Lean.BinderInfo.strictImplicit, Bool.true, Pure.pure, ForInStep.yield]]
[UInt64.val_eq_of_eq,[Eq, UInt64.val, congrArg]]
[Function.id_def,[rfl]]
[Lean.Elab.logTrace,[Lean.Elab.logInfo, Lean.MessageData.tagged, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Decidable.imp_iff_not_or,[Iff.intro, Decidable.not_or_of_imp, Or.neg_resolve_left]]
[Lean.Elab.Term.getMVarDecl,[Bind.bind, Lean.MonadMCtx.getMCtx, Pure.pure, Lean.MetavarContext.getDecl]]
[Lean.Meta.State.noConfusionType,[]]
[Std.HashMap.insert',[Prod, Std.HashMap, Bool, Std.HashMapImp.insert, Std.HashMap.insert'.proof_1, Prod.mk, Subtype.mk, Std.HashMap.insert'.proof_2]]
[Lean.PrefixTree,[Subtype, Lean.PrefixTreeNode.WellFormed]]
[Lean.Meta.NormNum.instLawfulOfNatNat,[Lean.Meta.NormNum.instLawfulOfNatNat.proof_1]]
[Lean.Parser.AliasValue.const.injEq,[Eq.propIntro, Eq.refl, Lean.Parser.AliasValue.const, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.eapply',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.Elab.Term.StructInst.Struct.setFields,[Lean.Elab.Term.StructInst.Struct.modifyFields]]
[Lean.Parser.Tactic.Conv.change,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.instToJsonArray,[Lean.ToJson.mk, Lean.Json.arr, Array.map, Lean.ToJson.toJson]]
[Lean.Level.PP.Result.offset.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Level.PP.Result.offset, Eq.symm, eq_of_heq, HEq.refl]]
[tacticExfalso,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Std.RBMap.min!,[Unit.unit, Prod, Std.RBMap.min, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Server.RequestContext.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instTransEq,[Trans.mk, instTransEq.proof_1]]
[Lean.Meta.SynthInstanceCache,[Std.PersistentHashMap, Lean.Expr, Option]]
[dif_neg,[Eq, dite, absurd, rfl]]
[USize.xor,[USize.mk, Fin.xor, USize.val]]
[Lean.ConstantInfo.thmInfo.injEq,[Eq.propIntro, Eq.refl, Lean.ConstantInfo.thmInfo, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Tactic.ElimApp.evalAlts.applyPreTac,[ite, Eq, Lean.Syntax.isNone, Bool.true, Pure.pure, List.cons, List.nil, Lean.Elab.Tactic.evalTacticAt, Lean.Syntax.getOp, OfNat.ofNat]]
[Bool.and_true,[rfl, Eq.symm, Eq.refl]]
[Lean.Lsp.instToJsonWorkDoneProgressEnd,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.WorkDoneProgressEnd.kind, List.nil, Lean.Json.opt, Lean.Lsp.WorkDoneProgressEnd.message?]]
[Lean.Server.WithRpcRef.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Tactic.mkTacticAttribute,[Lean.Elab.mkElabAttribute, Lean.Elab.Tactic.Tactic, Lean.Name.mkStr, Lean.Name.anonymous]]
[instToStringList,[ToString.mk, List.toString]]
[Lean.Lsp.instToJsonSemanticTokens,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.SemanticTokens.data, List.nil]]
[Option.getD,[]]
[Lean.Parser.Tactic.tacticLet_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[and_self,[propext, Iff.intro, And.left, And.intro]]
[Lean.IR.UnreachableBranches.resetParamAssignment,[Lean.IR.UnreachableBranches.resetVarAssignment, Lean.IR.Param.x]]
[Lean.Elab.Term.expandCDot?,[ite, Eq, Bool.true, Bind.bind, StateT.run, List.toArray, List.nil, Lean.MacroM, Option, Lean.Syntax, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Option.some, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.Syntax.atom, Array.append, Option.none, Lean.Elab.Term.expandCDot?.go]]
[Lean.Meta.GeneralizeIndicesSubgoal.mvarId,[]]
[Lean.Elab.Term.Quotation.MatchResult.covered.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Elab.Term.Quotation.MatchResult.covered, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Elab.Command.State.noConfusionType,[]]
[Lean.Meta.IndPredBelow.mkBrecOnDecl,[Bind.bind, Lean.Meta.IndPredBelow.proveBrecOn, Pure.pure, Lean.Declaration.thmDecl, Lean.TheoremVal.mk, Lean.ConstantVal.mk, Lean.ConstantVal.levelParams, Lean.InductiveVal.toConstantVal, Lean.Meta.IndPredBelow.mkBrecOnDecl.mkType, Lean.Meta.IndPredBelow.mkBrecOnDecl.mkIH]]
[Array.foldrMUnsafe.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bind.bind, Array.uget, HSub.hSub, OfNat.ofNat, lcProof, Array.foldrMUnsafe.fold]]
[Lean.PrettyPrinter.Formatter.nonReservedSymbolNoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.symbolNoAntiquot.formatter]]
[Lean.ImportM.Context.env,[]]
[Lean.MetavarDecl.numScopeArgs,[]]
[Lean.ppGoal,[Lean.PPFns.ppGoal, Lean.EnvExtension.getState, Lean.ppExt, Lean.PPContext.env]]
[Lean.instToStringLOption,[ToString.mk, Unit.unit, String, HAppend.hAppend, ToString.toString]]
[Lean.Core.getMaxHeartbeats,[HMul.hMul, Lean.Option.get, Lean.Core.maxHeartbeats, OfNat.ofNat]]
[Lean.Parser.Term.doExpr.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.Term.notFollowedByRedefinedTermToken.formatter, Lean.Parser.termParser.formatter, Lean.PrettyPrinter.Formatter.notFollowedBy.formatter, Lean.PrettyPrinter.Formatter.orelse.formatter, Lean.Parser.symbol.formatter]]
[Lean.Parser.Command.structSimpleBinder.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer, Lean.Parser.Command.declModifiers.parenthesizer, Lean.Parser.ident.parenthesizer, Lean.Parser.optional.parenthesizer, Lean.Parser.Command.inferMod.parenthesizer, Lean.Parser.Command.optDeclSig.parenthesizer, Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer, Lean.Parser.Term.binderTactic.parenthesizer, Lean.Parser.Term.binderDefault.parenthesizer]]
[Lean.Lsp.instToJsonRpcConnected,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.RpcConnected.sessionId, List.nil]]
[Lean.Parser.Tactic.first,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[Lean.reservedMacroScope,[OfNat.ofNat]]
[Lean.indentExpr,[Lean.indentD, Lean.MessageData.ofExpr]]
[imp_self,[iff_true_intro, id]]
[Prod.Lex.decidable.proof_1,[Iff.symm, Prod.lex_def]]
[Lean.Meta.assertExt,[Lean.Meta.withMVarContext, Bind.bind, Lean.Meta.checkNotAssigned, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.getMVarTag, Lean.Meta.getMVarType, Lean.Meta.getLevel, Lean.Meta.mkFreshExprSyntheticOpaqueMVar, Lean.Meta.mkEqRefl, Lean.Meta.assignExprMVar, Lean.mkApp2, Pure.pure, Lean.Expr.mvarId!]]
[Lean.Meta.isDefEqNoConstantApprox,[Lean.Meta.approxDefEq, Lean.Meta.isDefEq]]
[Lean.IR.EmitC.toCInitName,[Bind.bind, Lean.IR.EmitC.getEnv, Unit.unit, Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Lean.IR.EmitC.M, String, Lean.getExportNameFor, Pure.pure, HAppend.hAppend, Lean.IR.EmitC.throwInvalidExportName, Lean.Name.mangle]]
[Lean.Parser.ppHardSpace,[Lean.Parser.skip]]
[Lean.Lsp.instToJsonTypeDefinitionParams,[Lean.ToJson.mk, Lean.Json.mkObj, List.join, List.cons, Prod.mk, Lean.ToJson.toJson, Lean.Lsp.TextDocumentPositionParams.textDocument, Lean.Lsp.TypeDefinitionParams.toTextDocumentPositionParams, List.nil, Lean.Lsp.TextDocumentPositionParams.position]]
[Lean.Parser.nodeWithAntiquot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.PrettyPrinter.Parenthesizer.node.parenthesizer]]
[Lean.IR.Sorry.State.noConfusionType,[]]
[AddSemigroup.toAdd,[]]
[calc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, calcStep, Lean.ParserDescr.const]]
[List.disjoint_singleton,[Eq.mpr, Eq.refl, Iff, List.disjoint, List.cons, List.nil, Not, Mem.mem, propext, List.disjoint_comm, List.singleton_disjoint, Iff.rfl]]
[Lean.MetavarKind.isNatural,[Unit.unit, Lean.MetavarKind.synthetic, Lean.MetavarKind.syntheticOpaque, Bool, Bool.true, Bool.false]]
[Lean.Parser.Term.stx.quot.parenthesizer,[Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer, Lean.Parser.mkAntiquot.parenthesizer, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer, OfNat.ofNat, Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer, Lean.Parser.symbol.parenthesizer, Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer, Lean.Parser.syntaxParser.parenthesizer]]
[Lean.Meta.GeneralizeIndicesSubgoal.numEqs,[]]
[Lean.IR.CtorInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Elab.Term.instMonadLogTermElabM,[Lean.Elab.MonadLog.mk, Lean.MonadRef.getRef, Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Term.Context.fileName, readThe, Lean.Core.Context, modify, Lean.Elab.Term.State.mk, Lean.Elab.Term.State.levelNames, Lean.Elab.Term.State.syntheticMVars, Lean.Elab.Term.State.mvarErrorInfos, Lean.MessageLog.add, Lean.Elab.Term.State.messages, Lean.Elab.Term.State.letRecsToLift, Lean.Elab.Term.State.infoState]]
[Lean.Elab.Term.Context.declName?,[]]
[Lean.IR.emitC,[Except, String, EStateM.run, Lean.IR.EmitC.main, Lean.IR.EmitC.Context.mk, Except.ok, Except.error]]
[Lean.PrettyPrinter.Formatter.Context.options,[]]
[Lean.Parser.Attr.toAdditive,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const]]
[ExceptCpsT.run_throw,[rfl]]
[instToStringChar,[ToString.mk, Char.toString]]
[Lean.Expr.Data.approxDepth,[UInt64.toUInt8, UInt64.land, UInt64.shiftRight, OfNat.ofNat]]
[Lean.Meta.Match.MatcherInfo.arity,[HAdd.hAdd, Lean.Meta.Match.MatcherInfo.numParams, OfNat.ofNat, Lean.Meta.Match.MatcherInfo.numDiscrs, Lean.Meta.Match.MatcherInfo.numAlts]]
[instOrOpUInt64,[OrOp.mk, UInt64.lor]]
[Lean.Meta.Match.Unify.assign,[ite, Eq, Lean.Meta.Match.Unify.occurs, Bool.true, Bind.bind, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.mkFVar, Pure.pure, PUnit.unit, MonadReader.read, Lean.Meta.Match.Unify.isAltVar]]
[Lean.Meta.Attribute.Recursor.getMajorPos,[ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, OfNat.ofNat, Bind.bind, Lean.throwErrorAt, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit]]
[Lean.Elab.Command.StructFieldView.binders,[]]
[forall_congr,[]]
[Lean.RecursorRule.nfields,[]]
[IO.Error.mkPermissionDenied,[IO.Error.permissionDenied, Option.none]]
[Lean.isProjectionFn,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.Environment.isProjectionFn]]
[Lean.Parser.Command.openScoped,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.many1, Lean.Parser.checkColGt, Lean.Parser.ident]]
[Lean.Xml.Parser.PEDef,[HOrElse.hOrElse, SeqRight.seqRight, Lean.Xml.Parser.EntityValue, Pure.pure, Unit.unit, Lean.Xml.Parser.ExternalID]]
[Char.isDigit,[and, Decidable.decide, GE.ge, Char.val, OfNat.ofNat, LE.le]]
[Lean.Parser.sepByInfo,[Lean.Parser.ParserInfo.mk, Function.comp, Lean.Parser.ParserInfo.collectTokens, Lean.Parser.ParserInfo.collectKinds]]
[Lean.Elab.Term.NamedArg.val,[]]
[Lean.TagAttribute.mk.inj,[And.intro]]
[Lean.Parser.Term.simpleBinder.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.many1.formatter, Lean.Parser.Term.binderIdent.formatter, Lean.Parser.Term.optType.formatter]]
[Int.negSucc_ofNat_add_ofNat,[rfl]]
[Lean.AxiomVal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Syntax.getOptionalIdent?,[Unit.unit, Option, Lean.Name, Lean.Syntax.getOptional?, Option.some, Lean.Syntax.getId, Option.none]]
[Lean.Xml.Parser.GEDecl,[SeqRight.seqRight, Lean.Parsec.skipString, Lean.Xml.Parser.S, Lean.Xml.Parser.Name, Lean.Xml.Parser.EntityDef, optional, Lean.Parsec.skipChar, Char.ofNat]]
[Int.add,[Int, Int.ofNat, HAdd.hAdd, Int.subNatNat, Nat.succ, Int.negSucc]]
[Lean.Lsp.WorkDoneProgressBegin.title,[]]
[List.toByteArray.loop,[ByteArray, PProd.fst, ByteArray.push]]
[Lean.IR.findDecl',[Bind.bind, MonadState.get, Pure.pure, Lean.IR.findEnvDecl', Lean.IR.CompilerState.env]]
[Std.Format.instInhabitedFlattenBehavior,[Inhabited.mk, Std.Format.FlattenBehavior.allOrNone]]
[PointedType.noConfusionType,[]]
[Std.HashMapImp.expand,[]]
[ExceptT.tryCatch,[ExceptT.mk, Bind.bind, Except, Pure.pure, Except.ok]]
[Lean.Meta.instToMessageDataSimpLemma,[Lean.ToMessageData.mk, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[Lean.Parser.Tactic.clear,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Lean.isRecCore,[Option.none, Option.some, Lean.ConstantInfo.axiomInfo, Lean.ConstantInfo.defnInfo, Lean.ConstantInfo.thmInfo, Lean.ConstantInfo.opaqueInfo, Lean.ConstantInfo.quotInfo, Lean.ConstantInfo.inductInfo, Lean.ConstantInfo.ctorInfo, Bool, Lean.Environment.find?, Bool.true, Bool.false]]
[String.Iterator.remainingBytes,[Nat, HSub.hSub, String.bsize]]
[UInt8.instSemiringUInt8.proof_10,[rfl]]
[Lean.instMVarIdSetInhabited,[Std.instInhabitedRBTree]]
[Lean.Elab.Term.elabScientificLit,[Unit.unit, Lean.Elab.Term.TermElabM, Lean.Expr, Lean.Syntax.isScientificLit?, Lean.Elab.throwIllFormedSyntax, Bind.bind, liftM, Lean.Meta.mkFreshTypeMVar, Lean.MetavarKind.synthetic, Lean.Name.anonymous, Option.none, Functor.discard, Lean.Meta.isDefEq, Pure.pure, Lean.Meta.getDecLevel, Lean.Elab.Term.mkInstMVar, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, List.cons, List.nil, Lean.Elab.Term.registerMVarErrorImplicitArgInfo, Lean.Expr.mvarId!]]
[Lean.Widget.InteractiveGoal.pretty,[Id.run, Bind.bind, ForIn.forIn, Unit.unit, Id, ForInStep, Std.Format, Lean.Widget.InteractiveHypothesis.val?, Pure.pure, PUnit.unit, ForInStep.yield, HAppend.hAppend, Std.ToFormat.format, Std.Format.nest, Std.Format.text, Lean.Widget.TaggedText.stripTags, Lean.Widget.InteractiveGoal.type]]
[Lean.Parser.ParserCategory.noConfusionType,[]]
[Lean.Expr.updateSort!,[Lean.Expr.bvar, Lean.Expr.fvar, Lean.Expr.mvar, Lean.Expr.const, Lean.Expr.app, Lean.Expr.lam, Lean.Expr.forallE, Lean.Expr.letE, Lean.Expr.lit, Lean.Expr.mdata, Lean.Expr.proj, Lean.Expr, Lean.Expr.updateSort, Lean.Expr.sort, Lean.Expr.updateSort!.proof_1, panicWithPosWithDecl, OfNat.ofNat]]
[Lean.Elab.Tactic.Conv.evalArg,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, BEq.beq, OfNat.ofNat, Bind.bind, Lean.throwError, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, Lean.Elab.throwUnsupportedSyntax]]
[UInt16.instSemiringUInt16.proof_12,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HMul.hMul, UInt16.add_def, UInt16.mul_def, UInt16.mk, HAdd.hAdd, UInt16.val, UInt16.eq_of_val_eq, Semiring.add_mul]]
[Lean.Lsp.instFileSourceVersionedTextDocumentIdentifier,[Lean.Lsp.FileSource.mk, Lean.Lsp.VersionedTextDocumentIdentifier.uri]]
[Lean.getStructureInfo?,[Unit.unit, Option, Lean.StructureInfo, Lean.Environment.getModuleIdxFor?, Array.binSearch, Lean.PersistentEnvExtension.getModuleEntries, Lean.structureExt, Lean.StructureInfo.mk, Lean.StructureInfo.lt, OfNat.ofNat, HSub.hSub, Array.size, Std.PersistentHashMap.find?, Lean.SimplePersistentEnvExtension.getState]]
[Lean.Parser.Term.macroArg.parenthesizer,[Lean.Parser.termParser.parenthesizer, Lean.Parser.maxPrec]]
[Lean.PrettyPrinter.formatCommand,[Lean.PrettyPrinter.format, Lean.PrettyPrinter.Formatter.categoryParser.formatter, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.MonadTracer.trace,[Lean.trace]]
[StateCpsT.run_eq,[rfl]]
[Lean.PrettyPrinter.Formatter.fold,[Bind.bind, Lean.PrettyPrinter.Formatter.getStackSize, Lean.PrettyPrinter.Formatter.getStack, Lean.PrettyPrinter.Formatter.setStack, Array.push, Array.shrink]]
[Lean.Lsp.DocumentHighlight.kind?,[]]
[Std.PersistentArray.filter,[Std.PersistentArray.foldl, ite, Eq, Bool.true, Std.PersistentArray.push, Std.PersistentArray.mk, OfNat.ofNat]]
[Lean.Parser.Command.macro_rules,[Lean.Parser.suppressInsideQuot, Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.optional, Lean.Parser.Command.docComment, Lean.Parser.Term.attrKind, Lean.Parser.symbol, Lean.Parser.Command.optKind, Lean.Parser.Term.matchAlts, Lean.Parser.termParser]]
[Lean.Elab.Term.Quotation.HeadInfo.onMatch,[]]
[Lean.Parser.ParserCategory.tables,[]]
[Std.PersistentArray.toArray,[Std.PersistentArray.foldl, Array.push, List.toArray, List.nil, OfNat.ofNat]]
[Lean.MacroScopesView.scopes,[]]
[Lean.PrettyPrinter.Formatter.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Tactic.Ring.subst_into_mul,[Eq.mpr, Eq.refl, Eq, HMul.hMul, rfl]]
[Lean.Expr.collectMVars,[Lean.CollectMVars.visit]]
[Lean.Meta.SynthInstance.ConsumerNode.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.instCoeParserParserAliasValue,[Coe.mk, Lean.Parser.AliasValue.const]]
[Lean.IR.LocalContextEntry.localVar.inj,[And.intro]]
[Lean.Meta.AltVarNames.noConfusionType,[]]
[Lean.Elab.TerminationHints.mk.inj,[And.intro]]
[instInhabitedNat,[Inhabited.mk, Nat.zero]]
[Lean.PrettyPrinter.Formatter.getStackSize,[Bind.bind, Lean.PrettyPrinter.Formatter.getStack, Pure.pure, Array.size]]
[IO.userError,[IO.Error.userError]]
[ite_false,[rfl]]
[Lean.Lsp.SemanticTokenType.variable.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Nat.toUInt64,[UInt64.ofNat]]
[Substring.any,[Bool, String.anyAux]]
[Lean.Parser.Syntax.atom,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.strLit]]
[Lean.Elab.Level.instMonadRefLevelElabM,[Lean.MonadRef.mk, Bind.bind, MonadReader.read, Pure.pure, Lean.Elab.Level.Context.ref, MonadWithReader.withReader, Lean.Elab.Level.Context.mk, Lean.Elab.Level.Context.options, Lean.Elab.Level.Context.autoBoundImplicit]]
[Lean.Parser.sepByElemParser.formatter,[Lean.Parser.withAntiquotSpliceAndSuffix.formatter, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Parser.symbol.formatter, HAppend.hAppend, String.trim]]
[Lean.Meta.SimpLemmas.noConfusionType,[]]
[Lean.Lsp.instFromJsonTrace,[Lean.FromJson.mk, Except.error, dite, Eq, Unit.unit, Eq.symm, Except.ok, Except, String, Lean.Lsp.Trace, Lean.Json.getStr?, Pure.pure, Lean.Lsp.Trace.off, Lean.Lsp.Trace.messages, Lean.Lsp.Trace.verbose, MonadExcept.throw]]
[Lean.Elab.Term.PatternVar.noConfusionType,[]]
[Lean.ImportState.moduleNames,[]]
[AddCommSemigroup.toAddSemigroup,[]]
[Std.PersistentArray.getOp,[Std.PersistentArray.get!]]
[Nat.succ_sub_succ_eq_sub,[rfl, congrArg, Nat.pred]]
[Lean.Elab.Term.instInhabitedTermElabResult,[Inhabited.mk, EStateM.Result.ok, arbitrary]]
[Lean.instToMessageDataSyntax,[Lean.ToMessageData.mk, Lean.MessageData.ofSyntax]]
[Lean.PrettyPrinter.Formatter.nameLitNoAntiquot.formatter,[Lean.PrettyPrinter.Formatter.visitAtom, Lean.nameLitKind]]
[Lean.Elab.throwAbortTerm,[MonadExcept.throw, Lean.Exception.internal, Lean.Elab.abortTermExceptionId, Lean.KVMap.mk]]
[Lean.Parser.Command.macroArg.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.optional.formatter, Lean.PrettyPrinter.Formatter.atomic.formatter, Lean.Parser.ident.formatter, Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter, Lean.Parser.symbol.formatter, Lean.Parser.syntaxParser.formatter, Lean.Parser.argPrec]]
[Lean.CollectLevelParams.State.getUnusedLevelParam,[ite, Eq, Std.HashSet.contains, Lean.CollectLevelParams.State.visitedLevel, Bool.true, OfNat.ofNat, Lean.CollectLevelParams.State.getUnusedLevelParam.loop]]
[Lean.Parser.Attr.extern,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.nonReservedSymbol, Bool.false, Lean.Parser.optional, Lean.Parser.numLit, Lean.Parser.many, Lean.Parser.Attr.externEntry]]
[id,[]]
[Lean.Meta.matchNot?,[Lean.Meta.matchHelper?, Option.none, Lean.Meta.MetaM, Option, Lean.Expr, Lean.Expr.not?, Pure.pure, Option.some, Lean.Expr.arrow?, Bind.bind, Lean.Meta.matchFalse, ite, Eq, Bool.true]]
[Fin.sub.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[Lean.PersistentEnvExtension.toEnvExtension,[]]
[UInt8.modn,[UInt8.mk, HMod.hMod, UInt8.val]]
[FloatSpec.decLe,[]]
[Char.quoteCore,[ite, Eq, Char.ofNat, Or, LE.le, Char.toNat, OfNat.ofNat, HAppend.hAppend, charToHex, String.singleton]]
[Lean.Meta.PrioritySet,[Std.RBTree, Nat, Ord.compare]]
[List.concat_eq_append,[Eq.trans, List.concat_eq_append', List.append'_eq_append, List.cons, List.nil]]
[Lean.LocalContext.containsFVar,[Lean.LocalContext.contains, Lean.Expr.fvarId!]]
[Lean.Elab.ContextInfo.currNamespace,[]]
[Lean.Meta.Simp.rewritePost,[Bind.bind, MonadReader.read, Pure.pure, Lean.Meta.Simp.Context.simpLemmas, Lean.Meta.Simp.rewrite, Lean.Meta.SimpLemmas.post, Lean.Meta.SimpLemmas.erased, Lean.Meta.Simp.Step.visit]]
[Lean.Widget.InteractiveTermGoal.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.MetavarContext.dAssignment,[]]
[Lean.Elab.Structural.EqnInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Std.ShareCommon.ObjectPersistentSet.insert,[Std.PersistentHashSet.insert]]
[Lean.Lsp.instFromJsonRpcConnected,[Lean.FromJson.mk, Bind.bind, Lean.Json.getObjValAs?, UInt64, Pure.pure, Lean.Lsp.RpcConnected.mk]]
[Lean.Elab.ContextInfo.mctx,[]]
[Function.has_right_inverse.surjective,[Function.surjective, Function.right_inverse.surjective]]
[Lean.Lsp.CompletionOptions.mk.inj,[And.intro]]
[Lean.Widget.MsgToInteractive.noConfusionType,[]]
[Lean.IR.LogEntry.noConfusionType,[]]
[Lean.Parser.AliasValue.const.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.Parser.Term.doMatchAlts,[Lean.Parser.Term.matchAlts, Lean.Parser.Term.doSeq]]
[Lean.Elab.Term.StructInst.DefaultFields.propagate,[StateRefT'.run', Lean.Elab.Term.StructInst.DefaultFields.propagateLoop, OfNat.ofNat, Lean.Elab.Term.StructInst.DefaultFields.Context.mk, Lean.Elab.Term.StructInst.DefaultFields.State.mk]]
[instToStringIterator,[ToString.mk, String.Iterator.remainingToString]]
[Lean.Elab.Frontend.setMessages,[modify, Lean.Elab.Frontend.State.mk, Lean.Elab.Command.State.mk, Lean.Elab.Command.State.env, Lean.Elab.Command.State.scopes, Lean.Elab.Command.State.nextMacroScope, Lean.Elab.Command.State.maxRecDepth, Lean.Elab.Command.State.nextInstIdx, Lean.Elab.Command.State.ngen, Lean.Elab.Command.State.infoState, Lean.Elab.Command.State.traceState, Lean.Elab.Frontend.State.parserState, Lean.Elab.Frontend.State.cmdPos, Lean.Elab.Frontend.State.commands]]
[Lean.Parser.Term.doIfCond,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.none, Bool.false, HOrElse.hOrElse, Lean.Parser.Term.doIfLet, Lean.Parser.Term.doIfProp]]
[Lean.Parser.Command.end.formatter,[Lean.PrettyPrinter.Formatter.withAntiquot.formatter, Lean.Parser.mkAntiquot.formatter, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode.formatter, OfNat.ofNat, Lean.PrettyPrinter.Formatter.andthen.formatter, Lean.Parser.symbol.formatter, Lean.Parser.optional.formatter, Lean.Parser.ident.formatter]]
[Lean.Macro.getCurrNamespace,[Bind.bind, Lean.Macro.getMethods, Lean.Macro.Methods.getCurrNamespace]]
[Lean.Elab.Command.Scope.varDecls,[]]
[Lean.Meta.IndPredBelow.BrecOnVariables.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.IndPredBelow.BrecOnVariables.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Array.filter,[Array.foldl, ite, Eq, Bool.true, Array.push, List.toArray, List.nil]]
[Lean.Server.FileWorker.RpcSession.hasExpired,[Bind.bind, liftM, IO.monoMsNow, Pure.pure, Decidable.decide, LE.le, Lean.Server.FileWorker.RpcSession.expireTime]]
[Lean.Expr.mkAppRevRange,[]]
[Decidable.not_forall,[Iff.intro, not.decidable_imp_symm, Exists.intro, not_forall_of_exists_not]]
[List.disjoint_left,[of_eq_true, iff_self, False]]
[Nat.sub_le,[Nat.le_refl, HSub.hSub, OfNat.ofNat, Nat.le_trans, Nat.pred_le]]
[Decidable.not_imp_comm,[Iff.intro, Not.decidable_imp_symm]]
[Lean.SMap.mk.inj,[And.intro]]
[StateCpsT.runK_lift,[rfl]]
[Lean.Expr.updateSort!.proof_1,[rfl]]
[Int.negSucc_ofNat_add_negSucc_ofNat,[rfl]]
[Lean.Parser.Command.private,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, Lean.Parser.symbol]]
[«term_∣_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Meta.Simp.rewrite,[Bind.bind, liftM, Lean.Meta.DiscrTree.getMatchWithExtra, ite, Eq, Array.isEmpty, Bool.true, Lean.isTracingEnabledFor, Lean.addTrace, HAppend.hAppend, Lean.ToMessageData.toMessageData, Pure.pure, PUnit.unit, ForIn.forIn, MProd.mk, Option.none, Lean.Meta.Simp.SimpM, ForInStep, MProd, Option, Lean.Meta.Simp.Result, PUnit, ForInStep.yield, Lean.Meta.Simp.tryLemmaWithExtraArgs?, ForInStep.done, Option.some, Unit.unit, MProd.fst, Lean.Meta.Simp.rewrite.inErasedSet]]
[Lean.MapDeclarationExtension.find?,[Unit.unit, Option, Lean.Environment.getModuleIdxFor?, Array.binSearch, Lean.PersistentEnvExtension.getModuleEntries, Prod.mk, arbitrary, Lean.Name.quickLt, Prod.fst, OfNat.ofNat, HSub.hSub, Array.size, Option.some, Prod.snd, Option.none, Lean.NameMap.find?, Lean.SimplePersistentEnvExtension.getState]]
[Lean.Parser.Term.stateRefT,[Lean.Parser.withAntiquot, Lean.Parser.mkAntiquot, Option.some, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Parser.leadingNode, OfNat.ofNat, HAndThen.hAndThen, Lean.Parser.symbol, Lean.Parser.Term.macroArg, Lean.Parser.Term.macroLastArg]]
[Nat.coprime.gcd_mul_left_cancel,[Nat.dvd_antisymm, Nat.dvd_gcd, Nat.coprime.dvd_of_dvd_mul_left, Nat.gcd_dvd_left, HMul.hMul, Nat.gcd_dvd_right, Nat.gcd_dvd_gcd_mul_left]]
[IO.FS.Stream.ofHandle,[IO.FS.Stream.mk, liftM, IO.FS.Handle.isEof, IO.FS.Handle.flush, IO.FS.Handle.read, IO.FS.Handle.write, IO.FS.Handle.getLine, IO.FS.Handle.putStr]]
[Lean.Meta.addImplicitTargets,[Lean.Meta.withNewMCtxDepth, Bind.bind, Lean.Meta.mkConstWithFreshMVarLevels, Lean.Meta.ElimInfo.name, Lean.Meta.inferType, OfNat.ofNat, List.toArray, List.nil, Array.mapM, Lean.Meta.instantiateMVars, ForIn.forIn, PUnit.unit, Lean.Meta.hasAssignableMVar, ite, Eq, Bool.true, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.indentExpr, Pure.pure, ForInStep.yield, Lean.Meta.addImplicitTargets.collect]]
[Lean.Meta.whnfD,[Lean.Meta.withTransparency, Lean.Meta.TransparencyMode.default, Lean.Meta.whnf]]
[Lean.ParametricAttribute.noConfusionType,[]]
[ForInStep.noConfusionType,[]]
[Lean.Elab.Term.Quotation.mkPrecheckAttribute,[Lean.KeyedDeclsAttribute.init, Lean.KeyedDeclsAttribute.Def.mk, Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.SMap.stage₁,[]]
[Substring.get,[Char, String.get, HAdd.hAdd]]
[Lean.MessageData.compose.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Lean.getPPProofsWithType,[Lean.KVMap.get, Lean.Option.name, Lean.pp.proofs.withType, Lean.Option.defValue]]
[Lean.Parser.Tactic.trace,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.IR.FnBody.replaceVar,[Lean.IR.FnBody.mapVars, ite, Eq, BEq.beq, Bool.true]]
[Lean.Parser.Tactic.casesType,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.parser]]
[Array.toList,[Array.foldr, List.cons, List.nil, Array.size, OfNat.ofNat]]
