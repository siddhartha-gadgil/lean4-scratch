[LawfulMonad.pure_bind,[]]
[Nat.ofNat_eq_Nat,[rfl]]
[Prod.Lex.decidable,[decidable_of_decidable_of_iff, inferInstance, Prod.Lex.decidable.proof_1]]
[of_eq_true,[trivial, Eq.symm]]
[noConfusionEnum.proof_1,[Eq.symm, if_pos]]
[StateRefT',[ReaderT, ST.Ref]]
[instToFormatArray,[Std.ToFormat.mk, HAppend.hAppend, Std.Format.text, Std.ToFormat.format, Array.toList]]
[List.sublists',[List.sublists'Aux, id, List.nil]]
[instSizeOfName,[SizeOf.mk, Lean.Name.sizeOf]]
[ByteArray.mkEmpty,[ByteArray.mk, List.toArray, List.nil]]
[Mathlib.Tactic.Lint.Linter.noErrorsFound,[]]
[forallâ‚„_congr,[forall_congr', forallâ‚ƒ_congr]]
[ExceptT.bind,[ExceptT.mk, Bind.bind, ExceptT.bindCont]]
[Nat.le_of_succ_le,[Nat.le_trans, Nat.le_succ]]
[coeHead,[CoeHead.coe]]
[instOrOpUSize,[OrOp.mk, USize.lor]]
[Except.map_id,[funext, Eq.mpr, congr, congrArg, Eq, Except, Except.error, Except.ok, id_eq, rfl, Eq.symm, Eq.refl]]
[Int.lt_sub_right_of_add_lt,[]]
[coeOfHead,[CoeHTCT.mk, coeHead]]
[SubNegMonoid.gsmul_neg',[]]
[Array.instCoeSubarrayArray,[Coe.mk, Array.ofSubarray]]
[Mathlib.Tactic.Ext.tacticApply_ext_lemma,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Option.none_orelse,[rfl, Eq.symm, Eq.refl]]
[Float.le,[FloatSpec.le, floatSpec, Float.val]]
[List.sublistsAux,[List, List.nil, List.cons, PProd.fst]]
[pow_mul_comm,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HMul.hMul, HPow.hPow, Nat.zero_eq, pow_zero, one_mul, mul_one, eq_self, pow_succ', mul_assoc]]
[Nat.le_trans,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, LE.le, Nat.le.step, PProd.fst]]
[List.ofFnNthVal,[dite, LT.lt, Option.some, Fin.mk, Option.none]]
[Function.surjective.existsâ‚ƒ,[Iff.trans, Function.surjective.exists, exists_congr, Function.surjective.existsâ‚‚]]
[String.pushn,[Nat.repeat, String.push]]
[reprStr,[Std.Format.pretty, Repr.reprPrec, OfNat.ofNat, Std.Format.defWidth]]
[String.instAppendString,[Append.mk, String.append]]
[HEq.subst,[HEq.ndrecOn]]
[HShiftRight.hShiftRight,[]]
[StateRefT'.run',[Bind.bind, StateRefT'.run, Pure.pure]]
[Int.negSucc_ofNat_eq,[rfl]]
[Int.negSucc_ofNat_ofNat,[rfl]]
[Nat.min_zero,[min_eq_right, Nat.zero_le]]
[CommSemigroup.noConfusionType,[]]
[instDecidableEqSum.proof_1,[rfl]]
[ByteSliceT.off,[]]
[Neg.noConfusionType,[]]
[instSemiringFin.proof_2,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.mul_def, OfNat.ofNat, congrFun, HMod.hMod, HMul.hMul, Fin.zero_def, Nat.zero_mul, Nat.zero_mod, eq_true_of_decide, Eq.refl, Bool.true]]
[Function.update_comp_eq_of_injective,[Function.update_comp_eq_of_injective']]
[ReaderT.run_seq,[Eq.mpr, Eq.refl, Eq, ReaderT.run, Seq.seq, seq_eq_bind, rfl]]
[Mathlib.Tactic.Lint.LintVerbosity.noConfusionType,[noConfusionTypeEnum, Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx]]
[List.nil_append,[rfl]]
[List.exists_of_mem_map,[Exists, And, Mem.mem, List.nil, Eq, Eq.refl, List.eq_or_mem_of_mem_cons, Exists.intro, And.intro, List.mem_cons_self, Eq.symm, List.cons, List.mem_cons_of_mem]]
[List.disjoint_cons_left,[Iff.trans, List.disjoint_append_left, of_eq_true, Eq.trans, congrFun, congrArg, Iff, And, propext, List.singleton_disjoint, List.disjoint, Not, Mem.mem, iff_self]]
[USize.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[false_implies_iff,[Iff.intro, trivial, False.elim]]
[instAddNat,[Add.mk, Nat.add]]
[Array.mk.injEq,[Eq.propIntro, Eq.refl, Array.mk, Eq.symm, eq_of_heq, HEq.refl]]
[repr,[Repr.reprPrec, OfNat.ofNat]]
[List.product_spec,[Iff.intro, Eq.mpr, Eq.trans, implies_congr, propext, List.mem_bind, congrArg, Exists, funext, And, Mem.mem, List.mem_map, Prod.mk.injEq, exists_eq_right_right', Eq.refl, and_imp, And.intro, id]]
[Nat.gcd_eq_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, Nat.gcd_comm, Nat.gcd_eq_left, rfl]]
[ToString.noConfusionType,[]]
[Nat.toDigits,[Nat.toDigitsCore, HAdd.hAdd, OfNat.ofNat, List.nil]]
[ExceptCpsT.run_throw,[rfl]]
[StateCpsT.runK_monadLift,[rfl]]
[UInt32.noConfusionType,[]]
[Nat.ne_of_beq_eq_false,[False]]
[Nat.add_mul_div_right,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HAdd.hAdd, HMul.hMul, Nat.mul_comm, Nat.add_mul_div_left, rfl]]
[Nat.instShiftRightNat,[ShiftRight.mk, Nat.shiftRight]]
[List.union_equiv_append,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, List.mem_union_iff, List.mem_append, iff_self, Or, Mem.mem]]
[instOfScientificFloat,[OfScientific.mk, ite, Eq, Bool.true, Float.ofBinaryScientific, HSub.hSub, HMul.hMul, Neg.neg, OfNat.ofNat, Int.ofNat, HPow.hPow]]
[instSemigroupFin,[Semigroup.mk, instSemigroupFin.proof_1]]
[instLTProd,[LT.mk, Or, LT.lt, Prod.fst, And, Eq, Prod.snd]]
[ByteArray.set,[ByteArray, ByteArray.mk, Array.set]]
[gt_of_ge_of_gt,[lt_of_lt_of_le]]
[plift.noConfusionType,[]]
[instDivUInt16,[Div.mk, UInt16.div]]
[Option.melim,[Bind.bind, Option.elim]]
[instAddUInt8,[Add.mk, UInt8.add]]
[generalizeRight,[invImage, PSigma.fst]]
[Prod.fst_swap,[rfl]]
[Nat.lt_or_eq_of_le,[Or.imp_right, Nat.le_antisymm, Nat.lt_or_ge]]
[Function.involutive.surjective,[Exists.intro]]
[Subtype.trans,[Setoid.trans]]
[Tactic.Ring.RingM,[ReaderT, Tactic.Ring.Cache, StateRefT', IO.RealWorld, Tactic.Ring.State, Lean.Meta.MetaM]]
[Nat.succ_inj',[Iff.intro, Nat.succ.inj, congr_arg, Nat.succ]]
[UInt16.zero_def,[rfl]]
[instReprIterator,[Repr.mk, Std.Format, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg]]
[instToStringString,[ToString.mk]]
[String.revFind,[ite, Eq, BEq.beq, String.bsize, OfNat.ofNat, Bool.true, Option.none, String.revFindAux, String.prev]]
[Function.inv_fun_on_eq',[]]
[Nat.coprime_self,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, Eq, Nat.gcd_self, OfNat.ofNat, iff_self]]
[floatDecLt,[Float.decLt]]
[UInt8.isAlpha,[or, UInt8.isUpper, UInt8.isLower]]
[UInt8.instRingUInt8,[Ring.mk, UInt8.instRingUInt8.proof_1, UInt8.mk, Ring.gsmul, UInt8.val, UInt8.instRingUInt8.proof_2, UInt8.instRingUInt8.proof_3, UInt8.instRingUInt8.proof_4, UInt8.instRingUInt8.proof_5]]
[let_val_congr,[rfl]]
[or_of_or_of_imp_right,[Or.imp_right]]
[instMonoidWithZero,[MonoidWithZero.mk, Semiring.zero_mul, Semiring.mul_zero]]
[ByteSlice.instForInByteSliceUInt8,[ForIn.mk, ByteSlice.forIn.loop, HAdd.hAdd]]
[zero_lt_of_lt,[LT.lt, OfNat.ofNat, Nat.lt_trans, Nat.zero_lt_succ]]
[Set.inter,[setOf, And, Mem.mem]]
[Int.neg_inj,[Eq.mpr, Eq.refl, Eq, Eq.symm, Int.neg_neg, Neg.neg, rfl]]
[Nat.ble_self_eq_true,[Unit.unit, Eq, Nat.ble, Bool.true, rfl, PProd.fst]]
[Fin.mod_eq_of_lt,[Fin.eq_of_val_eq, Eq.mpr, congrFun, congrArg, Eq, Fin.val, Fin.mod_def, Eq.refl, HMod.hMod, Nat.mod_eq_of_lt, Fin.isLt, rfl]]
[Â«termÎ£'_,_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
[List.eq_of_mem_singleton,[Or.elim, List.eq_or_mem_of_mem_cons, absurd, List.not_mem_nil]]
[List.erase,[List, List.nil, Unit.unit, BEq.beq, List.cons, PProd.fst]]
[UInt32.add,[UInt32.mk, HAdd.hAdd, UInt32.val]]
[MonadWithReaderOf.noConfusionType,[]]
[Nat.min_eq_right,[Eq.mpr, Eq.refl, Eq, Nat.min, Nat.min_comm, Nat.min_eq_left]]
[List.mem_iff_get?,[Iff.trans, List.mem_iff_get, exists_congr, Iff.symm, List.get?_eq_some]]
[UInt32.mod_def,[rfl]]
[Fin.instDivFin,[Div.mk, Fin.div]]
[Array.filterSepElems,[Id.run, Array.filterSepElemsM]]
[Iff.noConfusionType,[]]
[Nat.discriminate,[Eq.refl]]
[unexpandUnit,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Array.mkEmpty,[Array.mk, List.nil]]
[Nat.lt_wfRel.proof_1,[WellFounded.intro, Acc.intro, OfNat.ofNat, absurd, Nat.not_lt_zero, Nat.succ]]
[Ring.gsmul_neg',[]]
[left_identity,[Eq]]
[Array.toSubarray,[dite, LE.le, Array.size, Subarray.mk, Nat.le_refl, Array.toSubarray.proof_1]]
[pow_succ',[Monoid.npow_succ']]
[Int.neg_add_lt_of_lt_add,[]]
[UInt16.eq_of_val_eq,[Eq, congrArg, UInt16.mk]]
[UInt64.instSemiringUInt64.proof_3,[congrArg, UInt64.mk, Semiring.nsmul_zero', UInt64.val]]
[ReaderT.read,[Pure.pure]]
[Option.eq_of_eq_some,[Eq, rfl, Iff.mpr, Iff.mp, congrArg, Option.some]]
[Nat.pow_zero,[rfl]]
[Quot.liftOn,[Quot.lift]]
[Mathlib.Tactic.Lint.Linter.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Mathlib.Tactic.Lint.Linter.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Quotient.liftOnâ‚‚,[Quotient.liftâ‚‚]]
[and_imp,[Iff.intro, And.intro]]
[Equiv.instCoeFunEquivArrow,[CoeFun.mk, Equiv.toFun]]
[lt_of_le_of_ne,[lt_of_le_not_le, mt, le_antisymm]]
[Int.mul_negSucc_ofNat_negSucc_ofNat,[rfl]]
[Nat.eq_zero_or_eq_succ_pred,[of_eq_true, Eq.trans, congr, congrArg, Or, congrFun, Eq, Nat.zero_eq, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true, eq_false', Eq.symm, Nat.succ, Nat.pred_succ, eq_self]]
[List.mapWithComplement,[List.mapWithPrefixSuffix, HAppend.hAppend]]
[RandomGen.range,[]]
[System.FilePath.isDir,[Bind.bind, EIO.toBaseIO, System.FilePath.metadata, BaseIO, Bool, Pure.pure, BEq.beq, IO.FS.Metadata.type, IO.FS.FileType.dir, Bool.false]]
[Fin.mod_eq,[Fin.eq_of_val_eq, Eq.mpr, congrFun, congrArg, Eq, Eq.trans, Fin.val, Fin.modn_def, Nat.mod_mod, Nat.mod_eq_of_lt, Fin.isLt]]
[instReprOption,[Repr.mk, Std.Format, Std.Format.text, Repr.addAppParen, HAppend.hAppend, reprArg]]
[Array.isEmpty,[Decidable.decide, Eq, Array.size, OfNat.ofNat]]
[Substring.front,[Substring.get, OfNat.ofNat]]
[noConfusionEnum,[dite, Eq, cast, noConfusionEnum.proof_1, False.elim, noConfusionEnum.proof_2]]
[Nat.mul_eq,[rfl]]
[MonadExcept.noConfusionType,[]]
[ForInStep.noConfusionType,[]]
[Mathlib.ExtendedBinder.Â«binderTerm<_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Function.left_inverse.comp,[]]
[TC.accessible.proof_1,[Acc.intro, Acc.inv]]
[Float.mk.injEq,[Eq.propIntro, Eq.refl, Float.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Task.Priority.default,[OfNat.ofNat]]
[lt_or_le,[dite, LE.le, Or.inr, Or.inl, lt_of_not_ge]]
[List.length_insert_of_mem,[Eq.mpr, Eq.refl, Eq, List.length, List.insert, List.insert_of_mem, rfl]]
[List.getRest,[List.nil, List.cons, Option, List, Option.some, Option.none, ite, Eq, PProd.fst]]
[ReaderT.instMonadReaderT,[Monad.mk]]
[UInt16.toUInt64,[Nat.toUInt64, UInt16.toNat]]
[instMonadExceptOfEST,[inferInstanceAs, MonadExceptOf, EStateM]]
[List.splitOn,[List.splitOnP, Eq]]
[mul_mul_mul_comm,[of_eq_true, Eq.trans, congr, congrArg, Eq, mul_left_comm, HMul.hMul, mul_assoc, eq_self]]
[Tactic.LibrarySearch.librarySearch,[Bind.bind, Lean.MonadOptions.getOptions, Lean.profileitM, Lean.Exception, Lean.Meta.inferType, MonadState.get, MonadExcept.tryCatch, Lean.Meta.solveByElim, Pure.pure, DoResultPR.return, Option.none, PUnit.unit, MonadStateOf.set, DoResultPR.pure, Lean.Meta.MetaM, Option, Array, Prod, Lean.MetavarContext, List, Lean.MVarId]]
[Mathlib.Tactic.Conv.convTry_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.Conv.convSeq]]
[Option.join_join,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, Option.bind, Option.none_bind, id, Option.map_none', eq_self, Option.none, Eq.symm, Option.some_bind, id_eq, Option.map_some', Option.some, Eq.refl]]
[Int.neg_add_le_of_le_add,[]]
[Nat.dvd_mul_left,[Exists.intro, Nat.mul_comm]]
[EStateM.instInhabitedResult,[Inhabited.mk, EStateM.Result.error, arbitrary]]
[Mathlib.Tactic.Ext.withExtHyps,[Bind.bind, Lean.MonadEnv.getEnv, ite, Eq, Lean.isStructure, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[Function.inv_fun_on_neg,[]]
[Option.join_ne_none',[of_eq_true, Eq.trans, congrFun, congrArg, Iff, Not, propext, Option.bind_eq_none, forall_congr, implies_congr, Option.mem_def, Mem.mem, id_eq, not_forall, Exists, funext, not_not, exists_prop, exists_eq_right, Eq, Option.some, iff_self]]
[CommGroup.mul_comm,[]]
[List.elem,[Unit.unit, Bool, Bool.false, BEq.beq, Bool.true, PProd.fst]]
[UInt8.decEq.proof_1,[rfl]]
[instDecidableLe_2,[UInt16.decLe]]
[Int.le_add_of_nonneg_left,[]]
[UInt8.shiftRight,[UInt8.mk, HShiftRight.hShiftRight, UInt8.val, UInt8.modn, OfNat.ofNat]]
[List.foldrIdxAux,[PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[List.mem_append_left,[Iff.mpr, List.mem_append, Or.inl]]
[and_iff_left_of_imp,[Iff.intro, And.left, And.intro]]
[List.length_map,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.length_nil, eq_true_of_decide, Eq.refl, Bool.true, List.length_cons, Nat.succ, eq_self, List.length]]
[Set.instLawfulFunctorSet.proof_1,[LawfulFunctor.mk, rfl, funext, propext, Iff.intro, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Exists.intro, And.intro, Functor.map, Function.comp]]
[Subarray.forRevM,[Array.forRevM, Subarray.as, Subarray.stop, Subarray.start]]
[StateCpsT.runK_get,[rfl]]
[implies,[]]
[Fin.size_positive',[Fin.size_positive, Inhabited.default]]
[HEq.rfl,[HEq.rfl.proof_1]]
[Function.right_inverse,[Function.left_inverse]]
[instForIn,[ForIn.mk, Stream.forIn]]
[USize.shiftLeft,[USize.mk, HShiftLeft.hShiftLeft, USize.val, USize.modn, System.Platform.numBits]]
[add_right_neg,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat, Eq.symm, add_left_neg, neg_neg, rfl]]
[add_assoc,[AddSemigroup.add_assoc]]
[List.eq_or_mem_of_mem_cons,[id]]
[add_right_comm,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, add_assoc, add_comm, rfl]]
[instHashableFin,[Hashable.mk, Nat.toUInt64, Fin.val]]
[List.tail?,[Unit.unit, Option, List, Option.none, Option.some]]
[decidable_of_iff',[decidable_of_decidable_of_iff, Iff.symm]]
[gt_of_gt_of_ge,[lt_of_le_of_lt]]
[Function.sometimes_eq,[dif_pos, Nonempty.intro]]
[ByteArray.instAppendByteArray,[Append.mk, ByteArray.append]]
[Int.lt_add_of_sub_left_lt,[]]
[Except.pure,[Except.ok]]
[Nat.zero_mod,[Eq.mpr, Eq.refl, Eq, HMod.hMod, OfNat.ofNat, Nat.mod_eq]]
[instToStringUInt16,[ToString.mk, ToString.toString, UInt16.toNat]]
[Int.eq_neg_of_eq_neg,[Eq.mpr, Eq.refl, Eq, Neg.neg, Int.neg_neg, rfl]]
[Array.data_toArray,[Eq, List.toArray, Array.data, Array.ext', List.toArray_data]]
[Function.inv_fun_eq,[Function.inv_fun_on_eq, Exists, And, Mem.mem, Set.univ, Eq, Exists.intro, And.intro, trivial]]
[Nat.eq_zero_or_pos,[Unit.unit, Or, Eq, OfNat.ofNat, GT.gt, Or.inl, rfl, Or.inr, Nat.succ_pos]]
[lt_or_eq_of_le,[Decidable.lt_or_eq_of_le]]
[and_iff_right_iff_imp,[Iff.intro, And.left, Iff.mpr, and_iff_right_of_imp]]
[instReprSourceInfo,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, HAppend.hAppend, Std.Format.text, Std.Format.line, reprArg, Std.Format.FlattenBehavior.allOrNone]]
[false_iff,[propext, Iff.intro, Iff.mpr, False.elim]]
[instTransLeLeLe,[Trans.mk, instTransLeLeLe.proof_1]]
[exists_and_distrib_left,[Iff.intro, And, Exists, And.intro, Exists.intro]]
[Subarray.stop,[]]
[Function.combine,[]]
[Sum.noConfusionType,[]]
[Trans.trans,[]]
[Nat.mul_mod_left,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HMul.hMul, OfNat.ofNat, Nat.mul_comm, Nat.mul_mod_right, rfl]]
[add_right_cancel,[IsAddRightCancel.add_right_cancel]]
[String.Iterator.toString,[String]]
[String.intercalate.go,[Unit.unit, String, PProd.fst, HAppend.hAppend]]
[Nat.lcm_dvd,[Dvd.dvd, Nat.lcm, Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, Nat.dvd_zero, Nat.dvd_of_mul_dvd_mul_left, Nat.gcd_pos_of_pos_left, Nat.pos_of_dvd_of_pos, HMul.hMul, Nat.gcd, Nat.gcd_mul_lcm, Eq.symm, Nat.gcd_mul_right, Nat.mul_comm, Nat.dvd_gcd, Nat.mul_dvd_mul_left, Nat.mul_dvd_mul_right]]
[Bind.noConfusionType,[]]
[modifyGetThe,[MonadStateOf.modifyGet]]
[Mathlib.Eval.evalExpr,[Lean.withoutModifyingEnv, Bind.bind, liftM, Lean.Core.mkFreshUserName, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Meta.inferType, Lean.Meta.isDefEq, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[List.mem_nil,[Iff.rfl]]
[strictAnd,[and]]
[neg_neg,[neg_eq_of_add_eq_zero, add_left_neg]]
[Prod.snd,[]]
[List.filterMap,[Unit.unit, List, List.nil, PProd.fst, List.cons]]
[UInt32.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[if_false,[if_neg, not_false]]
[ByteArray.instInhabitedByteArray,[Inhabited.mk, ByteArray.empty]]
[Fin.upRel,[WellFoundedRelation.mk, LT.lt, Fin.gt_wf]]
[FloatArray.uget,[Float, Array.uget]]
[set.separates_points,[Exists, And, Mem.mem, Ne]]
[Int.noConfusionType,[]]
[Set.setOf.unexpander,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesIdent, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[tactic_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Mathlib.Tactic.Lint.NamedLinter.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Mathlib.Tactic.Lint.NamedLinter.mk, Eq.symm, eq_of_heq, HEq.refl]]
[List.subset_append_of_subset_right,[List.subset.trans, List.subset_append_right]]
[LawfulApplicative.map_pure,[]]
[Complement.noConfusionType,[]]
[USize.instNumericUSize,[Numeric.mk, USize.mk, Numeric.ofNat]]
[Function.update_comp_eq_of_forall_ne',[funext, Function.update_noteq]]
[UInt64.sub_def,[rfl]]
[Array.binInsert,[Id.run, Array.binInsertM]]
[Int.negSucc_ofNat_inj_iff,[Iff.intro, Int.negSucc.inj, of_eq_true, Eq.trans, congrFun, congrArg, Eq, Int.negSucc, eq_self]]
[instLawfulMonadStateRefT'.proof_1,[inferInstanceAs, LawfulMonad, ReaderT, ST.Ref]]
[ReaderT.map,[Functor.map]]
[add_left_neg,[AddGroup.add_left_neg]]
[UInt64.instSemiringUInt64.proof_6,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, HMul.hMul, UInt64.zero_def, UInt64.mul_def, UInt64.mk, OfNat.ofNat, MonoidWithZero.mul_zero, UInt64.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt64]]
[Array.foldrM.fold.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self]]
[List.getLastD.proof_1,[]]
[Subtype.forall,[Iff.intro, Subtype.mk]]
[Quotient.hrecOn,[Quot.hrecOn]]
[Nat.gcd_mul_left,[Nat.gcd.induction, of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, Nat.gcd, Nat.mul_zero, HMul.hMul, Nat.gcd_zero_left, eq_self, Eq.mp, Eq.refl, HMod.hMod, Eq.symm, Nat.gcd_rec, Nat.mul_mod_mul_left]]
[Nat.min,[ite, LE.le]]
[Option.ne_none_iff_exists',[Iff.trans, Option.ne_none_iff_exists, exists_congr, eq_comm]]
[Nat.lt.base.proof_1,[Nat.le_refl, Nat.succ]]
[iff_false_intro,[Iff.intro, False.elim]]
[Pow.noConfusionType,[]]
[BinaryHeap.size_mkHeap,[Subtype.property, BinaryHeap.mkHeap]]
[List.toArray,[List.toArrayAux, Array.mkEmpty, List.redLength]]
[Nat.to_digits_core_lens_eq,[of_eq_true, eq_self, HAdd.hAdd, OfNat.ofNat, Classical.em, Eq, HDiv.hDiv, Eq.trans, congr, congrArg, List.length, ite_congr, congrFun, eq_true_of_decide, Eq.refl, Bool.true, List.cons, Nat.digitChar, HMod.hMod, Nat.toDigitsCore, if_true, Eq.symm, Eq.mpr, eq_false, if_false]]
[liftM,[MonadLiftT.monadLift]]
[StateT.run_modify,[rfl]]
[Or.assoc,[Iff.intro, Or.imp_right, Or.inl, Or.inr, Or.imp_left]]
[Nat.anyM.loop,[Unit.unit, Bool, Pure.pure, Bool.false, Bind.bind, HSub.hSub, OfNat.ofNat, Bool.true, PProd.fst]]
[Nat.gcd_le_left,[Nat.le_of_dvd, Nat.gcd_dvd_left]]
[Option.HasMem,[Mem.mk, Eq, Option.some]]
[Nat.mul_div_le,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, OfNat.ofNat, HEq.refl, LE.le, HMul.hMul, HDiv.hDiv, Nat.eq_zero_or_pos, Eq.mpr, Nat.zero_mul, Nat.zero_le, Nat.mul_comm, propext, Nat.le_div_iff_mul_le, Nat.le_refl]]
[OptionT.instMonadExceptOfUnitOptionT,[MonadExceptOf.mk, OptionT.fail, OptionT.tryCatch]]
[UInt8.mod,[UInt8.mk, HMod.hMod, UInt8.val]]
[Int.mul_lt_mul_of_pos_left,[]]
[Nat.instAndOpNat,[AndOp.mk, Nat.land]]
[Decidable.predToBool,[CoeDep.mk, Decidable.decide]]
[List.length_erase_of_mem,[Eq.mpr, Eq.refl, Eq, List.length, List.erase, Nat.pred, List.erase_eq_erasep, List.length_erasep_of_mem, rfl]]
[forallâ‚‚_congr,[forall_congr']]
[forallâ‚ƒ_congr,[forall_congr', forallâ‚‚_congr]]
[ExceptCpsT.runK,[]]
[instInhabitedUInt8.proof_1,[of_decide_eq_true, Eq.refl, Bool.true]]
[List.ext,[Eq, rfl, Eq.refl, List.get?, List.nil, OfNat.ofNat, HEq.refl, List.cons]]
[instModUInt8,[Mod.mk, UInt8.mod]]
[StateT.run_map,[of_eq_true, Eq.trans, congrArg, Eq, Bind.bind, Pure.pure, Prod.mk, map_eq_pure_bind, Prod.fst, Prod.snd, eq_self]]
[OptionT.pure,[OptionT.mk, Pure.pure, Option.some]]
[Char.isLower,[and, Decidable.decide, GE.ge, Char.val, OfNat.ofNat, LE.le]]
[Nat.eq_or_lt_of_le,[Or, Eq, LT.lt, Or.inl, rfl, Or.inr, Nat.succ_le_succ, Nat.zero_le, absurd, Nat.not_succ_le_zero]]
[UInt32.eq_of_val_eq,[Eq, congrArg, UInt32.mk]]
[Nat.lt_add_right,[lt_of_lt_of_le, Nat.le_add_right]]
[Tactic.Ring.State.atoms,[]]
[Mathlib.Prelude.Rename.align,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[guardHyp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[And.congr_right_iff,[Iff.intro, Eq.mp, congr, congrArg, Iff, Eq.trans, congrFun, And, eq_true, true_and, and_congr_right]]
[Acc.brecOn,[Acc.below.intro]]
[Semiring.zero_add,[]]
[Eq.propIntro,[propext, Iff.intro]]
[Function.inv_fun_neg,[Function.inv_fun_on_neg, mt, Exists, Eq, Exists.intro]]
[String.getOp,[String.get]]
[iff_of_eq,[Iff.rfl]]
[let_body_congr,[]]
[Int.instDivInt,[Div.mk, Int.div]]
[controlAt,[Bind.bind, MonadControlT.liftWith, MonadControlT.restoreM]]
[Int.sub_nonpos_of_le,[]]
[Quotient.recOn,[Quot.recOn]]
[or_iff_left_of_imp,[Iff.intro, id, Or.inl]]
[Equivalence.noConfusionType,[]]
[Int.sub_neg_of_lt,[]]
[Set.instInterSet,[Inter.mk, Set.inter]]
[List.get?_modifyNth_eq,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.get?_modifyNth, Functor.map, funext, ite_congr, eq_self, Eq.refl, if_pos, True, List.get?]]
[StateT.run_monadLift,[rfl]]
[USize.mk_val_eq,[Eq, USize.mk, USize.val, rfl]]
[List.forall_mem_map_iff,[Iff.intro, List.mem_map_of_mem, Iff.mp, List.mem_map, Eq.mpr, Eq.refl]]
[ExceptT.run,[]]
[EStateM.orElse',[EStateM.Result.ok, EStateM.Result, EStateM.Backtrackable.restore, EStateM.Result.error, ite, Eq, Bool.true]]
[List.get?_append,[]]
[List.hasDecEq,[Unit.unit, Decidable, Eq, Decidable.isTrue, List.hasDecEq.proof_1, Decidable.isFalse, List.hasDecEq.proof_2, List.hasDecEq.proof_3, List.cons, decEq, PProd.fst, List.hasDecEq.proof_4, List.hasDecEq.proof_5, List.hasDecEq.proof_6]]
[Int.add_le_add_three,[le_trans, Int.add_le_add, le_refl, HAdd.hAdd]]
[List.mapWithPrefixSuffix,[List.mapWithPrefixSuffixAux, List.nil]]
[List.mem_remove_iff,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, List.mem_nil, And, ne_eq, false_and, Not, Eq, eq_true_of_decide, Eq.refl, Bool.true, Eq.mpr, Mem.mem, ite, List.cons, List.mem_cons, Decidable.em, congrFun, if_pos, List, Or, Iff.intro, And.intro, Or.inr, Ne, Or.resolve_left, Eq.symm, if_neg, Or.inl, Ne.symm, And.left, And.right]]
[le_antisymm,[PartialOrder.le_antisymm]]
[Nat.add_sub_cancel_left,[]]
[List.card_map_le,[of_eq_true, Eq.trans, congr, congrArg, LE.le, List.card_nil, eq_true_of_decide, Eq.refl, Bool.true, Decidable.em, Mem.mem, List.map, Eq.mpr, congrFun, List.card_cons_of_mem, eq_true, List.card, List.cons, Nat.le_trans, List.card_le_card_cons, Eq.symm]]
[Nat.pow_succ,[rfl]]
[String.csize,[UInt32.toNat, Char.utf8Size]]
[List.subset_cons,[Or.inr]]
[Function.inv_fun,[Function.inv_fun_on, Set.univ]]
[Array.forIn,[Array.size, Nat.le_refl, Array.forIn.loop]]
[instInhabitedBool,[Inhabited.mk, Bool.false]]
[Mathlib.Tactic.Lint.Linter.errorsFound,[]]
[List.equiv_iff_subset_and_subset,[Iff.intro, And.intro, Iff.mp, Iff.mpr, Iff, Mem.mem]]
[Â«term_-_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[UInt8.toUInt16,[Nat.toUInt16, UInt8.toNat]]
[Tactic.Ring.HornerExpr.xadd.injEq,[Eq.propIntro, And.intro, Eq.refl, Tactic.Ring.HornerExpr.xadd, Eq.symm, eq_of_heq, HEq.refl]]
[DivInvMonoid.div_eq_mul_inv,[]]
[ne_self_iff_false,[not_iff_false_intro, rfl]]
[List.union,[List.foldr, List.insert]]
[Quot.hrecOn.proof_1,[eq_of_heq]]
[Mathlib.Tactic.Lint.shouldBeLinted,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Lean.ParametricAttribute.getParam, Mathlib.Tactic.Lint.nolintAttr, not, Array.contains, Option.getD, EmptyCollection.emptyCollection]]
[ReaderT.pure,[Pure.pure]]
[List.filterAux,[List, List.reverse, Unit.unit, PProd.fst, List.cons]]
[Nat.anyM,[Nat.anyM.loop]]
[List.instDecidableMem.proof_3,[not_or_intro]]
[String.intercalate,[Unit.unit, String, String.intercalate.go]]
[Function.injective2.eq_iff,[Iff.intro, Eq, congr_arg2]]
[Nat.add_le_add,[Nat.le_trans, Nat.add_le_add_right, Nat.add_le_add_left]]
[StateCpsT.instLawfulMonadStateCpsT.proof_1,[LawfulMonad.mk, rfl]]
[Nat.add_sub_of_le,[Eq, HAdd.hAdd, HSub.hSub, Eq.mpr, Eq.refl, Eq.symm, Nat.add_sub_cancel_left, rfl]]
[String.takeRightWhile,[Substring.toString, Substring.takeRightWhile, String.toSubstring]]
[WellFoundedRelation.rel,[]]
[System.FilePath.instDivFilePath,[Div.mk, System.FilePath.join]]
[CoeHead.coe,[]]
[Set.termð’«_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instDecidableEqBool,[Unit.unit, Decidable, Eq, Decidable.isTrue, rfl, Decidable.isFalse, instDecidableEqBool.proof_1, instDecidableEqBool.proof_2]]
[not_false,[id]]
[EStateM.Result.ok.injEq,[Eq.propIntro, And.intro, Eq.refl, EStateM.Result.ok, Eq.symm, eq_of_heq, HEq.refl]]
[Function.eq_update_iff,[Iff.trans, Function.funext_iff, Function.forall_update_iff, Eq]]
[Except.ok.inj,[]]
[min_assoc,[eq_min, le_trans, min_le_left, min, le_min, min_le_right]]
[Fin.checked_mul_spec,[Iff.intro, Decidable.em, LE.le, HMul.hMul, Fin.val, False.elim, Eq.mp, Eq.trans, congrFun, congrArg, Eq, Unit.unit, Bool, Option, Fin, Prod.mk, Iff.mpr, decide_eq_true_iff, Option.none, Option.some, Bool.true, Bool.false, eq_false', Eq.symm, Nat.lt_of_not_le, Eq.refl, of_eq_true, decide_eq_false, Nat.not_le_of_lt, eq_true_of_decide]]
[Option.map_eq_some',[of_eq_true, Eq.trans, congr, congrArg, Iff, congrFun, Eq, Option.map_none', Option.some, eq_false', Exists, funext, And, false_and, eq_false, exists_false, eq_true_of_decide, Eq.refl, Bool.true, Eq.symm, Option.map_some', Option.some.injEq, propext, exists_eq_left', iff_self]]
[UInt64.xor,[UInt64.mk, Fin.xor, UInt64.val]]
[Option.isEqSome,[Bool, BEq.beq, Bool.false]]
[String.Iterator.prevn,[String.Iterator, PProd.fst, String.Iterator.prev]]
[Int.sub_lt_of_sub_lt,[Int.sub_left_lt_of_lt_add, Int.lt_add_of_sub_right_lt]]
[heq_of_heq_of_eq,[HEq.trans, heq_of_eq]]
[MonoidWithZero.zero_mul,[]]
[List.append_eq_appendTR,[funext, rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, List.cons, List.reverseAux_reverseAux, List.nil, eq_self]]
[Nat.mod_add_mod,[]]
[Â«term_!=_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Subarray.start,[]]
[Prod.map_mk,[rfl]]
[proof_irrel_heq,[]]
[Nat.dvd_mul_right,[Exists.intro, rfl]]
[Nat.lt_iff_le_not_le,[Iff.intro, And.intro, Nat.le_of_lt, Nat.not_le_of_gt, Nat.gt_of_not_le, And.right]]
[le_total,[LinearOrder.le_total]]
[List.mem_nil_iff,[Iff.rfl]]
[UInt16.instNegUInt16,[Neg.mk, UInt16.mk, Neg.neg, UInt16.val]]
[instAddSemigroupFin.proof_1,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, congrFun, HAdd.hAdd, Fin.add_def, Fin.mk, HMod.hMod, Nat.mod_lt, Fin.size_positive, Nat.mod_add_mod, Nat.add_assoc, Nat.add_mod_mod, eq_self]]
[Exists.choose,[Classical.choose]]
[Classical.choose,[Subtype.val, Classical.indefiniteDescription]]
[Array.instInhabitedArray,[Inhabited.mk, Array.empty]]
[List.get?_modifyNth,[Nat.zero, List.nil, List.cons, Nat.succ, Eq, List.get?, List.modifyNth, Functor.map, ite, rfl, Eq.symm, Eq.refl, Eq.trans, PProd.fst, Decidable.em, of_eq_true, congr, congrArg, congrFun, funext, ite_congr, eq_self, if_pos, True, Option.none, HAdd.hAdd, OfNat.ofNat, eq_false, if_false, mt, Nat.succ.inj, Not, eq_true_of_decide, Bool.true, Option.some]]
[Classical.indefiniteDescription,[Classical.choice, Classical.indefiniteDescription.proof_1]]
[SubNegMonoid.sub_eq_add_neg,[]]
[List.filterMapM,[List.reverse, List.nil, List.filterMapM.loop]]
[Array.swap!,[dite, LT.lt, Array.size, Array.swap, Fin.mk, panicWithPosWithDecl, OfNat.ofNat]]
[OptionT.mk,[]]
[Int.neg_succ_lt_zero,[lt_of_not_ge, False.elim, Eq.refl, HSub.hSub, Int.negSucc, OfNat.ofNat, HEq.refl]]
[Tactic.Ring.Cache.noConfusionType,[]]
[AddMonoid.add_zero,[]]
[of_not_imp,[Decidable.of_not_imp]]
[MonadExcept.tryCatch,[]]
[Eq.mpr,[Eq.symm]]
[Int.eq_x_or_neg,[Exists.intro, Int.natAbs, Int.natAbs_eq]]
[Nat.succ_add_eq_succ_add,[of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.succ_add, Nat.add_succ, eq_self, Nat.succ, HAdd.hAdd]]
[ByteArray.toUInt64LE!,[ite, Eq, BEq.beq, ByteArray.size, OfNat.ofNat, Bool.true, HOr.hOr, HShiftLeft.hShiftLeft, UInt8.toUInt64, ByteArray.get!, panicWithPosWithDecl, HAppend.hAppend]]
[UInt64.decEq.proof_1,[rfl]]
[plift.down_up,[rfl]]
[PSigma.lex,[PSigma.lex.proof_1]]
[List.modifyHead,[Unit.unit, List, List.nil, List.cons]]
[Nat.mul_left_comm,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Eq.symm, Nat.mul_assoc, Nat.mul_comm, rfl]]
[Tactic.Ring.tacticRing,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Except.bind,[Except, Except.error]]
[Dvd.dvd,[]]
[MonadWithReader.noConfusionType,[]]
[String.toNat?,[ite, Eq, String.isNat, Bool.true, Option.some, String.foldl, HAdd.hAdd, HMul.hMul, OfNat.ofNat, HSub.hSub, Char.toNat, Char.ofNat, Option.none]]
[String.Iterator.s,[]]
[Fin.mod_eq_val,[Nat.mod_eq_of_lt, Fin.isLt]]
[List.or_exists_of_exists_mem_cons,[Or, Exists, And, Mem.mem, Eq.mpr, Eq.refl, Eq.symm, Or.inl, Or.inr, Exists.intro, And.intro]]
[Int.negSucc_ofNat_coe',[Eq.mpr, Eq.refl, Eq, Int.negSucc, HSub.hSub, Neg.neg, Int.ofNat, OfNat.ofNat, Int.sub_eq_add_neg, HAdd.hAdd, Eq.symm, Int.neg_add, rfl]]
[Equiv.apply_symm_apply,[Equiv.rightInv]]
[Mathlib.Tactic.Lint.elements,[Bind.bind, ForIn.forIn, PUnit.unit, StateT, Array, Id, ForInStep, PUnit, Mathlib.Tactic.Lint.trieElements, Pure.pure, ForInStep.yield]]
[add_left_inj,[Iff.intro, add_right_cancel, rfl]]
[Mathlib.Tactic.Ext.commandDeclareExtTheoremsFor__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Int.instSubInt,[Sub.mk, Int.sub]]
[UInt32.val_eq_of_lt,[Fin.val_eq_of_lt]]
[invImage,[WellFoundedRelation.mk, InvImage, WellFoundedRelation.rel, invImage.proof_1]]
[Fin.ne_of_val_ne,[absurd, Fin.val_eq_of_eq]]
[instAndOpUInt16,[AndOp.mk, UInt16.land]]
[List.removeAll,[List.filter, List.notElem]]
[Array.foldrMUnsafe.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bind.bind, Array.uget, HSub.hSub, OfNat.ofNat, lcProof, Array.foldrMUnsafe.fold]]
[String.trimLeft,[Substring.toString, Substring.trimLeft, String.toSubstring]]
[List.length_eq_zero,[Iff.intro, List.eq_nil_of_length_eq_zero, Eq.mpr, Eq.refl, Eq, List.length, OfNat.ofNat, rfl]]
[non_contradictory_intro,[absurd]]
[Substring.isEmpty,[BEq.beq, Substring.bsize, OfNat.ofNat]]
[Decidable.of_not_imp,[Decidable.by_contradiction, not_not_of_not_imp]]
[decidableLt_of_decidableLe.proof_1,[not_le_of_gt]]
[Nat.coprime_zero_right,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, Eq, Nat.gcd_zero_right, OfNat.ofNat, iff_self]]
[Decidable.or_iff_not_and_not,[Eq.mpr, Eq.refl, Iff, Or, Not, And, Eq.symm, propext, not_or_distrib, Decidable.not_not, Iff.rfl]]
[Nat.gcd_le_right,[Nat.le_of_dvd, Nat.gcd_dvd_right]]
[PSum.noConfusionType,[]]
[instMulUInt32,[Mul.mk, UInt32.mul]]
[instDecidableArrow.proof_1,[]]
[CoeT.coe,[]]
[Int.sub_eq_zero_iff_eq,[Iff.intro, Int.eq_of_sub_eq_zero, Int.sub_eq_zero_of_eq]]
[Function.injective.ne,[mt]]
[List.forIn,[List.forIn.loop]]
[ExceptT.instMonadLiftExceptT,[MonadLift.mk, ExceptT.lift]]
[of_decide_eq_false,[Not, absurd, ne_false_of_eq_true, decide_eq_true]]
[Fin.isLt,[]]
[instDecidableOr.proof_1,[False]]
[Nat.mul_mod_right,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HMul.hMul, OfNat.ofNat, Eq.symm, Nat.zero_add, HAdd.hAdd, Nat.add_mul_mod_self_left, Nat.zero_mod, rfl]]
[Tactic.NormCast.instInhabitedNormCastExtension,[Inhabited.mk, Tactic.NormCast.NormCastExtension.mk, arbitrary]]
[Prod.rprod.proof_1,[Subrelation.wf, WellFoundedRelation.wf, Prod.lex, Prod.RProdSubLex]]
[Quot.recOnSubsingleton,[Quot.rec, Quot.recOnSubsingleton.proof_1]]
[Mathlib.Tactic.Lint.instDecidableEqLintVerbosity.proof_2,[absurd, Eq.refl, Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx]]
[Array.filterSepElemsM,[OfNat.ofNat, List.toArray, List.nil]]
[USize.instNegUSize,[Neg.mk, USize.mk, Neg.neg, USize.val]]
[Int.sub_lt_sub_of_lt_of_le,[Int.add_lt_add_of_lt_of_le, Int.neg_le_neg]]
[UInt64.instSemiringUInt64.proof_8,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt64.one_def, UInt64.mul_def, UInt64.mk, OfNat.ofNat, mul_one, UInt64.val, UInt64.mk_val_eq, eq_self, propext, forall_const, UInt64]]
[Array.getOp,[Array.get!]]
[Array.uset,[Array.set, Fin.mk, USize.toNat]]
[instSubUSize,[Sub.mk, USize.sub]]
[instOfNatUInt16,[OfNat.mk, UInt16.ofNat]]
[Option.isNone_none,[rfl]]
[List.filterM,[Bind.bind, List.filterAuxM, List.nil, Pure.pure, List.reverse]]
[And.right,[]]
[List.instSetoidList,[Setoid.mk, List.Perm, List.Perm.Equivalence]]
[UInt16.neg_def,[rfl]]
[String.leftpad,[String.mk, List.leftpad, String.data]]
[instInhabitedPNonScalar,[Inhabited.mk, PNonScalar.mk, arbitrary]]
[List.mem_erase_of_ne,[Eq.mpr, Eq.refl, Iff, Mem.mem, List.erase, List.erase_eq_erasep, List.mem_erasep_of_neg, Ne.symm]]
[or_comm,[Or.comm]]
[ByteArray.foldlM.proof_1,[Nat.le_refl, ByteArray.size]]
[IsAddLeftCancel.noConfusionType,[]]
[Â«command_ClassAbbrev__:_:=__,Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[Nat.add_left_comm,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Eq.symm, Nat.add_assoc, Nat.add_comm, rfl]]
[tacticMatch_target_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[HXor.noConfusionType,[]]
[Nat.toUSize,[USize.ofNat]]
[And.left,[]]
[plift.up.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Char.utf8Size.proof_1,[of_decide_eq_true, Eq.refl, Bool.true]]
[Char.utf8Size.proof_7,[of_decide_eq_true, Eq.refl, Bool.true]]
[pow_zero,[Monoid.npow_zero']]
[instReprFin,[Repr.mk, repr, Fin.val]]
[Prod.RProdSubLex,[Prod.RProdSubLex.proof_1]]
[Option.eq_some_iff_get_eq,[Eq.mpr, Eq.trans, congrFun, congrArg, Iff, eq_false', Exists, Eq, Option.get, false_iff, propext, not_exists, sorryAx, False, Bool.true, Eq.symm, of_eq_true, congr, Option.some.injEq, funext, Option.get_some, exists_prop, And, Option.isSome_some, eq_true_of_decide, Eq.refl, true_and, iff_self]]
[Nat.allM,[Nat.allM.loop]]
[Nat.mul_lt_mul',[Nat.lt_of_le_of_lt, Nat.mul_le_mul_of_nonneg_right, Nat.mul_lt_mul_of_pos_left]]
[Int.mul_zero,[Eq, HMul.hMul, OfNat.ofNat, rfl]]
[BinaryHeap.replaceMax.proof_2,[Eq.mpr, congrArg, LT.lt, OfNat.ofNat, Array.size_set, BinaryHeap.arr, Fin.mk, BinaryHeap.size_pos_of_max]]
[max_eq_right_of_lt,[max_eq_right, le_of_lt]]
[Thunk.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Fin.nsmuls_eq,[Eq, HMul.hMul, Fin.ofNat', Fin.size_positive', Fin.val, Fin.eq_of_val_eq, Eq.mpr, congrFun, congrArg, Fin.mul_def, Fin.mk, HMod.hMod, Nat.mod_lt, Eq.refl, Eq.symm, Nat.mod_eq_of_lt, Nat.mul_mod, rfl]]
[Nat.succ_pos,[Nat.zero_lt_succ]]
[or_false,[propext, Iff.intro, False.elim, Or.inl]]
[Prod.map,[Prod, Prod.mk]]
[Nat.sub_lt,[LT.lt, HSub.hSub, absurd, Nat.lt_irrefl, OfNat.ofNat, Eq.symm, Nat.succ_sub_succ_eq_sub]]
[String.toUpper,[String.map, Char.toUpper]]
[instReprUInt8,[Repr.mk, repr, UInt8.toNat]]
[eq_rec_heq,[eqRec_heq]]
[Tactic.Ring.HornerExpr.xadd.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[forall_prop_decidable,[dite, decidableOfDecidableOfIff, forall_prop_decidable.proof_1, Decidable.isTrue, forall_prop_decidable.proof_2]]
[Nat.sub_self,[Unit.unit, Eq, HSub.hSub, OfNat.ofNat, Eq.mpr, Eq.refl, Nat.sub_zero, rfl, Nat.succ, Nat.succ_sub_succ, PProd.fst]]
[FloatArray.data,[]]
[Monoid.toOne,[]]
[UInt8.instSemiringUInt8.proof_9,[rfl]]
[Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1]]
[ByteSliceT.mk.inj,[And.intro]]
[iff_self,[propext, Iff.intro, trivial, id]]
[MonadExceptOf.tryCatch,[]]
[Decidable.not_iff_comm,[Eq.mpr, Eq.refl, Iff, Not, propext, iff_def, And, and_congr, Decidable.not_imp_comm, imp_not_comm]]
[Float.mk.inj,[]]
[Fin.mk.injEq,[Eq.propIntro, Eq.refl, Fin.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Â«term_||_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.lt_succ_iff,[Iff.intro, Nat.le_of_lt_succ, Nat.lt_succ_of_le]]
[and_congr_left',[and_congr, Iff.rfl]]
[Nat.pos_of_dvd_of_pos,[Nat.pos_of_ne_zero, Nat.lt_irrefl, OfNat.ofNat, Eq.mp, Eq.refl, LT.lt, Nat.eq_zero_of_zero_dvd, Dvd.dvd]]
[Nat.sub_one_sub_lt,[Eq.mpr, Eq.refl, LT.lt, HSub.hSub, OfNat.ofNat, Nat.sub_sub, Nat.sub_lt, Nat.lt_of_lt_of_le, Nat.zero_lt_succ, HAdd.hAdd, Nat.add_comm]]
[String.offsetOfPos,[String.offsetOfPosAux, OfNat.ofNat]]
[Function.surj_inv_eq,[Classical.choose_spec]]
[instInhabitedSubstring,[Inhabited.mk, Substring.mk, OfNat.ofNat]]
[USize.val_eq_of_eq,[Eq, USize.val, congrArg]]
[Fin.xor,[Fin, Fin.mk, HMod.hMod, Nat.xor, Fin.xor.proof_1]]
[Nat.toDigitsCore,[List, Char, ite, Eq, OfNat.ofNat, List.cons, PProd.fst]]
[instMonadControlExceptT,[MonadControl.mk, Except, liftM, ExceptT.run]]
[Int.zero_add,[Int.add_zero, Int.add_comm, OfNat.ofNat]]
[List.get?_set_ne,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.get?, List.set_eq_modifyNth, List.get?_modifyNth_ne, eq_self]]
[Int.neg_eq_neg_one_mul,[Unit.unit, Eq, Neg.neg, HMul.hMul, OfNat.ofNat, rfl]]
[String.Iterator.hasPrev,[Bool, Decidable.decide, GT.gt, OfNat.ofNat]]
[EIO.toBaseIO,[EStateM.Result, Empty, IO.RealWorld, Except, EStateM.Result.ok, Except.ok, Except.error]]
[And.elim,[And.left, And.right]]
[Function.has_uncurry_induction,[Function.has_uncurry.mk, Function.has_uncurry.uncurry, Prod.fst, Prod.snd]]
[Substring.hasBeq,[BEq.mk, Substring.beq]]
[instSemiringFin.proof_3,[Fin.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, Fin.val, Eq.trans, HMul.hMul, Fin.add_def, Fin.mul_def, Fin.mk, HMod.hMod, HAdd.hAdd, Nat.mod_lt, Fin.size_positive, Nat.add_mod_mod, Nat.mod_add_mod, Eq.refl, Eq.symm, Eq.mp, Nat.mul_mod, Nat.mod_eq_of_lt, Fin.isLt, Semiring.mul_add, rfl]]
[UInt8.one_def,[rfl]]
[opt_param_eq,[optParam_eq]]
[false_of_ne,[Ne.irrefl]]
[Pure.pure,[]]
[Nat.succ_ne_zero,[]]
[USize.decLe,[Decidable, LE.le, inferInstanceAs]]
[min_eq_right,[Eq.mpr, Eq.refl, Eq, min, min_comm, min_eq_left]]
[Â«term_::_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.log2,[WellFounded.fix, Nat.log2.proof_1, dite, GE.ge, OfNat.ofNat, HAdd.hAdd, HDiv.hDiv, Eq.refl, Nat.zero, HEq.refl, absurd, of_decide_eq_false, Decidable.decide, Nat.succ, LT.lt, of_decide_eq_true, Bool.true, Eq.mpr, Nat.div_eq, ite, And, LE.le, HSub.hSub, if_pos, And.intro, Nat.succ_lt_succ, Nat.zero_lt_succ, Nat.lt_trans, PProd.fst, PProd.snd, Nat.lt_succ_self]]
[Function.surjective.prod_map,[Exists, Eq, Prod.map, Exists.intro, Prod.mk, Prod.ext']]
[Nat.dvd_of_mul_dvd_mul_left,[Exists.elim, Exists.intro, Nat.eq_of_mul_eq_mul_left, Eq.mp, Eq.refl, Eq, HMul.hMul, Nat.mul_assoc]]
[Tactic.Find.Â«command#find_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[not_le,[Iff.symm, lt_iff_not_ge]]
[Int.add_zero,[Eq, HAdd.hAdd, OfNat.ofNat, rfl]]
[LawfulMonad.bind_assoc,[]]
[Int.lt_add_of_neg_lt_sub_left,[Int.lt_add_of_neg_add_lt_left, Int.add_lt_of_lt_sub_right]]
[List.cons_union,[of_eq_true, eq_self, List.insert]]
[ST.Prim.Ref.modifyUnsafe,[Bind.bind, ST.Prim.Ref.take, ST.Prim.Ref.set]]
[Function.decidable_eq_pfun,[Decidable, Eq, decidable_of_iff, Function.decidable_eq_pfun.proof_1]]
[String.contains,[String.any, BEq.beq]]
[List.filterAuxM,[List, Pure.pure, Bind.bind, PProd.fst, cond, List.cons]]
[Fin.sub_def,[Eq, HSub.hSub, Fin.mk, HMod.hMod, HAdd.hAdd, Fin.val, Nat.mod_lt, Fin.size_positive, rfl]]
[SeqLeft.seqLeft,[]]
[UInt16.mk_val_eq,[Eq, UInt16.mk, UInt16.val, rfl]]
[Mathlib.Tactic.Conv.find,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq]]
[List.transpose,[Unit.unit, List, List.nil, List.transposeAux, PProd.fst]]
[instLawfulFunctorOption,[instLawfulFunctorOption.proof_1]]
[Function.surjective_iff_has_right_inverse,[Iff.intro, Function.surjective.has_right_inverse, Function.has_right_inverse.surjective]]
[IsMulRightCancel.noConfusionType,[]]
[Int.lt_of_sub_neg,[]]
[EStateM.instToStringResult,[ToString.mk, String, HAppend.hAppend, ToString.toString]]
[termPrintln!__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[Function.uncurry_curry,[funext, Eq, Function.uncurry, Function.curry, rfl]]
[Â«term_<*>_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[exists_prop_decidable.proof_1,[Iff.intro, Exists.intro]]
[UInt32.instSemiringUInt32.proof_1,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt32.zero_def, UInt32.add_def, UInt32.mk, OfNat.ofNat, add_zero, UInt32.val, UInt32.mk_val_eq, eq_self, propext, forall_const, UInt32]]
[List.map_nil,[rfl]]
[List.not_exists_mem_nil,[False, Eq.refl]]
[ExceptT.mk,[]]
[Monoid.toSemigroup,[]]
[Int.lt_of_le_sub_one,[Int.add_le_of_le_sub_right]]
[Nat.le_of_sub_eq_zero,[Nat.zero, Nat.succ, LE.le, of_eq_true, Eq.trans, congrFun, congrArg, Eq.mp, Eq.refl, Eq, HSub.hSub, OfNat.ofNat, Nat.sub_zero, eq_true_of_decide, Bool.true, Nat.zero_le, HAdd.hAdd, Nat.add_le_add_right, PProd.fst, Nat.add_sub_add_right]]
[decidableOfDecidableOfIff.proof_1,[absurd, Iff.mpr]]
[instAddSemigroupFin,[AddSemigroup.mk, instAddSemigroupFin.proof_1]]
[DoResultSBC.noConfusionType,[]]
[Nat.div_one,[]]
[Int.neg_neg_ofNat_succ,[rfl]]
[Fin.instAddFin,[Add.mk, Fin.add]]
[Array.swap.proof_1,[Eq.symm, Array.size_set, Array.get]]
[Int.neg_lt_sub_right_of_lt_add,[Int.lt_sub_left_of_add_lt, Int.sub_right_lt_of_lt_add]]
[String.front,[String.get, OfNat.ofNat]]
[Int.ofNat.injEq,[Eq.propIntro, Eq.refl, Int.ofNat, Eq.symm, eq_of_heq, HEq.refl]]
[OptionT.instMonadOptionT,[Monad.mk]]
[imp_iff_not_or,[Decidable.imp_iff_not_or]]
[Bool.or_true,[rfl, Eq.symm, Eq.refl]]
[Function.surjective.of_comp_iff',[Iff.intro, Exists, Eq, Exists.intro, Function.bijective.injective, Function.surjective.comp, Function.bijective.surjective]]
[Nat.add_le_add_iff_le_right,[Iff.intro, Nat.le_of_add_le_add_right, Nat.add_le_add_right]]
[Int.ofNat_natAbs_of_nonpos,[Eq.mpr, Eq.refl, Eq, Int.ofNat, Int.natAbs, Neg.neg, Eq.symm, Int.natAbs_neg, Int.natAbs_of_nonneg, Int.neg_nonneg_of_nonpos, rfl]]
[List.tail,[Unit.unit, List, List.nil]]
[String.instInhabitedRange,[Inhabited.mk, String.Range.mk, arbitrary]]
[List.toString,[Unit.unit, String, HAppend.hAppend, List.toStringAux, Bool.true, List.cons]]
[AddMonoid.zero_add,[]]
[exists_eq_right_right,[Iff.intro, And, And.intro, Exists, Eq, Exists.intro, rfl]]
[Fin.elim0,[absurd, Nat.not_lt_zero]]
[UInt32.add_def,[rfl]]
[Array.indexOf?,[Array.indexOfAux, OfNat.ofNat]]
[AddSemigroup.add_assoc,[]]
[Mem.mem,[]]
[Mathlib.Tactic.Lint.LintVerbosity.noConfusion,[noConfusionEnum, Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx]]
[not_and_of_not_right,[mt, And.right]]
[implies_of_if_neg,[]]
[HOrElse.noConfusionType,[]]
[List.reverse_reverse,[Eq.mpr, Eq.refl, Eq, List.reverseAux, List.nil, List.reverseAux_reverseAux_nil, rfl]]
[bind_congr,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Bind.bind, funext, eq_self]]
[BinaryHeap.mk.inj,[]]
[instAddCommGroup,[AddCommGroup.mk, instAddCommGroup.proof_5]]
[List.init,[Unit.unit, List.cons, List, List.nil, PProd.fst]]
[EStateM.nonBacktrackable,[EStateM.Backtrackable.mk, EStateM.dummySave, EStateM.dummyRestore]]
[ST.Ref.mk.injEq,[Eq.propIntro, Eq.refl, ST.Ref.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Int.ofNat_mul_ofNat,[rfl]]
[exists_prop_decidable.proof_2,[mt]]
[RandomGen.noConfusionType,[]]
[Nat.lt_or_ge,[Unit.unit, Or, LT.lt, GE.ge, Or.inr, Nat.zero_le, Nat.succ, PProd.fst, Or.inl, Nat.le_succ_of_le, Nat.eq_or_lt_of_le, Nat.le_refl]]
[Zero.noConfusionType,[]]
[UInt32.decEq,[Decidable, Eq, dite, Decidable.isTrue, UInt32.decEq.proof_1, Decidable.isFalse, UInt32.decEq.proof_2]]
[Â«term_<&>_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Quotient.exists_rep,[Quot.exists_rep]]
[Setoid.noConfusionType,[]]
[UInt64.instRingUInt64.proof_2,[congrArg, UInt64.mk, Ring.gsmul_zero', UInt64.val]]
[EmptyCollection.noConfusionType,[]]
[Array.any,[Id.run, Array.anyM]]
[unexpandSigma,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[UInt16.shiftLeft,[UInt16.mk, HShiftLeft.hShiftLeft, UInt16.val, UInt16.modn, OfNat.ofNat]]
[Array.noConfusionType,[]]
[instLTOption,[LT.mk, Option.lt, LT.lt]]
[List.instLTList,[LT.mk, List.lt]]
[Int.mul_lt_mul_of_neg_right,[]]
[String.Iterator.extract,[String, ite, Eq, or, Decidable.decide, Ne, GT.gt, Bool.true, String.extract]]
[Nat.lt_succ_self,[Nat.lt.base]]
[Int.sub_eq_zero_of_eq,[Eq.mpr, Eq.refl, Eq, HSub.hSub, OfNat.ofNat, Int.sub_self, rfl]]
[List.erase_cons,[Decidable.em, Eq, of_eq_true, Eq.trans, congr, congrArg, congrFun, Unit.unit, List, Iff.mp, EqIffBeqTrue, Eq.symm, List.cons, if_pos, List.erase, eq_self, NeqIffBeqFalse, Ne.symm, if_neg, Eq.refl]]
[List.inj_on,[Eq]]
[Nat.mul_div_cancel_left,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, Nat.mul_comm, Nat.mul_div_cancel, rfl]]
[List.disjoint_left,[of_eq_true, iff_self, False]]
[instDecidableRelLeLeOfOrd,[inferInstanceAs, DecidableRel, Eq, Ordering.isLE, Ord.compare, Bool.true]]
[instSubsingleton,[instSubsingleton.proof_1]]
[StateRefT'.get,[ST.Ref.get]]
[Array.filterM,[Array.foldlM, Bind.bind, ite, Eq, Bool.true, Pure.pure, Array.push, List.toArray, List.nil]]
[Option.lt,[Option.none, Option.some, True, False]]
[Int.quot,[Int, Int.ofNat, HDiv.hDiv, Neg.neg, Nat.succ]]
[List.reverse_cons,[Eq.mpr, Eq.refl, Eq, HAppend.hAppend, List.reverseAux, List.nil, List.cons, Eq.symm, List.reverseAux_eq_append, rfl]]
[UInt64.instNegUInt64,[Neg.mk, UInt64.mk, Neg.neg, UInt64.val]]
[instOrOpUInt32,[OrOp.mk, UInt32.lor]]
[Nat.repeat.loop,[PProd.fst]]
[List.card_cons_of_not_mem,[Eq.mpr, Eq.refl, Eq, ite, Mem.mem, HAdd.hAdd, OfNat.ofNat, List.card, if_neg, rfl]]
[Substring.splitOn,[ite, Eq, BEq.beq, Bool.true, List.cons, List.nil, OfNat.ofNat, Substring.splitOn.loop]]
[Nat.mul_mod_mul_right,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HMul.hMul, Nat.mul_comm, Nat.mul_mod_mul_left]]
[throwThe,[MonadExceptOf.throw]]
[Â«term_>>>_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.lt_ge_by_cases.proof_1,[Iff.mp, not_lt]]
[Option.bind_assoc,[rfl, Eq.symm, Eq.refl]]
[Option.ext,[Option.none, Option.some, Eq, rfl, Eq.symm, Iff.mp, Iff.mpr]]
[by_contra,[Decidable.by_contradiction]]
[Â«term_âˆ‰_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[ReaderT.instLawfulMonadReaderT.proof_1,[LawfulMonad.mk, ReaderT.ext, Eq.mpr, congr, congrArg, Eq, Eq.trans, ReaderT.run_bind, Pure.pure, Bind.bind, ReaderT.run, funext, ReaderT.run_pure, ReaderT.run_map, LawfulMonad.bind_pure_comp, rfl, of_eq_true, congrFun, LawfulMonad.pure_bind, eq_self, LawfulMonad.bind_assoc]]
[unsafeIO,[unsafeEIO]]
[toBoolUsing_eq_true,[decide_eq_true]]
[StateT.seqRight_eq,[StateT.ext, Eq.mpr, congr, congrArg, Eq, StateT.run_seqRight, Eq.trans, StateT.run_seq, Functor.map, id, Bind.bind, StateT.run_map, map_eq_pure_bind, Prod.mk, Prod.snd, StateT.run, funext, Prod.fst, LawfulMonad.bind_assoc, Pure.pure, LawfulMonad.pure_bind, congrFun, id_eq, bind_congr, of_eq_true, Prod.ext, bind_pure, eq_self, Eq.symm, Eq.refl]]
[Bool.false.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Prod.exists',[Prod.exists]]
[List.get!,[List.nil, PProd.fst, panicWithPosWithDecl, OfNat.ofNat]]
[BinaryHeap.noConfusionType,[]]
[Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1]]
[Int.lt_of_add_one_le,[]]
[List.find,[Unit.unit, Option, Option.none, ite, Option.some, PProd.fst]]
[Prod.map_fst',[funext, Prod.map_fst]]
[MonadFunctorT.noConfusionType,[]]
[Int.lt_of_neg_lt_neg,[Int.neg_lt_neg, Int.neg_neg]]
[Nat.le.brecOn,[Nat.le.below.refl, Nat.le.below.step]]
[imp_not_self,[Iff.intro]]
[existsâ‚ƒ_congr,[exists_congr, existsâ‚‚_congr]]
[Mathlib.Tactic.Lint.getAllDecls,[Bind.bind, Mathlib.Tactic.Lint.getDeclsInCurrModule, Lean.MonadEnv.getEnv, Pure.pure, HAppend.hAppend, Array.map, Prod.fst, Std.HashMap.toArray, Lean.SMap.mapâ‚, Lean.Environment.constants]]
[instMulUInt64,[Mul.mk, UInt64.mul]]
[not_and',[Iff.trans, not_and, imp_not_comm]]
[UInt8.instSemiringUInt8.proof_8,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt8.one_def, UInt8.mul_def, UInt8.mk, OfNat.ofNat, mul_one, UInt8.val, UInt8.mk_val_eq, eq_self, propext, forall_const, UInt8]]
[List.mapIdxAux,[List, List.nil, List.cons, PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[List.partitionMap,[Unit.unit, Prod, List, Prod.mk, List.nil, Prod.map, id, List.cons, PProd.fst]]
[Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx,[OfNat.ofNat]]
[Int.sign_mul_natAbs,[Unit.unit, Eq, HMul.hMul, Int.sign, Int.ofNat, Int.natAbs, Int.one_mul, HAdd.hAdd, OfNat.ofNat, rfl, Eq.symm, Int.neg_eq_neg_one_mul, Int.negSucc]]
[Nat.toUInt16,[UInt16.ofNat]]
[Function.surjective.has_right_inverse,[Exists.intro, Function.surj_inv, Function.right_inverse_surj_inv]]
[List.find?,[Unit.unit, Option, Option.none, Option.some, PProd.fst]]
[ReprTuple.reprTuple,[]]
[Nat.zero_mul,[Unit.unit, Eq, HMul.hMul, OfNat.ofNat, rfl, Eq.symm, PProd.fst, Nat.mul_succ]]
[List.toArrayAux_data,[Eq, Array.data, List.toArrayAux, HAppend.hAppend, Eq.symm, List.append_nil, List.nil, Eq.trans, PProd.fst, Array.push, of_eq_true, congrFun, congrArg, Array.mk, List.concat_eq_append, List.append_assoc, List.cons, List.singleton_append, eq_self]]
[List.splitAt,[Prod, List, Prod.mk, List.nil, List.cons]]
[Nat.coprime.mul_right,[Nat.coprime.symm, Nat.coprime.mul]]
[Prod.allI,[Nat.anyAux, not, Prod.snd, HSub.hSub, Prod.fst]]
[StateCpsT.runK_bind_lift,[rfl]]
[instTransGtGeGt,[Trans.mk, instTransGtGeGt.proof_1]]
[instXorUInt8,[Xor.mk, UInt8.xor]]
[Tactic.Cache.get,[Bind.bind, Pure.pure, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, liftM, EIO.asTask, StateRefT'.run, Prod.fst, Task.Priority.default]]
[List.append_right_injective,[List.append_left_cancel]]
[Function.right_inverse.injective,[Function.left_inverse.injective, Function.right_inverse.left_inverse]]
[SubNegMonoid.noConfusionType,[]]
[instShiftRightUInt64,[ShiftRight.mk, UInt64.shiftRight]]
[Subtype.map_involutive,[Subtype.ext, Subtype.val]]
[ByteSlice.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Int.nonneg_of_neg_nonpos,[Int.le_of_neg_le_neg, Eq.mpr, Eq.refl, LE.le, Neg.neg, OfNat.ofNat, Int.neg_zero]]
[LinearOrder.le_total,[]]
[Char.utf8Size.proof_3,[of_decide_eq_true, Eq.refl, Bool.true]]
[Fin.checkedSub,[Option, Fin, Fin.underflowingSub, Option.none, Option.some]]
[Int.le.intro_sub,[Eq.mpr, Eq.trans, propext, Int.le_def, congrArg, Int.NonNeg, Int.NonNeg.mk]]
[Nat.coprime_one_left_iff,[of_eq_true, Eq.trans, congr, congrArg, Iff, congrFun, Eq, Nat.gcd_one_left, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true]]
[nsmul_rec,[OfNat.ofNat, HAdd.hAdd, PProd.fst]]
[or_iff_right_iff_imp,[Eq.mpr, Eq.refl, Iff, Or, propext, or_comm, or_iff_left_iff_imp, Iff.rfl]]
[Ord.compare,[]]
[instAddFloat,[Add.mk, Float.add]]
[Int.sub_le_of_sub_le,[Int.sub_left_le_of_le_add, Int.le_add_of_sub_right_le]]
[instReprUInt64,[Repr.mk, repr, UInt64.toNat]]
[forall_eq,[Iff.intro, rfl, Eq.symm]]
[readThe,[MonadReaderOf.read]]
[UInt16.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd]]
[CommRing.noConfusionType,[]]
[Int.negOfNat_mul_negSucc_ofNat,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Int.negOfNat, Int.negSucc, Int.ofNat, Nat.succ, Int.mul_comm, Int.negSucc_ofNat_mul_negOfNat, Nat.mul_comm, rfl]]
[Option.pmap.proof_1,[Iff.mpr, Option.mem_def, rfl]]
[Ordering.lt.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[UInt32.instAddCommSemigroupUInt32,[AddCommSemigroup.mk, UInt32.instAddCommSemigroupUInt32.proof_1]]
[Mathlib.Tactic.Lint.groupedByFilename,[Bind.bind, ForIn.forIn, Lean.Core.CoreM, ForInStep, Std.HashMap, Lean.Name, Lean.MessageData, Lean.findModuleOf?, Lean.MonadEnv.getEnv, Pure.pure, PUnit.unit, ForInStep.yield, List.mapM, Mathlib.Tactic.Lint.printWarnings, HAppend.hAppend, Lean.ToMessageData.toMessageData, Array.toList, Lean.MessageData.joinSep, Lean.MessageData.ofFormat, Std.Format.line]]
[List.Perm.symm,[List.Perm.nil, List.Perm.cons, List.Perm.swap, List.Perm.trans]]
[Set.instLawfulFunctorSet,[Set.instLawfulFunctorSet.proof_1]]
[DivInvMonoid.toInv,[]]
[StateRefT'.set,[ST.Ref.set]]
[String.Iterator.hasNext,[Bool, Decidable.decide, LT.lt, String.utf8ByteSize]]
[Subtype.coind_injective,[congrArg, Subtype.val]]
[Array.forRevM,[Array.foldrM, PUnit.unit]]
[decidableLt_of_decidableLe.proof_2,[le_of_lt]]
[UInt16.instSemiringUInt16.proof_10,[rfl]]
[withPtrEq,[Unit.unit]]
[Int.le_of_lt,[LE.le, Int.le.intro, Nat.succ]]
[UInt16.instAddCommSemigroupUInt16.proof_1,[congrArg, UInt16.mk, AddCommSemigroup.add_comm, UInt16.val]]
[Int.sub_left_lt_of_lt_add,[]]
[Nat.eq_zero_of_le_zero,[Nat.le_antisymm, Nat.zero_le]]
[Nat.dvd_refl,[Exists.intro, OfNat.ofNat, of_eq_true, Eq.trans, congrArg, Eq, Nat.mul_one, eq_self]]
[cond,[Unit.unit]]
[Option.map_some',[rfl]]
[Nat.imax,[ite, Eq, OfNat.ofNat, Nat.max]]
[EIO.bindTask,[BaseIO.bindTask, EIO.catchExceptions, Pure.pure, Task.pure, Except.error]]
[instHSub,[HSub.mk, Sub.sub]]
[String.foldl,[String.foldlAux, String.bsize, OfNat.ofNat]]
[List.head_eq_of_cons_eq,[]]
[String.Iterator.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.replicateTR.loop,[List, PProd.fst, List.cons]]
[Subtype.coe_mk,[rfl]]
[Array.filter,[Array.foldl, ite, Eq, Bool.true, Array.push, List.toArray, List.nil]]
[instXorUInt32,[Xor.mk, UInt32.xor]]
[MonadStateOf.get,[]]
[UInt8.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd]]
[Tactic.Ring.State.numAtoms,[]]
[Fin.checkedMul,[Option, Fin, Fin.overflowingMul, Option.none, Option.some]]
[List.hasDecEq.proof_3,[]]
[UInt8.shiftLeft,[UInt8.mk, HShiftLeft.hShiftLeft, UInt8.val, UInt8.modn, OfNat.ofNat]]
[le_or_lt,[Or.symm, lt_or_le]]
[Option.get!,[Unit.unit, panicWithPosWithDecl, OfNat.ofNat]]
[eq_comm,[Iff.intro, Eq.symm]]
[Int.neg_lt_sub_left_of_lt_add,[]]
[Int.le_refl,[Int.le.intro, Int.add_zero]]
[add_neg_cancel_right,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, add_assoc, add_right_neg, OfNat.ofNat, add_zero, rfl]]
[Nat.mul_succ,[rfl]]
[List.leftpad_length,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.length_append, List.repeat, HSub.hSub, List.length, HAdd.hAdd, List.length_repeat, Nat.sub_add_eq_max, max, eq_self]]
[String.foldrAux,[String.foldrAux.loop]]
[CommSemiring.noConfusionType,[]]
[UInt8.toChar,[Char.mk, UInt8.toUInt32, UInt8.toChar.proof_1]]
[String.next,[HAdd.hAdd, String.csize]]
[lt_trichotomy,[Or.elim, le_total, Decidable.lt_or_eq_of_le, Or.inl, Or.inr, Eq.symm]]
[Equiv.inv_fun_as_coe,[rfl]]
[instMonadExceptOfExceptT,[MonadExceptOf.mk, ExceptT.mk, throwThe, tryCatchThe]]
[FloatArray.forIn,[FloatArray.size, Nat.le_refl, FloatArray.forIn.loop]]
[PSigma.revLex,[PSigma.revLex.proof_1]]
[Substring.drop,[Substring.mk, Substring, HAdd.hAdd, Substring.nextn, OfNat.ofNat]]
[Nat.div_self,[Eq.mp, Eq.refl, Eq, HDiv.hDiv, Nat.succ, OfNat.ofNat, Nat.zero_div, HAdd.hAdd, Nat.zero_add]]
[List.findIdxs,[List.foldrIdx, ite, List.cons, List.nil]]
[Function.const_apply,[rfl]]
[FloatArray.mk.inj,[]]
[instHModUInt64NatUInt64,[HMod.mk, UInt64.modn]]
[Nat.coprime.mul_dvd_of_dvd_of_dvd,[Dvd.dvd, HMul.hMul, Nat.mul_dvd_mul_left, Nat.coprime.dvd_of_dvd_mul_left, Nat.coprime.symm, Eq.symm]]
[HAnd.hAnd,[]]
[Int.lt_add_succ,[Int.le.intro, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, OfNat.ofNat, Int.ofNat, Nat.succ, Int.add_comm, Int.add_left_comm, rfl]]
[Int.sub_one_lt_of_le,[Int.sub_right_lt_of_lt_add, Int.lt_add_one_of_le]]
[Nat.lt_succ_of_le,[Nat.succ_le_succ]]
[or_not,[em]]
[Int.add_sub_assoc,[Eq.mpr, Eq.refl, Eq, HSub.hSub, HAdd.hAdd, Int.sub_eq_add_neg, Neg.neg, Int.add_assoc, Eq.symm, rfl]]
[instDecidableArrow,[dite, Decidable.isTrue, instDecidableArrow.proof_1, Decidable.isFalse, instDecidableArrow.proof_2, instDecidableArrow.proof_3]]
[One.noConfusionType,[]]
[Semiring.npow_succ',[]]
[instHAndThen,[HAndThen.mk, AndThen.andThen]]
[List.mem_cons_eq,[rfl]]
[GE.ge,[LE.le]]
[Equiv.symm_comp_self,[funext, Equiv.symm_apply_apply]]
[Mathlib.Tactic.Lint.formatLinterResults,[Bind.bind, Array.filterMapM, Lean.Core.CoreM, Option, Lean.MessageData, ite, Eq, not, Std.HashMap.isEmpty, Bool.true, Mathlib.Tactic.Lint.groupedByFilename, Mathlib.Tactic.Lint.printWarnings, Mathlib.Tactic.Lint.LintVerbosity.high, Pure.pure, Option.some, HAppend.hAppend, Lean.ToMessageData.toMessageData, Mathlib.Tactic.Lint.Linter.noErrorsFound, Mathlib.Tactic.Lint.NamedLinter.toLinter, Option.none, OfNat.ofNat, Array.size, Array.filterM, Mathlib.Tactic.Lint.isAutoDecl]]
[gpow_rec,[npow_rec, Inv.inv, Nat.succ]]
[Char.lt,[LT.lt, Char.val]]
[Int.sub_nat_self,[Unit.unit, Eq, Int.subNatNat, OfNat.ofNat, rfl, Eq.mpr, Eq.refl, Nat.succ, Int.subNatNat_of_sub_eq_zero, HSub.hSub, Nat.sub_self, Int.ofNat, Int.ofNat_zero]]
[mul_pow,[of_eq_true, Eq.trans, congr, congrArg, Eq, HPow.hPow, HMul.hMul, Nat.zero_eq, pow_zero, mul_one, OfNat.ofNat, eq_self, congrFun, mul_comm, Nat.succ, pow_succ', mul_assoc]]
[Option.toList,[Unit.unit, List, List.nil, List.cons]]
[not_iff_self,[iff_not_self, Iff.symm]]
[UInt8.isDigit,[and, Decidable.decide, GE.ge, OfNat.ofNat, LE.le]]
[CommSemigroup.mul_comm,[]]
[UInt64.mod,[UInt64.mk, HMod.hMod, UInt64.val]]
[commandOfNat_class___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[instInhabitedUInt16,[Inhabited.mk, UInt16.ofNatCore, OfNat.ofNat, instInhabitedUInt16.proof_1]]
[Option.mem_unique,[Option.some.inj, Eq.trans, Eq.symm]]
[Classical.axiomOfChoice,[Exists.intro, Classical.choose, Classical.choose_spec]]
[instStreamRangeNat,[Stream.mk, ite, LT.lt, Std.Range.start, Std.Range.stop, Option.some, Prod.mk, Std.Range.mk, HAdd.hAdd, Std.Range.step, Option.none]]
[instNegFin.proof_1,[Nat.mod_lt, HSub.hSub, Fin.val, lt_of_le_of_lt, Nat.zero_le, Fin.isLt]]
[instInhabitedUInt64.proof_1,[of_decide_eq_true, Eq.refl, Bool.true]]
[EStateM.set,[EStateM.Result.ok, PUnit.unit]]
[Mathlib.Tactic.Lint.decorateError,[MonadExcept.tryCatch, MonadExcept.throw]]
[Int.neg_of_sign_eq_neg_one,[LT.lt, OfNat.ofNat, Eq.refl, Neg.neg, HEq.refl, Int.ofNat, HAdd.hAdd, Int.neg_succ_lt_zero]]
[List.length_pos_of_ne_nil,[Iff.mpr, Nat.pos_iff_ne_zero, Iff.mp, List.length_eq_zero]]
[Functor.map_equiv,[Equiv.mk, Functor.map, Equiv.toFun, Equiv.symm, Functor.map_equiv.proof_1, Functor.map_equiv.proof_2]]
[List.get?_append_right,[Eq.refl, Nat.zero, HEq.refl, Eq, List.get?, HAppend.hAppend, HSub.hSub, List.length, rfl, Eq.mpr, List.cons, HAdd.hAdd, OfNat.ofNat, List.cons_append, congr, congrArg, Eq.trans, Nat.add_eq, Nat.add_zero, List.length_cons, Nat.succ, Nat.add_sub_add_right, PProd.fst, Iff.mp, Nat.lt_succ_iff]]
[UInt16.instRingUInt16.proof_2,[congrArg, UInt16.mk, Ring.gsmul_zero', UInt16.val]]
[Id.run,[]]
[or_self_right,[Iff.intro, Or.elim, id, Or.inr, Function.comp, Or.inl]]
[Equiv.trans,[Equiv.mk, Function.comp, Equiv.toFun, Equiv.symm, Equiv.trans.proof_1, Equiv.trans.proof_2]]
[not_forall_of_exists_not,[False]]
[Nat.succ.injEq,[Eq.propIntro, Eq.refl, Nat.succ, Eq.symm, eq_of_heq, HEq.refl]]
[List.mem_insert_of_mem,[Iff.mpr, List.mem_insert_iff, Or.inr]]
[sizeOfWFRel,[measure, SizeOf.sizeOf]]
[Â«tacticBy_cases__:_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[WellFounded.noConfusionType,[]]
[Nat.repr,[List.asString, Nat.toDigits, OfNat.ofNat]]
[UInt32.land,[UInt32.mk, Fin.land, UInt32.val]]
[GroupWithZero.toZero,[]]
[ST.Ref.ptrEq,[liftM, ST.Prim.Ref.ptrEq]]
[String.find,[String.findAux, String.bsize, OfNat.ofNat]]
[decidable_of_decidable_of_iff.proof_1,[Iff.mp, not_iff_not_of_iff]]
[List.head!,[Unit.unit, panicWithPosWithDecl, OfNat.ofNat]]
[List.tailD,[List]]
[List.length_eq_lengthTR,[funext, of_eq_true, Eq.trans, congrArg, Eq, List.length, Eq.symm, List.length_add_eq_lengthTRAux, OfNat.ofNat, Nat.add_zero, eq_self]]
[Array.appendCore.loop,[dite, LT.lt, Array.size, Unit.unit, Array, PProd.fst, HAdd.hAdd, OfNat.ofNat, Array.push, Array.get, Fin.mk]]
[Nat.mul_one,[Nat.zero_add]]
[List.card,[Unit.unit, Nat, OfNat.ofNat, ite, Mem.mem, PProd.fst, HAdd.hAdd]]
[false_of_true_eq_false,[trivial]]
[add_neg_self,[add_right_neg]]
[instMonadControlReaderT,[MonadControl.mk, id]]
[Tactic.Ring.State.noConfusionType,[]]
[List.Pairwise.brecOn,[List.Pairwise.below.nil, List.Pairwise.below.cons]]
[instReprAtomChar,[ReprAtom.mk]]
[instReprId,[inferInstanceAs, Repr]]
[List.mem_bind,[Eq.mpr, congrFun, congrArg, Iff, Eq.trans, propext, List.mem_join, Exists, funext, And, List.mem_map, Mem.mem, Iff.intro, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Exists.intro, And.intro, Eq, rfl]]
[Function.uncurry,[Prod.fst, Prod.snd]]
[Array.filterMapM,[Array.foldlM, Bind.bind, Unit.unit, Array, Pure.pure, Array.push, List.toArray, List.nil]]
[List.eq_nil_iff_forall_not_mem,[]]
[Nat.gcd_one_left,[Eq.mpr, Eq.refl, Eq, Nat.gcd, OfNat.ofNat, Nat.gcd_succ, HMod.hMod, Nat.succ, Nat.mod_one, rfl]]
[Fin.mod.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[Fin.underflowingSub,[Prod.mk, Decidable.decide, LT.lt, Fin.val, HSub.hSub]]
[dif_eq_if,[Eq, dite, ite, rfl]]
[Ne.elim,[]]
[Char.utf8Size.proof_5,[of_decide_eq_true, Eq.refl, Bool.true]]
[ByteArray.foldlM,[dite, LE.le, ByteArray.size, ByteArray.foldlM.proof_1]]
[false_or,[propext, Iff.intro, False.elim, Or.inr]]
[Nat.zero_lt_succ,[Nat.succ_le_succ, Nat.zero_le]]
[List.sublistsAuxâ‚,[List, List.nil, HAppend.hAppend, List.cons, PProd.fst]]
[Prod.mk.inj_right,[And.left, Prod.mk.inj]]
[Int.mul_sub,[Trans.trans, Int.distrib_left, Neg.neg, of_eq_true, Eq.trans, congr, congrArg, Eq, HAdd.hAdd, HMul.hMul, Int.mul_neg_eq_neg_mul_symm, Int.sub_eq_add_neg, eq_self]]
[Equivalence.refl,[]]
[peirce',[id]]
[Option.eq_none_of_isNone,[Eq.refl, Bool.true, HEq.refl, Eq, Option.none, rfl]]
[Â«termÎ£_,_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
[Â«term_âˆ©_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Int.le_natAbs,[Or.elim, le_total, OfNat.ofNat, Eq.mpr, Eq.refl, LE.le, Int.ofNat, Int.natAbs, Int.eq_natAbs_of_zero_le, Int.le_refl, le_trans, Int.ofNat_zero_le]]
[Nat.min_succ_succ,[]]
[ST.Ref.swap,[liftM, ST.Prim.Ref.swap]]
[Â«term_<*_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Ordering.noConfusionType,[noConfusionTypeEnum, Ordering.toCtorIdx]]
[instDecidableEqPUnit,[Decidable.isTrue, PUnit.subsingleton]]
[instHashableUSize,[Hashable.mk, USize.toUInt64]]
[Nat.lt_trans,[Nat.le_trans, Nat.le_step]]
[MonadControlT.restoreM,[]]
[System.FilePath.pathSeparators,[ite, Eq, System.Platform.isWindows, Bool.true, List.cons, Char.ofNat, List.nil]]
[List.notElem,[not, List.elem]]
[Array.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Mathlib.Tactic.Lint.heuristicallyExtractSimpLemmas,[Mathlib.Tactic.Lint.heuristicallyExtractSimpLemmasCore, Mathlib.Tactic.Lint.constToSimpDeclMap]]
[ne_true_of_not,[]]
[exacts,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat]]
[dite_false,[rfl]]
[MonadControlT.stM,[]]
[Set.Â«term{_|_}_1Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Mathlib.ExtendedBinder.extBinders]]
[not_le_of_gt,[And.right, le_not_le_of_lt]]
[Int.subNatNat_sub,[Eq.mpr, Eq.refl, Eq, Int.subNatNat, HSub.hSub, HAdd.hAdd, Eq.symm, Int.subNatNat_add_add, Nat.sub_add_cancel, rfl]]
[List.eraseDups,[List.eraseDupsAux, List.nil]]
[Â«termÂ¬_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Option.some_inj,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, Option.some.injEq, Eq, iff_self]]
[Mathlib.Tactic.Lint.withSimpLemmaInfos,[Lean.Meta.withReducible, Bind.bind, Lean.Meta.mkSorry, Bool.true, Bool.false, Array.mapM, Lean.Meta.MetaM, Lean.Meta.forallTelescopeReducing, Pure.pure, Lean.Expr.eq?, Option.none, Mathlib.Tactic.Lint.isConditionalHyps, Array.toList, Mathlib.Tactic.Lint.SimpLemmaInfo.mk, Lean.throwError, HAppend.hAppend, Lean.ToMessageData.toMessageData, List.toArray]]
[Function.cantor_injective,[Function.cantor_surjective, Function.right_inverse.surjective, funext, propext, Iff.intro, rfl]]
[Bool.toLBool,[Unit.unit, Lean.LBool, Lean.LBool.true, Lean.LBool.false]]
[Fin.instXorFin,[Xor.mk, Fin.xor]]
[EStateM.run,[]]
[List.instListDecidableLe,[inferInstanceAs, Decidable, Not, LT.lt]]
[Classical.strongIndefiniteDescription.proof_2,[absurd]]
[List.range',[List, Nat, List.nil, List.cons, PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[instDecidableEqSum.proof_4,[absurd]]
[Or.resolve_left,[Or.elim, absurd, id]]
[noConfusionEnum.proof_2,[congrArg]]
[Mathlib.Tactic.Lint.isSimpLemma,[Bind.bind, liftM, Lean.Meta.getSimpLemmas, Pure.pure, Std.PersistentHashSet.contains, Lean.Meta.SimpLemmas.lemmaNames]]
[Inhabited.noConfusionType,[]]
[And.imp_left,[And.imp, id]]
[Function.surjective.forall,[Iff.intro]]
[unexpandIte,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[Fin.land.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[Â«term_%_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instDecidableEqQuotient.proof_2,[absurd, Quotient.exact]]
[USize.instSemiringUSize.proof_2,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, USize.zero_def, USize.add_def, USize.mk, OfNat.ofNat, zero_add, USize.val, USize.mk_val_eq, eq_self, propext, forall_const, USize]]
[OrElse.noConfusionType,[]]
[List.mapTRAux,[List, List.reverse, PProd.fst, List.cons]]
[Nat.repr_length,[Eq.symm, Classical.em, Eq, HDiv.hDiv, Nat.succ, OfNat.ofNat, Eq.mpr, congrFun, congrArg, LE.le, List.length, ite_congr, Eq.trans, eq_true_of_decide, Eq.refl, Bool.true, List.cons, Nat.digitChar, HMod.hMod, List.nil, congr, Nat.toDigitsCore, Nat.to_digits_core_length, of_decide_eq_true, HAdd.hAdd]]
[PSum.inl.injEq,[Eq.propIntro, Eq.refl, PSum.inl, Eq.symm, eq_of_heq, HEq.refl]]
[StateT.get,[Pure.pure, Prod.mk]]
[EStateM.Result.error.inj,[And.intro]]
[instCoeTailNat,[CoeTail.mk, Numeric.ofNat]]
[not_or,[Iff.intro, And.intro, mt, Or.inl, Or.inr, False, Or.elim]]
[Tactic.Ring.mkAppCS,[Bind.bind, MonadReader.read, Pure.pure, Lean.mkAppN, Lean.mkConst, List.cons, Tactic.Ring.Cache.univ, List.nil, HAppend.hAppend, List.toArray, Tactic.Ring.Cache.Î±, Tactic.Ring.Cache.cs]]
[or_iff_not_imp_left,[Decidable.or_iff_not_imp_left]]
[Nat.coprime_div_gcd_div_gcd,[Eq.mpr, Eq.refl, Nat.coprime, HDiv.hDiv, Nat.gcd, propext, Nat.coprime_iff_gcd_eq_one, Eq, OfNat.ofNat, Nat.gcd_div, Nat.gcd_dvd_left, Nat.gcd_dvd_right, Nat.div_self, rfl]]
[StateCpsT.runK_bind_pure,[rfl]]
[Int.negOfNat,[Unit.unit, Int, OfNat.ofNat, Int.negSucc]]
[Ne.irrefl,[rfl]]
[List.dropLast,[Unit.unit, List.cons, List, List.nil, PProd.fst]]
[Tactic.Find.findType,[Lean.Meta.withReducible, Bind.bind, liftM, Lean.Meta.instantiateMVars, Lean.Meta.forallMetaTelescopeReducing, Option.none, Lean.MetavarKind.natural, Lean.Meta.abstractMVars, Lean.MonadEnv.getEnv, Tactic.DeclCache.get, Tactic.Find.findDeclsPerHead, ForIn.forIn, Lean.Meta.mkFreshLevelMVars, Lean.ConstantInfo.numLevelParams, Pure.pure, Lean.ConstantInfo.instantiateTypeLevelParams, Lean.Meta.forallTelescopeReducing, Lean.Meta.AbstractMVarsResult.numMVars, Lean.Expr.instantiateLevelParamsArray, Lean.Meta.AbstractMVarsResult.expr, Lean.Meta.AbstractMVarsResult.paramNames, List.toArray, Lean.Meta.lambdaMetaTelescope, Lean.Elab.Term.TermElabM, Bool, andM, Lean.Meta.isDefEq, Array.toList, List.nil, ite, Eq, Bool.true, GT.gt, OfNat.ofNat, Lean.Elab.logInfo, Lean.ToMessageData.toMessageData, ForInStep.done, PUnit.unit, ForInStep.yield]]
[instAndOpUInt64,[AndOp.mk, UInt64.land]]
[Nat.coprime.gcd_mul_right_cancel,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.mul_comm, Nat.coprime.gcd_mul_left_cancel, rfl]]
[EIO,[EStateM, IO.RealWorld]]
[Div.div,[]]
[Tactic.Find.Â«tactic#find_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Nat.add_one_ne_zero,[Nat.succ_ne_zero]]
[Nat.decEq.proof_1,[Eq.refl, Nat.beq]]
[Nat.coprime.gcd_left,[Nat.coprime.coprime_dvd_left, Nat.gcd_dvd_right]]
[UInt8.mk_val_eq,[Eq, UInt8.mk, UInt8.val, rfl]]
[PNonScalar.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[StateRefT'.instMonadFunctorStateRefT',[inferInstanceAs, MonadFunctor, ReaderT, ST.Ref]]
[List.toFloatArray.loop,[FloatArray, PProd.fst, FloatArray.push]]
[Int.sub_eq_add_neg,[rfl]]
[MonadControl.noConfusionType,[]]
[coeOfHeafOfTCOfTail,[CoeHTCT.mk, coeTail, coeTC, coeHead]]
[EStateM.instMonadStateOfEStateM,[MonadStateOf.mk, EStateM.get, EStateM.set, EStateM.modifyGet]]
[List.get_map',[List.get_map, List.length_map]]
[Option.lift_or_get_none_left,[rfl, Eq.symm, Eq.refl]]
[Function.involutive,[Eq]]
[Nat.gcd_eq_left,[Nat.dvd_antisymm, Nat.gcd_dvd_left, Nat.dvd_gcd, Nat.dvd_refl]]
[DoResultPR.pure.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[FloatArray.mk.injEq,[Eq.propIntro, Eq.refl, FloatArray.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.succ_mul,[rfl, Eq.mpr, Eq.refl, Eq, HMul.hMul, Nat.succ, HAdd.hAdd, Nat.mul_succ, Nat.add_succ, Nat.add_right_comm]]
[List.exists_mem_cons_of_exists,[Exists, And, Mem.mem, List.cons, Exists.intro, And.intro, Or.inr]]
[ByteArray.foldlMUnsafe.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bind.bind, ByteArray.uget, lcProof, ByteArray.foldlMUnsafe.fold, HAdd.hAdd, OfNat.ofNat]]
[Array.size_set,[List.length_set, Array.data, Fin.val]]
[List.get_map,[Option.some.inj, Eq.mpr, Eq.refl, Eq, Option.some, List.get, List.map, Eq.symm, List.get?_eq_get, List.get?, List.get?_map, Option.map, rfl]]
[instSizeOfNat,[SizeOf.mk]]
[List.ext_get,[List.ext, dite, LT.lt, List.length, Eq.mpr, Eq.refl, Eq, List.get?, List.get?_eq_get, Option.some, List.get, Eq.symm, rfl]]
[Nat.mul_le_mul_right,[Nat.mul_le_mul_left, Nat.mul_comm]]
[Subtype.simps.coe,[Subtype.val]]
[Function.update_comp_eq_of_forall_ne,[Function.update_comp_eq_of_forall_ne']]
[List.length_le_of_sublist,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, LE.le, List.length, le_refl, OfNat.ofNat, Nat.le_succ_of_le, PProd.fst, Nat.succ_le_succ]]
[Mul.mul,[]]
[Int.subNatNat_add,[]]
[Int.le_add_of_sub_left_le,[]]
[Function.extend_comp,[funext, Function.extend_apply]]
[List.not_mem_of_not_mem_cons,[absurd, Or.inr]]
[Nat.min_eq_min,[rfl]]
[USize.add,[USize.mk, HAdd.hAdd, USize.val]]
[UInt64.add_def,[rfl]]
[Nat.lt_irrefl,[Nat.not_succ_le_self]]
[Â«stx_,*,?Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Setoid.iseqv,[]]
[Acc.ndrec,[]]
[Bool.true_or,[rfl, Eq.symm, Eq.refl]]
[HXor.hXor,[]]
[Mathlib.Prelude.Rename.elabAlign,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Lean.Elab.Command.liftCoreM, Mathlib.Prelude.Rename.addNameAlignment, Lean.Syntax.getId, Lean.Elab.throwUnsupportedSyntax]]
[String.isPrefix,[List.isPrefix]]
[or_iff_not_imp_right,[Decidable.or_iff_not_imp_right]]
[Except.error.inj,[]]
[String.anyAux,[String.anyAux.loop]]
[Nat.dvd_add_iff_right,[Iff.intro, Nat.dvd_add, Exists.elim, Eq.symm, eq_of_heq, Eq.refl, HMul.hMul, HEq.refl, Dvd.dvd, Exists.intro, HSub.hSub, Eq.mpr, Eq, Nat.mul_sub_left_distrib, HAdd.hAdd, Nat.add_sub_cancel_left, rfl]]
[Array.findSomeM?,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, ForInStep, MProd, Option, PUnit, Pure.pure, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, MProd.fst]]
[GroupWithZero.exists_pair_ne,[]]
[List.isSuffix,[Exists, Eq, HAppend.hAppend]]
[ST.Ref.h,[]]
[add_left_cancel,[IsAddLeftCancel.add_left_cancel]]
[Except.ok.injEq,[Eq.propIntro, Eq.refl, Except.ok, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.le_succ,[Nat.le.step, Nat.le.refl]]
[Nat.div,[WellFounded.fix, Nat.div.proof_1, dite, And, LT.lt, OfNat.ofNat, LE.le, HAdd.hAdd, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le, Nat.zero]]
[Â«termâ†‘_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[WellFoundedRelation.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Div.noConfusionType,[]]
[Semiring.toAddCommSemigroup,[]]
[commandSudoSet_option___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Nat.log2.proof_1,[]]
[DivInvMonoid.gpow,[]]
[Fin.mod,[Fin, Fin.mk, HMod.hMod, Fin.mod.proof_1]]
[StateT,[Prod]]
[Mathlib.Tactic.Ext.mkAndN,[Unit.unit, List.cons, Lean.Expr, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil, Lean.mkAnd, PProd.fst]]
[instReprAtomString,[ReprAtom.mk]]
[Tactic.Ring.horner,[HAdd.hAdd, HMul.hMul, HPow.hPow]]
[Decidable.iff_iff_and_or_not_and_not,[Iff.intro, Eq.mpr, Eq.refl, Or, And, Not, propext, Decidable.em, Or.inl, And.intro, Eq.symm, Or.inr, Iff, And.right, And.left, False.elim]]
[Array.anyM.proof_1,[Nat.le_refl, Array.size]]
[Option.orelse_none,[rfl, Eq.symm, Eq.refl]]
[Function.eval,[]]
[existsâ‚„_congr,[exists_congr, existsâ‚ƒ_congr]]
[Substring.stopPos,[]]
[instShiftLeftUInt64,[ShiftLeft.mk, UInt64.shiftLeft]]
[Nat.pred_succ,[rfl]]
[System.FilePath.join,[ite, Eq, System.FilePath.isAbsolute, Bool.true, System.FilePath.mk, HAppend.hAppend, System.FilePath.toString, Char.toString, System.FilePath.pathSeparator]]
[Id.instLawfulMonadId,[Id.instLawfulMonadId.proof_1]]
[instToStringBool,[ToString.mk, cond]]
[not_iff,[Decidable.not_iff]]
[StateCpsT.runK,[]]
[Fin.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Monoid.one_mul,[]]
[List.instDecidableMem,[Unit.unit, Decidable, Mem.mem, Decidable.isFalse, not_false, dite, Eq, Decidable.isTrue, List.instDecidableMem.proof_1, List.cons, PProd.fst, List.instDecidableMem.proof_2, List.instDecidableMem.proof_3]]
[Function.involutive.ite_not,[Eq.mpr, Eq.refl, Eq, ite, Not, apply_ite, ite_not, rfl]]
[Setoid.symm,[Equivalence.symm, Setoid.iseqv]]
[LawfulApplicative.seq_assoc,[]]
[Array.concatMap,[Array.foldl, HAppend.hAppend, Array.empty, OfNat.ofNat, Array.size]]
[String.toSubstring,[Substring.mk, OfNat.ofNat, String.bsize]]
[BEq.noConfusionType,[]]
[Nat.dvd_zero,[Exists.intro, OfNat.ofNat, of_eq_true, Eq.trans, congrArg, Eq, Nat.mul_zero, eq_true_of_decide, Eq.refl, Bool.true]]
[ReaderT.adapt,[]]
[Mathlib.Tactic.Conv.traceLHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[ReaderT.instMonadExceptOfReaderT,[MonadExceptOf.mk, liftM, MonadExcept.throw, tryCatchThe]]
[UInt16.size_positive,[of_decide_eq_true, Eq.refl, Bool.true]]
[Nat.mul_div_cancel',[Eq.mp, Eq.refl, Eq, HAdd.hAdd, OfNat.ofNat, HMul.hMul, HDiv.hDiv, Nat.zero_add, HMod.hMod, Nat.mod_eq_zero_of_dvd]]
[Int.sub_lt_sub_left,[Int.add_lt_add_left, Int.neg_lt_neg]]
[UInt32.toUInt8,[Nat.toUInt8, UInt32.toNat]]
[Decidable.imp_or_distrib',[Decidable.em, of_eq_true, Eq.trans, congr, congrArg, Iff, implies_congr, Eq.refl, congrFun, Or, eq_true, true_or, implies_true, eq_true_of_decide, Bool.true, Eq.symm, Eq.mpr, eq_false, False, false_or, Iff.symm, or_iff_right_of_imp, False.elim]]
[String.atEnd,[Bool, Decidable.decide, GE.ge, String.utf8ByteSize]]
[Function.injective.prod_map,[]]
[FloatArray.foldl,[Id.run, FloatArray.foldlM]]
[instHModUSizeNatUSize,[HMod.mk, USize.modn]]
[Nat.mul_assoc,[Eq, HMul.hMul, rfl]]
[unexpandListNil,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Array.heapSort,[Array.toBinaryHeap, List.toArray, List.nil, Array.heapSort.loop]]
[AddSemigroup.toAdd,[]]
[Mathlib.Prelude.Rename.getRenameMap,[Lean.SimplePersistentEnvExtension.getState, Mathlib.Prelude.Rename.renameExtension]]
[StateT.instMonadStateT,[Monad.mk]]
[ExceptT.lift_pure,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, ExceptT.mk, LawfulApplicative.map_pure, Except.ok, Pure.pure, eq_self]]
[WellFoundedRelation.wf,[]]
[Int.neg_neg,[Unit.unit, Eq, Neg.neg, rfl]]
[UInt32.decLe,[Decidable, LE.le, inferInstanceAs]]
[Function.surjective_id,[Exists.intro, rfl]]
[instDivUInt64,[Div.mk, UInt64.div]]
[List.toByteArray,[ByteArray.empty, List.toByteArray.loop]]
[instDecidableArrow.proof_3,[absurd]]
[Applicative.toFunctor,[]]
[instInhabitedList,[Inhabited.mk, List.nil]]
[Nat.instOrOpNat,[OrOp.mk, Nat.lor]]
[proofIrrel,[rfl]]
[dite,[]]
[Option.some_injective,[Iff.mp, Option.some_inj]]
[Group.toDivInvMonoid,[]]
[Id,[]]
[Int.instMulInt,[Mul.mk, Int.mul]]
[instOrOpUInt64,[OrOp.mk, UInt64.lor]]
[Â«term_<||>_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[String.prev,[String.Pos, ite, Eq, OfNat.ofNat, PProd.fst]]
[Int.neg_mul_comm,[of_eq_true, Eq.trans, congr, congrArg, Eq, Int.neg_mul_eq_neg_mul_symm, Int.mul_neg_eq_neg_mul_symm, eq_self, Neg.neg, HMul.hMul]]
[instComplementUInt8,[Complement.mk, UInt8.complement]]
[Function.left_inverse_iff_comp,[Iff.intro, Function.left_inverse.comp_eq_id, congr_fun]]
[SeqRight.noConfusionType,[]]
[Int.neg_add_cancel_right,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, Int.add_assoc, Int.add_left_neg, OfNat.ofNat, Int.add_zero, rfl]]
[Nat.mod_zero,[]]
[ExceptT.run_map,[Eq.mpr, congrArg, Eq, ExceptT.run, ExceptT.mk, Bind.bind, Except, Pure.pure, Except.ok, Except.error, map_eq_pure_bind, Except.map, bind_congr, of_eq_true, eq_self, Eq.symm, Eq.refl]]
[Nat.lt_of_lt_of_le,[Nat.le_trans]]
[UInt32.instSemiringUInt32.proof_12,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HMul.hMul, UInt32.add_def, UInt32.mul_def, UInt32.mk, HAdd.hAdd, UInt32.val, UInt32.eq_of_val_eq, Semiring.add_mul]]
[Nat.gcd_gcd_self_left_left,[Eq.mpr, Eq.refl, Eq, Nat.gcd, Nat.gcd_comm, Nat.gcd_gcd_self_left_right, rfl]]
[instStreamSubarray,[Stream.mk, dite, LT.lt, Subarray.start, Subarray.stop, Option.none]]
[Int.add_le_add,[le_trans, Int.add_le_add_right, Int.add_le_add_left]]
[UInt16.val_eq_of_eq,[Eq, UInt16.val, congrArg]]
[Int.sign_eq_zero_iff_zero,[Iff.intro, Int.eq_zero_of_sign_eq_zero, Eq.mpr, Eq.refl, Eq, Int.sign, OfNat.ofNat, Int.sign_zero, rfl]]
[BinaryHeap.increaseKey,[BinaryHeap.mk, Subtype.val, BinaryHeap.heapifyUp, Array.set, BinaryHeap.arr, Fin.mk, Fin.val, BinaryHeap.increaseKey.proof_1]]
[instBEqProd,[BEq.mk, Bool, and, BEq.beq]]
[Array.insertionSort.traverse,[Unit.unit, Array, dite, LT.lt, Array.size, PProd.fst, Array.insertionSort.swapLoop, HAdd.hAdd, OfNat.ofNat]]
[not_not_not,[Iff.intro, mt, not_not_intro]]
[UInt64.neg_def,[rfl]]
[List.Â«term_<:+_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Â«term_>>=_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Function.inv_fun_on_eq,[And.right, Function.inv_fun_on_pos]]
[Nat.le_of_eq,[Nat.le_refl]]
[List.nil_subset,[False.elim, Iff.mp, List.mem_nil_iff]]
[decidable_of_bool.proof_2,[mt, Iff.mpr, Bool.ff_ne_tt]]
[Array.size,[List.length, Array.data]]
[instMonadExceptOfEIO,[inferInstanceAs, MonadExceptOf, EStateM, IO.RealWorld]]
[Nat.lcm_comm,[]]
[Â«term_â‰ƒ_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instHOr,[HOr.mk, OrOp.or]]
[Equiv.self_comp_symm,[funext, Equiv.apply_symm_apply]]
[Nat.eq_of_mul_eq_mul_left,[Nat.le_antisymm, Nat.le_of_mul_le_mul_left, Nat.le_of_eq, Eq.symm]]
[heq_iff_eq,[Iff.intro, eq_of_heq, heq_of_eq]]
[Decidable.not_imp,[Iff.intro, And.intro, Decidable.of_not_imp, not_of_not_imp, not_imp_of_and_not]]
[Nat.pred_lt_pred,[Eq.refl, Nat.zero, HEq.refl, LT.lt, Nat.pred, False.elim, rfl, Nat.lt_of_succ_lt_succ]]
[fix1,[fixCore1, arbitrary]]
[Int.neg_pos_of_neg,[]]
[Nat.add_zero,[rfl]]
[Nat.le_total,[Or, LE.le, Nat.lt_or_ge, Or.inl, Nat.le_of_lt, Or.inr]]
[inv_eq_of_mul_eq_one,[left_inv_eq_right_inv, inv_mul_self]]
[HAndThen.noConfusionType,[]]
[List.append_right_inj,[Function.injective.eq_iff, List.append_right_injective]]
[UInt8.decEq,[Decidable, Eq, dite, Decidable.isTrue, UInt8.decEq.proof_1, Decidable.isFalse, UInt8.decEq.proof_2]]
[List.replicateTR_loop_replicate_eq,[of_eq_true, Eq.trans, congrArg, Eq, List.replicate, congrFun, HAdd.hAdd, Nat.zero_eq, Nat.zero_add, eq_self, Eq.mpr, List.replicateTR.loop, List.cons, Nat.succ_add, OfNat.ofNat]]
[BinaryHeap.size_pos_of_max,[Decidable.of_not_not, False.elim, Eq.mp, Eq.trans, congrFun, congrArg, Eq, dite_congr, eq_false, Eq.refl, Option.some, Array.get, BinaryHeap.arr, Fin.mk, OfNat.ofNat, Eq.mpr_prop, Option.none, dite_false, eq_false']]
[true_iff,[propext, Iff.intro, Iff.mp, trivial]]
[instTransGeGtGt.proof_1,[gt_of_ge_of_gt]]
[MonadState.modifyGet,[]]
[Int.gcd,[Nat.gcd, Int.natAbs]]
[UInt64.instRingUInt64.proof_5,[UInt64.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, UInt64.val, congrFun, HAdd.hAdd, UInt64.neg_def, UInt64.add_def, UInt64.mk, Neg.neg, add_left_neg, UInt64.zero_def, eq_true_of_decide, Eq.refl, Bool.true]]
[Int.mul_assoc,[Eq, HMul.hMul, of_eq_true, Eq.trans, congr, congrArg, congrFun, Int.ofNat_mul_ofNat, Int.ofNat, Nat.mul_assoc, eq_self, Eq.symm, Int.negSucc, Int.ofNat_mul_negSucc_ofNat, Int.negOfNat, Nat.succ, Int.ofNat_mul_negOfNat, Eq.refl, Int.negOfNat_mul_ofNat, Int.negSucc_ofNat_ofNat, Int.negOfNat_mul_negSucc_ofNat, Int.mul_negSucc_ofNat_negSucc_ofNat, Int.negSucc_ofNat_mul_negOfNat]]
[instToStringUnit,[ToString.mk]]
[UInt64.le,[LE.le, UInt64.val]]
[USize.toUInt32,[Nat.toUInt32, USize.toNat]]
[Nat.gcd_mul_left_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.gcd_comm, Nat.gcd_mul_left_left, rfl]]
[Int.neg_le_neg,[]]
[List.eq_or_mem_of_mem_insert,[Iff.mp, List.mem_insert_iff]]
[Equiv.trans.proof_2,[Function.right_inverse.comp, Equiv.rightInv]]
[pow_add,[of_eq_true, Eq.trans, congr, congrArg, Eq, HPow.hPow, HAdd.hAdd, Nat.zero_eq, Nat.add_zero, HMul.hMul, pow_zero, mul_one, eq_self, Eq.mpr, Eq.refl, Nat.succ, Nat.add_succ, pow_succ', Eq.symm, mul_assoc, pow_mul_comm, rfl]]
[List.ball_cons,[Iff.intro, And.intro, List.mem_cons_self, List.mem_cons_of_mem, Or.elim, Eq.symm]]
[Option.pbind,[Option, Option.none, Option.pbind.proof_1]]
[Function.bijective_iff_has_inverse,[Iff.intro, Exists.intro, Function.surj_inv, And.right, And.intro, Function.left_inverse_surj_inv, Function.right_inverse_surj_inv, Function.bijective, Function.left_inverse.injective, Function.right_inverse.surjective]]
[EIO.asTask,[BaseIO.asTask, EIO.toBaseIO]]
[Nat.coprime.gcd_eq_one,[id]]
[Nat.gcd_dvd_left,[And.left, Nat.gcd_dvd]]
[ST.Ref.modify,[liftM, ST.Prim.Ref.modify]]
[Tactic.Ring.HornerExpr.pp,[Lean.Meta.MetaM, Std.Format, Bind.bind, Lean.PrettyPrinter.ppExpr, Lean.Name.anonymous, List.nil, Pure.pure, HAppend.hAppend, Std.Format.text, ToString.toString, PProd.fst, PProd.snd, Prod.fst]]
[forall_prop_of_true,[forall_const]]
[instDecidableLe_1,[UInt8.decLe]]
[Unit.unit,[PUnit.unit]]
[StateT.ext,[funext]]
[List.map,[Unit.unit, List, List.nil, List.cons, PProd.fst]]
[EStateM.Result.ok.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.getLast,[absurd, List.getLast.proof_1, PProd.fst, List.getLast.proof_2]]
[Function.bijective.exists_unique,[Iff.mp, Function.bijective_iff_exists_unique]]
[Equiv.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Equiv.mk, Eq.symm, eq_of_heq, HEq.refl]]
[eq_false,[propext, Iff.intro, absurd, False.elim]]
[List.zipLeft,[List.mapâ‚‚Left, Prod.mk]]
[List.last',[Unit.unit, List.cons, Option, Option.none, Option.some, PProd.fst]]
[StateT.modifyGet,[Pure.pure]]
[Option.isNone_some,[rfl]]
[WellFounded.apply,[WellFounded.apply.proof_1]]
[ForM.forM,[]]
[mul_left_cancel,[IsMulLeftCancel.mul_left_cancel]]
[PSum.inr.injEq,[Eq.propIntro, Eq.refl, PSum.inr, Eq.symm, eq_of_heq, HEq.refl]]
[List.splitOnP,[List.splitOnPAux, id]]
[Int.sub_le_sub,[Int.add_le_add, Int.neg_le_neg]]
[Int.le_add_of_neg_add_le_right,[Int.le_add_of_sub_right_le, Eq.mp, Eq.refl, LE.le, HAdd.hAdd, Neg.neg, Int.add_comm]]
[Nat.one_add,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Nat.add_comm, OfNat.ofNat, Nat.succ, eq_self, HAdd.hAdd]]
[Int.zero_lt_one,[Int.NonNeg.mk, HSub.hSub, Nat.succ]]
[Nat.dvd_trans,[Dvd.dvd, Exists.intro, HMul.hMul]]
[eq_iff_iff,[Iff.symm, iff_iff_eq]]
[andM,[Bind.bind, Unit.unit, ToBool.toBool, Pure.pure]]
[exists_eq,[Exists.intro, rfl]]
[Nat.le_of_add_le_add_right,[Eq.mpr, Eq.refl, LE.le, Nat.add_comm, Nat.le_of_add_le_add_left]]
[Int.instCommRingInt.proof_1,[]]
[Monoid.npow_succ',[]]
[Or.intro_right,[Or.inr]]
[decidableOfDecidableOfIff,[dite, Decidable.isTrue, Iff.mp, Decidable.isFalse, decidableOfDecidableOfIff.proof_1]]
[not_imp,[Decidable.not_imp]]
[UInt16.sub_def,[rfl]]
[Eq.mpr_prop,[Eq.symm]]
[Inter.inter,[]]
[ByteArray.extract,[ByteArray.copySlice, ByteArray.empty, OfNat.ofNat, HSub.hSub, Bool.true]]
[Fin.val,[]]
[Substring.dropRightWhile,[Substring, Substring.mk]]
[List.disjoint_nil_right,[Eq.mpr, Eq.refl, List.disjoint, List.nil, propext, List.disjoint_comm, List.disjoint_nil_left]]
[HAndThen.hAndThen,[]]
[Array.zip,[Array.zipWith, Prod.mk]]
[instLTUInt32,[LT.mk, LT.lt, UInt32.val]]
[Mathlib.Tactic.Ext.tacticSubst_eqs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[mul_inv_cancel_right,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Inv.inv, mul_assoc, mul_right_inv, OfNat.ofNat, mul_one, rfl]]
[Array.getD,[dite, LT.lt, Array.size, Array.get, Fin.mk]]
[Classical.epsilon_singleton,[Classical.epsilon_spec, Exists.intro, rfl]]
[and_true,[propext, Iff.intro, And.left, And.intro, trivial]]
[PSigma.mkSkipLeft,[PSigma.mkSkipLeft.proof_1]]
[Nat.coprime.coprime_dvd_left,[Nat.eq_one_of_dvd_one]]
[Int.eq_of_mul_eq_mul_right,[]]
[instInhabitedPointedType,[Inhabited.mk, PointedType.mk, PUnit, PUnit.unit]]
[List.getD,[Option.getD, List.get?]]
[Decidable.peirce,[dite, Not.elim]]
[npow_eq_pow,[rfl]]
[Array.mapMUnsafe,[unsafeCast, OfNat.ofNat, Array.mapMUnsafe.map]]
[Int.neg_nonneg_of_nonpos,[]]
[Option.isSome_some,[rfl]]
[instMulUSize,[Mul.mk, USize.mul]]
[Nat.add_comm,[Eq, HAdd.hAdd, Eq.symm, Nat.zero_add]]
[List.Perm.refl,[Unit.unit, List.Perm, List.Perm.nil, List.Perm.cons, PProd.fst]]
[Int.ofNat_zero,[rfl]]
[List.decidablePairwise.proof_3,[Iff.mpr, List.Pairwise_cons, And.intro]]
[instMonadLiftBaseIOEIO,[MonadLift.mk, BaseIO.toEIO]]
[ShiftLeft.noConfusionType,[]]
[Substring.atEnd,[Bool, BEq.beq, HAdd.hAdd]]
[Classical.propDecidable,[Classical.choice, Classical.propDecidable.proof_1]]
[LawfulMonad.noConfusionType,[]]
[List.cons_append,[rfl]]
[if_pos,[Eq, ite, rfl, absurd]]
[Decidable.not_and_distrib,[Iff.intro, dite, Or.inr, And.intro, Or.inl, not_and_of_not_or_not]]
[Nat.min_comm,[Decidable.em, LE.le, Eq.mpr, congr, congrArg, Eq, Eq.trans, ite_congr, eq_true, Eq.refl, ite_true, Nat.le_antisymm, Eq.symm, of_eq_true, eq_false, ite_false, eq_self, not_or_intro, Nat.le_or_le]]
[Fin.instSubFin,[Sub.mk, Fin.sub]]
[Subarray.hâ‚,[]]
[Applicative.toPure,[]]
[Nat.dvd_add,[Exists.elim, Exists.intro, HAdd.hAdd, of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.left_distrib, eq_self, HMul.hMul]]
[Fin.mk.inj,[]]
[ofNat_eq_ofNat,[rfl]]
[inv_inv,[inv_eq_of_mul_eq_one, mul_left_inv]]
[Nat.sub_le,[Nat.le_refl, HSub.hSub, OfNat.ofNat, Nat.le_trans, Nat.pred_le]]
[EIO.catchExceptions,[EStateM.Result, Empty, IO.RealWorld, EStateM.Result.ok]]
[String.utf8ByteSize,[Nat, PProd.fst, HAdd.hAdd, String.csize, OfNat.ofNat]]
[UInt64.instSemiringUInt64.proof_4,[congrArg, UInt64.mk, AddMonoid.nsmul_succ', UInt64.val]]
[List.get?_len_le,[Eq.refl, Nat.zero, HEq.refl, Eq, List.get?, Option.none, rfl, PProd.fst, Nat.le_of_succ_le_succ]]
[List.mapIdxM,[OfNat.ofNat, List.mapIdxM.loop]]
[Quotient.recOnSubsingleton,[Quot.recOnSubsingleton]]
[map_eq_pure_bind,[Eq.mpr, Eq.refl, Eq, Functor.map, Bind.bind, Pure.pure, Eq.symm, LawfulMonad.bind_pure_comp, rfl]]
[Function.bijective.comp,[Function.bijective, Function.comp, And.intro, Function.injective.comp, Function.surjective.comp]]
[unexpandListToArray,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, Unit.unit]]
[FloatArray.get,[Float, Array.get]]
[mul_comm,[CommSemigroup.mul_comm]]
[List.length_eq_one,[Iff.intro, Exists, Eq, List.cons, List.nil, Exists.intro, rfl, False.elim, Eq.mp, Eq.trans, congrFun, congrArg, List.length_cons, Nat.succ, OfNat.ofNat, Nat.succ.injEq, HAdd.hAdd, List.length, eq_false, Nat.succ_ne_zero, Eq.mpr, Eq.refl, of_eq_true, List.length_singleton, eq_true_of_decide, Bool.true]]
[generalizeLeft,[invImage, PSigma.snd]]
[UInt64.shiftRight,[UInt64.mk, HShiftRight.hShiftRight, UInt64.val, UInt64.modn, OfNat.ofNat]]
[List.mem,[Unit.unit, False, Or, Eq, PProd.fst]]
[instReprUnit,[Repr.mk, Std.Format.text]]
[Mathlib.ExtendedBinder.extBinderParenthesized,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Mathlib.ExtendedBinder.extBinder]]
[CoeTC.coe,[]]
[OptionT.lift,[OptionT.mk, Bind.bind, Pure.pure, Option.some]]
[Semiring.mul_zero,[]]
[Option.not_mem_none,[]]
[UInt16.instSemiringUInt16.proof_2,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt16.zero_def, UInt16.add_def, UInt16.mk, OfNat.ofNat, zero_add, UInt16.val, UInt16.mk_val_eq, eq_self, propext, forall_const, UInt16]]
[iff_true_left,[Iff.intro, Iff.mp, iff_of_true]]
[forall_congr,[]]
[UInt16.toNat,[Fin.val, UInt16.val]]
[Inter.noConfusionType,[]]
[instInhabitedUSize.proof_1,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, OfNat.ofNat, HEq.refl, LT.lt, USize.size, usize_size_eq, of_decide_eq_true, Bool.true]]
[Nat.sub_eq_sub_min,[dite, GE.ge, Eq.mpr, Eq.refl, Eq, HSub.hSub, min, min_eq_right, rfl, Nat.sub_eq_zero_of_le, le_of_not_ge, OfNat.ofNat, min_eq_left, Nat.sub_self]]
[neq_of_not_iff,[mt, Eq.to_iff]]
[Monoid.HPow,[HPow.mk, Monoid.npow]]
[Int.add_left_neg,[Unit.unit, Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat, rfl, of_eq_true, Eq.trans, congrFun, congrArg, Int.neg_ofNat_of_succ, Int.ofNat, Nat.succ, Int.negSucc_ofNat_add_ofNat, Int.sub_nat_self, eq_true_of_decide, Eq.refl, Bool.true, Int.neg_neg_ofNat_succ, Int.negSucc, Int.ofNat_add_negSucc_ofNat]]
[List.insert,[ite, Mem.mem, List.cons]]
[String.revPosOf,[ite, Eq, BEq.beq, String.bsize, OfNat.ofNat, Bool.true, Option.none, String.revPosOfAux, String.prev]]
[Nat.gcd_dvd,[Nat.gcd.induction, And.intro, Exists.intro, OfNat.ofNat, of_eq_true, Eq.trans, congrArg, Eq, congrFun, HMul.hMul, Nat.gcd_zero_left, Nat.mul_zero, eq_true_of_decide, Eq.refl, Bool.true, Nat.mul_one, eq_self, Eq.mpr, Dvd.dvd, Nat.gcd, Nat.gcd_rec, Iff.mp, Nat.dvd_mod_iff, Eq.mp, HMod.hMod, Eq.symm]]
[Float.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[HAppend.hAppend,[]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.mk.inj,[And.intro]]
[List.append_subset_iff,[Iff.intro, Eq.mpr, congr, congrArg, And, propext, List.subset_def, And.intro, Eq.mp, List.mem_append_left, List.mem_append_right, Subset.subset, HAppend.hAppend, List.append_subset_of_subset_of_subset]]
[Int.sub_lt_sub_of_le_of_lt,[Int.add_lt_add_of_le_of_lt, Int.neg_lt_neg]]
[trans_rel_right,[Eq.symm]]
[Int.pow,[Unit.unit, Int, OfNat.ofNat, HMul.hMul, PProd.fst]]
[max_comm,[eq_max, le_max_right, le_max_left, max_le]]
[List.dropWhile,[Unit.unit, List, List.nil, PProd.fst, List.cons]]
[instMulNat,[Mul.mk, Nat.mul]]
[Int.le_of_sub_nonpos,[]]
[Fin.modn_def,[Eq, HMod.hMod, Fin.mk, Fin.val, Nat.mod_lt, Fin.size_positive, rfl]]
[List.pure,[List.cons, List.nil]]
[instDecidableIte,[Decidable, ite]]
[List.last_singleton,[rfl]]
[Int.le,[Int.NonNeg, HSub.hSub]]
[Applicative.toSeq,[]]
[Nat.gcd_self,[of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.gcd, Nat.zero_eq, Nat.gcd_zero_right, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true, Eq.symm, congrFun, Nat.gcd_succ, Nat.succ, Nat.mod_self, Nat.gcd_zero_left, eq_self]]
[decidableBAll.proof_1,[Not]]
[le_refl,[Preorder.le_refl]]
[UInt8.size_positive,[of_decide_eq_true, Eq.refl, Bool.true]]
[Int.neg_lt_neg,[]]
[Char.toLower,[ite, And, GE.ge, OfNat.ofNat, LE.le, Char.ofNat, HAdd.hAdd]]
[lt_iff_not_ge,[Iff.intro, not_le_of_gt, lt_of_not_ge]]
[UInt8.land,[UInt8.mk, Fin.land, UInt8.val]]
[FloatArray.foldlMUnsafe.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bind.bind, FloatArray.uget, lcProof, FloatArray.foldlMUnsafe.fold, HAdd.hAdd, OfNat.ofNat]]
[BinaryHeap.decreaseKey,[BinaryHeap.mk, Subtype.val, BinaryHeap.heapifyDown, Array.set, BinaryHeap.arr, Fin.mk, Fin.val, BinaryHeap.decreaseKey.proof_1]]
[exists_false,[False]]
[ofNat_one,[rfl]]
[BinaryHeap.arr,[]]
[instInhabitedNonScalar,[Inhabited.mk, NonScalar.mk, arbitrary]]
[ExceptCpsT.instMonadExceptOfExceptCpsT,[MonadExceptOf.mk]]
[pow_succ,[Eq.mpr, Eq.refl, Eq, HPow.hPow, Nat.succ, HMul.hMul, pow_succ', pow_mul_comm, rfl]]
[Prod.swap_right_inverse,[Prod.swap_swap]]
[List.getLast.proof_1,[rfl]]
[Sum.inr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instToStringChar,[ToString.mk, Char.toString]]
[EStateM.orElse,[EStateM.Result.ok, EStateM.Result, Unit.unit, EStateM.Backtrackable.restore]]
[StateRefT'.instMonadExceptOfStateRefT',[MonadExceptOf.mk, Function.comp, StateRefT'.lift, throwThe, tryCatchThe]]
[Char.quoteCore,[ite, Eq, Char.ofNat, Or, LE.le, Char.toNat, OfNat.ofNat, HAppend.hAppend, charToHex, String.singleton]]
[UInt32.mul_def,[rfl]]
[Array.findIdx?.loop.proof_2,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, OfNat.ofNat, Array.size, Eq.symm, Nat.add_comm, Nat.add_assoc, rfl]]
[Int.add_lt_of_lt_sub_left,[]]
[Int.instCommRingInt,[CommRing.mk, Int.mul_comm]]
[EIO.toIO,[EStateM.adaptExcept]]
[ReaderT.run_monadLift,[rfl]]
[List.card_cons_of_mem,[Eq.mpr, Eq.refl, Eq, ite, Mem.mem, HAdd.hAdd, OfNat.ofNat, List.card, if_pos, rfl]]
[Classical.propDecidable.proof_1,[Nonempty, Decidable, Classical.em, Nonempty.intro, Decidable.isTrue, Decidable.isFalse]]
[min_comm,[eq_min, min_le_right, min_le_left, le_min]]
[Int.sub_lt_sub_right,[Int.add_lt_add_right, Neg.neg]]
[List.getLast!,[Unit.unit, panicWithPosWithDecl, OfNat.ofNat, List.getLast, List.cons, List.getLast!.proof_1]]
[Â«term_âŠ•'_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[List.append_ne_nil_of_ne_nil_left,[of_eq_true, Eq.trans, implies_congr_ctx, ne_eq, List.nil, HAppend.hAppend, congrArg, Not, propext, List.append_eq_nil, congrFun, And, eq_false, Eq, false_and, eq_true_of_decide, Eq.refl, Bool.true, implies_true]]
[Int.lt,[LE.le, HAdd.hAdd, OfNat.ofNat]]
[instIsAddLeftCancel.proof_1,[Eq.mpr, Eq.refl, Eq, Eq.symm, neg_add_cancel_left, HAdd.hAdd, Neg.neg, rfl]]
[Function.partial_inv_left,[Function.is_partial_inv_left, Function.partial_inv_of_injective]]
[eq_true,[propext, Iff.intro, trivial]]
[List.append_left_injective,[List.append_right_cancel]]
[Fin.ofNat',[Fin.mk, HMod.hMod, Nat.mod_lt]]
[Option.getD_of_ne_none,[absurd, Eq.refl, Option.none, Eq.symm, Eq.mpr, Eq, Option.some, Option.getD, Option.getD_some, rfl]]
[Option.mmap,[Option.maybe, Option.map]]
[mul_right_cancel,[IsMulRightCancel.mul_right_cancel]]
[System.Platform.isWindows,[System.Platform.getIsWindows, Unit.unit]]
[List.enum,[List.enumFrom, OfNat.ofNat]]
[Â«prio(_)Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[Tactic.Ring.HornerExpr.const.inj,[And.intro]]
[Nat.instCommSemiringNat,[CommSemiring.mk, Nat.mul_comm]]
[Nat.succ_mul_succ_eq,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Nat.succ, HAdd.hAdd, OfNat.ofNat, Nat.mul_succ, Nat.succ_mul, Nat.add_right_comm, rfl]]
[and_iff_right,[Iff.intro, And.right, And.intro]]
[dite_not,[Decidable.em, of_eq_true, Eq.trans, congr, congrArg, Eq, dite_congr, Not, eq_true, eq_false_of_decide, Eq.refl, Bool.false, Eq.mpr_prop, Eq.mpr_not, dite_false, not_not_intro, dite_true, eq_self, not_false, Eq.symm, eq_false, eq_true_of_decide, Bool.true, True.intro]]
[Â«term_â†”_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.gcd_add_mul_self,[of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.gcd_rec, HAdd.hAdd, HMul.hMul, congrFun, Nat.gcd, Nat.add_mul_mod_self_right, eq_self, HMod.hMod]]
[Prod.exists,[Iff.intro, Exists, Prod.mk, Exists.intro]]
[instHPow,[HPow.mk, Pow.pow]]
[add_right_cancel_iff,[Iff.intro, add_right_cancel, rfl]]
[MonadLift.monadLift,[]]
[StdGen.s2,[]]
[Mathlib.Prelude.Rename.lookup3,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[StdGen.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, StdGen.mk, Eq.symm, eq_of_heq, HEq.refl]]
[heq_of_eqRec_eq,[heq_of_eq]]
[Tactic.Ring.Cache.Î±,[]]
[MProd.snd,[]]
[UInt16.instSemiringUInt16.proof_5,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, congrFun, HMul.hMul, UInt16.zero_def, UInt16.mul_def, UInt16.mk, OfNat.ofNat, MonoidWithZero.zero_mul, UInt16.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt16]]
[and_congr,[Iff.intro, And.imp, Iff.mp, Iff.mpr]]
[Nat.add_sub_add_right,[Eq, HSub.hSub, HAdd.hAdd, Eq.mpr, Eq.refl, OfNat.ofNat, Nat.add_zero, rfl, Nat.add_succ, Nat.succ, Nat.succ_sub_succ, PProd.fst]]
[or_and_distrib_left,[Iff.intro, And.intro, Or.inl, And.imp, Or.inr, Function.comp, imp_intro, Or.imp_right]]
[Decidable.iff_iff_not_or_and_or_not,[Eq.mpr, Eq.refl, Iff, And, Or, Not, propext, iff_iff_implies_and_implies, congr, congrArg, Eq.trans, Decidable.imp_iff_not_or, or_comm, congrFun, Iff.rfl]]
[Array.ext.extAux,[rfl, Eq.symm, Eq.mp, Eq.refl, Eq, List.length, List.nil, List.cons, List.length_cons]]
[System.FilePath.extension,[Option.bind, System.FilePath.fileName, Unit.unit, dite, Eq, Eq.symm, Option, String, String.revPosOf, Char.ofNat, Option.none, Option.some, String.extract, HAdd.hAdd, OfNat.ofNat, String.bsize]]
[instHashableUInt8,[Hashable.mk, UInt8.toUInt64]]
[instComplementUInt32,[Complement.mk, UInt32.complement]]
[List.card_map_eq_of_inj_on,[of_eq_true, Eq.trans, implies_congr, Eq.refl, List.inj_on, List.nil, congr, congrArg, Eq, List.card_nil, eq_true_of_decide, Bool.true, implies_true, Decidable.em, Mem.mem, List.map, List.exists_of_mem_map, Eq.symm]]
[System.FilePath.withExtension,[Unit.unit, System.FilePath, System.FilePath.fileStem, System.FilePath.withFileName, ite, Eq, String.isEmpty, Bool.true, HAppend.hAppend]]
[instHShiftLeft,[HShiftLeft.mk, ShiftLeft.shiftLeft]]
[Function.comp_right,[]]
[List.mem_append_right,[Iff.mpr, List.mem_append, Or.inr]]
[USize.ofNat32,[USize.mk, Fin.mk, USize.ofNat32.proof_1]]
[Option.mapM,[Option.none, Option, Bind.bind, Pure.pure, Option.some]]
[Array.get?_set,[Classical.em, Eq, Fin.val, Eq.mpr, congrArg, Array.get?, Array.set, if_pos, of_eq_true, Eq.trans, congrFun, Array.get?_set_eq, Option.some, eq_self, if_neg, Array.get?_set_ne, ne_eq, Not, eq_false, eq_true_of_decide, Eq.refl, Bool.true]]
[List.countp,[Unit.unit, Nat, OfNat.ofNat, ite, HAdd.hAdd, PProd.fst]]
[DoResultPR.noConfusionType,[]]
[BinaryHeap.size_popMax,[Subtype.property, BinaryHeap.popMaxAux]]
[Tactic.Ring.horner_mul_horner,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Tactic.Ring.horner, Eq.symm, HAdd.hAdd, OfNat.ofNat, of_eq_true, Eq.trans, congr, congrArg, congrFun, mul_comm, HPow.hPow, mul_add, mul_left_comm, add_mul, mul_assoc, add_zero, eq_self]]
[Int.instCommRingInt.proof_2,[rfl]]
[List.subset,[Mem.mem]]
[Or.by_cases',[dite, Or.resolve_right]]
[Prod.mk.inj,[And.intro]]
[Xor.noConfusionType,[]]
[tacticBy_cases_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[UInt8.instSemiringUInt8.proof_2,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt8.zero_def, UInt8.add_def, UInt8.mk, OfNat.ofNat, zero_add, UInt8.val, UInt8.mk_val_eq, eq_self, propext, forall_const, UInt8]]
[InvImage.wf,[InvImage.wf.proof_1]]
[Function.injective.eq_iff',[Function.injective.eq_iff]]
[Nat.succ_le_of_lt,[]]
[instToStringUInt32,[ToString.mk, ToString.toString, UInt32.toNat]]
[Decidable.not_and_iff_or_not,[Iff.intro, Decidable.isFalse, Decidable.isTrue, Or, Not, absurd, And.intro, Or.inr, Or.inl, False]]
[ByteSlice.arr,[]]
[Prod.map_snd,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Prod.snd, prod_map, eq_self]]
[List.length_drop,[Eq, List.length, List.drop, HSub.hSub, rfl, Eq.symm, Nat.zero_sub, Nat.succ, Trans.trans, PProd.fst, Nat.succ_sub_succ_eq_sub]]
[Nat.mod_mod,[Or.elim, Nat.eq_zero_or_pos, of_eq_true, Eq.trans, congr, congrArg, Eq, HMod.hMod, Nat.mod_zero, eq_self, Nat.mod_eq_of_lt, Nat.mod_lt]]
[Int.sign_eq_neg_one_of_neg,[Eq.symm, eq_of_heq, Eq.refl, Int.negSucc, HEq.refl, Eq, Int.sign, Neg.neg, OfNat.ofNat, Int.eq_neg_succ_of_lt_zero, rfl]]
[ExceptT.pure,[ExceptT.mk, Pure.pure, Except.ok]]
[String.Iterator.forward,[String.Iterator, PProd.fst, String.Iterator.next]]
[ExistsUnique,[Exists, And, Eq]]
[Subtype.noConfusionType,[]]
[heq_self_iff_true,[iff_true_intro, HEq.rfl]]
[Subarray.toArray,[Array.ofSubarray]]
[not_and_distrib,[Decidable.not_and_distrib]]
[Int.subNatNat_add_left,[]]
[withPtrEqDecEq,[Decidable, Eq, Eq.refl, Decidable.isTrue, withPtrEqDecEq.proof_2, Decidable.isFalse, withPtrEqDecEq.proof_3]]
[UInt16.lt,[LT.lt, UInt16.val]]
[Array.get?,[dite, LT.lt, Array.size, Option.some, Array.get, Fin.mk, Option.none]]
[instStreamList,[Stream.mk, Unit.unit, Option, Prod, List, Option.none, Option.some, Prod.mk]]
[ST.instInhabitedRef.proof_1,[Nonempty.intro, arbitrary]]
[DivInvMonoid.gpow_neg',[]]
[List.forM_nil,[rfl]]
[not_of_not_imp,[mt, imp_intro]]
[iff_not_self,[Iff.mpr]]
[self_eq_add_right,[Eq.mpr, Eq.refl, Iff, Eq, HAdd.hAdd, OfNat.ofNat, Eq.symm, propext, add_left_cancel_iff, add_zero, eq_comm, Iff.rfl]]
[List.indexOf,[List.findIdx, Eq, BEq.beq, Bool.true]]
[Â«term_\/_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Int.ofNat_sub,[]]
[ExceptT.map,[ExceptT.mk, Bind.bind, Except, Pure.pure, Except.ok, Except.error]]
[instToFormat,[Std.ToFormat.mk, Function.comp, Std.Format.text, ToString.toString]]
[PSigma.snd,[]]
[of_not_not,[by_contra]]
[MonadExcept.orElse,[MonadExcept.tryCatch, Unit.unit]]
[BinaryHeap.extractMax,[Prod.mk, BinaryHeap.max, BinaryHeap.popMax]]
[decidableLt_of_decidableLe,[Decidable, LT.lt, dite, LE.le, Decidable.isFalse, decidableLt_of_decidableLe.proof_1, Decidable.isTrue, lt_of_le_not_le, decidableLt_of_decidableLe.proof_2]]
[String.Iterator.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, String.Iterator.mk, Eq.symm, eq_of_heq, HEq.refl]]
[tacticFunext__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[HAdd.hAdd,[]]
[Equiv.refl.proof_2,[rfl]]
[StateCpsT.run',[StateCpsT.runK, Pure.pure]]
[Int.mul_lt_mul',[Trans.trans, Int.mul_le_mul_of_nonneg_right, Int.mul_lt_mul_of_pos_left]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.rhs,[]]
[type_eq_of_heq,[type_eq_of_heq.proof_1]]
[commandGenIntDeclars__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[List.head?,[Unit.unit, Option, Option.none, Option.some]]
[Mathlib.Tactic.Lint.Â«command#lintMathlibAll+-*Only__Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[instOfNat,[OfNat.mk, Zero.zero]]
[Set.sUnion,[setOf, Exists, And, Mem.mem]]
[List.map_subset,[Eq.mpr, Eq.trans, implies_congr, propext, List.mem_map, exists_imp_distrib, forall_congr, and_imp, Exists.intro, And.intro]]
[panicWithPosWithDecl,[panic, HAppend.hAppend, ToString.toString]]
[String.decapitalize,[String.set, OfNat.ofNat, Char.toLower, String.get]]
[Nat.add_mul,[Nat.right_distrib]]
[Bool.false_or,[rfl, Eq.symm, Eq.refl]]
[Quotient.sound,[Quotient.sound.proof_1]]
[Â«term_<->_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[ByteSliceT.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[termS!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[unexpandSorryAx,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[iff_not_comm,[Decidable.iff_not_comm]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Mathlib.Tactic.Lint.SimpLemmaInfo.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.one_mul,[Nat.mul_one, Nat.mul_comm, OfNat.ofNat]]
[Option.map_eq_none,[Option.map_eq_none']]
[List.foldl,[PProd.fst]]
[Iff.elim_left.proof_1,[Iff.mp]]
[System.FilePath.withFileName,[Unit.unit, System.FilePath, System.FilePath.parent, System.FilePath.mk, HDiv.hDiv]]
[Nonempty.elim,[Nonempty.elim.proof_1]]
[Set.Â«term{_}Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.ParserDescr.cat, Bool.false]]
[not_imp_comm,[Decidable.not_imp_comm]]
[EStateM.Backtrackable.save,[]]
[xor,[Or, And, Not]]
[Nat.gcd,[WellFounded.fix, Nat.gcd.proof_1, Unit.unit, Nat, HMod.hMod, Nat.succ, Nat.mod_lt, Nat.zero_lt_succ]]
[precMin,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat.lt_trans]]
[Int.le.intro,[Int.le.intro_sub, Eq.mpr, Eq.refl, Eq, HSub.hSub, Int.ofNat, Eq.symm, HAdd.hAdd, Int.add_comm, of_eq_true, Eq.trans, congrFun, congrArg, Int.sub_eq_add_neg, Int.add_assoc, Neg.neg, Int.add_right_neg, Int.add_zero, eq_self]]
[mt,[]]
[Nat.div.inductionOn,[WellFounded.fix, WellFoundedRelation.wf, measure, id, dite, And, LT.lt, OfNat.ofNat, LE.le, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le]]
[Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat.lt_of_le_of_lt]]
[Fin.instModFin,[Mod.mk, Fin.mod]]
[UInt32.instNumericUInt32,[Numeric.mk, UInt32.mk, Numeric.ofNat]]
[Array.mapM,[Array.foldlM, Bind.bind, Pure.pure, Array.push, Array.mkEmpty, Array.size, OfNat.ofNat]]
[Mathlib.Tactic.Lint.getLinter,[arbitrary]]
[Int.natAbs,[Nat, Nat.succ]]
[List.traverse,[Unit.unit, List, Pure.pure, List.nil, Seq.seq, Functor.map, List.cons, PProd.fst]]
[Prod.lt_def,[rfl]]
[Int.ofNat_mul_subNatNat,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HMul.hMul, Int.ofNat, Nat.zero_eq, Int.ofNat_zero, Int.subNatNat, Int.zero_mul, Nat.zero_mul, Int.sub_nat_self, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true, Eq.symm]]
[Iff.elim.proof_1,[Iff.mp, Iff.mpr]]
[or_imp_distrib,[Iff.intro, And.intro, Or.inl, Or.inr]]
[BinaryHeap.size_heapifyDown,[Subtype.property, BinaryHeap.heapifyDown]]
[Nat.sub_induction,[PProd.fst]]
[Sum.inr.inj,[]]
[List.forIn_cons,[rfl]]
[Bool.true_and,[rfl, Eq.symm, Eq.refl]]
[Quotient.exact,[Quot.inductionOn, Setoid.refl]]
[not_not_of_not_imp,[mt, Not.elim]]
[Subtype.val,[]]
[Fin.xor.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[ExceptCpsT.runCatch_bind_throw,[rfl]]
[instZero,[Zero.mk, OfNat.ofNat]]
[not_exists,[exists_imp_distrib]]
[ite,[]]
[decidable_of_bool,[Decidable, Decidable.isTrue, decidable_of_bool.proof_1, Decidable.isFalse, decidable_of_bool.proof_2]]
[List.cons_ne_nil,[Eq.refl, List.nil, HEq.refl]]
[Â«term_âŠ•_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Int.neg_neg_of_pos,[]]
[Array.Â«term__[_:_]Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Alternative.orElse,[]]
[apply_dite,[Decidable.em, of_eq_true, Eq.trans, congr, congrArg, Eq, dite_congr, eq_true, Eq.refl, Eq.mpr_prop, Eq.mpr_not, dite_true, eq_self, True.intro, Eq.symm, eq_false, dite_false, not_false]]
[Int.le_neg_add_of_add_le,[]]
[AndThen.noConfusionType,[]]
[Substring.any,[Bool, String.anyAux]]
[Tactic.Ring.horner_add_horner_gt,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Tactic.Ring.horner, Eq.symm, OfNat.ofNat, of_eq_true, Eq.trans, congr, congrArg, add_comm, HMul.hMul, HPow.hPow, add_assoc, congrFun, add_zero, add_mul, mul_assoc, pow_add, eq_self]]
[Set.instUnionSet,[Union.mk, Set.union]]
[ByteArray.toSliceT,[ByteSliceT.mk, OfNat.ofNat]]
[instReprAtomInt,[ReprAtom.mk]]
[instHModUInt16NatUInt16,[HMod.mk, UInt16.modn]]
[ByteArray.get!,[UInt8, Array.get!]]
[RandomGen.split,[]]
[List.Â«term_<+_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[SeqRight.seqRight,[]]
[instInhabitedArrow,[Inhabited.mk, arbitrary]]
[non_contradictory_em,[]]
[List.getLast.proof_2,[]]
[Function.bijective_id,[And.intro, Function.injective_id, Function.surjective_id]]
[Equiv.coe_fn_mk,[rfl]]
[Nat.find_spec,[And.left, Subtype.property, Nat.find_x]]
[Nat.add_lt_add,[Nat.lt_trans, Nat.add_lt_add_right, Nat.add_lt_add_left]]
[Eq.substr,[Eq.symm]]
[Array.findSome!,[Unit.unit, Array.findSome?, panicWithPosWithDecl, OfNat.ofNat]]
[instAppendSubarray,[Append.mk, Array.toSubarray, OfNat.ofNat, Array.size]]
[CommGroup.toGroup,[]]
[List.decidablePairwise.proof_1,[Eq.refl]]
[add_mul,[Semiring.add_mul]]
[Â«term_>>_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instReprTupleProd,[ReprTuple.mk, List, Std.Format, ReprTuple.reprTuple, List.cons, repr]]
[Int.add_comm,[Eq, HAdd.hAdd, of_eq_true, Eq.trans, congr, congrArg, Int.ofNat_add_ofNat, Int.ofNat, Nat.add_comm, eq_self, rfl, Int.negSucc_ofNat_add_negSucc_ofNat, Int.negSucc, Nat.succ]]
[List.pwFilter,[Unit.unit, List, List.nil, ite, List.cons]]
[USize.sub,[USize.mk, HSub.hSub, USize.val]]
[ToStream.noConfusionType,[]]
[UInt16.instSemiringUInt16.proof_8,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt16.one_def, UInt16.mul_def, UInt16.mk, OfNat.ofNat, mul_one, UInt16.val, UInt16.mk_val_eq, eq_self, propext, forall_const, UInt16]]
[Function.surjective_to_subsingleton,[Exists, Eq, Exists.intro, Subsingleton.elim]]
[instAddUInt16,[Add.mk, UInt16.add]]
[Nat.succ_ne_self,[False, absurd, Nat.succ_ne_zero, OfNat.ofNat, PProd.fst, id]]
[StateT.failure,[Alternative.failure]]
[Nat.gcd_gcd_self_left_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, Nat.gcd_comm, Nat.gcd_gcd_self_right_right, rfl]]
[Subsingleton.helim,[Subsingleton.helim.proof_1]]
[Nat.le_succ_of_le,[Nat.le_trans, Nat.le_succ]]
[Array.contains,[Array.any, BEq.beq, OfNat.ofNat, Array.size]]
[Classical.inhabited_of_nonempty,[Inhabited.mk, Classical.choice]]
[List.length_cons,[rfl]]
[Or.swap,[Or.inr, Or.inl]]
[BinaryHeap.insertExtractMax.proof_2,[Eq.mpr, congrArg, LT.lt, OfNat.ofNat, Array.size_set, BinaryHeap.arr, Fin.mk, BinaryHeap.size_pos_of_max]]
[Nat.sub_zero,[rfl]]
[Function.left_inverse.right_inverse,[]]
[Nat.gcd_mul_gcd_of_coprime_of_mul_eq_mul,[Nat.dvd_antisymm, Nat.coprime.dvd_of_dvd_mul_right, Nat.coprime.mul, Nat.coprime.gcd_left, Eq.mpr, Eq.refl, Dvd.dvd, HMul.hMul, Nat.gcd, Eq.symm, Nat.mul_dvd_mul, And.left, Nat.gcd_dvd, Nat.gcd_comm]]
[List.redLength,[Unit.unit, Nat, OfNat.ofNat, Nat.succ, PProd.fst]]
[Quotient.liftOn,[Quot.liftOn]]
[xor_false,[funext, of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, Or, false_and, Not, And, eq_true_of_decide, Eq.refl, Bool.true, and_true, false_or, id_eq, eq_self, implies_true]]
[instCoeTail_1,[CoeTail.mk, coeSort]]
[NonScalar.val,[]]
[ExceptCpsT.instLawfulMonadExceptCpsT,[ExceptCpsT.instLawfulMonadExceptCpsT.proof_1]]
[Tactic.NormCast.addElim,[Lean.Meta.addSimpLemma, Tactic.NormCast.NormCastExtension.up, Tactic.NormCast.normCastExt, Bool.false]]
[instBEq,[BEq.mk, Decidable.decide, Eq]]
[MonadControl.liftWith,[]]
[UInt16.size,[OfNat.ofNat]]
[Nat.anyAux,[Unit.unit, Bool, Bool.false, or, HSub.hSub, Nat.succ, PProd.fst]]
[Subset.subset,[]]
[OptionT.tryCatch,[OptionT.mk, Bind.bind, Option.none, Option, Pure.pure, Option.some, Unit.unit]]
[List.hasDecidableLt.proof_1,[Eq.refl, List.nil, HEq.refl, False]]
[List.decidablePairwise.proof_4,[Eq.symm, eq_of_heq, Eq.refl, List.cons, HEq.refl, False]]
[or_assoc,[Or.assoc]]
[Int.sub_right_le_of_le_add,[]]
[Nat.add_sub_assoc,[Eq, HSub.hSub, HAdd.hAdd, Eq.mpr, Eq.refl, Eq.symm, Nat.add_sub_cancel_left, Nat.add_comm, Nat.add_assoc, Nat.add_sub_cancel, rfl]]
[Â«term_âˆ˜_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.mod,[WellFounded.fix, Nat.mod.proof_1, dite, And, LT.lt, OfNat.ofNat, LE.le, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le]]
[List.append_eq_nil,[of_eq_true, Eq.trans, congr, congrArg, Iff, congrFun, Eq, List.nil_append, List.nil, And, eq_self, true_and, iff_self, Eq.symm, List.cons_append, eq_false', false_and, eq_true_of_decide, Eq.refl, Bool.true]]
[UInt8.instCommRingUInt8,[CommRing.mk, UInt8.instCommRingUInt8.proof_1]]
[Prod.swap_swap,[Eq, Prod.swap, rfl]]
[Quotient.ind,[Quot.ind]]
[Char.toNat,[UInt32.toNat, Char.val]]
[StateRefT'.instAlternativeStateRefT',[inferInstanceAs, Alternative, ReaderT, ST.Ref]]
[List.mem_of_mem_erasep,[List.erasep_subset]]
[let_congr,[]]
[List.forA,[Unit.unit, PUnit, Pure.pure, PUnit.unit, SeqRight.seqRight, PProd.fst]]
[Nat.dvd_iff_mod_eq_zero,[Iff.intro, Nat.mod_eq_zero_of_dvd, Nat.dvd_of_mod_eq_zero]]
[Int.ofNat_mul_negSucc_ofNat,[rfl]]
[Int.le_of_add_le_add_left,[]]
[instOfNatUInt32,[OfNat.mk, UInt32.ofNat]]
[Nat.instXorNat,[Xor.mk, Nat.xor]]
[List.erasep_cons,[rfl]]
[add_left_comm,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Eq.symm, add_assoc, add_comm, rfl]]
[unexpandEqNDRec,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[Nat.coprime_one_right,[Nat.gcd_one_right]]
[Function.left_inverse_of_surjective_of_right_inverse,[Eq, Eq.mpr, Eq.refl, Eq.symm, rfl]]
[Fin.zero_def,[]]
[USize.modn_lt,[LT.lt, USize.toNat, HMod.hMod, Fin.modn_lt]]
[Â«term_\_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instStreamSubstringChar,[Stream.mk, ite, LT.lt, Substring.startPos, Substring.stopPos, Option.some, Prod.mk, String.get, Substring.str, Substring.mk, String.next, Option.none]]
[Â«stx_,+Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Int.eq_one_of_mul_eq_self_right,[Int.eq_of_mul_eq_mul_left, Eq.mpr, Eq.refl, Eq, HMul.hMul, OfNat.ofNat, Int.mul_one, rfl]]
[id,[]]
[EStateM.instMonadEStateM,[Monad.mk]]
[instModUInt64,[Mod.mk, UInt64.mod]]
[Nat.coprime.coprime_mul_left,[Nat.coprime.coprime_dvd_left, Nat.dvd_mul_left]]
[Nat.div_zero,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, OfNat.ofNat, Nat.div_eq, of_eq_true, Eq.trans, congrFun, congrArg, ite_congr, And, eq_false_of_decide, Bool.false, LE.le, false_and, HAdd.hAdd, Nat.sub_zero, ite_false, eq_true_of_decide, Bool.true]]
[Option.map_injective,[Eq.refl, Option.map, Option.some, HEq.refl, Option.none, Eq, rfl, Eq.mpr, Option.some.inj]]
[Option.isNone,[Unit.unit, Bool, Bool.false, Bool.true]]
[Fin.addOverflows?,[Decidable.decide, LE.le, HAdd.hAdd, Fin.val]]
[StateT.instMonadExceptOfStateT,[MonadExceptOf.mk, Function.comp, StateT.lift, throwThe, tryCatchThe]]
[instToFormatProd,[Std.ToFormat.mk, Std.Format, Std.Format.paren, HAppend.hAppend, Std.ToFormat.format, Std.Format.text, Std.Format.line]]
[coeSortToCoeTail,[CoeTail.mk, CoeSort.coe]]
[compareOfLessAndEq,[ite, LT.lt, Ordering.lt, Eq, Ordering.eq, Ordering.gt]]
[instInhabitedExcept,[Inhabited.mk, Except.error, arbitrary]]
[CoeHead.noConfusionType,[]]
[EStateM.Result.ok.inj,[And.intro]]
[And.rotate,[Eq.mpr, congrArg, Iff, And, Eq.trans, propext, and_comm, And.left_comm, Iff.rfl]]
[instInhabitedFloat,[Inhabited.mk, Float.mk, FloatSpec.val, floatSpec]]
[Int.add_pos,[Int.add_lt_add, Int.zero_add, OfNat.ofNat]]
[Array.foldlM.proof_1,[Nat.le_refl, Array.size]]
[String.dropRight,[Substring.toString, Substring.dropRight, String.toSubstring]]
[CommSemiring.mul_comm,[]]
[String.Pos,[Nat]]
[Stream.noConfusionType,[]]
[OrElse.orElse,[]]
[List.filter,[List.filterAux, List.nil]]
[instSemiringFin.proof_7,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.mul_def, Fin.mk, HMod.hMod, OfNat.ofNat, Nat.mod_lt, Fin.size_positive, congrFun, HMul.hMul, Nat.zero_mod, MonoidWithZero.zero_mul, Fin.zero_def, eq_true_of_decide, Eq.refl, Bool.true]]
[Int.eq_natAbs_of_zero_le,[Eq.mpr, Eq.refl, rfl]]
[Array.findIdx?.loop,[dite, LT.lt, Array.size, Option, Nat, False.elim, Array.findIdx?.loop.proof_1, ite, Eq, Array.get, Fin.mk, Bool.true, Option.some, Option.none]]
[Decidable.by_cases,[Decidable.byCases]]
[Option.guard_eq_some,[Decidable.em, of_eq_true, Eq.trans, congr, congrArg, Iff, congrFun, Eq, ite_congr, eq_true, Eq.refl, Option.some, Option.none, ite_true, Option.some.injEq, And, and_true, iff_self, Eq.symm, eq_false, ite_false, eq_false', and_false, eq_true_of_decide, Bool.true]]
[iff_true,[propext, Iff.intro, Iff.mpr, trivial]]
[dif_neg,[Eq, dite, absurd, rfl]]
[Mod.mod,[]]
[List.modify_get?_length,[List.modifyNthTail_length, List.modifyHead, rfl, Eq.symm, Eq.refl]]
[ForIn.noConfusionType,[]]
[Int.lt_add_of_pos_right,[]]
[Nat.prod_dvd_and_dvd_of_dvd_prod.proof_1,[Eq.symm]]
[FloatArray.foldlM.proof_1,[Nat.le_refl, FloatArray.size]]
[Array.eraseIdx',[Array.eraseIdxSzAux, HAdd.hAdd, Fin.val, OfNat.ofNat, Array.eraseIdx'.proof_1]]
[List.decidablePairwise,[Decidable, List.Pairwise, List.decidablePairwise.proof_1, Decidable.isTrue, List.Pairwise.nil, List.cons, PProd.fst, decidableBAll, Decidable.isFalse, List.decidablePairwise.proof_2, List.decidablePairwise.proof_3, List.decidablePairwise.proof_4]]
[exists_unique_congr,[exists_congr, and_congr, forall_congr', imp_congr_left]]
[List.hasDecidableLt.proof_4,[Eq.symm, eq_of_heq, Eq.refl, List.cons, HEq.refl, False, absurd]]
[List.format,[Unit.unit, List.cons, Std.Format, Std.Format.text, Std.Format.sbracket, Std.Format.joinSep, HAppend.hAppend, Std.Format.line]]
[Int.lt_add_of_neg_add_lt,[]]
[Option.ball_ne_none,[Iff.intro, Option.some, Option.some_ne_none]]
[String.dropRightWhile,[Substring.toString, Substring.dropRightWhile, String.toSubstring]]
[instToStreamArraySubarray,[ToStream.mk, Array.toSubarray, OfNat.ofNat, Array.size]]
[Tactic.Ring.horner_atom,[of_eq_true, Eq.trans, congrArg, Eq, congrFun, HAdd.hAdd, HMul.hMul, OfNat.ofNat, pow_one, one_mul, add_zero, eq_self]]
[List.reverse_append,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.reverse, List.nil_append, HAppend.hAppend, List.reverse_nil, List.append_nil, eq_self, Eq.mpr, List.cons_append, List.reverse_cons, congrFun, List.cons, List.nil, Eq.refl, List.append_assoc, rfl]]
[Array.get!,[Array.getD, arbitrary]]
[MonadLiftT.monadLift,[]]
[instHashableInt,[Hashable.mk, UInt64, UInt64.ofNat, HMul.hMul, OfNat.ofNat, HAdd.hAdd]]
[List.or,[List.any, id]]
[List.get?_of_mem,[Exists, Eq, List.get?, Option.some, Exists.intro, Eq.mpr, Eq.refl, List.get?_eq_get, List.get, rfl]]
[true_eq_false_of_false,[False.elim]]
[List.eraseIdx,[List, List.nil, List.cons, PProd.fst]]
[instShiftLeftUInt16,[ShiftLeft.mk, UInt16.shiftLeft]]
[Equiv.toFun,[]]
[Function.surjective.forallâ‚ƒ,[Iff.trans, Function.surjective.forall, forall_congr', Function.surjective.forallâ‚‚]]
[decide_true_eq_true,[Eq, Decidable.decide, True, Bool.true, rfl, False.elim, True.intro]]
[Nat.gcd_dvd_gcd_of_dvd_left,[Nat.dvd_gcd, Nat.dvd_trans, Nat.gcd_dvd_left, Nat.gcd_dvd_right]]
[List.inter,[List.filter, Decidable.decide, Mem.mem]]
[instReprAtomUInt8,[ReprAtom.mk]]
[Nat.coprime_iff_gcd_eq_one,[Iff.rfl]]
[Classical.byCases,[Decidable.byCases]]
[forall_and_distrib,[Iff.intro, And.intro, And.left, And.right, And]]
[min_le_right,[dite, LE.le, Eq.mpr, congrFun, congrArg, if_pos, of_eq_true, Eq.trans, if_neg, eq_true, le_refl]]
[List.erasep_cons_of_neg,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.erasep_cons, ite_congr, eq_false, Eq.refl, List.cons, List.erasep, ite_false, eq_self]]
[instToStringOption,[ToString.mk, Unit.unit, String, HAppend.hAppend, addParenHeuristic, ToString.toString]]
[Nat.pred,[Unit.unit, Nat, OfNat.ofNat]]
[ST.Ref.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Mathlib.Tactic.Lint.LintVerbosity.medium.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Decidable.not_and_not_right,[Iff.intro, Not.decidable_imp_symm, And.intro, False]]
[List.firstM,[Unit.unit, Alternative.failure, HOrElse.hOrElse, PProd.fst]]
[List.mem_of_ne_of_mem,[Or.elim, List.eq_or_mem_of_mem_cons, absurd]]
[ite_congr,[Decidable.em, Eq.mpr, Eq.refl, Eq, ite, if_pos, Eq.symm, if_neg]]
[Char.ne_of_val_ne,[absurd, Char.val_eq_of_eq]]
[Nat.gcd_dvd_gcd_of_dvd_right,[Nat.dvd_gcd, Nat.gcd_dvd_left, Nat.dvd_trans, Nat.gcd_dvd_right]]
[Nat.one_eq_succ_zero,[rfl]]
[Int.natAbs_eq,[Or, Eq, Int.ofNat, Int.natAbs, Neg.neg, Or.inl, rfl, Or.inr]]
[String.Iterator.toEnd,[String.Iterator, String.Iterator.mk, String.bsize]]
[ReaderT.run_seqLeft,[Eq.mpr, Eq.refl, Eq, ReaderT.run, SeqLeft.seqLeft, seqLeft_eq_bind, rfl]]
[Int.eq_of_mul_eq_mul_left,[]]
[Nat.zero_sub,[Unit.unit, Eq, HSub.hSub, OfNat.ofNat, rfl, congr_arg, Nat.pred, PProd.fst]]
[UInt16.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Substring.toIterator,[String.Iterator, String.Iterator.mk]]
[ofNat_add,[Eq, Numeric.ofNat, HAdd.hAdd, Eq.symm, add_zero, OfNat.ofNat, Trans.trans, Semiring.ofNat_succ, Nat.add, of_eq_true, Eq.trans, congr, congrArg, congrFun, Nat.add_eq, Nat.add_zero, PProd.fst, add_assoc, eq_self]]
[Nat.below,[PUnit, PProd]]
[Tactic.Ring.evalConstMul,[Tactic.Ring.RingM, Prod, Tactic.Ring.HornerExpr, Lean.Expr, Bind.bind, liftM, Lean.Meta.mkMul, Prod.fst, Lean.Meta.NormNum.eval, Pure.pure, Prod.mk, Tactic.Ring.HornerExpr.const, HMul.hMul, Prod.snd, PProd.fst, PProd.snd, Tactic.Ring.HornerExpr.xadd', Tactic.Ring.mkAppCS, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Tactic.Ring.HornerExpr.e, List.nil]]
[ExceptT.run_pure,[rfl]]
[Not.elim,[absurd]]
[not_iff_not_of_iff,[Iff.intro, Iff.elim_right, Iff.elim_left]]
[UInt8.instRingUInt8.proof_2,[congrArg, UInt8.mk, Ring.gsmul_zero', UInt8.val]]
[Sub.noConfusionType,[]]
[Fin.shiftRight.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[List.indexesValues,[List.foldrIdx, ite, List.cons, Prod.mk, List.nil]]
[BinaryHeap.max,[Array.get?, BinaryHeap.arr, OfNat.ofNat]]
[UInt16.instSemiringUInt16.proof_12,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HMul.hMul, UInt16.add_def, UInt16.mul_def, UInt16.mk, HAdd.hAdd, UInt16.val, UInt16.eq_of_val_eq, Semiring.add_mul]]
[List.take_append_drop,[Eq, HAppend.hAppend, List.take, List.drop, rfl, congr_arg, List.cons, PProd.fst]]
[List.reverse_nil,[rfl]]
[instSubsingletonDecidable.proof_1,[Subsingleton.intro, Eq, Decidable.isTrue, rfl, absurd, Decidable.isFalse]]
[skipLeft',[WellFoundedRelation.mk, PSigma.Lex, WellFoundedRelation.rel, emptyWf, skipLeft'.proof_1]]
[UInt8.instSemiringUInt8,[Semiring.mk, UInt8.instSemiringUInt8.proof_1, UInt8.instSemiringUInt8.proof_2, UInt8.mk, Semiring.nsmul, UInt8.val, UInt8.instSemiringUInt8.proof_3, UInt8.instSemiringUInt8.proof_4, UInt8.instSemiringUInt8.proof_5, UInt8.instSemiringUInt8.proof_6, UInt8.instSemiringUInt8.proof_7, UInt8.instSemiringUInt8.proof_8, UInt8.instSemiringUInt8.proof_9, UInt8.instSemiringUInt8.proof_10, UInt8.instSemiringUInt8.proof_11, UInt8.instSemiringUInt8.proof_12, UInt8.instSemiringUInt8.proof_13]]
[Prod.mk.inj_iff,[Iff.intro, Prod.mk.inj, Eq.mpr, Eq.refl, Eq, Prod.mk, And.left, And.right, rfl]]
[Array.toList,[Array.foldr, List.cons, List.nil, Array.size, OfNat.ofNat]]
[USize.val_eq_of_lt,[Fin.val_eq_of_lt]]
[DoResultPRBC.pure.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Int.zero_mul,[Int.mul_zero, Int.mul_comm, OfNat.ofNat]]
[Array.getIdx?,[Array.findIdx?, BEq.beq]]
[Nat.zero_lt_of_lt,[LT.lt, OfNat.ofNat]]
[Array.get?_push_eq,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Array.get?, Array.mk, List.concat_eq_append, Array.data, Array.size, Array.get?_eq_get?, HAppend.hAppend, List.cons, List.nil, List.get?_concat_length, Option.some, eq_self]]
[Function.injective2.left,[And.left]]
[Mathlib.ExtendedBinder.Â«termâˆ€__,_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.binderIdent, Lean.ParserDescr.cat]]
[Nat.decidable_dvd.proof_1,[Iff.symm, Nat.dvd_iff_mod_eq_zero]]
[BaseIO,[EIO, Empty]]
[PSigma.SkipLeft,[PSigma.RevLex, emptyRelation]]
[Function.bicompr,[]]
[Tactic.instInhabitedCache,[inferInstanceAs, Inhabited, IO.Ref, Sum, Lean.Meta.MetaM, Task, Except, Lean.Exception]]
[Subarray.hâ‚‚,[]]
[Nat.mod_eq_of_lt,[]]
[instDecidableEqProd.proof_3,[absurd]]
[iff_false,[propext, Iff.intro, Iff.mp, False.elim]]
[Nat.gcd_dvd_gcd_mul_left,[Nat.gcd_dvd_gcd_of_dvd_left, Nat.dvd_mul_left]]
[String.length_eq_list_length,[of_eq_true, eq_self, List.length]]
[Int.natAbs_ofNat,[rfl]]
[Nat.dvd_add_iff_left,[Eq.mpr, Eq.refl, Iff, Dvd.dvd, HAdd.hAdd, Nat.add_comm, Nat.dvd_add_iff_right]]
[Decidable.byContradiction,[Decidable.byCases, id, False.elim]]
[fixCore3,[bfix3, USize.size]]
[Array.swap,[Array.set, Array.swap.proof_1]]
[FloatArray.push,[FloatArray, FloatArray.mk, Array.push]]
[List.mem_filterAux,[Iff, Mem.mem, List.filterAux, Or, And, Eq, Bool.true, of_eq_true, Eq.trans, congr, congrArg, propext, List.mem_reverse, congrFun, List.mem_nil, false_and, false_or, iff_self, Eq.mpr, Unit.unit, List, List.cons, List.mem_cons, PProd.fst, Iff.intro, Or.inl, And.intro, Or.inr, And.left, And.right, Eq.mp, Eq.refl, Bool.false, Eq.symm]]
[StateT.pure,[Pure.pure, Prod.mk]]
[List.mapTR,[List.mapTRAux, List.nil]]
[UInt64.toUInt16,[Nat.toUInt16, UInt64.toNat]]
[instAddCommSemigroup,[AddCommSemigroup.mk, AddCommMonoid.add_comm]]
[Nat.coprime.dvd_of_dvd_mul_right,[Eq.mp, Eq.refl, Dvd.dvd, HMul.hMul, OfNat.ofNat, Nat.mul_one, Nat.gcd, Nat.coprime.gcd_eq_one, Nat.gcd_mul_left]]
[if_ctx_simp_congr_prop,[if_ctx_congr_prop]]
[UInt8.toNat,[Fin.val, UInt8.val]]
[LawfulApplicative.pure_seq,[]]
[Char.isValidChar_of_isValidChar_Nat,[isValidChar, UInt32.ofNat', Char.isValidUInt32, Or.inl, Or.inr, And.intro]]
[instInhabitedExceptT,[Inhabited.mk, MonadExcept.throw, arbitrary]]
[String.trimRight,[Substring.toString, Substring.trimRight, String.toSubstring]]
[System.FilePath.parent,[Functor.map, System.FilePath.mk, String.extract, System.FilePath.toString, OfNat.ofNat, String.revFind, List.contains, System.FilePath.pathSeparators]]
[String.take,[Substring.toString, Substring.take, String.toSubstring]]
[not_imp_of_and_not,[False]]
[List.append_eq_has_append,[rfl]]
[Classical.choose_spec,[Subtype.property, Classical.indefiniteDescription]]
[Functor.map_equiv_symm_apply,[rfl]]
[Substring.foldr,[String.foldrAux]]
[instReprUInt32,[Repr.mk, repr, UInt32.toNat]]
[HPow.noConfusionType,[]]
[dite_congr,[Decidable.em, Eq.mpr, Eq.refl, Eq, dite, dif_pos, Eq.symm, dif_neg]]
[instHashable,[Hashable.mk, OfNat.ofNat]]
[PLift.noConfusionType,[]]
[Nat.mul_div_assoc,[Eq, HDiv.hDiv, HMul.hMul, Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, OfNat.ofNat, Nat.div_zero, Nat.mul_zero, rfl]]
[instToStringSigma,[ToString.mk, String, HAppend.hAppend, ToString.toString]]
[Nat.coprime_mul_iff_right,[Eq.mpr, Eq.refl, Iff, Nat.coprime, HMul.hMul, And, propext, Nat.coprime_comm, Nat.coprime_mul_iff_left, Iff.rfl]]
[Â«term_âˆª_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Option.bind_eq_some,[of_eq_true, Eq.trans, congr, congrArg, Iff, congrFun, Eq, Option.none_bind, Option.some, eq_false', Exists, funext, And, false_and, eq_false, exists_false, eq_true_of_decide, Eq.refl, Bool.true, Eq.symm, Option.some_bind, Option.some.injEq, propext, exists_eq_left', iff_self]]
[USize.instInhabitedFinSize,[Inhabited.mk, Fin.ofNat', OfNat.ofNat, USize.size_positive]]
[Semiring.mul_one,[]]
[ByteArray.forInUnsafe,[OfNat.ofNat, ByteArray.forInUnsafe.loop]]
[instIsAddLeftCancel,[IsAddLeftCancel.mk, instIsAddLeftCancel.proof_1]]
[instInhabitedUInt16.proof_1,[of_decide_eq_true, Eq.refl, Bool.true]]
[System.Platform.isEmscripten,[System.Platform.getIsEmscripten, Unit.unit]]
[Int.instCommRingInt.proof_5,[Int.sub_eq_add_neg]]
[BinaryHeap.increaseKey.proof_1,[Eq.mpr, Eq.refl, LT.lt, Fin.val, Array.size, Array.set, BinaryHeap.arr, Array.size_set, Fin.isLt]]
[Int.eq_ofNat_of_zero_le,[]]
[Int.sub_left_le_of_le_add,[]]
[ByteArray.getOp,[ByteArray.get!]]
[HDiv.hDiv,[]]
[instOrdUInt8,[Ord.mk, compareOfLessAndEq]]
[USize.instRingUSize.proof_1,[congrArg, USize.mk, Ring.sub_eq_add_neg, USize.val]]
[Nat.prod_dvd_and_dvd_of_dvd_prod.proof_4,[Eq.symm]]
[instInhabitedEIO,[inferInstanceAs, Inhabited, EStateM, IO.RealWorld]]
[Array.instReprArray,[Repr.mk, Std.Format, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Std.Format.text, Std.Format.bracketFill, Std.Format.joinSep, Array.toList, HAppend.hAppend, Std.Format.line]]
[Mathlib.Prelude.Rename.RenameMap.insertPair,[Mathlib.Prelude.Rename.RenameMap, Std.HashMap.insert]]
[Nat.add_mul_mod_self_right,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, HMul.hMul, Nat.mul_comm, Nat.add_mul_mod_self_left, rfl]]
[inv_mul_self,[mul_left_inv]]
[List.mapâ‚‚Right',[List.mapâ‚‚Left', flip]]
[List.disjoint_of_subset_left,[]]
[proof_irrel,[proofIrrel]]
[UInt64.decLt,[Decidable, LT.lt, inferInstanceAs]]
[Fin.mul_def,[Eq, HMul.hMul, Fin.mk, HMod.hMod, Fin.val, Nat.mod_lt, Fin.size_positive, rfl]]
[instInhabitedUInt64,[Inhabited.mk, UInt64.ofNatCore, OfNat.ofNat, instInhabitedUInt64.proof_1]]
[Int.sub_le_self,[Trans.trans, Int.add_le_add_left, Int.neg_nonpos_of_nonneg, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, OfNat.ofNat, Int.add_zero, rfl]]
[Nat.sub_self_add,[]]
[String.utf16Length,[String.foldr, HAdd.hAdd, UInt32.toNat, Char.utf16Size, OfNat.ofNat]]
[instToStringInt,[ToString.mk, String, ToString.toString, HAppend.hAppend, Nat.succ]]
[ofNat_zero,[rfl]]
[Char.ofNat.proof_2,[Or.inl, of_decide_eq_true, Eq.refl, Bool.true]]
[instShiftLeftUInt8,[ShiftLeft.mk, UInt8.shiftLeft]]
[AndThen.andThen,[]]
[withPtrEqDecEq.proof_2,[ofBoolUsing_eq_true]]
[Option.join_map_eq_map_join,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, Option.bind, Option.map_none', id, Option.none_bind, Option.map, eq_self, Option.none, Eq.symm, Option.map_some', Option.some, Option.some_bind, id_eq, Eq.refl]]
[List.Nodup,[List.Pairwise, Ne]]
[Function.involutive.eq_iff,[Function.injective.eq_iff', Function.involutive.injective]]
[Tactic.Ring.HornerExpr.const.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Mathlib.Tactic.Lint.simpVarHead,[Mathlib.Tactic.Lint.Linter.mk, Bind.bind, Mathlib.Tactic.Lint.isSimpLemma, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Option.none, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[Option.getD,[]]
[Set.instSubsetSet,[Subset.mk, Set.subset]]
[List.map_id,[of_eq_true, eq_self, List.nil, Eq.trans, congrFun, congrArg, Eq, congr, List.cons, id_eq]]
[List.card_insert_of_not_mem,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.card, List.insert_of_not_mem, Not, eq_false, eq_true_of_decide, Eq.refl, Bool.true, List.card_cons_of_not_mem, HAdd.hAdd, OfNat.ofNat, eq_self]]
[setOf,[]]
[SubNegMonoid.gsmul_zero',[]]
[List.length_pos_iff_ne_nil,[Iff.intro, List.ne_nil_of_length_pos, List.length_pos_of_ne_nil]]
[cast_heq,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, HEq, cast]]
[System.instInhabitedFilePath,[Inhabited.mk, System.FilePath.mk, arbitrary]]
[ite_true,[rfl]]
[GroupWithZero.inv_zero,[]]
[UInt8.instInhabitedFinSize,[Inhabited.mk, Fin.ofNat', OfNat.ofNat, UInt8.size_positive]]
[decidable_of_bool.proof_1,[Iff.mp, rfl]]
[List.tail!,[Unit.unit, List, panicWithPosWithDecl, OfNat.ofNat]]
[String.instDecidableEqIterator,[Decidable, Eq, dite, Decidable.isTrue, rfl, Decidable.isFalse]]
[List.get_of_eq,[rfl, Eq.symm, eq_of_heq, Eq.refl, HEq.refl]]
[Nat.decLe,[dite, Eq, Nat.ble, Bool.true, Decidable.isTrue, Nat.le_of_ble_eq_true, Decidable.isFalse, Nat.not_le_of_not_ble_eq_true]]
[Nat.two_step_induction,[Unit.unit, PProd.fst, PProd.snd]]
[imp_false,[Iff.rfl]]
[Int.lt_of_add_lt_add_right,[Int.lt_of_add_lt_add_left, Eq.mpr, Eq.refl, LT.lt, HAdd.hAdd, Int.add_comm]]
[Int.neg_add_cancel_left,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, Eq.symm, Int.add_assoc, Int.add_left_neg, OfNat.ofNat, Int.zero_add, rfl]]
[Bool.toUInt64,[ite, Eq, Bool.true, OfNat.ofNat]]
[Nat.mod_add_div,[Nat.mod.inductionOn, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HMod.hMod, HMul.hMul, HDiv.hDiv, Nat.div_eq, ite, And, LT.lt, OfNat.ofNat, LE.le, HSub.hSub, Nat.mod_eq, congrFun, congrArg, congr, Eq.trans, ite_congr, eq_true, eq_true_of_decide, Bool.true, ite_true, Nat.mul_succ, Eq.symm, Nat.add_assoc, Nat.sub_add_cancel, And.right, rfl, of_eq_true, eq_false, ite_false, Nat.mul_zero, Nat.add_zero, eq_self]]
[List.get,[absurd, Nat.not_lt_zero]]
[Tactic.Ring.State.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Tactic.Ring.State.mk, Eq.symm, eq_of_heq, HEq.refl]]
[List.get_cons_length,[Eq.mpr, Eq.refl, Eq, List.get, List.cons, of_eq_true, Eq.trans, congr, congrArg, LT.lt, List.length_cons, eq_true, Nat.lt_succ_self, List.length, List.last, List.cons_ne_nil, List.last_eq_get, rfl, Eq.symm, eq_of_heq, HEq.refl]]
[Fin.land,[Fin, Fin.mk, HMod.hMod, Nat.land, Fin.land.proof_1]]
[Nat.mul_mod_mul_left,[dite, Eq, OfNat.ofNat, Eq.mpr, Eq.refl, HMod.hMod, HMul.hMul, Nat.mul_zero, Nat.mod_zero, rfl, Nat.zero_mul, Nat.strong_rec_on]]
[Trans.noConfusionType,[]]
[Int.negSucc_ofNat_mul_subNatNat,[]]
[Subarray.forInUnsafe,[USize.ofNat, Subarray.start, Subarray.forInUnsafe.loop]]
[Function.has_right_inverse,[Exists, Function.right_inverse]]
[Function.bijective,[And, Function.injective, Function.surjective]]
[Function.right_inverse_of_injective_of_left_inverse,[]]
[decidableEq_of_decidableLe,[Decidable, Eq, dite, LE.le, Decidable.isTrue, le_antisymm, Decidable.isFalse, decidableEq_of_decidableLe.proof_1, decidableEq_of_decidableLe.proof_2]]
[Not.intro,[]]
[List.card_insert_of_mem,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.card, List.insert_of_mem, eq_true, eq_self]]
[instInhabitedReaderT,[Inhabited.mk, arbitrary]]
[Or.elim,[]]
[Function.update_eq_self,[Iff.mpr, Function.update_eq_iff, And.intro, rfl]]
[Nat.succ_eq_add_one,[rfl]]
[Option.map_eq_none',[of_eq_true, Eq.trans, congr, congrArg, Iff, congrFun, Eq, Option.map_none', Option.none, eq_self, eq_true_of_decide, Eq.refl, Bool.true, Eq.symm, Option.map_some', eq_false']]
[Nat.gcd_pos_of_pos_right,[Nat.pos_of_dvd_of_pos, Nat.gcd_dvd_right]]
[Option.ne_none_iff_exists,[of_eq_true, Eq.trans, congr, congrArg, Iff, ne_eq, Option.none, Not, eq_self, eq_false_of_decide, Eq.refl, Bool.false, Exists, funext, eq_false', eq_false, exists_false, eq_true_of_decide, Bool.true, Eq.symm, Option.some, Option.some.injEq, eq_true, exists_eq]]
[HDiv.noConfusionType,[]]
[List.mem_or_eq_of_mem_set,[List.nil, Or, Mem.mem, Eq, Or.elim, Iff.mp, List.mem_cons, Or.inr, Function.comp, Or.inl, List.mem_cons_of_mem, List.mem_cons_self, PProd.fst, Nat.add]]
[BinaryHeap.insertExtractMax,[Prod, BinaryHeap, BinaryHeap.max, BinaryHeap.insertExtractMax.proof_1, Prod.mk, ite, Eq, Bool.true, BinaryHeap.mk, Subtype.val, BinaryHeap.heapifyDown, Fin.mk, OfNat.ofNat, BinaryHeap.insertExtractMax.proof_2]]
[UInt32.shiftLeft,[UInt32.mk, HShiftLeft.hShiftLeft, UInt32.val, UInt32.modn, OfNat.ofNat]]
[forall_imp,[]]
[Int.mul_le_mul_of_nonneg_right,[Decidable.em, LE.le, of_eq_true, Eq.trans, congrArg, HMul.hMul, congrFun, le_antisymm, eq_true, le_refl, Eq.symm, OfNat.ofNat, congr, Int.mul_zero, eq_true_of_decide, Eq.refl, Bool.true, And.left, le_not_le_of_lt, Int.mul_lt_mul_of_pos_right, lt_of_le_not_le]]
[ExceptT.run_lift,[rfl]]
[instLTUSize,[LT.mk, USize.lt]]
[List.get?_eq_some,[Iff.intro, Eq, List.get?, Option.some, List.get?_eq_get]]
[List.hasDecEq.proof_5,[absurd]]
[Nat.toSuperDigits,[Nat.toSuperDigitsAux, List.nil]]
[instAndOpUInt8,[AndOp.mk, UInt8.land]]
[UInt8.instRingUInt8.proof_3,[congrArg, UInt8.mk, Ring.gsmul_succ', UInt8.val]]
[dbgTrace,[Unit.unit]]
[Int.subNatNat_add_right,[]]
[UInt8.ofNatCore,[UInt8.mk, Fin.mk]]
[UInt32.toUSize,[Nat.toUSize, UInt32.toNat]]
[Or.imp_left,[Or.imp, id]]
[Option.isSome_iff_exists,[of_eq_true, Eq.trans, congr, congrArg, Iff, eq_false', Exists, funext, eq_false, exists_false, eq_true_of_decide, Eq.refl, Bool.true, Eq.symm, Option.some.injEq, eq_true, exists_eq']]
[List.modifyNthTail_id,[Eq, List.modifyNthTail, id, rfl, congr_arg, List.cons, PProd.fst]]
[Prod.snd_injective,[Prod.ext', Subsingleton.elim, Prod.fst]]
[Nat.strong_rec_on,[WellFounded.fix', WellFoundedRelation.wf, Nat.lt_wfRel]]
[List.mem_singleton_self,[List.mem_cons_self, List.nil]]
[instInhabitedNat,[Inhabited.mk, Nat.zero]]
[StateT.bind,[Bind.bind, Prod]]
[fix3,[fixCore3, arbitrary]]
[Array.swapAt,[Prod.mk]]
[Iff.mpr,[]]
[instHAnd,[HAnd.mk, AndOp.and]]
[FloatArray.size,[Nat, Array.size]]
[recSubsingleton,[Subsingleton]]
[Measure,[InvImage, LT.lt]]
[Ring.toSub,[]]
[Mathlib.TermUnsafe.termUnsafe_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Option.join,[Option.bind, id]]
[Mathlib.Tactic.Lint.NamedLinter.declName,[]]
[And.assoc,[Iff.intro, And, And.intro]]
[boolToSort,[CoeSort.mk, Eq, Bool.true]]
[and_self,[propext, Iff.intro, And.left, And.intro]]
[List.mmapUpperTriangle,[Unit.unit, List, Pure.pure, List.nil, Bind.bind, List.mmap, PProd.fst, HAppend.hAppend, List.cons]]
[Nat.add_div_right,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HAdd.hAdd, Nat.succ, Nat.div_eq_sub_div, Nat.le_add_left, HSub.hSub, OfNat.ofNat, Nat.add_sub_cancel, rfl]]
[List.set_eq_modifyNth,[Eq, List.set, List.modifyNth, rfl, Eq.symm, Eq.refl, congr_arg, List.cons, PProd.fst]]
[Functor.map_equiv.proof_1,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Functor.map_map, Equiv.toFun, Equiv.symm, Functor.map, Equiv.symm_comp_self, LawfulFunctor.id_map, eq_self]]
[Nat.ne_of_lt,[Nat.not_le_of_lt, Nat.le_refl, Eq.symm]]
[unexpandEqRec,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[Tactic.Ring.evalAtom,[Bind.bind, Tactic.Ring.addAtom, MonadReader.read, liftM, Lean.Meta.mkAppOptM, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Option.some, Tactic.Ring.Cache.Î±, Lean.mkRawNatLit, OfNat.ofNat, Option.none, List.nil, Pure.pure, Tactic.Ring.HornerExpr.const, Tactic.Ring.HornerExpr.xadd', Prod.mk, Tactic.Ring.mkAppCS]]
[instIsAddRightCancel,[IsAddRightCancel.mk, instIsAddRightCancel.proof_1]]
[List.Â«term_~_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Tactic.TryThis.addTermSuggestion,[Bind.bind, Tactic.TryThis.delabToRefinableSyntax, Tactic.TryThis.addSuggestion]]
[Function.right_inverse_iff_comp,[Iff.intro, Function.right_inverse.comp_eq_id, congr_fun]]
[List.last_append,[Eq, List.last, HAppend.hAppend, List.cons, List.nil, rfl]]
[String.isEmpty,[BEq.beq, String.bsize, OfNat.ofNat]]
[List.allM,[Unit.unit, Bool, Pure.pure, Bool.true, Bind.bind, PProd.fst, Bool.false]]
[List.eq_nil_of_subset_nil,[Eq, List.nil, rfl, False.elim, List.mem_cons_self]]
[BinaryHeap.mkHeap.loop.proof_4,[Eq.trans, Subtype.property, BinaryHeap.heapifyDown, Fin.mk, BinaryHeap.mkHeap.loop.proof_2]]
[Fin.checked_add_spec,[Decidable.em, LE.le, HAdd.hAdd, Fin.val, of_eq_true, Eq.trans, congrFun, congrArg, Iff, Eq, Unit.unit, Bool, Option, Fin, Prod.mk, decide_eq_true, eq_true, Option.none, Option.some, Bool.true, Bool.false, eq_false', LT.lt, false_iff, propext, not_lt, Eq.symm, congr, decide_eq_false, Not, eq_false, eq_true_of_decide, Eq.refl, Eq.mp, not_le]]
[StateRefT'.instMonadLiftStateRefT',[MonadLift.mk, StateRefT'.lift]]
[List.subset_append_of_subset_left,[List.subset.trans, List.subset_append_left]]
[Fin.modn,[Fin, Fin.mk, HMod.hMod, Fin.modn.proof_1]]
[Nat.mul_le_mul_left,[LE.le, HMul.hMul, Nat.le.dest]]
[Quotient.rec,[Quot.rec]]
[List.partition,[List.partitionAux, Prod.mk, List.nil]]
[PSigma.lexNdepWf,[PSigma.lexNdepWf.proof_1]]
[List.toPersistentArrayAux,[Std.PersistentArray, PProd.fst, Std.PersistentArray.push]]
[Nat.lcm_one_left,[]]
[List.disjoint_of_disjoint_append_left_right,[And.right, Iff.mp, List.disjoint_append_left]]
[decidableBEx.proof_2,[Exists.intro, And.intro, Or.inl, rfl]]
[List.diff,[List, ite, Eq, List.elem, Bool.true, PProd.fst, List.erase]]
[and_or_distrib_left,[Iff.intro, Or, And, Or.imp, And.intro, And.imp_right, Or.inl, Or.inr]]
[Function.involutive_iff_iter_2_eq_id,[Iff.symm, Function.funext_iff]]
[instReprSubtype,[Repr.mk, Repr.reprPrec, Subtype.val]]
[UInt64.land,[UInt64.mk, Fin.land, UInt64.val]]
[Alternative.toApplicative,[]]
[UInt64.decEq,[Decidable, Eq, dite, Decidable.isTrue, UInt64.decEq.proof_1, Decidable.isFalse, UInt64.decEq.proof_2]]
[ExistsUnique.exists,[Exists, Exists.intro]]
[StateM,[StateT, Id]]
[GT.gt,[LT.lt]]
[MonadFinally.noConfusionType,[]]
[instHashableOption,[Hashable.mk, Unit.unit, UInt64, OfNat.ofNat, mixHash, Hashable.hash]]
[Int.mul_comm,[Eq, HMul.hMul, of_eq_true, Eq.trans, congr, congrArg, Int.ofNat_mul_ofNat, Int.ofNat, Nat.mul_comm, eq_self, Eq.symm, Int.ofNat_mul_negSucc_ofNat, Int.negSucc_ofNat_ofNat, Int.negOfNat, Nat.succ, Eq.refl, Int.mul_negSucc_ofNat_negSucc_ofNat]]
[getThe,[MonadStateOf.get]]
[ByteArray.push,[ByteArray, ByteArray.mk, Array.push]]
[imp_intro,[]]
[lt_trans,[LT.lt, le_not_le_of_lt, lt_of_le_not_le, le_trans]]
[instLawfulFunctorOption.proof_1,[LawfulFunctor.mk, rfl, Eq.symm, Eq.refl]]
[Quotient.liftâ‚‚.proof_1,[Setoid.refl]]
[one_mul,[Monoid.one_mul]]
[List.mem_cons_of_mem,[Or.inr]]
[instDivFloat,[Div.mk, Float.div]]
[Â«term%[_|_]Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false]]
[BaseIO.mapTasks.go,[BaseIO, Task, BaseIO.bindTask, PProd.fst, List.cons, BaseIO.asTask, List.reverse]]
[Function.extend,[dite, Exists, Eq, Classical.choose]]
[List.exists_of_erasep,[Exists, And, Not, Eq, List.nil, HAppend.hAppend, List.cons, List.erasep, Eq.refl, Decidable.em, Exists.intro, And.intro, List.forall_mem_nil, of_eq_true, Eq.trans, congr, congrArg, List.nil_append, eq_self, List.erasep_cons_of_pos, eq_true, eq_true_of_decide, Bool.true, Eq.symm, False.elim, Eq.mp, Iff.mpr, List.forall_mem_cons, Eq.mpr, List.cons_append, rfl, List.erasep_cons_of_neg, eq_false]]
[Nat.eq_zero_of_add_eq_zero_left,[Nat.eq_zero_of_add_eq_zero_right, Nat.add_comm]]
[lt_of_lt_of_le,[LT.lt, lt_of_le_not_le, le_trans]]
[instDecidableFalse,[Decidable.isFalse, not_false]]
[noConfusionTypeEnum,[ite, Eq]]
[Function.surj_inv,[Classical.choose]]
[Array.mk.inj,[]]
[Except.instMonadExcept,[Monad.mk]]
[Semiring.toSemigroup,[]]
[ExceptT.instMonadFunctorExceptT,[MonadFunctor.mk, Except]]
[Inhabited.default,[]]
[Int.le.dest,[Exists, Eq, HAdd.hAdd, Int.ofNat, Exists.intro, Eq.mpr, Eq.refl, Eq.symm, HSub.hSub, Int.add_comm, of_eq_true, Eq.trans, congrFun, congrArg, Int.sub_eq_add_neg, Int.add_assoc, Neg.neg, Int.add_left_neg, Int.add_zero, eq_self]]
[Option.mem_map_of_mem,[Iff.mpr, Option.mem_def, Option.map_some', Eq.symm, Iff.mp]]
[instRingFin,[Ring.mk, Fin, Semiring.nsmul, Neg.neg, Nat.succ, instRingFin.proof_2, instRingFin.proof_3, instRingFin.proof_4, instRingFin.proof_5]]
[List.get?_modifyNth_ne,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.get?_modifyNth, Functor.map, funext, if_neg, List.get?, id_map', eq_self]]
[Nat.forRevM,[Nat.forRevM.loop]]
[instReprInt,[Repr.mk, Std.Format.text, Int.repr]]
[Nat.eq_zero_of_zero_dvd,[Exists.elim, Eq.trans, Nat.zero_mul]]
[Monad.toBind,[]]
[Function.bijective.surjective,[And.right]]
[decidableBEx.proof_1,[Exists.intro, And.intro, False]]
[System.FilePath.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt8.add,[UInt8.mk, HAdd.hAdd, UInt8.val]]
[eq_of_heq,[]]
[WellFounded.recursion,[WellFounded.apply]]
[FloatArray.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Int.subNatNat_of_sub_eq_succ,[]]
[Fin.mod_lt,[LT.lt, HMod.hMod]]
[instComplementUInt64,[Complement.mk, UInt64.complement]]
[instToBoolOption,[ToBool.mk, Option.toBool]]
[String.extract,[String, ite, GE.ge, String.mk, List.nil, List.cons, List, Char, Eq, PProd.fst, HAdd.hAdd, String.csize, OfNat.ofNat]]
[InvImage,[]]
[Thunk.bind,[Thunk.mk, Thunk.get]]
[Substring.beq,[and, BEq.beq, Substring.bsize, String.substrEq, Substring.str, Substring.startPos]]
[Â«stx_*Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Exists.imp,[exists_imp_exists]]
[List.append_inj_right,[And.right, List.append_inj]]
[min_le_left,[dite, LE.le, of_eq_true, Eq.trans, congrFun, congrArg, if_pos, eq_true, le_refl, Eq.mpr, if_neg, le_of_not_le]]
[Mathlib.Tactic.Ext.tacticExt_or_skip__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Int.sub_lt_sub,[Int.add_lt_add, Int.neg_lt_neg]]
[OptionT,[Option]]
[List.removeNth,[List, List.nil, List.cons, PProd.fst]]
[unexpandExists,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, MonadExcept.throw, Unit.unit]]
[Tactic.Ring.Cache.univ,[]]
[Quot.indep,[PSigma.mk, Quot.mk]]
[instDecidableOr,[Decidable, Or, Decidable.isTrue, Or.inl, Or.inr, Decidable.isFalse, instDecidableOr.proof_1]]
[instReprBool,[Repr.mk, Std.Format, Std.Format.text]]
[instLEUSize,[LE.mk, USize.le]]
[StdGen.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[String.decEq.proof_2,[absurd]]
[heq_of_eq_rec_right,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, HEq, HEq.rfl]]
[UInt64.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[ExceptT.ext,[id]]
[Nat.mul_sub_left_distrib,[Eq.mpr, Eq.refl, Eq, HMul.hMul, HSub.hSub, Nat.mul_comm, Nat.mul_sub_right_distrib, rfl]]
[Function.uncurry_apply_pair,[rfl]]
[Mathlib.TermUnsafe.mkAuxName,[Lean.MonadQuotation.withFreshMacroScope, Bind.bind, Lean.Elab.Term.getDeclName?, Lean.MonadQuotation.getMainModule, Lean.MonadQuotation.getCurrMacroScope, Pure.pure, Lean.addMacroScope]]
[StateRefT'.modifyGet,[ST.Ref.modifyGet]]
[prioMid,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Nat.mul_pos,[]]
[Semiring.zero_mul,[]]
[Function.has_left_inverse.injective,[Exists.elim, Function.left_inverse.injective]]
[CoeFun.coe,[]]
[Sum.inr.injEq,[Eq.propIntro, Eq.refl, Sum.inr, Eq.symm, eq_of_heq, HEq.refl]]
[le_max_left,[dite, LT.lt, of_eq_true, Eq.trans, congrArg, LE.le, if_pos, eq_true, le_refl, Eq.mpr, if_neg, le_of_not_lt]]
[Or.by_cases,[dite, False.elim, Or.elim]]
[Subarray.foldrM,[Array.foldrM, Subarray.as, Subarray.stop, Subarray.start]]
[List.exists_mem_cons_iff,[Iff.intro, List.or_exists_of_exists_mem_cons, Or.elim, List.exists_mem_cons_of, List.exists_mem_cons_of_exists]]
[MonadFunctorT.monadMap,[]]
[Bool.false_and,[rfl, Eq.symm, Eq.refl]]
[Preorder.le_trans,[]]
[Nat.foldRevM,[Nat.foldRevM.loop]]
[Semiring.nsmul_zero',[]]
[Function.partial_inv,[dite, Exists, Eq, Option.some, Classical.choose, Option.none]]
[Int.le_of_sub_one_lt,[Int.le_of_lt_add_one, Int.lt_add_of_sub_right_lt]]
[List.concat,[List, List.cons, List.nil, PProd.fst]]
[Array.binSearchContains,[ite, LT.lt, Array.size, Array.binSearchAux, Option.isSome, Bool.false]]
[Â«term_â‰¥_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[List.ofFn,[List.ofFnAux, Nat.le_refl, List.nil]]
[instDecidableEqSum.proof_5,[]]
[Option.map_comp_map,[funext, of_eq_true, Eq.trans, congrFun, congrArg, Eq, Function.comp_apply, Option.map_map, Option.map, Function.comp, eq_self]]
[Prod.rprod,[WellFoundedRelation.mk, Prod.RProd, WellFoundedRelation.rel, Prod.rprod.proof_1]]
[StateCpsT.runK_pure,[rfl]]
[List.forall_mem_singleton,[Eq.mpr, congrFun, congrArg, Iff, Eq.trans, forall_congr, implies_congr, propext, List.mem_singleton, Eq.refl, forall_eq, Iff.rfl]]
[unique_of_exists_unique,[Eq, Eq.trans, Eq.symm]]
[System.mkFilePath,[System.FilePath.mk, String.intercalate, Char.toString, System.FilePath.pathSeparator]]
[Int.add_pos_of_nonneg_of_pos,[Int.add_lt_add_of_le_of_lt, Int.zero_add, OfNat.ofNat]]
[instRingFin.proof_1,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, Fin.sub_def, Fin.add_def, Fin.mk, HMod.hMod, HSub.hSub, Fin.val, instNegFin.proof_1, Fin.mk.injEq, HAdd.hAdd, Nat.mod_lt, Fin.size_positive, Nat.add_mod_mod, eq_self, propext, forall_const, Fin]]
[CommRing.toRing,[]]
[List.get?_mem,[Mem.mem, List.get_mem]]
[Nat.succ_sub,[Exists.elim, Nat.le.dest, Eq.mpr, Eq.refl, Eq, HSub.hSub, Nat.succ, Eq.symm, HAdd.hAdd, Nat.add_sub_cancel_left, Nat.add_succ, rfl]]
[List.appendTR,[List.reverseAux, List.reverse]]
[String.endsWith,[BEq.beq, Substring.takeRight, String.toSubstring, String.length]]
[Nat.le_lt_antisymm,[Nat.lt_irrefl, Nat.lt_of_le_of_lt]]
[instToStringExcept,[ToString.mk, String, HAppend.hAppend, ToString.toString]]
[DecidablePred,[Decidable]]
[Int.ne_of_lt,[Int.lt_irrefl, Eq.symm, eq_of_heq, Eq.refl, HEq.refl]]
[List.filterMapM.loop,[List, Pure.pure, Bind.bind, Unit.unit, PProd.fst, List.cons]]
[UInt32.instSemiringUInt32.proof_2,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt32.zero_def, UInt32.add_def, UInt32.mk, OfNat.ofNat, zero_add, UInt32.val, UInt32.mk_val_eq, eq_self, propext, forall_const, UInt32]]
[zero_add,[AddMonoid.zero_add]]
[List.fillNones,[List, List.nil, List.cons, PProd.fst, List.reduceOption]]
[Â«term_*_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Tactic.Ring.HornerExpr.e,[Lean.Expr]]
[Quotient.mk,[Quot.mk, Setoid.r]]
[HMul.hMul,[]]
[Tactic.Ring.horner_pow,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HPow.hPow, add_zero, HMul.hMul, mul_pow, HAdd.hAdd, Eq.symm, pow_mul, OfNat.ofNat, eq_self]]
[ReaderT.failure,[Alternative.failure]]
[Substring.next,[String.Pos, ite, Eq, HSub.hSub, String.next]]
[USize.decEq.proof_1,[rfl]]
[Option.map_id',[Option.map_id]]
[UInt32.instSemiringUInt32.proof_3,[congrArg, UInt32.mk, Semiring.nsmul_zero', UInt32.val]]
[CoeDep.coe,[]]
[Char.val_ne_of_ne,[absurd, Char.eq_of_val_eq]]
[List.noConfusionType,[]]
[Nat.not_lt_zero,[Nat.not_succ_le_zero]]
[Function.involutive.injective,[Function.left_inverse.injective, Function.involutive.left_inverse]]
[pow_mul,[of_eq_true, Eq.trans, congr, congrArg, Eq, HPow.hPow, HMul.hMul, Nat.zero_eq, Nat.mul_zero, pow_zero, eq_self, OfNat.ofNat, Eq.mpr, Eq.refl, Nat.succ, Nat.mul_succ, HAdd.hAdd, pow_add, pow_succ', pow_mul_comm, rfl]]
[decide_eq_true_iff,[Iff.intro, of_decide_eq_true, decide_eq_true]]
[instSubNat,[Sub.mk, Nat.sub]]
[Char.valid,[]]
[UInt32.decLt,[Decidable, LT.lt, inferInstanceAs]]
[Â«termExists_,_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
[Subrelation.accessible.proof_1,[Acc.intro]]
[Decidable.not_and,[Decidable.not_and_iff_or_not]]
[String.leftpad_prefix,[String.isPrefix, String.repeat, HSub.hSub, String.length, String.leftpad, of_eq_true, eq_true, List.leftpad_prefix]]
[UInt16.mul_def,[rfl]]
[DecidableEq,[Decidable, Eq]]
[Â«term_==_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[outParam,[]]
[Nat.le_of_ble_eq_true,[Eq.refl, Bool.true, HEq.refl, LE.le, Nat.zero_le, Nat.succ_le_succ, PProd.fst]]
[UInt8.instSemiringUInt8.proof_10,[rfl]]
[StateCpsT,[]]
[Semiring.toNumeric,[]]
[Function.comp.left_id,[rfl]]
[List.groupBy,[Unit.unit, List, List.nil, List.groupByAux, List.cons]]
[Nat.gt_of_not_le,[GT.gt, Nat.lt_or_ge, absurd]]
[Nat.mul_dvd_mul,[Dvd.dvd, HMul.hMul, Exists.intro, Eq.mpr, Eq.refl, Eq, Nat.mul_assoc, Eq.symm, Nat.mul_comm, rfl]]
[Subtype.existsOfSubtype.proof_1,[Exists, Exists.intro]]
[instToStringFloat,[ToString.mk, Float.toString]]
[List.nodupDecidable,[List.decidablePairwise]]
[Mathlib.Tactic.Lint.isAutoDecl,[ite, Eq, Lean.Name.hasMacroScopes, Bool.true, Pure.pure, Bind.bind, PUnit.unit]]
[USize.instSemiringUSize.proof_5,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, congrFun, HMul.hMul, USize.zero_def, USize.mul_def, USize.mk, OfNat.ofNat, MonoidWithZero.zero_mul, USize.val, eq_self, propext, forall_const, USize]]
[System.instReprFilePath,[Repr.mk, Repr.addAppParen, HAppend.hAppend, Std.Format.text, repr, System.FilePath.toString]]
[Char.utf8Size_pos,[Classical.em, LE.le, Char.val, UInt32.ofNatCore, OfNat.ofNat, Char.utf8Size.proof_1, Eq.mpr, congrArg, LT.lt, if_pos, of_decide_eq_true, Eq.refl, Bool.true, if_neg, Char.utf8Size.proof_3, Char.utf8Size.proof_5]]
[List.foldrIdx,[List.foldrIdxAux, OfNat.ofNat]]
[Subtype.equivalence,[Equivalence.mk, Subtype.refl, Subtype.symm, Subtype.trans]]
[Nat.le_of_lt,[Nat.le_of_succ_le]]
[ByteArray.instEmptyCollectionByteArray,[EmptyCollection.mk, ByteArray.empty]]
[Int.instNegInt,[Neg.mk, Int.neg]]
[Mathlib.Tactic.Lint.isSimpEq,[Lean.Meta.withReducible, ite, Eq, Bool.true, Bind.bind, Lean.Meta.whnf, Pure.pure]]
[and_iff_not_or_not,[Decidable.and_iff_not_or_not]]
[StateT.run_set,[rfl]]
[StateT.run',[Functor.map, Prod.fst]]
[instAddCommGroup.proof_3,[Semiring.nsmul_zero']]
[UInt16.mod_def,[rfl]]
[isValidChar,[Or, LT.lt, OfNat.ofNat, And]]
[Nat.ble,[Unit.unit, Bool, Bool.true, Bool.false, PProd.fst]]
[List.erasep_append_left,[List.nil, Eq, List.erasep, HAppend.hAppend, Decidable.em, of_eq_true, Eq.trans, congr, congrArg, List.cons_append, List.erasep_cons_of_pos, eq_true, congrFun, eq_self, Eq.symm, Eq.mpr, List.erasep_cons_of_neg, Not, eq_false, eq_true_of_decide, Eq.refl, Bool.true, List.cons.injEq, And, true_and, PProd.fst, List.mem_of_ne_of_mem, mt, eq_of_heq, HEq.refl, rfl]]
[Function.surjective.exists,[Iff.intro, Exists, Exists.intro, Eq.symm]]
[instReprULift,[Repr.mk, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg, ULift.down]]
[Fin.shiftRight,[Fin, Fin.mk, HMod.hMod, HShiftRight.hShiftRight, Fin.shiftRight.proof_1]]
[HEq.trans,[HEq.subst]]
[EStateM.Backtrackable.noConfusionType,[]]
[imp_or_distrib',[Decidable.imp_or_distrib']]
[Â«term_/_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Int.le_total,[Or.imp_right, Eq.mp, Eq.refl, Int.NonNeg, Neg.neg, HSub.hSub, of_eq_true, Eq.trans, congr, congrArg, Eq, Int.sub_eq_add_neg, Int.neg_add, HAdd.hAdd, Int.neg_neg, Int.add_comm, eq_self, Int.nonneg_or_nonneg_neg]]
[instOfNat_1,[OfNat.mk, One.one]]
[Id.hasBind,[inferInstance]]
[BinaryHeap.mkHeap,[HDiv.hDiv, Array.size, OfNat.ofNat, Nat.div_le_self, BinaryHeap.mkHeap.loop]]
[Subarray.popFront.proof_1,[Nat.le_of_lt_succ, Nat.add_lt_add_right, OfNat.ofNat]]
[List.mem_map_of_mem,[Mem.mem, List.map, List.nil, Eq.refl, Eq.mpr, List.cons, Or.inl, rfl, Eq.symm, Or.inr]]
[Sum.inl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.find_x.proof_1,[And.intro]]
[instDecidableIff.proof_4,[Iff.intro, absurd]]
[ReaderT.run_bind,[rfl]]
[instReprAtomNat,[ReprAtom.mk]]
[min_left_comm,[left_comm, min, min_comm, min_assoc]]
[Function.comp_left,[]]
[Array.allM,[Bind.bind, Array.anyM, Pure.pure, not, OfNat.ofNat, Array.size]]
[Bind.bind,[]]
[Int.ofNat_succ_pos,[Iff.mpr, Int.ofNat_lt, Nat.succ_pos]]
[Int.mul_le_mul,[Trans.trans, Int.mul_le_mul_of_nonneg_right, Int.mul_le_mul_of_nonneg_left]]
[Â«term_|||_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.sub_mul_mod,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HSub.hSub, HMul.hMul, Nat.zero, Nat.mul_zero, OfNat.ofNat, Nat.sub_zero, rfl]]
[UInt64.instSemiringUInt64.proof_11,[Eq.mpr, congr, congrArg, Eq, Eq.trans, HMul.hMul, UInt64.add_def, UInt64.mul_def, UInt64.mk, HAdd.hAdd, UInt64.val, UInt64.eq_of_val_eq, Semiring.mul_add]]
[instCommMonoid_1,[CommMonoid.mk, CommSemiring.mul_comm]]
[AndOp.and,[]]
[List.forIn_nil,[rfl]]
[USize.one_def,[rfl]]
[Char.toUInt8,[UInt32.toUInt8, Char.val]]
[instDivUSize,[Div.mk, USize.div]]
[PSigma.fst,[]]
[List.get_repeat,[List.eq_of_mem_repeat, List.get_mem, List.repeat]]
[String.takeRight,[Substring.toString, Substring.takeRight, String.toSubstring]]
[or_of_or_of_imp_of_imp,[Or.imp]]
[Â«term_+_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.le_add_right,[LE.le, HAdd.hAdd, Nat.le_refl, Nat.le_succ_of_le, PProd.fst]]
[Xor.xor,[]]
[Int.lt_add_one_of_le,[Int.add_le_add_right, OfNat.ofNat]]
[Char.le,[LE.le, Char.val]]
[Tactic.Ring.horner_horner,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HAdd.hAdd, HMul.hMul, add_zero, HPow.hPow, mul_assoc, Eq.symm, pow_add, eq_self]]
[Tactic.Ring.HornerExpr.const.injEq,[Eq.propIntro, And.intro, Eq.refl, Tactic.Ring.HornerExpr.const, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.sub_sub,[Eq, HSub.hSub, HAdd.hAdd, Eq.mpr, Eq.refl, OfNat.ofNat, Nat.add_zero, Nat.sub_zero, rfl, Nat.succ, Nat.add_succ, Nat.sub_succ, Nat.pred, PProd.fst]]
[Fin.instOrOpFin,[OrOp.mk, Fin.lor]]
[Option.some.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[ST.Ref.get,[liftM, ST.Prim.Ref.get]]
[Â«stx_,+,?Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[FloatSpec.val,[]]
[Int.rem,[Int, Int.ofNat, HMod.hMod, Nat.succ, Neg.neg]]
[add_left_cancel_iff,[Iff.intro, add_left_cancel, congrArg, HAdd.hAdd]]
[UInt64.instCommRingUInt64.proof_1,[UInt64.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, UInt64.val, UInt64.mul_def, CommSemiring.mul_comm]]
[FloatArray.instInhabitedFloatArray,[Inhabited.mk, FloatArray.empty]]
[Decidable.le_iff_lt_or_eq,[Iff.intro, Decidable.lt_or_eq_of_le, le_of_lt_or_eq]]
[FloatArray.toList,[OfNat.ofNat, List.nil, FloatArray.toList.loop]]
[Mathlib.Tactic.Lint.Â«command#list_lintersÂ»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Int.lt_add_of_sub_right_lt,[]]
[Int.mul_nonpos_of_nonpos_of_nonneg,[]]
[Nat.mod_eq,[congrFun, WellFounded.fix_eq, WellFoundedRelation.wf, measure, id, dite, And, LT.lt, OfNat.ofNat, LE.le, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le, dif_eq_if, HMod.hMod]]
[Except.ok.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instReprChar,[Repr.mk, Std.Format.text, Char.quote]]
[instToStringList,[ToString.mk, List.toString]]
[instNonempty,[instNonempty.proof_1]]
[Function.comp_apply,[rfl]]
[TC.wf,[TC.wf.proof_1]]
[Option.decidable_forall_mem.proof_3,[mt, rfl]]
[USize.lt,[LT.lt, USize.val]]
[Int.add_lt_add_of_lt_of_le,[lt_of_lt_of_le, Int.add_lt_add_right, Int.add_le_add_left]]
[List.card_subset_le,[LE.le, List.card, Eq.mpr, congrFun, congrArg, List.card_nil, Nat.zero_le, Decidable.em, Mem.mem, Eq.symm, Eq.refl]]
[commutative,[Eq]]
[Nat.coprime.pow,[Nat.coprime.pow_right, Nat.coprime.pow_left]]
[String.toName,[List.foldl, Lean.Name.mkStr, String.trim, Lean.Name.anonymous]]
[System.FilePath.normalize,[ite, Eq, and, BEq.beq, List.length, System.FilePath.pathSeparators, OfNat.ofNat, not, Bool.true, System.FilePath.mk, String.map, List.contains, System.FilePath.pathSeparator, Char.toLower, System.FilePath.toString]]
[StateCpsT.runK_bind_set,[rfl]]
[UInt8.zero_def,[rfl]]
[Option.isSome_none,[rfl]]
[String.Iterator.prev,[String.Iterator, String.Iterator.mk, String.prev]]
[Nat.coprime_one_left,[Nat.gcd_one_left]]
[AddSemigroup.noConfusionType,[]]
[List.head,[absurd, Eq.refl, List.nil]]
[USize.instSemiringUSize.proof_4,[congrArg, USize.mk, AddMonoid.nsmul_succ', USize.val]]
[List.get?_map,[Eq, List.get?, List.map, Option.map, rfl, PProd.fst]]
[instTransLtLeLt,[Trans.mk, instTransLtLeLt.proof_1]]
[exists_eq_right,[Iff.trans, exists_congr, And.comm, exists_eq_left]]
[Option.isSome,[Unit.unit, Bool, Bool.true, Bool.false]]
[Nat.mul_lt_mul,[Nat.lt_of_lt_of_le, Nat.mul_lt_mul_of_pos_right, Nat.mul_le_mul_of_nonneg_left]]
[List.length_take_le,[of_eq_true, Eq.trans, congrFun, congrArg, LE.le, List.length_take, eq_true, min_le_left, List.length]]
[Nat.coprime.coprime_dvd_right,[Nat.coprime.symm, Nat.coprime.coprime_dvd_left]]
[of_heq_true,[of_eq_true, eq_of_heq]]
[Â«term_$__Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[List.intercalate,[List.join, List.intersperse]]
[List.toChunks,[Nat.zero, List.cons, Nat.succ, List, List.nil]]
[instToBoolBool,[ToBool.mk]]
[List.toArrayAux,[Array, PProd.fst, Array.push]]
[System.Platform.isOSX,[System.Platform.getIsOSX, Unit.unit]]
[coeTrans,[CoeTC.mk, coeB, coeTC]]
[EST,[EStateM]]
[List.get_set_eq,[Eq.mpr, Eq.refl, Eq, List.get, List.set, Eq.symm, propext, Option.some_inj, Option.some, List.get?_eq_get, List.get?, List.get?_set_eq, Functor.map, of_eq_true, eq_true, Eq.mp, congrArg, LT.lt, List.length_set, Eq.trans, congrFun, Option.map_eq_map, Option.map_some', eq_self]]
[Subrelation.wf,[Subrelation.wf.proof_1]]
[Nat.mod_lt,[Nat.mod.inductionOn]]
[instToStringByteArray,[ToString.mk, List.toString, ByteArray.toList]]
[Subset.noConfusionType,[]]
[PSum.inl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Char.utf8Size,[ite, LE.le, UInt32.ofNatCore, OfNat.ofNat, Char.utf8Size.proof_1, Char.utf8Size.proof_2, Char.utf8Size.proof_3, Char.utf8Size.proof_4, Char.utf8Size.proof_5, Char.utf8Size.proof_6, Char.utf8Size.proof_7]]
[Function.right_inverse_inv_fun,[Function.inv_fun_eq]]
[randNat,[Prod, Nat, Prod.mk]]
[Quotient,[Quot, Setoid.r]]
[String.Range.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, String.Range.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Float.ofBinaryScientific,[Float.scaleB, UInt64.toFloat]]
[not_or_intro,[False, absurd]]
[Int.instCommRingInt.proof_6,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Int.ofNat, Nat.succ, HAdd.hAdd, Int.ofNat_succ, OfNat.ofNat, Int.distrib_right, Int.add_comm, Int.one_mul, rfl]]
[EmptyCollection.emptyCollection,[]]
[List.bind,[List.join, List.map]]
[Option.mem_def,[Iff.rfl]]
[DivInvMonoid.toMonoid,[]]
[UInt8.div,[UInt8.mk, HDiv.hDiv, UInt8.val]]
[BinaryHeap.heapifyUp,[WellFounded.fix, dite, Eq, Fin.val, OfNat.ofNat, Subtype.mk, rfl, PSigma.mk]]
[List.insert_of_not_mem,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, if_neg, List, List.cons, eq_self]]
[ByteArray.toUInt64BE!,[ite, Eq, BEq.beq, ByteArray.size, OfNat.ofNat, Bool.true, HOr.hOr, HShiftLeft.hShiftLeft, UInt8.toUInt64, ByteArray.get!, panicWithPosWithDecl, HAppend.hAppend]]
[Fin.instOfNatFinHAdd,[OfNat.mk, Fin.ofNat]]
[Mathlib.Tactic.Ext.Â«termExt_iff_proof%Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[USize.mod_def,[rfl]]
[instCommSemiring,[CommSemiring.mk, CommRing.mul_comm]]
[min_eq_left,[Eq.symm, eq_min, le_refl]]
[Array.insertionSort.swapLoop.proof_1,[Nat.lt_trans, Nat.lt_succ_self, Eq.symm]]
[Array.foldrM.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure]]
[UInt32.mk_val_eq,[Eq, UInt32.mk, UInt32.val, rfl]]
[ToString.toString,[]]
[Tactic.Ring.subst_into_mul,[Eq.mpr, Eq.refl, Eq, HMul.hMul, rfl]]
[USize.instSemiringUSize.proof_12,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HMul.hMul, USize.add_def, USize.mul_def, USize.mk, HAdd.hAdd, USize.val, USize.eq_of_val_eq, Semiring.add_mul]]
[Thunk.pure,[Thunk.mk]]
[List.hasDecEq.proof_6,[absurd]]
[System.SearchPath.separator,[ite, Eq, System.Platform.isWindows, Bool.true, Char.ofNat]]
[Fin.mod_def,[Eq, HMod.hMod, Fin.mk, Fin.val, Nat.mod_lt, Fin.size_positive, rfl]]
[Nat.case_strong_rec_on,[Nat.strong_rec_on, Nat.lt_succ_of_le]]
[MonadExceptOf.throw,[]]
[Equiv.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[StateT.run_modifyGet,[of_eq_true, eq_self, Pure.pure]]
[Array.feraseIdx,[Array.eraseIdxAux, HAdd.hAdd, Fin.val, OfNat.ofNat]]
[Function.right_inverse.comp_eq_id,[funext]]
[Nat.dvd_mod_iff,[Eq.mp, Eq.refl, Iff, Dvd.dvd, HMod.hMod, HAdd.hAdd, HMul.hMul, HDiv.hDiv, Nat.mod_add_div]]
[Nat.gcd_dvd_gcd_mul_left_right,[Nat.gcd_dvd_gcd_of_dvd_right, Nat.dvd_mul_left]]
[Ne.symm,[Eq.symm]]
[Â«tacticÂ·.__;_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[ExceptCpsT.runCatch_throw,[rfl]]
[Bool.and_false,[rfl, Eq.symm, Eq.refl]]
[stx!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Subtype.ext_iff_val,[Subtype.ext_iff]]
[Nat.lt_eq,[rfl]]
[Nat.add_succ,[rfl]]
[Nat.not_succ_le_self,[Unit.unit, Not, LE.le, Nat.succ, Nat.not_succ_le_zero, OfNat.ofNat, absurd, Nat.le_of_succ_le_succ, PProd.fst]]
[if_ctx_congr_prop,[Iff, ite, absurd, Iff.mp, not_iff_not_of_iff, Iff.mpr]]
[Mathlib.Tactic.Conv.convRHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.Conv.convSeq]]
[List.forall_mem_append,[Eq.mpr, congrFun, congrArg, Iff, Eq.trans, forall_congr, implies_congr, propext, List.mem_append, Eq.refl, or_imp_distrib, forall_and_distrib, And, Iff.rfl]]
[instHMul,[HMul.mk, Mul.mul]]
[Int.eq_one_of_mul_eq_self_left,[Int.eq_of_mul_eq_mul_right, Eq.mpr, Eq.refl, Eq, HMul.hMul, OfNat.ofNat, Int.one_mul, rfl]]
[Nat.forM.loop,[Unit.unit, Unit, Pure.pure, Bind.bind, HSub.hSub, OfNat.ofNat, PProd.fst]]
[Nat.coprime.dvd_of_dvd_mul_left,[Nat.coprime.dvd_of_dvd_mul_right, Eq.mp, Eq.refl, Dvd.dvd, HMul.hMul, Nat.mul_comm]]
[leOfOrd,[LE.mk, Eq, Ordering.isLE, Ord.compare, Bool.true]]
[ulift.noConfusionType,[]]
[Int.neg_le_of_neg_le,[]]
[Array.concatMapM,[Array.foldlM, Bind.bind, Pure.pure, HAppend.hAppend, Array.empty, OfNat.ofNat, Array.size]]
[Function.injective_surj_inv,[Function.right_inverse.injective, Function.right_inverse_surj_inv]]
[prioDefault,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Task.pure.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.toUInt32,[UInt32.ofNat]]
[Mathlib.ExtendedBinder.extBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Mathlib.ExtendedBinder.extBinder, Mathlib.ExtendedBinder.extBinderCollection]]
[coe,[CoeT.coe]]
[PSigma.mkSkipLeft.proof_1,[PSigma.RevLex.right]]
[List.length_repeat,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.length_nil, Nat.zero_eq, eq_true_of_decide, Eq.refl, Bool.true, congrFun, List.length_cons, Nat.succ, eq_self]]
[Option.noConfusionType,[]]
[USize.eq_of_val_eq,[Eq, congrArg, USize.mk]]
[STWorld.noConfusionType,[]]
[List.length_mapâ‚‚,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.length_nil, min, min_self, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true, Eq.symm, List.length_cons, Nat.zero_min, Nat.succ, List.length, Nat.min_zero, Nat.min_succ_succ, eq_self]]
[Semiring.noConfusionType,[]]
[Subtype.eq,[Eq.symm, eq_of_heq, Eq.refl, Subtype.val, Subtype.mk, HEq.refl, Eq, rfl]]
[StateCpsT.lift,[Bind.bind]]
[AddCommSemigroup.toAddSemigroup,[]]
[OptionT.run,[]]
[OptionT.orElse,[OptionT.mk, Bind.bind, Option.none, Option, Pure.pure, Option.some, Unit.unit]]
[Option.get_mem,[Eq.refl, Bool.true, HEq.refl, Mem.mem, Option.get, rfl]]
[ByteArray.findIdx?,[ByteArray.findIdx?.loop]]
[Nat.all,[not, Nat.any]]
[USize.instAddCommSemigroupUSize,[AddCommSemigroup.mk, USize.instAddCommSemigroupUSize.proof_1]]
[StateT.instAlternativeStateT,[Alternative.mk, StateT.failure, StateT.orElse]]
[instReprNat,[Repr.mk, Std.Format.text, Nat.repr]]
[Quotient.recOnSubsingletonâ‚‚.proof_2,[]]
[calcStep,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.symbol]]
[precLead,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Function.bijective.of_comp_iff,[and_congr, Function.injective.of_comp_iff', Function.surjective.of_comp_iff, Function.bijective.surjective]]
[Mathlib.Tactic.Lint.getLinters,[List.mapM, Mathlib.Tactic.Lint.getLinter]]
[Â«term_â»Â¹Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[or_true,[propext, Iff.intro, trivial, Or.inr]]
[WellFoundedRelation.mk.injEq,[Eq.propIntro, Eq.refl, WellFoundedRelation.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.dvd_sub,[Iff.mpr, Nat.dvd_add_iff_left, Eq.mpr, Eq.refl, Dvd.dvd, HAdd.hAdd, HSub.hSub, Nat.sub_add_cancel]]
[instXorUInt16,[Xor.mk, UInt16.xor]]
[List.mem_singleton,[Iff.intro, List.eq_of_mem_singleton, Or.inl]]
[ReaderT.bind,[Bind.bind]]
[UInt32.mod,[UInt32.mk, HMod.hMod, UInt32.val]]
[instMonadControlOptionT,[MonadControl.mk, Option, liftM, OptionT.run]]
[List.modifyNth_eq_set,[Eq, List.modifyNth, Option.getD, Functor.map, List.set, List.get?, rfl, Eq.symm, Eq.refl, Eq.trans, congr_arg, List.cons, PProd.fst]]
[Int.natAbs_of_nonneg,[Eq.symm, eq_of_heq, Eq.refl, Int.ofNat, HEq.refl, Eq, Int.natAbs, Int.eq_ofNat_of_zero_le, rfl]]
[Unit,[PUnit]]
[Mathlib.ExtendedBinder.Â«termâˆƒ__,_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.binderIdent, Lean.ParserDescr.cat]]
[ExceptCpsT.run_pure,[rfl]]
[List.reverseAux_reverseAux_nil,[rfl, of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.cons, List.reverseAux, eq_self]]
[Int.fmod,[Int.ofNat, Int.negSucc, Nat.succ, Int, OfNat.ofNat, HMod.hMod, Int.subNatNat, Neg.neg]]
[Prod.foldI,[Nat.foldAux, Prod.snd, HSub.hSub, Prod.fst]]
[Int.negSucc_ofNat_add_negSucc_ofNat,[rfl]]
[List.get_singleton,[]]
[instCoeDep,[CoeDep.mk, coeFun]]
[AddGroup.toSubNegMonoid,[]]
[Set.image,[setOf, Exists, And, Mem.mem, Eq]]
[Nat.le_step,[Nat.le.step]]
[Coe.noConfusionType,[]]
[or_self,[propext, Iff.intro, Or.inl]]
[instLawfulMonadStateRefT',[instLawfulMonadStateRefT'.proof_1]]
[BaseIO.mapTasks,[List.nil, BaseIO.mapTasks.go]]
[Fin.mul,[Fin, Fin.mk, HMod.hMod, HMul.hMul, Fin.mul.proof_1]]
[Â«term_âˆˆ_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[String.isNat,[String.all, Char.isDigit]]
[instToStringFloatArray,[ToString.mk, List.toString, FloatArray.toList]]
[Thunk.get,[Unit.unit]]
[Function.Â«termâ†¿_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[USize.ofNat,[USize.mk, Fin.ofNat', usize_size_gt_zero]]
[List.length_removeNth,[Eq, List.length, List.removeNth, HSub.hSub, OfNat.ofNat, rfl, Eq.mpr, congrArg, congrFun, List.length_cons]]
[ptrAddrUnsafe,[OfNat.ofNat]]
[Equiv.symm_apply_apply,[Equiv.leftInv]]
[instToStringSubstring,[ToString.mk, Substring.toString]]
[Nat.gcd_rec,[Unit.unit, Eq, Nat.gcd, HMod.hMod, of_eq_true, Eq.trans, congrFun, congrArg, Nat.gcd_succ, HAdd.hAdd, OfNat.ofNat, eq_self, Nat.succ]]
[peirce,[Decidable.peirce]]
[UInt8.instAddCommSemigroupUInt8,[AddCommSemigroup.mk, UInt8.instAddCommSemigroupUInt8.proof_1]]
[Â«term{}Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol]]
[USize.toNat,[Fin.val, USize.val]]
[LawfulFunctor.comp_map,[]]
[Subrelation.accessible,[Subrelation.accessible.proof_1]]
[List.mem_append_eq,[propext, List.mem_append]]
[Nat.Up.WF,[Subrelation.wf, WellFoundedRelation.rel, measure, HSub.hSub, Nat.sub_lt_sub_left, WellFoundedRelation.wf]]
[Nat.exists_coprime',[Exists, And, LT.lt, OfNat.ofNat, Nat.coprime, Eq, HMul.hMul, Exists.intro, Nat.gcd, And.intro]]
[Int.exists_eq_neg_ofNat,[Exists, Eq, Neg.neg, Int.ofNat, Exists.intro, Int.eq_neg_of_eq_neg, Eq.symm]]
[IsMulRightCancel.mul_right_cancel,[]]
[UInt64.val_eq_of_lt,[Fin.val_eq_of_lt]]
[Function.injective.ne_iff',[Function.injective.ne_iff]]
[instOrdUInt16,[Ord.mk, compareOfLessAndEq]]
[List.append_inj,[And, Eq, And.intro, rfl, List.eq_nil_of_length_eq_zero, Eq.symm, List.cons, Eq.mpr, Eq.refl]]
[coeFun,[CoeFun.coe]]
[instLTFloat,[LT.mk, Float.lt]]
[Nat.eq_zero_of_gcd_eq_zero_right,[Nat.eq_zero_of_gcd_eq_zero_left, Eq.mp, Eq.refl, Eq, Nat.gcd, OfNat.ofNat, Nat.gcd_comm]]
[of_decide_eq_true,[absurd, ne_true_of_eq_false, decide_eq_false]]
[Fin.sub,[Fin, Fin.mk, HMod.hMod, HAdd.hAdd, HSub.hSub, Fin.sub.proof_1]]
[List.sublist.brecOn,[List.sublist.below.slnil, List.sublist.below.cons, List.sublist.below.cons2]]
[let_eq,[]]
[List.ilast',[PProd.fst]]
[Nat.coprime.eq_one_of_dvd,[Eq.mpr, Eq.refl, Eq, OfNat.ofNat, Eq.symm, Nat.coprime.gcd_eq_one, Nat.gcd, Nat.gcd_eq_left, rfl]]
[instTransLeLtLt,[Trans.mk, instTransLeLtLt.proof_1]]
[List.toStringAux,[Bool.false, Bool.true, String, HAppend.hAppend, ToString.toString, PProd.fst]]
[Sdiff.noConfusionType,[]]
[Int.ofNat_mul,[rfl]]
[ulift.up.inj,[]]
[if_true,[if_pos, trivial]]
[coeTC,[CoeTC.coe]]
[Int.toNat_sub,[rfl]]
[instAddCommGroup.proof_1,[Semiring.add_zero]]
[Function.injective.decidable_eq,[decidable_of_iff, Eq, Function.injective.eq_iff]]
[List.hasDecEq.proof_4,[rfl]]
[instAddCommSemigroupFin,[AddCommSemigroup.mk, instAddCommSemigroupFin.proof_1]]
[List.mem_iff_get,[Iff.intro, List.get_of_mem, Mem.mem, List.get_mem]]
[Array.appendList,[List.foldl, Array.push]]
[lt_of_le_not_le,[LT.lt, Iff.mpr, lt_iff_le_not_le, And.intro]]
[DivInvMonoid.gpow_succ',[]]
[List.zipWithâ‚…,[List.nil, List.cons, List, PProd.fst]]
[StateT.run,[]]
[Int.eq_zero_or_eq_zero_of_mul_eq_zero,[Or, Eq, OfNat.ofNat, lt_trichotomy, Or.inr, Eq.symm, Or.inl]]
[FloatSpec.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, FloatSpec.mk, Eq.symm, eq_of_heq, DecidableRel, HEq.refl]]
[ne_true_of_eq_false,[Not, Eq, Bool.true]]
[Nat.isValidChar,[Or, LT.lt, OfNat.ofNat, And]]
[List.findM?,[Unit.unit, Option, Pure.pure, Option.none, Bind.bind, Option.some, PProd.fst]]
[instSubUInt64,[Sub.mk, UInt64.sub]]
[not_and_of_not_or_not,[False, Or.elim, absurd]]
[UInt16.instInhabitedFinSize,[Inhabited.mk, Fin.ofNat', OfNat.ofNat, UInt16.size_positive]]
[Acc.inv,[Acc.inv.proof_1]]
[BinaryHeap.insert,[BinaryHeap.mk, Subtype.val, BinaryHeap.heapifyUp, Array.push, BinaryHeap.arr, Fin.mk, BinaryHeap.insert.proof_1]]
[BinaryHeap.insertExtractMax.proof_1,[Eq.refl, BinaryHeap.max]]
[Int.natAbs_mul_self,[Eq, Int.ofNat, HMul.hMul, Int.natAbs, rfl]]
[instStreamSubarray.proof_1,[Nat.succ_le_of_lt]]
[iff_true_right,[Iff.trans, Iff.comm, iff_true_left]]
[instToStreamListList,[ToStream.mk]]
[toBoolUsing,[Decidable.decide]]
[List.tail_eq_of_cons_eq,[]]
[instDecidableEq,[Decidable, Eq, Decidable.isTrue, propext, Decidable.isFalse, instDecidableEq.proof_1]]
[Int.lt.dest,[Exists.imp, Eq.mp, Eq.refl, Eq, HAdd.hAdd, Int.ofNat, OfNat.ofNat, Int.add_left_comm, Int.add_comm, Int.le.dest]]
[usize_size_gt_zero,[Nat.pos_pow_of_pos, System.Platform.numBits, Nat.zero_lt_succ, OfNat.ofNat]]
[Nat.lt_of_lt_of_eq,[]]
[List.not_mem_append,[mt, Iff.mp, List.mem_append, Iff.mpr, not_or, Mem.mem, And.intro]]
[Function.injective,[Eq]]
[Subsingleton.helim.proof_1,[heq_of_eq, Subsingleton.elim]]
[instDecidableLe,[UInt32.decLe]]
[Char.isAlpha,[or, Char.isUpper, Char.isLower]]
[mul_left_comm,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Eq.symm, mul_assoc, mul_comm, rfl]]
[Option.map,[Option.bind, Function.comp, Option.some]]
[ne_false_of_self,[]]
[Substring.toNat?,[ite, Eq, Substring.isNat, Bool.true, Option.some, Substring.foldl, HAdd.hAdd, HMul.hMul, OfNat.ofNat, HSub.hSub, Char.toNat, Char.ofNat, Option.none]]
[List.insert_equiv_cons,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, List.mem_insert_iff, List.mem_cons, iff_self, Or, Eq, Mem.mem]]
[Subtype.instDecidableEqSubtype.proof_2,[absurd]]
[Fin.div,[Fin, Fin.mk, HMod.hMod, HDiv.hDiv, Fin.div.proof_1]]
[List.ne_nil_of_mem,[False, Eq.mp, Eq.refl, Mem.mem]]
[Nat.div_lt_iff_lt_mul,[Eq.mpr, Eq.refl, Iff, LT.lt, HDiv.hDiv, HMul.hMul, Eq.symm, propext, not_le, Not, LE.le, not_congr, Nat.le_div_iff_mul_le]]
[Nat.lt_asymm,[Nat.le_lt_antisymm, Nat.le_of_lt]]
[max_le,[dite, LT.lt, Eq.mpr, congrFun, congrArg, LE.le, if_pos, if_neg]]
[not_of_iff_false,[Iff.mp]]
[List.span,[List.spanAux, List.nil]]
[DoResultPRBC.return.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Â«term_<_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[List.rotateLeft,[ite, LE.le, OfNat.ofNat, HAppend.hAppend]]
[PNonScalar.noConfusionType,[]]
[Option.none_bind,[rfl]]
[List.length_insert_of_not_mem,[Eq.mpr, Eq.refl, Eq, List.length, List.insert, HAdd.hAdd, OfNat.ofNat, List.insert_of_not_mem, rfl]]
[instLTUInt16,[LT.mk, UInt16.lt]]
[or_iff_not_and_not,[Decidable.or_iff_not_and_not]]
[Mathlib.Tactic.Lint.sortResults,[Bind.bind, ForIn.forIn, Lean.Core.CoreM, ForInStep, Std.HashMap, Lean.Name, Nat, Lean.findDeclarationRanges?, Option.none, Pure.pure, PUnit.unit, ForInStep.yield, Array.qsort, Std.HashMap.toArray, Bool, Decidable.decide, LT.lt, Std.HashMap.findD, OfNat.ofNat, HSub.hSub, Array.size]]
[List.lookmap,[Unit.unit, List, List.nil, List.cons, PProd.fst]]
[tacticRwa__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.Parser.Tactic.location]]
[instDecidableEqSum.proof_2,[absurd]]
[Int.le_def,[Iff.refl, LE.le]]
[List.Â«term_<:+:_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Functor.noConfusionType,[]]
[Int.sign_eq_one_of_pos,[Eq.symm, eq_of_heq, Eq.refl, Int.ofNat, Nat.succ, HEq.refl, Eq, Int.sign, OfNat.ofNat, Int.eq_succ_of_zero_lt, rfl]]
[ToBool.noConfusionType,[]]
[PSum.inl.inj,[]]
[Array.findSomeRevM?,[Array.size, Nat.le_refl, Array.findSomeRevM?.find]]
[ByteArray.foldlM.loop.proof_1,[Nat.lt_of_lt_of_le]]
[System.FilePath.mk.inj,[]]
[BaseIO.toIO,[liftM]]
[FloatArray.foldlM,[dite, LE.le, FloatArray.size, FloatArray.foldlM.proof_1]]
[Semiring.one_mul,[]]
[LawfulApplicative.seqRight_eq,[]]
[SubNegMonoid.toAddMonoid,[]]
[eq_true_of_ne_false,[Eq, Bool.true, rfl, False.elim]]
[plift.up_down,[Eq, plift.up, plift.down, rfl]]
[instDecidableXor.proof_1,[False]]
[String.instLTString,[LT.mk, LT.lt, String.data]]
[List.exists_mem_of_length_pos,[Exists, Mem.mem, Eq.refl, List.length, List.nil, HEq.refl, Exists.intro, List.mem_cons_self]]
[Nat.succ_eq_one_add,[Eq.mpr, Eq.refl, Eq, Nat.succ, HAdd.hAdd, OfNat.ofNat, Nat.succ_eq_add_one, Nat.add_comm, rfl]]
[Fin.ofNat.proof_1,[Nat.mod_lt, Nat.zero_lt_succ]]
[List.append_ne_nil_of_ne_nil_right,[of_eq_true, Eq.trans, implies_congr_ctx, ne_eq, List.nil, HAppend.hAppend, congrArg, Not, propext, List.append_eq_nil, And, Eq, eq_false, and_false, eq_true_of_decide, Eq.refl, Bool.true, implies_true]]
[Nat.lt_of_le_of_lt,[Nat.le_trans, Nat.succ_le_succ]]
[Substring.trimRight,[Substring.dropRightWhile, Char.isWhitespace]]
[Function.involutive.right_inverse,[]]
[MProd.fst,[]]
[Nat.mod_one,[]]
[Int.instHPowIntNatInt,[HPow.mk, Int.pow]]
[List.findSomeM?,[Unit.unit, Option, Pure.pure, Option.none, Bind.bind, Option.some, PProd.fst]]
[MonadStateOf.set,[]]
[ExceptCpsT.instMonadLiftExceptCpsT,[MonadLift.mk, ExceptCpsT.lift]]
[List.card_eq_of_equiv,[Nat.le_antisymm, List.card_subset_le, And.left, And.right]]
[instReprAtomUInt64,[ReprAtom.mk]]
[Array.extract,[Array.ofSubarray, Array.toSubarray]]
[Nat.pow_le_pow_of_le_right,[LE.le, HPow.hPow, Nat.succ, Nat.lt_or_eq_or_le_succ, Nat.le_refl, Eq.symm]]
[xor_comm,[of_eq_true, Eq.trans, congrArg, Eq, Or, And, Not, propext, or_comm, eq_self]]
[Nat.le_of_succ_le_succ,[Nat.pred_le_pred]]
[Char.isDigit,[and, Decidable.decide, GE.ge, Char.val, OfNat.ofNat, LE.le]]
[List.append_ne_nil_of_left_ne_nil,[of_eq_true, Eq.trans, ne_eq, HAppend.hAppend, List.nil, congrArg, Not, propext, List.append_eq_nil, congrFun, And, eq_false, Eq, false_and, eq_true_of_decide, Eq.refl, Bool.true]]
[Prod.map_map,[of_eq_true, Eq.trans, congr, congrArg, Eq, Prod.map, prod_map, Prod.mk, Prod.fst, Prod.snd, Function.comp, Function.comp_apply, eq_self]]
[instLEFin,[LE.mk, LE.le, Fin.val]]
[Function.curry_uncurry,[rfl]]
[Â«term_++_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[BinaryHeap.mkHeap.loop,[Subtype, Eq, Array.size, Subtype.mk, BinaryHeap.mkHeap.loop.proof_1, BinaryHeap.mkHeap.loop.proof_4]]
[And.imp_right,[And.imp, id]]
[instReprString,[Repr.mk, Std.Format.text, String.quote]]
[ST.Ref.take,[liftM, ST.Prim.Ref.take]]
[Array.mapSepElems,[Id.run, Array.mapSepElemsM]]
[Iff.elim_right,[Iff.elim_right.proof_1]]
[String.mapTokens,[Function.comp, String.intercalate, String.singleton, List.map, String.split, Decidable.decide, Eq]]
[Substring.posOf,[String.Pos, HSub.hSub, String.posOfAux]]
[Nat.succ_sub_succ,[Nat.succ_sub_succ_eq_sub]]
[Nat.fold,[Nat.foldAux]]
[Nat.foldM,[Nat.foldM.loop]]
[Fin.decLt,[Nat.decLt, Fin.val]]
[bfix2,[PProd.fst]]
[UInt32.size_positive,[of_decide_eq_true, Eq.refl, Bool.true]]
[UInt64.instSemiringUInt64.proof_10,[rfl]]
[instMonadReaderOfReaderT,[MonadReaderOf.mk, ReaderT.read]]
[ite_false,[rfl]]
[Nat.add_mul_mod_self_left,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, HMul.hMul, Nat.zero, Nat.mul_zero, OfNat.ofNat, Nat.add_zero, rfl, Nat.succ, Nat.mul_succ, Eq.symm, Nat.add_assoc, Nat.add_mod_right]]
[Int.decEq.proof_6,[]]
[Option.mgetD,[Option.melim, Pure.pure]]
[Char.isValidChar_zero,[Or.inl, of_decide_eq_true, Eq.refl, Bool.true]]
[Tactic.Ring.State.mk.inj,[And.intro]]
[Fin.gt_wf,[Subrelation.wf, And.intro, Fin.isLt, WellFoundedRelation.wf, invImage, Fin.val, Nat.upRel]]
[Nat.dvd_lcm_left,[Exists.intro, HDiv.hDiv, Nat.gcd, Eq.mpr, Eq.refl, Eq, Nat.lcm, HMul.hMul, Eq.symm, Nat.mul_div_assoc, Nat.gcd_dvd_right, rfl]]
[Complement.complement,[]]
[List.append_inj_left',[And.left, List.append_inj']]
[List.disjoint_of_disjoint_append_left_left,[And.left, Iff.mp, List.disjoint_append_left]]
[List.takeWhile,[Unit.unit, List, List.nil, List.cons, PProd.fst]]
[unexpandPSigma,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[UInt32.mul,[UInt32.mk, HMul.hMul, UInt32.val]]
[PSigma.revLex.proof_1,[WellFounded.intro, Acc, PSigma.RevLex, PSigma.revLexAccessible, WellFounded.apply]]
[decEq,[]]
[List.card_nil,[rfl]]
[inline,[]]
[Decidable.iff_not_comm,[Eq.mpr, Eq.refl, Iff, Not, propext, iff_def, And, and_congr, imp_not_comm, Decidable.not_imp_comm]]
[instMonadControlT_1,[MonadControlT.mk, Pure.pure]]
[UInt64.instRingUInt64.proof_1,[congrArg, UInt64.mk, Ring.sub_eq_add_neg, UInt64.val]]
[List.inits,[Unit.unit, List, List.cons, List.nil, List.map, PProd.fst]]
[UInt64.shiftLeft,[UInt64.mk, HShiftLeft.hShiftLeft, UInt64.val, UInt64.modn, OfNat.ofNat]]
[Int.neg_add_le_right_of_le_add,[Int.neg_add_le_left_of_le_add, Eq.mp, Eq.refl, LE.le, HAdd.hAdd, Int.add_comm]]
[instOrdUInt32,[Ord.mk, compareOfLessAndEq]]
[AddMonoid.nsmul,[]]
[List.disjoint_comm,[Iff.intro, List.disjoint_symm]]
[Function.surjective,[Exists, Eq]]
[List.get_of_mem,[List.nil, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Exists, Eq, List.get, Exists.intro, OfNat.ofNat, Nat.succ_pos, List.length, rfl, List.cons, HAdd.hAdd, Nat.succ_lt_succ]]
[Equiv.rightInv,[]]
[Fin.eq_of_val_eq,[Eq.symm, eq_of_heq, Eq.refl, Fin.val, Fin.mk, HEq.refl, Eq, rfl]]
[ST.Prim.Ref.modifyGetUnsafe,[Bind.bind, ST.Prim.Ref.take, ST, ST.Prim.Ref.set, Pure.pure]]
[Substring.trim,[Substring, Substring.mk]]
[Tactic.Ring.State.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[ite_id,[rfl, Eq.symm, Eq.refl]]
[HMod.hMod,[]]
[Decidable.not_imp_symm,[Decidable.by_contradiction, Function.comp]]
[System.SearchPath.parse,[List.map, System.FilePath.mk, String.split, BEq.beq, System.SearchPath.separator]]
[instDecidableIff.proof_2,[Iff.mp]]
[List.get_set_ne,[Eq.mpr, Eq.refl, Eq, List.get, List.set, Eq.mp, congrArg, LT.lt, List.length_set, Eq.symm, propext, Option.some_inj, Option.some, List.get?_eq_get, List.get?, List.get?_set_ne, rfl]]
[PSum.inr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[decidableEq_of_decidableLe.proof_2,[le_refl]]
[if_ctx_congr,[Eq, ite, absurd, Iff.mp, not_iff_not_of_iff, Iff.mpr]]
[Â«term_<<<_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[ne_iff_lt_or_gt,[Iff.intro, lt_or_gt_of_ne, Ne, ne_of_lt, ne_of_gt]]
[Tactic.Ring.instInhabitedHornerExpr,[Inhabited.mk, Tactic.Ring.HornerExpr.const, Lean.mkRawNatLit, OfNat.ofNat]]
[Nat.sub_lt_of_pos_le,[Nat.sub_lt, lt_of_lt_of_le]]
[UInt16.instSemiringUInt16.proof_11,[Eq.mpr, congr, congrArg, Eq, Eq.trans, HMul.hMul, UInt16.add_def, UInt16.mul_def, UInt16.mk, HAdd.hAdd, UInt16.val, UInt16.eq_of_val_eq, Semiring.mul_add]]
[Subarray.forInUnsafe.loop,[ite, LT.lt, Bind.bind, Pure.pure, Subarray.forInUnsafe.loop, HAdd.hAdd, OfNat.ofNat]]
[instDecidableLe_3,[UInt64.decLe]]
[fixCore4,[bfix4, USize.size]]
[Option.decidable_eq_none,[decidableOfDecidableOfIff, instDecidableEqBool, Option.isNone, Bool.true, Option.isNone_iff_eq_none]]
[Sum.inhabitedRight,[Inhabited.mk, Sum.inr, arbitrary]]
[Empty.elim,[sorryAx, Bool.true]]
[Nat.mul_div_right,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HDiv.hDiv, HMul.hMul, Nat.zero_eq, Nat.mul_zero, Nat.zero_div, eq_true_of_decide, Eq.refl, Bool.true, Nat.mul_succ, Nat.add_div_right, eq_true, Nat.succ, eq_self]]
[And.right_comm,[Eq.mpr, congr, congrArg, Iff, Eq.trans, propext, and_comm, And, And.left_comm, Iff.rfl]]
[AddCommGroup.toAddGroup,[]]
[Substring.isNat,[Substring.all, Char.isDigit]]
[Function.involutive.bijective,[And.intro, Function.involutive.injective, Function.involutive.surjective]]
[ExceptCpsT.instMonadExceptCpsT,[Monad.mk]]
[List.filterRevM,[List.filterAuxM, List.reverse, List.nil]]
[Decidable.decide,[Bool.false, Bool.true]]
[ByteSliceT.getOp,[ByteArray.get!, ByteSliceT.arr, HAdd.hAdd, ByteSliceT.off]]
[Int.sign_eq_one_iff_pos,[Iff.intro, Int.pos_of_sign_eq_one, Int.sign_eq_one_of_pos]]
[Decidable.not_not,[Iff.intro, Decidable.by_contradiction, not_not_intro]]
[String.splitOn,[ite, Eq, BEq.beq, Bool.true, List.cons, List.nil, String.splitOnAux, OfNat.ofNat]]
[Nat.pos_iff_ne_zero,[Iff.intro, absurd, of_decide_eq_false, Eq.refl, Decidable.decide, LT.lt, OfNat.ofNat, Nat.zero, Eq.symm, Nat.succ_ne_zero, Nat.pos_of_ne_zero]]
[Task.Priority.dedicated,[OfNat.ofNat]]
[List.toFloatArray,[FloatArray.empty, List.toFloatArray.loop]]
[instInhabitedArrow_1,[Inhabited.mk, Pure.pure]]
[instHashableProd,[Hashable.mk, UInt64, mixHash, Hashable.hash]]
[instDecidableEqProd.proof_1,[rfl]]
[le_of_eq_or_lt,[LE.le, le_of_eq, le_of_lt]]
[Mathlib.Eval.evalTerm,[Bind.bind, Lean.Elab.Term.elabTermEnsuringType, Option.some, Bool.true, Option.none, Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing, Bool.false, liftM, Lean.Meta.instantiateMVars, Lean.Meta.getMVars, Lean.Elab.Term.logUnassignedUsingErrorInfos, ite, Eq, Lean.Elab.throwAbortTerm, Pure.pure, PUnit.unit]]
[Tactic.Ring.horner_add_horner_eq,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Tactic.Ring.horner, Eq.symm, of_eq_true, Eq.trans, congr, congrArg, add_comm, HMul.hMul, HPow.hPow, add_assoc, congrFun, add_mul, eq_self]]
[command_Lemma___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[Int.neg_add_le_left_of_le_add,[Eq.mpr, Eq.refl, LE.le, HAdd.hAdd, Neg.neg, Int.add_comm, Int.sub_left_le_of_le_add]]
[Char.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.mod_eq_sub_mod,[Eq, HMod.hMod, HSub.hSub, Nat.eq_zero_or_pos, rfl, Eq.symm, Nat.sub_zero, if_pos, And.intro, Nat.mod_eq]]
[ne_of_gt,[absurd, lt_irrefl]]
[Substring.noConfusionType,[]]
[dbgTraceIfShared,[]]
[Iff.elim_left,[Iff.elim_left.proof_1]]
[instDecidableLe_4,[USize.decLe]]
[Int.sub_lt_self,[Trans.trans, Int.add_lt_add_left, Int.neg_neg_of_pos, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, OfNat.ofNat, Int.add_zero, rfl]]
[instSubUInt8,[Sub.mk, UInt8.sub]]
[not_not_em,[Or.inr, Or.inl]]
[Eq.symm,[rfl]]
[instAndOpUSize,[AndOp.mk, USize.land]]
[List.eq_of_mem_repeat,[And.right, Iff.mp, List.mem_repeat]]
[List.findSome?,[Unit.unit, Option, Option.none, Option.some, PProd.fst]]
[Tactic.Ring.HornerExpr.isZero,[Tactic.Ring.HornerExpr.xadd, Bool, Decidable.decide, Eq, OfNat.ofNat, Bool.false]]
[List.mem_of_mem_cons_of_mem,[Or.elim, List.eq_or_mem_of_mem_cons, Eq.symm]]
[UInt16.instSemiringUInt16.proof_13,[UInt16.eq_of_val_eq, Eq.mpr, congrArg, Eq, Fin.ofNat', HAdd.hAdd, OfNat.ofNat, Fin.size_positive', UInt16.val, Eq.trans, UInt16.mk, UInt16.one_def, UInt16.add_def]]
[Nat.lt_of_not_le,[Or.resolve_right, Nat.lt_or_ge]]
[List.disjoint_iff_ne,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, List.disjoint_left, forall_congr, implies_congr, Eq.refl, Mem.mem, ne_eq, imp_not_comm, forall_eq', iff_self, Not]]
[String.Range.mk.inj,[And.intro]]
[not_false_iff,[iff_true_intro, not_false]]
[Set.subset,[Mem.mem]]
[Nat.not_lt_of_le,[Nat.not_le_of_gt]]
[ExistsUnique.intro,[Exists.intro, And.intro]]
[List.get_zero,[Eq.refl, List.length, List.nil, HEq.refl, Eq.symm, of_eq_true, eq_self, Option.some]]
[AddMonoid.nsmul_succ',[]]
[List.instDecidableMem.proof_2,[Or.inr]]
[termSudoSet_option___In_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[ExceptCpsT.run_bind_lift,[rfl]]
[ByteSliceT.toSlice,[ByteSlice, ByteSlice.mk, HSub.hSub, ByteArray.size]]
[Mathlib.Tactic.Lint.printWarning,[Bind.bind, Lean.mkConstWithLevelParams, Pure.pure, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[EStateM.fromStateM,[EStateM.Result, StateT.run, EStateM.Result.ok]]
[instSubUInt32,[Sub.mk, UInt32.sub]]
[Nat.dvd_of_mul_dvd_mul_right,[Nat.dvd_of_mul_dvd_mul_left, Eq.mp, Eq.refl, Dvd.dvd, HMul.hMul, Nat.mul_comm]]
[ByteArray.forIn.loop.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self]]
[Ne.def,[rfl]]
[bne,[not, BEq.beq]]
[instOrdBool,[Ord.mk, Bool.false, Unit.unit, Bool.true, Ordering, Ordering.lt, Ordering.gt, Ordering.eq]]
[instInhabitedUSize,[Inhabited.mk, USize.ofNatCore, OfNat.ofNat, instInhabitedUSize.proof_1]]
[UInt16.instRingUInt16.proof_1,[congrArg, UInt16.mk, Ring.sub_eq_add_neg, UInt16.val]]
[Acc.inv.proof_1,[]]
[USize.decEq.proof_2,[absurd]]
[Equiv.invFun,[]]
[Array.toArrayLit_eq'.aux,[Eq, Array.toListLitAux, List.drop, Array.data, rfl]]
[Nat.gcd_div,[Eq, Nat.gcd, HDiv.hDiv, Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, OfNat.ofNat, Nat.div_zero, Nat.gcd_zero_right, rfl, Nat.eq_of_mul_eq_mul_right, HMul.hMul, Nat.div_mul_cancel, Nat.dvd_gcd, Eq.symm, Nat.gcd_mul_right]]
[Char.eq_of_val_eq,[Eq.symm, eq_of_heq, Eq.refl, Char.val, Char.mk, HEq.refl, Eq, rfl]]
[MonadReaderOf.noConfusionType,[]]
[Nat.prod_dvd_and_dvd_of_dvd_prod.proof_3,[Nat.zero_lt_succ, Eq.symm]]
[Array.mapIdxM.map,[Array, Pure.pure]]
[Function.Â«term_âˆ˜â‚‚_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[String.isSuffix,[List.isSuffix]]
[UInt64.toUInt8,[Nat.toUInt8, UInt64.toNat]]
[ExceptCpsT.runCatch_lift,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, bind_pure, eq_self]]
[CoeFun.noConfusionType,[]]
[PSigma.noConfusionType,[]]
[Tactic.NormCast.addInfer,[Bind.bind, Lean.getConstInfo, Tactic.NormCast.addElim]]
[Function.left_inverse.comp_eq_id,[funext]]
[timeCmd,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[ByteSlice.off,[]]
[evalGuardHyp,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.isNone, Unit.unit, Option.none, Lean.Syntax.matchesNull, OfNat.ofNat, Option.some, Lean.Elab.throwUnsupportedSyntax]]
[instToStringProd,[ToString.mk, String, HAppend.hAppend, ToString.toString]]
[and_comm,[And.comm]]
[npow_rec,[OfNat.ofNat, HMul.hMul, PProd.fst]]
[mul_left_inj,[Iff.intro, mul_right_cancel, rfl]]
[instReprList_1,[Repr.mk, Std.Format, List.cons, Std.Format.text, Std.Format.bracketFill, Std.Format.joinSep, HAppend.hAppend, Std.Format.line]]
[AddCommGroup.noConfusionType,[]]
[OrOp.noConfusionType,[]]
[And.symm,[And, And.intro]]
[Acc.ndrecOn,[]]
[LawfulFunctor.map_const,[]]
[tacticExfalso,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Nat.coprime.mul,[Eq.trans, Nat.coprime.gcd_mul_left_cancel]]
[instBEqOption,[BEq.mk, Unit.unit, Option.none, Option.some, Bool, Bool.true, and, BEq.beq, Bool.false]]
[Nat.le_antisymm,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Eq, rfl, absurd, Nat.lt_of_le_of_lt, Nat.lt_irrefl]]
[heq_of_eq_of_heq,[HEq.trans, heq_of_eq]]
[List.subset_def,[Iff.rfl]]
[UInt32.instRingUInt32.proof_3,[congrArg, UInt32.mk, Ring.gsmul_succ', UInt32.val]]
[Array.push,[Array.mk, List.concat, Array.data]]
[Nat.succ_sub_sub_succ,[Eq.mpr, Eq.refl, Eq, HSub.hSub, Nat.succ, Nat.sub_sub, HAdd.hAdd, Nat.add_succ, Nat.succ_sub_succ, rfl]]
[imp.swap,[Iff.intro, Function.swap]]
[List.reverseAux_eq_append,[of_eq_true, Eq.trans, congrArg, Eq, List.nil_append, eq_self, Eq.mpr, Eq.refl, HAppend.hAppend, List.cons, List.reverseAux, List.nil, List.append_assoc, rfl]]
[instTransLtLeLt.proof_1,[lt_of_lt_of_le]]
[USize.le,[LE.le, USize.val]]
[Id.finally,[MonadFinally.mk, Pure.pure, Prod.mk]]
[Nat.lt_add_of_pos_right,[Nat.add_lt_add_left]]
[HAnd.noConfusionType,[]]
[BinaryHeap.replaceMax,[Prod, Option, BinaryHeap, BinaryHeap.max, BinaryHeap.replaceMax.proof_1, Prod.mk, Option.none, BinaryHeap.mk, Array.push, BinaryHeap.arr, Option.some, Subtype.val, BinaryHeap.heapifyDown, Fin.mk, OfNat.ofNat, BinaryHeap.replaceMax.proof_2]]
[Quot.indBeta,[rfl]]
[eq_self_iff_true,[iff_true_intro, rfl]]
[Tactic.Find.tacticFind,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[AddMonoid.nsmul_zero',[]]
[Fin.mulOverflows?,[Decidable.decide, LE.le, HMul.hMul, Fin.val]]
[ForInStep.done.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Â«term_â‰¤_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.le.dest,[Exists, Eq, HAdd.hAdd, Exists.intro, OfNat.ofNat, rfl, Nat.succ, Eq.symm, Nat.add_comm, absurd, Nat.not_succ_le_zero]]
[Function.uncurry_bicompl,[funext, Eq, Function.uncurry, Function.bicompl, Function.comp, Prod.map, rfl]]
[trivial,[True.intro]]
[Subtype.mk_eq_mk,[Subtype.ext_iff]]
[Int.le_add_of_neg_le_sub_right,[Int.le_add_of_sub_right_le, Int.add_le_of_le_sub_left]]
[UInt32.instSemiringUInt32.proof_5,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, congrFun, HMul.hMul, UInt32.zero_def, UInt32.mul_def, UInt32.mk, OfNat.ofNat, MonoidWithZero.zero_mul, UInt32.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt32]]
[instTransGeGeGe,[Trans.mk, instTransGeGeGe.proof_1]]
[List.join,[Unit.unit, List, List.nil, HAppend.hAppend, PProd.fst]]
[String.quote,[ite, Eq, String.isEmpty, Bool.true, HAppend.hAppend, String.foldl, Char.quoteCore]]
[decidableBEx.proof_3,[Exists, And, Mem.mem, List.cons, Exists.intro, And.intro, Or.inr]]
[ofNat_mul,[Eq, Numeric.ofNat, HMul.hMul, of_eq_true, Eq.trans, congr, congrArg, Nat.mul_zero, ofNat_zero, MonoidWithZero.mul_zero, eq_self, OfNat.ofNat, Nat.mul_succ, ofNat_add, congrFun, HAdd.hAdd, ofNat_one, mul_add, mul_one]]
[Nat.eq_zero_of_mul_eq_zero,[Or, Eq, OfNat.ofNat, Or.inl, rfl, Or.inr, Nat.eq_zero_of_add_eq_zero_left, Eq.mp, Eq.refl, HMul.hMul, HAdd.hAdd, Nat.succ_mul]]
[StdGen.mk.inj,[And.intro]]
[String.Iterator.mk.inj,[And.intro]]
[instToStreamRangeRange,[ToStream.mk]]
[em,[Classical.em]]
[MonadControl.stM,[]]
[Equiv.noConfusionType,[]]
[Set.insertUnexpander,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesIdent, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, Unit.unit]]
[Setoid.refl,[Equivalence.refl, Setoid.iseqv]]
[Int.lt.intro,[Int.lt_add_succ]]
[CoeHTCT.noConfusionType,[]]
[Function.curry,[Prod.mk]]
[Int.mul_neg_of_pos_of_neg,[]]
[ByteSlice.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, ByteSlice.mk, Eq.symm, eq_of_heq, HEq.refl]]
[DoResultSBC.pureReturn.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instMonadWithReaderOfReaderT,[MonadWithReaderOf.mk]]
[Nat.any,[Nat.anyAux]]
[Array.mapIdxM.map.proof_1,[Eq.mpr, Eq.refl, LT.lt, Array.size, Eq.symm, HAdd.hAdd, OfNat.ofNat, Nat.add_assoc, Nat.add_comm, Nat.le_add_right, Nat.succ]]
[instTransLeLeLe.proof_1,[le_trans]]
[instMonadEST,[inferInstanceAs, Monad, EStateM]]
[type_eq_of_heq.proof_1,[HEq.ndrecOn, Eq.refl]]
[Nat.instLinearOrderNat,[LinearOrder.mk, Nat.le_total, inferInstance]]
[String.leftpad_suffix,[String.isSuffix, String.leftpad, of_eq_true, eq_true, List.leftpad_suffix]]
[Subarray.forM,[Array.forM, Subarray.as, Subarray.start, Subarray.stop]]
[USize.lor,[USize.mk, Fin.lor, USize.val]]
[lt_by_cases.proof_1,[le_antisymm, le_of_not_gt]]
[Int.subNatNat_elim,[]]
[Prod.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Prod.mk, Eq.symm, eq_of_heq, HEq.refl]]
[CommSemiring.toSemiring,[]]
[Prod.noConfusionType,[]]
[Classical.inhabited_of_exists.proof_1,[Exists.elim, Nonempty.intro]]
[max_eq_right,[Eq.mpr, Eq.refl, Eq, max, Eq.symm, max_comm, max_eq_left]]
[Function.id_def,[rfl]]
[List.subset_append_right,[List.mem_append_right]]
[SubNegMonoid.toNeg,[]]
[List.decidablePairwise.proof_2,[]]
[List.mapâ‚‚Left',[Prod, List, Prod.mk, List.nil, List.map, Option.none, List.cons, Option.some, Prod.fst, Prod.snd]]
[instReprAtomUInt16,[ReprAtom.mk]]
[FloatSpec.mk.inj,[And.intro]]
[StdGen.noConfusionType,[]]
[Set.compl,[setOf, Not, Mem.mem]]
[Tactic.LibrarySearch.lines,[Lean.MessageData.joinSep, Lean.MessageData.ofFormat, Std.Format.line]]
[Nat.sub_lt_sub_left,[Eq.refl, Nat.zero, HEq.refl, LT.lt, HSub.hSub, Eq.mpr, HAdd.hAdd, OfNat.ofNat, Nat.add_sub_add_right, Nat.lt_succ_of_le, Nat.sub_le, PProd.fst, Nat.lt_of_succ_lt_succ]]
[Array.findRev?,[Id.run, Array.findRevM?]]
[List.reverseAux,[List, PProd.fst, List.cons]]
[Subtype.refl,[Setoid.refl, Subtype.val]]
[ByteArray.set!,[ByteArray, ByteArray.mk, Array.set!]]
[Neg.neg,[]]
[Function.bicompl,[]]
[instDecidableLt_1,[UInt8.decLt]]
[iff_congr,[Iff.intro, Iff.trans, Iff.symm]]
[Nat.lt_of_succ_lt_succ,[Nat.le_of_succ_le_succ]]
[instDecidableEqBool.proof_1,[]]
[instSemiringFin.proof_13,[]]
[instPowNatNat,[Pow.mk, Nat.pow]]
[List.cons_bind,[of_eq_true, eq_self, HAppend.hAppend]]
[List.cons.inj,[And.intro]]
[plift.up.injEq,[Eq.propIntro, Eq.refl, plift.up, Eq.symm, eq_of_heq, HEq.refl]]
[Tactic.Ring.horner_mul_const,[of_eq_true, Eq.trans, congr, congrArg, Eq, add_mul, HMul.hMul, HPow.hPow, congrFun, HAdd.hAdd, mul_right_comm, Eq.symm, eq_self]]
[Int.neg_le_sub_right_of_le_add,[Int.le_sub_left_of_add_le, Int.sub_right_le_of_le_add]]
[Char.utf8Size.proof_4,[of_decide_eq_true, Eq.refl, Bool.true]]
[And.left_comm,[Eq.mpr, Eq.refl, Iff, And, Eq.symm, propext, and_assoc, And.comm, Iff.rfl]]
[Int.toNat,[Nat, OfNat.ofNat]]
[instDecidableAnd,[Decidable, And, Decidable.isTrue, And.intro, Decidable.isFalse, instDecidableAnd.proof_1, instDecidableAnd.proof_2]]
[eq_self,[propext, Iff.intro, trivial, rfl]]
[Function.surjective.comp,[Exists.elim, Exists.intro]]
[Subtype.eta,[rfl, Eq.symm, Eq.refl]]
[MonadLift.noConfusionType,[]]
[Array.findM?,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, ite, Eq, Bool.true, Pure.pure, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, Option, MProd.fst]]
[Subtype.instHasEquivSubtype,[HasEquiv.mk, HasEquiv.Equiv, Subtype.val]]
[Exists.nonempty,[Nonempty, Nonempty.intro]]
[Int.neg_mul_eq_neg_mul_symm,[Eq.symm, Int.neg_mul_eq_neg_mul]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.isConditional,[]]
[Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat.lt_of_lt_of_le]]
[xor_true,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, funext, congr, Or, true_and, Not, And, eq_false_of_decide, Eq.refl, Bool.false, and_false, or_false, eq_self]]
[Int.le_of_sub_nonneg,[]]
[Option.guard,[ite, Option.some, Option.none]]
[USize.instSemiringUSize.proof_3,[congrArg, USize.mk, Semiring.nsmul_zero', USize.val]]
[ExceptT.run_bind_lift,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Bind.bind, map_eq_pure_bind, Except.ok, Except, Pure.pure, Except.error, LawfulMonad.bind_assoc, funext, LawfulMonad.pure_bind, eq_self]]
[List.mem_bind_of_mem,[Iff.mpr, List.mem_bind, Exists.intro, And.intro]]
[List.exists_cons_of_ne_nil,[absurd, Eq.refl, List.nil, Exists.intro, rfl]]
[UInt16.val_eq_of_lt,[Fin.val_eq_of_lt]]
[Array.empty,[Array.mkEmpty, OfNat.ofNat]]
[Alternative.noConfusionType,[]]
[DoResultSBC.break.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt32.ofNat,[UInt32.mk, Fin.ofNat]]
[dec_em,[Decidable.em]]
[ExceptT.run_bind,[rfl]]
[GroupWithZero.noConfusionType,[]]
[decidableBAll.proof_2,[dite, False.elim, Exists.intro, And.intro]]
[UInt64.val_eq_of_eq,[Eq, UInt64.val, congrArg]]
[UInt32.instAddCommSemigroupUInt32.proof_1,[congrArg, UInt32.mk, AddCommSemigroup.add_comm, UInt32.val]]
[Prod.lexAccessible.proof_1,[Acc.intro, Prod.mk, Eq.symm, eq_of_heq, Eq.refl, HEq.refl]]
[List.erasep_cons_of_pos,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.erasep_cons, ite_congr, eq_true, Eq.refl, List.cons, List.erasep, ite_true, eq_self]]
[Union.union,[]]
[Int.instInhabitedInt,[Inhabited.mk, Int.ofNat, OfNat.ofNat]]
[instToStringId_1,[inferInstanceAs, ToString]]
[Tactic.Ring.zero_horner,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, HAdd.hAdd, MonoidWithZero.zero_mul, HPow.hPow, zero_add, eq_self]]
[PartialOrder.le_antisymm,[]]
[timeCmdElab,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, liftM, IO.monoMsNow, Lean.Elab.Command.elabCommand, Lean.Elab.logInfoAt, HAppend.hAppend, Lean.ToMessageData.toMessageData, HSub.hSub, Lean.Elab.throwUnsupportedSyntax]]
[instReprFloat,[Repr.mk, Std.Format.text, Float.toString]]
[List.intersperse,[Unit.unit, List.cons, List, List.nil, PProd.fst]]
[instReprAtomFloat,[ReprAtom.mk]]
[Â«stx_+Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Function.left_inverse.eq_right_inverse,[]]
[PUnit.subsingleton,[rfl, Eq.symm, Eq.refl]]
[instOrOpUInt16,[OrOp.mk, UInt16.lor]]
[PSigma.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[MonadState.noConfusionType,[]]
[Function.left_inverse_surj_inv,[Function.right_inverse_of_injective_of_left_inverse, And.left, Function.right_inverse_surj_inv, And.right]]
[Set.mem,[]]
[Option.bind_id_eq_join,[rfl]]
[List.leftpad_suffix,[Exists.intro, List.repeat, HSub.hSub, List.length, rfl]]
[String.foldr,[String.foldrAux, String.bsize, OfNat.ofNat]]
[PUnit.eq_punit,[PUnit.subsingleton, PUnit.unit]]
[List.zipRight',[List.mapâ‚‚Right', Prod.mk]]
[congr_fun,[congrFun]]
[usize_size_eq,[]]
[OfScientific.noConfusionType,[]]
[List.scanr,[List, List.cons]]
[Nat.mul_sub_div,[]]
[Nat.gcd_eq_zero_iff,[Iff.intro, And.intro, Nat.eq_zero_of_gcd_eq_zero_left, Nat.eq_zero_of_gcd_eq_zero_right, Eq.mpr, Eq.refl, Eq, Nat.gcd, OfNat.ofNat, And.left, And.right, Nat.gcd_zero_right]]
[List.exists_mem_of_ne_nil,[List.exists_mem_of_length_pos, List.length_pos_of_ne_nil]]
[Option.not_isSome,[of_eq_true, Eq.trans, congr, congrArg, Iff, congrFun, Eq, Option.isSome_none, Bool.false, eq_true_of_decide, Eq.refl, Bool.true, Option.isNone_none, Eq.symm, Option.isSome_some, eq_false', Option.isNone_some]]
[UInt32.instRingUInt32.proof_2,[congrArg, UInt32.mk, Ring.gsmul_zero', UInt32.val]]
[Int.instDecidableEqInt,[Int.decEq]]
[Ring.gsmul_zero',[]]
[ByteArray.mk.injEq,[Eq.propIntro, Eq.refl, ByteArray.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.find_x,[WellFounded.fix', WellFounded.intro, Acc, And, Eq, HAdd.hAdd, OfNat.ofNat, Not, dite, Subtype.mk, Nat.find_x.proof_1, Nat.find_x.proof_3]]
[WellFoundedRelation.noConfusionType,[]]
[Int.instOfNatInt,[OfNat.mk, Int.ofNat]]
[Nat.forRevM.loop,[Unit.unit, Unit, Pure.pure, Bind.bind, PProd.fst]]
[Function.inv_fun_comp,[funext, Function.left_inverse_inv_fun]]
[List.last_eq_get,[Eq, List.last, List.get, HSub.hSub, List.length, OfNat.ofNat, Nat.sub_lt, List.length_pos_of_ne_nil, Nat.one_pos, rfl, Eq.mpr, Eq.refl, List.cons, List.nil, List.last_singleton, List.get_singleton, List.last_cons, List.cons_ne_nil, PProd.fst]]
[Nat.lcm_self,[Eq, Nat.lcm, Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, OfNat.ofNat, Nat.lcm_zero_left, rfl]]
[EStateM.instMonadExceptOfEStateM,[MonadExceptOf.mk, EStateM.throw, EStateM.tryCatch]]
[Quotient.sound.proof_1,[Quot.sound]]
[Function.inv_fun_on_pos,[]]
[UInt16.decEq.proof_2,[absurd]]
[List.mem_map_of_injective,[Iff.intro, Mem.mem, List.mem_map_of_mem]]
[Option.decidable_exists_mem.proof_3,[Eq.symm, eq_of_heq, Eq.refl, Option.some, HEq.refl, False]]
[Nat.sub_lt_self,[Nat.sub_lt, Nat.lt_of_lt_of_le]]
[instMonadST,[inferInstanceAs, Monad, EST, Empty]]
[UInt16.lor,[UInt16.mk, Fin.lor, UInt16.val]]
[OptionM,[OptionT, Id]]
[Nat.Up.next,[And.intro, Nat.lt_succ_self]]
[Mathlib.Tactic.Lint.constToSimpDeclMap,[Id.run, Bind.bind, ForIn.forIn, Option.none, Id, ForInStep, Std.HashMap, Lean.Name, Lean.Meta.SimpLemma.name?, Lean.Expr.constName?, Lean.Expr.getAppFn, Lean.Meta.SimpLemma.proof, Pure.pure, PUnit.unit, ForInStep.yield]]
[List.mem_reverse,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, propext, List.mem_reverseAux, List.nil, Or, Mem.mem, List.mem_nil, or_false, iff_self]]
[Nat.add_right_comm,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Nat.add_assoc, Nat.add_comm, Eq.symm, rfl]]
[instLEUInt64,[LE.mk, UInt64.le]]
[EStateM.Backtrackable.restore,[]]
[Except.noConfusionType,[]]
[Option.bind_comm,[rfl, Eq.symm, Eq.refl]]
[String.decLt,[List.hasDecidableLt, String.data]]
[typedExpr,[]]
[Option.join_ne_none,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, ne_eq, Option.bind, id, Option.none, Not, propext, Option.bind_eq_none, forall_congr, implies_congr, Option.mem_def, Mem.mem, id_eq, not_forall, Exists, funext, not_not, exists_prop, exists_eq_right, Eq, Option.some, iff_self]]
[List.get_mem,[Eq.refl, List.length, List.nil, HEq.refl, Mem.mem, List.get, List.mem_cons_self, List.cons, OfNat.ofNat, List.mem_cons_of_mem, PProd.fst, Nat.add, Nat.le_of_succ_le_succ, List.length_cons]]
[Mathlib.ExtendedBinder.binderPred.quot,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[instRandomGenStdGen,[RandomGen.mk, stdRange, stdNext, stdSplit]]
[Mathlib.Tactic.Lint.LintVerbosity.high.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[List.append_bind,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, List.bind, List.cons_append, List.cons_bind, HAppend.hAppend, List.append_assoc, eq_self]]
[ExceptCpsT.instInhabitedExceptCpsT,[Inhabited.mk, arbitrary]]
[AddCommMonoid.toAddMonoid,[]]
[Function.injective2,[And, Eq]]
[String.nextUntil,[String.nextWhile, not]]
[UInt64.toUInt32,[Nat.toUInt32, UInt64.toNat]]
[List.cons_subset_cons,[Mem.mem, List.cons, List.eq_or_mem_of_mem_cons, Or.inl, Or.inr]]
[instInhabitedForInStep,[Inhabited.mk, ForInStep.done, arbitrary]]
[Thunk.map,[Thunk.mk, Thunk.get]]
[instPowFloatFloat,[Pow.mk, Float.pow]]
[Fin.add_def,[Eq, HAdd.hAdd, Fin.mk, HMod.hMod, Fin.val, Nat.mod_lt, Fin.size_positive, rfl]]
[FloatArray.foldlM.loop,[dite, LT.lt, Unit.unit, Pure.pure, Bind.bind, FloatArray.get, Fin.mk, FloatArray.foldlM.loop.proof_1, PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[ByteArray.size,[Nat, Array.size]]
[List.mapTRAux_eq,[of_eq_true, Eq.trans, congrArg, Eq, List.reverse, List.append_nil, eq_self, Eq.mpr, Eq.refl, HAppend.hAppend, List.cons, List.map, List.reverse_cons, List.nil, List.append_assoc, rfl]]
[Int.add_neg,[Int.add_lt_add, Int.zero_add, OfNat.ofNat]]
[Substring.trimLeft,[Substring.dropWhile, Char.isWhitespace]]
[Append.append,[]]
[or_congr_left,[or_congr, Iff.rfl]]
[List.not_mem_cons_of_ne_of_not_mem,[absurd, List.eq_or_mem_of_mem_cons, Iff.mpr, not_or, Eq, Mem.mem, And.intro]]
[Option.bind,[Option, Option.none]]
[ReaderT.run_map,[rfl]]
[Float.ofNat,[OfScientific.ofScientific, Bool.false, OfNat.ofNat]]
[Tactic.NormCast.NormCastExtension.noConfusionType,[]]
[Function.is_partial_inv,[Iff, Eq, Option.some]]
[Nat.gcd.induction,[WellFounded.induction, WellFoundedRelation.wf, Nat.lt_wfRel, HAdd.hAdd, OfNat.ofNat, Nat.succ_pos, HMod.hMod, Nat.mod_lt]]
[Substring.takeRightWhile,[Substring, Substring.mk]]
[instSubFloat,[Sub.mk, Float.sub]]
[List.toAssocList,[Unit.unit, Std.AssocList, Std.AssocList.nil, Std.AssocList.cons, PProd.fst]]
[Nat.not_succ_le_zero,[False, Eq.refl, OfNat.ofNat, HEq.refl]]
[Array.Â«term__[:_]Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[System.FilePath.isAbsolute,[or, List.contains, System.FilePath.pathSeparators, String.front, System.FilePath.toString, and, System.Platform.isWindows, Decidable.decide, GE.ge, String.bsize, OfNat.ofNat, BEq.beq, String.getOp, Char.ofNat]]
[instInhabitedPUnit,[Inhabited.mk, PUnit.unit]]
[Tactic.Ring.RingM.run,[Bind.bind, Lean.Meta.getLevel, Lean.Level.zero, Lean.Level.max, Lean.Level.imax, Lean.Level.param, Lean.Level.mvar, Lean.Meta.MetaM, Lean.Meta.synthInstance, Lean.mkApp, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, List.nil, Option.none, StateRefT'.run', Tactic.Ring.Cache.mk, Tactic.Ring.State.mk, Lean.throwError, Lean.ToMessageData.toMessageData]]
[ByteArray.forIn.loop.proof_1,[Nat.lt_of_le_of_lt, Nat.sub_le, HSub.hSub, ByteArray.size, OfNat.ofNat, Nat.sub_lt, Nat.zero_lt_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self, of_decide_eq_true, Eq.refl, Bool.true]]
[Coe.coe,[]]
[UInt64.ofNat,[UInt64.mk, Fin.ofNat]]
[List.card_union_disjoint,[Eq.mpr, Eq.refl, Eq, List.card, List.union, HAdd.hAdd, List.card_eq_of_equiv, List.union_equiv_append, HAppend.hAppend, List.card_append_disjoint, rfl]]
[Nat.div_mul_cancel,[Eq.mpr, Eq.refl, Eq, HMul.hMul, HDiv.hDiv, Nat.mul_comm, Nat.mul_div_cancel', rfl]]
[UInt16.instSemiringUInt16.proof_3,[congrArg, UInt16.mk, Semiring.nsmul_zero', UInt16.val]]
[List.and,[List.all, id]]
[UInt16.instRingUInt16.proof_5,[UInt16.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, UInt16.val, congrFun, HAdd.hAdd, UInt16.neg_def, UInt16.add_def, UInt16.mk, Neg.neg, add_left_neg, UInt16.zero_def, eq_true_of_decide, Eq.refl, Bool.true]]
[instLTUInt64,[LT.mk, UInt64.lt]]
[Int.one_mul,[Eq, HMul.hMul, OfNat.ofNat]]
[mul_right_inv,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Inv.inv, OfNat.ofNat, Eq.symm, mul_left_inv, inv_inv, rfl]]
[Mathlib.Tactic.Lint.printWarnings,[Bind.bind, Mathlib.Tactic.Lint.sortResults, Array.mapM, Lean.Core.CoreM, Lean.MessageData, Mathlib.Tactic.Lint.printWarning, Pure.pure, Lean.MessageData.joinSep, Array.toList, Lean.MessageData.ofFormat, Std.Format.line]]
[Or.comm,[Iff.intro, Or.symm]]
[Nat.lt_of_succ_lt,[Nat.le_of_succ_le]]
[List.erase_append_left,[Eq.mpr, congr, congrArg, Eq, List.erase_eq_erasep, HAppend.hAppend, congrFun, List.erasep_append_left, rfl]]
[CoeDep.noConfusionType,[]]
[UInt16.instNumericUInt16,[Numeric.mk, UInt16.mk, Numeric.ofNat]]
[Nat.coprime.gcd_mul_left_cancel_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.gcd_comm, Nat.coprime.gcd_mul_left_cancel, rfl]]
[instDecidableEqOption,[Unit.unit, Decidable, Eq, Decidable.isTrue, rfl, Decidable.isFalse, dite]]
[Set.insert,[setOf, Or, Eq, Mem.mem]]
[Int.decEq.proof_1,[rfl]]
[List.bor,[List.any, id]]
[decPropToBool,[CoeDep.mk, Decidable.decide]]
[StateCpsT.runK_modify,[rfl]]
[UInt16.div,[UInt16.mk, HDiv.hDiv, UInt16.val]]
[USize.instRingUSize.proof_4,[congrArg, USize.mk, SubNegMonoid.gsmul_neg', USize.val]]
[Int.subNatNat_of_sub_eq_zero,[]]
[Function.update_noteq,[dif_neg]]
[FloatArray.mkEmpty,[FloatArray.mk, List.toArray, List.nil]]
[Option.to_list_none,[rfl]]
[Nat.coprime.coprime_div_left,[Nat.coprime, HDiv.hDiv, Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, Nat.eq_zero_of_zero_dvd, Eq.mp, Dvd.dvd, congrFun, congrArg, Nat.zero_div, HMul.hMul, Nat.mul_div_cancel_left, Nat.coprime.coprime_mul_left]]
[le_or_gt,[le_or_lt]]
[USize.decEq,[Decidable, Eq, dite, Decidable.isTrue, USize.decEq.proof_1, Decidable.isFalse, USize.decEq.proof_2]]
[instReprSubarray,[Repr.mk, HAppend.hAppend, repr, Subarray.toArray, Std.Format.text]]
[List.groupByAux,[List.nil, List.cons, List, Unit.unit, PProd.fst, List.reverse]]
[ByteArray.uget,[UInt8, Array.uget]]
[Option.decidable_exists_mem,[Unit.unit, Decidable, Exists, And, Mem.mem, Decidable.isFalse, Option.decidable_exists_mem.proof_1, dite, Decidable.isTrue, Option.decidable_exists_mem.proof_2, Option.decidable_exists_mem.proof_3]]
[ByteArray.mk.inj,[]]
[Function.sometimes_spec,[Eq.mpr, Eq.refl, Function.sometimes, Function.sometimes_eq]]
[Int.subNatNat_eq_coe,[Int.subNatNat_elim, Eq, HSub.hSub, Int.ofNat, Eq.mpr, congrArg, Eq.trans, congrFun, Int.ofNat_add, Int.sub_eq_add_neg, Int.add_assoc, Neg.neg, Int.add_left_comm, HAdd.hAdd, Int.add_right_neg, rfl, congr, Int.negSucc_ofNat_coe, OfNat.ofNat, Int.neg_add, Eq.symm, Eq.refl, Int.ofNat_sub, Nat.le_refl, Nat.sub_self, Int.ofNat_zero, Int.zero_add]]
[Function.has_left_inverse,[Exists, Function.left_inverse]]
[Task.spawn,[Task.pure, Unit.unit]]
[Monoid.noConfusionType,[]]
[Classical.inhabited_of_exists,[Classical.inhabited_of_nonempty, Classical.inhabited_of_exists.proof_1]]
[Function.inv_fun_eq_of_injective_of_right_inverse,[funext, Function.inv_fun, Eq.mpr, Eq.refl, Eq, Function.inv_fun_eq, Exists.intro]]
[termâ„•,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Nat.lcm_assoc,[Nat.dvd_antisymm, Nat.lcm_dvd, Nat.dvd_lcm_left, Nat.lcm, Nat.dvd_trans, Nat.dvd_lcm_right]]
[Nat.instCommSemiringNat.proof_2,[of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.pow_succ, Nat.mul_comm, HPow.hPow, eq_self, HMul.hMul]]
[ofBoolUsing_eq_true,[of_decide_eq_true]]
[Option.some_ne_none,[]]
[FloatArray.foldlMUnsafe,[ite, LT.lt, LE.le, FloatArray.size, USize.ofNat, Pure.pure, FloatArray.foldlMUnsafe.fold]]
[byContra,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[List.ball_nil,[False.elim]]
[Subarray.noConfusionType,[]]
[List.reduceOption,[List.filterMap, id]]
[List.scanrAux,[Unit.unit, Prod, List, Prod.mk, List.nil, List.cons]]
[List.mem_filter,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, propext, List.mem_filterAux, List.nil, Or, And, Mem.mem, Eq, Bool.true, List.mem_nil, or_false, iff_self]]
[ExceptT.seqLeft_eq,[]]
[Array.size_mkArray,[List.length_replicate]]
[UInt8.add_def,[rfl]]
[Prod.snd_surjective,[Nonempty.elim, Exists.intro, Prod.mk, rfl]]
[Int.sign_neg_one,[rfl]]
[Int.instLEInt,[LE.mk, Int.le]]
[UInt16.instAddSemigroupUInt16.proof_1,[congrArg, UInt16.mk, AddSemigroup.add_assoc, UInt16.val]]
[instInhabitedUInt8,[Inhabited.mk, UInt8.ofNatCore, OfNat.ofNat, instInhabitedUInt8.proof_1]]
[Array.unzip,[Array.foldl, Prod, Array, Prod.mk, Array.push, List.toArray, List.nil, OfNat.ofNat, Array.size]]
[Substring.dropRight,[Substring.mk, Substring, HAdd.hAdd, Substring.prevn, Substring.bsize]]
[Substring.prev,[String.Pos, ite, Eq, HSub.hSub, String.prev]]
[List.length_add_eq_lengthTRAux,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Nat.zero_add, eq_self, Eq.mpr, congr, Nat.succ_add, Eq.symm, Nat.succ, rfl]]
[Quot.indepCoherent,[PSigma.eta, Quot.sound]]
[String.Iterator.next,[String.Iterator, String.Iterator.mk, String.next]]
[BinaryHeap.instEmptyCollectionBinaryHeap,[EmptyCollection.mk, BinaryHeap.empty]]
[Fin.modn_lt,[LT.lt, Fin.val, HMod.hMod, Nat.lt_of_le_of_lt, Nat.mod_le, Nat.mod_lt]]
[Nat.succ_add,[Eq, HAdd.hAdd, Nat.succ, rfl, congrArg, PProd.fst]]
[instReprList,[Repr.mk, Std.Format, List.cons, Std.Format.text, Std.Format.bracket, Std.Format.joinSep, HAppend.hAppend, Std.Format.line]]
[Int.lt_of_add_lt_add_left,[]]
[Nat.le_div_iff_mul_le,[Nat.mod.inductionOn, Eq.mpr, Eq.refl, Iff, LE.le, HDiv.hDiv, HMul.hMul, Nat.div_eq, congrFun, congrArg, Eq.trans, ite_congr, congr, And, eq_true, eq_true_of_decide, Bool.true, HAdd.hAdd, HSub.hSub, OfNat.ofNat, ite_true, of_eq_true, Nat.zero_eq, Nat.zero_le, Nat.zero_mul, Eq.symm, Nat.succ, Nat.add_one, propext, Nat.add_le_add_iff_le_right, Nat.succ_mul, Nat.add_sub_cancel, Nat.sub_le_sub_right_iff, And.right, Iff.rfl, eq_false, ite_false, Nat.not_succ_le_zero, Nat.add_comm, false_iff, not_le, Nat.lt_of_lt_of_le, Iff.mp, And.intro, Nat.le_add_right]]
[instDecidableEqString,[String.decEq]]
[Nat.coprime.coprime_mul_right,[Nat.coprime.coprime_dvd_left, Nat.dvd_mul_right]]
[Mathlib.Tactic.Lint.isConditionalHyps,[Unit.unit, Lean.Meta.MetaM, Bool, Pure.pure, Bool.false, Bind.bind, Lean.Meta.getFVarLocalDecl, List.anyM, Lean.Meta.inferType, Lean.Expr.containsFVar, Lean.Expr.fvarId!, ite, Eq, and, not, Lean.BinderInfo.isInstImplicit, Lean.LocalDecl.binderInfo, Bool.true, PUnit.unit]]
[List.erasep_nil,[rfl]]
[PProd.mk.inj,[And.intro]]
[Int.ofNat.inj,[]]
[Nat.div_eq_of_lt_le,[]]
[List.toSSet,[List.foldl, Lean.SSet.insert, Lean.SMap.mk]]
[decidableBAll,[dite, Exists, And, Mem.mem, Not, Decidable.isFalse, decidableBAll.proof_1, Decidable.isTrue, decidableBAll.proof_2]]
[Array.foldl,[Id.run, Array.foldlM]]
[neg_eq_of_add_eq_zero,[left_neg_eq_right_neg, neg_add_self]]
[List.not_mem_nil,[not_false]]
[Prod.map_snd',[funext, Prod.map_snd]]
[LE.le,[]]
[Iff.refl,[Iff.intro]]
[CoeTail.noConfusionType,[]]
[List.subset_append_left,[List.mem_append_left]]
[EStateM.dummySave,[PUnit.unit]]
[List.replicateTR,[List.nil, List.replicateTR.loop]]
[Â«term_=_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[StateT.orElse,[HOrElse.hOrElse, Unit.unit]]
[Int.div,[Int, Int.ofNat, HDiv.hDiv, Neg.neg, Nat.succ]]
[charToHex,[HAppend.hAppend, hexDigitRepr]]
[exists_eq_left',[of_eq_true, Eq.trans, congrFun, congrArg, Iff, Exists, funext, And, propext, eq_comm, exists_eq_left, iff_self]]
[instModUInt16,[Mod.mk, UInt16.mod]]
[Set.instFunctorSet,[Functor.mk, Set.image]]
[guardTargetStrict,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.toUInt64,[UInt64.ofNat]]
[List.leftpad,[HAppend.hAppend, List.repeat, HSub.hSub, List.length]]
[Int.instLTInt,[LT.mk, Int.lt]]
[mul_add,[Semiring.mul_add]]
[AndOp.noConfusionType,[]]
[CommRing.mul_comm,[]]
[Option.choice_eq,[Eq.mpr, Eq.refl, Eq, dite, Nonempty, Option.some, Classical.choice, Option.none, dif_pos, Nonempty.intro, Option.some.injEq, Subsingleton.elim]]
[Â«termDecl_name%Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Subtype.coind_surjective,[Exists, Eq, Subtype.coind, Exists.intro, Subtype.coe_injective]]
[instTransEq_1,[Trans.mk, instTransEq_1.proof_1]]
[Nat.to_digits_core_length,[of_eq_true, eq_true, Nat.zero_le, False.elim, Nat.lt_irrefl, OfNat.ofNat, Eq.symm, Classical.em, LT.lt, Eq.refl]]
[List.singleton_disjoint,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, forall_congr, implies_congr, propext, List.mem_singleton, Eq.refl, False, forall_eq, Not, Mem.mem, iff_self]]
[not.decidable_imp_symm,[Decidable.not_imp_symm]]
[Function.comp,[]]
[List.subset_of_cons_subset,[List.mem_cons_of_mem]]
[HAppend.noConfusionType,[]]
[ofNat_pow,[Eq.mpr, Eq.refl, Eq, Numeric.ofNat, HPow.hPow, Nat.zero, pow_zero, OfNat.ofNat, Nat.pow_zero, rfl, Nat.succ, pow_succ, HMul.hMul, Nat.pow_succ, ofNat_mul]]
[Setoid.trans,[Equivalence.trans, Setoid.iseqv]]
[ShiftRight.shiftRight,[]]
[String.Iterator.pos,[String.Pos]]
[implies_congr,[rfl]]
[ExceptT.instMonadLiftExceptExceptT,[MonadLift.mk, ExceptT.mk, Pure.pure]]
[Char.isValidCharNat,[Or, LT.lt, OfNat.ofNat, And]]
[fix2,[fixCore2, arbitrary]]
[Not,[False]]
[FloatArray.instEmptyCollectionFloatArray,[EmptyCollection.mk, FloatArray.empty]]
[Int.negSucc_ofNat_mul_negOfNat,[Unit.unit, Eq, HMul.hMul, Int.negSucc, Int.negOfNat, Int.ofNat, Nat.succ, rfl]]
[Mathlib.ExtendedBinder.Â«binderTermâ‰¤_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[forall_eq',[of_eq_true, Eq.trans, congrFun, congrArg, Iff, forall_congr, implies_congr, propext, eq_comm, Eq.refl, forall_eq, iff_self]]
[Array.ext',[Eq.symm, eq_of_heq, Eq.refl, Array.data, Array.mk, HEq.refl, Eq, rfl]]
[Nat.digitChar,[ite, Eq, OfNat.ofNat, Char.ofNat]]
[List.unzip,[Unit.unit, Prod, List, Prod.mk, List.nil, PProd.fst, List.cons]]
[EStateM.get,[EStateM.Result.ok]]
[Array.foldlMUnsafe,[ite, LT.lt, LE.le, Array.size, USize.ofNat, Pure.pure, Array.foldlMUnsafe.fold]]
[List.empty_eq,[rfl]]
[measure,[invImage, Nat.lt_wfRel]]
[List.eraseDupsAux,[List, List.reverse, Unit.unit, List.elem, PProd.fst, List.cons]]
[Int.le_of_neg_le_neg,[]]
[Function.has_uncurry_base,[Function.has_uncurry.mk, id]]
[instMonadExceptOfExcept,[MonadExceptOf.mk, Except.error, Except.tryCatch]]
[Nat.toSuperscriptString,[List.asString, Nat.toSuperDigits]]
[eqRec_heq,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, HEq]]
[coeId,[CoeT.mk]]
[instDecidableAnd.proof_2,[And.left]]
[instComplementUInt16,[Complement.mk, UInt16.complement]]
[ReaderT.run,[]]
[tacticRepeat'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser]]
[List.rangeAux,[List, Nat, PProd.fst, List.cons]]
[UInt8.instRingUInt8.proof_4,[congrArg, UInt8.mk, SubNegMonoid.gsmul_neg', UInt8.val]]
[Fin.val_eq_of_lt,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Nat.mod_eq_of_lt, eq_self]]
[Option.traverse,[Unit.unit, Option, Pure.pure, Option.none, Functor.map, Option.some]]
[UInt64.mul,[UInt64.mk, HMul.hMul, UInt64.val]]
[instDecidableEq.proof_1,[Iff.rfl]]
[Nat.le_add_left,[Nat.le_add_right, Nat.add_comm]]
[instHashableList,[Hashable.mk, List.foldl, mixHash, Hashable.hash, OfNat.ofNat]]
[Array.back?,[Array.get?, HSub.hSub, Array.size, OfNat.ofNat]]
[Int.neg,[Int, Int.negOfNat, Int.ofNat, Nat.succ]]
[eq_rec_constant,[rfl, Eq.symm, eq_of_heq, Eq.refl, HEq.refl]]
[Array.uget,[Array.get, Fin.mk, USize.toNat]]
[USize.instRingUSize.proof_5,[USize.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, USize.val, congrFun, HAdd.hAdd, USize.neg_def, USize.add_def, USize.mk, Neg.neg, add_left_neg, USize.zero_def, eq_self, OfNat.ofNat]]
[Fin.add.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[Ring.toNeg,[]]
[Int.natAbs_zero,[rfl]]
[Function.extend_apply,[Eq.mpr, congrFun, congrArg, Eq, Eq.trans, Function.extend_def, dite_congr, eq_true, exists_apply_eq_apply, Eq.refl, Classical.choose, Eq.mpr_prop, dif_pos, of_eq_true, True, congr_arg, Classical.choose_spec]]
[ex_of_PSigma,[Exists, Exists.intro]]
[Mathlib.Tactic.Lint.Linter.test,[]]
[le_antisymm_iff,[Iff.intro, And.intro, le_of_eq, Eq.symm, Eq, le_antisymm]]
[Subarray.all,[Id.run, Subarray.allM]]
[instDecidableEqProd,[Decidable, Eq, Prod.mk, decEq, Decidable.isTrue, instDecidableEqProd.proof_1, Decidable.isFalse, instDecidableEqProd.proof_2, instDecidableEqProd.proof_3]]
[FloatArray.set!,[FloatArray, FloatArray.mk, Array.set!]]
[Set.instSdiffSet,[Sdiff.mk, Set.diff]]
[Nat.repeat,[Nat.repeat.loop]]
[WellFoundedRelation.mk.inj,[]]
[Array.findIdx?.loop.proof_1,[absurd, Eq.mp, Eq.refl, LT.lt, Array.size, Eq, HAdd.hAdd, OfNat.ofNat, Nat.zero_add, Nat.lt_irrefl]]
[ForIn.forIn,[]]
[Â«stx_<|>_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.lcm_ne_zero,[]]
[Functor.map_equiv.proof_2,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Functor.map_map, Equiv.toFun, Equiv.symm, Functor.map, Equiv.self_comp_symm, LawfulFunctor.id_map, eq_self]]
[associative,[Eq]]
[instSubsingletonSquash.proof_1,[Subsingleton.intro, Squash.ind, Quot.sound, True.intro]]
[Function.Equiv.refl,[rfl]]
[dec_em',[Or.swap, dec_em]]
[liftExcept,[Pure.pure, MonadExcept.throw]]
[ReaderT.instAlternativeReaderT,[Alternative.mk, ReaderT.failure, ReaderT.orElse]]
[List.last_concat,[Eq.mpr, Eq.refl, Eq, List.last, List.concat, List.concat_eq_append, List.last_append]]
[Tactic.TryThis.addExactSuggestion,[Bind.bind, liftM, Tactic.TryThis.delabToRefinableSyntax, ite, Eq, Lean.Expr.hasExprMVar, Bool.true, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[String.length_repeat,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.length_repeat, eq_self]]
[Int.ofNat_mul_negOfNat,[Unit.unit, Eq, HMul.hMul, Int.ofNat, Int.negOfNat, rfl]]
[MonadStateOf.modifyGet,[]]
[decide_eq_false,[Eq, Decidable.decide, Bool.false, absurd, rfl]]
[Char.ofNat.proof_1,[of_decide_eq_true, Eq.refl, Bool.true]]
[cast_eq,[rfl]]
[MonadControlT.liftWith,[]]
[Array.anyMUnsafe,[ite, LT.lt, LE.le, Array.size, USize.ofNat, Pure.pure, Bool.false, Array.anyMUnsafe.any]]
[StateT.instLawfulMonadStateT.proof_1,[LawfulMonad.mk, StateT.ext, Eq.mpr, congr, congrArg, Eq, Eq.trans, StateT.run_bind, Pure.pure, Bind.bind, StateT.run, funext, StateT.run_pure, Prod.fst, Prod.snd, StateT.run_map, LawfulMonad.bind_pure_comp, Prod.mk, rfl, of_eq_true, congrFun, LawfulMonad.pure_bind, eq_self, LawfulMonad.bind_assoc]]
[List.nil.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[USize.instCommRingUSize,[CommRing.mk, USize.instCommRingUSize.proof_1]]
[Fin.sub.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[Subtype.forall',[Iff.symm, Subtype.forall]]
[MonadControl.restoreM,[]]
[Classical.epsilon,[Subtype.val, Classical.strongIndefiniteDescription]]
[Option.all,[Unit.unit, Bool, Bool.true]]
[instDecidableEq_1,[LinearOrder.decidable_eq]]
[Int.le_add_of_sub_right_le,[]]
[System.FilePath.extSeparator,[Char.ofNat]]
[List.erase_cons_head,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.erase_cons, ite_congr, eq_self, Eq.refl, List.cons, List.erase, ite_true]]
[ne_of_lt,[absurd, lt_irrefl]]
[List.band,[List.all, id]]
[List.append_nil,[rfl, of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.cons, id, eq_self]]
[Array.filterMap,[Id.run, Array.filterMapM]]
[left_neg_eq_right_neg,[Eq.mpr, Eq.refl, Eq, Eq.symm, zero_add, HAdd.hAdd, OfNat.ofNat, add_assoc, add_zero, rfl]]
[Int.add_left_cancel,[]]
[Nat.mod_self,[Eq.mpr, Eq.refl, Eq, HMod.hMod, OfNat.ofNat, Nat.mod_eq_sub_mod, Nat.le_refl, HSub.hSub, Nat.sub_self, Nat.zero_mod, rfl]]
[USize.instRingUSize.proof_2,[congrArg, USize.mk, Ring.gsmul_zero', USize.val]]
[Int.ofNat_nonneg,[Int.NonNeg.mk, HAdd.hAdd, OfNat.ofNat]]
[LawfulFunctor.id_map,[]]
[Nat.div_eq_of_lt,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, OfNat.ofNat, Nat.div_eq, ite, And, LT.lt, LE.le, HAdd.hAdd, HSub.hSub, if_neg, Nat.not_le_of_gt, And.right, rfl]]
[List.remove,[Unit.unit, List, List.nil, ite, Eq, PProd.fst, List.cons]]
[List.hasDecidableLt.proof_2,[Eq.refl, List.cons, List.nil, HEq.refl, False]]
[USize.neg_def,[rfl]]
[ULift.down_up,[rfl]]
[Nat.coprime.gcd_right,[Nat.coprime.coprime_dvd_right, Nat.gcd_dvd_right]]
[Monoid.mul_one,[]]
[StateT.seqLeft_eq,[StateT.ext, of_eq_true, Eq.trans, congr, congrArg, Eq, StateT.run_seqLeft, StateT.run_seq, Functor.map, Function.const, Bind.bind, StateT.run_map, map_eq_pure_bind, Prod.mk, Prod.fst, Prod.snd, StateT.run, funext, LawfulMonad.bind_assoc, Pure.pure, LawfulMonad.pure_bind, congrFun, Function.const_apply, eq_self]]
[UInt64.sub,[UInt64.mk, HSub.hSub, UInt64.val]]
[List.rotateRight,[ite, LE.le, OfNat.ofNat, HAppend.hAppend]]
[Function.bijective.of_comp_iff',[and_congr, Function.injective.of_comp_iff, Function.bijective.injective, Function.surjective.of_comp_iff']]
[heq_of_eq,[Eq.subst, HEq.refl]]
[Int.le_antisymm,[]]
[Array.eraseIdx,[ite, LT.lt, Array.size, Array.eraseIdxAux, HAdd.hAdd, OfNat.ofNat]]
[List.mapIdxM.loop,[List, Pure.pure, List.nil, Seq.seq, Functor.map, List.cons, PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[Prod.eq_iff_fst_eq_snd_eq,[Iff, Eq, And, Prod.fst, Prod.snd, of_eq_true, Eq.trans, congrFun, congrArg, Prod.mk.injEq, iff_self]]
[HSub.hSub,[]]
[Nat.eq_zero_of_add_eq_zero_right,[Eq, OfNat.ofNat, of_eq_true, Eq.trans, implies_congr, congrFun, congrArg, Nat.zero_add, eq_true_of_decide, Eq.refl, Bool.true, implies_true, False.elim, Nat.succ_ne_zero, HAdd.hAdd, Eq.mp, Nat.succ, Nat.succ_add, Nat.add_one]]
[Fin.decLe,[Nat.decLe, Fin.val]]
[exists_eq_left,[Iff.intro, Exists.intro, And.intro, rfl]]
[lt_asymm,[lt_irrefl, lt_trans]]
[and_congr_right,[Iff.intro, And, And.intro, Iff.mp, Iff.mpr]]
[Except.tryCatch,[Except, Except.ok]]
[List.repeat,[Unit.unit, List, List.nil, List.cons, PProd.fst]]
[List.bagInter,[List.nil, List.cons, List, ite, Eq, List.elem, Bool.true, PProd.fst, List.erase]]
[non_contradictory,[Not]]
[ExceptT,[Except]]
[instTransGeGtGt,[Trans.mk, instTransGeGtGt.proof_1]]
[StateT.instLawfulMonadStateT,[StateT.instLawfulMonadStateT.proof_1]]
[Array.find?,[Id.run, Array.findM?]]
[Nat.mul_comm,[Eq, HMul.hMul, rfl, Eq.symm, Nat.mul_zero, Nat.zero_mul, PProd.fst, Nat.succ_mul, Nat.mul_succ]]
[List.any,[List.foldr, or, Bool.false]]
[Mathlib.ExtendedBinder.Â«termâˆ€áµ‰_,_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Mathlib.ExtendedBinder.extBinders, Lean.ParserDescr.cat]]
[fixCore5,[bfix5, USize.size]]
[instToStringSum,[ToString.mk, String, HAppend.hAppend, addParenHeuristic, ToString.toString]]
[UInt64.mod_def,[rfl]]
[ne_eq,[rfl]]
[Ordering.isLE,[Unit.unit, Bool, Bool.true, Bool.false]]
[List.foldlIdxAux,[PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[FloatArray.foldlM.loop.proof_1,[Nat.lt_of_lt_of_le]]
[ByteArray.copySlice,[ByteArray.mk, HAppend.hAppend, Array.extract, ByteArray.data, OfNat.ofNat, HAdd.hAdd, Array.size]]
[instOrOpUInt8,[OrOp.mk, UInt8.lor]]
[Nat.gcd_eq_left_iff_dvd,[Iff.intro, Eq.mpr, Eq.refl, Eq, Nat.gcd, Nat.gcd_rec, HMod.hMod, Nat.mod_eq_zero_of_dvd, OfNat.ofNat, Nat.gcd_zero_left, rfl, Nat.gcd_dvd_right]]
[Nat.instCommSemiringNat.proof_1,[of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.succ_mul, Nat.add_comm, HMul.hMul, eq_self, HAdd.hAdd]]
[iff_of_false,[Iff.intro, Not.elim]]
[Int.neg_add_lt_left_of_lt_add,[Eq.mpr, Eq.refl, LT.lt, HAdd.hAdd, Neg.neg, Int.add_comm, Int.sub_left_lt_of_lt_add]]
[Nat.pred_lt,[LT.lt, Nat.pred, absurd, rfl, Nat.lt_succ_of_le, Nat.le_refl, Nat.succ]]
[iff_iff_and_or_not_and_not,[Decidable.iff_iff_and_or_not_and_not]]
[SizeOf.sizeOf,[]]
[instInhabitedDepArrow,[Inhabited.mk, arbitrary]]
[toLBoolM,[Bind.bind, Pure.pure, Bool.toLBool]]
[Array.getMax?,[dite, LT.lt, OfNat.ofNat, Array.size, Option.some, Array.foldl, ite, Eq, Bool.true, Option.none]]
[Nat.le_of_not_lt,[Or.resolve_left, Nat.lt_or_ge]]
[Option.toMonad,[Unit.unit, Alternative.failure, Pure.pure]]
[not_iff_false_intro,[iff_false_intro, not_not_intro]]
[as_false,[ite, False, True]]
[DoResultBC.noConfusionType,[]]
[optionCoe,[CoeTail.mk, Option.some]]
[Nat.lcm_zero_right,[Nat.lcm_zero_left, Nat.lcm_comm, OfNat.ofNat]]
[NonScalar.noConfusionType,[]]
[UInt16.instSemiringUInt16,[Semiring.mk, UInt16.instSemiringUInt16.proof_1, UInt16.instSemiringUInt16.proof_2, UInt16.mk, Semiring.nsmul, UInt16.val, UInt16.instSemiringUInt16.proof_3, UInt16.instSemiringUInt16.proof_4, UInt16.instSemiringUInt16.proof_5, UInt16.instSemiringUInt16.proof_6, UInt16.instSemiringUInt16.proof_7, UInt16.instSemiringUInt16.proof_8, UInt16.instSemiringUInt16.proof_9, UInt16.instSemiringUInt16.proof_10, UInt16.instSemiringUInt16.proof_11, UInt16.instSemiringUInt16.proof_12, UInt16.instSemiringUInt16.proof_13]]
[ulift.up_down,[Eq, ulift.up, ulift.down, rfl]]
[Substring.str,[]]
[List.forIn.loop,[Pure.pure, Bind.bind, PProd.fst]]
[Classical.exists_true_of_nonempty,[Exists, True, Exists.intro, trivial]]
[List.length_dropLast,[Unit.unit, Eq, List.length, List.dropLast, HSub.hSub, OfNat.ofNat, rfl]]
[StateRefT'.run,[Bind.bind, ST.mkRef, ST.Ref.get, Pure.pure, Prod.mk]]
[Int.neg_mul_neg,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Int.mul_neg_eq_neg_mul_symm, Neg.neg, Int.neg_mul_eq_neg_mul_symm, Int.neg_neg, HMul.hMul, eq_self]]
[USize.instRingUSize,[Ring.mk, USize.instRingUSize.proof_1, USize.mk, Ring.gsmul, USize.val, USize.instRingUSize.proof_2, USize.instRingUSize.proof_3, USize.instRingUSize.proof_4, USize.instRingUSize.proof_5]]
[and_iff_left_iff_imp,[Iff.intro, And.right, Iff.mpr, and_iff_left_of_imp]]
[Int.lt_neg_add_of_add_lt,[]]
[LawfulMonad.toLawfulApplicative,[]]
[instShiftRightUInt32,[ShiftRight.mk, UInt32.shiftRight]]
[List.take,[List, List.nil, List.cons, PProd.fst]]
[Nat.add_le_add_right,[Eq.mpr, Eq.refl, LE.le, HAdd.hAdd, Nat.add_comm, Nat.add_le_add_left]]
[Int.negOfNat_eq_subNatNat_zero,[Unit.unit, Eq, Int.negOfNat, Int.subNatNat, OfNat.ofNat, rfl]]
[UInt16.toUInt32,[Nat.toUInt32, UInt16.toNat]]
[Subtype.existsOfSubtype,[Subtype.existsOfSubtype.proof_1]]
[Nat.eq_of_mul_eq_mul_right,[Nat.eq_of_mul_eq_mul_left, Eq.mp, Eq.refl, Eq, HMul.hMul, Nat.mul_comm]]
[UInt64.div,[UInt64.mk, HDiv.hDiv, UInt64.val]]
[Function.left_inverse_inv_fun,[]]
[instInhabitedList_1,[Inhabited.mk, List.nil]]
[instReprSubstring,[Repr.mk, Std.Format.text, HAppend.hAppend, String.quote, Substring.toString]]
[Subtype.map_comp,[rfl]]
[Mul.noConfusionType,[]]
[BinaryHeap.popMaxAux.proof_3,[Eq.mpr, Eq.refl, LT.lt, OfNat.ofNat, Array.size, BinaryHeap.arr, Nat.succ_pos]]
[true_ne_false,[ne_false_of_self, trivial]]
[Nat.div_eq,[congrFun, WellFounded.fix_eq, WellFoundedRelation.wf, measure, id, dite, And, LT.lt, OfNat.ofNat, LE.le, HAdd.hAdd, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le, Nat.zero, dif_eq_if, HDiv.hDiv]]
[Iff.subst,[Eq.subst, propext]]
[UInt16.decEq,[Decidable, Eq, dite, Decidable.isTrue, UInt16.decEq.proof_1, Decidable.isFalse, UInt16.decEq.proof_2]]
[EStateM.dummyRestore,[]]
[congr_arg,[congrArg]]
[Array.get_eq_get,[rfl]]
[Dvd.noConfusionType,[]]
[Nat.nat_repr_len_aux,[Eq.mpr, implies_congr, congrArg, LT.lt, Nat.pow_succ, Eq.refl, HDiv.hDiv, HPow.hPow, Iff.mpr, Nat.div_lt_iff_lt_mul]]
[not_and_self,[False]]
[Decidable.and_iff_not_or_not,[Eq.mpr, Eq.refl, Iff, And, Not, Or, Eq.symm, propext, Decidable.not_and_distrib, Decidable.not_not, Iff.rfl]]
[ST.Ref.modifyGet,[liftM, ST.Prim.Ref.modifyGet]]
[instMonadFinallyStateRefT',[inferInstanceAs, MonadFinally, ReaderT, ST.Ref]]
[Nat.le_or_le,[Or.imp_left, Nat.le_of_lt, Nat.lt_or_ge]]
[USize.size_positive,[usize_size_gt_zero]]
[Array.Â«term__[_:]Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Array.mkArray,[Array.mk, List.replicate]]
[not_and_self_iff,[Iff.intro, False, False.elim]]
[EStateM.instMonadFinallyEStateM,[MonadFinally.mk, EStateM.Result, Prod, Option.some, EStateM.Result.ok, Prod.mk, EStateM.Result.error, Option.none]]
[Int.mul_le_mul_of_nonneg_left,[Decidable.em, LE.le, of_eq_true, Eq.trans, congrArg, HMul.hMul, le_antisymm, eq_true, le_refl, Eq.symm, OfNat.ofNat, congr, congrFun, Int.zero_mul, eq_true_of_decide, Eq.refl, Bool.true, And.left, le_not_le_of_lt, Int.mul_lt_mul_of_pos_left, lt_of_le_not_le]]
[min,[ite, LE.le]]
[Ring.noConfusionType,[]]
[plift.down,[]]
[unexpandSubtype,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[Array.findSomeRevM?.find.proof_1,[Nat.lt_of_lt_of_le, Nat.lt_succ_self]]
[Mathlib.ExtendedBinder.extBinderCollection,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.unary, Mathlib.ExtendedBinder.extBinderParenthesized]]
[seqRight_eq_bind,[Eq.mpr, Eq.refl, Eq, SeqRight.seqRight, Bind.bind, LawfulApplicative.seqRight_eq, of_eq_true, Eq.trans, congrFun, congrArg, Seq.seq, map_eq_pure_bind, id, seq_eq_bind_map, Pure.pure, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, id_eq, bind_pure, eq_self]]
[Set.univ,[setOf, True]]
[Nat.not_lt,[Iff.intro, Nat.le_of_not_lt, Nat.not_lt_of_le]]
[EStateM.pure,[EStateM.Result.ok]]
[Function.Equiv.symm,[Eq.symm]]
[CommGroup.noConfusionType,[]]
[Classical.propComplete,[Or, Eq, True, False, Classical.em, Or.inl, propext, Iff.intro, True.intro, Or.inr, False.elim]]
[gsmul_rec,[nsmul_rec, Neg.neg, Nat.succ]]
[Array.getSepElems,[Array.getEvenElems]]
[List.disjoint,[False]]
[List.nil_eq_append_iff,[Eq.mpr, Eq.refl, Iff, Eq, List.nil, HAppend.hAppend, And, propext, eq_comm, List.append_eq_nil, Iff.rfl]]
[instDecidableEqFin,[Decidable, Eq, decEq, Fin.val, Decidable.isTrue, Fin.eq_of_val_eq, Decidable.isFalse, Fin.ne_of_val_ne]]
[String.any,[String.anyAux, String.bsize, OfNat.ofNat]]
[DoResultPR.return.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[congrFun,[rfl]]
[MonadState.get,[]]
[Int.decLt,[Decidable, Int.NonNeg, Decidable.isTrue, Int.NonNeg.mk, Decidable.isFalse, Eq.refl, Int.negSucc, HEq.refl, False, HSub.hSub, HAdd.hAdd, OfNat.ofNat]]
[Nat.sub_succ,[rfl]]
[or_left_comm,[Eq.mpr, Eq.refl, Iff, Or, Eq.symm, propext, or_assoc, or_comm, Iff.rfl]]
[Nat.succ_pred_eq_of_pos,[Eq.refl, Nat.zero, HEq.refl, Eq, Nat.succ, Nat.pred, rfl]]
[And.noConfusionType,[]]
[HOr.hOr,[]]
[List.asString,[String.mk]]
[EStateM,[EStateM.Result]]
[Nat.foldRev.loop,[PProd.fst]]
[List.getLastD,[List.getLast, List.cons, List.getLastD.proof_1]]
[Squash.lift,[Quot.lift, Squash.lift.proof_1]]
[instCoeNatInt,[Coe.mk, Int.ofNat]]
[iff_iff_implies_and_implies,[Iff.intro, And.intro, Iff.mp, Iff.mpr, And.left, And.right]]
[UInt16.toUInt8,[Nat.toUInt8, UInt16.toNat]]
[UInt32.modn,[UInt32.mk, HMod.hMod, UInt32.val]]
[instSubsingletonForall,[instSubsingletonForall.proof_1]]
[add_right_eq_self,[Eq.mpr, Eq.refl, Iff, Eq, HAdd.hAdd, OfNat.ofNat, Eq.symm, propext, add_left_cancel_iff, add_zero, Iff.rfl]]
[UInt64.add,[UInt64.mk, HAdd.hAdd, UInt64.val]]
[Subtype.restrict_injective,[Function.injective.comp, Subtype.coe_injective]]
[Nat.add_eq,[rfl]]
[Except.error.injEq,[Eq.propIntro, Eq.refl, Except.error, Eq.symm, eq_of_heq, HEq.refl]]
[Squash.mk,[Quot.mk, True]]
[OptionT.instAlternativeOptionT,[Alternative.mk, OptionT.fail, OptionT.orElse]]
[Nat.lt_trichotomy,[Nat.lt_by_cases, Or.inl, Function.comp, Or.inr]]
[Task.Priority,[Nat]]
[Nat.land,[Nat.bitwise, and]]
[UInt64.zero_def,[rfl]]
[instOfNatUInt8,[OfNat.mk, UInt8.ofNat]]
[UInt8.instSemiringUInt8.proof_12,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HMul.hMul, UInt8.add_def, UInt8.mul_def, UInt8.mk, HAdd.hAdd, UInt8.val, UInt8.eq_of_val_eq, Semiring.add_mul]]
[Ordering.eq.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[List.product,[List.bind, List.map, Prod.mk]]
[imp_self,[iff_true_intro, id]]
[Fin.add,[Fin, Fin.mk, HMod.hMod, HAdd.hAdd, Fin.add.proof_1]]
[StateT.run_seqLeft,[]]
[Fin.lor,[Fin, Fin.mk, HMod.hMod, Nat.lor, Fin.lor.proof_1]]
[MonadControlT.noConfusionType,[]]
[USize.add_def,[rfl]]
[Decidable.not_imp_not,[Iff.intro, Decidable.by_contradiction, mt]]
[or_iff_right_of_imp,[Iff.intro, id, Or.inr]]
[UInt64.decEq.proof_2,[absurd]]
[instCoeStringError,[Coe.mk, IO.userError]]
[FloatArray.noConfusionType,[]]
[Function.comp.right_id,[rfl]]
[left_distributive,[Eq]]
[List.takeD,[List, List.nil, List.cons, List.headD, PProd.fst, List.tail]]
[UInt32.instSemiringUInt32.proof_13,[UInt32.eq_of_val_eq, Eq.mpr, congrArg, Eq, Fin.ofNat', HAdd.hAdd, OfNat.ofNat, Fin.size_positive', UInt32.val, Eq.trans, UInt32.mk, UInt32.one_def, UInt32.add_def]]
[Option.choice_isSome_iff_nonempty,[Iff.intro, Nonempty.intro, Option.get, Eq.mpr, Eq.refl, Eq, Option.isSome, dite, Nonempty, Option.some, Classical.choice, Option.none, Bool.true, dif_pos, Option.isSome_some]]
[Mathlib.ExtendedBinder.Â«termSatisfiesBinderPred%__Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instSemiringFin.proof_14,[of_eq_true, Eq.trans, congrArg, Eq, Fin.mk, HMod.hMod, HAdd.hAdd, OfNat.ofNat, Nat.mod_lt, Fin.size_positive', Fin.add_def, Fin.mk.injEq, Fin.val, Fin.size_positive, congrFun, Fin.one_def, Nat.add_mod_mod, Nat.mod_add_mod, eq_self]]
[String.decEq,[Decidable, Eq, dite, Decidable.isTrue, String.decEq.proof_1, Decidable.isFalse, String.decEq.proof_2]]
[Nat.sub_add_min_cancel,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HSub.hSub, min, Nat.sub_eq_sub_min, Nat.sub_add_cancel, min_le_left, rfl]]
[Function.Equiv.trans,[Eq.trans]]
[Tactic.Ring.subst_into_pow,[Eq.mpr, Eq.refl, Eq, HPow.hPow, rfl]]
[Semiring.ofNat_succ,[]]
[Array.instForInArray,[ForIn.mk, Array.forIn]]
[exists_eq',[Exists.intro, rfl]]
[HEq.ndrecOn,[]]
[String.csize_pos,[Char.utf8Size_pos]]
[MonadFunctor.monadMap,[]]
[Â«term_>_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[List.length_erasep_of_mem,[Eq.mpr, Eq.refl, congr, congrArg, Eq, List.length_append, Nat.pred, Eq.trans, List.length, List.cons, HAdd.hAdd, List.length_cons, rfl]]
[Function.bijective_iff_exists_unique,[Iff.intro, ExistsUnique, Eq, Exists.intro, And.intro, Function.bijective.injective, Eq.trans, Eq.symm, unique_of_exists_unique, rfl, ExistsUnique.exists]]
[ExceptT.seqRight_eq,[]]
[List.append_inj_left,[And.left, List.append_inj]]
[ULift.noConfusionType,[]]
[Hashable.noConfusionType,[]]
[right_cancelative,[Eq]]
[List.mem_constructor,[Exists, Eq, List.nil, HAppend.hAppend, List.cons, Eq.refl, Eq.mpr, Exists.intro, rfl, Eq.symm, List.cons_append]]
[MProd.noConfusionType,[]]
[congr,[rfl]]
[le_of_lt_or_eq,[LE.le, le_of_lt, le_refl]]
[List.card_remove_of_mem,[Eq, List.card, HAdd.hAdd, List.remove, OfNat.ofNat, False.elim, List.not_mem_nil, Decidable.em, Eq.mpr, congrArg, List.cons, congrFun, if_pos, List, Mem.mem, Eq.symm, Eq.refl]]
[UInt8.instAddSemigroupUInt8.proof_1,[congrArg, UInt8.mk, AddSemigroup.add_assoc, UInt8.val]]
[ST.Prim.Ref.modifyGet,[Bind.bind, ST.Prim.Ref.get, ST, ST.Prim.Ref.set, Pure.pure]]
[List.get?,[List.nil, Option, Option.some, PProd.fst, Option.none]]
[UInt64.val,[]]
[or,[Unit.unit, Bool, Bool.true]]
[UInt32.div,[UInt32.mk, HDiv.hDiv, UInt32.val]]
[List.foldlIdx,[List.foldlIdxAux, OfNat.ofNat]]
[List.drop,[List, List.nil, PProd.fst]]
[instSTWorld,[STWorld.mk]]
[instCommRingFin.proof_1,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.mul_def, congrFun, HMod.hMod, Nat.mul_comm, eq_self, HMul.hMul]]
[List.Â«term_<+:_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[ByteSlice.toString,[Id.run, Bind.bind, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield]]
[Function.has_uncurry.noConfusionType,[]]
[List.erase_eq_erasep,[rfl, Decidable.em, Eq, of_eq_true, Eq.trans, congr, congrArg, List.erase, List.cons, List.erase_cons_head, List.erasep_cons_of_pos, congrFun, eq_self, Eq.symm, List.erase_cons_tail, ne_eq, Not, eq_false, Ne.symm, eq_true_of_decide, Eq.refl, Bool.true, List.erasep_cons_of_neg, List.erasep]]
[Mathlib.Tactic.Conv.convLHS,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.Conv.convSeq]]
[instCommSemigroup,[CommSemigroup.mk, CommMonoid.mul_comm]]
[UInt64.mul_def,[rfl]]
[and_congr_right',[and_congr, Iff.rfl]]
[Monoid.npow,[]]
[Equiv.to_fun_as_coe,[rfl]]
[UInt8.size,[OfNat.ofNat]]
[rawNatLit,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Function.injective_of_partial_inv_right,[Eq.trans, Eq.symm, Iff.mp]]
[Int.sub_right_lt_of_lt_add,[]]
[ExistsUnique.elim,[Exists.elim, And.left, And.right]]
[String.takeWhile,[Substring.toString, Substring.takeWhile, String.toSubstring]]
[Tactic.Cache.mk,[liftM, IO.mkRef, Sum.inl]]
[Substring.dropWhile,[Substring, Substring.mk]]
[Prod.swap_left_inverse,[Prod.swap_swap]]
[Prod.RProdSubLex.proof_1,[Prod.Lex.left, Eq.symm, eq_of_heq, Eq.refl, HEq.refl]]
[Â«termâˆƒ!_,_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
[decidableEq_of_decidableLe.proof_1,[le_refl]]
[Bool.and_self,[rfl, Eq.symm, Eq.refl]]
[tacticCalc_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, calcStep]]
[Semigroup.toMul,[]]
[USize.instSemiringUSize.proof_1,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, USize.zero_def, USize.add_def, USize.mk, OfNat.ofNat, add_zero, USize.val, USize.mk_val_eq, eq_self, propext, forall_const, USize]]
[AddGroup.add_left_neg,[]]
[Quot.recOn,[Quot.rec]]
[List.map_eq_mapTR,[funext, of_eq_true, Eq.trans, congrArg, Eq, List.map, List.mapTRAux_eq, List.nil, congrFun, HAppend.hAppend, List.reverse_nil, List.nil_append, eq_self]]
[List.drop_eq_nil_of_le,[Eq, List.drop, List.nil, rfl, Eq.symm, Eq.refl, OfNat.ofNat, HEq.refl]]
[Nat.mul_add,[Nat.left_distrib]]
[Int.NonNeg.elim,[Iff.mp, Int.nonneg_def]]
[ExceptCpsT,[]]
[BinaryHeap.mk.injEq,[Eq.propIntro, Eq.refl, BinaryHeap.mk, Eq.symm, eq_of_heq, HEq.refl]]
[ByteArray.uset,[ByteArray, ByteArray.mk, Array.uset]]
[Set.diff,[setOf, And, Mem.mem, Not]]
[List.append_eq_cons_iff,[of_eq_true, Eq.trans, congr, congrArg, Iff, congrFun, Eq, List.nil_append, List.cons, Or, And, eq_self, List.nil, true_and, Exists, funext, eq_false', HAppend.hAppend, false_and, eq_false, exists_false, or_false, iff_self, Eq.symm, Eq.mpr, List.cons_append, List.cons.injEq, false_or, Iff.intro, Exists.intro, eq_true_of_decide, Eq.refl, Bool.true, And.intro, rfl]]
[Array.toPArray,[Array.toPersistentArray]]
[Option.some.injEq,[Eq.propIntro, Eq.refl, Option.some, Eq.symm, eq_of_heq, HEq.refl]]
[Array.toArrayLit.proof_1,[Nat.le_refl, Array.size]]
[instToStringFormat,[ToString.mk, Std.Format.pretty, Std.Format.defWidth]]
[Array.foldrMUnsafe,[ite, LE.le, Array.size, LT.lt, USize.ofNat, Pure.pure, Array.foldrMUnsafe.fold]]
[Fin.one_def,[]]
[Set.singletonUnexpander,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesIdent, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit]]
[List.map_cons,[rfl]]
[String.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Semiring.npow_zero',[]]
[subtypeCoe,[CoeHead.mk, Subtype.val]]
[not_and_of_not_left,[mt, And.left]]
[instXorUSize,[Xor.mk, USize.xor]]
[MonoidWithZero.toMonoid,[]]
[instOfNatFloat,[OfNat.mk, Float.ofNat]]
[UInt32.instSemiringUInt32.proof_7,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt32.one_def, UInt32.mul_def, UInt32.mk, OfNat.ofNat, one_mul, UInt32.val, UInt32.mk_val_eq, eq_self, propext, forall_const, UInt32]]
[not_exists_of_forall_not,[Iff.mpr, exists_imp_distrib]]
[Int.le_sub_one_of_lt,[Int.le_sub_right_of_add_le]]
[Int.natAbs_one,[rfl]]
[Except.orElseLazy,[Except, Except.ok, Unit.unit]]
[addParenHeuristic,[ite, Eq, or, String.isPrefixOf, Bool.true, not, String.any, Char.isWhitespace, HAppend.hAppend]]
[Set.powerset,[setOf, Subset.subset]]
[Inv.inv,[]]
[UInt64.eq_of_val_eq,[Eq, congrArg, UInt64.mk]]
[UInt16.decEq.proof_1,[rfl]]
[Nat.div_eq_sub_div,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HAdd.hAdd, HSub.hSub, OfNat.ofNat, Nat.div_eq, ite, And, LT.lt, LE.le, if_pos, And.intro, rfl]]
[FloatArray.uset,[FloatArray, FloatArray.mk, Array.uset]]
[Mathlib.Tactic.rename',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[Nat.toUInt8,[UInt8.ofNat]]
[BinaryHeap.popMaxAux,[Subtype, Eq, BinaryHeap.size, HSub.hSub, OfNat.ofNat, Array.size, BinaryHeap.arr, BinaryHeap.popMaxAux.proof_1, Subtype.mk, BinaryHeap.popMaxAux.proof_2]]
[not_true,[iff_false_intro, not_not_intro, trivial]]
[Function.inv_fun_on_mem,[And.left, Function.inv_fun_on_pos]]
[Prod.swap_bijective,[And.intro, Prod.swap_injective, Prod.swap_surjective]]
[Subtype.exists,[Iff.intro, Exists, Subtype.mk, Exists.intro]]
[GroupWithZero.mul_inv_cancel,[]]
[Int.add_lt_of_lt_sub_right,[]]
[List.mapâ‚‚Right,[List.mapâ‚‚Left, flip]]
[USize.zero_def,[rfl]]
[coeOfTail,[CoeHTCT.mk, coeTail]]
[PLift.down,[]]
[Int.mul_le_mul_of_nonpos_right,[]]
[Tactic.DeclCache.get,[Bind.bind, Tactic.Cache.get, Prod.fst, Lean.MonadEnv.getEnv, ForIn.forIn, Lean.Meta.MetaM, ForInStep, Prod.snd, Pure.pure, PUnit.unit, ForInStep.yield]]
[Fin.lor.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[StateT.instMonadLiftStateT,[MonadLift.mk, StateT.lift]]
[InvImage.accessible,[InvImage.accessible.proof_1]]
[iff_mpr_iff_true_intro,[rfl]]
[Tactic.NormCast.NormCastExtension.mk.inj,[And.intro]]
[Id.instLawfulMonadId.proof_1,[LawfulMonad.mk, rfl]]
[List.disjoint_of_disjoint_cons_left,[List.disjoint_of_subset_left, List.subset_cons]]
[PSigma.lexAccessible,[PSigma.lexAccessible.proof_1]]
[instMonadWithReader,[MonadWithReader.mk, withTheReader]]
[instReprPUnit,[Repr.mk, Std.Format.text]]
[instLTFin,[LT.mk, LT.lt, Fin.val]]
[PSigma.lexNdepWf.proof_1,[WellFounded.intro, Acc, PSigma.lexNdep, PSigma.lexAccessible, WellFounded.apply]]
[instMonadWithReaderOf,[MonadWithReaderOf.mk, MonadFunctorT.monadMap, withTheReader]]
[Int.instModInt,[Mod.mk, Int.mod]]
[OrOp.or,[]]
[Tactic.Ring.horner_add_const,[of_eq_true, Eq.trans, congr, congrArg, Eq, add_assoc, HMul.hMul, HPow.hPow, HAdd.hAdd, Eq.symm, eq_self]]
[Decidable.byCases,[]]
[List.zipWithâ‚ƒ,[List.nil, List.cons, List, PProd.fst]]
[Function.right_inverse.left_inverse,[]]
[AddMonoid.toAddSemigroup,[]]
[Prod.fst_eq_iff,[Iff, Eq, Prod.fst, Prod.mk, Prod.snd, of_eq_true, Eq.trans, congrArg, Prod.mk.injEq, And, eq_self, and_true, iff_self]]
[LawfulMonad.bind_map,[]]
[UInt64.instSemiringUInt64.proof_13,[UInt64.eq_of_val_eq, Eq.mpr, congrArg, Eq, Fin.ofNat', HAdd.hAdd, OfNat.ofNat, Fin.size_positive', UInt64.val, Eq.trans, UInt64.mk, UInt64.one_def, UInt64.add_def]]
[Option.format,[Unit.unit, Std.Format, Std.Format.text, HAppend.hAppend, Std.ToFormat.format]]
[Array.forIn.loop.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self]]
[Option.bind_map_comm,[of_eq_true, Eq.trans, congr, congrArg, Eq, Option.none_bind, Option.map, congrFun, Option.bind, Option.map_none', id, eq_self, Option.none, Eq.symm, Option.some_bind, Option.map_some', id_eq, Eq.refl]]
[Nat.coprime.gcd_mul_left_cancel,[Nat.dvd_antisymm, Nat.dvd_gcd, Nat.coprime.dvd_of_dvd_mul_left, Nat.gcd_dvd_left, HMul.hMul, Nat.gcd_dvd_right, Nat.gcd_dvd_gcd_mul_left]]
[List.get?_eq_none_iff,[Iff.intro, Classical.byContradiction, List.get?_len_le]]
[Nat.beq,[Unit.unit, Bool, Bool.true, Bool.false, PProd.fst]]
[List.getLast?,[Unit.unit, Option, Option.none, Option.some, List.getLast, List.cons, List.getLast?.proof_1]]
[or_iff_left_iff_imp,[Iff.intro, Iff.mp, Or.inr, or_iff_left_of_imp]]
[List.mmapFilter,[Unit.unit, List, Pure.pure, List.nil, Bind.bind, PProd.fst, List.cons]]
[EStateM.Result.noConfusionType,[]]
[Array.binInsertM,[ite, Eq, Array.isEmpty, Bool.true, Bind.bind, Unit.unit, Pure.pure, Array.push, Array.get!, OfNat.ofNat, Array.insertAt, not, Array.modifyM, Array.back, HSub.hSub, Array.size]]
[coeOfTC,[CoeHTCT.mk, coeTC]]
[List.mapWithPrefixSuffixAux,[List, List.nil, List.cons, PProd.fst, List.concat]]
[Id.instMonadId,[Monad.mk]]
[mul_left_cancel_iff,[Iff.intro, mul_left_cancel, congrArg, HMul.hMul]]
[heq_of_eq_rec_left,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, HEq, HEq.rfl]]
[EStateM.instOrElseEStateM,[OrElse.mk, EStateM.orElse]]
[List.Forallâ‚‚.brecOn,[List.Forallâ‚‚.below.nil, List.Forallâ‚‚.below.cons]]
[coeOfHeadOfTC,[CoeHTCT.mk, coeTC, coeHead]]
[ShiftRight.noConfusionType,[]]
[Nat.succ_sub_succ_eq_sub,[rfl, congrArg, Nat.pred]]
[Semigroup.noConfusionType,[]]
[Int.le_of_lt_add_one,[Int.le_of_add_le_add_right]]
[Subarray.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Int.mul_neg_of_neg_of_pos,[]]
[Array.insertionSort.swapLoop,[Array, Eq.refl]]
[imp_iff_right,[Iff.intro, imp_intro]]
[Option.orElse,[Option, Option.some, Unit.unit]]
[System.FilePath.mk.injEq,[Eq.propIntro, Eq.refl, System.FilePath.mk, Eq.symm, eq_of_heq, HEq.refl]]
[List.singleton_append,[rfl]]
[Nat.mul_le_mul,[Nat.le_trans, Nat.mul_le_mul_right, Nat.mul_le_mul_left]]
[Nat.gcd_succ,[rfl]]
[UInt64.instAddCommSemigroupUInt64,[AddCommSemigroup.mk, UInt64.instAddCommSemigroupUInt64.proof_1]]
[Subtype.map.proof_1,[Subtype.val, Subtype.prop]]
[instHXor,[HXor.mk, Xor.xor]]
[reprArg,[Repr.reprPrec, OfNat.ofNat]]
[Nat.left_distrib,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Nat.zero, HAdd.hAdd, Nat.zero_mul, OfNat.ofNat, rfl, congr, congrArg, Eq.trans, Nat.succ_mul, congrFun, Nat.add_assoc, Nat.add_left_comm]]
[CoeTC.noConfusionType,[]]
[List.foldr,[Unit.unit, PProd.fst]]
[Function.right_inverse.comp,[Function.left_inverse.comp]]
[And.imp,[And.intro, And.left, And.right]]
[Array.all,[Id.run, Array.allM]]
[StateRefT'.instMonadStateRefT',[inferInstanceAs, Monad, ReaderT, ST.Ref]]
[Tactic.instInhabitedDeclCache,[inferInstanceAs, Inhabited, Prod, Tactic.Cache, Lean.Meta.MetaM]]
[Semiring.nsmul_succ',[]]
[instNonempty.proof_1,[Nonempty.intro, arbitrary]]
[Subtype.equiv_iff,[Iff.rfl]]
[Nat.add_right_cancel,[Nat.add_left_cancel, Eq.mp, Eq.refl, Eq, HAdd.hAdd, Nat.add_comm]]
[List.join_nil,[rfl]]
[List.leftpad_prefix,[Exists.intro, rfl]]
[Array.set,[Array.mk, List.set, Array.data, Fin.val]]
[UInt32.lor,[UInt32.mk, Fin.lor, UInt32.val]]
[String.toInt!,[Unit.unit, Int, String.toInt?, panic]]
[instInhabitedProp,[Inhabited.mk, True]]
[Array.append,[Array.foldl, Array.push, OfNat.ofNat, Array.size]]
[List.get.proof_1,[Nat.le_of_succ_le_succ, List.length_cons]]
[LT.lt,[]]
[coeOfDep,[CoeT.mk, coeD]]
[bind_pure_unit,[Eq.mpr, Eq.refl, Eq, Bind.bind, Pure.pure, PUnit.unit, bind_pure, rfl]]
[ByteSlice.noConfusionType,[]]
[and_symm_right,[Iff.intro, And, Eq, And.intro, Eq.symm]]
[List.bind_map,[Unit.unit, Eq, List.map, List.bind, rfl, of_eq_true, Eq.trans, congr, congrArg, List.cons_bind, List.map_append, HAppend.hAppend, PProd.fst, eq_self]]
[List.get_append,[Eq.refl, List.length, List.nil, HEq.refl, Eq, List.get, HAppend.hAppend, rfl, PProd.fst, Nat.add, Nat.le_of_succ_le_succ, List.length_cons, List.append]]
[Int.ofNat_one,[rfl]]
[List.forall_mem_nil,[Eq.refl]]
[UInt8.toChar_aux,[Eq.mpr, Eq.refl, Nat.isValidChar, Fin.val, UInt32.val, UInt32.ofNat, UInt32.val_eq_of_lt, Nat.lt_trans, of_decide_eq_true, Bool.true, Or.inl]]
[NeqIffBeqFalse,[Iff.intro, decide_eq_false, of_decide_eq_false]]
[liftCoeM,[Bind.bind, liftM, Pure.pure, coe]]
[instSemiringFin.proof_9,[Eq.mpr, Eq.refl, Eq, HMul.hMul, OfNat.ofNat, instSemiringFin.proof_4, instSemiringFin.proof_2]]
[MonadReader.noConfusionType,[]]
[Group.mul_left_inv,[]]
[Option.not_isSome_iff_eq_none,[of_eq_true, Eq.trans, congr, congrArg, Iff, Not, congrFun, Eq, Option.isSome_none, Bool.true, eq_false', eq_true_of_decide, Eq.refl, eq_self, Option.none, Eq.symm, Option.isSome_some, eq_false_of_decide, Bool.false]]
[Prod.swap_surjective,[Function.right_inverse.surjective, Prod.swap_left_inverse]]
[Nat.coprime.pow_left,[Nat.coprime_one_left]]
[instInhabitedOrdering,[Inhabited.mk, Ordering.lt]]
[Nat.mul_sub_right_distrib,[Eq, HMul.hMul, HSub.hSub, of_eq_true, Eq.trans, congr, congrArg, congrFun, Nat.sub_zero, Nat.zero_mul, eq_self, Eq.mpr, Eq.refl, HAdd.hAdd, OfNat.ofNat, Nat.sub_succ, Nat.pred, Nat.mul_pred_left, PProd.fst, Nat.succ_mul, Nat.sub_sub, rfl]]
[String.bsize,[String.utf8ByteSize]]
[instSemiringFin.proof_5,[Fin.eq_of_val_eq, Eq.mpr, congrFun, congrArg, Eq, Eq.trans, Fin.val, Fin.mul_def, OfNat.ofNat, HMod.hMod, HMul.hMul, Fin.one_def, False.elim, Fin.elim0, Eq.symm, Nat.succ, Nat.lt_or_eq_of_le, Nat.mod_le, of_eq_true, Nat.mul_one, Nat.mod_eq_of_lt, Fin.isLt, eq_self, Eq.refl]]
[UInt64.mk_val_eq,[Eq, UInt64.mk, UInt64.val, rfl]]
[Int.nonneg_or_nonneg_neg,[Or, Int.NonNeg, Neg.neg, Or.inl, Int.NonNeg.mk, Or.inr, Nat.succ]]
[bind_pure,[]]
[Fin.instInhabitedFinHAdd,[Inhabited.mk, OfNat.ofNat]]
[USize.instSemiringUSize.proof_7,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, USize.one_def, USize.mul_def, USize.mk, OfNat.ofNat, one_mul, USize.val, USize.mk_val_eq, eq_self, propext, forall_const, USize]]
[Array.findSomeRevM?.find.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self]]
[AddMonoid.toZero,[]]
[randBool,[Prod, Bool, Prod.mk, Decidable.decide, Eq, OfNat.ofNat]]
[Nat.lt_of_add_lt_add_left,[Nat.lt_of_le_of_ne, Nat.le_of_add_le_add_left, Nat.le_of_lt, Nat.lt_irrefl, HAdd.hAdd, Eq.mp, Eq.refl, LT.lt]]
[Option.map_congr,[of_eq_true, Eq.trans, congr, congrArg, Eq, Option.map_none', eq_self, Option.none, Eq.symm, Option.map_some', Option.some, propext, Option.mem_def, Eq.refl]]
[Int.mul,[Int, Int.ofNat, HMul.hMul, Int.negOfNat, Nat.succ]]
[instSubsingletonStateM,[instSubsingletonStateM.proof_1]]
[instReprAtomBool,[ReprAtom.mk]]
[Int.le_add_of_nonneg_right,[]]
[Function.bijective.injective,[And.left]]
[String.map,[String.mapAux, OfNat.ofNat]]
[ULift.up_down,[Eq, ULift.up, ULift.down, rfl]]
[Seq.seq,[]]
[System.instCoeStringFilePath,[Coe.mk, System.FilePath.mk]]
[coeSort,[CoeSort.coe]]
[Tactic.Ring.HornerExpr.xadd',[Bind.bind, Tactic.Ring.mkAppCS, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Tactic.Ring.HornerExpr.e, Prod.fst, List.nil, Pure.pure, Tactic.Ring.HornerExpr.xadd]]
[ByteArray.data,[]]
[String.Range.toLspRange,[Lean.Lsp.Range.mk, Lean.FileMap.utf8PosToLspPos, String.Range.start, String.Range.stop]]
[String.push,[String, String.mk, HAppend.hAppend, List.cons, List.nil]]
[Mathlib.Tactic.Lint.checkAllSimpLemmaInfos,[Bind.bind, Mathlib.Tactic.Lint.withSimpLemmaInfos, Option.mapM, Lean.addMessageContextFull, ite, Eq, Array.isEmpty, Bool.true, Pure.pure, Option.none, Option.some, Lean.MessageData.joinSep, Array.toList, Lean.MessageData.ofFormat, Std.Format.line]]
[Function.Equiv,[Eq]]
[List.get?_eq_get,[Eq.refl, List.length, List.nil, HEq.refl, Eq, List.get?, Option.some, List.get, rfl, PProd.fst, Nat.le_of_succ_le_succ, List.length_cons, Nat.add]]
[USize.modn,[USize.mk, HMod.hMod, USize.val]]
[Array.insertionSort,[OfNat.ofNat, Array.size, Array.insertionSort.traverse, Array.insertionSort.swapLoop]]
[Float.ofInt,[Float, Float.ofNat, Float.neg, Nat.succ]]
[inv_mul_cancel_left,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Inv.inv, Eq.symm, mul_assoc, mul_left_inv, OfNat.ofNat, one_mul, rfl]]
[Char.instDecidableLe,[UInt32.decLe, Char.val]]
[UInt8.noConfusionType,[]]
[Repr.addAppParen,[ite, GE.ge, OfNat.ofNat, Std.Format.paren]]
[Nat.gcd_mul_right_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.gcd_comm, Nat.gcd_mul_right_left, rfl]]
[List.append_inj_right',[And.right, List.append_inj']]
[true_iff_false,[iff_false_intro, Iff.mp, trivial]]
[EStateM.throw,[EStateM.Result.error]]
[Nat.find_x.proof_3,[absurd, Nat.not_lt_zero]]
[ToStream.toStream,[]]
[String.trim,[Substring.toString, Substring.trim, String.toSubstring]]
[Unit.ext,[rfl]]
[Array.setD,[dite, LT.lt, Array.size, Array.set, Fin.mk]]
[Nat.sub_le_sub_right,[Unit.unit, LE.le, HSub.hSub, Nat.pred_le_pred, PProd.fst]]
[String.Iterator.remainingBytes,[Nat, HSub.hSub, String.bsize]]
[and_self_right,[Iff.intro, And.intro, And.left, And.right]]
[StateT.monadControl,[MonadControl.mk, Prod, Bind.bind, MonadState.get, liftM, StateT.run, StateT, MonadStateOf.set, Pure.pure]]
[System.FilePath.instHDivFilePathStringFilePath,[HDiv.mk, System.FilePath.join, System.FilePath.mk]]
[List.map_eq_append_split,[]]
[Group.noConfusionType,[]]
[Squash,[Quot, True]]
[UInt8.mod_def,[rfl]]
[BinaryHeap.replaceMax.proof_1,[Eq.refl, BinaryHeap.max]]
[Substring.takeWhile,[Substring, Substring.mk]]
[UInt16.instSemigroupUInt16,[Semigroup.mk, UInt16.instSemigroupUInt16.proof_1]]
[Array.toArrayLit_eq',[Array.toArrayLit_eq'.aux]]
[Int.sign_of_succ,[rfl]]
[Int.le_add_of_neg_add_le_left,[Int.le_add_of_sub_left_le, Eq.mp, Eq.refl, LE.le, HAdd.hAdd, Neg.neg, Int.add_comm]]
[Array.getLit.proof_1,[Eq.symm]]
[Ordering.toCtorIdx,[OfNat.ofNat]]
[Array.findSomeRev?,[Id.run, Array.findSomeRevM?]]
[List.get_map_rev,[Eq.symm, List.get_map, List.length_map]]
[Int.ofNat_add,[rfl]]
[true_and,[propext, Iff.intro, And.right, And.intro, trivial]]
[Array.zipWith,[Array.zipWithAux, OfNat.ofNat, List.toArray, List.nil]]
[Nat.mod_two_eq_zero_or_one,[Or, Eq, OfNat.ofNat, HMod.hMod, Nat.mod_lt, of_eq_true, eq_true_of_decide, Eq.refl, Bool.true, Or.inl, rfl, Or.inr, absurd, Nat.not_lt_zero, Nat.lt_of_succ_lt_succ]]
[UInt32.instRingUInt32,[Ring.mk, UInt32.instRingUInt32.proof_1, UInt32.mk, Ring.gsmul, UInt32.val, UInt32.instRingUInt32.proof_2, UInt32.instRingUInt32.proof_3, UInt32.instRingUInt32.proof_4, UInt32.instRingUInt32.proof_5]]
[exists_congr,[Iff.intro, exists_imp_exists, Iff.mp, Iff.mpr]]
[Int.coe_nat_inj,[Int.ofNat.inj]]
[Mathlib.Tactic.Lint.LintVerbosity.low.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[ofBoolUsing_eq_false,[of_decide_eq_false]]
[Decidable.eq_or_lt_of_le,[Or.symm, Decidable.lt_or_eq_of_le]]
[or_of_or_of_imp_left,[Or.imp_left]]
[instOrdInt,[Ord.mk, compareOfLessAndEq]]
[Nat.mod_le,[LE.le, HMod.hMod, Nat.lt_or_ge, Eq.mpr, Eq.refl, Nat.mod_eq_of_lt, Nat.le_refl, Nat.eq_zero_or_pos, OfNat.ofNat, Nat.mod_zero, Nat.le_trans, Nat.le_of_lt, Nat.mod_lt]]
[bfix5,[PProd.fst]]
[String.Range.contains,[and, Decidable.decide, LE.le, String.Range.start, LT.lt, String.Range.stop]]
[Monad.toApplicative,[]]
[Or.neg_resolve_right,[Or.elim, id, absurd]]
[Â«term#[_,]Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false]]
[List.disjoint_append_left,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, forall_congr, implies_congr, propext, List.mem_append, Eq.refl, False, or_imp_distrib, forall_and_distrib, And, iff_self]]
[UInt32.ofNatCore,[UInt32.mk, Fin.mk]]
[Nat.mul_self_sub_mul_self_eq,[Eq.mpr, Eq.refl, Eq, HSub.hSub, HMul.hMul, HAdd.hAdd, Nat.mul_sub_left_distrib, Nat.right_distrib, Nat.mul_comm, Nat.add_comm, Nat.add_sub_add_left, rfl]]
[rfl,[rfl.proof_1]]
[List.lt.brecOn,[List.lt.below.nil, List.lt.below.head, List.lt.below.tail]]
[List.Perm.swap',[]]
[PointedType.val,[]]
[UInt8.val,[]]
[USize.instAddSemigroupUSize,[AddSemigroup.mk, USize.instAddSemigroupUSize.proof_1]]
[List.Perm.Equivalence,[Equivalence.mk, List.Perm.refl, List.Perm.symm, List.Perm.trans]]
[IsAddRightCancel.noConfusionType,[]]
[Mathlib.Tactic.Conv.convRun_conv_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Nat.dvd_gcd_iff,[Iff.intro, And.intro, Nat.dvd_trans, And.left, Nat.gcd_dvd, And.right, Nat.dvd_gcd]]
[Array.foldr,[Id.run, Array.foldrM]]
[String.toNat!,[ite, Eq, String.isNat, Bool.true, String.foldl, HAdd.hAdd, HMul.hMul, OfNat.ofNat, HSub.hSub, Char.toNat, Char.ofNat, panicWithPosWithDecl]]
[Int.le_neg_of_le_neg,[]]
[System.Platform.getNumBits.proof_1,[Or.inr, rfl]]
[List.inj_on_of_subset,[]]
[Tactic.Ring.HornerExpr.reflConv,[Bind.bind, liftM, Lean.Meta.mkEqRefl, Tactic.Ring.HornerExpr.e, Pure.pure, Prod.mk]]
[Int.add_lt_add,[lt_trans, Int.add_lt_add_right, Int.add_lt_add_left]]
[termDepIfThenElse,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[emptyWf,[WellFoundedRelation.mk, emptyRelation, emptyWf.proof_1]]
[Nat.to_digits_core_lens_eq_aux,[Classical.em, Eq, HDiv.hDiv, OfNat.ofNat, of_eq_true, Eq.trans, congr, congrArg, List.length, ite_congr, congrFun, eq_true_of_decide, Eq.refl, Bool.true, List.cons, Nat.digitChar, HMod.hMod, Nat.toDigitsCore, if_true, HAdd.hAdd, eq_self, Eq.symm, Eq.mpr, eq_false, if_false, Eq.mp, implies_congr, trivial]]
[Option.elim_some,[rfl]]
[Quot.rec,[Quot.liftIndepPr1, PSigma.snd, Quot.lift, Quot.indep, Quot.indepCoherent]]
[Function.left_inverse,[Eq]]
[optParam,[]]
[List.get_append_right,[Option.some.inj, Eq.mpr, Eq.refl, Eq, Option.some, List.get, HAppend.hAppend, HSub.hSub, List.length, List.get_append_right_aux, Eq.symm, List.get?_eq_get, List.get?, List.get?_append_right, rfl]]
[GroupWithZero.toDivInvMonoid,[]]
[StateCpsT.instMonadStateCpsT,[Monad.mk]]
[implies_true,[propext, Iff.intro, trivial, True.intro]]
[String.posOf,[String.posOfAux, String.bsize, OfNat.ofNat]]
[CoeSort.noConfusionType,[]]
[FloatArray.isEmpty,[BEq.beq, FloatArray.size, OfNat.ofNat]]
[funext,[]]
[Nat.gcd_zero_right,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, Nat.gcd, Nat.zero_eq, OfNat.ofNat, Nat.gcd_zero_left, eq_true_of_decide, Eq.refl, Bool.true, Eq.symm, Nat.gcd_succ, Nat.zero_mod, Nat.succ, eq_self]]
[eq_min,[le_antisymm, le_min, min, min_le_left, min_le_right]]
[Int.add_neg_cancel_right,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, Int.add_assoc, Int.add_right_neg, OfNat.ofNat, Int.add_zero, rfl]]
[Subtype.coe_eta,[Subtype.ext, rfl]]
[instNegFloat,[Neg.mk, Float.neg]]
[List.reverse,[List.reverseAux, List.nil]]
[Array.mapMUnsafe.map,[ite, LT.lt, Bind.bind, unsafeCast, Array.mapMUnsafe.map, HAdd.hAdd, OfNat.ofNat, Array.uset, lcProof, Pure.pure]]
[Â«term_Ã—'_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.bracketedExplicitBinders, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[true_or,[propext, Iff.intro, trivial, Or.inl]]
[or_congr_right,[or_congr, Iff.rfl]]
[ExceptT.bind_pure_comp,[rfl]]
[instLEUInt16,[LE.mk, UInt16.le]]
[Fin.overflowingMul,[Prod.mk, Decidable.decide, LE.le, HMul.hMul, Fin.val]]
[Sum.inl.injEq,[Eq.propIntro, Eq.refl, Sum.inl, Eq.symm, eq_of_heq, HEq.refl]]
[congr_arg2,[rfl]]
[Semiring.nsmul,[]]
[Fin.val_ne_of_ne,[absurd, Fin.eq_of_val_eq]]
[List.ofFnAux,[List, PProd.fst, Nat.le_of_lt, List.cons, Fin.mk]]
[UInt16.decLt,[Decidable, LT.lt, inferInstanceAs]]
[instShiftRightUInt8,[ShiftRight.mk, UInt8.shiftRight]]
[Nat.sub_one,[rfl]]
[Array.foldlM,[dite, LE.le, Array.size, Array.foldlM.proof_1]]
[Array.forInUnsafe,[OfNat.ofNat, Array.forInUnsafe.loop]]
[instHashableUInt64,[Hashable.mk]]
[instMonadStateOf,[MonadStateOf.mk, liftM, MonadStateOf.get, MonadStateOf.set, MonadLiftT.monadLift, MonadState.modifyGet]]
[ST.Ref.set,[liftM, ST.Prim.Ref.set]]
[of_iff_true,[Iff.mpr, True.intro]]
[UInt32.instSemiringUInt32.proof_4,[congrArg, UInt32.mk, AddMonoid.nsmul_succ', UInt32.val]]
[BinaryHeap.popMaxAux.proof_1,[Eq.refl, Array.size, BinaryHeap.arr]]
[String.isPrefixOf,[String.substrEq, OfNat.ofNat, String.bsize]]
[Nat.coprime_mul_iff_left,[Iff.intro, And.intro, Nat.coprime.coprime_mul_right, Nat.coprime.coprime_mul_left, Nat.coprime, HMul.hMul, Eq.mpr, Eq.refl, propext, Nat.coprime_iff_gcd_eq_one, Eq, Nat.gcd, OfNat.ofNat, Nat.coprime.gcd_mul_left_cancel]]
[OfNat.ofNat,[]]
[UInt32.one_def,[rfl]]
[Nat.le_of_le_of_sub_le_sub_right,[Nat.zero_le, Eq.symm, LE.le, Nat.succ, Nat.zero, Nat.not_succ_le_zero, Eq.refl, Nat.succ_le_succ, Nat.le_of_succ_le_succ, Eq.mp, congr, congrArg, Nat.succ_sub_succ]]
[ReaderT.orElse,[HOrElse.hOrElse, Unit.unit]]
[UInt16.one_def,[rfl]]
[ExceptT.finally,[MonadFinally.mk, ExceptT.mk, Bind.bind, MonadFinally.tryFinally', Option.none, Option.some, Except.error, Except, Except.ok, Prod, Pure.pure, Prod.mk]]
[instCommMonoid_1.proof_4,[Semiring.npow_succ']]
[String.Iterator.i,[]]
[String.Range.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.mod_eq_zero_of_dvd,[Exists.elim, Eq.mpr, Eq.refl, Eq, HMod.hMod, OfNat.ofNat, HMul.hMul, Nat.mul_mod_right, rfl]]
[UInt32.zero_def,[rfl]]
[instHashableNat,[Hashable.mk, UInt64.ofNat]]
[Function.app,[]]
[Nat.gcd_comm,[Nat.dvd_antisymm, Nat.dvd_gcd, Nat.gcd_dvd_right, Nat.gcd_dvd_left]]
[Nat.find,[Subtype.val, Nat.find_x]]
[Nat.mul_pred_left,[Eq, HMul.hMul, Nat.pred, HSub.hSub, of_eq_true, Eq.trans, congr, congrArg, congrFun, Nat.pred_zero, Nat.zero_mul, Nat.zero_sub, eq_true_of_decide, Eq.refl, Bool.true, Eq.mpr, HAdd.hAdd, OfNat.ofNat, Nat.pred_succ, Nat.succ_mul, Nat.add_sub_cancel, rfl]]
[ByteArray.foldlM.loop,[dite, LT.lt, Unit.unit, Pure.pure, Bind.bind, ByteArray.get, Fin.mk, ByteArray.foldlM.loop.proof_1, PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[Function.injective_of_partial_inv,[Option.some.inj, Eq.trans, Eq.symm, Iff.mpr, rfl]]
[ST.Ref.noConfusionType,[]]
[LawfulApplicative.seqLeft_eq,[]]
[Not.imp_symm,[Not.decidable_imp_symm]]
[List.length_set,[rfl, Eq.symm, of_eq_true, Eq.trans, congr, congrArg, Eq, List.length_cons, Nat.succ, eq_self, List.length, Eq.refl]]
[iff_false_right,[Iff.trans, Iff.comm, iff_false_left]]
[Set,[]]
[Function.injective.dite,[]]
[tacticAny_goals_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.parser]]
[Or.symm,[Or, Or.inr, Or.inl]]
[USize.instSemiringUSize.proof_13,[USize.eq_of_val_eq, Eq.mpr, congrArg, Eq, Fin.ofNat', HAdd.hAdd, OfNat.ofNat, Fin.size_positive', USize.val, Eq.trans, USize.mk, USize.one_def, USize.add_def]]
[Or.left_comm,[Iff.trans, Iff.symm, Or.assoc, or_congr, Or.comm, Iff.refl]]
[termWithout_expected_type_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[String.Iterator.remainingToString,[String, String.extract, String.bsize]]
[EIO.mapTasks,[BaseIO.mapTasks, EIO.toBaseIO]]
[Int.mul_lt_mul_of_neg_left,[]]
[FloatArray.forInUnsafe.loop,[ite, LT.lt, Bind.bind, Pure.pure, FloatArray.forInUnsafe.loop, HAdd.hAdd, OfNat.ofNat]]
[EIO.toIO',[liftM, EIO.toBaseIO]]
[List.length,[Unit.unit, Nat, OfNat.ofNat, HAdd.hAdd, PProd.fst]]
[Nat.succ_lt_succ,[Nat.succ_le_succ]]
[Nat.eq_zero_of_nonpos,[Unit.unit, Eq, OfNat.ofNat, rfl, absurd, Nat.zero_lt_succ]]
[FloatSpec.float,[]]
[False.elim,[]]
[Option.getD_map,[rfl, Eq.symm, Eq.refl]]
[USize.instSemiringUSize.proof_11,[Eq.mpr, congr, congrArg, Eq, Eq.trans, HMul.hMul, USize.add_def, USize.mul_def, USize.mk, HAdd.hAdd, USize.val, USize.eq_of_val_eq, Semiring.mul_add]]
[guard,[ite, Pure.pure, Unit.unit, Alternative.failure]]
[if_simp_congr_prop,[if_ctx_simp_congr_prop]]
[Int.instNumericInt,[Numeric.mk, Int.ofNat]]
[Nat.gcd_dvd_right,[And.right, Nat.gcd_dvd]]
[ByteSliceT.noConfusionType,[]]
[instMonadLiftT_1,[MonadLiftT.mk]]
[eq_false_of_decide,[propext, Iff.intro, absurd, of_decide_eq_false, False.elim]]
[CommMonoid.toMonoid,[]]
[instToStringUSize,[ToString.mk, ToString.toString, USize.toNat]]
[PSigma.lex.proof_1,[WellFounded.intro, Acc, PSigma.Lex, PSigma.lexAccessible, WellFounded.apply]]
[Mathlib.ExtendedBinder.Â«termâˆƒáµ‰_,_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Mathlib.ExtendedBinder.extBinders, Lean.ParserDescr.cat]]
[GroupWithZero.mul_zero,[]]
[String.nextWhile,[String.bsize]]
[List.mapâ‚‚Left,[List, List.nil, List.map, Option.none, List.cons, Option.some, PProd.fst]]
[List.Perm_comm,[Iff.intro, List.Perm.symm]]
[Nat.prod_dvd_and_dvd_of_dvd_prod,[Nat.gcd, Nat.prod_dvd_and_dvd_of_dvd_prod.proof_1, Nat.prod_dvd_and_dvd_of_dvd_prod.proof_2, Nat.prod_dvd_and_dvd_of_dvd_prod.proof_4]]
[instToFormatOption,[Std.ToFormat.mk, Option.format]]
[Nat.le.intro,[Nat.le_add_right]]
[instRingFin.proof_3,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, Semiring.nsmul_succ', HAdd.hAdd, Semiring.nsmul, eq_self, propext, forall_const, Fin, Nat]]
[Fin.subUnderflows?,[Decidable.decide, LT.lt, Fin.val]]
[Int.mod,[Int, Int.ofNat, HMod.hMod, Nat.succ, Neg.neg]]
[Nat.foldRevM.loop,[Pure.pure, Bind.bind, PProd.fst]]
[Array.mapIdxM.map.proof_2,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, OfNat.ofNat, Array.size, Eq.symm, Nat.add_comm, Nat.add_assoc, rfl]]
[Decidable.not_or_iff_and_not,[Iff.intro, And, Not, False.elim, Or.inl, Or.inr, And.intro, False, Or.elim]]
[Int.add_pos_of_pos_of_nonneg,[Int.add_lt_add_of_lt_of_le, Int.zero_add, OfNat.ofNat]]
[Eq.to_iff,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Iff, Iff.rfl]]
[EStateM.tryCatch,[EStateM.Result.ok, EStateM.Result, EStateM.Backtrackable.restore]]
[Subarray.anyM,[Array.anyM, Subarray.as, Subarray.start, Subarray.stop]]
[instMonadFunctorT,[MonadFunctorT.mk, MonadFunctor.monadMap, MonadFunctorT.monadMap]]
[Subtype.restrict,[Subtype.val]]
[List.length_concat,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, List.length_cons, Nat.succ, congrFun, HAdd.hAdd, OfNat.ofNat, eq_self, List.length]]
[OptionT.fail,[OptionT.mk, Pure.pure, Option.none]]
[instOrdNat,[Ord.mk, compareOfLessAndEq]]
[Ring.gsmul_succ',[]]
[HShiftLeft.noConfusionType,[]]
[Monad.noConfusionType,[]]
[Int.le_add_of_neg_le_sub_left,[Int.le_add_of_neg_add_le_left, Int.add_le_of_le_sub_right]]
[getModify,[MonadState.modifyGet, Prod.mk]]
[Function.decidable_eq_pfun.proof_1,[Iff.symm, Function.funext_iff]]
[Iff.comm,[Iff.intro, Iff.symm]]
[Nat.add_lt_add_right,[Nat.add_lt_add_left, Nat.add_comm]]
[instCommMonoid,[CommMonoid.mk, CommGroup.mul_comm]]
[UInt8.instSemiringUInt8.proof_5,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, congrFun, HMul.hMul, UInt8.zero_def, UInt8.mul_def, UInt8.mk, OfNat.ofNat, MonoidWithZero.zero_mul, UInt8.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt8]]
[BinaryHeap.popMaxAux.proof_2,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HSub.hSub, OfNat.ofNat, Nat.zero_sub, eq_true_of_decide, Eq.refl, Bool.true]]
[stdNext,[Prod, Nat, StdGen, Prod.mk, Int.toNat, StdGen.mk]]
[Mathlib.Tactic.Ext.mkIff,[Lean.mkApp2, Lean.mkConst, Lean.Name.mkStr, Lean.Name.anonymous, List.nil]]
[Option.decidable_forall_mem,[Unit.unit, Decidable, Decidable.isTrue, Option.decidable_forall_mem.proof_1, dite, Option.decidable_forall_mem.proof_2, Decidable.isFalse, Option.decidable_forall_mem.proof_3]]
[HEq.rfl.proof_1,[HEq.refl]]
[Array.pop,[Array.mk, List.dropLast, Array.data]]
[Int.lt_add_of_pos_left,[]]
[lt_or_ge,[lt_or_le]]
[Function.surjective.of_comp,[Exists, Eq, Exists.intro]]
[Char.utf8Size.proof_6,[of_decide_eq_true, Eq.refl, Bool.true]]
[List.erase_subset,[Eq.mpr, Eq.refl, Subset.subset, List.erase, List.erase_eq_erasep, List.erasep_subset]]
[Â«term_/\_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Tactic.Ring.subst_into_add,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, rfl]]
[WellFounded.fix',[WellFounded.fix]]
[Mathlib.Tactic.Lint.NamedLinter.noConfusionType,[]]
[Option.isNone_iff_eq_none,[Iff.intro, Option.eq_none_of_isNone, rfl, Eq.symm]]
[instReprSSet,[Repr.mk, Repr.addAppParen, HAppend.hAppend, reprArg, Lean.SSet.toList, Std.Format.text]]
[instComplementUSize,[Complement.mk, USize.complement]]
[Set.instMemSet,[Mem.mk, Set.mem]]
[String.utf16PosToCodepointPosFrom,[OfNat.ofNat]]
[Nat.forM,[Nat.forM.loop]]
[instToStreamStringSubstring,[ToStream.mk, String.toSubstring]]
[String.data,[]]
[Int.add_neg_of_nonpos_of_neg,[Int.add_lt_add_of_le_of_lt, Int.zero_add, OfNat.ofNat]]
[Classical.typeDecidableEq,[inferInstance]]
[Mathlib.Tactic.Lint.Linter.noConfusionType,[]]
[List.toChunksAux,[Prod, List, Prod.mk, List.nil, List.cons]]
[HSub.noConfusionType,[]]
[instDecidableAnd.proof_1,[And.right]]
[Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp,[Trans.mk, Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp.proof_1]]
[Function.right_inverse.surjective,[Exists.intro]]
[List.instSubsetList,[Subset.mk, List.subset]]
[StateT.run_seqRight,[]]
[seq_eq_bind_map,[Eq.mpr, Eq.refl, Eq, Seq.seq, Bind.bind, Functor.map, Eq.symm, LawfulMonad.bind_map, rfl]]
[LinearOrder.toPartialOrder,[]]
[not_non_contradictory_iff_absurd,[Iff.intro, mt, not_not_intro]]
[Function.cantor_surjective,[False]]
[instMonadControlStateRefT',[inferInstanceAs, MonadControl, ReaderT, ST.Ref]]
[Option.instDecidableRelLt,[Unit.unit, Decidable, Option.lt, Decidable.isTrue, trivial, Decidable.isFalse, not_false]]
[Mathlib.Tactic.Lint.instDecidableEqLintVerbosity,[dite, Eq, Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx, Decidable.isTrue, Mathlib.Tactic.Lint.instDecidableEqLintVerbosity.proof_1, Decidable.isFalse, Mathlib.Tactic.Lint.instDecidableEqLintVerbosity.proof_2]]
[Fin.instAndOpFin,[AndOp.mk, Fin.land]]
[UInt32.instAddSemigroupUInt32.proof_1,[congrArg, UInt32.mk, AddSemigroup.add_assoc, UInt32.val]]
[and_not_self_iff,[Iff.intro, And.right, And.left, False.elim]]
[prod_map,[rfl, Eq.symm, Eq.refl]]
[instAddCommMonoid_1.proof_1,[AddCommSemigroup.add_comm]]
[Nat.foldRev,[Nat.foldRev.loop]]
[eq_or_lt_of_not_lt,[dite, Eq, Or.inl, Or.inr, lt_of_not_ge, lt_of_le_of_ne]]
[String.Range.stop,[]]
[Nat.decidable_dvd,[decidable_of_decidable_of_iff, inferInstance, Nat.decidable_dvd.proof_1]]
[Char.repr,[Char.quote]]
[Tactic.Ring.addAtom,[Bind.bind, MonadState.get, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, liftM, Lean.Meta.isDefEq, Array.getOp, Tactic.Ring.State.atoms, ite, Eq, Bool.true, Pure.pure, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, Tactic.Ring.RingM, Nat, MProd.fst]]
[Tactic.NormCast.addSquash,[Bind.bind, Lean.Meta.addSimpLemma, Tactic.NormCast.pushCastExt, Bool.false, Tactic.NormCast.NormCastExtension.squash, Tactic.NormCast.normCastExt, Tactic.NormCast.NormCastExtension.down]]
[Array.get?_set_ne,[of_eq_true, Eq.trans, congr, congrArg, Eq, Array.get?_eq_get?, Array.mk, List.set, Array.data, Fin.val, List.get?_set_ne, eq_self, List.get?]]
[EStateM.run',[Option, EStateM.run, Option.some, Option.none]]
[Nat.add_mod_left,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, Nat.add_comm, Nat.add_mod_right, rfl]]
[UInt32.sub_def,[rfl]]
[Nat.lt_of_le_of_ne,[LT.lt, Nat.lt_or_ge, absurd, Nat.le_antisymm]]
[Union.noConfusionType,[]]
[Char.toString,[String.singleton]]
[UInt64.instSemigroupUInt64,[Semigroup.mk, UInt64.instSemigroupUInt64.proof_1]]
[tryCatchThe,[MonadExceptOf.tryCatch]]
[fixCore6,[bfix6, USize.size]]
[UInt64.size,[OfNat.ofNat]]
[Subtype.ext_val,[Subtype.ext]]
[Int.neg_of_neg_pos,[]]
[HMul.noConfusionType,[]]
[Nat.mul_pred_right,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Nat.pred, HSub.hSub, Nat.mul_comm, Nat.mul_pred_left, rfl]]
[Tactic.Ring.HornerExpr.instCoeHornerExprExpr,[Coe.mk, Tactic.Ring.HornerExpr.e]]
[Fin.size_positive,[LT.lt, OfNat.ofNat, Nat.eq_or_lt_of_le, Nat.zero_le, Eq.symm, Nat.lt_trans]]
[ByteArray.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instToStringIterator,[ToString.mk, String.Iterator.remainingToString]]
[List.disjoint_symm,[]]
[List.instLEList,[LE.mk, List.le]]
[instReprSigma,[Repr.mk, Std.Format, Std.Format.bracket, HAppend.hAppend, repr, Std.Format.text]]
[fix,[fixCore1, arbitrary]]
[Function.left_inverse.injective,[rfl]]
[Int.eq_of_sub_eq_zero,[]]
[ByteArray.toList,[OfNat.ofNat, List.nil, ByteArray.toList.loop]]
[forall_not_of_not_exists,[Exists.intro]]
[List.disjoint_singleton,[Eq.mpr, Eq.refl, Iff, List.disjoint, List.cons, List.nil, Not, Mem.mem, propext, List.disjoint_comm, List.singleton_disjoint, Iff.rfl]]
[Nat.decLt,[Nat.decLe, Nat.succ]]
[Exists.elim,[]]
[List.eq_nil_of_length_eq_zero,[rfl]]
[withTheReader,[MonadWithReaderOf.withReader]]
[And.comm,[Iff.intro, And.symm]]
[Â«term_Ã—_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Subtype.heq_iff_coe_heq,[]]
[Functor.discard,[Functor.mapConst, PUnit.unit]]
[decidable_eq_of_bool_pred.proof_1,[absurd, Eq.mp, Eq.refl, Not, Eq, Bool.true]]
[Int.neg_add,[]]
[max_assoc,[eq_max, le_trans, le_max_left, max, max_le, le_max_right]]
[Mathlib.Tactic.Lint.LintVerbosity.ofNat,[cond, Nat.ble, Nat.beq, Mathlib.Tactic.Lint.LintVerbosity.medium, Mathlib.Tactic.Lint.LintVerbosity.high, Mathlib.Tactic.Lint.LintVerbosity.low]]
[coeDecidableEq,[inferInstanceAs, Decidable, Eq, Bool.true]]
[UInt32.toNat,[Fin.val, UInt32.val]]
[List.get?_zero,[rfl, Eq.symm, Eq.refl]]
[Substring.startPos,[]]
[Function.left_id,[rfl]]
[MonadFunctor.noConfusionType,[]]
[List.sublists'Aux,[List, List.cons, List.nil, PProd.fst, Function.comp]]
[LinearOrder.decidable_le,[]]
[Ordering.gt.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[BinaryHeap.mkHeap.loop.proof_3,[le_of_lt, Nat.lt_of_succ_le, Eq.symm, Subtype.property, BinaryHeap.heapifyDown, Fin.mk]]
[Nat.find_min',[Iff.mp, not_lt, Nat.find_min]]
[instHAppend,[HAppend.mk, Append.append]]
[String.congr_append,[Eq, HAppend.hAppend, String.mk, String.data, rfl]]
[UInt8.instSemiringUInt8.proof_7,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt8.one_def, UInt8.mul_def, UInt8.mk, OfNat.ofNat, one_mul, UInt8.val, UInt8.mk_val_eq, eq_self, propext, forall_const, UInt8]]
[Nat.coprime.gcd_both,[Nat.coprime.gcd_right, Nat.coprime.gcd_left]]
[instHasEquiv,[HasEquiv.mk, Setoid.r]]
[not_and,[and_imp]]
[Semiring.npow,[]]
[List.eraseReps,[Unit.unit, List, List.nil, List.eraseRepsAux]]
[DoResultPRBC.break.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Mathlib.Tactic.Ext.tacticExt__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[SizeOf.noConfusionType,[]]
[decidable_of_decidable_of_iff,[dite, Decidable.isTrue, Iff.mp, Decidable.isFalse, decidable_of_decidable_of_iff.proof_1]]
[Function.curry_apply,[rfl]]
[Option.map_eq_map,[rfl]]
[PProd.fst,[]]
[Quot.hrecOn,[Quot.recOn, Quot.hrecOn.proof_1]]
[Or.elim3,[Or.elim]]
[Nat.exists_eq_succ_of_ne_zero,[Exists.intro, Nat.pred, Or.resolve_left, Nat.eq_zero_or_eq_succ_pred]]
[Prod.id_prod,[funext, Eq, Prod.mk, Prod.fst, Prod.snd, id, rfl]]
[Prod.mk.inj_left,[And.right, Prod.mk.inj]]
[List.isSuffixOf,[List.isPrefixOf, List.reverse]]
[Prod.Lex.decidable.proof_1,[Iff.symm, Prod.lex_def]]
[StateT.lift,[Bind.bind, Pure.pure, Prod.mk]]
[Or.resolve_right,[Or.elim, id, absurd]]
[Int.ofNat_succ,[rfl]]
[Int.nonneg_def,[Iff.intro, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Exists, Eq, Int.ofNat, Exists.intro, rfl, Int.NonNeg, Int.NonNeg.mk]]
[String.decEq.proof_1,[congrArg, String.mk]]
[Functor.map,[]]
[runST,[Unit, Unit.unit]]
[instToStringPUnit,[ToString.mk]]
[FloatArray.set,[FloatArray, FloatArray.mk, Array.set]]
[instOrElse,[OrElse.mk, Alternative.orElse]]
[instDecidableEqBool.proof_2,[]]
[lt_irrefl,[False, le_not_le_of_lt]]
[Nat.Â«term_^[_]Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[decidable_of_iff,[decidable_of_decidable_of_iff]]
[List.instDecidableMem.proof_1,[Or.inl]]
[instInhabitedStdGen,[Inhabited.mk, StdGen.mk, OfNat.ofNat]]
[instToStreamSubarraySubarray,[ToStream.mk]]
[Tactic.Ring.horner_const_mul,[of_eq_true, Eq.trans, congr, congrArg, Eq, mul_add, HMul.hMul, HPow.hPow, HAdd.hAdd, congrFun, Eq.symm, mul_assoc, eq_self]]
[Decidable.eq_or_ne,[dec_em, Eq]]
[Int.mul_lt_mul_of_pos_right,[]]
[UInt16.instAddCommSemigroupUInt16,[AddCommSemigroup.mk, UInt16.instAddCommSemigroupUInt16.proof_1]]
[List.ibelow,[True, And]]
[DivInvMonoid.noConfusionType,[]]
[Int.subNatNat_of_le,[Int.subNatNat_of_sub_eq_zero, Nat.sub_eq_zero_of_le]]
[Nat.sub_add_comm,[Iff.mpr, Nat.sub_eq_iff_eq_add, Nat.le_trans, Nat.le_add_right, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HSub.hSub, Nat.add_right_comm, Nat.sub_add_cancel, rfl]]
[instDecidableXor,[dite, Decidable.isFalse, instDecidableXor.proof_1, Decidable.isTrue, instDecidableXor.proof_2, instDecidableXor.proof_3, instDecidableXor.proof_4]]
[UInt64.instSemigroupUInt64.proof_1,[congrArg, UInt64.mk, Semigroup.mul_assoc, UInt64.val]]
[OptionM.run,[]]
[instReprSum,[Repr.mk, Std.Format, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg]]
[left_inv_eq_right_inv,[Eq.mpr, Eq.refl, Eq, Eq.symm, one_mul, HMul.hMul, OfNat.ofNat, mul_assoc, mul_one, rfl]]
[Nat.coprime.pow_right,[Nat.coprime.symm, Nat.coprime.pow_left]]
[instDecidableEqQuotient.proof_1,[instSubsingletonDecidable, Eq, Quotient.mk]]
[max_lt,[Or.elim, le_or_gt, Eq.mpr, Eq.refl, LT.lt, max, max_eq_right, max_eq_left_of_lt]]
[List.erasep,[Unit.unit, List, List.nil, ite, List.cons, PProd.fst]]
[Quotient.liftâ‚‚,[Quotient.lift, Quotient.liftâ‚‚.proof_1, Quotient.liftâ‚‚.proof_2]]
[EStateM.seqRight,[EStateM.Result, Unit.unit, EStateM.Result.error]]
[Nat.ibelow,[True, And]]
[or_self_left,[Iff.intro, Or.elim, Or.inl, id, Function.comp, Or.inr]]
[nonempty_of_exists,[Nonempty, Nonempty.intro]]
[Array.elem,[Array.contains]]
[BinaryHeap.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[IsMulLeftCancel.noConfusionType,[]]
[right_distributive,[Eq]]
[instOrElseEIO,[OrElse.mk, MonadExcept.orElse]]
[LawfulMonad.bind_pure_comp,[]]
[String.str,[String.push]]
[monadFunctorRefl,[MonadFunctorT.mk]]
[Int.le_sub_left_of_add_le,[]]
[List.instInterList,[Inter.mk, List.inter]]
[Array.foldlMUnsafe.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bind.bind, Array.uget, lcProof, Array.foldlMUnsafe.fold, HAdd.hAdd, OfNat.ofNat]]
[Array.anyM.loop.proof_1,[Nat.lt_of_lt_of_le]]
[Nat.instShiftLeftNat,[ShiftLeft.mk, Nat.shiftLeft]]
[UInt32.val_eq_of_eq,[Eq, UInt32.val, congrArg]]
[Function.injective.of_comp_iff',[Iff.intro, Eq, rfl, Function.injective.comp, Function.bijective.injective]]
[Nat.lt,[Nat.le, Nat.succ]]
[gt_trans,[lt_trans]]
[Int.instAddInt,[Add.mk, Int.add]]
[List.erase_append_right,[Eq.mpr, Eq.refl, Eq, List.erase, HAppend.hAppend, List.erase_eq_erasep, List.erasep, List.erasep_append_right, Eq.mp, Not, Mem.mem, rfl]]
[Â«term_&&&_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[UInt64.size_positive,[of_decide_eq_true, Eq.refl, Bool.true]]
[withPtrAddr,[OfNat.ofNat]]
[StateCpsT.runK_bind_get,[rfl]]
[StdGen.s1,[]]
[Nat.div_div_eq_div_mul,[Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, OfNat.ofNat, Nat.mul_zero, Nat.div_zero, rfl, Eq.symm, Nat.zero_mul, Nat.zero_div, Nat.le_antisymm, Iff.mpr, Nat.le_div_iff_mul_le, Nat.mul_pos, LE.le, Nat.mul_comm, Nat.mul_assoc, Iff.mp, Nat.le_refl]]
[UInt8.sub_def,[rfl]]
[instDecidableEqNat,[Nat.decEq]]
[UInt16.instSemiringUInt16.proof_6,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, HMul.hMul, UInt16.zero_def, UInt16.mul_def, UInt16.mk, OfNat.ofNat, MonoidWithZero.mul_zero, UInt16.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt16]]
[Array.toListLitAux,[List, PProd.fst, Array.toListLitAux.proof_1, List.cons, Array.getLit, Array.toListLitAux.proof_2]]
[ShiftLeft.shiftLeft,[]]
[Int.sub_add_cancel,[Int.neg_add_cancel_right]]
[Array.sequenceMap.loop,[dite, LT.lt, Array.size, Unit.unit, Array, Pure.pure, Bind.bind, Array.get, Fin.mk, PProd.fst, HAdd.hAdd, OfNat.ofNat, Array.push]]
[UInt8.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[bfix1,[PProd.fst]]
[List.cons_subset,[Eq.mpr, congr, congrArg, Iff, Eq.trans, propext, List.subset_def, forall_congr, implies_congr, List.mem_cons, Eq.refl, Mem.mem, or_imp_distrib, forall_and_distrib, congrFun, And, forall_eq, Iff.rfl]]
[Nat.case_strong_induction_on,[Nat.strong_induction_on, Unit.unit, Nat.lt_succ_of_le]]
[List.toArray_data,[List.toArrayAux_data, Array.mkEmpty, List.redLength]]
[instOrdChar,[Ord.mk, compareOfLessAndEq]]
[Function.Equiv.isEquivalence,[Equivalence.mk, Function.Equiv.refl, Function.Equiv.symm, Function.Equiv.trans]]
[ulift.down_up,[rfl]]
[Nat.add_left_cancel,[Eq.mpr, implies_congr, congr, congrArg, Eq, Eq.trans, congrFun, HAdd.hAdd, Nat.zero_eq, Nat.zero_add, Eq.refl, Nat.succ_add, Nat.succ.injEq]]
[List.eq_or_ne_mem_of_mem,[Classical.em, Eq, Or.inl, Eq.symm, Or.inr, And.intro, Or.resolve_left, Eq.refl]]
[IsAddRightCancel.add_right_cancel,[]]
[Â«term{__:_//_}Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[pow_one,[Eq.mpr, Eq.refl, Eq, HPow.hPow, OfNat.ofNat, Nat.one_eq_succ_zero, Nat.succ, pow_succ, HMul.hMul, pow_zero, one_mul, rfl]]
[Option.mem_toList,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, List.mem_nil, Option.mem_def, eq_false', eq_true_of_decide, Eq.refl, Bool.true, Eq.symm, List.mem_cons, Or, Eq, or_false, eq_comm, Option.some.injEq, iff_self]]
[UInt8.toUInt64,[Nat.toUInt64, UInt8.toNat]]
[Option.bind_some,[rfl, Eq.symm, Eq.refl]]
[Nat.add_mul_div_left,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HAdd.hAdd, HMul.hMul, Nat.zero, Nat.mul_zero, OfNat.ofNat, Nat.add_zero, rfl, Nat.succ, Nat.mul_succ, Eq.symm, Nat.add_assoc, Nat.add_div_right]]
[UInt16.add_def,[rfl]]
[Int.add_assoc,[Int.ofNat, Int.negSucc, Eq, HAdd.hAdd, Int.add_assoc_aux1, Eq.mpr, Eq.refl, Int.add_comm, Eq.symm, rfl, Int.add_assoc_aux2, of_eq_true, Eq.trans, congr, congrArg, congrFun, Int.negSucc_ofNat_add_negSucc_ofNat, Nat.succ, Nat.add_comm, Nat.add_succ, Nat.add_left_comm, eq_self]]
[Â«stx_,*Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Array.size_push,[List.length_concat, Array.data]]
[WellFounded.induction,[WellFounded.recursion]]
[USize.noConfusionType,[]]
[ToBool.toBool,[]]
[Prod.lex,[WellFoundedRelation.mk, Prod.Lex, WellFoundedRelation.rel, Prod.lex.proof_1]]
[Classical.epsilon_spec,[Classical.epsilon_spec_aux, nonempty_of_exists]]
[Tactic.Ring.HornerExpr.ibelow,[True, And]]
[instDecidableLt_4,[USize.decLt]]
[Option.decidable_exists_mem.proof_2,[Exists.intro, And.intro, rfl]]
[seqLeft_eq_bind,[Eq.mpr, Eq.refl, Eq, SeqLeft.seqLeft, Bind.bind, Pure.pure, LawfulApplicative.seqLeft_eq, of_eq_true, Eq.trans, congrFun, congrArg, Seq.seq, map_eq_pure_bind, Function.const, seq_eq_bind_map, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, Function.const_apply, eq_self]]
[StateT.run_monadMap,[rfl]]
[Option.get,[Eq.refl, Bool.true, HEq.refl]]
[List.range,[List.rangeAux, List.nil]]
[Option.any,[Unit.unit, Bool, Bool.false]]
[List.revzip,[List.zip, List.reverse]]
[Subsingleton.elim,[Subsingleton.elim.proof_1]]
[Int.negOfNat_add,[Unit.unit, Eq, HAdd.hAdd, Int.negOfNat, of_eq_true, Eq.trans, congr, congrArg, Nat.zero_eq, Nat.add_zero, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true, Eq.mpr, congrFun, Nat.succ, Nat.zero_add, rfl, Nat.succ_add]]
[UInt8.instNumericUInt8,[Numeric.mk, UInt8.mk, Numeric.ofNat]]
[Nat.instDecidableCoprime,[dite, Eq, Nat.gcd, OfNat.ofNat, Decidable.isTrue, Decidable.isFalse]]
[UInt32.instNegUInt32,[Neg.mk, UInt32.mk, Neg.neg, UInt32.val]]
[Eq.mp,[]]
[List.below,[PUnit, PProd]]
[Nat.dvd_antisymm,[dite, Eq, Nat.zero, Eq.symm, Nat.succ, Nat.eq_zero_of_zero_dvd, Nat.le_antisymm, Nat.le_of_dvd, Nat.succ_pos]]
[guardExprStrict,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[Int.sub_self,[Eq.mpr, Eq.refl, Eq, HSub.hSub, OfNat.ofNat, Int.sub_eq_add_neg, HAdd.hAdd, Neg.neg, Int.add_right_neg, rfl]]
[UInt32.toUInt16,[Nat.toUInt16, UInt32.toNat]]
[forall_congr',[Iff.intro, Iff.mp, Iff.mpr]]
[Option.get_of_mem,[Eq.symm, eq_of_heq, Eq.refl, Option.some, HEq.refl, Eq, Option.get, rfl]]
[Option.getD_some,[rfl]]
[String.length_append,[Eq, String.length, HAppend.hAppend, HAdd.hAdd, Eq.mpr, Eq.refl, String.mk, String.congr_append, List.length_append]]
[Equiv.trans.proof_1,[Function.left_inverse.comp, Equiv.leftInv]]
[and_false,[propext, Iff.intro, And.right, False.elim]]
[Tactic.DeclCache.mk,[Bind.bind, Tactic.Cache.mk, Lean.MonadOptions.getOptions, Lean.profileitM, Lean.Exception, Pure.pure, Lean.MonadEnv.getEnv, ForIn.forIn, Lean.Meta.MetaM, ForInStep, PUnit.unit, ForInStep.yield, Prod.mk]]
[Int.mul_one,[Eq.mpr, Eq.refl, Eq, HMul.hMul, OfNat.ofNat, Int.mul_comm, Int.one_mul, rfl]]
[Subarray.allM,[Array.allM, Subarray.as, Subarray.start, Subarray.stop]]
[Fin.val_eq_of_eq,[rfl]]
[FloatArray.instForInFloatArrayFloat,[ForIn.mk, FloatArray.forIn]]
[UInt8.ofNat,[UInt8.mk, Fin.ofNat]]
[List.ne_and_not_mem_of_not_mem_cons,[And.intro, List.ne_of_not_mem_cons, List.not_mem_of_not_mem_cons]]
[decidableBEx,[Unit.unit, Decidable, Exists, And, Mem.mem, Decidable.isFalse, decidableBEx.proof_1, dite, Decidable.isTrue, decidableBEx.proof_2, List.cons, PProd.fst, decidableBEx.proof_3, decidableBEx.proof_4]]
[String.toInt?,[OptionM.run, ite, Eq, String.get, OfNat.ofNat, Char.ofNat, Bind.bind, Substring.toNat?, Substring.drop, String.toSubstring, Pure.pure, Neg.neg, Int.ofNat, Functor.map, String.toNat?]]
[right_commutative,[Eq]]
[instSubsingletonPUnit,[Subsingleton.intro, PUnit.subsingleton]]
[Classical.indefiniteDescription.proof_1,[Nonempty, Subtype, Nonempty.intro, Subtype.mk]]
[instShiftLeftUSize,[ShiftLeft.mk, USize.shiftLeft]]
[Prod.fst_surjective,[Nonempty.elim, Exists.intro, Prod.mk, rfl]]
[if_neg,[Eq, ite, absurd, rfl]]
[Int.Â«term-[1+_]Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[notM,[Functor.map, not]]
[Nat.gcd_mul_right_left,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.mul_comm, Nat.gcd_mul_left_left, rfl]]
[Array.mapIdx,[Id.run, Array.mapIdxM]]
[Classical.typeDecidable.proof_1,[absurd, Nonempty.intro]]
[MonadExcept.orelse',[MonadExcept.tryCatch, MonadExcept.throw, ite, Eq, Bool.true]]
[Prod.swap_injective,[Function.left_inverse.injective, Prod.swap_left_inverse]]
[instHashableUInt32,[Hashable.mk, UInt32.toUInt64]]
[OptionT.instMonadExceptOfOptionT,[MonadExceptOf.mk, OptionT.mk, throwThe, tryCatchThe]]
[Nat.le_zero_iff,[Iff.intro, Nat.eq_zero_of_le_zero, le_refl]]
[Nat.dvd_lcm_right,[Nat.dvd_lcm_left, Nat.lcm_comm]]
[panic,[panicCore]]
[BinaryHeap.instInhabitedBinaryHeap,[Inhabited.mk, BinaryHeap.empty]]
[Array.get_push,[Classical.em, LT.lt, Fin.val, Array.size, Eq.mpr, congrArg, Eq, Array.get, Array.push, dif_pos, Option.some.inj, Eq.refl, Option.some, Fin.mk, Eq.symm, Array.get?_eq_get, Array.get?_push_lt, dif_neg, Array.get?, le_antisymm, Nat.le_of_lt_succ, Eq.mp, Array.size_push, le_of_not_lt, Array.get?_push_eq, rfl]]
[List.join_cons,[rfl]]
[Mathlib.ExtendedBinder.Â«binderTerm>_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Equiv.symm,[Equiv.mk, Equiv.invFun, Equiv.toFun, Equiv.rightInv, Equiv.leftInv]]
[Array.erase,[Unit.unit, Array, Array.indexOf?, Array.feraseIdx]]
[lt_or_gt_of_ne,[Or, LT.lt, GT.gt, lt_trichotomy, Or.inl, absurd, Or.inr]]
[instShiftLeftUInt32,[ShiftLeft.mk, UInt32.shiftLeft]]
[String.append,[String, String.mk, HAppend.hAppend]]
[Array.ext,[congrArg, Array.mk, Eq.symm, Eq.refl, Array.ext.extAux]]
[List.mmap',[Unit.unit, Unit, Pure.pure, SeqRight.seqRight, PProd.fst]]
[Int.ofNat_zero_le,[Iff.mpr, Int.ofNat_le, Nat.zero_le]]
[instDecidableLt_3,[UInt64.decLt]]
[ExceptT.instLawfulMonadExceptT,[ExceptT.instLawfulMonadExceptT.proof_1]]
[ByteSliceT.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, ByteSliceT.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Classical.skolem,[Iff.intro, Classical.axiomOfChoice, Exists, Exists.intro]]
[and,[Unit.unit, Bool, Bool.false]]
[Decidable.or_iff_not_imp_right,[Iff.trans, Or.comm, Decidable.or_iff_not_imp_left]]
[Int.subNatNat_add_negSucc_ofNat,[]]
[ExceptT.bind_throw,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, LawfulMonad.pure_bind, Except.error, Except, Pure.pure, eq_self]]
[Quotient.indâ‚‚,[Quotient.ind]]
[UInt16.ofNat,[UInt16.mk, Fin.ofNat]]
[Id.bind_eq,[rfl]]
[String.toFileMap,[Lean.FileMap.ofString]]
[Function.update,[dite, Eq, Eq.symm]]
[PSigma.revLexAccessible.proof_1,[Acc.intro, PSigma.mk, Eq.symm, eq_of_heq, Eq.refl, HEq.refl]]
[Decidable.not_iff_not,[Eq.mpr, Eq.refl, Iff, Not, propext, iff_def, And, iff_def', and_congr, Decidable.not_imp_not]]
[UInt32.decEq.proof_2,[absurd]]
[floatDecLe,[Float.decLe]]
[UInt16.instSemiringUInt16.proof_7,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt16.one_def, UInt16.mul_def, UInt16.mk, OfNat.ofNat, one_mul, UInt16.val, UInt16.mk_val_eq, eq_self, propext, forall_const, UInt16]]
[Â«term_â‰ˆ_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[fix6,[fixCore6, arbitrary]]
[List.Pairwise_cons,[Iff.intro, Eq.symm, eq_of_heq, Eq.refl, List.cons, HEq.refl, And, List.Pairwise, And.intro, And.elim, List.Pairwise.cons]]
[Nat.mul_dvd_mul_right,[Nat.mul_dvd_mul, Nat.dvd_refl]]
[Nat.add_mod_right,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, Nat.mod_eq_sub_mod, Nat.le_add_left, HSub.hSub, Nat.add_sub_cancel, rfl]]
[Equiv.refl,[Equiv.mk, id, Equiv.refl.proof_1, Equiv.refl.proof_2]]
[instInhabitedUInt32,[Inhabited.mk, UInt32.ofNatCore, OfNat.ofNat, instInhabitedUInt32.proof_1]]
[USize.ofNatCore,[USize.mk, Fin.mk]]
[Subarray.any,[Id.run, Subarray.anyM]]
[instOrdString,[Ord.mk, compareOfLessAndEq]]
[Subtype.val_prop,[Subtype.property]]
[Int.pos_of_neg_neg,[Int.lt_of_neg_lt_neg, Eq.mpr, Eq.refl, LT.lt, Neg.neg, OfNat.ofNat, Int.neg_zero]]
[Option.filter,[Unit.unit, Option, ite, Eq, Bool.true, Option.some, Option.none]]
[Fin.shiftLeft,[Fin, Fin.mk, HMod.hMod, HShiftLeft.hShiftLeft, Fin.shiftLeft.proof_1]]
[Prod.forall',[Prod.forall]]
[Int.mul_self_le_mul_self,[Int.mul_le_mul, le_trans]]
[Â«term_*>_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[UInt16.add,[UInt16.mk, HAdd.hAdd, UInt16.val]]
[Array.back,[Array.get!, HSub.hSub, Array.size, OfNat.ofNat]]
[List.replace,[List, List.nil, Unit.unit, BEq.beq, List.cons, PProd.fst]]
[Int.add_neg_cancel_left,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, Eq.symm, Int.add_assoc, Int.add_right_neg, OfNat.ofNat, Int.zero_add, rfl]]
[Function.partial_inv_of_injective,[Iff, Eq, Function.partial_inv, Option.some, Iff.intro]]
[List.allSome,[Unit.unit, Option, List, Option.some, List.nil, Functor.map, List.cons, PProd.fst, Option.none]]
[Except.map,[Except, Except.error, Except.ok]]
[Int.add_sub_cancel,[Int.add_neg_cancel_right]]
[USize.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd]]
[UInt8.eq_of_val_eq,[Eq, congrArg, UInt8.mk]]
[inferInstance,[]]
[Mod.noConfusionType,[]]
[List.mem_insert_iff,[Decidable.em, Mem.mem, Eq.mpr, Eq.refl, Iff, List.insert, Or, Eq, List.insert_of_mem, Iff.intro, Or.inr, Eq.symm, List.insert_of_not_mem, Iff.rfl]]
[System.FilePath.isCaseInsensitive,[or, System.Platform.isWindows, System.Platform.isOSX]]
[MonoidWithZero.noConfusionType,[]]
[Bool.or_self,[rfl, Eq.symm, Eq.refl]]
[FloatArray.get?,[dite, LT.lt, FloatArray.size, Option.some, FloatArray.get, Fin.mk, Option.none]]
[Option.bex_ne_none,[Iff.intro, Exists, Option.some, Exists.intro, Option.get, Iff.mp, Option.ne_none_iff_isSome, Eq.mpr, Eq.refl, Option.some_get, Option.some_ne_none]]
[decidable_of_decidable_of_eq,[decidable_of_decidable_of_iff, Eq.to_iff]]
[List.last.proof_2,[]]
[ExceptT.seq_eq,[rfl]]
[List.instEmptyCollectionList,[EmptyCollection.mk, List.nil]]
[FloatArray.forInUnsafe,[OfNat.ofNat, FloatArray.forInUnsafe.loop]]
[Prod.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[solve,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[Nat.lt.step,[Nat.lt.step.proof_1]]
[Char.quote,[HAppend.hAppend, Char.quoteCore]]
[Subsingleton.allEq,[]]
[instTransGtGeGt.proof_1,[gt_of_gt_of_ge]]
[USize.mul,[USize.mk, HMul.hMul, USize.val]]
[Int.negSucc.injEq,[Eq.propIntro, Eq.refl, Int.negSucc, Eq.symm, eq_of_heq, HEq.refl]]
[Function.right_inverse_surj_inv,[Function.surj_inv_eq]]
[PUnit.ext,[rfl]]
[Nat.gcd_mul_dvd_mul_gcd,[Dvd.dvd, Nat.gcd, HMul.hMul, Nat.prod_dvd_and_dvd_of_dvd_prod, Nat.gcd_dvd_right]]
[MonadWithReaderOf.withReader,[]]
[Seq.noConfusionType,[]]
[instDecidableLt_2,[UInt16.decLt]]
[instToStringUInt64,[ToString.mk, ToString.toString, UInt64.toNat]]
[Int.add_le_add_right,[Int.add_le_add_left, Int.add_comm]]
[lt_of_le_of_lt,[LT.lt, lt_of_le_not_le, le_trans]]
[Int.sub_mul,[Trans.trans, Int.distrib_right, Neg.neg, of_eq_true, Eq.trans, congr, congrArg, Eq, HAdd.hAdd, HMul.hMul, Int.neg_mul_eq_neg_mul_symm, Int.sub_eq_add_neg, eq_self]]
[Int.lt_neg_of_lt_neg,[]]
[List.mem_of_mem_remove,[And.left, Eq.mp, Eq.refl, Mem.mem, List.remove, propext, List.mem_remove_iff]]
[Array.shrink.loop,[Array, PProd.fst, Array.pop]]
[String.instReprRange,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, String.Range.start, Std.Format.line, String.Range.stop]]
[HasEquiv.Equiv,[]]
[UInt64.lor,[UInt64.mk, Fin.lor, UInt64.val]]
[UInt32.instSemiringUInt32,[Semiring.mk, UInt32.instSemiringUInt32.proof_1, UInt32.instSemiringUInt32.proof_2, UInt32.mk, Semiring.nsmul, UInt32.val, UInt32.instSemiringUInt32.proof_3, UInt32.instSemiringUInt32.proof_4, UInt32.instSemiringUInt32.proof_5, UInt32.instSemiringUInt32.proof_6, UInt32.instSemiringUInt32.proof_7, UInt32.instSemiringUInt32.proof_8, UInt32.instSemiringUInt32.proof_9, UInt32.instSemiringUInt32.proof_10, UInt32.instSemiringUInt32.proof_11, UInt32.instSemiringUInt32.proof_12, UInt32.instSemiringUInt32.proof_13]]
[Nat.add_assoc,[Eq, HAdd.hAdd, rfl, congrArg, Nat.succ, PProd.fst]]
[Quotient.recOnSubsingletonâ‚‚,[Quot.recOnSubsingleton]]
[Quot.inductionOn,[Quot.ind]]
[Nat.lt_by_cases,[Nat.lt_ge_by_cases, Nat.le_antisymm]]
[Nat.add_le_of_le_sub_left,[Iff.mp, Nat.not_lt, Iff.mpr, Nat.sub_lt_left_of_lt_add]]
[List.foldlM,[Pure.pure, Bind.bind, PProd.fst]]
[ByteSliceT.arr,[]]
[Int.instCommRingInt.proof_7,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Int.negSucc, Int.ofNat, Neg.neg, Nat.succ, Int.negSucc_ofNat_ofNat, Int.negOfNat, Int.ofNat_mul_ofNat, rfl, Eq.symm, Int.mul_negSucc_ofNat_negSucc_ofNat, Int.ofNat_mul_negSucc_ofNat]]
[List.bex_cons,[Iff.intro, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Or, Exists, And, Mem.mem, Or.inl, Or.inr, Exists.intro, And.intro, Or.elim, List.mem_cons_self, List.cons, List.mem_cons_of_mem]]
[ne_or_eq,[em', Eq]]
[Int.eq_zero_of_sign_eq_zero,[Eq.refl, OfNat.ofNat, HEq.refl, Eq, rfl]]
[Prod.swap_swap_eq,[funext, Prod.swap_swap]]
[Functor.map_map,[Eq.symm, LawfulFunctor.comp_map]]
[decidable_eq_inl_refl,[Eq, Decidable.isTrue, Eq.refl, rfl, absurd]]
[Int.lt_iff_le_and_ne,[Iff.intro, And.intro, Int.le_of_lt, Int.ne_of_lt, LT.lt]]
[List.card_append_disjoint,[Eq, List.card, HAppend.hAppend, HAdd.hAdd, of_eq_true, Eq.trans, congr, congrArg, List.nil_append, congrFun, List.card_nil, Nat.zero_add, eq_self]]
[List.set_comm,[Nat.zero, absurd, Eq.refl, Nat.succ, Eq, List.set, of_eq_true, Eq.trans, congr, congrArg, congrFun, List.set_nil, eq_self, List.nil, List.cons, Nat.add_eq, Nat.add_zero, Eq.mpr, PProd.fst, Nat.add, OfNat.ofNat, Iff.mpr, Nat.succ_inj', rfl]]
[HEq.symm,[HEq.ndrecOn, HEq.refl]]
[Id.instOfNatId,[inferInstanceAs, OfNat]]
[instDecidableXor.proof_4,[False]]
[Nat.sub_le_sub_left,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, LE.le, HSub.hSub, Nat.le.dest, Eq.mpr, Nat.sub_sub, Nat.sub_le]]
[System.FilePath.fileName,[ite, Eq, or, String.isEmpty, BEq.beq, Bool.true, Option.none, Option.some]]
[bfix4,[PProd.fst]]
[AddCommGroup.add_comm,[]]
[String.noConfusionType,[]]
[withPtrEqDecEq.proof_3,[ofBoolUsing_eq_false]]
[Nat.add_sub_cancel,[]]
[List.minimum?,[Unit.unit, Option, Option.none, Option.some, List.foldl, min]]
[ReaderT,[]]
[Nat.coprime.gcd_mul,[Nat.dvd_antisymm, Nat.gcd_mul_dvd_mul_gcd, Nat.coprime.mul_dvd_of_dvd_of_dvd, Nat.coprime.gcd_both, Nat.gcd_dvd_gcd_mul_right_right, Nat.gcd_dvd_gcd_mul_left_right]]
[bfix3,[PProd.fst]]
[instLTUInt8,[LT.mk, UInt8.lt]]
[Eq.subst,[]]
[forall_prop_decidable.proof_2,[absurd]]
[instInhabitedProd,[Inhabited.mk, Prod.mk, arbitrary]]
[MonoidWithZero.mul_zero,[]]
[Decidable.or_iff_not_imp_left,[Iff.intro, Or.resolve_left, dite, Or.inl, Function.comp, Or.inr]]
[coeM,[Bind.bind, Pure.pure, coe]]
[Int.neg_nonpos_of_nonneg,[]]
[OptionT.instMonadFunctorOptionT,[MonadFunctor.mk, Option]]
[Sigma.fst,[]]
[Option.lift_or_get,[Unit.unit, Option, Option.none, Option.some]]
[UInt8.instAddCommSemigroupUInt8.proof_1,[congrArg, UInt8.mk, AddCommSemigroup.add_comm, UInt8.val]]
[ExceptT.run_throw,[rfl]]
[instOfNatNat,[OfNat.mk]]
[PointedType.type,[]]
[Sdiff.sdiff,[]]
[instStreamProdProd,[Stream.mk, Option, Prod, Unit.unit, Stream.next?, Option.none, Option.some, Prod.mk]]
[Int.negSucc.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[LinearOrder.decidable_lt,[]]
[String.toLower,[String.map, Char.toLower]]
[Nat.sub_eq_zero_iff_le,[Iff.intro, Nat.le_of_sub_eq_zero, Nat.sub_eq_zero_of_le]]
[iff_iff_not_or_and_or_not,[Decidable.iff_iff_not_or_and_or_not]]
[String.dropWhile,[Substring.toString, Substring.dropWhile, String.toSubstring]]
[String.join,[List.foldl, HAppend.hAppend]]
[Array.modifyOp,[Array.modify]]
[Pure.noConfusionType,[]]
[Fin.ofNat,[Fin.mk, HMod.hMod, Nat.succ, Fin.ofNat.proof_1]]
[Equiv.instInhabitedEquiv,[Inhabited.mk, Equiv.refl]]
[List.lengthTRAux,[Nat, PProd.fst, Nat.succ]]
[Int.add_le_of_le_sub_right,[]]
[List.length_pos_iff_exists_mem,[Iff.intro, List.exists_mem_of_length_pos, LT.lt, OfNat.ofNat, List.length, List.length_pos_of_mem]]
[String.replace,[OfNat.ofNat, String.replace.loop]]
[Subtype.map,[Subtype.mk, Subtype.val, Subtype.map.proof_1]]
[PSigma.revLexAccessible,[PSigma.revLexAccessible.proof_1]]
[Int.lt_add_of_neg_lt_sub_right,[Int.lt_add_of_sub_right_lt, Int.add_lt_of_lt_sub_left]]
[Inv.noConfusionType,[]]
[Array.get?_set_eq,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Array.get?_eq_get?, Array.mk, List.set, Array.data, Fin.val, List.get?_set_of_lt, Fin.isLt, Option.some, eq_self]]
[Â«term_âˆ£_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[List.Chain.brecOn,[List.Chain.below.nil, List.Chain.below.cons]]
[UInt16.ofNatCore,[UInt16.mk, Fin.mk]]
[USize.div,[USize.mk, HDiv.hDiv, USize.val]]
[Nat.lt.base,[Nat.lt.base.proof_1]]
[Nat.div_lt_self,[]]
[instMonadExcept,[MonadExcept.mk, throwThe, tryCatchThe]]
[String.substrEq,[and, Decidable.decide, LE.le, HAdd.hAdd, String.bsize, String.substrEq.loop]]
[USize.mul_def,[rfl]]
[UInt64.one_def,[rfl]]
[Nat.le_refl,[Nat.le.refl]]
[false_and,[propext, Iff.intro, And.left, False.elim]]
[EqIffBeqTrue,[Iff.intro, decide_eq_true, of_decide_eq_true]]
[UInt16.modn,[UInt16.mk, HMod.hMod, UInt16.val]]
[Mathlib.Tactic.Lint.LintVerbosity.ofNat_toCtorIdx,[Eq.refl, Mathlib.Tactic.Lint.LintVerbosity.low, Mathlib.Tactic.Lint.LintVerbosity.medium, Mathlib.Tactic.Lint.LintVerbosity.high]]
[Subarray.as,[]]
[Array.forIn.loop,[Pure.pure]]
[forall_const,[Iff.intro, Nonempty.elim]]
[System.SearchPath,[List, System.FilePath]]
[Nat.add_left_cancel_iff,[Iff.intro, Nat.add_left_cancel, Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Eq, HAdd.hAdd, rfl]]
[inferInstanceAs,[]]
[exists_eq_right_right',[Iff.intro, And, And.intro, Eq.symm, Exists, Eq, Exists.intro, rfl]]
[Nat.foldAux,[PProd.fst, HSub.hSub, Nat.succ]]
[Â«binderTermâˆˆ_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[UInt16.instSemiringUInt16.proof_9,[rfl]]
[ReprTuple.noConfusionType,[]]
[Mathlib.Tactic.Lint.formatLemmas,[Bind.bind, Array.mapM, Lean.mkConstWithLevelParams, Pure.pure, Lean.ToMessageData.toMessageData]]
[StateT.run_bind_lift,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, LawfulMonad.bind_assoc, Pure.pure, Prod.mk, Bind.bind, funext, LawfulMonad.pure_bind, eq_self]]
[ByteArray.get,[UInt8, Array.get]]
[UInt8.toChar.proof_1,[UInt8.toChar_aux, Fin.val, UInt8.val, Fin.isLt]]
[Nat.sub_lt_succ,[Nat.lt_succ_of_le, Nat.sub_le]]
[OptionT.bind,[OptionT.mk, Bind.bind, Unit.unit, Option, Pure.pure, Option.none]]
[not_lt,[Iff.intro, le_of_not_gt, not_lt_of_ge]]
[Int.instCommRingInt.proof_3,[Eq.mpr, Eq.refl, Eq, HPow.hPow, Nat.succ, HMul.hMul, Int.mul_comm, rfl]]
[Classical.strongIndefiniteDescription,[dite, Exists, Subtype.mk, Classical.choice, Classical.strongIndefiniteDescription.proof_2]]
[Function.inv_fun_on,[dite, Exists, And, Mem.mem, Eq, Classical.choose, Classical.choice]]
[Int.add_right_neg,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat, Int.add_comm, Int.add_left_neg, rfl]]
[UInt8.instRingUInt8.proof_1,[congrArg, UInt8.mk, Ring.sub_eq_add_neg, UInt8.val]]
[Nat.exists_coprime,[Exists.intro, HDiv.hDiv, Nat.gcd, And.intro, Nat.coprime_div_gcd_div_gcd, Eq.symm, Nat.div_mul_cancel, Nat.gcd_dvd_left, Nat.gcd_dvd_right]]
[Array.qpartition,[Array.qpartition.loop]]
[Int.termâ„¤,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Char.instLEChar,[LE.mk, Char.le]]
[modifyThe,[MonadStateOf.modifyGet, Prod.mk, PUnit.unit]]
[NonScalar.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Array.findSome?,[Id.run, Array.findSomeM?]]
[List.exists_or_eq_self_of_erasep,[Decidable.em, Exists, And, Mem.mem, Or.inr, List.exists_of_erasep, Eq.symm, Or.inl, List.erasep_of_forall_not, Eq.mp, Eq.trans, propext, not_exists, forall_congr, not_and, Eq.refl]]
[List.get?_set_of_lt,[Eq.mpr, Eq.refl, Eq, List.get?, List.set, Option.some, List.get?_set_eq, Functor.map, List.get?_eq_get, rfl]]
[Subtype.prop,[Subtype.property]]
[Function.surjective.existsâ‚‚,[Iff.trans, Function.surjective.exists, exists_congr]]
[instNumericFin,[Numeric.mk, Fin.ofNat', Fin.size_positive']]
[Set.instEmptyCollectionSet,[EmptyCollection.mk, Eq, Bool.false, Bool.true]]
[Add.noConfusionType,[]]
[Nat.eq_of_beq_eq_true,[Eq, rfl]]
[StateCpsT.runK_lift,[rfl]]
[Array.set!,[Array.setD]]
[Array.sequenceMap,[Array.size, OfNat.ofNat, Array.empty, Array.sequenceMap.loop]]
[Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1]]
[Int.pos_of_sign_eq_one,[Eq.refl, OfNat.ofNat, HEq.refl, LT.lt, Iff.mpr, Int.ofNat_lt, Nat.succ_pos]]
[UInt32.instRingUInt32.proof_5,[UInt32.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, UInt32.val, congrFun, HAdd.hAdd, UInt32.neg_def, UInt32.add_def, UInt32.mk, Neg.neg, add_left_neg, UInt32.zero_def, eq_true_of_decide, Eq.refl, Bool.true]]
[Bool.true.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[instAddUInt32,[Add.mk, UInt32.add]]
[Tactic.Cache,[IO.Ref, Sum, Lean.Meta.MetaM, Task, Except, Lean.Exception]]
[Eq.mpr_not,[Eq.symm]]
[Int.neg_mul_eq_neg_mul,[Int.neg_eq_of_add_eq_zero, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HMul.hMul, Neg.neg, OfNat.ofNat, Eq.symm, Int.distrib_right, Int.add_right_neg, Int.zero_mul, rfl]]
[List.forall_mem_cons,[List.ball_cons]]
[instLTNat,[LT.mk, Nat.lt]]
[Char.val,[]]
[Nat.gcd_mul_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.mul_comm, Nat.gcd_mul_left, rfl]]
[List.length_nil,[rfl]]
[Substring.foldl,[String.foldlAux]]
[WellFounded.fixF,[]]
[Iff.mp,[]]
[System.instDecidableEqFilePath,[Decidable, Eq, dite, Decidable.isTrue, rfl, Decidable.isFalse]]
[and_implies,[And.imp]]
[IsMulLeftCancel.mul_left_cancel,[]]
[Nat.superDigitChar,[ite, Eq, OfNat.ofNat, Char.ofNat]]
[Eq.trans,[]]
[Function.extend_def,[Eq.mpr, Eq.refl, Eq, Function.extend, dite, Exists, Classical.choose, Subsingleton.elim, Classical.propDecidable, rfl]]
[UInt32.instSemiringUInt32.proof_8,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt32.one_def, UInt32.mul_def, UInt32.mk, OfNat.ofNat, mul_one, UInt32.val, UInt32.mk_val_eq, eq_self, propext, forall_const, UInt32]]
[Array.toListLitAux.proof_1,[Nat.le_of_succ_le]]
[instInhabitedOption,[Inhabited.mk, Option.none]]
[UInt16.le,[LE.le, UInt16.val]]
[Prod.forall,[Iff.intro, Prod.mk]]
[UInt64.noConfusionType,[]]
[neg_add_cancel_left,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, Eq.symm, add_assoc, add_left_neg, OfNat.ofNat, zero_add, rfl]]
[not_congr,[Iff.intro, mt, Iff.mpr, Iff.mp]]
[UInt32.instSemigroupUInt32.proof_1,[congrArg, UInt32.mk, Semigroup.mul_assoc, UInt32.val]]
[MonadStateOf.noConfusionType,[]]
[instDecidableEqProd.proof_2,[absurd]]
[Nat.lcm,[HDiv.hDiv, HMul.hMul, Nat.gcd]]
[Option.choice,[dite, Nonempty, Option.some, Classical.choice, Option.none]]
[instInhabitedUInt32.proof_1,[of_decide_eq_true, Eq.refl, Bool.true]]
[Prod.snd_eq_iff,[Iff, Eq, Prod.snd, Prod.mk, Prod.fst, of_eq_true, Eq.trans, congrArg, Prod.mk.injEq, congrFun, And, eq_self, true_and, iff_self]]
[decide_false_eq_false,[Eq, Decidable.decide, False, Bool.false, rfl, False.elim]]
[List.cons_ne_self,[mt, congr_arg, List.length, Nat.succ_ne_self]]
[and_assoc,[And.assoc]]
[Nat.mul_dvd_mul_left,[Nat.mul_dvd_mul, Nat.dvd_refl]]
[control,[controlAt]]
[exists_unique_of_exists_of_unique,[Exists.elim, ExistsUnique.intro]]
[Option.bind_eq_none,[Eq.mpr, congr, congrArg, Iff, Eq.trans, propext, Option.eq_none_iff_forall_not_mem, forall_congr, Not, Option.mem_def, Option.bind_eq_some, not_exists, not_and, implies_congr, Iff.rfl]]
[Int.negSucc.inj,[]]
[Array.toArrayLit_eq,[sorryAx, Eq, Array.toArrayLit, Bool.false]]
[Sum.inhabitedLeft,[Inhabited.mk, Sum.inl, arbitrary]]
[instDecidableEqUInt32,[UInt32.decEq]]
[instSubsingletonSquash,[instSubsingletonSquash.proof_1]]
[List.rotate',[dite, Eq, Eq.symm, List.cons, List, List.nil, PProd.fst, HAppend.hAppend]]
[MonadFinally.tryFinally',[]]
[Option.lift_or_get_none_right,[rfl, Eq.symm, Eq.refl]]
[Int.instLinearOrderInt,[LinearOrder.mk, Int.le_total, inferInstance]]
[Nat.pred_zero,[rfl]]
[Int.eq_neg_succ_of_lt_zero,[Exists, Eq, Int.negSucc, absurd, not_lt_of_ge, Int.ofNat_zero_le, Exists.intro, rfl]]
[Tactic.NormCast.NormCastExtension.up,[]]
[Array.get?_eq_get,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, dite_congr, eq_true, Eq.refl, Option.some, Array.get, Fin.mk, Eq.mpr_prop, Option.none, dite_true, eq_self, True.intro]]
[List.getLast!.proof_1,[]]
[fix5,[fixCore5, arbitrary]]
[Nat.zero_lt_one,[Nat.zero_lt_succ, OfNat.ofNat]]
[List.isPrefixOf,[List.nil, List.cons, Bool, Bool.true, Bool.false, and, BEq.beq, PProd.fst]]
[Array.foldrM,[dite, LE.le, Array.size, ite, LT.lt, Pure.pure, Nat.le_refl, Array.foldrM.fold]]
[Function.inv_fun_surjective,[Function.left_inverse.surjective, Function.left_inverse_inv_fun]]
[is_dec_eq,[Eq]]
[not_of_eq_false,[]]
[Nat.coprime.coprime_div_right,[Nat.coprime.symm, Nat.coprime.coprime_div_left]]
[List.length_tail,[rfl, Eq.symm, Eq.refl]]
[UInt16.instSemiringUInt16.proof_4,[congrArg, UInt16.mk, AddMonoid.nsmul_succ', UInt16.val]]
[Nat.zero_ne_one,[]]
[instDecidableIff.proof_3,[Iff.mpr]]
[UInt16.instRingUInt16,[Ring.mk, UInt16.instRingUInt16.proof_1, UInt16.mk, Ring.gsmul, UInt16.val, UInt16.instRingUInt16.proof_2, UInt16.instRingUInt16.proof_3, UInt16.instRingUInt16.proof_4, UInt16.instRingUInt16.proof_5]]
[Except.toBool,[Bool, Bool.true, Bool.false]]
[Classical.epsilon_spec_aux,[Subtype.property, Classical.strongIndefiniteDescription]]
[Nat.ble_eq_true_of_le,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Eq, Nat.ble, Bool.true, Nat.ble_self_eq_true, Nat.ble_succ_eq_true, PProd.fst]]
[instDecidableEqChar,[Decidable, Eq, decEq, Char.val, Decidable.isTrue, Char.eq_of_val_eq, Decidable.isFalse, Char.ne_of_val_ne]]
[Nat.one_pos,[Nat.zero_lt_one]]
[Not.imp,[mt]]
[false_of_true_iff_false,[Iff.mp, trivial]]
[StateCpsT.run,[StateCpsT.runK, Pure.pure, Prod.mk]]
[Int.lt_of_sub_pos,[]]
[instMulFloat,[Mul.mk, Float.mul]]
[instAddCommSemigroupFin.proof_1,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.add_def, congrFun, HMod.hMod, Nat.add_comm, eq_self, HAdd.hAdd]]
[String.codepointPosToUtf8PosFrom,[String.Pos, PProd.fst, String.next]]
[List.concat_eq_append,[Eq, List.concat, HAppend.hAppend, List.cons, List.nil, Eq.symm, List.append_nil, of_eq_true, Eq.trans, congr, congrArg, PProd.fst, List.cons_append, eq_self]]
[Quot.liftBeta,[rfl]]
[Function.injective.of_comp,[]]
[instInhabited,[Inhabited.mk, Pure.pure, arbitrary]]
[One.one,[]]
[sorry,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Subarray.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Subarray.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Option.map_map,[of_eq_true, Eq.trans, congr, congrArg, Eq, Option.map, Option.map_none', eq_self, Option.none, Eq.symm, Option.map_some', Option.some, Eq.refl]]
[absurd,[False.elim]]
[UInt8.lor,[UInt8.mk, Fin.lor, UInt8.val]]
[Option.elim,[]]
[Nat.gcd_dvd_gcd_mul_right,[Nat.gcd_dvd_gcd_of_dvd_left, Nat.dvd_mul_right]]
[Option.map_none',[rfl]]
[List.sections,[Unit.unit, List, List.cons, List.nil, List.bind, PProd.fst, List.map]]
[Option.decidable_exists_mem.proof_1,[False, Eq.refl, Option.some, HEq.refl]]
[HOrElse.hOrElse,[]]
[instMonadControlT,[MonadControlT.mk, MonadControlT.stM, MonadControl.stM, MonadControl.liftWith, MonadControlT.liftWith, Function.comp, MonadControl.restoreM, MonadControlT.restoreM]]
[List.mapIdx,[List.mapIdxAux, OfNat.ofNat]]
[Nat.mul_le_mul_of_nonneg_left,[Decidable.em, LE.le, of_eq_true, Eq.trans, congrArg, HMul.hMul, Nat.le_antisymm, eq_true, le_refl, Eq.symm, OfNat.ofNat, congr, congrFun, Nat.zero_le, Nat.zero_mul, eq_true_of_decide, Eq.refl, Bool.true, Nat.le_of_lt, Nat.mul_lt_mul_of_pos_left, Iff.mp, not_le]]
[List.ne_nil_of_length_pos,[Nat.lt_irrefl, OfNat.ofNat, Eq.subst, Iff.mpr, List.length_eq_zero]]
[DecidableRel,[Decidable]]
[instToFormatList,[Std.ToFormat.mk, List.format]]
[Char.isWhitespace,[or, Decidable.decide, Eq, Char.ofNat]]
[lt_of_not_ge,[lt_of_le_not_le, Or.resolve_right, le_total]]
[instXorUInt64,[Xor.mk, UInt64.xor]]
[Int.add_assoc_aux2,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HAdd.hAdd, Int.negSucc_ofNat_add_negSucc_ofNat, Int.ofNat, Int.negSucc_ofNat_add_ofNat, Nat.succ, Int.negSucc, Eq.refl, Int.subNatNat, Int.add_comm, Int.subNatNat_add_negSucc_ofNat, of_eq_true, Nat.add_succ, Nat.succ_add, Nat.add_comm, eq_self]]
[ExceptT.instLawfulMonadExceptT.proof_1,[LawfulMonad.mk, ExceptT.bind_pure_comp, rfl, ExceptT.ext, of_eq_true, Eq.trans, congrFun, congrArg, Eq, ExceptT.run_bind, Pure.pure, Bind.bind, ExceptT.run_pure, Except, ExceptT.run, Except.error, LawfulMonad.pure_bind, Except.ok, eq_self, Eq.mpr, congr, LawfulMonad.bind_assoc, funext, bind_congr, Eq.symm, Eq.refl]]
[elabVariables,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Bind.bind, Lean.Elab.logWarningAt, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Option.getD, Lean.Syntax.getHeadInfo?, Array.append, List.nil, Lean.Elab.Command.elabVariable, Lean.Elab.throwUnsupportedSyntax]]
[System.FilePath.exeExtension,[ite, Eq, System.Platform.isWindows, Bool.true]]
[instSubsingletonForall.proof_1,[Subsingleton.intro, funext, Subsingleton.elim]]
[ST.instInhabitedRef,[Inhabited.mk, ST.Ref.mk, PointedType.val, ST.RefPointed, ST.instInhabitedRef.proof_1]]
[UInt8.instSemigroupUInt8.proof_1,[congrArg, UInt8.mk, Semigroup.mul_assoc, UInt8.val]]
[eq_false_of_ne_true,[Eq, Bool.false, False.elim, rfl]]
[Array.heapSort.loop,[WellFounded.fix, Array, BinaryHeap.max, Eq.refl, PSigma.mk]]
[Tactic.DeclCache,[Prod, Tactic.Cache, Lean.Meta.MetaM]]
[List.insertNth,[List.modifyNthTail, List.cons]]
[UInt16.decLe,[Decidable, LE.le, inferInstanceAs]]
[instSemiringFin.proof_6,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, OfNat.ofNat, add_comm, instSemiringFin.proof_1]]
[Nat.find_x.proof_2,[Or.elim, lt_or_eq_of_le, Eq.mpr, Eq.refl, Not]]
[le_of_not_le,[Or.resolve_left, le_total]]
[min_eq_left_of_lt,[min_eq_left, le_of_lt]]
[MonadLiftT.noConfusionType,[]]
[Int.mul_lt_mul,[Trans.trans, Int.mul_lt_mul_of_pos_right, Int.mul_le_mul_of_nonneg_left]]
[List.beq,[Unit.unit, List.nil, List.cons, Bool, Bool.true, and, BEq.beq, PProd.fst, Bool.false]]
[Mathlib.Prelude.Rename.RenameMap,[Std.HashMap, Lean.Name]]
[dif_ctx_congr,[Eq, dite, absurd, Iff.mp, not_iff_not_of_iff, Iff.mpr]]
[ForInStep.yield.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Array.modifyM.proof_1,[Eq.symm, Array.size_set, Fin.mk, arbitrary]]
[Subtype.map_injective,[Subtype.coind_injective, Subtype.map.proof_1, Function.injective.comp, Subtype.coe_injective]]
[Nat.pred_le,[Unit.unit, LE.le, Nat.pred, Nat.le.refl, Nat.le_succ, Nat.succ]]
[Function.update_comm,[funext, Decidable.em, Eq, Eq.mpr, Eq.refl, dite, Eq.symm, dif_pos, Eq.trans, dif_neg, rfl]]
[Substring.take,[Substring.mk, Substring, HAdd.hAdd, Substring.nextn, OfNat.ofNat]]
[Array.eraseIdxSzAuxInstance,[Inhabited.mk, Subtype.mk, Array.pop, Array.size_pop]]
[List.isPrefix,[Exists, Eq, HAppend.hAppend]]
[Function.right_id,[rfl]]
[List.Perm.subset,[List.nil_subset, List.nil, List.cons_subset_cons, Eq.mpr, Eq.refl, Mem.mem, List.cons, propext, List.mem_cons, Or.inr, Or.inl, List.subset.trans]]
[List.mem_append,[of_eq_true, Eq.trans, congr, congrArg, Iff, Mem.mem, List.nil_append, congrFun, Or, propext, List.mem_nil, false_or, iff_self, List.cons_append, List.mem_cons, Eq, or_assoc]]
[instMonadFinallyEIO,[inferInstanceAs, MonadFinally, EStateM, IO.RealWorld]]
[Nat.max,[ite, LE.le]]
[AddCommMonoid.noConfusionType,[]]
[Nat.zero_eq,[rfl]]
[instTransGeGeGe.proof_1,[ge_trans]]
[Nat.mod.proof_1,[WellFoundedRelation.wf, measure, id]]
[Subsingleton.noConfusionType,[]]
[Â«term[_]Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false]]
[Â«term_â‰ _Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Set.union,[setOf, Or, Mem.mem]]
[Decidable.of_not_not,[Decidable.byContradiction, absurd]]
[exists_prop,[Iff.intro, And, And.intro, Exists, Exists.intro]]
[Nat.div_le_of_le_mul,[LE.le, HDiv.hDiv, of_eq_true, Eq.trans, congrFun, congrArg, Nat.div_zero, eq_true, Nat.zero_le]]
[decide_eq_true,[Eq, Decidable.decide, Bool.true, rfl, absurd]]
[not_or_of_imp,[Decidable.not_or_of_imp]]
[and_or_distrib_right,[Iff.trans, Or.comm, or_and_distrib_left, and_congr]]
[Nat.instDvdNat,[Dvd.mk, Exists, Eq, HMul.hMul]]
[mul_right_cancel_iff,[Iff.intro, mul_right_cancel, rfl]]
[SeqLeft.noConfusionType,[]]
[Function.surjective.forallâ‚‚,[Iff.trans, Function.surjective.forall, forall_congr']]
[Int.mul_pos,[Eq.mpr, Eq.refl, Eq.symm, Int.ofNat_mul, Nat.succ, Int.ofNat_succ_pos]]
[UInt8.xor,[UInt8.mk, Fin.xor, UInt8.val]]
[withPtrEqUnsafe,[ite, Eq, BEq.beq, ptrAddrUnsafe, Bool.true, Unit.unit]]
[Prod.fst_injective,[Prod.ext', Subsingleton.elim, Prod.snd]]
[UInt32.decEq.proof_1,[rfl]]
[Function.comp.assoc,[rfl]]
[Array.forIn.loop.proof_1,[Nat.lt_of_le_of_lt, Nat.sub_le, HSub.hSub, Array.size, OfNat.ofNat, Nat.sub_lt, Nat.zero_lt_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self, of_decide_eq_true, Eq.refl, Bool.true]]
[UInt64.instRingUInt64.proof_4,[congrArg, UInt64.mk, SubNegMonoid.gsmul_neg', UInt64.val]]
[ForM.noConfusionType,[]]
[instAddUSize,[Add.mk, USize.add]]
[emptyRelation,[False]]
[Option.some_orelse,[rfl]]
[CommMonoid.mul_comm,[]]
[StateT.instMonadFunctorStateT,[MonadFunctor.mk, Prod]]
[List.mem_insert_self,[Iff.mpr, List.mem_insert_iff, Or.inl, rfl]]
[coeOfTCOfTail,[CoeHTCT.mk, coeTail, coeTC]]
[Char.instDecidableLt,[UInt32.decLt, Char.val]]
[PProd.snd,[]]
[List.erase_of_not_mem,[rfl, Eq.mpr, Eq.refl, Eq, List.erase, List.cons, List.erase_cons, ite, if_neg, Ne.symm, And.left, Eq.mp, Not, Or, Mem.mem, propext, not_or, List.mem_cons, And.right]]
[UInt8.neg_def,[rfl]]
[Int.le_of_add_le_add_right,[Int.le_of_add_le_add_left, Eq.mpr, Eq.refl, LE.le, HAdd.hAdd, Int.add_comm]]
[instModUSize,[Mod.mk, USize.mod]]
[add_comm,[AddCommSemigroup.add_comm]]
[Equivalence.symm,[]]
[EStateM.map,[EStateM.Result, EStateM.Result.ok, EStateM.Result.error]]
[UInt64.instAddSemigroupUInt64,[AddSemigroup.mk, UInt64.instAddSemigroupUInt64.proof_1]]
[UInt16.instSemigroupUInt16.proof_1,[congrArg, UInt16.mk, Semigroup.mul_assoc, UInt16.val]]
[Mathlib.Tactic.Lint.Linter.mk.inj,[And.intro]]
[Nat.pow_le_pow_of_le_left,[Unit.unit, LE.le, HPow.hPow, Nat.le_refl, OfNat.ofNat, Nat.mul_le_mul, PProd.fst]]
[UInt16.instCommRingUInt16,[CommRing.mk, UInt16.instCommRingUInt16.proof_1]]
[Function.left_inverse.surjective,[Function.right_inverse.surjective, Function.left_inverse.right_inverse]]
[EIO.mapTask,[BaseIO.mapTask, EIO.toBaseIO]]
[List.slice,[List, List.drop, List.nil, List.cons, PProd.fst]]
[add_right_inj,[Iff.intro, add_left_cancel, congrArg, HAdd.hAdd]]
[Int.ofNat_eq_ofNat_iff,[Iff.intro, Int.ofNat.inj, congrArg, Int.ofNat]]
[instSubsingleton.proof_1,[Subsingleton.intro, proofIrrel]]
[exists_imp_distrib,[Iff.intro, Exists.intro]]
[Subarray.mk.inj,[And.intro]]
[BinaryHeap.popMax,[Subtype.val, BinaryHeap.popMaxAux]]
[Prod.swap_prod_mk,[rfl]]
[Array.binSearch,[ite, LT.lt, Array.size, Array.binSearchAux, id, Option.none]]
[Nat.sub_mul_div,[Nat.eq_zero_or_pos, Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HSub.hSub, HMul.hMul, OfNat.ofNat, Nat.div_zero, Nat.zero_sub, rfl, Eq.symm, Nat.zero, Nat.mul_zero, Nat.sub_zero]]
[ByteSlice.toArray,[ByteArray, ByteArray.extract]]
[Function.left_inverse.id,[funext]]
[Prod.map_fst,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Prod.fst, prod_map, eq_self]]
[Array.isPrefixOf,[dite, LE.le, Array.size, Array.isPrefixOfAux, OfNat.ofNat, Bool.false]]
[hasOfNatOfCoe,[OfNat.mk, coe, OfNat.ofNat]]
[Except.mapError,[Except, Except.error, Except.ok]]
[instDecidableNot,[Decidable, Not, Decidable.isFalse, absurd, Decidable.isTrue]]
[Int.add_lt_add_left,[Iff.mpr, Int.lt_iff_le_and_ne, And.intro, Int.add_le_add_left, Int.le_of_lt, Int.lt_irrefl, Eq.mp, Eq.refl, LT.lt, Int.add_left_cancel]]
[instHashableBool,[Hashable.mk, Unit.unit, UInt64, OfNat.ofNat]]
[ByteArray.forIn.loop,[Pure.pure]]
[Monoid.npow_zero',[]]
[GroupWithZero.zero_mul,[]]
[List.toByteArray.loop,[ByteArray, PProd.fst, ByteArray.push]]
[instHShiftRight,[HShiftRight.mk, ShiftRight.shiftRight]]
[Nat.mul_lt_mul_of_pos_left,[Nat.lt_of_lt_of_le, Nat.add_lt_add_left, Nat.mul, Nat.mul_le_mul_left, Nat.succ_le_of_lt, Nat.mul_succ]]
[List.cons_eq_append_iff,[Eq.mpr, Eq.refl, Iff, Eq, List.cons, HAppend.hAppend, Or, And, List.nil, Exists, propext, eq_comm, List.append_eq_cons_iff, Iff.rfl]]
[UInt8.instNegUInt8,[Neg.mk, UInt8.mk, Neg.neg, UInt8.val]]
[Int.eq_succ_of_zero_lt,[Exists, Eq, Int.ofNat, Nat.succ, Exists.intro, Eq.symm, Eq.mp, Eq.refl, HAdd.hAdd, OfNat.ofNat, Nat.add_comm]]
[Nat.zero_min,[min_eq_left, Nat.zero_le]]
[Int.add_nonneg,[Int.add_le_add, Int.zero_add, OfNat.ofNat]]
[String.capitalize,[String.set, OfNat.ofNat, Char.toUpper, String.get]]
[instReprDecidable,[Repr.mk, Std.Format, Repr.addAppParen, Std.Format.text]]
[instTransLeLtLt.proof_1,[lt_of_le_of_lt]]
[List.mem_of_mem_erase,[List.erase_subset]]
[Substring.all,[not, Substring.any]]
[Ring.add_left_neg,[]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[EStateM.instReprResult,[Repr.mk, Std.Format, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg]]
[Option.pbind.proof_1,[rfl]]
[Int.mul_neg_eq_neg_mul_symm,[Eq.symm, Int.neg_mul_eq_mul_neg]]
[Nat.lt_le_antisymm,[Nat.le_lt_antisymm]]
[Tactic.NormCast.NormCastExtension.squash,[]]
[Prod.swap,[Prod.mk, Prod.snd, Prod.fst]]
[invImage.proof_1,[InvImage.wf, WellFoundedRelation.wf]]
[Int.add_le_add_left,[LE.le, HAdd.hAdd, Int.le.intro, Eq.mpr, Eq.refl, Eq, Int.ofNat, Int.add_assoc, rfl]]
[introv,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[Function.update_comp_eq_of_injective',[Iff.mpr, Function.eq_update_iff, And.intro, Function.update_same, Function.update_noteq, Function.injective.ne]]
[UInt8.mul_def,[rfl]]
[ULift.down,[]]
[instReprStdGen,[Repr.mk, Std.Format, Std.Format.bracket, HAppend.hAppend, repr, Std.Format.text]]
[and_self_left,[Iff.intro, And.intro, And.left, And.right]]
[Nat.eq_or_lt_of_not_lt,[Or.resolve_left, Nat.lt_trichotomy]]
[List.append_inj',[List.append_inj, Nat.add_right_cancel, Eq.mp, Eq.refl, Eq, HAdd.hAdd, List.length, Eq.symm, congr, congrArg, List.length_append]]
[FloatArray.forIn.loop,[Pure.pure]]
[Option.none.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Mathlib.Prelude.Rename.addNameAlignment,[Lean.MonadEnv.modifyEnv, Lean.PersistentEnvExtension.addEntry, Mathlib.Prelude.Rename.renameExtension, Prod.mk]]
[instSemiringFin,[Semiring.mk, instSemiringFin.proof_6, HMul.hMul, Fin.ofNat', Fin.size_positive, instSemiringFin.proof_7, instSemiringFin.proof_8, instSemiringFin.proof_9, instSemiringFin.proof_10, instSemiringFin.proof_11, instSemiringFin.proof_12, instSemiringFin.proof_13, instSemiringFin.proof_14]]
[Tactic.Ring.HornerExpr.below,[PUnit, PProd]]
[imp_congr_left,[Iff.intro, Iff.mpr, Iff.mp]]
[Mathlib.Tactic.Lint.heuristicallyExtractSimpLemmasCore,[Id.run, Bind.bind, ForIn.forIn, ite, Eq, Std.PersistentHashSet.contains, Lean.Meta.SimpLemmas.toUnfold, Lean.Meta.Simp.Context.simpLemmas, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, Lean.SMap.contains, Lean.Meta.CongrLemmas.lemmas, Lean.Meta.Simp.Context.congrLemmas, Option.none, Id, ForInStep, Std.HashSet, Lean.Name, Std.HashMap.find?, Std.HashSet.toArray]]
[Array.partition,[Id.run, Bind.bind, ForIn.forIn, MProd.mk, ite, Eq, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, Id, Prod, Array, Prod.mk]]
[Nat.mul_le_mul_of_nonneg_right,[Decidable.em, LE.le, of_eq_true, Eq.trans, congrArg, HMul.hMul, congrFun, Nat.le_antisymm, eq_true, le_refl, Eq.symm, OfNat.ofNat, congr, Nat.zero_le, Nat.mul_zero, eq_true_of_decide, Eq.refl, Bool.true, Nat.le_of_lt, Nat.mul_lt_mul_of_pos_right, Iff.mp, not_le]]
[Nat.gcd_pos_of_pos_left,[Nat.pos_of_dvd_of_pos, Nat.gcd_dvd_left]]
[Option.instFunctorOption,[Functor.mk, Option.map]]
[instDecidableEqUSize,[USize.decEq]]
[PSigma.skipLeft.proof_1,[PSigma.revLex, WellFoundedRelation.wf, emptyWf]]
[instDecidableXor.proof_3,[Or.inr, And.intro]]
[UInt32.instAddSemigroupUInt32,[AddSemigroup.mk, UInt32.instAddSemigroupUInt32.proof_1]]
[List.append_left_cancel,[List.append_inj_right, rfl]]
[String.all,[not, String.any]]
[EStateM.Result.error.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Function.injective_id,[id]]
[ReaderT.instMonadLiftReaderT,[MonadLift.mk]]
[Array.foldlM.loop.proof_1,[Nat.lt_of_lt_of_le]]
[System.FilePath.fileStem,[Option.map, Unit.unit, dite, Eq, Eq.symm, String, String.revPosOf, Char.ofNat, String.extract, OfNat.ofNat, System.FilePath.fileName]]
[Tactic.TryThis.addSuggestion,[Lean.Elab.logInfoAt, HAppend.hAppend, Lean.ToMessageData.toMessageData]]
[not_of_not_not_not,[absurd, not_not_intro]]
[Int.ofNat_le,[Iff.intro, LE.le, Nat.le.intro, Int.ofNat.inj, Eq.trans, Int.ofNat_add, Int.ofNat, Int.le.intro, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Eq.symm, rfl]]
[USize.mod,[USize.mk, HMod.hMod, USize.val]]
[String.instInhabitedString,[Inhabited.mk]]
[instReprUSize,[Repr.mk, repr, USize.toNat]]
[UInt32.shiftRight,[UInt32.mk, HShiftRight.hShiftRight, UInt32.val, UInt32.modn, OfNat.ofNat]]
[Mathlib.Prelude.Rename.elabLookup3,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, cond, Bind.bind, Lean.MonadEnv.getEnv, Unit.unit, Lean.Elab.Command.CommandElabM, Unit, Std.HashMap.find?, Mathlib.Prelude.Rename.getRenameMap, Lean.Elab.logInfoAt, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format, HAppend.hAppend, ToString.toString, Lean.Elab.throwUnsupportedSyntax]]
[instSubsingletonEmpty,[instSubsingletonEmpty.proof_1]]
[List.append_left_inj,[Function.injective.eq_iff, List.append_left_injective]]
[Int.le_trans,[LE.le, Int.le.intro, HAdd.hAdd, Eq.mpr, Eq.refl, Eq, Int.ofNat, Eq.symm, Int.add_assoc, Int.ofNat_add, rfl]]
[USize.instSemigroupUSize,[Semigroup.mk, USize.instSemigroupUSize.proof_1]]
[Int.add_left_comm,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Eq.symm, Int.add_assoc, Int.add_comm, rfl]]
[Function.on_fun,[]]
[Nat.zero_add,[Unit.unit, Eq, HAdd.hAdd, OfNat.ofNat, rfl, congrArg, Nat.succ, PProd.fst]]
[instDecidableLt_5,[LinearOrder.decidable_lt]]
[Int.le.dest_sub,[Iff.mp, Int.nonneg_def]]
[List.foldrM,[Pure.pure, Bind.bind, PProd.fst]]
[Quotient.liftâ‚‚.proof_2,[Quotient.ind, Setoid.refl]]
[ExceptT.adapt,[ExceptT.mk, Functor.map, Except.mapError]]
[Mathlib.Tactic.Lint.getChecks,[ite, Eq, Bool.true, Bind.bind, Pure.pure, List.nil, Lean.MonadEnv.getEnv, Lean.TagAttribute.getDecls, Mathlib.Tactic.Lint.mathlibLinterAttr, Mathlib.Tactic.Lint.getLinters, Array.toList]]
[Â«term_&&_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Int.sign_one,[rfl]]
[Decidable.imp_iff_not_or,[Iff.intro, Decidable.not_or_of_imp, Or.neg_resolve_left]]
[List.lengthTR,[List.lengthTRAux, OfNat.ofNat]]
[ExceptCpsT.run,[Except, Pure.pure, Except.ok, Except.error]]
[List.instBEqList,[BEq.mk, List.beq]]
[Tactic.Ring.pow_succ_eq,[Eq.mpr, Eq.refl, Eq, HPow.hPow, HAdd.hAdd, OfNat.ofNat, Eq.symm, HMul.hMul, pow_succ, rfl]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.hyps,[]]
[DoResultPRBC.continue.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Option.get_some,[rfl]]
[List.partitionAux,[Prod, List, Prod.mk, List.reverse, Unit.unit, PProd.fst, List.cons]]
[List.instAppendList,[Append.mk, List.append]]
[UInt8.mul,[UInt8.mk, HMul.hMul, UInt8.val]]
[Array.swapAt!,[dite, LT.lt, Array.size, Array.swapAt, Fin.mk]]
[List.modifyNthTail_length,[Eq, List.length, List.modifyNthTail, rfl, congr_arg, HAdd.hAdd, OfNat.ofNat, PProd.fst]]
[right_comm,[]]
[Int.lt_add_of_neg_add_lt_right,[Int.lt_add_of_sub_right_lt, Eq.mp, Eq.refl, LT.lt, HAdd.hAdd, Neg.neg, Int.add_comm]]
[Array.singleton,[Array.mkArray, OfNat.ofNat]]
[Array.instEmptyCollectionArray,[EmptyCollection.mk, Array.empty]]
[Nat.Up,[And, LT.lt]]
[implies.trans,[]]
[UInt32.instSemigroupUInt32,[Semigroup.mk, UInt32.instSemigroupUInt32.proof_1]]
[Mathlib.Tactic.Lint.Linter.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[ExceptT.instMonadExceptT,[Monad.mk]]
[instHAdd,[HAdd.mk, Add.add]]
[UInt8.decEq.proof_2,[absurd]]
[SubNegMonoid.gsmul,[]]
[System.FilePath.pathExists,[Bind.bind, EIO.toBaseIO, System.FilePath.metadata, Pure.pure, Except.toBool]]
[Applicative.toSeqRight,[]]
[instToStringId,[inferInstanceAs, ToString]]
[Array.findIdxM?,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, ite, Eq, Bool.true, Pure.pure, ForInStep.done, Option.some, PUnit.unit, Unit.unit, Option, Nat, MProd.fst]]
[String.toAsciiByteArray,[OfNat.ofNat, ByteArray.empty, String.toAsciiByteArray.loop]]
[List.get_append_right_aux,[Nat.sub_lt_left_of_lt_add, Eq.mp, Eq.refl, LT.lt, List.length, HAppend.hAppend, List.length_append]]
[UInt16.shiftRight,[UInt16.mk, HShiftRight.hShiftRight, UInt16.val, UInt16.modn, OfNat.ofNat]]
[Array.ofSubarray,[Id.run, Bind.bind, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield]]
[Subtype.mk.injEq,[Eq.propIntro, Eq.refl, Subtype.mk, Eq.symm, eq_of_heq, HEq.refl]]
[PUnit.unit.sizeOf_spec,[Eq.refl, OfNat.ofNat]]
[Array.allDiff,[OfNat.ofNat]]
[UInt8.isUpper,[and, Decidable.decide, GE.ge, OfNat.ofNat, LE.le]]
[instBEqFloat,[BEq.mk, Float.beq]]
[Subtype.val_injective,[Subtype.coe_injective]]
[Functor.map_equiv_apply,[rfl]]
[ulift.up.injEq,[Eq.propIntro, Eq.refl, ulift.up, Eq.symm, eq_of_heq, HEq.refl]]
[instHMod,[HMod.mk, Mod.mod]]
[Nat.dvd_gcd,[Nat.gcd.induction, Eq.mpr, Eq.refl, Dvd.dvd, Nat.gcd, OfNat.ofNat, Nat.gcd_zero_left, Nat.gcd_rec, Iff.mpr, Nat.dvd_mod_iff]]
[List.indexesOf,[List.findIdxs, Eq]]
[Nat.not_coprime_of_dvd_of_dvd,[]]
[UInt8.sub,[UInt8.mk, HSub.hSub, UInt8.val]]
[USize.instAddCommSemigroupUSize.proof_1,[congrArg, USize.mk, AddCommSemigroup.add_comm, USize.val]]
[Or.neg_resolve_left,[Or.elim, absurd, id]]
[Option.toBool,[Unit.unit, Bool, Bool.true, Bool.false]]
[ExceptCpsT.runCatch_pure,[rfl]]
[Array.modify,[Id.run, Array.modifyM]]
[Decidable.not_imp_self,[]]
[Nat.coprime.symm,[Eq.trans, Nat.gcd_comm]]
[UInt64.toNat,[Fin.val, UInt64.val]]
[variables,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[Task.Priority.max,[OfNat.ofNat]]
[Tactic.NormCast.addMove,[Bind.bind, Lean.Meta.addSimpLemma, Tactic.NormCast.pushCastExt, Bool.false, Tactic.NormCast.NormCastExtension.up, Tactic.NormCast.normCastExt, Bool.true, Tactic.NormCast.NormCastExtension.down]]
[Int.sub_nonneg_of_le,[]]
[instReprTuple,[ReprTuple.mk, List.cons, repr]]
[Prod.lexAccessible,[Prod.lexAccessible.proof_1]]
[Nat.foldM.loop,[Pure.pure, Bind.bind, HSub.hSub, OfNat.ofNat, PProd.fst]]
[imp_congr,[imp_congr_ctx]]
[List.reverseAux_reverseAux,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, List.cons, List.reverseAux, List.nil, eq_self]]
[Id.map_eq,[rfl]]
[BaseIO.toEIO,[EStateM.Result.error, EStateM.Result, IO.RealWorld, EStateM.Result.ok]]
[Function.injective.eq_iff,[Iff.intro, congr_arg]]
[Subsingleton.elim.proof_1,[Subsingleton.allEq]]
[Nat.zero_le,[Unit.unit, LE.le, OfNat.ofNat, Nat.le.refl, Nat.le.step, PProd.fst]]
[imp_imp_imp,[Function.comp]]
[PSigma.eta,[rfl]]
[StateCpsT.run'_eq,[rfl]]
[Preorder.toLT,[]]
[USize.xor,[USize.mk, Fin.xor, USize.val]]
[not_lt_of_gt,[lt_asymm]]
[instDecidableXor.proof_2,[Or.inl, And.intro]]
[Subtype.coe_eq_iff,[Iff.intro, Exists.intro, Subtype.property, Eq.symm, Subtype.coe_eta, Eq, Subtype.val, rfl]]
[List.get?_concat_length,[Eq, List.get?, HAppend.hAppend, List.cons, List.nil, List.length, Option.some, rfl, Eq.mpr, Eq.refl, List.cons_append, List.length_cons, of_eq_true, Eq.trans, congrFun, congrArg, PProd.fst, eq_self]]
[ReaderT.run_read,[rfl]]
[StateT.run_lift,[rfl]]
[Prod.snd_swap,[rfl]]
[Â«term_^_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.add_le_add_left,[LE.le, HAdd.hAdd, Nat.le.dest]]
[UInt16.xor,[UInt16.mk, Fin.xor, UInt16.val]]
[Array.isEqv,[dite, Eq, Array.size, Array.isEqvAux, OfNat.ofNat, Bool.false]]
[StateRefT'.lift,[]]
[iff_iff_eq,[Iff.intro, propext, iff_of_eq]]
[let_value_eq,[rfl]]
[List.mapA,[Unit.unit, List, Pure.pure, List.nil, Seq.seq, Functor.map, List.cons, PProd.fst]]
[instSemiringFin.proof_10,[Eq.mpr, Eq.refl, Eq, HMul.hMul, OfNat.ofNat, instSemiringFin.proof_4, instSemiringFin.proof_5]]
[Mathlib.Tactic.Lint.NamedLinter.toLinter,[]]
[Nat.shiftRight,[Nat, HDiv.hDiv, PProd.fst, OfNat.ofNat]]
[Nat.not_le_of_not_ble_eq_true,[absurd, Nat.ble_eq_true_of_le]]
[Except.error.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[USize.decLt,[Decidable, LT.lt, inferInstanceAs]]
[exists_imp_exists',[Exists.elim, Exists.intro]]
[List.eraseDup,[List.pwFilter, Ne]]
[instModUInt32,[Mod.mk, UInt32.mod]]
[Nat.le_succ_of_pred_le,[Unit.unit, LE.le, Nat.succ, Nat.zero_le, Nat.succ_le_succ]]
[Nat.div.proof_1,[WellFoundedRelation.wf, measure, id]]
[List.ne_nil_of_length_eq_succ,[]]
[Function.const,[]]
[Subtype.map_id,[funext, Eq, Subtype.map, id, rfl]]
[USize.land,[USize.mk, Fin.land, USize.val]]
[add_zero,[AddMonoid.add_zero]]
[ByteArray.noConfusionType,[]]
[DoResultPRBC.noConfusionType,[]]
[Tactic.Ring.HornerExpr.noConfusionType,[]]
[Mathlib.Tactic.Lint.instDecidableEqLintVerbosity.proof_1,[]]
[ExceptT.lift,[ExceptT.mk, Functor.map, Except.ok]]
[instAddCommMonoid_1,[AddCommMonoid.mk, instAddCommMonoid_1.proof_1]]
[UInt64.instSemiringUInt64.proof_5,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, congrFun, HMul.hMul, UInt64.zero_def, UInt64.mul_def, UInt64.mk, OfNat.ofNat, MonoidWithZero.zero_mul, UInt64.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt64]]
[unexpandListCons,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, Unit.unit]]
[Nat.min_le_left,[Decidable.em, LE.le, of_eq_true, Eq.trans, congrFun, congrArg, ite_congr, eq_true, Eq.refl, ite_true, le_refl, Eq.symm, Eq.mpr, eq_false, ite_false, Nat.le_of_not_le]]
[namedPattern,[]]
[Mathlib.Tactic.Lint.NamedLinter.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[List.erasep_append_right,[Eq, List.erasep, HAppend.hAppend, rfl, of_eq_true, Eq.trans, congr, congrArg, List.cons_append, List.erasep_cons_of_neg, Not, eq_false, And.left, Iff.mp, List.forall_mem_cons, eq_true_of_decide, Eq.refl, Bool.true, List.cons, PProd.fst, And.right, eq_self]]
[instMulUInt8,[Mul.mk, UInt8.mul]]
[and_iff_right_of_imp,[Iff.intro, And.right, And.intro]]
[Nat.lt_of_le_and_ne,[LT.lt, Nat.eq_or_lt_of_le, absurd]]
[Nat.sub_eq_iff_eq_add,[Iff.intro, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Eq.symm, HSub.hSub, Nat.sub_add_cancel, rfl, Nat.add_sub_cancel]]
[optParam_eq,[rfl]]
[Nat.gcd_gcd_self_right_left,[Nat.dvd_antisymm, Nat.gcd_dvd_right, Nat.gcd, Nat.dvd_gcd, Nat.gcd_dvd_left, Nat.dvd_refl]]
[map_congr,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Functor.map, funext, eq_self]]
[Int.decEq,[Decidable, Eq, Int.ofNat, decEq, Decidable.isTrue, Int.decEq.proof_1, Decidable.isFalse, Int.decEq.proof_2, Int.negSucc, Int.decEq.proof_3, Int.decEq.proof_4, Int.decEq.proof_5, Int.decEq.proof_6]]
[Subtype.restrict_def,[rfl]]
[List.le,[Not, LT.lt]]
[List.mem_erasep_of_neg,[Iff.intro, List.mem_of_mem_erasep, Or.elim, List.exists_or_eq_self_of_erasep, Eq.mpr, Eq.refl, Mem.mem, List.erasep]]
[instSemiringFin.proof_12,[rfl]]
[Â«term_Ã—__1Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.bracketedExplicitBinders, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Int.negOfNat_mul_ofNat,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Int.negOfNat, Int.ofNat, Int.mul_comm, of_eq_true, Eq.trans, congrFun, congrArg, Int.ofNat_mul_negOfNat, Nat.mul_comm, eq_self]]
[Fin.instShiftLeftFin,[ShiftLeft.mk, Fin.shiftLeft]]
[ByteArray.empty,[ByteArray.mkEmpty, OfNat.ofNat]]
[iff_and_self,[Eq.mpr, Eq.refl, Iff, And, propext, and_comm, iff_self_and, Iff.rfl]]
[instHDiv,[HDiv.mk, Div.div]]
[List.mem_inter_iff,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, List.mem_filter, List.nil, Decidable.decide, Mem.mem, congrFun, And, List.mem_nil, Eq, Bool.true, false_and, eq_true_of_decide, Eq.refl, Eq.mpr, List.cons, List.mem_cons, And.congr_right_iff, decide_eq_true_iff, Iff.rfl]]
[String.singleton,[String.push]]
[set.piecewise,[ite, Mem.mem]]
[System.SearchPath.toString,[String.intercalate, Char.toString, System.SearchPath.separator, List.map, System.FilePath.toString]]
[UInt16.instRingUInt16.proof_3,[congrArg, UInt16.mk, Ring.gsmul_succ', UInt16.val]]
[instSubsingletonEmpty.proof_1,[Subsingleton.intro, Empty.elim]]
[Nat.pred_le_pred,[Nat.zero, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Nat.succ, LE.le, Nat.pred, Nat.le.refl, Nat.le_trans, Nat.le_succ]]
[StateT.run_get,[rfl]]
[BinaryHeap.mkHeap.loop.proof_2,[Nat.lt_of_succ_le]]
[Option.some_get,[Eq.refl, Bool.true, HEq.refl, Eq, Option.some, Option.get, rfl]]
[and_congr_left,[Iff.trans, And.comm, and_congr_right]]
[max_left_comm,[left_comm, max, max_comm, max_assoc]]
[Int.add_lt_of_lt_neg_add,[]]
[Not.decidable_imp_symm,[Decidable.not_imp_symm]]
[Â«termâˆ…Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[HEq.noConfusionType,[]]
[Applicative.toSeqLeft,[]]
[System.FilePath.pathSeparator,[ite, Eq, System.Platform.isWindows, Bool.true, Char.ofNat]]
[Subtype.coe_injective,[Subtype.ext]]
[Decidable.imp_or_distrib,[of_eq_true, Eq.trans, congr, congrArg, Iff, propext, Decidable.imp_iff_not_or, Or.left_comm, Or, or_comm, Not, or_self, iff_self]]
[rfl.proof_1,[Eq.refl]]
[add_add_add_comm,[of_eq_true, Eq.trans, congr, congrArg, Eq, add_left_comm, HAdd.hAdd, add_assoc, eq_self]]
[Nat.coprime.gcd_mul_right_cancel_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, HMul.hMul, Nat.mul_comm, Nat.coprime.gcd_mul_left_cancel_right, rfl]]
[instDecidableEqUInt8,[UInt8.decEq]]
[LawfulApplicative.noConfusionType,[]]
[instHashableUInt16,[Hashable.mk, UInt16.toUInt64]]
[imp_true_iff,[iff_true_intro, trivial]]
[instAddCommGroup.proof_4,[Semiring.nsmul_succ']]
[InvImage.wf.proof_1,[WellFounded.intro, InvImage.accessible, WellFounded.apply]]
[eq_true_of_decide,[propext, Iff.intro, trivial, of_decide_eq_true]]
[unsafeCast,[cast, unsafeCast.proof_1, PUnit]]
[Nat.instCommSemiringNat.proof_3,[rfl]]
[Subtype.ext_iff,[Iff.intro, congrArg, Subtype.val, Subtype.ext]]
[Option.forall,[Iff.intro, And.intro, Option.none, Option.some, And.left, And.right]]
[and_iff_left,[Iff.intro, And.left, And.intro]]
[Substring.extract,[Substring, ite, GE.ge, Substring.mk, OfNat.ofNat, Nat.min, HAdd.hAdd]]
[Option.lift_or_get_choice,[Unit.unit, Or, Eq, Option.lift_or_get, Or.inl, rfl, Or.inr]]
[List.replicate,[List, List.nil, List.cons, PProd.fst]]
[Nat.right_distrib,[]]
[Int.sub_pos_of_lt,[]]
[instSemiringFin.proof_11,[rfl]]
[Prod.ext,[rfl, Eq.symm, Eq.refl]]
[List.mem_map,[Unit.unit, Iff, Mem.mem, List.map, Exists, And, Eq, of_eq_true, Eq.trans, congr, congrArg, propext, List.mem_nil, funext, congrFun, false_and, eq_false, exists_false, eq_true_of_decide, Eq.refl, Bool.true, Eq.mpr, List.cons, List.map_cons, List.mem_cons, Or, PProd.fst, Iff.intro, Exists.intro, And.intro, Or.inl, rfl, Or.inr, Eq.symm, eq_of_heq, HEq.refl]]
[Array.get?_eq_get?,[Classical.em, LT.lt, Array.size, Eq.mpr, congrFun, congrArg, Eq, dif_pos, List.get?, Array.data, of_eq_true, Eq.trans, Option.some, List.get, Array.get.proof_1, Fin.mk, List.get?_eq_get, eq_self, dif_neg, Option.none, List.get?_len_le, le_of_not_lt]]
[List.cons.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instLEFloat,[LE.mk, Float.le]]
[instDecidableEqSum,[Decidable, Eq, dite, Decidable.isTrue, instDecidableEqSum.proof_1, Decidable.isFalse, instDecidableEqSum.proof_2, instDecidableEqSum.proof_3, instDecidableEqSum.proof_4, instDecidableEqSum.proof_5, instDecidableEqSum.proof_6]]
[congrArg,[rfl]]
[Int.mul_nonneg_of_nonpos_of_nonpos,[]]
[List.rotate,[List, HAppend.hAppend]]
[Array.toPersistentArray,[Array.foldl, Std.PersistentArray.push, Std.PersistentArray.empty, OfNat.ofNat, Array.size]]
[UInt8.instAddSemigroupUInt8,[AddSemigroup.mk, UInt8.instAddSemigroupUInt8.proof_1]]
[iff_true_intro,[Iff.intro, True.intro]]
[le_trans,[Preorder.le_trans]]
[Tactic.Ring.evalHorner,[Tactic.Ring.HornerExpr.const, Tactic.Ring.HornerExpr.xadd, Tactic.Ring.RingM, Prod, Tactic.Ring.HornerExpr, Lean.Expr, ite, Eq, OfNat.ofNat, Bind.bind, Tactic.Ring.mkAppCS, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Prod.fst, Tactic.Ring.HornerExpr.e, List.nil, Pure.pure, Prod.mk, Tactic.Ring.HornerExpr.xadd', Tactic.Ring.HornerExpr.reflConv, And, Prod.snd, Lean.Expr.numeral?, Option.some, Lean.mkRawNatLit, HAdd.hAdd, liftM, Lean.Meta.mkEqRefl]]
[UInt32.instInhabitedFinSize,[Inhabited.mk, Fin.ofNat', OfNat.ofNat, UInt32.size_positive]]
[instIsAddRightCancel.proof_1,[Eq.mpr, Eq.refl, Eq, Eq.symm, add_neg_cancel_right, HAdd.hAdd, Neg.neg, rfl]]
[coeD,[CoeDep.coe]]
[Char.noConfusionType,[]]
[String.length,[Nat, List.length]]
[RandomGen.next,[]]
[Array.foldrM.fold.proof_1,[Nat.lt_of_lt_of_le, Nat.lt_succ_self]]
[instOne,[One.mk, OfNat.ofNat]]
[Or.imp_right,[Or.imp, id]]
[SizeOfRef,[Measure, SizeOf.sizeOf]]
[List.exists_of_mem_bind,[Iff.mp, List.mem_bind]]
[Nat.gcd_dvd_gcd_mul_right_right,[Nat.gcd_dvd_gcd_of_dvd_right, Nat.dvd_mul_right]]
[HShiftRight.noConfusionType,[]]
[List.forM_cons,[rfl]]
[Sigma.noConfusionType,[]]
[mul_one,[Monoid.mul_one]]
[LE.noConfusionType,[]]
[Array.instAppendArray,[Append.mk, Array.append]]
[List.cons_subset_of_subset_of_mem,[Iff.mpr, List.cons_subset, And.intro]]
[UInt64.instCommRingUInt64,[CommRing.mk, UInt64.instCommRingUInt64.proof_1]]
[String.drop,[Substring.toString, Substring.drop, String.toSubstring]]
[Option.some_bind,[rfl]]
[exists_and_distrib_right,[of_eq_true, Eq.trans, congr, congrArg, Iff, Exists, funext, propext, and_comm, exists_and_distrib_left, iff_self, And]]
[UInt64.instSemiringUInt64.proof_1,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt64.zero_def, UInt64.add_def, UInt64.mk, OfNat.ofNat, add_zero, UInt64.val, UInt64.mk_val_eq, eq_self, propext, forall_const, UInt64]]
[Function.const_comp,[rfl]]
[Array.forM,[Array.foldlM, PUnit.unit]]
[instReprUInt16,[Repr.mk, repr, UInt16.toNat]]
[Int.subNatNat_add_add,[Int.subNatNat_elim, Eq, Int.subNatNat, HAdd.hAdd, Eq.mpr, Eq.refl, Int.ofNat, Nat.add_assoc, Nat.add_comm, Eq.symm, Int.subNatNat_add_left, OfNat.ofNat, Int.negSucc, Int.subNatNat_add_right]]
[eq_or_ne,[em, Eq]]
[dbgTraceVal,[dbgTrace, ToString.toString]]
[Mathlib.ExtendedBinder.Â«command__Binder_predicate_____=>_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.parser, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[UInt16.mul,[UInt16.mk, HMul.hMul, UInt16.val]]
[Int.neg_mul_eq_mul_neg,[Int.neg_eq_of_add_eq_zero, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HMul.hMul, Neg.neg, OfNat.ofNat, Eq.symm, Int.distrib_left, Int.add_right_neg, Int.mul_zero, rfl]]
[Nat.coprime_zero_left,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, Eq, Nat.gcd_zero_left, OfNat.ofNat, iff_self]]
[le_imp_le_of_lt_imp_lt,[le_of_not_lt, not_le_of_gt]]
[UInt8.isLower,[and, Decidable.decide, GE.ge, OfNat.ofNat, LE.le]]
[Mathlib.Tactic.Ext.Â«termExt_proof%Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Nat.lt_wfRel,[WellFoundedRelation.mk, Nat.lt, Nat.lt_wfRel.proof_1]]
[imp_not_comm,[imp.swap]]
[exists_imp_exists,[Exists.elim, Exists.intro]]
[UInt32.isValidChar,[Nat.isValidChar, UInt32.toNat]]
[not_imp_self,[Decidable.not_imp_self]]
[Option.ne_none_iff_isSome,[of_eq_true, Eq.trans, congr, congrArg, Iff, ne_eq, Option.none, Not, eq_self, eq_false_of_decide, Eq.refl, Bool.false, congrFun, Eq, Option.isSome_none, Bool.true, eq_false', eq_true_of_decide, Eq.symm, Option.some, Option.isSome_some]]
[UInt32.instRingUInt32.proof_1,[congrArg, UInt32.mk, Ring.sub_eq_add_neg, UInt32.val]]
[Int.neg_add_lt_right_of_lt_add,[Int.neg_add_lt_left_of_lt_add, Eq.mp, Eq.refl, LT.lt, HAdd.hAdd, Int.add_comm]]
[Prod.map_comp_map,[funext, of_eq_true, Eq.trans, congr, congrArg, Eq, Function.comp_apply, Prod.map, prod_map, Prod.mk, Prod.fst, Prod.snd, Function.comp, eq_self]]
[UInt64.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd]]
[UInt8.instRingUInt8.proof_5,[UInt8.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, UInt8.val, congrFun, HAdd.hAdd, UInt8.neg_def, UInt8.add_def, UInt8.mk, Neg.neg, add_left_neg, UInt8.zero_def, eq_true_of_decide, Eq.refl, Bool.true]]
[List.instUnionList,[Union.mk, List.union]]
[String.toAsciiByteArray.loop,[WellFounded.fix, dite, Eq, String.atEnd, Bool.true, PSigma.mk]]
[Int.lt_sub_left_of_add_lt,[]]
[String.toFormat,[Std.Format.joinSep, String.splitOn, Std.Format.line]]
[precArg,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Prod.mk.eta,[Eq, Prod.mk, Prod.fst, Prod.snd, rfl]]
[List.spanAux,[Prod, List, Prod.mk, List.reverse, List.nil, Unit.unit, PProd.fst, List.cons]]
[instSemigroupFin.proof_1,[Fin.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, Fin.val, Eq.trans, congrFun, HMul.hMul, Fin.mul_def, Fin.mk, HMod.hMod, Nat.mod_lt, Fin.size_positive, Eq.refl, Eq.symm, Eq.mp, Nat.mul_mod, Nat.mod_eq_of_lt, Fin.isLt, Nat.mul_assoc, rfl]]
[String.leftpad_length,[Eq, String.length, String.leftpad, max, of_eq_true, Eq.trans, congrFun, congrArg, List.leftpad_length, List.length, eq_self]]
[withPtrAddrUnsafe,[ptrAddrUnsafe]]
[USize.instSemigroupUSize.proof_1,[congrArg, USize.mk, Semigroup.mul_assoc, USize.val]]
[fixCore1,[bfix1, USize.size]]
[StateT.run'_eq,[rfl]]
[instHOrElse,[HOrElse.mk, OrElse.orElse]]
[List.hasDecidableLt.proof_3,[Eq.symm, eq_of_heq, Eq.refl, List.cons, HEq.refl, False, absurd]]
[optional,[HOrElse.hOrElse, Functor.map, Option.some, Pure.pure, Option.none]]
[UInt8.lt,[LT.lt, UInt8.val]]
[List.set_succ,[rfl]]
[Option.decidable_forall_mem.proof_1,[of_eq_true, Eq.trans, forall_congr, implies_congr, propext, Option.mem_def, eq_false', Eq.refl, false_implies, implies_true]]
[LawfulFunctor.noConfusionType,[]]
[Nat.ctor_eq_zero,[rfl]]
[instBEqOrdering,[BEq.mk, BEq.beq, Ordering.toCtorIdx]]
[CoeSort.coe,[]]
[Decidable.not_iff,[Iff, Not, of_eq_true, Eq.trans, congr, congrArg, eq_true, iff_true, iff_self, eq_false, iff_false, propext, not_not]]
[xor_self,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, congr, Or, eq_false, and_not_self, eq_false_of_decide, Eq.refl, Bool.false, False, eq_true_of_decide, Bool.true]]
[Array.findIdx?,[Array.size, OfNat.ofNat, rfl, Array.findIdx?.loop]]
[le_of_not_ge,[Or.resolve_left, le_total]]
[Semiring.add_mul,[]]
[decidable_eq_of_bool_pred,[dite, Eq, Bool.true, Decidable.isTrue, Decidable.isFalse, decidable_eq_of_bool_pred.proof_1]]
[bool,[Unit.unit, ToBool.toBool]]
[List.last,[absurd, List.last.proof_1, PProd.fst, List.last.proof_2]]
[stdRange,[Prod.mk, OfNat.ofNat]]
[List.mem_reverseAux,[Iff, Mem.mem, List.reverseAux, Or, of_eq_true, Eq.trans, congrArg, congrFun, propext, List.mem_nil, false_or, iff_self, Eq.mpr, congr, PProd.fst, List.cons, List.mem_cons, Eq.refl, Eq, Eq.symm, or_assoc, or_comm, Iff.rfl]]
[Mathlib.Tactic.Lint.nolint,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[mul_right_inj,[Iff.intro, mul_left_cancel, congrArg, HMul.hMul]]
[instOfNatUSize,[OfNat.mk, USize.ofNat]]
[EStateM.instInhabitedEStateM,[Inhabited.mk, EStateM.Result.error, arbitrary]]
[List.exists_mem_cons_of,[Exists.intro, And.intro, List.mem_cons_self]]
[List.findIdx,[Unit.unit, Nat, OfNat.ofNat, ite, Nat.succ, PProd.fst]]
[instSizeOf,[SizeOf.mk, default.sizeOf]]
[instTransEq_1.proof_1,[]]
[Char.isAlphanum,[or, Char.isAlpha, Char.isDigit]]
[Option.join_eq_some,[of_eq_true, Eq.trans, congrFun, congrArg, Iff, propext, Option.bind_eq_some, Exists, funext, And, Eq, Option.some, id_eq, exists_eq_right, iff_self]]
[plift.up.inj,[]]
[List.get_cons_drop,[Eq.refl, List.length, List.nil, HEq.refl, Eq, List.cons, List.get, List.drop, HAdd.hAdd, OfNat.ofNat, rfl, PProd.fst, Nat.le_of_succ_le_succ, List.length_cons, Nat.add]]
[Quotient.inductionOn,[Quot.inductionOn]]
[dbgSleep,[Unit.unit]]
[Tactic.NormCast.NormCastExtension.down,[]]
[not_forall,[Decidable.not_forall]]
[List.transposeAux,[List, List.cons, List.nil, PProd.fst]]
[USize.ofNat32.proof_1,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, OfNat.ofNat, HEq.refl, LT.lt, USize.size, usize_size_eq, Nat.lt_trans, of_decide_eq_true, Bool.true]]
[List.instMemList,[Mem.mk, List.mem]]
[panicWithPos,[panic, HAppend.hAppend, ToString.toString]]
[Int.sign,[Unit.unit, Int, OfNat.ofNat, Neg.neg]]
[Prod.ext_iff,[Eq.mpr, Eq.refl, Iff, Eq, And, Prod.fst, Prod.snd, Eq.symm, Prod.mk.eta, Prod.mk, propext, Prod.mk.inj_iff, Iff.rfl]]
[ByteArray.forInUnsafe.loop,[ite, LT.lt, Bind.bind, Pure.pure, ByteArray.forInUnsafe.loop, HAdd.hAdd, OfNat.ofNat]]
[Reader,[ReaderT, Id]]
[instDivUInt8,[Div.mk, UInt8.div]]
[UInt32.instRingUInt32.proof_4,[congrArg, UInt32.mk, SubNegMonoid.gsmul_neg', UInt32.val]]
[List.erasep_subset,[Mem.mem, List.exists_or_eq_self_of_erasep, Eq.mpr, Eq.refl, List.subset.refl, HAppend.hAppend, List.cons, propext, List.mem_append, Or, Or.inl, Or.inr, List.mem_cons_of_mem]]
[List.hasDecEq.proof_1,[rfl]]
[Int.lt_add_of_neg_add_lt_left,[Int.lt_add_of_sub_left_lt, Eq.mp, Eq.refl, LT.lt, HAdd.hAdd, Neg.neg, Int.add_comm]]
[Array.map,[Id.run, Array.mapM]]
[Nat.decEq,[Decidable, Eq, Nat.beq, Nat.decEq.proof_1, Decidable.isTrue, Nat.eq_of_beq_eq_true, Decidable.isFalse, Nat.ne_of_beq_eq_false]]
[id_eq,[rfl]]
[AddCommMonoid.add_comm,[]]
[Array.get.proof_1,[Fin.isLt]]
[UInt64.instSemiringUInt64.proof_7,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, UInt64.one_def, UInt64.mul_def, UInt64.mk, OfNat.ofNat, one_mul, UInt64.val, UInt64.mk_val_eq, eq_self, propext, forall_const, UInt64]]
[not,[Unit.unit, Bool, Bool.false, Bool.true]]
[Nat.mul_lt_mul_of_pos_right,[Nat.mul_lt_mul_of_pos_left, Nat.mul_comm]]
[Numeric.OfNat,[OfNat.mk, Numeric.ofNat]]
[List.hasDecidableLt,[Unit.unit, Decidable, LT.lt, Decidable.isFalse, List.hasDecidableLt.proof_1, Decidable.isTrue, List.lt.nil, List.hasDecidableLt.proof_2, List.cons, List.lt.head, List.hasDecidableLt.proof_3, PProd.fst, List.lt.tail, List.hasDecidableLt.proof_4]]
[ByteSlice.len,[]]
[decidableOfDecidableOfEq,[]]
[instDecidableLe_5,[LinearOrder.decidable_le]]
[Function.sometimes,[dite, Nonempty, Classical.choice]]
[MonadExcept.throw,[]]
[ByteArray.foldl,[Id.run, ByteArray.foldlM]]
[instReprProd,[Repr.mk, Std.Format, Std.Format.bracket, Std.Format.joinSep, List.reverse, ReprTuple.reprTuple, List.cons, repr, List.nil, HAppend.hAppend, Std.Format.text, Std.Format.line]]
[List.instForMList,[ForM.mk, List.forM]]
[List.last_cons,[absurd, Eq.refl, List.nil, rfl]]
[not_iff_not,[Decidable.not_iff_not]]
[Nat.zero_div,[Eq.trans, Nat.div_eq, OfNat.ofNat, if_neg, Nat.not_le_of_gt]]
[Nat.find_min,[And.right, Subtype.property, Nat.find_x]]
[Nat.mod.inductionOn,[Nat.div.inductionOn]]
[BinaryHeap.size_insert,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, BinaryHeap.size_heapifyUp, Array.push, BinaryHeap.arr, Fin.mk, Array.size, BinaryHeap.insert.proof_1, Array.size_push, HAdd.hAdd, OfNat.ofNat, eq_self]]
[BinaryHeap.singleton,[BinaryHeap.mk, List.toArray, List.cons, List.nil]]
[ST.Ref.mk.inj,[]]
[ne_false_of_eq_true,[Not, Eq, Bool.false]]
[Prod.lex.proof_1,[WellFounded.intro, Acc, Prod.Lex, WellFoundedRelation.rel, Prod.lexAccessible, WellFounded.apply, WellFoundedRelation.wf]]
[instLEUInt8,[LE.mk, UInt8.le]]
[Nat.lt.step.proof_1,[Nat.le_step]]
[Float.noConfusionType,[]]
[HasEquiv.noConfusionType,[]]
[mul_assoc,[Semigroup.mul_assoc]]
[unsafeBaseIO,[EStateM.Result.error, EStateM.run, Unit.unit]]
[List.tails,[Unit.unit, List, List.cons, List.nil, PProd.fst]]
[List.disjoint_of_subset_right,[]]
[String.firstDiffPos,[OfNat.ofNat, String.firstDiffPos.loop]]
[Array.instBEqArray,[BEq.mk, Array.isEqv, BEq.beq]]
[ExceptCpsT.run_lift,[rfl]]
[le_of_lt,[LE.le, And.left, le_not_le_of_lt]]
[Ordering.noConfusion,[noConfusionEnum, Ordering.toCtorIdx]]
[Int.lt_add_of_le_of_pos,[Int.add_lt_add_of_le_of_lt, Int.add_zero]]
[UInt64.instRingUInt64,[Ring.mk, UInt64.instRingUInt64.proof_1, UInt64.mk, Ring.gsmul, UInt64.val, UInt64.instRingUInt64.proof_2, UInt64.instRingUInt64.proof_3, UInt64.instRingUInt64.proof_4, UInt64.instRingUInt64.proof_5]]
[String.get,[Char, arbitrary, ite, Eq, PProd.fst, HAdd.hAdd, String.csize, OfNat.ofNat]]
[Substring.contains,[Substring.any, BEq.beq]]
[DivInvMonoid.gpow_zero',[]]
[le_iff_lt_or_eq,[Decidable.le_iff_lt_or_eq]]
[List.append,[List, List.cons, PProd.fst]]
[PSigma.skipLeft,[WellFoundedRelation.mk, PSigma.SkipLeft, WellFoundedRelation.rel, PSigma.skipLeft.proof_1]]
[List.takeList,[Prod, List, Prod.mk, List.nil, List.cons]]
[Mathlib.Tactic.Lint.getDeclsInMathlib,[Bind.bind, Mathlib.Tactic.Lint.getDeclsInCurrModule, Lean.MonadEnv.getEnv, ForIn.forIn, Lean.Core.CoreM, ForInStep, Array, Lean.Name, ite, Eq, Array.getOp, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield]]
[instDecidableTrue,[Decidable.isTrue, trivial]]
[List.scanl,[List, List.cons, List.nil, PProd.fst]]
[instCommMonoid_1.proof_2,[Semiring.one_mul]]
[Int.decEq.proof_4,[absurd]]
[max_self,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, if_t_t, LT.lt, eq_self]]
[Nat.pos_of_ne_zero,[Or.resolve_left, Nat.eq_zero_or_pos]]
[cast_proof_irrel,[rfl]]
[Repr.reprPrec,[]]
[Option.map_eq_some,[of_eq_true, Eq.trans, congr, congrArg, Iff, congrFun, Eq, Option.map_eq_map, Option.none, Option.map_none', Option.some, eq_false', Exists, funext, And, false_and, eq_false, exists_false, eq_true_of_decide, Eq.refl, Bool.true, Eq.symm, Option.map_some', Option.some.injEq, propext, exists_eq_left', iff_self]]
[Subtype.instDecidableEqSubtype,[Decidable, Eq, Subtype.mk, dite, Decidable.isTrue, Subtype.instDecidableEqSubtype.proof_1, Decidable.isFalse, Subtype.instDecidableEqSubtype.proof_2]]
[PointedType.noConfusionType,[]]
[instCommMonoid_1.proof_3,[Semiring.npow_zero']]
[Â«term_<|>_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Option.maybe,[Unit.unit, Option, Pure.pure, Option.none, Functor.map, Option.some]]
[Nat.le_of_mod_lt,[Decidable.byContradiction]]
[ST.Ref.ref,[]]
[BinaryHeap.size_heapifyUp,[Subtype.property, BinaryHeap.heapifyUp]]
[List.instForInList,[ForIn.mk, List.forIn]]
[List.modifyNthTail,[List, List.nil, List.cons, PProd.fst]]
[USize.instSemiringUSize.proof_6,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, HMul.hMul, USize.zero_def, USize.mul_def, USize.mk, OfNat.ofNat, MonoidWithZero.mul_zero, USize.val, eq_self, propext, forall_const, USize]]
[String.Iterator.nextn,[String.Iterator, PProd.fst, String.Iterator.next]]
[Â«termIfLet_:=_Then_Else_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[ulift.up.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt32.sub,[UInt32.mk, HSub.hSub, UInt32.val]]
[Iff.rfl,[Iff.refl]]
[String.back,[String.get, String.prev, String.bsize]]
[le_not_le_of_lt,[And, LE.le, Not, Iff.mp, lt_iff_le_not_le]]
[ExceptCpsT.runCatch_bind_lift,[rfl]]
[List.disjoint_right,[List.disjoint_comm]]
[flip,[]]
[Int.subNatNat_of_lt,[Eq.mpr, Eq.refl, Eq, Int.subNatNat, Int.negSucc, Nat.pred, HSub.hSub, Int.subNatNat_of_sub_eq_succ, Nat.succ, Nat.succ_pred_eq_of_pos, Nat.sub_pos_of_lt, rfl]]
[UInt64.instInhabitedFinSize,[Inhabited.mk, Fin.ofNat', OfNat.ofNat, UInt64.size_positive]]
[List.length_append,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.length, List.nil_append, congrFun, HAdd.hAdd, List.length_nil, Nat.zero_add, eq_self, List.cons_append, List.length_cons, HAppend.hAppend, Nat.succ, Nat.succ_add]]
[Nat.div_mul_le_self,[LE.le, HMul.hMul, HDiv.hDiv, Eq.mpr, congrFun, congrArg, Eq.trans, Nat.div_zero, OfNat.ofNat, Nat.mul_zero, Nat.zero_le, Iff.mp, Nat.le_div_iff_mul_le, Nat.succ_pos, Nat.le_refl, HAdd.hAdd]]
[List.nil_union,[of_eq_true, eq_self]]
[Classical.byContradiction,[Decidable.byContradiction]]
[Option.pmap,[Option, Option.none, Option.some, Option.pmap.proof_1]]
[OfNat.noConfusionType,[]]
[Nat.succ_le_succ,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, LE.le, Nat.succ, Nat.le.refl, Nat.le.step, PProd.fst]]
[List.card_le_card_cons,[Decidable.em, Mem.mem, of_eq_true, Eq.trans, congrArg, LE.le, List.card, List.card_cons_of_mem, eq_true, le_refl, Eq.symm, List.card_cons_of_not_mem, Not, eq_false, eq_true_of_decide, Eq.refl, Bool.true, Nat.le_succ]]
[USize.size,[HPow.hPow, OfNat.ofNat, System.Platform.numBits]]
[Int.decEq.proof_5,[]]
[Nat.dvd_of_mod_eq_zero,[Exists.intro, HDiv.hDiv]]
[not_or_distrib,[Iff.intro, And.intro, Or.inl, Or.inr, False, Or.elim]]
[Array.anyM.loop,[dite, LT.lt, Unit.unit, Bool, Pure.pure, Bool.false, Bind.bind, Array.get, Fin.mk, Array.anyM.loop.proof_1, ite, Eq, Bool.true, PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[List.append_subset_of_subset_of_subset,[Or.elim, Iff.mp, List.mem_append]]
[PProd.noConfusionType,[]]
[if_congr,[if_ctx_congr]]
[Nat.le_sub_iff_add_le,[Eq.mpr, Eq.refl, Iff, LE.le, HSub.hSub, HAdd.hAdd, Eq.symm, Nat.add_sub_cancel, propext, Nat.sub_le_sub_right_iff, Iff.rfl]]
[Int.mul_nonpos_of_nonneg_of_nonpos,[]]
[Int.negSucc_ofNat_add_ofNat,[rfl]]
[Nat.prod_dvd_and_dvd_of_dvd_prod.proof_2,[Eq.refl, Nat.gcd]]
[Equivalence.trans,[]]
[instDecidableEqUInt64,[UInt64.decEq]]
[or_and_distrib_right,[Iff.trans, And.comm, and_or_distrib_left, or_congr]]
[BinaryHeap.mkHeap.loop.proof_1,[rfl]]
[Hashable.hash,[]]
[Fin.checkedAdd,[Option, Fin, Fin.overflowingAdd, Option.none, Option.some]]
[Option.toLOption,[Unit.unit, Lean.LOption, Lean.LOption.none, Lean.LOption.some]]
[instToStringNat,[ToString.mk, Nat.repr]]
[Ring.sub_eq_add_neg,[]]
[List.toPersistentArray,[List.toPersistentArrayAux, Std.PersistentArray.mk]]
[Nat.lt_of_add_lt_add_right,[Nat.lt_of_add_lt_add_left, Eq.mpr, Eq.refl, LT.lt, HAdd.hAdd, Nat.add_comm]]
[List.zipRight,[List.mapâ‚‚Right, Prod.mk]]
[Array.reverse,[OfNat.ofNat, Array.reverse.rev]]
[Decidable.lt_or_eq_of_le,[dite, LE.le, Or.inr, le_antisymm, Or.inl, lt_of_le_not_le]]
[Function.apply_update,[Decidable.em, Eq, of_eq_true, Eq.trans, congr, congrArg, Function.update_same, eq_self, Eq.symm, Function.update_noteq, ne_eq, Not, eq_false, eq_true_of_decide, Eq.refl, Bool.true]]
[Int.ofNat_add_ofNat,[rfl]]
[String.isInt,[ite, Eq, String.get, OfNat.ofNat, Char.ofNat, Substring.isNat, Substring.drop, String.toSubstring, String.isNat]]
[List.count,[List.countp, Eq]]
[lt_by_cases,[dite, LT.lt, lt_by_cases.proof_1]]
[Int.lt_iff_le_not_le,[Eq.mpr, Eq.refl, Iff, LT.lt, And, LE.le, Not, propext, Int.lt_iff_le_and_ne, Iff.intro, And.intro, Not.imp, Int.le_antisymm, Ne, Int.le_refl]]
[MProd.mk.inj,[And.intro]]
[calc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.unary, calcStep]]
[Sigma.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[instSemiringFin.proof_4,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.mul_def, congrFun, HMod.hMod, Nat.mul_comm, eq_self, HMul.hMul]]
[List.append_right_cancel,[List.append_inj_left', rfl]]
[instToStringByteSlice,[ToString.mk, Id.run, Bind.bind, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield]]
[Nat.instDivNat,[Div.mk, Nat.div]]
[Nat.sub_add_cancel,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HSub.hSub, Nat.add_comm, Nat.add_sub_of_le, rfl]]
[eq_max,[le_antisymm, max, le_max_left, le_max_right, max_le]]
[termMax_prec,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[le_of_eq,[le_refl]]
[instToStringSubtype,[ToString.mk, ToString.toString, Subtype.val]]
[Array.modifyM,[dite, LT.lt, Array.size, Bind.bind, Pure.pure, Array.set, Array.modifyM.proof_1]]
[List.enumFrom,[List, Prod, Nat, List.nil, List.cons, Prod.mk, PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[StateT.run_pure,[rfl]]
[Array.get?_push_lt,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, Array.get?, Array.mk, List.concat_eq_append, Array.data, Array.get?_eq_get?, HAppend.hAppend, List.cons, List.nil, Option.some, Array.get_eq_get, Eq.symm, List.get?_eq_get, List.get?_append]]
[UInt32.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd]]
[Function.injective.of_comp_iff,[Iff.intro, Function.injective.of_comp, Function.injective.comp]]
[System.Platform.numBits,[Subtype.val, System.Platform.getNumBits, Unit.unit]]
[coeOfHTCT,[CoeT.mk, CoeHTCT.coe]]
[autoParam,[]]
[Function.forall_update_iff,[Iff.intro, Function.update]]
[instMonadBaseIO,[inferInstanceAs, Monad, EIO, Empty]]
[Â«term_^^^_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instMulUInt16,[Mul.mk, UInt16.mul]]
[Nat.iterate,[PProd.fst]]
[Classical.em,[]]
[Tactic.Ring.horner_add_horner_lt,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Tactic.Ring.horner, Eq.symm, OfNat.ofNat, of_eq_true, Eq.trans, congr, congrArg, add_comm, HMul.hMul, HPow.hPow, add_assoc, congrFun, add_zero, add_mul, mul_assoc, pow_add, eq_self]]
[Array.instHAppendArrayListArray,[HAppend.mk, Array.appendList]]
[precMax,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[instMonadFinallyBaseIO,[inferInstanceAs, MonadFinally, EIO, Empty]]
[Int.eq_zero_ofNatAbs_eq_zero,[Eq, OfNat.ofNat, congr_arg, Int.ofNat, absurd, Nat.succ_ne_zero]]
[Nat.not_le_of_lt,[Nat.not_le_of_gt]]
[List.mem_join,[Unit.unit, Iff, Mem.mem, List.join, Exists, And, of_eq_true, Eq.trans, congr, congrArg, propext, List.mem_nil, funext, congrFun, false_and, eq_false, exists_false, eq_true_of_decide, Eq.refl, Bool.true, Eq.mpr, List.mem_append, Or, PProd.fst, List.cons, Iff.intro, Exists.intro, And.intro, Or.inl, rfl, Or.inr, Eq.symm, eq_of_heq, HEq.refl]]
[List.mmap'Diag,[Unit.unit, Unit, Pure.pure, Bind.bind, List.mmap', PProd.fst]]
[List.forall_mem_of_forall_mem_cons,[And.right, Iff.mp, List.forall_mem_cons]]
[by_contradiction,[Decidable.by_contradiction]]
[Array.size_pop,[List.length_dropLast, Array.data]]
[Classical.strongIndefiniteDescription.proof_1,[Subtype.property, Classical.indefiniteDescription]]
[Nat.coprime.coprime_mul_left_right,[Nat.coprime.coprime_dvd_right, Nat.dvd_mul_left]]
[Int.natAbs_neg,[Unit.unit, Eq, Int.natAbs, Neg.neg, rfl]]
[iff_def',[Iff.trans, iff_def, And.comm]]
[exists_of_exists_unique,[Exists.elim, Exists.intro, And.left]]
[FloatArray.forIn.loop.proof_1,[Nat.lt_of_le_of_lt, Nat.sub_le, HSub.hSub, FloatArray.size, OfNat.ofNat, Nat.sub_lt, Nat.zero_lt_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self, of_decide_eq_true, Eq.refl, Bool.true]]
[Function.comp_update,[funext, Function.apply_update]]
[Int.neg_eq_of_add_eq_zero,[Eq.mpr, Eq.refl, Eq, Neg.neg, Eq.symm, Int.add_zero, HAdd.hAdd, OfNat.ofNat, Int.add_assoc, Int.add_left_neg, Int.zero_add, rfl]]
[not_lt_of_ge,[not_le_of_gt]]
[Tactic.Ring.Cache.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Char.isValidUInt32,[LT.lt, UInt32.size, Nat.lt_trans, of_decide_eq_true, Eq.refl, Bool.true]]
[withPtrEqDecEq.proof_1,[toBoolUsing_eq_true, Unit.unit]]
[instDecidableRelLtLtOfOrd,[inferInstanceAs, DecidableRel, Eq, BEq.beq, Ord.compare, Ordering.lt, Bool.true]]
[Fin.overflowingAdd,[Prod.mk, Decidable.decide, LE.le, HAdd.hAdd, Fin.val]]
[Nat.not_le,[Iff.intro, Nat.lt_of_not_le, Nat.not_le_of_lt]]
[emptyWf.proof_1,[WellFounded.intro, Acc.intro, Acc, emptyRelation, Eq.refl]]
[List.mem_join_of_mem,[Iff.mpr, List.mem_join, Exists.intro, And.intro]]
[Ord.noConfusionType,[]]
[Nat.lt_succ_of_lt,[Nat.le_succ_of_le]]
[Char.ofNat,[dite, Nat.isValidChar, Char.ofNatAux, Char.mk, UInt32.mk, Fin.mk, OfNat.ofNat, Char.ofNat.proof_1, Char.ofNat.proof_2]]
[Nat.gcd_assoc,[Nat.dvd_antisymm, Nat.dvd_gcd, Nat.dvd_trans, Nat.gcd_dvd_left, Nat.gcd, Nat.gcd_dvd_right]]
[Quot.recOnSubsingleton.proof_1,[Subsingleton.elim, Quot.sound]]
[not_iff_comm,[Decidable.not_iff_comm]]
[Int.nonpos_of_neg_nonneg,[Int.le_of_neg_le_neg, Eq.mpr, Eq.refl, LE.le, Neg.neg, OfNat.ofNat, Int.neg_zero]]
[Option.getD_none,[rfl]]
[Tactic.NormCast.NormCastExtension.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Tactic.NormCast.NormCastExtension.mk, Eq.symm, eq_of_heq, HEq.refl]]
[dite_true,[rfl]]
[List.extractp,[Unit.unit, Prod, Option, List, Prod.mk, Option.none, List.nil, ite, Option.some, List.cons]]
[MProd.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, MProd.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.add_le_to_le_sub,[Eq.mpr, Eq.refl, Iff, LE.le, HAdd.hAdd, HSub.hSub, Eq.symm, Nat.add_sub_cancel, propext, Nat.sub_le_sub_right_iff, Iff.rfl]]
[instMonadState,[MonadState.mk, getThe, MonadStateOf.set, MonadStateOf.modifyGet]]
[List.sigma,[List.bind, List.map, Sigma.mk]]
[String.utf16PosToCodepointPos,[String.utf16PosToCodepointPosFrom, OfNat.ofNat]]
[Fin.div.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[Function.swap,[]]
[UInt8.instSemiringUInt8.proof_4,[congrArg, UInt8.mk, AddMonoid.nsmul_succ', UInt8.val]]
[System.FilePath.noConfusionType,[]]
[ReaderT.tryFinally,[MonadFinally.mk, MonadFinally.tryFinally']]
[Option.some.inj,[]]
[Decidable.not_and_distrib',[Iff.intro, dite, Or.inl, And.intro, Or.inr, not_and_of_not_or_not]]
[instRingFin.proof_2,[Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Eq, Fin.val, Fin.mul_def, Fin.mk, HMod.hMod, Nat.mod_lt, Fin.size_positive, congrFun, HMul.hMul, Nat.zero_mod, Nat.zero_mul, Fin.zero_def, eq_true_of_decide, Eq.refl, Bool.true]]
[Int.add_le_of_le_neg_add,[]]
[StateT.tryFinally,[MonadFinally.mk, Bind.bind, MonadFinally.tryFinally', Unit.unit, Prod, Option.some, Option.none, Pure.pure, Prod.mk]]
[List.mem_cons,[Iff.rfl]]
[Subtype.instDecidableEqSubtype.proof_1,[rfl]]
[UInt32.instCommRingUInt32.proof_1,[UInt32.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, UInt32.val, UInt32.mul_def, CommSemiring.mul_comm]]
[List.modifyNth,[List.modifyNthTail, List.modifyHead]]
[Substring.takeRight,[Substring.mk, Substring, HAdd.hAdd, Substring.prevn, Substring.bsize]]
[Exists.choose_spec,[Classical.choose_spec]]
[Substring.nextn,[String.Pos, PProd.fst, Substring.next]]
[UInt64.instRingUInt64.proof_3,[congrArg, UInt64.mk, Ring.gsmul_succ', UInt64.val]]
[Nat.sub.right_comm,[Eq.mpr, Eq.refl, Eq, HSub.hSub, Nat.sub_sub, HAdd.hAdd, Nat.add_comm, rfl]]
[List.disjoint_of_disjoint_cons_right,[List.disjoint_of_subset_right, List.subset_cons]]
[Array.data,[]]
[Int.ofNat.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[UInt16.sub,[UInt16.mk, HSub.hSub, UInt16.val]]
[Quot.exists_rep,[Quot.inductionOn, Exists.intro, rfl]]
[Squash.ind,[Quot.ind]]
[Function.has_uncurry.uncurry,[]]
[Numeric.noConfusionType,[]]
[Decidable.not_or_of_imp,[dite, Or.inr, Or.inl]]
[instTransEq,[Trans.mk, instTransEq.proof_1]]
[List.mmap,[Unit.unit, List, Pure.pure, List.nil, Bind.bind, PProd.fst, List.cons]]
[Quotient.lift,[Quot.lift]]
[of_as_true,[False.elim]]
[MonadWithReader.withReader,[]]
[Fin.checked_sub_spec,[Iff.intro, Decidable.em, LT.lt, Fin.val, False.elim, Eq.mp, Eq.trans, congrFun, congrArg, Eq, Unit.unit, Bool, Option, Fin, Prod.mk, Iff.mpr, decide_eq_true_iff, HSub.hSub, Option.none, Option.some, Bool.true, Bool.false, eq_false', Eq.symm, Nat.le_of_not_lt, Eq.refl, of_eq_true, decide_eq_false, Nat.not_lt_of_le, eq_true_of_decide]]
[DoResultBC.continue.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[false_implies,[propext, Iff.intro, trivial, absurd, of_decide_eq_false, Eq.refl, Decidable.decide, False]]
[Decidable.noConfusionType,[]]
[Nat.lt_of_sub_eq_succ,[Iff.mp, not_le, False.elim, Eq.mp, Eq.trans, congrFun, congrArg, Eq, Nat.sub_eq_zero_of_le, Nat.succ, eq_false']]
[USize.shiftRight,[USize.mk, HShiftRight.hShiftRight, USize.val, USize.modn, System.Platform.numBits]]
[Int.distrib_left,[Eq, HMul.hMul, HAdd.hAdd, of_eq_true, Eq.trans, congr, congrArg, Int.ofNat, Int.ofNat_add_ofNat, Int.ofNat_mul_ofNat, Nat.left_distrib, eq_self, Eq.mpr, Int.ofNat_add_negSucc_ofNat, Int.ofNat_mul_subNatNat, Nat.succ, Int.ofNat_mul_negSucc_ofNat, Int.negOfNat_eq_subNatNat_zero, Eq.refl, Int.subNatNat, OfNat.ofNat, Eq.symm, Int.subNatNat_add, rfl, Int.negSucc_ofNat_add_ofNat, Int.add_comm, Int.negSucc_ofNat_add_negSucc_ofNat, Int.negOfNat_add, Int.negOfNat, Nat.succ_add, Int.negSucc, Int.negSucc_ofNat_ofNat, Nat.mul_comm, Nat.right_distrib, Int.negSucc_ofNat_mul_subNatNat, Int.mul_negSucc_ofNat_negSucc_ofNat, Int.ofNat.injEq]]
[List.all,[List.foldr, and, Bool.true]]
[HPow.hPow,[]]
[hexDigitRepr,[String.singleton, Nat.digitChar]]
[Int.sign_zero,[rfl]]
[Int.lt_irrefl,[False]]
[Int.add_neg_of_neg_of_nonpos,[Int.add_lt_add_of_lt_of_le, Int.zero_add, OfNat.ofNat]]
[USize.val,[]]
[ByteSlice.getOp,[ByteArray.get!, ByteSlice.arr, HAdd.hAdd, ByteSlice.off]]
[Iff.elim,[Iff.elim.proof_1]]
[trans_rel_left,[]]
[LinearOrder.noConfusionType,[]]
[List.getLast?.proof_1,[]]
[Subarray.instForInSubarray,[ForIn.mk, Subarray.forIn]]
[Â«prec(_)Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[Nat.ble_succ_eq_true,[Eq.refl, Bool.true, HEq.refl, Eq, Nat.ble, Nat.succ, rfl, PProd.fst]]
[fixCore,[fixCore1]]
[Int.add_le_of_le_sub_left,[]]
[UInt64.modn,[UInt64.mk, HMod.hMod, UInt64.val]]
[UInt64.instSemiringUInt64.proof_9,[rfl]]
[instMonadStateOfStateT,[MonadStateOf.mk, StateT.get, StateT.set, StateT.modifyGet]]
[Nat.noConfusionType,[]]
[Prod.fst,[]]
[Int.distrib_right,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Int.mul_comm, HAdd.hAdd, Int.distrib_left, congr, HMul.hMul, eq_self]]
[Subtype.property,[]]
[List.not_bex_nil,[False]]
[instSTWorldEST,[STWorld.mk]]
[WellFounded.fixFEq.proof_1,[rfl]]
[Mathlib.Tactic.Lint.instInhabitedLintVerbosity,[Inhabited.mk, Mathlib.Tactic.Lint.LintVerbosity.low]]
[toLOptionM,[Bind.bind, Pure.pure, Option.toLOption]]
[USize.instSemiringUSize.proof_10,[rfl]]
[String.codepointPosToUtf16PosFrom,[Nat, PProd.fst, String.next, HAdd.hAdd, UInt32.toNat, Char.utf16Size, String.get, OfNat.ofNat]]
[ExceptT.tryCatch,[ExceptT.mk, Bind.bind, Except, Pure.pure, Except.ok]]
[Or.imp,[Or.elim, Function.comp, Or.inl, Or.inr]]
[Sub.sub,[]]
[List.exists_of_length_succ,[Exists, Eq, List.cons, absurd, Eq.symm, Nat.succ_ne_zero, Exists.intro, rfl]]
[OptionT.instMonadLiftOptionT,[MonadLift.mk, OptionT.lift]]
[Prod.anyI,[Nat.anyAux, Prod.snd, HSub.hSub, Prod.fst]]
[Mathlib.ExtendedBinder.extBinder,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.binderIdent, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat]]
[List.cons.injEq,[Eq.propIntro, And.intro, Eq.refl, List.cons, Eq.symm, eq_of_heq, HEq.refl]]
[Option.map_none,[rfl]]
[le_max_right,[dite, LT.lt, Eq.mpr, congrArg, LE.le, if_pos, le_of_lt, of_eq_true, Eq.trans, if_neg, eq_true, le_refl]]
[Mathlib.Tactic.Lint.NamedLinter.mk.inj,[And.intro]]
[UInt32.val,[]]
[Tactic.Ring.HornerExpr.xadd.inj,[And.intro]]
[List.anyM,[Unit.unit, Bool, Pure.pure, Bool.false, Bind.bind, Bool.true, PProd.fst]]
[Array.range,[Nat.fold, flip, Array.push, List.toArray, List.nil]]
[fixCore2,[bfix2, USize.size]]
[Int.neg_ofNat_of_succ,[rfl]]
[Function.hfunext,[]]
[Int.negSucc_ofNat_coe,[rfl]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.noConfusionType,[]]
[instDecidableDite,[Decidable, dite]]
[coeTail,[CoeTail.coe]]
[Nat.mul_mod,[]]
[instInhabitedTask,[Inhabited.mk, Task.pure, arbitrary]]
[existsâ‚‚_congr,[exists_congr]]
[List.set,[List, List.cons, PProd.fst, List.nil]]
[String.startsWith,[BEq.beq, Substring.take, String.toSubstring, String.length]]
[Mathlib.Tactic.Ext.Â«termExt_type%__Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Subtype.instSetoidSubtype,[Setoid.mk, HasEquiv.Equiv, Subtype.equivalence]]
[let_value_heq,[Eq.mpr, Eq.refl, HEq, HEq.rfl]]
[let_body_eq,[Eq.mpr, Eq.refl, Eq, rfl]]
[Int.mul_nonneg,[Eq.mpr, Eq.refl, Eq.symm, Int.ofNat_mul, Int.ofNat_nonneg, HMul.hMul]]
[List.forM,[Unit.unit, PUnit, Pure.pure, PUnit.unit, Bind.bind, PProd.fst]]
[Set.singleton,[setOf, Eq]]
[Subtype.coind_bijective,[And.intro, Subtype.coind_injective, And.left, Subtype.coind_surjective, And.right]]
[Except.toOption,[Option, Option.some, Option.none]]
[Function.injective2.right,[And.right]]
[Classical.decidableInhabited,[Inhabited.mk, inferInstance]]
[Tactic.Ring.Cache.cs,[]]
[Nat.gcd_zero_left,[rfl]]
[Int.ofNat_add_negSucc_ofNat,[rfl]]
[UInt8.toUInt32,[Nat.toUInt32, UInt8.toNat]]
[Option.decidable_forall_mem.proof_2,[Iff.mp, Option.some_inj]]
[stx_?,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Task.noConfusionType,[]]
[Int.decLe,[Decidable, Int.NonNeg, Decidable.isTrue, Int.NonNeg.mk, Decidable.isFalse, Eq.refl, Int.negSucc, HEq.refl, False, HSub.hSub]]
[HMod.noConfusionType,[]]
[instCommRingFin,[CommRing.mk, instCommRingFin.proof_1]]
[Option.exists,[Iff.intro, Or, Option.none, Exists, Option.some, Or.inl, Or.inr, Exists.intro, Or.elim]]
[apply_ite,[apply_dite]]
[List.mem_union_iff,[of_eq_true, Eq.trans, congr, congrArg, Iff, Mem.mem, List.nil_union, congrFun, Or, propext, List.mem_nil, false_or, iff_self, List.cons_union, List.mem_insert_iff, Eq, List.mem_cons, or_assoc]]
[Int.mul_self_lt_mul_self,[Int.mul_lt_mul', Int.le_of_lt, lt_of_le_of_lt]]
[Nat.sub_add_eq_max,[le_total, Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HSub.hSub, max, max_eq_right, Iff.mpr, Nat.sub_eq_zero_iff_le, OfNat.ofNat, Nat.zero_add, rfl, Eq.symm, max_eq_left, Nat.sub_add_cancel]]
[Array.split,[Array.foldl, Prod, Array, ite, Eq, Bool.true, Prod.mk, Array.push, List.toArray, List.nil, OfNat.ofNat, Array.size]]
[Functor.mapConst,[]]
[DoResultSBC.continue.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Sum.inl.inj,[]]
[Int.lt_iff_add_one_le,[Iff.refl, LT.lt]]
[UInt8.decLt,[Decidable, LT.lt, inferInstanceAs]]
[right_identity,[Eq]]
[Or.intro_left,[Or.inl]]
[Iff.elim_right.proof_1,[Iff.mpr]]
[UInt8.instSemiringUInt8.proof_3,[congrArg, UInt8.mk, Semiring.nsmul_zero', UInt8.val]]
[Int.mul_pos_of_neg_of_neg,[]]
[List.exists_erase_eq,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Exists, And, Not, Mem.mem, Eq, HAppend.hAppend, List.cons, List.erase, List.exists_of_erasep, rfl, Eq.mpr, List.erase_eq_erasep, Exists.intro, And.intro]]
[StateCpsT.instMonadLiftStateCpsT,[MonadLift.mk, StateCpsT.lift]]
[Mem.noConfusionType,[]]
[Int.sub,[HAdd.hAdd, Neg.neg]]
[List.length_reverse,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, List.length, List.reverse_cons, List.length_append, List.reverse, List.cons, List.nil, HAdd.hAdd, List.length_cons, Nat.succ, List.length_nil, eq_self, OfNat.ofNat]]
[Nat.lor,[Nat.bitwise, or]]
[MonadState.set,[]]
[EStateM.modifyGet,[EStateM.Result, EStateM.Result.ok]]
[ByteArray.isEmpty,[BEq.beq, ByteArray.size, OfNat.ofNat]]
[mul_left_inv,[Group.mul_left_inv]]
[prioLow,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Nat.sub_pos_of_lt,[Nat.lt_of_add_lt_add_right, Eq.mpr, Eq.refl, LT.lt, HAdd.hAdd, OfNat.ofNat, HSub.hSub, Nat.zero_add, Nat.sub_add_cancel, Nat.le_of_lt]]
[lt_min,[Or.elim, le_or_gt, Eq.mpr, Eq.refl, LT.lt, min, min_eq_left, min_eq_right_of_lt]]
[Int.le_sub_right_of_add_le,[]]
[UInt16.land,[UInt16.mk, Fin.land, UInt16.val]]
[instDecidableEqSum.proof_3,[rfl]]
[String.Iterator.curr,[Char, String.get]]
[Mathlib.Tactic.Lint.NamedLinter.name,[Lean.Name.updatePrefix, Mathlib.Tactic.Lint.NamedLinter.declName, Lean.Name.anonymous]]
[String.Iterator.noConfusionType,[]]
[UInt8.instCommRingUInt8.proof_1,[UInt8.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, UInt8.val, UInt8.mul_def, CommSemiring.mul_comm]]
[and.swap,[And, And.intro]]
[String.toList,[String.data]]
[implies_true_iff,[Iff.intro, trivial]]
[ite_not,[dite_not]]
[List.zip,[List.zipWith, Prod.mk]]
[instReprAtomUSize,[ReprAtom.mk]]
[Subarray.foldl,[Id.run, Subarray.foldlM]]
[TC.accessible,[TC.accessible.proof_1]]
[Nat.lt_add_of_pos_left,[Eq.mpr, Eq.refl, LT.lt, HAdd.hAdd, Nat.add_comm, Nat.lt_add_of_pos_right]]
[ReaderT.instLawfulMonadReaderT,[ReaderT.instLawfulMonadReaderT.proof_1]]
[Task.map,[Task.pure, Task.get]]
[HOr.noConfusionType,[]]
[Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp.proof_1,[Nat.le_trans]]
[DoResultBC.break.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[BinaryHeap.empty,[BinaryHeap.mk, List.toArray, List.nil]]
[Tactic.Ring.Cache.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Tactic.Ring.Cache.mk, Eq.symm, eq_of_heq, HEq.refl]]
[ReaderT.ext,[funext, id]]
[Nat.toLevel,[Lean.Level.ofNat]]
[instMonadExceptOfExceptT_1,[MonadExceptOf.mk, ExceptT.mk, Pure.pure, Except.error, ExceptT.tryCatch]]
[Prod.ext',[Iff.mpr, Prod.ext_iff, And.intro]]
[Classical.Â«tacticByCases__:_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Function.uncurry_bicompr,[rfl]]
[Equiv.leftInv,[]]
[UInt16.mod,[UInt16.mk, HMod.hMod, UInt16.val]]
[PSigma.lexNdep,[PSigma.Lex]]
[ST.mkRef,[liftM, ST.Prim.mkRef]]
[implies_of_if_pos,[]]
[UInt32.instSemiringUInt32.proof_9,[rfl]]
[Equiv.refl.proof_1,[rfl]]
[Array.insertAt,[ite, GT.gt, Array.size, panicWithPosWithDecl, OfNat.ofNat, Array.insertAtAux]]
[imp_and_distrib,[Iff.intro, And.intro, And.left, And.right]]
[SubNegMonoid.toSub,[]]
[List.erasep_of_forall_not,[rfl, of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.erasep_cons_of_neg, Not, eq_false, Or.inl, eq_true_of_decide, Eq.refl, Bool.true, List.cons, List.forall_mem_of_forall_mem_cons, eq_self]]
[left_commutative,[Eq]]
[Subtype.symm,[Setoid.symm]]
[Int.neg_zero,[rfl]]
[InvImage.accessible.proof_1,[Acc.intro, rfl]]
[instCoeTail,[CoeTail.mk, coeFun]]
[Nat.le_of_mul_le_mul_left,[Iff.mp, not_lt, Iff.mpr, not_le, Nat.mul_lt_mul_of_pos_left]]
[Function.involutive.left_inverse,[]]
[Option.comp_map,[Eq.symm, Option.map_map]]
[Nat.pos_pow_of_pos,[Nat.pow_le_pow_of_le_right, Nat.zero_le]]
[orM,[Bind.bind, Unit.unit, ToBool.toBool, Pure.pure]]
[instMonadLiftT,[MonadLiftT.mk, MonadLift.monadLift, MonadLiftT.monadLift]]
[OfScientific.ofScientific,[]]
[iff_self_and,[Eq.mpr, Eq.refl, Iff, And, propext, Iff.comm, and_iff_left_iff_imp, Iff.rfl]]
[Â«term_<|_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Â«term_|>_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Mathlib.Tactic.Lint.SimpLemmaInfo.lhs,[]]
[FloatArray.getOp,[FloatArray.get!]]
[CommMonoid.noConfusionType,[]]
[ByteSlice.forIn.loop,[WellFounded.fix, dite, LT.lt, Bind.bind, ByteArray.get!, Pure.pure, PSigma.mk]]
[UInt8.le,[LE.le, UInt8.val]]
[ReprAtom.noConfusionType,[]]
[skipLeft'.proof_1,[PSigma.lex, WellFoundedRelation.wf, emptyWf]]
[Option.eq_none_iff_forall_not_mem,[Iff.intro, Eq.mp, Eq.refl, Mem.mem, Option.some, HEq.refl, Option.ext, Eq.mpr, forall_congr, Eq.trans, congr, congrArg, Iff, propext, Option.mem_def, eq_false', iff_false, Eq]]
[and_not_self,[False]]
[ge_trans,[le_trans]]
[instTransEq.proof_1,[Eq.symm]]
[Array.anyMUnsafe.any,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bool.false, Bind.bind, Array.uget, lcProof, Array.anyMUnsafe.any, HAdd.hAdd, OfNat.ofNat]]
[instRingFin.proof_4,[of_eq_true, Eq.trans, forall_congr, eq_self, Neg.neg, HMul.hMul, Fin.ofNat', Nat.succ, Fin.size_positive, propext, forall_const, Fin, Nat]]
[UInt8.instSemiringUInt8.proof_13,[UInt8.eq_of_val_eq, Eq.mpr, congrArg, Eq, Fin.ofNat', HAdd.hAdd, OfNat.ofNat, Fin.size_positive', UInt8.val, Eq.trans, UInt8.mk, UInt8.one_def, UInt8.add_def]]
[Zero.zero,[]]
[Nat.add_div_left,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HAdd.hAdd, Nat.succ, Nat.add_comm, Nat.add_div_right, rfl]]
[Decidable.em,[Decidable.byCases, Or.inl, Or.inr]]
[if_congr_prop,[if_ctx_congr_prop]]
[Option.to_list_some,[rfl]]
[Mathlib.Tactic.Lint.Linter.isFast,[]]
[List.subset_cons_of_subset,[Or.inr]]
[left_comm,[]]
[Nat.le_of_not_le,[Or.resolve_left, Nat.le_or_le]]
[unexpandProdMk,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, Unit.unit]]
[UInt16.noConfusionType,[]]
[FloatSpec.lt,[]]
[String.set,[String, String.mk, List, Char, List.nil, ite, Eq, List.cons, PProd.fst, HAdd.hAdd, String.csize, OfNat.ofNat]]
[LawfulApplicative.seq_pure,[]]
[instOrdUSize,[Ord.mk, compareOfLessAndEq]]
[List.mem_repeat,[Unit.unit, Iff, Mem.mem, List.repeat, And, Ne, OfNat.ofNat, Eq, of_eq_true, Eq.trans, congr, congrArg, propext, List.mem_nil, congrFun, eq_false_of_decide, Eq.refl, Bool.false, false_and, eq_true_of_decide, Bool.true, List.cons, Nat.add_eq, Nat.add_zero, List.mem_cons, Or, PProd.fst, ne_eq, HAdd.hAdd, Not, eq_false, Nat.succ_ne_zero, true_and, or_iff_left_iff_imp, and_imp, implies_congr, imp_self, implies_true]]
[Function.involutive.comp_self,[funext]]
[tacticTransitivity__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[instDecidableEqList,[List.hasDecEq]]
[Fin.mul.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[max_eq_left_of_lt,[max_eq_left, le_of_lt]]
[UInt8.instSemigroupUInt8,[Semigroup.mk, UInt8.instSemigroupUInt8.proof_1]]
[Option.mem_of_mem_join,[Iff.mpr, Option.mem_def, Iff.mp, Option.join_eq_some, Eq.symm]]
[Substring.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[USize.sub_def,[rfl]]
[Int.add_lt_add_right,[Eq.mpr, Eq.refl, LT.lt, HAdd.hAdd, Int.add_comm, Int.add_lt_add_left]]
[Nat.add_one,[rfl]]
[dif_ctx_simp_congr,[dif_ctx_congr]]
[UInt8.instSemiringUInt8.proof_1,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt8.zero_def, UInt8.add_def, UInt8.mk, OfNat.ofNat, add_zero, UInt8.val, UInt8.mk_val_eq, eq_self, propext, forall_const, UInt8]]
[Id.pure_eq,[rfl]]
[instLEUInt32,[LE.mk, LE.le, UInt32.val]]
[min_self,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, ite_congr, eq_true, le_refl, Eq.refl, if_t_t, True, eq_self]]
[ByteSlice.mk.inj,[And.intro]]
[FloatSpec.decLe,[]]
[le_of_not_lt,[LE.le, lt_trichotomy, le_of_lt, le_refl, absurd]]
[Array.getLit,[Array.get, Fin.mk, Array.getLit.proof_1]]
[Â«term-_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[List.isEqv,[List.nil, List.cons, Bool, Bool.true, and, PProd.fst, Bool.false]]
[BEq.beq,[]]
[dif_pos,[Eq, dite, rfl, absurd]]
[Add.add,[]]
[StateCpsT.runK_bind_modify,[rfl]]
[Array.eraseIdx'.proof_1,[rfl]]
[mul_right_comm,[Eq.mpr, Eq.refl, Eq, HMul.hMul, mul_assoc, mul_comm, rfl]]
[true_implies_iff,[Iff.intro, trivial]]
[UInt32.xor,[UInt32.mk, Fin.xor, UInt32.val]]
[Nat.add_sub_add_left,[Eq.mpr, Eq.refl, Eq, HSub.hSub, HAdd.hAdd, Nat.add_comm, Nat.add_sub_add_right, rfl]]
[Semiring.mul_add,[]]
[List.iota,[Unit.unit, Nat.succ, List, Nat, List.nil, List.cons, PProd.fst]]
[UInt64.instSemiringUInt64.proof_12,[Eq.mpr, congr, congrArg, Eq, Eq.trans, congrFun, HMul.hMul, UInt64.add_def, UInt64.mul_def, UInt64.mk, HAdd.hAdd, UInt64.val, UInt64.eq_of_val_eq, Semiring.add_mul]]
[List.append_assoc,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HAppend.hAppend, List.cons_append, List.cons, eq_self]]
[String.Iterator.setCurr,[String.Iterator, String.Iterator.mk, String.set]]
[left_cancelative,[Eq]]
[Â«term_<=_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.div_eq_of_eq_mul_right,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, Nat.mul_div_cancel_left, rfl]]
[PSum.inr.inj,[]]
[List.mapâ‚‚,[List.nil, List.cons, List, PProd.fst]]
[Int.add_one_le_of_lt,[]]
[precMin1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Array.toBinaryHeap,[BinaryHeap.mk, Subtype.val, BinaryHeap.mkHeap]]
[LinearOrder.decidable_eq,[]]
[ExceptCpsT.run_bind_throw,[rfl]]
[not_not,[Decidable.not_not]]
[stdSplit,[StdGen.mk, Prod, StdGen, Prod.mk]]
[ReaderT.run_seqRight,[Eq.mpr, Eq.refl, Eq, ReaderT.run, SeqRight.seqRight, seqRight_eq_bind, rfl]]
[ST.Prim.Ref.modify,[Bind.bind, ST.Prim.Ref.get, ST.Prim.Ref.set]]
[tacticIterate____,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.parser]]
[not_and_not_right,[Decidable.not_and_not_right]]
[Nat.strong_induction_on,[Nat.strong_rec_on]]
[Â«term_>=_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[PSigma.lexAccessible.proof_1,[Acc.intro, PSigma.mk, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, WellFounded.apply]]
[workOnGoal,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.parser]]
[List.mem_cons_self,[Or.inl, rfl]]
[Subarray.foldr,[Id.run, Subarray.foldrM]]
[List.subset.trans,[]]
[Function.surjective.of_comp_iff,[Iff.intro, Function.surjective.of_comp, Function.surjective.comp]]
[List.map_singleton,[rfl]]
[USize.instAddSemigroupUSize.proof_1,[congrArg, USize.mk, AddSemigroup.add_assoc, USize.val]]
[String.foldlAux,[String.foldlAux.loop]]
[Int.instCommRingInt.proof_4,[rfl]]
[List.get?_set_eq,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.get?, List.set_eq_modifyNth, List.get?_modifyNth_eq, Functor.map, eq_self]]
[HEq.elim,[eq_of_heq]]
[StateT.map,[Bind.bind, Prod, Pure.pure, Prod.mk]]
[USize.instRingUSize.proof_3,[congrArg, USize.mk, Ring.gsmul_succ', USize.val]]
[Functor.mapRev,[Functor.map]]
[UInt16.instAddSemigroupUInt16,[AddSemigroup.mk, UInt16.instAddSemigroupUInt16.proof_1]]
[Nonempty.elim.proof_1,[]]
[StateT.run_bind,[of_eq_true, eq_self, Bind.bind]]
[Setoid.r,[]]
[Nat.gcd_gcd_self_right_right,[Eq.mpr, Eq.refl, Eq, Nat.gcd, Nat.gcd_comm, Nat.gcd_gcd_self_right_left, rfl]]
[instToStringULift,[ToString.mk, ToString.toString, ULift.down]]
[Tactic.TryThis.delabToRefinableSyntax,[Bind.bind, readThe, Lean.Core.Context, liftM, Lean.PrettyPrinter.delab, Lean.Core.Context.currNamespace, Lean.Core.Context.openDecls, EmptyCollection.emptyCollection, Tactic.TryThis.replaceMVarsByUnderscores]]
[Substring.get,[Char, String.get, HAdd.hAdd]]
[strictOr,[or]]
[ByteSliceT.size,[HSub.hSub, ByteArray.size, ByteSliceT.arr, ByteSliceT.off]]
[or_congr,[Iff.intro, Or.imp, Iff.mp, Iff.mpr]]
[Nat.xor,[Nat.bitwise, bne]]
[ltOfOrd,[LT.mk, Eq, BEq.beq, Ord.compare, Ordering.lt, Bool.true]]
[System.FilePath.isRelative,[not, System.FilePath.isAbsolute]]
[Nat.succ.inj,[]]
[USize.instCommRingUSize.proof_1,[USize.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, USize.val, USize.mul_def, CommSemiring.mul_comm]]
[instHashableString,[Hashable.mk, String.hash]]
[Option.map_id,[funext, Unit.unit, Eq, Option.map, id, rfl]]
[UInt64.decLe,[Decidable, LE.le, inferInstanceAs]]
[Append.noConfusionType,[]]
[UInt16.val,[]]
[coeB,[Coe.coe]]
[HEq.ndrec,[]]
[List.subset.refl,[]]
[Ne,[Not, Eq]]
[Â«term_<$>_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[UInt32.instSemiringUInt32.proof_11,[Eq.mpr, congr, congrArg, Eq, Eq.trans, HMul.hMul, UInt32.add_def, UInt32.mul_def, UInt32.mk, HAdd.hAdd, UInt32.val, UInt32.eq_of_val_eq, Semiring.mul_add]]
[not_imp_not,[Decidable.not_imp_not]]
[Int.decEq.proof_3,[rfl]]
[Nat.gcd_eq_right_iff_dvd,[Eq.mpr, Eq.refl, Iff, Dvd.dvd, Eq, Nat.gcd, Nat.gcd_comm, Nat.gcd_eq_left_iff_dvd]]
[Nat.eq_one_of_dvd_one,[Nat.le_antisymm, Nat.le_of_dvd, of_decide_eq_true, rfl, Nat.pos_of_dvd_of_pos]]
[USize.instSemiringUSize.proof_8,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HMul.hMul, USize.one_def, USize.mul_def, USize.mk, OfNat.ofNat, mul_one, USize.val, USize.mk_val_eq, eq_self, propext, forall_const, USize]]
[UInt32.size,[OfNat.ofNat]]
[Option.lift_or_get_some_some,[rfl]]
[Function.injective_of_subsingleton,[Subsingleton.elim]]
[Nat.succ_sub_one,[rfl]]
[Mathlib.Tactic.Lint.getDeclsInCurrModule,[Bind.bind, Lean.MonadEnv.getEnv, Pure.pure, Array.map, Prod.fst, List.toArray, Std.PersistentHashMap.toList, Lean.SMap.mapâ‚‚, Lean.Environment.constants]]
[Tactic.LibrarySearch.librarySearch',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpArg, Lean.ParserDescr.const]]
[instDecidableEqQuotient,[Quotient.recOnSubsingletonâ‚‚, Decidable, Eq, Quotient.mk, Decidable.isTrue, Quotient.sound, Decidable.isFalse, instDecidableEqQuotient.proof_2]]
[Squash.lift.proof_1,[Subsingleton.elim]]
[em',[Or.swap, em]]
[Iff.trans,[Iff.intro, Iff.mp, Iff.mpr]]
[ByteArray.forIn,[ByteArray.size, Nat.le_refl, ByteArray.forIn.loop]]
[ByteArray.instForInByteArrayUInt8,[ForIn.mk, ByteArray.forIn]]
[imp_congr_right,[Iff.intro, Iff.mp, Iff.mpr]]
[instDecidablePredComp,[inferInstanceAs, DecidablePred]]
[Function.update_eq_iff,[Iff.trans, Function.funext_iff, Function.forall_update_iff, Eq]]
[Nat.eq_zero_of_gcd_eq_zero_left,[Eq, OfNat.ofNat, Nat.eq_zero_or_pos, absurd, Eq.symm, ne_of_lt, Nat.gcd_pos_of_pos_left]]
[List.map_eq_nil,[Iff.intro, rfl, Eq.symm, Eq.refl, Eq.mpr, Eq, List.map, List.nil]]
[evalIntrov,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, GE.ge, Lean.Syntax.getNumArgs, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.Elab.Tactic.evalTactic, Lean.Elab.throwUnsupportedSyntax, evalIntrov.introsDep, evalIntrov.intro1PStep]]
[or.right_comm,[Eq.mpr, Eq.refl, Iff, Or, propext, or_assoc, or_comm, Iff.rfl]]
[AddMonoid.noConfusionType,[]]
[Array.toListLitAux.proof_2,[Nat.lt_of_lt_of_eq, Nat.lt_of_lt_of_le, Nat.lt_succ_self]]
[Set.Â«termâ‹ƒâ‚€_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Array.forInUnsafe.loop,[ite, LT.lt, Bind.bind, Pure.pure, Array.forInUnsafe.loop, HAdd.hAdd, OfNat.ofNat]]
[UInt64.instSemiringUInt64,[Semiring.mk, UInt64.instSemiringUInt64.proof_1, UInt64.instSemiringUInt64.proof_2, UInt64.mk, Semiring.nsmul, UInt64.val, UInt64.instSemiringUInt64.proof_3, UInt64.instSemiringUInt64.proof_4, UInt64.instSemiringUInt64.proof_5, UInt64.instSemiringUInt64.proof_6, UInt64.instSemiringUInt64.proof_7, UInt64.instSemiringUInt64.proof_8, UInt64.instSemiringUInt64.proof_9, UInt64.instSemiringUInt64.proof_10, UInt64.instSemiringUInt64.proof_11, UInt64.instSemiringUInt64.proof_12, UInt64.instSemiringUInt64.proof_13]]
[UInt32.instSemiringUInt32.proof_10,[rfl]]
[evalIntrov.intro1PStep,[Lean.Elab.Tactic.liftMetaTactic, Bind.bind, Lean.Meta.intro1P, Lean.Meta.MetaM, List, Lean.MVarId, Pure.pure, List.cons, List.nil]]
[CoeTail.coe,[]]
[List.erase_nil,[rfl]]
[Char.isUpper,[and, Decidable.decide, GE.ge, Char.val, OfNat.ofNat, LE.le]]
[Int.neg_ofNat_zero,[rfl]]
[Mathlib.Tactic.Lint.simpNF,[Mathlib.Tactic.Lint.Linter.mk, Bind.bind, Mathlib.Tactic.Lint.isSimpLemma, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Option.none, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[Pow.pow,[]]
[Nat.lcm_one_right,[Nat.lcm_one_left, Nat.lcm_comm, OfNat.ofNat]]
[Nat.gcd_mul_lcm,[]]
[Int.decEq.proof_2,[absurd]]
[Array.get?_len_le,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, dite_congr, eq_false, not_lt_of_ge, Eq.refl, Option.some, Array.get, Fin.mk, Eq.mpr_prop, Option.none, dite_false, eq_self]]
[List.length_take,[Eq, List.length, List.take, min, of_eq_true, Eq.trans, congr, congrArg, List.length_nil, Nat.zero_min, eq_true_of_decide, Eq.refl, Bool.true, Nat.succ, Nat.min_zero, List.length_cons, PProd.fst, Nat.min_succ_succ, eq_self]]
[Nat.lt_or_eq_or_le_succ,[Decidable.byCases, Or.inr]]
[StateT.set,[Pure.pure, Prod.mk, PUnit.unit]]
[Stream.forIn,[Stream.forIn.visit]]
[Preorder.toLE,[]]
[UInt64.instAddSemigroupUInt64.proof_1,[congrArg, UInt64.mk, AddSemigroup.add_assoc, UInt64.val]]
[Nat.add_lt_add_left,[Nat.lt_of_succ_le, Nat.add_le_add_left, Nat.succ_le_of_lt, Nat.add_succ]]
[Substring.bsize,[Nat, Nat.sub]]
[List.last!,[Unit.unit, List.cons, panicWithPosWithDecl, OfNat.ofNat, PProd.fst, PProd.snd]]
[instSubsingletonDecidable,[instSubsingletonDecidable.proof_1]]
[instDecidableIff,[dite, Decidable.isTrue, instDecidableIff.proof_1, Decidable.isFalse, instDecidableIff.proof_2, instDecidableIff.proof_3, instDecidableIff.proof_4]]
[mkStdGen,[StdGen.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.add_mod,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, Nat.add_mod_mod, Nat.mod_add_mod, rfl]]
[AddCommSemigroup.noConfusionType,[]]
[Nat.mul_div_cancel,[Eq.mp, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, HAdd.hAdd, OfNat.ofNat, Nat.zero_add, Nat.zero_div]]
[instShiftRightUInt16,[ShiftRight.mk, UInt16.shiftRight]]
[WellFounded.apply.proof_1,[]]
[instReprId_1,[inferInstanceAs, Repr]]
[And.congr_left_iff,[Eq.mpr, congrArg, Iff, And, Eq.trans, Eq.symm, propext, And.congr_right_iff, congr, and_comm, Iff.rfl]]
[FloatArray.get!,[Float, Array.get!]]
[MonadReader.read,[]]
[instInhabitedEST,[inferInstanceAs, Inhabited, EStateM]]
[Nat.eq_zero_of_add_eq_zero,[And.intro, Nat.eq_zero_of_add_eq_zero_right, Nat.eq_zero_of_add_eq_zero_left]]
[List.equiv,[Iff, Mem.mem]]
[Nat.mul,[Nat, OfNat.ofNat, Nat.add, PProd.fst]]
[tacticAssumption',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[UInt64.instSemiringUInt64.proof_2,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt64.zero_def, UInt64.add_def, UInt64.mk, OfNat.ofNat, zero_add, UInt64.val, UInt64.mk_val_eq, eq_self, propext, forall_const, UInt64]]
[instToStringDecidable,[ToString.mk, String]]
[Fin.instMulFin,[Mul.mk, Fin.mul]]
[Nat.add_sub_cancel',[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, HSub.hSub, Nat.add_comm, Nat.sub_add_cancel, rfl]]
[instSubsingletonStateM.proof_1,[Subsingleton.intro, funext, Eq, Eq.mpr, Eq.refl, Prod.mk, Subsingleton.elim, rfl]]
[Nat.le_of_add_le_add_left,[Nat.le.intro, Eq.mp, Eq.refl, Eq, HAdd.hAdd, propext, Nat.add_left_cancel_iff, Nat.add_assoc]]
[MonoidWithZero.toZero,[]]
[Prod.lex_def,[Iff.intro, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Or, Prod.fst, And, Eq, Prod.snd, of_eq_true, Eq.trans, congrFun, congrArg, eq_true, true_or, congr, eq_self, eq_true_of_decide, Bool.true, or_true, Prod.Lex, Prod.Lex.left, Prod.Lex.right]]
[List.zipWith,[List.nil, List.cons, List, PProd.fst]]
[Â«term_âŠ†_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[UInt64.instAddCommSemigroupUInt64.proof_1,[congrArg, UInt64.mk, AddCommSemigroup.add_comm, UInt64.val]]
[le_min,[dite, LE.le, Eq.mpr, congrArg, if_pos, if_neg]]
[Bool.and_true,[rfl, Eq.symm, Eq.refl]]
[decidable_eq_inr_neg,[Eq, Decidable.isFalse, absurd, Eq.refl, proof_irrel]]
[Int.add_lt_add_of_le_of_lt,[lt_of_le_of_lt, Int.add_le_add_right, Int.add_lt_add_left]]
[Ring.gsmul,[]]
[Subtype.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Nat.lt_of_succ_le,[]]
[Int.sub_le_sub_right,[Int.add_le_add_right, Neg.neg]]
[MonadReaderOf.read,[]]
[Function.injective.ne_iff,[Iff.intro, mt, congr_arg, Function.injective.ne]]
[max,[ite, LT.lt]]
[Â«term~~~_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.sub_le_sub_right_iff,[Iff.intro, Nat.le_of_le_of_sub_le_sub_right, Nat.sub_le_sub_right]]
[BinaryHeap.get,[Array.get, BinaryHeap.arr]]
[Iff.symm,[Iff.intro, Iff.mpr, Iff.mp]]
[Option.elim_none,[rfl]]
[EStateM.Result.error.injEq,[Eq.propIntro, And.intro, Eq.refl, EStateM.Result.error, Eq.symm, eq_of_heq, HEq.refl]]
[Decidable.by_contradiction,[Decidable.byContradiction]]
[instDecidableEqSum.proof_6,[]]
[instToStringFin,[ToString.mk, ToString.toString, Fin.val]]
[Nat.sub_sub_self,[Iff.mpr, Nat.sub_eq_iff_eq_add, Nat.sub_le, Eq.symm, Nat.add_sub_of_le]]
[Function.update_idem,[funext, Decidable.em, Eq, of_eq_true, Eq.trans, congr, congrArg, dite_congr, congrFun, eq_self, Eq.refl, Eq.symm, Eq.mpr_prop, dite_true, True.intro, eq_false, dite_false]]
[instInhabitedSort,[Inhabited.mk, PUnit]]
[instDecidableArrow.proof_2,[absurd]]
[Function.uncurry_def,[rfl]]
[Char.instLTChar,[LT.mk, Char.lt]]
[iff_def,[iff_iff_implies_and_implies]]
[true_implies,[propext, Iff.intro, trivial]]
[WellFounded.fix,[WellFounded.fixF, WellFounded.apply]]
[StateCpsT.instMonadStateOfStateCpsT,[MonadStateOf.mk, PUnit.unit]]
[instAddCommGroup.proof_5,[AddCommSemigroup.add_comm]]
[List.disjoint_nil_left,[Not.elim, List.not_mem_nil]]
[Â«term_<&&>_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.sub,[Nat, Nat.pred, PProd.fst]]
[Nat.lcm_zero_left,[]]
[Nat.sub_eq_zero_of_le,[Exists.elim, Nat.le.dest, Eq.mpr, Eq.refl, Eq, HSub.hSub, OfNat.ofNat, Eq.symm, HAdd.hAdd, Nat.sub_self_add, rfl]]
[Array.shrink,[HSub.hSub, Array.size, Array.shrink.loop]]
[StateRefT'.instMonadStateOfStateRefT',[MonadStateOf.mk, StateRefT'.get, StateRefT'.set, StateRefT'.modifyGet]]
[Quotient.recOnSubsingletonâ‚‚.proof_1,[Quot.recOnSubsingleton]]
[System.FilePath.components,[String.splitOn, System.FilePath.toString, System.FilePath.normalize, Bool.false, Char.toString, System.FilePath.pathSeparator]]
[prodHasDecidableLt,[inferInstanceAs, Decidable, Or, LT.lt, Prod.fst, And, Eq, Prod.snd]]
[UInt8.decLe,[Decidable, LE.le, inferInstanceAs]]
[Nat.allM.loop,[Unit.unit, Bool, Pure.pure, Bool.true, Bind.bind, HSub.hSub, OfNat.ofNat, PProd.fst, Bool.false]]
[Char.utf8Size.proof_2,[of_decide_eq_true, Eq.refl, Bool.true]]
[ReaderT.run_monadMap,[rfl]]
[prioHigh,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[UInt32.neg_def,[rfl]]
[Set.Â«term{_|_}Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Mathlib.ExtendedBinder.extBinder, Lean.ParserDescr.cat]]
[observing,[MonadExcept.tryCatch, Bind.bind, Pure.pure, Except.ok, Except.error]]
[UInt64.lt,[LT.lt, UInt64.val]]
[PartialOrder.toPreorder,[]]
[Nat.gcd_mul_left_left,[Nat.dvd_antisymm, Nat.gcd_dvd_right, HMul.hMul, Nat.dvd_gcd, Nat.dvd_mul_left, Nat.dvd_refl]]
[Nat.div_le_self,[LE.le, HDiv.hDiv, Eq.mpr, congrFun, congrArg, Nat.div_zero, Nat.zero_le, Nat.div_le_of_le_mul]]
[Fin.shiftLeft.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[Nat.coprime_one_right_iff,[of_eq_true, Eq.trans, congr, congrArg, Iff, congrFun, Eq, Nat.gcd_one_right, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true]]
[UInt32.ofNat',[UInt32.mk, Fin.mk]]
[Array.mapIdxM,[Array.size, OfNat.ofNat, rfl, Array.mkEmpty, Array.mapIdxM.map]]
[Int.le_add_of_neg_add_le,[]]
[List.repeat_succ,[rfl]]
[Nat.le_of_lt_succ,[Nat.le_of_succ_le_succ]]
[System.Platform.numBits_eq,[Subtype.property, System.Platform.getNumBits, Unit.unit]]
[Equiv.mk.inj,[And.intro]]
[default.sizeOf,[OfNat.ofNat]]
[Subtype.coind,[Subtype.mk]]
[List.zipLeft',[List.mapâ‚‚Left', Prod.mk]]
[List.headD,[]]
[List.mapM,[Unit.unit, List, Pure.pure, List.nil, Bind.bind, PProd.fst, List.cons]]
[List.nil_bind,[of_eq_true, eq_self, List.nil]]
[iff_false_left,[Iff.intro, mt, Iff.mpr, iff_of_false]]
[Nat.one_ne_zero,[]]
[Mathlib.ExtendedBinder.Â«binderTermâ‰¥_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[StateT.run_seq,[]]
[Mathlib.Tactic.Lint.simpComm,[Mathlib.Tactic.Lint.Linter.mk, Lean.Meta.withReducible, Bind.bind, Mathlib.Tactic.Lint.isSimpLemma, ite, Eq, Bool.true, Pure.pure, PUnit.unit, Option.none, Function.comp, Lean.MessageData.ofFormat, Std.ToFormat.format]]
[BinaryHeap.insert.proof_1,[Eq.mpr, Eq.refl, LT.lt, BinaryHeap.size, Array.size, Array.push, BinaryHeap.arr, Array.size_push, Nat.lt_succ_self]]
[bfix6,[PProd.fst]]
[neg_add_self,[add_left_neg]]
[List.get?_injective,[Eq.refl, List.length, List.nil, HEq.refl, Eq, rfl, Eq.mpr, Nat.succ.injEq, Nat.lt_of_succ_lt_succ, Eq.symm, eq_of_heq, List.cons]]
[lt_iff_le_not_le,[Preorder.lt_iff_le_not_le]]
[UInt32.instCommRingUInt32,[CommRing.mk, UInt32.instCommRingUInt32.proof_1]]
[Subarray.foldlM,[Array.foldlM, Subarray.as, Subarray.start, Subarray.stop]]
[Mathlib.RunTac.tacticRun_tac_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[instSemiringFin.proof_1,[Fin.eq_of_val_eq, Eq.mpr, congrFun, congrArg, Eq, Eq.trans, Fin.val, Fin.add_def, OfNat.ofNat, HMod.hMod, HAdd.hAdd, Fin.zero_def, Nat.add_zero, Nat.mod_eq_of_lt, Fin.isLt]]
[Nat.instModNat,[Mod.mk, Nat.mod]]
[imp_or_distrib,[Decidable.imp_or_distrib]]
[Numeric.ofNat,[]]
[Nat.coprime_comm,[Iff.intro, Nat.coprime.symm]]
[MonadExcept.instOrElse,[OrElse.mk, MonadExcept.orElse]]
[instReprExcept,[Repr.mk, Std.Format, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg]]
[List.ne_of_not_mem_cons,[absurd, Or.inl]]
[List.erase_cons_tail,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.erase_cons, if_neg, List, List.cons, List.erase, eq_self]]
[Thunk.noConfusionType,[]]
[Nat.pow,[Unit.unit, Nat, OfNat.ofNat, Nat.mul, PProd.fst]]
[Function.injective.comp,[]]
[DivInvMonoid.toDiv,[]]
[BinaryHeap.heapifyDown,[WellFounded.fix, PSigma.mk]]
[ByteArray.foldlMUnsafe,[ite, LT.lt, LE.le, ByteArray.size, USize.ofNat, Pure.pure, ByteArray.foldlMUnsafe.fold]]
[instNegFin,[Neg.mk, Fin.mk, HMod.hMod, HSub.hSub, Fin.val, instNegFin.proof_1]]
[Int.natMod,[Int.toNat, HMod.hMod]]
[List.isInfix,[Exists, Eq, HAppend.hAppend]]
[System.FilePath.toString,[]]
[Array.get,[List.get, Array.data, Fin.val, Array.get.proof_1]]
[Array.anyM,[dite, LE.le, Array.size, Array.anyM.proof_1]]
[FloatArray.empty,[FloatArray.mkEmpty, OfNat.ofNat]]
[Function.has_right_inverse.surjective,[Function.surjective, Function.right_inverse.surjective]]
[instAndOpUInt32,[AndOp.mk, UInt32.land]]
[TC.wf.proof_1,[WellFounded.intro, TC.accessible, WellFounded.apply]]
[List.length_replicate,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.length_nil, Nat.zero_eq, eq_true_of_decide, Eq.refl, Bool.true, congrFun, List.length_cons, Nat.succ, eq_self]]
[Stream.next?,[]]
[Int.sub_le_sub_left,[Int.add_le_add_left, Int.neg_le_neg]]
[ByteArray.append,[ByteArray.copySlice, OfNat.ofNat, ByteArray.size, Bool.false]]
[FloatSpec.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[Function.update_injective,[]]
[instMonadLiftSTEST,[MonadLift.mk, EStateM.Result, EStateM.Result.ok]]
[pure_id_seq,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, LawfulApplicative.pure_seq, id, LawfulFunctor.id_map, eq_self]]
[GroupWithZero.toMonoidWithZero,[MonoidWithZero.mk, GroupWithZero.zero_mul, GroupWithZero.mul_zero]]
[instToStringSubarray,[ToString.mk, ToString.toString, Subarray.toArray]]
[Decidable.not_imp_comm,[Iff.intro, Not.decidable_imp_symm]]
[Nat.sub_lt_left_of_lt_add,[]]
[unsafeCast.proof_1,[lcProof]]
[instLENat,[LE.mk, Nat.le]]
[Â«term_âˆ§_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Subrelation.wf.proof_1,[WellFounded.intro, Subrelation.accessible, WellFounded.apply]]
[Applicative.noConfusionType,[]]
[instMonadReader,[MonadReader.mk, readThe]]
[List.set_nil,[rfl]]
[instAddCommMonoid,[AddCommMonoid.mk, AddCommGroup.add_comm]]
[Sigma.snd,[]]
[Semiring.add_zero,[]]
[ulift.down,[]]
[instSemiringFin.proof_8,[Eq.mpr, congr, congrArg, Eq, Fin.nsmuls_eq, Nat.succ, HAdd.hAdd, Eq.trans, Fin.mk, HMod.hMod, HMul.hMul, Fin.val, Nat.mod_lt, Fin.size_positive', Fin.add_def, Fin.mk.injEq, Fin.size_positive, Nat.add_mod_mod, Nat.succ_mul, Nat.add_comm]]
[List.perm_middle,[List.Perm, HAppend.hAppend, List.cons, List.Perm.refl, List.nil, List.Perm.trans, List.Perm.cons, List.Perm.swap]]
[exists_apply_eq_apply,[Exists.intro, rfl]]
[Int.fdiv,[Int.ofNat, Int.negSucc, Nat.succ, Int, OfNat.ofNat, HDiv.hDiv]]
[EStateM.bind,[EStateM.Result, EStateM.Result.error]]
[UInt16.instCommRingUInt16.proof_1,[UInt16.eq_of_val_eq, Eq.mpr, congr, congrArg, Eq, UInt16.val, UInt16.mul_def, CommSemiring.mul_comm]]
[mul_inv_self,[mul_right_inv]]
[termIfThenElse,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.const]]
[StateCpsT.instLawfulMonadStateCpsT,[StateCpsT.instLawfulMonadStateCpsT.proof_1]]
[Array.instToStringArray,[ToString.mk, HAppend.hAppend, ToString.toString, Array.toList]]
[false_ne_true,[trivial, Eq.symm]]
[eq_false',[propext, Iff.intro, absurd, False.elim]]
[Nat.coprime.coprime_mul_right_right,[Nat.coprime.coprime_dvd_right, Nat.dvd_mul_right]]
[ReaderT.run_pure,[rfl]]
[Array.mapSepElemsM,[OfNat.ofNat, List.toArray, List.nil]]
[Nat.mul_div_left,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, Nat.mul_comm, Nat.mul_div_right, rfl]]
[Mathlib.Tactic.Lint.lintCore,[Bind.bind, Lean.MonadEnv.getEnv, Lean.MonadOptions.getOptions, Array.mapM, Array.filterM, Mathlib.Tactic.Lint.shouldBeLinted, Mathlib.Tactic.Lint.NamedLinter.name, OfNat.ofNat, Array.size, liftM, BaseIO.asTask, EIO.toBaseIO, Lean.Core.CoreM.run', Lean.Meta.MetaM.run', Mathlib.Tactic.Lint.Linter.test, Mathlib.Tactic.Lint.NamedLinter.toLinter, Lean.Meta.Context.mk, Lean.Meta.State.mk, Lean.Core.Context.mk, Lean.Core.State.mk, BaseIO, Option, Lean.MessageData, Pure.pure, Option.some, HAppend.hAppend, Lean.ToMessageData.toMessageData, Lean.Exception.toMessageData, Task.Priority.default, Prod.mk, Lean.Core.CoreM, Prod, Mathlib.Tactic.Lint.NamedLinter, Std.HashMap, Lean.Name, ForIn.forIn, ForInStep, Option.none, Task.get, PUnit.unit, ForInStep.yield]]
[instShiftRightUSize,[ShiftRight.mk, USize.shiftRight]]
[Subrelation,[]]
[Subtype.mk.inj,[]]
[WellFounded.fix'.impl,[WellFounded.fix'.impl]]
[Nat.lt_ge_by_cases,[dite, LT.lt, Nat.lt_ge_by_cases.proof_1]]
[Fin.noConfusionType,[]]
[List.map_map,[of_eq_true, eq_self, List.nil, Eq.trans, congr, congrArg, Eq, List.cons, congrFun, Function.comp_apply]]
[instToStringUInt8,[ToString.mk, ToString.toString, UInt8.toNat]]
[le_of_not_gt,[le_of_not_lt]]
[cast,[]]
[Array.extLit,[Array.ext, Eq.trans, Eq.symm]]
[List.sublists,[List.cons, List.nil, List.sublistsAux]]
[String.modify,[String.set, String.get]]
[CoeHTCT.coe,[]]
[String.split,[String.splitAux, OfNat.ofNat, List.nil]]
[UInt32.instSemiringUInt32.proof_6,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, HMul.hMul, UInt32.zero_def, UInt32.mul_def, UInt32.mk, OfNat.ofNat, MonoidWithZero.mul_zero, UInt32.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt32]]
[instInhabitedTrue,[Inhabited.mk, True.intro]]
[instAddUInt64,[Add.mk, UInt64.add]]
[Array.findSomeRevM?.find,[Option, Pure.pure, Option.none]]
[instDivUInt32,[Div.mk, UInt32.div]]
[USize.instSemiringUSize,[Semiring.mk, USize.instSemiringUSize.proof_1, USize.instSemiringUSize.proof_2, USize.mk, Semiring.nsmul, USize.val, USize.instSemiringUSize.proof_3, USize.instSemiringUSize.proof_4, USize.instSemiringUSize.proof_5, USize.instSemiringUSize.proof_6, USize.instSemiringUSize.proof_7, USize.instSemiringUSize.proof_8, USize.instSemiringUSize.proof_9, USize.instSemiringUSize.proof_10, USize.instSemiringUSize.proof_11, USize.instSemiringUSize.proof_12, USize.instSemiringUSize.proof_13]]
[UInt8.instSemiringUInt8.proof_11,[Eq.mpr, congr, congrArg, Eq, Eq.trans, HMul.hMul, UInt8.add_def, UInt8.mul_def, UInt8.mk, HAdd.hAdd, UInt8.val, UInt8.eq_of_val_eq, Semiring.mul_add]]
[instMonadReaderOf,[MonadReaderOf.mk, liftM, MonadReader.read]]
[Function.const_def,[rfl]]
[Tactic.Ring.horner_mul_horner_zero,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Tactic.Ring.horner, OfNat.ofNat, Eq.symm, of_eq_true, Eq.trans, congr, congrArg, HAdd.hAdd, HPow.hPow, add_zero, add_mul, congrFun, mul_assoc, eq_self]]
[UInt8.val_eq_of_eq,[Eq, UInt8.val, congrArg]]
[String.mangle,[String, ite, Eq, or, Char.isAlpha, Char.isDigit, Bool.true, PProd.fst, String.Iterator.next, String.push, Char.ofNat, HAppend.hAppend, LT.lt, Char.toNat, OfNat.ofNat, String.length, String.mkIterator]]
[right_inverse,[Eq]]
[Int.natAbs_pos_of_ne_zero,[Or.resolve_left, Nat.eq_zero_or_pos, Int.natAbs, mt, Int.eq_zero_ofNatAbs_eq_zero]]
[List.lookup,[Option, Option.none, Unit.unit, BEq.beq, Option.some, PProd.fst]]
[instCommMonoid_1.proof_1,[Semiring.mul_one]]
[Nat.div_eq_of_eq_mul_left,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, Nat.mul_div_cancel, rfl]]
[Quotient.inductionOnâ‚‚,[Quotient.ind]]
[Â«termâ€¹_â€ºÂ»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Char.toUpper,[ite, And, GE.ge, OfNat.ofNat, LE.le, Char.ofNat, HSub.hSub]]
[Subarray.popFront,[dite, LT.lt, Subarray.start, Subarray.stop, Subarray.mk, Subarray.as, HAdd.hAdd, OfNat.ofNat, Subarray.popFront.proof_1, Subarray.hâ‚‚]]
[Nat.gcd_one_right,[Eq.trans, Nat.gcd_comm, OfNat.ofNat, Nat.gcd_one_left]]
[Substring.prevn,[String.Pos, PProd.fst, Substring.prev]]
[List.modifyLast,[Unit.unit, List.cons, List, List.nil, PProd.fst]]
[CommSemigroup.toSemigroup,[]]
[Nat.add,[Nat, Nat.succ, PProd.fst]]
[forall_prop_decidable.proof_1,[Iff.intro]]
[Char.ofNatAux,[Char.mk, UInt32.mk, Fin.mk, LT.lt, UInt32.size, Nat.lt_trans, of_decide_eq_true, Eq.refl, Bool.true]]
[Int.add_assoc_aux1,[Eq, HAdd.hAdd, Int.ofNat, of_eq_true, Eq.trans, congr, congrArg, congrFun, Int.ofNat_add_ofNat, Nat.add_assoc, eq_self, Int.negSucc, Int.ofNat_add_negSucc_ofNat, Int.subNatNat_add, Nat.succ, Int.subNatNat]]
[Nat.add_mod_mod,[Eq.mpr, Eq.refl, Eq, HMod.hMod, HAdd.hAdd, Nat.add_comm, Nat.mod_add_mod, rfl]]
[tryFinally,[Functor.map, Prod.fst]]
[Int.sign_eq_neg_one_iff_neg,[Iff.intro, Int.neg_of_sign_eq_neg_one, Int.sign_eq_neg_one_of_neg]]
[Tactic.Ring.Cache.mk.inj,[And.intro]]
[instReprAtomUInt32,[ReprAtom.mk]]
[Nat.not_le_of_gt,[False, Nat.lt_or_ge, absurd, Nat.lt_trans, Nat.lt_irrefl]]
[instRingFin.proof_5,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Neg.neg, OfNat.ofNat, add_comm, Eq.symm, instRingFin.proof_1, Fin.eq_of_val_eq, of_eq_true, Eq.trans, congr, congrArg, Fin.val, Fin.sub_def, congrFun, HMod.hMod, Nat.add_sub_cancel', Nat.le_of_lt, Fin.isLt, Nat.mod_self, Fin.zero_def, eq_true_of_decide, Bool.true]]
[EStateM.adaptExcept,[EStateM.Result, EStateM.Result.error, EStateM.Result.ok]]
[runEST,[Except, Unit, Unit.unit, Except.ok, Except.error]]
[LawfulApplicative.toLawfulFunctor,[]]
[Mathlib.Tactic.Ext.tacticSplit_ands,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Fin.coeToNat,[Coe.mk, Fin.val]]
[Â«term_âˆ¨_Â»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[List.isEmpty,[Unit.unit, Bool, Bool.true, Bool.false]]
[Array.appendCore,[Array.size, OfNat.ofNat, Array.appendCore.loop]]
[Function.funext_iff,[Iff.intro, rfl, funext]]
[IsAddLeftCancel.add_left_cancel,[]]
[Preorder.noConfusionType,[]]
[Fin.instShiftRightFin,[ShiftRight.mk, Fin.shiftRight]]
[false_iff_true,[iff_false_intro, Iff.mpr, trivial]]
[UInt32.toUInt64,[Nat.toUInt64, UInt32.toNat]]
[BinaryHeap.size,[Array.size, BinaryHeap.arr]]
[List.append_eq_append,[rfl]]
[Int.add,[Int, Int.ofNat, HAdd.hAdd, Int.subNatNat, Nat.succ, Int.negSucc]]
[instHModUInt8NatUInt8,[HMod.mk, UInt8.modn]]
[instOfNatUInt64,[OfNat.mk, UInt64.ofNat]]
[Bool.ff_ne_tt,[]]
[if_t_t,[Eq, ite, rfl]]
[Acc.noConfusionType,[]]
[Â«termâˆƒ_,_Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
[min_eq_right_of_lt,[min_eq_right, le_of_lt]]
[term!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Int.neg_lt_of_neg_lt,[]]
[Prod.swap_inj,[Function.injective.eq_iff, Prod.swap_injective]]
[PProd.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, PProd.mk, Eq.symm, eq_of_heq, HEq.refl]]
[Tactic.NormCast.NormCastExtension.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf]]
[HShiftLeft.hShiftLeft,[]]
[ExceptT.bindCont,[Except, Pure.pure, Except.error]]
[List.contains,[List.elem]]
[List.removeNth_eq_nth_tail,[Eq, List.removeNth, List.modifyNthTail, List.tail, rfl, Eq.symm, Eq.refl, congr_arg, List.cons, PProd.fst]]
[List.eraseRepsAux,[List, List.reverse, List.cons, Unit.unit, BEq.beq, PProd.fst]]
[List.exists_of_mem_join,[Iff.mp, List.mem_join]]
[Nat.coprime,[Eq, Nat.gcd, OfNat.ofNat]]
[FloatArray.forIn.loop.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self]]
[Nat.pred_inj,[Eq, Eq.mpr, Eq.refl, HAdd.hAdd, OfNat.ofNat, rfl, absurd, Nat.lt_irrefl]]
[monadLift_self,[rfl]]
[Int.add_nonpos,[Int.add_le_add, Int.zero_add, OfNat.ofNat]]
[Subtype.restrict_apply,[rfl]]
[Function.injective.has_left_inverse,[Exists.intro, Function.inv_fun, Function.left_inverse_inv_fun]]
[Nat.shiftLeft,[Nat, PProd.fst, HMul.hMul, OfNat.ofNat]]
[coeBase,[CoeTC.mk, coeB]]
[instHModUInt32NatUInt32,[HMod.mk, UInt32.modn]]
[List.insert_of_mem,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, if_pos, List, List.cons, eq_self]]
[Char.utf16Size,[ite, LE.le, Char.val, OfNat.ofNat]]
[Array.foldlM.loop,[dite, LT.lt, Unit.unit, Pure.pure, Bind.bind, Array.get, Fin.mk, Array.foldlM.loop.proof_1, PProd.fst, HAdd.hAdd, OfNat.ofNat]]
[and_symm_left,[Iff.intro, And, Eq, And.intro, Eq.symm]]
[Int.neg_le_sub_left_of_le_add,[]]
[ByteArray.toSlice,[ByteSlice.mk, OfNat.ofNat, ByteArray.size]]
[Int.subNatNat,[Unit.unit, Int, HSub.hSub, Int.ofNat, Int.negSucc]]
[Mathlib.Tactic.Ext.Â«termExt_iff_type%__Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Option.instOrElseOption,[OrElse.mk, Option.orElse]]
[Ring.toSemiring,[]]
[Int.zero_ne_one,[sorryAx, False, Bool.true]]
[Alternative.failure,[]]
[Bool.noConfusionType,[]]
[Nat.add_self_ne_one,[Eq.refl, OfNat.ofNat, HEq.refl, False]]
[Quot.liftIndepPr1,[Quot.ind, rfl]]
[Option.map_some,[rfl]]
[Float.lt,[FloatSpec.lt, floatSpec]]
[UInt64.ofNatCore,[UInt64.mk, Fin.mk]]
[is_dec_refl,[Eq, Bool.true]]
[String.codepointPosToUtf16Pos,[String.codepointPosToUtf16PosFrom, OfNat.ofNat]]
[Array.getEvenElems,[Prod.snd, Array.foldl, Prod, Bool, Array, ite, Eq, Bool.true, Prod.mk, Bool.false, Array.push, Array.empty, OfNat.ofNat, Array.size]]
[Decidable.not_not_iff,[Iff.intro, Decidable.of_not_not, not_not_intro]]
[FloatSpec.decLt,[]]
[Decidable.ne_or_eq,[dec_em', Eq]]
[Mathlib.Tactic.Lint.instReprLintVerbosity,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone]]
[boolToProp,[Coe.mk, Eq, Bool.true]]
[List.replicate_eq_replicateTR,[funext, Eq.symm, List.replicateTR_loop_replicate_eq, OfNat.ofNat]]
[Tactic.LibrarySearch.Â«termLibrary_search%Â»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol]]
[Function.update_apply,[]]
[Tactic.Ring.const_add_horner,[of_eq_true, Eq.trans, congr, congrArg, Eq, add_comm, HAdd.hAdd, HMul.hMul, HPow.hPow, add_assoc, Eq.symm, eq_self]]
[List.remove_eq_of_not_mem,[Eq, List.remove, of_eq_true, eq_self, List.nil]]
[max_eq_left,[Eq.symm, eq_max, le_refl]]
[Decidable.not_forall,[Iff.intro, not.decidable_imp_symm, Exists.intro, not_forall_of_exists_not]]
[String.Range.start,[]]
[Subtype.instInhabitedSubtype,[Inhabited.mk, Subtype.mk]]
[USize.instSemiringUSize.proof_9,[rfl]]
[Fin.modn.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt]]
[decidableBEx.proof_4,[absurd, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, False, Exists.intro, And.intro]]
[Nat.toFloat,[Float.ofNat]]
[Task.bind,[Task.pure, Task.get]]
[iff_of_true,[Iff.intro]]
[Ne.intro,[]]
[Nat.mul_div_mul,[Eq.mpr, Eq.refl, Eq, HDiv.hDiv, HMul.hMul, Eq.symm, Nat.div_div_eq_div_mul, Nat.mul_div_cancel_left, rfl]]
[Float.val,[]]
[PLift.up_down,[Eq, PLift.up, PLift.down, rfl]]
[Function.injective_iff_has_left_inverse,[Iff.intro, Function.injective.has_left_inverse, Function.has_left_inverse.injective]]
[List.Chain',[Unit.unit, True, List.Chain]]
[Array.reduceOption,[Array.filterMap, id, OfNat.ofNat, Array.size]]
[UInt8.modn,[UInt8.mk, HMod.hMod, UInt8.val]]
[Array.qsort,[Array.qsort.sort]]
[CoeT.noConfusionType,[]]
[Nat.mul_zero,[rfl]]
[Nat.le_eq,[rfl]]
[Nat.min_eq_left,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, ite_congr, eq_true, Eq.refl, ite_true, eq_self]]
[StateCpsT.run_eq,[rfl]]
[seq_eq_bind,[Eq.mpr, Eq.refl, Eq, Seq.seq, Bind.bind, Functor.map, LawfulMonad.bind_map, rfl]]
[Int.ofNat_lt,[Eq.mpr, Eq.refl, Iff, LT.lt, Int.ofNat, propext, Int.lt_iff_add_one_le, LE.le, HAdd.hAdd, OfNat.ofNat, Eq.symm, Int.ofNat_succ, Nat.succ, Int.ofNat_le, Iff.rfl]]
[Array.size_swap,[]]
[Array.insertionSort.swapLoop.proof_2,[Eq.mpr, Eq.refl, LT.lt, Array.size, Array.swap, Fin.mk, Nat.lt_trans, Nat.lt_succ_self, Eq.symm, Array.size_swap]]
[modify,[MonadState.modifyGet, Prod.mk, PUnit.unit]]
[Option.mem_iff,[Iff.rfl]]
[FloatSpec.noConfusionType,[]]
[Semigroup.mul_assoc,[]]
[Array.findRevM?,[Array.findSomeRevM?, Bind.bind, Pure.pure, ite, Eq, Bool.true, Option.some, Option.none]]
[Function.right_inverse.id,[funext]]
[UInt16.instSemiringUInt16.proof_1,[of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, HAdd.hAdd, UInt16.zero_def, UInt16.add_def, UInt16.mk, OfNat.ofNat, add_zero, UInt16.val, UInt16.mk_val_eq, eq_self, propext, forall_const, UInt16]]
[exists_prop_decidable,[dite, decidable_of_decidable_of_iff, exists_prop_decidable.proof_1, Decidable.isFalse, exists_prop_decidable.proof_2]]
[LT.noConfusionType,[]]
[hidden,[]]
[fix4,[fixCore4, arbitrary]]
[as_true,[ite, True, False]]
[BinaryHeap.decreaseKey.proof_1,[Eq.mpr, Eq.refl, LT.lt, Fin.val, Array.size, Array.set, BinaryHeap.arr, Array.size_set, Fin.isLt]]
[Quotient.inductionOnâ‚ƒ,[Quotient.ind]]
[Subtype.ext,[Eq, of_eq_true, Eq.trans, Subtype.mk.injEq, congrFun, congrArg, eq_self]]
[SubNegMonoid.gsmul_succ',[]]
[Substring.toString,[String, String.extract]]
[String.Range.noConfusionType,[]]
[MonadExceptOf.noConfusionType,[]]
[List.maximum?,[Unit.unit, Option, Option.none, Option.some, List.foldl, max]]
[ExceptCpsT.runCatch,[Pure.pure]]
[Function.comp_const_right,[rfl]]
[UInt8.isAlphanum,[or, UInt8.isAlpha, UInt8.isDigit]]
[Preorder.le_refl,[]]
[imp_congr_ctx,[Iff.trans, imp_congr_left, imp_congr_right]]
[Array.toArrayLit,[List.toArray, Array.toListLitAux, Array.toArrayLit.proof_1, List.nil]]
[List.hasDecEq.proof_2,[]]
[Subtype.heq_iff_coe_eq,[Iff.trans, heq_iff_eq, Subtype.ext_iff, funext, propext]]
[Repr.noConfusionType,[]]
[Nat.instNumericNat,[Numeric.mk, id]]
[instMonadEIO,[inferInstanceAs, Monad, EStateM, IO.RealWorld]]
[instDecidableEqUInt16,[UInt16.decEq]]
[Prod.map_def,[funext, of_eq_true, Eq.trans, forall_congr, congrFun, congrArg, Eq, prod_map, Prod.mk, Prod.fst, Prod.snd, eq_self, implies_true, Prod]]
[instDecidableLt,[UInt32.decLt]]
[instOrdUInt64,[Ord.mk, compareOfLessAndEq]]
[implies_congr_ctx,[propext, Iff.intro]]
[instDecidableIff.proof_1,[Iff.intro]]
[UInt64.instNumericUInt64,[Numeric.mk, UInt64.mk, Numeric.ofNat]]
[Int.repr,[String, Nat.repr, HAppend.hAppend, Nat.succ]]
[Nat.gcd.proof_1,[WellFoundedRelation.wf, measure, id]]
[Classical.typeDecidable,[PSum, False, Classical.propDecidable, Nonempty, PSum.inl, arbitrary, PSum.inr, Classical.typeDecidable.proof_1]]
[Function.update_same,[dif_pos, rfl]]
[UInt16.instRingUInt16.proof_4,[congrArg, UInt16.mk, SubNegMonoid.gsmul_neg', UInt16.val]]
[AddCommSemigroup.add_comm,[]]
[Function.is_partial_inv_left,[Iff.mpr, rfl]]
[List.last.proof_1,[rfl]]
[ST,[EST, Empty]]
[Nat.upRel,[WellFoundedRelation.mk, Nat.Up, Nat.Up.WF]]
[FloatSpec.le,[]]
[instOrdFin,[Ord.mk, Ord.compare, Fin.val]]
[List.splitOnPAux,[List, List.cons, List.nil, ite, PProd.fst, id]]
[ExceptCpsT.lift,[Bind.bind]]
[Int.coe_nat_sub,[Int.ofNat_sub]]
[Int.lt_succ,[Int.le_refl, HAdd.hAdd, OfNat.ofNat]]
[PartialOrder.noConfusionType,[]]
[instSubUInt16,[Sub.mk, UInt16.sub]]
[String.repeat,[String.mk, List.repeat]]
[String.mkIterator,[String.Iterator.mk, OfNat.ofNat]]
[List.length_singleton,[rfl]]
[Task.get,[]]
[Preorder.lt_iff_le_not_le,[]]
[gt_irrefl,[lt_irrefl]]
[List.erasep_map,[Unit.unit, Eq, List.erasep, List.map, Function.comp, rfl, Decidable.em, of_eq_true, Eq.trans, congr, congrArg, List.erasep_cons_of_pos, eq_true, Function.comp_apply, eq_self, Eq.symm, List.erasep_cons_of_neg, Not, eq_false, eq_true_of_decide, Eq.refl, Bool.true, List.cons, PProd.fst]]
[decide_eq_false_iff_not,[Iff.intro, of_decide_eq_false, decide_eq_false]]
[PLift.down_up,[rfl]]
[Fin.instHModFinNatFin,[HMod.mk, Fin.modn]]
[Nat.le_of_dvd,[LE.le, Eq.mpr, Eq.refl, HMul.hMul, False.elim, Eq.mp, Eq.trans, congrArg, LT.lt, OfNat.ofNat, Nat.mul_zero, eq_false_of_decide, Bool.false, Nat.succ, Nat.mul_one]]
[instAddCommGroup.proof_2,[Semiring.zero_add]]
[id.def,[rfl]]
[ReaderT.instMonadFunctorReaderT,[MonadFunctor.mk]]
[unsafeEIO,[unsafeBaseIO, EIO.toBaseIO]]
[id_map',[LawfulFunctor.id_map]]
[HAdd.noConfusionType,[]]
[Equiv.perm,[Equiv]]
[WellFounded.fixFEq,[WellFounded.fixFEq.proof_1]]
[UInt8.val_eq_of_lt,[Fin.val_eq_of_lt]]
[WellFounded.fix_eq,[WellFounded.fixFEq, WellFounded.apply]]
[ExceptCpsT.instLawfulMonadExceptCpsT.proof_1,[LawfulMonad.mk, rfl]]
[List.map_append,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.map, List.nil_append, eq_self, List.cons, List.append_eq_append, List.cons_append]]
[StateCpsT.runK_set,[rfl]]
[not_not_intro,[]]
[List.zipWithâ‚„,[List.nil, List.cons, List, PProd.fst]]
[Char.instInhabitedChar,[Inhabited.mk, Char.ofNat]]
[UInt8.instSemiringUInt8.proof_6,[of_eq_true, Eq.trans, forall_congr, congr, congrArg, Eq, HMul.hMul, UInt8.zero_def, UInt8.mul_def, UInt8.mk, OfNat.ofNat, MonoidWithZero.mul_zero, UInt8.val, eq_true_of_decide, Eq.refl, Bool.true, propext, forall_const, UInt8]]
[Bool.or_false,[rfl, Eq.symm, Eq.refl]]
[AddGroup.noConfusionType,[]]
[Function.comp_const,[rfl]]
[Char.val_eq_of_eq,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Eq, Char.val, rfl]]
[System.instToStringFilePath,[ToString.mk, System.FilePath.toString]]
[Array.toSubarray.proof_1,[Nat.le_refl, Array.size]]
[List.after,[Unit.unit, List, List.nil, ite, PProd.fst]]
[List.length_pos_of_mem,[LT.lt, OfNat.ofNat, List.length, List.nil, Eq.refl, Eq.mpr, List.cons, List.length_cons, Nat.zero_lt_succ]]
