[Fin.instModFin,[Mod.mk, Fin.mod],[Mod, Fin]]
[Lean.Parser.Tactic.generalize,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.generalizeArg, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Name.toString.maybePseudoSyntax,[Lean.Name.anonymous, Lean.Name.num, Bool, Lean.Name.getRoot, or, String.isPrefixOf, Bool.false],[Bool]]
[Std.Range.instForInRangeNat,[ForIn.mk, Std.Range.forIn],[ForIn, Std.Range, Nat]]
[Char.isUpper,[and, Decidable.decide, GE.ge, Char.val, OfNat.ofNat, LE.le],[Bool]]
[«term‹_›»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[List.intersperse,[Unit.unit, List.cons, List, List.nil, PProd.fst],[List]]
[UInt32.val,[],[Fin, UInt32.size]]
[OfNat.noConfusionType,[],[]]
[instMonadControlExceptT,[MonadControl.mk, Except, liftM, ExceptT.run],[MonadControl, ExceptT]]
[String.dropRight,[Substring.toString, Substring.dropRight, String.toSubstring],[String]]
[Array.foldlM.loop.proof_1,[Nat.lt_of_lt_of_le],[LT.lt, Array.size]]
[EIO.toIO',[liftM, EIO.toBaseIO],[IO, Except]]
[Lean.Syntax.atom.inj,[And.intro],[And, Eq]]
[Lean.Syntax.splitNameLit,[List.reverse, List.nil],[List, Substring]]
[System.FilePath.join,[ite, Eq, System.FilePath.isAbsolute, Bool.true, System.FilePath.mk, HAppend.hAppend, System.FilePath.toString, Char.toString, System.FilePath.pathSeparator],[System.FilePath]]
[Bool.toUInt64,[ite, Eq, Bool.true, OfNat.ofNat],[UInt64]]
[instLTOption,[LT.mk, Option.lt, LT.lt],[LT, Option]]
[Array.«term__[:_]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Macro.instInhabitedMethodsRef,[Inhabited.mk, Lean.Macro.mkMethods, arbitrary],[Inhabited, PointedType.type]]
[Lean.SourceInfo.fromRef,[Option.none, Option.some, Lean.SourceInfo, Lean.Syntax.getPos?, Bool.false, Lean.Syntax.getTailPos?, Lean.SourceInfo.synthetic, Lean.SourceInfo.none],[Lean.SourceInfo]]
[Lean.Module.noConfusionType,[],[]]
[EStateM.dummySave,[PUnit.unit],[PUnit]]
[Array.instHAppendArrayListArray,[HAppend.mk, Array.appendList],[HAppend, Array, List]]
[ByteArray.empty,[ByteArray.mkEmpty, OfNat.ofNat],[ByteArray]]
[Nat.lt.step,[Nat.lt.step.proof_1],[LT.lt, Nat.succ]]
[String.isPrefixOf,[String.substrEq, OfNat.ofNat, String.bsize],[Bool]]
[Array.findIdx?.loop,[dite, LT.lt, Array.size, Option, Nat, False.elim, Array.findIdx?.loop.proof_1, ite, Eq, Array.get, Fin.mk, Bool.true, Option.some, Option.none],[Option, Nat]]
[List.dropLast,[Unit.unit, List.cons, List, List.nil, PProd.fst],[List]]
[Lean.Meta.Rewrite.Config.mk.inj,[And.intro],[And, Eq]]
[Option.noConfusionType,[],[]]
[Nat.add_comm,[Eq, HAdd.hAdd, Eq.symm, Nat.zero_add],[Eq, HAdd.hAdd]]
[instDecidableEqProd,[Decidable, Eq, Prod.mk, decEq, Decidable.isTrue, instDecidableEqProd.proof_1, Decidable.isFalse, instDecidableEqProd.proof_2, instDecidableEqProd.proof_3],[DecidableEq, Prod]]
[Lean.Parser.Tactic.Conv.rewrite,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq],[Lean.ParserDescr]]
[Lean.SyntaxNodeKind,[Lean.Name],[]]
[instHShiftLeft,[HShiftLeft.mk, ShiftLeft.shiftLeft],[HShiftLeft]]
[UInt64.modn,[UInt64.mk, HMod.hMod, UInt64.val],[UInt64]]
[ST.mkRef,[liftM, ST.Prim.mkRef],[ST.Ref]]
[Applicative.toSeqRight,[],[SeqRight]]
[MonadFinally.noConfusionType,[],[]]
[Char.utf8Size.proof_5,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[Function.Equiv.isEquivalence,[Equivalence.mk, Function.Equiv.refl, Function.Equiv.symm, Function.Equiv.trans],[Equivalence, Function.Equiv]]
[Lean.Parser.Tactic.Conv.delta,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[instSizeOf,[SizeOf.mk, default.sizeOf],[SizeOf]]
[PointedType.val,[],[PointedType.type]]
[instHAnd,[HAnd.mk, AndOp.and],[HAnd]]
[IO.FS.SystemTime.mk.inj,[And.intro],[And, Eq]]
[Option.filter,[Unit.unit, Option, ite, Eq, Bool.true, Option.some, Option.none],[Option]]
[List.toFloatArray,[FloatArray.empty, List.toFloatArray.loop],[FloatArray]]
[fix4,[fixCore4, arbitrary],[]]
[instDecidableEqProd.proof_1,[rfl],[Eq, Prod.mk]]
[Lean.MonadQuotation.noConfusionType,[],[]]
[String.toInt?,[OptionM.run, ite, Eq, String.get, OfNat.ofNat, Char.ofNat, Bind.bind, Substring.toNat?, Substring.drop, String.toSubstring, Pure.pure, Neg.neg, Int.ofNat, Functor.map, String.toNat?],[Option, Int]]
[Nat.eq_zero_of_le_zero,[Nat.le_antisymm, Nat.zero_le],[Eq, OfNat.ofNat]]
[Nat.foldRevM,[Nat.foldRevM.loop],[]]
[Array.eraseIdx',[Array.eraseIdxSzAux, HAdd.hAdd, Fin.val, OfNat.ofNat, Array.eraseIdx'.proof_1],[Subtype, Eq, Array.size, HSub.hSub, OfNat.ofNat]]
[Lean.Syntax.getOptional?,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Option, Lean.Syntax, ite, Eq, and, BEq.beq, Lean.nullKind, Array.size, OfNat.ofNat, Bool.true, Option.some, Array.get!, Option.none],[Option, Lean.Syntax]]
[UInt64.decEq,[Decidable, Eq, dite, Decidable.isTrue, UInt64.decEq.proof_1, Decidable.isFalse, UInt64.decEq.proof_2],[Decidable, Eq]]
[ReaderT.instMonadFunctorReaderT,[MonadFunctor.mk],[MonadFunctor, ReaderT]]
[mt,[],[Not]]
[instDecidableEq,[Decidable, Eq, Decidable.isTrue, propext, Decidable.isFalse, instDecidableEq.proof_1],[Decidable, Eq]]
[ExceptT.finally,[MonadFinally.mk, ExceptT.mk, Bind.bind, MonadFinally.tryFinally', Option.none, Option.some, Except.error, Except, Except.ok, Prod, Pure.pure, Prod.mk],[MonadFinally, ExceptT]]
[Lean.Meta.Simp.Config.zeta,[],[Bool]]
[UInt32.add,[UInt32.mk, HAdd.hAdd, UInt32.val],[UInt32]]
[Lean.Name.hash,[Unit.unit, UInt64, UInt64.ofNatCore, OfNat.ofNat, Lean.Name.hash.proof_1],[UInt64]]
[WellFounded.induction,[WellFounded.recursion],[]]
[Substring.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Substring.mk, HAdd.hAdd, OfNat.ofNat]]
[instMonadStateOf,[MonadStateOf.mk, liftM, MonadStateOf.get, MonadStateOf.set, MonadLiftT.monadLift, MonadState.modifyGet],[MonadStateOf]]
[UInt8.le,[LE.le, UInt8.val],[]]
[coe,[CoeT.coe],[]]
[Lean.MonadRef.noConfusionType,[],[]]
[Quotient.exact,[Quot.inductionOn, Setoid.refl],[HasEquiv.Equiv]]
[Lean.Syntax.SepArray.getElems,[Array.getSepElems, Lean.Syntax.SepArray.elemsAndSeps],[Array, Lean.Syntax]]
[HEq.elim,[eq_of_heq],[]]
[«term_∧_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instLawfulMonadStateRefT'.proof_1,[inferInstanceAs, LawfulMonad, ReaderT, ST.Ref],[LawfulMonad, ReaderT, ST.Ref]]
[dif_neg,[Eq, dite, absurd, rfl],[Eq, dite]]
[Std.Format.nest.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.Format.nest, HAdd.hAdd, OfNat.ofNat]]
[Squash,[Quot, True],[]]
[Lean.Syntax.isIdent,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Bool, Bool.true, Bool.false],[Bool]]
[HAdd.hAdd,[],[]]
[getModify,[MonadState.modifyGet, Prod.mk],[]]
[Lean.Macro.State.traceMsgs,[],[List, Prod, Lean.Name, String]]
[Fin.instXorFin,[Xor.mk, Fin.xor],[Xor, Fin]]
[Lean.instEvalIO,[Lean.Eval.mk, Bind.bind, Unit.unit, Lean.Eval.eval, Bool.true],[Lean.Eval, IO]]
[Array.findSomeM?,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, ForInStep, MProd, Option, PUnit, Pure.pure, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, MProd.fst],[Option]]
[EStateM.instOrElseEStateM,[OrElse.mk, EStateM.orElse],[OrElse, EStateM]]
[Lean.Parser.Tactic.Conv.convApply_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[List.forIn_nil,[rfl],[Eq, ForIn.forIn, List.nil, Pure.pure]]
[StateT.ext,[funext],[Eq]]
[Nat.gt_of_not_le,[GT.gt, Nat.lt_or_ge, absurd],[GT.gt]]
[Quotient.liftOn,[Quot.liftOn],[]]
[instSubsingletonForall,[instSubsingletonForall.proof_1],[Subsingleton]]
[UInt64.shiftRight,[UInt64.mk, HShiftRight.hShiftRight, UInt64.val, UInt64.modn, OfNat.ofNat],[UInt64]]
[IO.Process.Stdio.noConfusion,[noConfusionEnum, IO.Process.Stdio.toCtorIdx],[IO.Process.Stdio.noConfusionType]]
[Lean.Parser.Tactic.Conv.rhs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Nat.superDigitChar,[ite, Eq, OfNat.ofNat, Char.ofNat],[Char]]
[implies.trans,[],[implies]]
[instToStringSubstring,[ToString.mk, Substring.toString],[ToString, Substring]]
[PLift.down_up,[rfl],[Eq, PLift.down, PLift.up]]
[InvImage.accessible.proof_1,[Acc.intro, rfl],[Acc, InvImage]]
[Option.toBool,[Unit.unit, Bool, Bool.true, Bool.false],[Bool]]
[String.Iterator.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, String.Iterator.mk, HAdd.hAdd, OfNat.ofNat]]
[OptionT.mk,[],[OptionT]]
[Subarray.as,[],[Array]]
[instDecidableEqQuotient,[Quotient.recOnSubsingleton₂, Decidable, Eq, Quotient.mk, Decidable.isTrue, Quotient.sound, Decidable.isFalse, instDecidableEqQuotient.proof_2],[DecidableEq, Quotient]]
[Std.instToFormatFormat,[Std.ToFormat.mk],[Std.ToFormat, Std.Format]]
[MonadStateOf.get,[],[]]
[System.FilePath.instHDivFilePathStringFilePath,[HDiv.mk, System.FilePath.join, System.FilePath.mk],[HDiv, System.FilePath, String]]
[HOr.hOr,[],[]]
[instToStreamStringSubstring,[ToStream.mk, String.toSubstring],[ToStream, String, Substring]]
[Lean.Parser.Tactic.specialize,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[instInhabitedUInt8,[Inhabited.mk, UInt8.ofNatCore, OfNat.ofNat, instInhabitedUInt8.proof_1],[Inhabited, UInt8]]
[instHMod,[HMod.mk, Mod.mod],[HMod]]
[Ord.noConfusionType,[],[]]
[Squash.lift,[Quot.lift, Squash.lift.proof_1],[]]
[Lean.Module.mk.inj,[And.intro],[And, Eq]]
[calc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, calcStep, Lean.ParserDescr.const],[Lean.ParserDescr]]
[EStateM.throw,[EStateM.Result.error],[EStateM]]
[Nat.le_succ_of_le,[Nat.le_trans, Nat.le_succ],[LE.le, Nat.succ]]
[Lean.Parser.Tactic.tacticTry_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Iff.noConfusionType,[],[]]
[System.instToStringFilePath,[ToString.mk, System.FilePath.toString],[ToString, System.FilePath]]
[IO.Process.StdioConfig.noConfusionType,[],[]]
[MonadState.noConfusionType,[],[]]
[LawfulFunctor.id_map,[],[Eq, Functor.map, id]]
[IO.Process.Stdio.toCtorIdx,[OfNat.ofNat],[Nat]]
[Std.Range.forM.loop,[ite, GE.ge, Std.Range.stop, Pure.pure, PUnit.unit, Unit.unit, PUnit, Bind.bind, PProd.fst, HAdd.hAdd, Std.Range.step],[PUnit]]
[Lean.NameGenerator.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.NameGenerator.mk, HAdd.hAdd, OfNat.ofNat]]
[instXorUSize,[Xor.mk, USize.xor],[Xor, USize]]
[String.Iterator.setCurr,[String.Iterator, String.Iterator.mk, String.set],[String.Iterator]]
[ReaderT.tryFinally,[MonadFinally.mk, MonadFinally.tryFinally'],[MonadFinally, ReaderT]]
[String.Iterator.noConfusionType,[],[]]
[instHashableNat,[Hashable.mk, UInt64.ofNat],[Hashable, Nat]]
[Lean.mkAtomFrom,[Lean.Syntax.atom, Lean.SourceInfo.fromRef],[Lean.Syntax]]
[Int.instInhabitedInt,[Inhabited.mk, Int.ofNat, OfNat.ofNat],[Inhabited, Int]]
[instDivUInt64,[Div.mk, UInt64.div],[Div, UInt64]]
[IO.FS.Stream.Buffer.pos,[],[Nat]]
[StateRefT'.instMonadStateOfStateRefT',[MonadStateOf.mk, StateRefT'.get, StateRefT'.set, StateRefT'.modifyGet],[MonadStateOf, StateRefT']]
[instReprExcept,[Repr.mk, Std.Format, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg],[Repr, Except]]
[String.map,[String.mapAux, OfNat.ofNat],[String]]
[Array.get.proof_1,[Fin.isLt],[LT.lt, Fin.val, Array.size]]
[instOrElseEIO,[OrElse.mk, MonadExcept.orElse],[OrElse, EIO]]
[Sum.inl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Sum.inl, HAdd.hAdd, OfNat.ofNat]]
[implies_congr_ctx,[propext, Iff.intro],[Eq]]
[Thunk.noConfusionType,[],[]]
[OptionT.pure,[OptionT.mk, Pure.pure, Option.some],[OptionT]]
[strictOr,[or],[Bool]]
[Lean.Syntax.setKind,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.node],[Lean.Syntax]]
[Lean.Meta.Rewrite.Config.transparency,[],[Lean.Meta.TransparencyMode]]
[Nat.foldRev.loop,[PProd.fst],[]]
[Nat.le_add_right,[LE.le, HAdd.hAdd, Nat.le_refl, Nat.le_succ_of_le, PProd.fst],[LE.le, HAdd.hAdd]]
[HOrElse.noConfusionType,[],[]]
[Nat.succ_lt_succ,[Nat.succ_le_succ],[LT.lt, Nat.succ]]
[«term_*>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Subarray.forM,[Array.forM, Subarray.as, Subarray.start, Subarray.stop],[PUnit]]
[Std.Format.FlattenBehavior.noConfusion,[noConfusionEnum, Std.Format.FlattenBehavior.toCtorIdx],[Std.Format.FlattenBehavior.noConfusionType]]
[Nat.add_lt_add,[Nat.lt_trans, Nat.add_lt_add_right, Nat.add_lt_add_left],[LT.lt, HAdd.hAdd]]
[Option.isEqSome,[Bool, BEq.beq, Bool.false],[Bool]]
[Nat.zero_lt_one,[Nat.zero_lt_succ, OfNat.ofNat],[LT.lt, OfNat.ofNat]]
[Lean.Meta.TransparencyMode.noConfusion,[noConfusionEnum, Lean.Meta.TransparencyMode.toCtorIdx],[Lean.Meta.TransparencyMode.noConfusionType]]
[IO.Process.Stdio.inherit.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.Process.Stdio.inherit, OfNat.ofNat]]
[Lean.Parser.Tactic.rwWithRfl,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Option.getD, Lean.Syntax.getHeadInfo?, List.nil],[Lean.MacroM, Lean.Syntax]]
[IO.Error.resourceBusy.inj,[And.intro],[And, Eq]]
[Array.findSome?,[Id.run, Array.findSomeM?],[Option]]
[PSum.inl.inj,[],[Eq]]
[String.foldrAux,[String.foldrAux.loop],[]]
[BEq.beq,[],[Bool]]
[USize.sub,[USize.mk, HSub.hSub, USize.val],[USize]]
[IO.Error.protocolError.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.protocolError, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.Conv.convSeq1Indented,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[instHModUInt8NatUInt8,[HMod.mk, UInt8.modn],[HMod, UInt8, Nat]]
[Array.toArrayLit,[List.toArray, Array.toListLitAux, Array.toArrayLit.proof_1, List.nil],[Array]]
[UInt32.toNat,[Fin.val, UInt32.val],[Nat]]
[Lean.extractMacroScopes,[Unit.unit, Lean.MacroScopesView, Lean.Name.hasMacroScopes, Lean.Name.anonymous, PProd.fst, List.cons, Lean.Name.str, Lean.Name.num, BEq.beq, Lean.MacroScopesView.mk, Lean.Name, Lean.Name.mkStr, Lean.Name.mkNum, panic, List.nil],[Lean.MacroScopesView]]
[USize.toUInt32,[Nat.toUInt32, USize.toNat],[UInt32]]
[coeDecidableEq,[inferInstanceAs, Decidable, Eq, Bool.true],[Decidable, coe]]
[Std.Format.text.injEq,[Eq.propIntro, Eq.refl, Std.Format.text, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.Format.text]]
[ByteArray.isEmpty,[BEq.beq, ByteArray.size, OfNat.ofNat],[Bool]]
[Lean.Parser.Tactic.tacticSuffices_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Nat.add_assoc,[Eq, HAdd.hAdd, rfl, congrArg, Nat.succ, PProd.fst],[Eq, HAdd.hAdd]]
[System.FilePath.noConfusionType,[],[]]
[Array.foldlMUnsafe.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bind.bind, Array.uget, lcProof, Array.foldlMUnsafe.fold, HAdd.hAdd, OfNat.ofNat],[]]
[Fin.shiftRight,[Fin, Fin.mk, HMod.hMod, HShiftRight.hShiftRight, Fin.shiftRight.proof_1],[Fin]]
[«term_>>>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Syntax.isNameLit?,[Option.none, Option, Lean.Name, Lean.Syntax.isLit?, Lean.nameLitKind, Lean.Syntax.decodeNameLit],[Option, Lean.Name]]
[Prod.ext,[rfl, Eq.symm, Eq.refl],[Eq, Prod.mk, Prod.fst, Prod.snd]]
[IO.FS.DirEntry.noConfusionType,[],[]]
[Lean.Name.toString,[Lean.Name.toStringWithSep, and, not, Lean.Name.isInaccessibleUserName, Lean.Name.hasMacroScopes, Lean.Name.toString.maybePseudoSyntax],[String]]
[Std.Format.prettyM,[List.cons, Bool.false, Std.Format.FlattenBehavior.allOrNone, Int.ofNat, OfNat.ofNat, List.nil],[Unit]]
[Int.decEq,[Decidable, Eq, Int.ofNat, decEq, Decidable.isTrue, Int.decEq.proof_1, Decidable.isFalse, Int.decEq.proof_2, Int.negSucc, Int.decEq.proof_3, Int.decEq.proof_4, Int.decEq.proof_5, Int.decEq.proof_6],[Decidable, Eq]]
[Lean.Macro.withIncRecDepth,[Bind.bind, MonadReader.read, Unit.unit, Lean.MacroM, BEq.beq, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth, MonadExcept.throw, Lean.Macro.Exception.error, Lean.maxRecDepthErrorMessage, MonadWithReader.withReader, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope, HAdd.hAdd, OfNat.ofNat, Lean.Macro.Context.ref],[Lean.MacroM]]
[StateT.run_seqLeft,[],[Eq, StateT.run, SeqLeft.seqLeft, Bind.bind, Prod.snd, Pure.pure, Prod.mk, Prod.fst]]
[Nat.digitChar,[ite, Eq, OfNat.ofNat, Char.ofNat],[Char]]
[Array.data,[],[List]]
[Array.findRev?,[Id.run, Array.findRevM?],[Option]]
[hasOfNatOfCoe,[OfNat.mk, coe, OfNat.ofNat],[OfNat]]
[Lean.monadNameGeneratorLift,[Lean.MonadNameGenerator.mk, liftM, Lean.MonadNameGenerator.getNGen, Lean.MonadNameGenerator.setNGen],[Lean.MonadNameGenerator]]
[ShiftLeft.shiftLeft,[],[]]
[ExceptCpsT.run_pure,[rfl],[Eq, ExceptCpsT.run, Pure.pure, Except.ok]]
[Array.appendCore.loop,[dite, LT.lt, Array.size, Unit.unit, Array, PProd.fst, HAdd.hAdd, OfNat.ofNat, Array.push, Array.get, Fin.mk],[Array]]
[UInt8.ofNat,[UInt8.mk, Fin.ofNat],[UInt8]]
[instModUSize,[Mod.mk, USize.mod],[Mod, USize]]
[«term_×_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Parser.Tactic.tacticLet'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[EStateM,[EStateM.Result],[]]
[Option.instDecidableRelLt,[Unit.unit, Decidable, Option.lt, Decidable.isTrue, trivial, Decidable.isFalse, not_false],[DecidableRel, Option.lt]]
[Quot.recOn,[Quot.rec],[]]
[Std.Format.instInhabitedSpaceResult,[Inhabited.mk, arbitrary],[Inhabited]]
[Lean.instInhabitedNameGenerator,[Inhabited.mk, Lean.NameGenerator.mk, arbitrary],[Inhabited, Lean.NameGenerator]]
[instRandomGenStdGen,[RandomGen.mk, stdRange, stdNext, stdSplit],[RandomGen, StdGen]]
[HAndThen.hAndThen,[],[]]
[UInt16.le,[LE.le, UInt16.val],[]]
[StateCpsT.runK_pure,[rfl],[Eq, StateCpsT.runK, Pure.pure]]
[rawNatLit,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[List.filterMap,[Unit.unit, List, List.nil, PProd.fst, List.cons],[List]]
[IO.FS.instLESystemTime,[leOfOrd],[LE, IO.FS.SystemTime]]
[Lean.binderIdent,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[String.revPosOf,[ite, Eq, BEq.beq, String.bsize, OfNat.ofNat, Bool.true, Option.none, String.revPosOfAux, String.prev],[Option, String.Pos]]
[Lean.Name.replacePrefix,[Lean.Name.str, Lean.Name.num, Lean.Name, Lean.Name.anonymous, ite, Eq, BEq.beq, Bool.true, Lean.Name.mkStr, PProd.fst, Lean.Name.mkNum],[Lean.Name]]
[IO.FS.Metadata.noConfusionType,[],[]]
[Nat.not_le_of_not_ble_eq_true,[absurd, Nat.ble_eq_true_of_le],[Not, LE.le]]
[FloatArray.toList,[OfNat.ofNat, List.nil, FloatArray.toList.loop],[List, Float]]
[Lean.Macro.State.macroScope,[],[Lean.MacroScope]]
[Array.swap.proof_1,[Eq.symm, Array.size_set, Array.get],[Eq, Array.size, Array.set, Array.get]]
[Char.valid,[],[UInt32.isValidChar, Char.val]]
[instStreamRangeNat,[Stream.mk, ite, LT.lt, Std.Range.start, Std.Range.stop, Option.some, Prod.mk, Std.Range.mk, HAdd.hAdd, Std.Range.step, Option.none],[Stream, Std.Range, Nat]]
[instDecidableEq.proof_1,[Iff.rfl],[False]]
[Bool.noConfusionType,[],[]]
[Quotient.lift₂,[Quotient.lift, Quotient.lift₂.proof_1, Quotient.lift₂.proof_2],[]]
[monadLift_self,[rfl],[Eq, MonadLiftT.monadLift]]
[IO.FS.FileType.noConfusion,[noConfusionEnum, IO.FS.FileType.toCtorIdx],[IO.FS.FileType.noConfusionType]]
[String.anyAux,[String.anyAux.loop],[Bool]]
[Lean.Parser.Tactic.simpAll,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma],[Lean.ParserDescr]]
[USize.noConfusionType,[],[]]
[String.takeWhile,[Substring.toString, Substring.takeWhile, String.toSubstring],[String]]
[System.FilePath.components,[String.splitOn, System.FilePath.toString, System.FilePath.normalize, Bool.false, Char.toString, System.FilePath.pathSeparator],[List, String]]
[Array.instToStringArray,[ToString.mk, HAppend.hAppend, ToString.toString, Array.toList],[ToString, Array]]
[Array.toListLitAux.proof_1,[Nat.le_of_succ_le],[LE.le, Array.size]]
[FloatArray.mk.inj,[],[Eq]]
[Array.anyM.loop,[dite, LT.lt, Unit.unit, Bool, Pure.pure, Bool.false, Bind.bind, Array.get, Fin.mk, Array.anyM.loop.proof_1, ite, Eq, Bool.true, PProd.fst, HAdd.hAdd, OfNat.ofNat],[Bool]]
[IO.toEIO,[EStateM.adaptExcept],[EIO]]
[unsafeCast.proof_1,[lcProof],[Eq]]
[fixCore6,[bfix6, USize.size],[]]
[«term∃_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[instMonadReaderOf,[MonadReaderOf.mk, liftM, MonadReader.read],[MonadReaderOf]]
[List.tail?,[Unit.unit, Option, List, Option.none, Option.some],[Option, List]]
[«stx_,*,?»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[TC.wf.proof_1,[WellFounded.intro, TC.accessible, WellFounded.apply],[WellFounded, TC]]
[Prod.snd,[],[]]
[UInt8.lt,[LT.lt, UInt8.val],[]]
[Lean.isIdRest,[or, Char.isAlphanum, Decidable.decide, Eq, Char.ofNat, BEq.beq, Lean.isLetterLike, Lean.isSubScriptAlnum],[Bool]]
[OptionT,[Option],[]]
[Lean.Syntax.mkNameLit,[Lean.Syntax.mkLit, Lean.nameLitKind],[Lean.Syntax]]
[Fin.instAddFin,[Add.mk, Fin.add],[Add, Fin]]
[instAddFloat,[Add.mk, Float.add],[Add, Float]]
[FloatArray.forIn,[FloatArray.size, Nat.le_refl, FloatArray.forIn.loop],[]]
[Nat.add,[Nat, Nat.succ, PProd.fst],[Nat]]
[Substring.noConfusionType,[],[]]
[«term_$__»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[UInt64.shiftLeft,[UInt64.mk, HShiftLeft.hShiftLeft, UInt64.val, UInt64.modn, OfNat.ofNat],[UInt64]]
[Lean.instEvalUnit,[Lean.Eval.mk, ite, Eq, Bool.true, Pure.pure, Unit.unit, IO.println, repr],[Lean.Eval, Unit]]
[Nat.zero_le,[Unit.unit, LE.le, OfNat.ofNat, Nat.le.refl, Nat.le.step, PProd.fst],[LE.le, OfNat.ofNat]]
[liftM,[MonadLiftT.monadLift],[]]
[instXorUInt64,[Xor.mk, UInt64.xor],[Xor, UInt64]]
[ptrAddrUnsafe,[OfNat.ofNat],[USize]]
[IO.Error.hardwareFault.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.hardwareFault, HAdd.hAdd, OfNat.ofNat]]
[noConfusionEnum.proof_2,[congrArg],[False]]
[IO.Error.mkResourceExhaustedFile,[Function.comp, IO.Error.resourceExhausted, Option.some],[IO.Error]]
[Nat.decEq,[Decidable, Eq, Nat.beq, Nat.decEq.proof_1, Decidable.isTrue, Nat.eq_of_beq_eq_true, Decidable.isFalse, Nat.ne_of_beq_eq_false],[Decidable, Eq]]
[bfix1,[PProd.fst],[]]
[Nat.eq_of_beq_eq_true,[Eq, rfl],[Eq]]
[Decidable.em,[Decidable.byCases, Or.inl, Or.inr],[Or, Not]]
[Array.isEqv,[dite, Eq, Array.size, Array.isEqvAux, OfNat.ofNat, Bool.false],[Bool]]
[ExceptT.instMonadLiftExceptT,[MonadLift.mk, ExceptT.lift],[MonadLift, ExceptT]]
[PSigma.lex,[PSigma.lex.proof_1],[WellFounded, PSigma.Lex]]
[Fin.land.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, Nat.land]]
[id.def,[rfl],[Eq, id]]
[«term_-_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[List.toArray,[List.toArrayAux, Array.mkEmpty, List.redLength],[Array]]
[Lean.Name.num.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.Conv.convIntro___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Except.map,[Except, Except.error, Except.ok],[Except]]
[List.minimum?,[Unit.unit, Option, Option.none, Option.some, List.foldl, min],[Option]]
[ReaderT.run_bind,[rfl],[Eq, ReaderT.run, Bind.bind]]
[instMonadExceptOfEIO,[inferInstanceAs, MonadExceptOf, EStateM, IO.RealWorld],[MonadExceptOf, EIO]]
[ExceptT.bind,[ExceptT.mk, Bind.bind, ExceptT.bindCont],[ExceptT]]
[instSubsingletonStateM.proof_1,[Subsingleton.intro, funext, Eq, Eq.mpr, Eq.refl, Prod.mk, Subsingleton.elim, rfl],[Subsingleton, StateM]]
[precMin,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[instReprProd,[Repr.mk, Std.Format, Std.Format.bracket, Std.Format.joinSep, List.reverse, ReprTuple.reprTuple, List.cons, repr, List.nil, HAppend.hAppend, Std.Format.text, Std.Format.line],[Repr, Prod]]
[List.filterAuxM,[List, Pure.pure, Bind.bind, PProd.fst, cond, List.cons],[List]]
[Nat.zero_lt_succ,[Nat.succ_le_succ, Nat.zero_le],[LT.lt, OfNat.ofNat, Nat.succ]]
[Fin.div.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, HDiv.hDiv]]
[IO.FS.DirEntry.path,[HDiv.hDiv, IO.FS.DirEntry.root, System.FilePath.mk, IO.FS.DirEntry.fileName],[System.FilePath]]
[Nat.pred_lt,[LT.lt, Nat.pred, absurd, rfl, Nat.lt_succ_of_le, Nat.le_refl, Nat.succ],[LT.lt, Nat.pred]]
[Lean.MonadRef.getRef,[],[Lean.Syntax]]
[noConfusionTypeEnum,[ite, Eq],[]]
[UInt8.shiftLeft,[UInt8.mk, HShiftLeft.hShiftLeft, UInt8.val, UInt8.modn, OfNat.ofNat],[UInt8]]
[UInt8.decLe,[Decidable, LE.le, inferInstanceAs],[Decidable, LE.le]]
[ST.Ref.modifyGet,[liftM, ST.Prim.Ref.modifyGet],[]]
[Lean.Parser.Tactic.constructor,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[List.length_add_eq_lengthTRAux,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Nat.zero_add, eq_self, Eq.mpr, congr, Nat.succ_add, List.length, Eq.symm, Nat.succ, rfl],[Eq, HAdd.hAdd, List.length, List.lengthTRAux]]
[Classical.inhabited_of_nonempty,[Inhabited.mk, Classical.choice],[Inhabited]]
[Char.utf8Size.proof_4,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[Option.orElse,[Option, Option.some, Unit.unit],[Option]]
[Trans.trans,[],[]]
[noConfusionEnum,[dite, Eq, cast, noConfusionEnum.proof_1, False.elim, noConfusionEnum.proof_2],[noConfusionTypeEnum]]
[Array.erase,[Unit.unit, Array, Array.indexOf?, Array.feraseIdx],[Array]]
[Int.le,[Int.NonNeg, HSub.hSub],[]]
[IO.Error.illegalOperation.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.illegalOperation, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.Conv.change,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Tactic.refine',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[WellFounded.fixF,[],[]]
[«term_*_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[«term_>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[MonadControl.noConfusionType,[],[]]
[instStreamProdProd,[Stream.mk, Option, Prod, Unit.unit, Stream.next?, Option.none, Option.some, Prod.mk],[Stream, Prod]]
[Float.mk.injEq,[Eq.propIntro, Eq.refl, Float.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Float.mk]]
[Substring.trimRight,[Substring.dropRightWhile, Char.isWhitespace],[Substring]]
[instReprAtomFloat,[ReprAtom.mk],[ReprAtom, Float]]
[List.getLast?.proof_1,[],[List.noConfusionType, False, List.cons, List.nil]]
[Char.val_eq_of_eq,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Eq, Char.val, rfl],[Eq, Char.val]]
[Nat.lt_of_succ_lt_succ,[Nat.le_of_succ_le_succ],[LT.lt]]
[instToStringSubarray,[ToString.mk, ToString.toString, Subarray.toArray],[ToString, Subarray]]
[IO.FS.Mode.write.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.Mode.write, OfNat.ofNat]]
[tacticCalc_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, calcStep],[Lean.ParserDescr]]
[Char.utf8Size.proof_3,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[Char.lt,[LT.lt, Char.val],[]]
[IO.FS.Stream.Buffer.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.FS.Stream.Buffer.mk, HAdd.hAdd, OfNat.ofNat]]
[FloatSpec.val,[],[FloatSpec.float]]
[instSizeOfNat,[SizeOf.mk],[SizeOf, Nat]]
[instDivUInt8,[Div.mk, UInt8.div],[Div, UInt8]]
[PSigma.revLexAccessible.proof_1,[Acc.intro, PSigma.mk, Eq.symm, eq_of_heq, Eq.refl, HEq.refl],[Acc, PSigma.RevLex, PSigma.mk]]
[Stream.forIn,[Stream.forIn.visit],[]]
[Lean.Macro.hasDecl,[Bind.bind, Lean.Macro.getMethods, Lean.Macro.Methods.hasDecl],[Lean.MacroM, Bool]]
[Lean.Meta.Simp.Config.proj,[],[Bool]]
[SeqLeft.noConfusionType,[],[]]
[«term_/_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[List.length_set,[rfl, Eq.symm, of_eq_true, Eq.trans, congr, congrArg, Eq, List.length_cons, List.set, Nat.succ, eq_self, List.length, Eq.refl],[Eq, List.length, List.set]]
[bind_congr,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Bind.bind, funext, eq_self],[Eq, Bind.bind]]
[Std.ToFormat.format,[],[Std.Format]]
[Std.Format.tag.inj,[And.intro],[And, Eq]]
[Lean.Parser.Tactic.Conv.enterArg,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[UInt64.ofNat,[UInt64.mk, Fin.ofNat],[UInt64]]
[ToString.toString,[],[String]]
[StateT.run_bind_lift,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, LawfulMonad.bind_assoc, Pure.pure, Prod.mk, Bind.bind, funext, LawfulMonad.pure_bind, eq_self],[Eq, StateT.run, Bind.bind, StateT.lift]]
[String.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, String.mk, HAdd.hAdd, OfNat.ofNat]]
[String.Iterator.extract,[String, ite, Eq, or, Decidable.decide, Ne, GT.gt, Bool.true, String.extract],[String]]
[String.Pos,[Nat],[]]
[Decidable.byContradiction,[Decidable.byCases, id, False.elim],[]]
[Nat.mod_one,[],[Eq, HMod.hMod, OfNat.ofNat]]
[UInt16.shiftLeft,[UInt16.mk, HShiftLeft.hShiftLeft, UInt16.val, UInt16.modn, OfNat.ofNat],[UInt16]]
[Lean.instQuoteArray,[Lean.Quote.mk, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Quote.quote, Array.toList, List.nil],[Lean.Quote, Array]]
[IO.Error.unsupportedOperation.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.unsupportedOperation, HAdd.hAdd, OfNat.ofNat]]
[Lean.Syntax.getId,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Name, Lean.Name.anonymous],[Lean.Name]]
[precMax,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[instToStringSum,[ToString.mk, String, HAppend.hAppend, addParenHeuristic, ToString.toString],[ToString, Sum]]
[Int.instOfNatInt,[OfNat.mk, Int.ofNat],[OfNat, Int]]
[Nat.noConfusionType,[],[]]
[UInt32.decEq.proof_2,[absurd],[False]]
[ExceptT.mk,[],[ExceptT]]
[eq_true,[propext, Iff.intro, trivial],[Eq, True]]
[FloatArray.size,[Nat, Array.size],[Nat]]
[ForInStep.noConfusionType,[],[]]
[IO.Process.Output.stderr,[],[String]]
[Lean.Name.append,[Lean.Name, Lean.Name.mkStr, PProd.fst, Lean.Name.mkNum],[Lean.Name]]
[IO.Error.illegalOperation.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.illegalOperation, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.illegalOperation, And]]
[Char.isValidChar_zero,[Or.inl, of_decide_eq_true, Eq.refl, Bool.true],[isValidChar, OfNat.ofNat]]
[FloatArray.get!,[Float, Array.get!],[Float]]
[Lean.Parser.Tactic.tacticUnhygienic_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[«term_>=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[List.cons.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, List.cons, HAdd.hAdd, OfNat.ofNat]]
[CoeHead.coe,[],[]]
[«prio(_)»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[ByteArray.toList,[OfNat.ofNat, List.nil, ByteArray.toList.loop],[List, UInt8]]
[Array.eraseIdxSzAuxInstance,[Inhabited.mk, Subtype.mk, Array.pop, Array.size_pop],[Inhabited, Subtype, Eq, Array.size, HSub.hSub, OfNat.ofNat]]
[Nat.pow_succ,[rfl],[Eq, HPow.hPow, Nat.succ, HMul.hMul]]
[Lean.Macro.Methods.resolveGlobalName,[],[Lean.MacroM, List, Prod, Lean.Name, String]]
[Nat.lt_succ_of_le,[Nat.succ_le_succ],[LT.lt, Nat.succ]]
[Array.mkArray,[Array.mk, List.replicate],[Array]]
[Array.foldrM.fold.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self],[LE.le, Array.size]]
[String.join,[List.foldl, HAppend.hAppend],[String]]
[IO.FileRight.group,[],[IO.AccessRight]]
[Fin.mk.inj,[],[Eq]]
[coeOfHeafOfTCOfTail,[CoeHTCT.mk, coeTail, coeTC, coeHead],[CoeHTCT]]
[StateT.seqLeft_eq,[StateT.ext, of_eq_true, Eq.trans, congr, congrArg, Eq, StateT.run_seqLeft, StateT.run_seq, Functor.map, Function.const, Bind.bind, StateT.run_map, map_eq_pure_bind, Prod.mk, Prod.fst, Prod.snd, StateT.run, funext, LawfulMonad.bind_assoc, Pure.pure, LawfulMonad.pure_bind, congrFun, Function.const_apply, eq_self],[Eq, SeqLeft.seqLeft, Seq.seq, Functor.map, Function.const]]
[instDecidableEqSum.proof_6,[],[Sum.noConfusionType, False, Sum.inl, Sum.inr]]
[Lean.Parser.Tactic.assumption,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[List.hasDecEq.proof_4,[rfl],[Eq, List.cons]]
[decidableOfDecidableOfIff.proof_1,[absurd, Iff.mpr],[False]]
[String.back,[String.get, String.prev, String.bsize],[Char]]
[List.drop,[List, List.nil, PProd.fst],[List]]
[Int.instAddInt,[Add.mk, Int.add],[Add, Int]]
[List.toFloatArray.loop,[FloatArray, PProd.fst, FloatArray.push],[FloatArray]]
[Int.instDivInt,[Div.mk, Int.div],[Div, Int]]
[IO.Process.Output.exitCode,[],[UInt32]]
[Substring.beq,[and, BEq.beq, Substring.bsize, String.substrEq, Substring.str, Substring.startPos],[Bool]]
[Option.eq_none_of_isNone,[Eq.refl, Bool.true, HEq.refl, Eq, Option.none, rfl],[Eq, Option.none]]
[EStateM.nonBacktrackable,[EStateM.Backtrackable.mk, EStateM.dummySave, EStateM.dummyRestore],[EStateM.Backtrackable, PUnit]]
[Lean.mkSepArray,[Id.run, Bind.bind, ForIn.forIn, MProd.mk, ite, GT.gt, OfNat.ofNat, Pure.pure, PUnit.unit, Id, Array, Lean.Syntax],[Array, Lean.Syntax]]
[ST.Ref.ref,[],[PointedType.type, ST.RefPointed]]
[Alternative.orElse,[],[]]
[Std.Format.MonadPrettyFormat.pushNewline,[],[Unit]]
[Classical.strongIndefiniteDescription.proof_2,[absurd],[Classical.choice]]
[Lean.MonadQuotation.addMacroScope,[Bind.bind, Lean.MonadQuotation.getMainModule, Lean.MonadQuotation.getCurrMacroScope, Pure.pure, Lean.addMacroScope],[Lean.Name]]
[UInt64.decEq.proof_1,[rfl],[Eq, UInt64.mk]]
[Nat.not_lt_zero,[Nat.not_succ_le_zero],[Not, LT.lt, OfNat.ofNat]]
[IO.FS.SystemTime.nsec,[],[UInt32]]
[Array.size,[List.length, Array.data],[Nat]]
[Array.filterM,[Array.foldlM, Bind.bind, ite, Eq, Bool.true, Pure.pure, Array.push, List.toArray, List.nil],[Array]]
[Lean.expandExplicitBinders,[Bind.bind, Lean.MonadRef.getRef, ite, Eq, BEq.beq, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.expandExplicitBindersAux, Array.all, Lean.Syntax.getArgs, OfNat.ofNat, Array.size, Lean.expandBrackedBindersAux, Lean.Macro.throwError],[Lean.MacroM, Lean.Syntax]]
[Lean.Syntax.mkSep,[Lean.mkNullNode, Lean.mkSepArray],[Lean.Syntax]]
[ByteArray.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, ByteArray.mk, HAdd.hAdd, OfNat.ofNat]]
[coeTC,[CoeTC.coe],[]]
[Lean.Parser.Tactic.Conv.conv,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[instDecidableArrow.proof_1,[],[]]
[MonadReaderOf.read,[],[]]
[instReprId,[inferInstanceAs, Repr],[Repr, id]]
[coeD,[CoeDep.coe],[]]
[Array.findSomeRevM?,[Array.size, Nat.le_refl, Array.findSomeRevM?.find],[Option]]
[PSigma.skipLeft,[WellFoundedRelation.mk, PSigma.SkipLeft, WellFoundedRelation.rel, PSigma.skipLeft.proof_1],[WellFoundedRelation, PSigma]]
[Lean.Parser.Syntax.subPrec,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[boolToProp,[Coe.mk, Eq, Bool.true],[Coe, Bool]]
[StateCpsT.runK_bind_set,[rfl],[Eq, StateCpsT.runK, Bind.bind, MonadStateOf.set, PUnit.unit]]
[instMonadWithReaderOfReaderT,[MonadWithReaderOf.mk],[MonadWithReaderOf, ReaderT]]
[instReprBool,[Repr.mk, Std.Format, Std.Format.text],[Repr, Bool]]
[Lean.Syntax.node.inj,[And.intro],[And, Eq]]
[Lean.Macro.instInhabitedMethods,[Inhabited.mk, Lean.Macro.Methods.mk, arbitrary],[Inhabited, Lean.Macro.Methods]]
[Array.getLit.proof_1,[Eq.symm],[LT.lt, Array.size]]
[instSubsingletonPUnit,[Subsingleton.intro, PUnit.subsingleton],[Subsingleton, PUnit]]
[«term_>>=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Quotient.rec,[Quot.rec],[]]
[ST.Ref.noConfusionType,[],[]]
[runST,[Unit, Unit.unit],[]]
[PProd.fst,[],[]]
[instOrdBool,[Ord.mk, Bool.false, Unit.unit, Bool.true, Ordering, Ordering.lt, Ordering.gt, Ordering.eq],[Ord, Bool]]
[System.instInhabitedFilePath,[Inhabited.mk, System.FilePath.mk, arbitrary],[Inhabited, System.FilePath]]
[USize.le,[LE.le, USize.val],[]]
[Lean.Name.mkStr,[Lean.Name.str, mixHash, Hashable.hash],[Lean.Name]]
[Lean.mkGroupNode,[Lean.mkNode, Lean.groupKind],[Lean.Syntax]]
[Array.instEmptyCollectionArray,[EmptyCollection.mk, Array.empty],[EmptyCollection, Array]]
[ByteArray.set!,[ByteArray, ByteArray.mk, Array.set!],[ByteArray]]
[EStateM.instMonadStateOfEStateM,[MonadStateOf.mk, EStateM.get, EStateM.set, EStateM.modifyGet],[MonadStateOf, EStateM]]
[Lean.MacroScopesView.imported,[],[Lean.Name]]
[«term_=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[IO.setAccessRights,[IO.Prim.setAccessRights, IO.FileRight.flags],[IO, Unit]]
[coeOfHeadOfTC,[CoeHTCT.mk, coeTC, coeHead],[CoeHTCT]]
[unexpandSubtype,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Lean.Syntax.ident.inj,[And.intro],[And, Eq]]
[Nat.toUInt8,[UInt8.ofNat],[UInt8]]
[List.length_eq_lenghtTR,[funext, of_eq_true, Eq.trans, congrArg, Eq, List.length, Eq.symm, List.length_add_eq_lengthTRAux, OfNat.ofNat, Nat.add_zero, eq_self],[Eq, List.length, List.lengthTR]]
[HEq.rfl.proof_1,[HEq.refl],[HEq]]
[HEq.ndrec,[],[]]
[Id.bind_eq,[rfl],[Eq, Bind.bind]]
[EStateM.Backtrackable.restore,[],[]]
[emptyRelation,[False],[]]
[StdGen.mk.inj,[And.intro],[And, Eq]]
[Sum.inl.inj,[],[Eq]]
[StateT.instMonadLiftStateT,[MonadLift.mk, StateT.lift],[MonadLift, StateT]]
[instMonadEIO,[inferInstanceAs, Monad, EStateM, IO.RealWorld],[Monad, EIO]]
[DoResultBC.noConfusionType,[],[]]
[Lean.Macro.resolveNamespace?,[Bind.bind, Lean.Macro.getMethods, Lean.Macro.Methods.resolveNamespace?],[Lean.MacroM, Option, Lean.Name]]
[String.Iterator.toString,[String],[String]]
[Nat.repeat.loop,[PProd.fst],[]]
[instMonadControlOptionT,[MonadControl.mk, Option, liftM, OptionT.run],[MonadControl, OptionT]]
[Eq.mpr_not,[Eq.symm],[Not]]
[List.replace,[List, List.nil, Unit.unit, BEq.beq, List.cons, PProd.fst],[List]]
[instModUInt32,[Mod.mk, UInt32.mod],[Mod, UInt32]]
[Div.div,[],[]]
[prioHigh,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Ord.compare,[],[Ordering]]
[IO.Process.Child.stdout,[],[IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdout]]
[UInt16.mul,[UInt16.mk, HMul.hMul, UInt16.val],[UInt16]]
[List.length_concat,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, List.length_cons, List.concat, Nat.succ, congrFun, HAdd.hAdd, OfNat.ofNat, eq_self, List.length],[Eq, List.length, List.concat, HAdd.hAdd, OfNat.ofNat]]
[List.foldlM,[Pure.pure, Bind.bind, PProd.fst],[]]
[Reader,[ReaderT, Id],[]]
[Array.anyM.loop.proof_1,[Nat.lt_of_lt_of_le],[LT.lt, Array.size]]
[Lean.Parser.Tactic.simpPost,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[List.forM_nil,[rfl],[Eq, ForM.forM, List.nil, Pure.pure, PUnit.unit]]
[Lean.Parser.Tactic.tacticShow_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[SeqLeft.seqLeft,[],[]]
[Lean.isNumericSubscript,[and, Decidable.decide, LE.le, OfNat.ofNat, Char.val],[Bool]]
[Nat.add_le_add_left,[LE.le, HAdd.hAdd, Nat.le.dest],[LE.le, HAdd.hAdd]]
[List.get.proof_1,[Nat.le_of_succ_le_succ, List.length_cons],[LE.le, Nat.succ, List.length]]
[Array.instBEqArray,[BEq.mk, Array.isEqv, BEq.beq],[BEq, Array]]
[Substring.toNat?,[ite, Eq, Substring.isNat, Bool.true, Option.some, Substring.foldl, HAdd.hAdd, HMul.hMul, OfNat.ofNat, HSub.hSub, Char.toNat, Char.ofNat, Option.none],[Option, Nat]]
[Char.utf8Size.proof_7,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[instInhabitedProd,[Inhabited.mk, Prod.mk, arbitrary],[Inhabited, Prod]]
[Lean.Parser.Tactic.Conv.paren,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.Conv.convSeq, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Quotient.mk,[Quot.mk, Setoid.r],[Quotient]]
[instMonadControlReaderT,[MonadControl.mk, id],[MonadControl, ReaderT]]
[Lean.Syntax.isNodeOf,[and, Lean.Syntax.isOfKind, BEq.beq, Lean.Syntax.getNumArgs],[Bool]]
[Fin.instDivFin,[Div.mk, Fin.div],[Div, Fin]]
[Append.append,[],[]]
[Array.mk.inj,[],[Eq]]
[instHashableList,[Hashable.mk, List.foldl, mixHash, Hashable.hash, OfNat.ofNat],[Hashable, List]]
[instHModUInt16NatUInt16,[HMod.mk, UInt16.modn],[HMod, UInt16, Nat]]
[«term∅»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Thunk.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Thunk.mk, OfNat.ofNat]]
[CoeFun.coe,[],[]]
[measure,[invImage, Nat.lt_wfRel],[WellFoundedRelation]]
[Fin.add,[Fin, Fin.mk, HMod.hMod, HAdd.hAdd, Fin.add.proof_1],[Fin]]
[instDivUSize,[Div.mk, USize.div],[Div, USize]]
[FloatArray.forIn.loop.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self],[LE.le, FloatArray.size]]
[Lean.Syntax.setTailInfo,[Unit.unit, Lean.Syntax, Lean.Syntax.setTailInfoAux],[Lean.Syntax]]
[Std.Format.tag.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.Format.tag, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.Format.tag, And]]
[PSigma.snd,[],[PSigma.fst]]
[instShiftRightUInt32,[ShiftRight.mk, UInt32.shiftRight],[ShiftRight, UInt32]]
[Array.foldl,[Id.run, Array.foldlM],[]]
[EmptyCollection.emptyCollection,[],[]]
[String.dropRightWhile,[Substring.toString, Substring.dropRightWhile, String.toSubstring],[String]]
[Char.utf8Size,[ite, LE.le, UInt32.ofNatCore, OfNat.ofNat, Char.utf8Size.proof_1, Char.utf8Size.proof_2, Char.utf8Size.proof_3, Char.utf8Size.proof_4, Char.utf8Size.proof_5, Char.utf8Size.proof_6, Char.utf8Size.proof_7],[UInt32]]
[List.firstM,[Unit.unit, Alternative.failure, HOrElse.hOrElse, PProd.fst],[]]
[Array.forInUnsafe.loop,[ite, LT.lt, Bind.bind, Pure.pure, Array.forInUnsafe.loop, HAdd.hAdd, OfNat.ofNat],[]]
[IO.FS.Stream.mk.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.Stream.mk, OfNat.ofNat]]
[instMonadControlStateRefT',[inferInstanceAs, MonadControl, ReaderT, ST.Ref],[MonadControl, StateRefT']]
[Array.set,[Array.mk, List.set, Array.data, Fin.val],[Array]]
[instMonadFinallyBaseIO,[inferInstanceAs, MonadFinally, EIO, Empty],[MonadFinally, BaseIO]]
[instAddUInt64,[Add.mk, UInt64.add],[Add, UInt64]]
[toBoolUsing,[Decidable.decide],[Bool]]
[List.hasDecidableLt,[Unit.unit, Decidable, LT.lt, Decidable.isFalse, List.hasDecidableLt.proof_1, Decidable.isTrue, List.lt.nil, List.hasDecidableLt.proof_2, List.cons, List.lt.head, List.hasDecidableLt.proof_3, PProd.fst, List.lt.tail, List.hasDecidableLt.proof_4],[Decidable, LT.lt]]
[ExceptT.bindCont,[Except, Pure.pure, Except.error],[Except]]
[ReaderT.run_seq,[Eq.mpr, Eq.refl, Eq, ReaderT.run, Seq.seq, seq_eq_bind, rfl],[Eq, ReaderT.run, Seq.seq]]
[Quotient.sound,[Quotient.sound.proof_1],[Eq, Quotient.mk]]
[Lean.Syntax.getOptionalIdent?,[Unit.unit, Option, Lean.Name, Lean.Syntax.getOptional?, Option.some, Lean.Syntax.getId, Option.none],[Option, Lean.Name]]
[ByteArray.foldlM.loop.proof_1,[Nat.lt_of_lt_of_le],[LT.lt, ByteArray.size]]
[ST.Prim.Ref.modifyGet,[Bind.bind, ST.Prim.Ref.get, ST, ST.Prim.Ref.set, Pure.pure],[ST]]
[Lean.termEval_prio_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Syntax.below,[PUnit, PProd],[]]
[instOrdUInt32,[Ord.mk, compareOfLessAndEq],[Ord, UInt32]]
[false_and,[propext, Iff.intro, And.left, False.elim],[Eq, And, False]]
[String.drop,[Substring.toString, Substring.drop, String.toSubstring],[String]]
[Ordering.isLE,[Unit.unit, Bool, Bool.true, Bool.false],[Bool]]
[IO.FS.instReprSystemTime,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, IO.FS.SystemTime.sec, Std.Format.line, IO.FS.SystemTime.nsec],[Repr, IO.FS.SystemTime]]
[instInhabitedEST,[inferInstanceAs, Inhabited, EStateM],[Inhabited, EST]]
[Bool.true.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Bool.true, OfNat.ofNat]]
[UInt64.lt,[LT.lt, UInt64.val],[]]
[GT.gt,[LT.lt],[]]
[Option.toMonad,[Unit.unit, Alternative.failure, Pure.pure],[]]
[Array.toSubarray,[dite, LE.le, Array.size, Subarray.mk, Nat.le_refl, Array.toSubarray.proof_1],[Subarray]]
[Lean.Syntax.expandInterpolatedStr,[Bind.bind, Lean.Syntax.expandInterpolatedStrChunks, Lean.Syntax.getArgs, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.MacroM, Lean.Syntax]]
[Option.instOrElseOption,[OrElse.mk, Option.orElse],[OrElse, Option]]
[Prod.fst,[],[]]
[IO.Process.Output.mk.inj,[And.intro],[And, Eq]]
[OptionT.lift,[OptionT.mk, Bind.bind, Pure.pure, Option.some],[OptionT]]
[ShiftRight.noConfusionType,[],[]]
[Nat.log2.proof_1,[],[WellFounded]]
[List.anyM,[Unit.unit, Bool, Pure.pure, Bool.false, Bind.bind, Bool.true, PProd.fst],[Bool]]
[instTransEq,[Trans.mk, instTransEq.proof_1],[Trans, Eq]]
[UInt8.xor,[UInt8.mk, Fin.xor, UInt8.val],[UInt8]]
[EStateM.instToStringResult,[ToString.mk, String, HAppend.hAppend, ToString.toString],[ToString, EStateM.Result]]
[Lean.Name.mkNum,[Lean.Name.num, mixHash, Hashable.hash, dite, LT.lt, UInt64.size, UInt64.ofNatCore, OfNat.ofNat, Lean.Name.mkNum.proof_1],[Lean.Name]]
[instDecidableEqUInt64,[UInt64.decEq],[DecidableEq, UInt64]]
[instHMul,[HMul.mk, Mul.mul],[HMul]]
[StateRefT'.run,[Bind.bind, ST.mkRef, ST.Ref.get, Pure.pure, Prod.mk],[Prod]]
[withPtrEqDecEq.proof_3,[ofBoolUsing_eq_false],[Not, Eq]]
[Nat.decEq.proof_1,[Eq.refl, Nat.beq],[Eq, Nat.beq]]
[inferInstanceAs,[],[]]
[IO.rand,[Bind.bind, ST.Ref.get, IO.stdGenRef, IO, Nat, ST.Ref.set, Pure.pure],[IO, Nat]]
[bfix3,[PProd.fst],[]]
[List.partition,[List.partitionAux, Prod.mk, List.nil],[Prod, List]]
[IO.ofExcept,[IO, Pure.pure, MonadExcept.throw, IO.userError, ToString.toString],[IO]]
[System.FilePath.exeExtension,[ite, Eq, System.Platform.isWindows, Bool.true],[String]]
[instMonadExceptOfExceptT_1,[MonadExceptOf.mk, ExceptT.mk, Pure.pure, Except.error, ExceptT.tryCatch],[MonadExceptOf, ExceptT]]
[IO.FS.instInhabitedSystemTime,[Inhabited.mk, IO.FS.SystemTime.mk, arbitrary],[Inhabited, IO.FS.SystemTime]]
[Lean.Parser.Tactic.rename,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[instLTFin,[LT.mk, LT.lt, Fin.val],[LT, Fin]]
[System.FilePath.withFileName,[Unit.unit, System.FilePath, System.FilePath.parent, System.FilePath.mk, HDiv.hDiv],[System.FilePath]]
[Seq.noConfusionType,[],[]]
[Nat.sub_le,[Nat.le_refl, HSub.hSub, OfNat.ofNat, Nat.le_trans, Nat.pred_le],[LE.le, HSub.hSub]]
[ST.Ref.take,[liftM, ST.Prim.Ref.take],[]]
[IO.Error.otherError.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.otherError, HAdd.hAdd, OfNat.ofNat]]
[LawfulApplicative.seqLeft_eq,[],[Eq, SeqLeft.seqLeft, Seq.seq, Functor.map, Function.const]]
[Fin.sub,[Fin, Fin.mk, HMod.hMod, HAdd.hAdd, HSub.hSub, Fin.sub.proof_1],[Fin]]
[String.isEmpty,[BEq.beq, String.bsize, OfNat.ofNat],[Bool]]
[List.hasDecEq.proof_2,[],[List.noConfusionType, False, List.cons, List.nil]]
[instReprNat,[Repr.mk, Std.Format.text, Nat.repr],[Repr, Nat]]
[FloatSpec.lt,[],[]]
[Function.Equiv.trans,[Eq.trans],[Function.Equiv]]
[«term_⊕_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[List.hasDecidableLt.proof_1,[Eq.refl, List.nil, HEq.refl, False],[False]]
[instDecidableIff.proof_3,[Iff.mpr],[False]]
[Char.eq_of_val_eq,[Eq.symm, eq_of_heq, Eq.refl, Char.val, Char.mk, HEq.refl, Eq, rfl],[Eq]]
[instStreamList,[Stream.mk, Unit.unit, Option, Prod, List, Option.none, Option.some, Prod.mk],[Stream, List]]
[PLift.down,[],[]]
[Id.run,[],[]]
[Nat.sub,[Nat, Nat.pred, PProd.fst],[Nat]]
[Subsingleton.elim.proof_1,[Subsingleton.allEq],[Eq]]
[IO.Process.SpawnArgs.cmd,[],[String]]
[Substring.next,[String.Pos, ite, Eq, HSub.hSub, String.next],[String.Pos]]
[Prod.rprod.proof_1,[Subrelation.wf, WellFoundedRelation.wf, Prod.lex, Prod.RProdSubLex],[WellFounded, Prod.RProd, WellFoundedRelation.rel]]
[ReaderT.instLawfulMonadReaderT,[ReaderT.instLawfulMonadReaderT.proof_1],[LawfulMonad, ReaderT]]
[precArg,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[coeM,[Bind.bind, Pure.pure, coe],[]]
[Lean.mkCIdentFromRef,[Bind.bind, Lean.MonadRef.getRef, Pure.pure, Lean.mkCIdentFrom],[Lean.Syntax]]
[heq_of_eq_of_heq,[HEq.trans, heq_of_eq],[HEq]]
[Lean.Parser.Tactic.Conv.convErw_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq],[Lean.ParserDescr]]
[dif_pos,[Eq, dite, rfl, absurd],[Eq, dite]]
[UInt8.div,[UInt8.mk, HDiv.hDiv, UInt8.val],[UInt8]]
[ExceptT.run_bind,[rfl],[Eq, ExceptT.run, Bind.bind, Except, Pure.pure, Except.error]]
[instMonadExcept,[MonadExcept.mk, throwThe, tryCatchThe],[MonadExcept]]
[IO.FS.Stream.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FS.Stream.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.FS.Stream.mk, And]]
[DoResultPRBC.continue.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultPRBC.continue, HAdd.hAdd, OfNat.ofNat]]
[tryFinally,[Functor.map, Prod.fst],[]]
[coeB,[Coe.coe],[]]
[Int.ofNat.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Int.ofNat, HAdd.hAdd, OfNat.ofNat]]
[Fin.val_ne_of_ne,[absurd, Fin.eq_of_val_eq],[Ne, Fin.val]]
[Array.foldrM,[dite, LE.le, Array.size, ite, LT.lt, Pure.pure, Nat.le_refl, Array.foldrM.fold],[]]
[not,[Unit.unit, Bool, Bool.false, Bool.true],[Bool]]
[IO.Error.interrupted.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.interrupted, HAdd.hAdd, OfNat.ofNat]]
[List.findM?,[Unit.unit, Option, Pure.pure, Option.none, Bind.bind, Option.some, PProd.fst],[Option]]
[Substring.toIterator,[String.Iterator, String.Iterator.mk],[String.Iterator]]
[ByteArray.uget,[UInt8, Array.uget],[UInt8]]
[List.length_reverse,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, List.length, List.reverse_cons, List.length_append, List.reverse, List.cons, List.nil, HAdd.hAdd, List.length_cons, Nat.succ, List.length_nil, eq_self, OfNat.ofNat],[Eq, List.length, List.reverse]]
[Array.feraseIdx,[Array.eraseIdxAux, HAdd.hAdd, Fin.val, OfNat.ofNat],[Array]]
[IO.FS.FileType.toCtorIdx,[OfNat.ofNat],[Nat]]
[instLTNat,[LT.mk, Nat.lt],[LT, Nat]]
[Setoid.iseqv,[],[Equivalence, Setoid.r]]
[FloatArray.foldlM.proof_1,[Nat.le_refl, FloatArray.size],[LE.le, FloatArray.size]]
[String.append,[String, String.mk, HAppend.hAppend],[String]]
[IO.Error.noConfusionType,[],[]]
[Nat.left_distrib,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Nat.zero, HAdd.hAdd, Nat.zero_mul, OfNat.ofNat, rfl, congr, congrArg, Eq.trans, Nat.succ_mul, congrFun, Nat.add_assoc, Nat.add_left_comm],[Eq, HMul.hMul, HAdd.hAdd]]
[Lean.Meta.Simp.instReprConfig,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, Lean.Meta.Simp.Config.maxSteps, Std.Format.line, Lean.Meta.Simp.Config.maxDischargeDepth, Lean.Meta.Simp.Config.contextual, Lean.Meta.Simp.Config.memoize, Lean.Meta.Simp.Config.singlePass, Lean.Meta.Simp.Config.zeta, Lean.Meta.Simp.Config.beta, Lean.Meta.Simp.Config.eta, Lean.Meta.Simp.Config.etaStruct, Lean.Meta.Simp.Config.iota, Lean.Meta.Simp.Config.proj, Lean.Meta.Simp.Config.decide],[Repr, Lean.Meta.Simp.Config]]
[Nat.pow_le_pow_of_le_left,[Unit.unit, LE.le, HPow.hPow, Nat.le_refl, OfNat.ofNat, Nat.mul_le_mul, PProd.fst],[LE.le, HPow.hPow]]
[Int.negSucc.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Int.negSucc, HAdd.hAdd, OfNat.ofNat]]
[Array.zip,[Array.zipWith, Prod.mk],[Array, Prod]]
[ToStream.toStream,[],[]]
[Classical.strongIndefiniteDescription.proof_1,[Subtype.property, Classical.indefiniteDescription],[Subtype.val, Classical.indefiniteDescription]]
[String.quote,[ite, Eq, String.isEmpty, Bool.true, HAppend.hAppend, String.foldl, Char.quoteCore],[String]]
[Subtype.instDecidableEqSubtype.proof_2,[absurd],[False]]
[EStateM.get,[EStateM.Result.ok],[EStateM]]
[ToString.noConfusionType,[],[]]
[UInt32.decEq.proof_1,[rfl],[Eq, UInt32.mk]]
[StateCpsT.runK_bind_lift,[rfl],[Eq, StateCpsT.runK, Bind.bind, StateCpsT.lift]]
[FloatArray.noConfusionType,[],[]]
[ExceptCpsT.runK,[],[]]
[Array.mapIdxM.map,[Array, Pure.pure],[Array]]
[Lean.Macro.instMonadRefMacroM,[Lean.MonadRef.mk, Bind.bind, MonadReader.read, Pure.pure, Lean.Macro.Context.ref, MonadWithReader.withReader, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth],[Lean.MonadRef, Lean.MacroM]]
[LawfulMonad.noConfusionType,[],[]]
[UInt32.decLt,[Decidable, LT.lt, inferInstanceAs],[Decidable, LT.lt]]
[Nat.gcd,[WellFounded.fix, Nat.gcd.proof_1, Unit.unit, Nat, HMod.hMod, Nat.succ, Nat.mod_lt, Nat.zero_lt_succ],[Nat]]
[coeHead,[CoeHead.coe],[]]
[Option.mapM,[Option.none, Option, Bind.bind, Pure.pure, Option.some],[Option]]
[Array.findSomeRevM?.find,[Option, Pure.pure, Option.none],[Option]]
[Squash.ind,[Quot.ind],[]]
[Lean.Parser.Tactic.first,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[instOrdUInt16,[Ord.mk, compareOfLessAndEq],[Ord, UInt16]]
[ne_true_of_not,[],[Ne, True]]
[Float.mk.inj,[],[Eq]]
[ExceptT.run_pure,[rfl],[Eq, ExceptT.run, Pure.pure, Except.ok]]
[withPtrEqDecEq,[Decidable, Eq, Eq.refl, Decidable.isTrue, withPtrEqDecEq.proof_2, Decidable.isFalse, withPtrEqDecEq.proof_3],[Decidable, Eq]]
[System.FilePath.isRelative,[not, System.FilePath.isAbsolute],[Bool]]
[MonadExceptOf.tryCatch,[],[]]
[coeOfHead,[CoeHTCT.mk, coeHead],[CoeHTCT]]
[instMulUInt16,[Mul.mk, UInt16.mul],[Mul, UInt16]]
[MonadStateOf.modifyGet,[],[]]
[Lean.Parser.Tactic.«tactic_<;>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Nat.le.dest,[Exists, Eq, HAdd.hAdd, Exists.intro, OfNat.ofNat, rfl, Nat.succ, Eq.symm, Nat.add_comm, absurd, Nat.not_succ_le_zero],[Exists, Eq, HAdd.hAdd]]
[HEq.subst,[HEq.ndrecOn],[]]
[Array.size_pop,[List.length_dropLast, Array.data],[Eq, Array.size, Array.pop, HSub.hSub, OfNat.ofNat]]
[Array.contains,[Array.any, BEq.beq, OfNat.ofNat, Array.size],[Bool]]
[StdGen.noConfusionType,[],[]]
[instMonadLiftT,[MonadLiftT.mk, MonadLift.monadLift, MonadLiftT.monadLift],[MonadLiftT]]
[IO.Error.invalidArgument.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.invalidArgument, HAdd.hAdd, OfNat.ofNat]]
[ReaderT.failure,[Alternative.failure],[ReaderT]]
[instSubUInt64,[Sub.mk, UInt64.sub],[Sub, UInt64]]
[String.contains,[String.any, BEq.beq],[Bool]]
[UInt64.decEq.proof_2,[absurd],[False]]
[Substring.trimLeft,[Substring.dropWhile, Char.isWhitespace],[Substring]]
[Applicative.toFunctor,[],[Functor]]
[panic,[panicCore],[]]
[Lean.Parser.Tactic.Conv.convArgs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Fin.mk.injEq,[Eq.propIntro, Eq.refl, Fin.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Fin.mk]]
[Subarray.popFront,[dite, LT.lt, Subarray.start, Subarray.stop, Subarray.mk, Subarray.as, HAdd.hAdd, OfNat.ofNat, Subarray.popFront.proof_1, Subarray.h₂],[Subarray]]
[instMonadFunctorT,[MonadFunctorT.mk, MonadFunctor.monadMap, MonadFunctorT.monadMap],[MonadFunctorT]]
[Acc.ndrec,[],[]]
[PSigma.lexNdepWf,[PSigma.lexNdepWf.proof_1],[WellFounded, PSigma.lexNdep]]
[congr,[rfl],[Eq]]
[PSigma.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, PSigma.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.split,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.Parser.Tactic.intro,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Id,[],[]]
[CoeT.coe,[],[]]
[Std.Format.joinSep,[List.cons, Std.Format, Std.Format.nil, Std.ToFormat.format, HAppend.hAppend, PProd.fst],[Std.Format]]
[Eq.substr,[Eq.symm],[]]
[ST.Ref.get,[liftM, ST.Prim.Ref.get],[]]
[IO.Error.resourceExhausted.inj,[And.intro],[And, Eq]]
[List.getLast!.proof_1,[],[List.noConfusionType, False, List.cons, List.nil]]
[Array.insertAt,[ite, GT.gt, Array.size, panicWithPosWithDecl, OfNat.ofNat, Array.insertAtAux],[Array]]
[ite_true,[rfl],[Eq, ite, True]]
[Inhabited.noConfusionType,[],[]]
[Trans.noConfusionType,[],[]]
[Lean.Name.noConfusionType,[],[]]
[List.get!,[Nat.zero, List.nil, Nat.succ, PProd.fst, panicWithPosWithDecl, OfNat.ofNat],[]]
[stdNext,[Prod, Nat, StdGen, Prod.mk, Int.toNat, StdGen.mk],[Prod, Nat, StdGen]]
[Lean.Name.escapePart,[ite, Eq, and, Decidable.decide, GT.gt, String.length, OfNat.ofNat, Lean.isIdFirst, String.getOp, Substring.all, Substring.drop, String.toSubstring, Lean.isIdRest, Bool.true, Option.some, String.any, Lean.isIdEndEscape, Option.none, HAppend.hAppend, Char.toString, Lean.idBeginEscape, Lean.idEndEscape],[Option, String]]
[MonadReader.noConfusionType,[],[]]
[CoeSort.coe,[],[]]
[List.instListDecidableLe,[inferInstanceAs, Decidable, Not, LT.lt],[Decidable, LE.le]]
[Fin.instSubFin,[Sub.mk, Fin.sub],[Sub, Fin]]
[Lean.expandBrackedBindersAux.loop,[Unit.unit, Lean.MacroM, Lean.Syntax, Pure.pure, Bind.bind, Lean.expandExplicitBindersAux, Option.some, PProd.fst],[Lean.MacroM, Lean.Syntax]]
[ULift.noConfusionType,[],[]]
[«term_<$>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Subtype.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Subtype.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.sub_zero,[rfl],[Eq, HSub.hSub, OfNat.ofNat]]
[instLTProd,[LT.mk, Or, LT.lt, Prod.fst, And, Eq, Prod.snd],[LT, Prod]]
[MProd.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, MProd.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, MProd.mk, And]]
[eq_true_of_ne_false,[Eq, Bool.true, rfl, False.elim],[Eq, Bool.true]]
[Char.isValidChar_of_isValidChar_Nat,[isValidChar, UInt32.ofNat', Char.isValidUInt32, Or.inl, Or.inr, And.intro],[isValidChar, UInt32.ofNat', Char.isValidUInt32]]
[Complement.complement,[],[]]
[Std.Format.join,[List.foldl, HAppend.hAppend, Std.Format.text],[Std.Format]]
[ST.Ref.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, ST.Ref.mk, HAdd.hAdd, OfNat.ofNat]]
[«term_<<<_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[IO.Error.alreadyExists.inj,[And.intro],[And, Eq]]
[Int.neg,[Int, Int.negOfNat, Int.ofNat, Nat.succ],[Int]]
[Std.Format.nestD,[Std.Format.nest, Int.ofNat, Std.Format.defIndent],[Std.Format]]
[ByteArray.foldlM.proof_1,[Nat.le_refl, ByteArray.size],[LE.le, ByteArray.size]]
[bind_pure,[],[Eq, Bind.bind, Pure.pure]]
[UInt16.add,[UInt16.mk, HAdd.hAdd, UInt16.val],[UInt16]]
[IO.Error.userError.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.userError, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.focus,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[IO.Error.noSuchThing.inj,[And.intro],[And, Eq]]
[Lean.Meta.instBEqTransparencyMode,[BEq.mk, BEq.beq, Lean.Meta.TransparencyMode.toCtorIdx],[BEq, Lean.Meta.TransparencyMode]]
[Lean.Parser.Tactic.tacticInfer_instance,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[IO.println,[IO.print, String.push, ToString.toString, Char.ofNat],[IO, Unit]]
[DoResultPR.noConfusionType,[],[]]
[unsafeIO,[unsafeEIO],[Except, IO.Error]]
[UInt32.toUInt64,[Nat.toUInt64, UInt32.toNat],[UInt64]]
[Array.findSome!,[Unit.unit, Array.findSome?, panicWithPosWithDecl, OfNat.ofNat],[]]
[IO.Error.mkUnsupportedOperation,[IO.Error.unsupportedOperation],[IO.Error]]
[Lean.instMonadRef,[Lean.MonadRef.mk, liftM, Lean.MonadRef.getRef, MonadFunctorT.monadMap, Lean.MonadRef.withRef],[Lean.MonadRef]]
[instToFormat,[Std.ToFormat.mk, Function.comp, Std.Format.text, ToString.toString],[Std.ToFormat]]
[Acc.inv,[Acc.inv.proof_1],[Acc]]
[Int.sub,[HAdd.hAdd, Neg.neg],[Int]]
[instLEFloat,[LE.mk, Float.le],[LE, Float]]
[StateRefT'.get,[ST.Ref.get],[StateRefT']]
[IO.FS.SystemTime.noConfusionType,[],[]]
[usize_size_gt_zero,[Nat.pos_pow_of_pos, System.Platform.numBits, Nat.zero_lt_succ, OfNat.ofNat],[GT.gt, USize.size, OfNat.ofNat]]
[Std.Range.forM,[Std.Range.stop, Std.Range.start, Std.Range.forM.loop],[PUnit]]
[String.decEq.proof_1,[congrArg, String.mk],[Eq, String.mk]]
[Std.Range.forIn,[Std.Range.stop, Std.Range.start, Std.Range.forIn.loop],[]]
[ST.instInhabitedRef,[Inhabited.mk, ST.Ref.mk, PointedType.val, ST.RefPointed, ST.instInhabitedRef.proof_1],[Inhabited, ST.Ref]]
[instSubsingletonSquash.proof_1,[Subsingleton.intro, Squash.ind, Quot.sound, True.intro],[Subsingleton, Squash]]
[«term_\/_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Monad.toApplicative,[],[Applicative]]
[List.enumFrom,[List, Prod, Nat, List.nil, List.cons, Prod.mk, PProd.fst, HAdd.hAdd, OfNat.ofNat],[List, Prod, Nat]]
[IO.withStdin,[Bind.bind, liftM, IO.setStdin, tryFinally, Functor.discard],[]]
[List.length_nil,[rfl],[Eq, List.length, List.nil, OfNat.ofNat]]
[Lean.evalPrio,[Lean.Macro.withIncRecDepth, Bind.bind, Lean.expandMacros, cond, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Option.getD, Lean.Syntax.isNatLit?, OfNat.ofNat, Lean.Macro.throwErrorAt],[Lean.MacroM, Nat]]
[FloatSpec.decLt,[],[DecidableRel, FloatSpec.lt]]
[ExceptT.ext,[id],[Eq]]
[List.head!,[Unit.unit, panicWithPosWithDecl, OfNat.ofNat],[]]
[List.append_eq_appendTR,[funext, rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, List.cons, List.reverseAux_reverseAux, List.nil, eq_self, List.reverseAux],[Eq, List.append, List.appendTR]]
[BaseIO,[EIO, Empty],[]]
[List.le,[Not, LT.lt],[]]
[Lean.version.patch,[Unit.unit],[Nat]]
[PSigma.SkipLeft,[PSigma.RevLex, emptyRelation],[]]
[Functor.mapRev,[Functor.map],[]]
[instLTUInt64,[LT.mk, UInt64.lt],[LT, UInt64]]
[ToStream.noConfusionType,[],[]]
[Add.add,[],[]]
[Fin.ne_of_val_ne,[absurd, Fin.val_eq_of_eq],[Not, Eq]]
[StdGen.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, StdGen.mk, HAdd.hAdd, OfNat.ofNat]]
[ST.Ref.swap,[liftM, ST.Prim.Ref.swap],[]]
[String.Iterator.toEnd,[String.Iterator, String.Iterator.mk, String.bsize],[String.Iterator]]
[Nat.mul_comm,[Eq, HMul.hMul, rfl, Eq.symm, Nat.mul_zero, Nat.zero_mul, PProd.fst, Nat.succ_mul, Nat.mul_succ],[Eq, HMul.hMul]]
[instReprIterator,[Repr.mk, Std.Format, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg],[Repr, String.Iterator]]
[instReprSum,[Repr.mk, Std.Format, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg],[Repr, Sum]]
[instToStreamArraySubarray,[ToStream.mk, Array.toSubarray, OfNat.ofNat, Array.size],[ToStream, Array, Subarray]]
[List.appendTR,[List.reverseAux, List.reverse],[List]]
[instDecidableIff,[dite, Decidable.isTrue, instDecidableIff.proof_1, Decidable.isFalse, instDecidableIff.proof_2, instDecidableIff.proof_3, instDecidableIff.proof_4],[Decidable, Iff]]
[Nat.one_mul,[Nat.mul_one, Nat.mul_comm, OfNat.ofNat],[Eq, HMul.hMul, OfNat.ofNat]]
[instAndOpUInt64,[AndOp.mk, UInt64.land],[AndOp, UInt64]]
[String.take,[Substring.toString, Substring.take, String.toSubstring],[String]]
[Classical.inhabited_of_exists.proof_1,[Exists.elim, Nonempty.intro],[Nonempty]]
[Nat.toUInt16,[UInt16.ofNat],[UInt16]]
[Nat.anyM.loop,[Unit.unit, Bool, Pure.pure, Bool.false, Bind.bind, HSub.hSub, OfNat.ofNat, Bool.true, PProd.fst],[Bool]]
[coeOfTCOfTail,[CoeHTCT.mk, coeTail, coeTC],[CoeHTCT]]
[Classical.epsilon_singleton,[Classical.epsilon_spec, Exists.intro, rfl],[Eq, Classical.epsilon]]
[Lean.Macro.Context.maxRecDepth,[],[Nat]]
[instReprString,[Repr.mk, Std.Format.text, String.quote],[Repr, String]]
[ST.Prim.Ref.modify,[Bind.bind, ST.Prim.Ref.get, ST.Prim.Ref.set],[ST, Unit]]
[Char.ofNat,[dite, Nat.isValidChar, Char.mk, UInt32.mk, Fin.mk, LT.lt, UInt32.size, Nat.lt_trans, of_decide_eq_true, Eq.refl, Bool.true, OfNat.ofNat, Char.ofNat.proof_1, Char.ofNat.proof_2],[Char]]
[Lean.Parser.Tactic.renameI,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Subrelation.accessible.proof_1,[Acc.intro],[Acc]]
[termMax_prec,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.instQuoteProd,[Lean.Quote.mk, Lean.Syntax, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Quote.quote, List.nil],[Lean.Quote, Prod]]
[Nat.add_eq,[rfl],[Eq, Nat.add, HAdd.hAdd]]
[instInhabitedTrue,[Inhabited.mk, True.intro],[Inhabited, True]]
[Array.binSearchContains,[ite, LT.lt, Array.size, Array.binSearchAux, Option.isSome, Bool.false],[Bool]]
[heq_of_eq,[Eq.subst, HEq.refl],[HEq]]
[UInt64.decLe,[Decidable, LE.le, inferInstanceAs],[Decidable, LE.le]]
[List.removeAll,[List.filter, List.notElem],[List]]
[let_val_congr,[rfl],[Eq]]
[List.zipWith,[List.nil, List.cons, List, PProd.fst],[List]]
[String.mkIterator,[String.Iterator.mk, OfNat.ofNat],[String.Iterator]]
[Array.mapMUnsafe.map,[ite, LT.lt, Bind.bind, unsafeCast, Array.mapMUnsafe.map, HAdd.hAdd, OfNat.ofNat, Array.uset, lcProof, Pure.pure],[Array, PNonScalar]]
[Int.decEq.proof_3,[rfl],[Eq, Int.negSucc]]
[IO.Error.noSuchThing.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.noSuchThing, HAdd.hAdd, OfNat.ofNat]]
[Seq.seq,[],[]]
[«term_≤_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[dbgTrace,[Unit.unit],[]]
[IO.Error.mkResourceExhausted,[IO.Error.resourceExhausted, Option.none],[IO.Error]]
[ByteArray.mkEmpty,[ByteArray.mk, List.toArray, List.nil],[ByteArray]]
[List.all,[List.foldr, and, Bool.true],[Bool]]
[«term_×'_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.bracketedExplicitBinders, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Prod.map,[Prod, Prod.mk],[Prod]]
[IO.Error.invalidArgument.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.invalidArgument, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.invalidArgument, And]]
[Classical.em,[],[Or, Not]]
[instDecidableEqSum.proof_2,[absurd],[False]]
[Lean.Meta.Simp.Config.singlePass,[],[Bool]]
[List.pure,[List.cons, List.nil],[List]]
[Option.eq_of_eq_some,[Eq, rfl, Iff.mpr, Iff.mp, congrArg, Option.some],[Eq]]
[Lean.Parser.Tactic.clear,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Array.push,[Array.mk, List.concat, Array.data],[Array]]
[Mod.mod,[],[]]
[List.filterM,[Bind.bind, List.filterAuxM, List.nil, Pure.pure, List.reverse],[List]]
[instCoeDep,[CoeDep.mk, coeFun],[CoeDep]]
[Array.binSearch,[ite, LT.lt, Array.size, Array.binSearchAux, id, Option.none],[Option]]
[Lean.Parser.Tactic.expandRwSeq,[Lean.Parser.Tactic.rwWithRfl, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Macro]]
[TC.wf,[TC.wf.proof_1],[WellFounded, TC]]
[Nat.zero_mul,[Unit.unit, Eq, HMul.hMul, OfNat.ofNat, rfl, Eq.symm, PProd.fst, Nat.mul_succ],[Eq, HMul.hMul, OfNat.ofNat]]
[String.instLTString,[LT.mk, LT.lt, String.data],[LT, String]]
[Lean.Syntax.instToFormatSyntax,[Std.ToFormat.mk, Lean.Syntax.formatStx, Option.none, Bool.false],[Std.ToFormat, Lean.Syntax]]
[Int.decEq.proof_1,[rfl],[Eq, Int.ofNat]]
[UInt64.decLt,[Decidable, LT.lt, inferInstanceAs],[Decidable, LT.lt]]
[instToStringUInt16,[ToString.mk, ToString.toString, UInt16.toNat],[ToString, UInt16]]
[PSigma.lexNdepWf.proof_1,[WellFounded.intro, Acc, PSigma.lexNdep, PSigma.lexAccessible, WellFounded.apply],[WellFounded, PSigma.lexNdep]]
[instInhabited,[Inhabited.mk, Pure.pure, arbitrary],[Inhabited]]
[List.reverse_append,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.reverse, List.nil_append, HAppend.hAppend, List.reverse_nil, List.append_nil, eq_self, Eq.mpr, List.cons_append, List.reverse_cons, congrFun, List.cons, List.nil, Eq.refl, List.append_assoc, rfl],[Eq, List.reverse, HAppend.hAppend]]
[instMonadExceptOfEST,[inferInstanceAs, MonadExceptOf, EStateM],[MonadExceptOf, EST]]
[Nat.mod_eq_sub_mod,[Eq, HMod.hMod, HSub.hSub, Nat.eq_zero_or_pos, rfl, Eq.symm, Nat.sub_zero, if_pos, And.intro, Nat.mod_eq],[Eq, HMod.hMod, HSub.hSub]]
[instOfNatUInt16,[OfNat.mk, UInt16.ofNat],[OfNat, UInt16]]
[ByteArray.foldlM.loop,[dite, LT.lt, Unit.unit, Pure.pure, Bind.bind, ByteArray.get, Fin.mk, ByteArray.foldlM.loop.proof_1, PProd.fst, HAdd.hAdd, OfNat.ofNat],[]]
[ByteArray.instAppendByteArray,[Append.mk, ByteArray.append],[Append, ByteArray]]
[Nat.succ_le_succ,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, LE.le, Nat.succ, Nat.le.refl, Nat.le.step, PProd.fst],[LE.le, Nat.succ]]
[Lean.Parser.Tactic.revert,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[TC.accessible,[TC.accessible.proof_1],[Acc, TC]]
[Task.bind,[Task.pure, Task.get],[Task]]
[Lean.Macro,[Lean.MacroM, Lean.Syntax],[]]
[«term_%_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.defaultMaxRecDepth,[OfNat.ofNat],[Nat]]
[Nat.toSuperDigits,[Nat.toSuperDigitsAux, List.nil],[List, Char]]
[USize.add,[USize.mk, HAdd.hAdd, USize.val],[USize]]
[congrArg,[rfl],[Eq]]
[Std.Range.noConfusionType,[],[]]
[Nat.lt_or_eq_or_le_succ,[Decidable.byCases, Or.inr],[Or, LE.le, Eq, Nat.succ]]
[Lean.NameGenerator.namePrefix,[],[Lean.Name]]
[Lean.Parser.Tactic.Conv.convSkip,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[List.take,[List, List.nil, List.cons, PProd.fst],[List]]
[Nat.any,[Nat.anyAux],[Bool]]
[term!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[implies_true,[propext, Iff.intro, trivial, True.intro],[Eq, True]]
[IO.FileRight.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FileRight.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.FileRight.mk, And]]
[FloatSpec.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, FloatSpec.mk, HAdd.hAdd, OfNat.ofNat]]
[instInhabitedExcept,[Inhabited.mk, Except.error, arbitrary],[Inhabited, Except]]
[Except.toOption,[Option, Option.some, Option.none],[Option]]
[liftExcept,[Pure.pure, MonadExcept.throw],[]]
[coeOfTail,[CoeHTCT.mk, coeTail],[CoeHTCT]]
[Fin.instOrOpFin,[OrOp.mk, Fin.lor],[OrOp, Fin]]
[CoeTail.noConfusionType,[],[]]
[StateCpsT.instMonadStateOfStateCpsT,[MonadStateOf.mk, PUnit.unit],[MonadStateOf, StateCpsT]]
[Lean.instQuoteName,[Lean.Quote.mk, Unit.unit, Lean.Syntax, OptionM, List, String, Pure.pure, Bind.bind, Lean.Name.escapePart, PProd.fst, List.cons, Option.none, List.nil, Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, Lean.Syntax.mkNameLit, HAppend.hAppend, String.intercalate, Lean.SourceInfo.none, Lean.mkCIdent, Lean.Syntax.mkCApp, Lean.Quote.quote],[Lean.Quote, Lean.Name]]
[Function.Equiv.refl,[rfl],[Function.Equiv]]
[List.bind,[List.join, List.map],[List]]
[Lean.bracketedExplicitBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.binderIdent, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[Nat.mul_le_mul_left,[LE.le, HMul.hMul, Nat.le.dest],[LE.le, HMul.hMul]]
[UInt32.modn,[UInt32.mk, HMod.hMod, UInt32.val],[UInt32]]
[ExceptT.instMonadLiftExceptExceptT,[MonadLift.mk, ExceptT.mk, Pure.pure],[MonadLift, Except, ExceptT]]
[OptionT.instMonadFunctorOptionT,[MonadFunctor.mk, Option],[MonadFunctor, OptionT]]
[List.init,[Unit.unit, List.cons, List, List.nil, PProd.fst],[List]]
[USize.xor,[USize.mk, Fin.xor, USize.val],[USize]]
[andM,[Bind.bind, Unit.unit, ToBool.toBool, Pure.pure],[]]
[Lean.Syntax.isIdOrAtom?,[Lean.Syntax.missing, Lean.Syntax.node, Option, String, Option.some, Substring.toString, Option.none],[Option, String]]
[StateRefT'.instMonadStateRefT',[inferInstanceAs, Monad, ReaderT, ST.Ref],[Monad, StateRefT']]
[iff_iff_implies_and_implies,[Iff.intro, And.intro, Iff.mp, Iff.mpr, And.left, And.right],[Iff, And]]
[Array.forIn,[Array.size, Nat.le_refl, Array.forIn.loop],[]]
[Sigma.fst,[],[]]
[instAndOpUSize,[AndOp.mk, USize.land],[AndOp, USize]]
[Int.repr,[String, Nat.repr, HAppend.hAppend, Nat.succ],[String]]
[Array.filterSepElems,[Id.run, Array.filterSepElemsM],[Array, Lean.Syntax]]
[Iff.mpr,[],[]]
[List.takeWhile,[Unit.unit, List, List.nil, List.cons, PProd.fst],[List]]
[HOr.noConfusionType,[],[]]
[IO.instMonadLiftSTRealWorldBaseIO,[MonadLift.mk, id],[MonadLift, ST, IO.RealWorld, BaseIO]]
[not_not_intro,[],[Not]]
[Task.Priority,[Nat],[]]
[List.range,[List.rangeAux, List.nil],[List, Nat]]
[UInt8.decLt,[Decidable, LT.lt, inferInstanceAs],[Decidable, LT.lt]]
[«term_≈_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Iff.refl,[Iff.intro],[Iff]]
[«term_⊕'_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Std.Format.sbracket,[Std.Format.bracket],[Std.Format]]
[Std.Format.nest.inj,[And.intro],[And, Eq]]
[Task.Priority.default,[OfNat.ofNat],[Task.Priority]]
[DoResultPRBC.return.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultPRBC.return, HAdd.hAdd, OfNat.ofNat]]
[Array.pop,[Array.mk, List.dropLast, Array.data],[Array]]
[ExceptCpsT.runCatch_lift,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, bind_pure, eq_self],[Eq, ExceptCpsT.runCatch, ExceptCpsT.lift]]
[ExceptT.tryCatch,[ExceptT.mk, Bind.bind, Except, Pure.pure, Except.ok],[ExceptT]]
[Equivalence.noConfusionType,[],[]]
[Nat.succ.injEq,[Eq.propIntro, Eq.refl, Nat.succ, Eq.symm, eq_of_heq, HEq.refl],[Eq, Nat.succ]]
[instReprAtomUInt16,[ReprAtom.mk],[ReprAtom, UInt16]]
[Array.uset,[Array.set, Fin.mk, USize.toNat],[Array]]
[Lean.Syntax.getHeadInfo,[Unit.unit, Lean.SourceInfo, Lean.Syntax.getHeadInfo?, Lean.SourceInfo.none],[Lean.SourceInfo]]
[IO.Process.Child.noConfusionType,[],[]]
[Std.Range.instForMRangeNat,[ForM.mk, Std.Range.forM],[ForM, Std.Range, Nat]]
[bne,[not, BEq.beq],[Bool]]
[Std.termF!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Option.get!,[Unit.unit, panicWithPosWithDecl, OfNat.ofNat],[]]
[Function.const_apply,[rfl],[Eq, Function.const]]
[reprStr,[Std.Format.pretty, Repr.reprPrec, OfNat.ofNat, Std.Format.defWidth],[String]]
[UInt16.shiftRight,[UInt16.mk, HShiftRight.hShiftRight, UInt16.val, UInt16.modn, OfNat.ofNat],[UInt16]]
[Fin.xor,[Fin, Fin.mk, HMod.hMod, Nat.xor, Fin.xor.proof_1],[Fin]]
[Int.mul,[Int, Int.ofNat, HMul.hMul, Int.negOfNat, Nat.succ],[Int]]
[String.modify,[String.set, String.get],[String]]
[StateT.modifyGet,[Pure.pure],[StateT]]
[Lean.Syntax.instBEqSyntax,[BEq.mk, Lean.Syntax.structEq],[BEq, Lean.Syntax]]
[PProd.mk.inj,[And.intro],[And, Eq]]
[Fin.modn.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod]]
[Subsingleton.helim.proof_1,[heq_of_eq, Subsingleton.elim],[HEq]]
[ByteArray.size,[Nat, Array.size],[Nat]]
[CoeDep.coe,[],[]]
[Lean.termThis,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[DoResultBC.continue.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultBC.continue, HAdd.hAdd, OfNat.ofNat]]
[Bool.or_true,[rfl, Eq.symm, Eq.refl],[Eq, or, Bool.true]]
[Complement.noConfusionType,[],[]]
[Lean.Parser.Tactic.done,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[String.dropWhile,[Substring.toString, Substring.dropWhile, String.toSubstring],[String]]
[Functor.map,[],[]]
[Setoid.noConfusionType,[],[]]
[EStateM.Result.error.injEq,[Eq.propIntro, And.intro, Eq.refl, EStateM.Result.error, Eq.symm, eq_of_heq, HEq.refl],[Eq, EStateM.Result.error, And]]
[Std.Format.group.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.Format.group, HAdd.hAdd, OfNat.ofNat]]
[WellFoundedRelation.mk.injEq,[Eq.propIntro, Eq.refl, WellFoundedRelation.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, WellFoundedRelation.mk]]
[instDecidableLt_2,[UInt16.decLt],[Decidable, LT.lt]]
[Applicative.noConfusionType,[],[]]
[Array.concatMap,[Array.foldl, HAppend.hAppend, Array.empty, OfNat.ofNat, Array.size],[Array]]
[Fin.eq_of_val_eq,[Eq.symm, eq_of_heq, Eq.refl, Fin.val, Fin.mk, HEq.refl, Eq, rfl],[Eq]]
[instNonempty,[instNonempty.proof_1],[Nonempty]]
[StateT.run_seq,[],[Eq, StateT.run, Seq.seq, Bind.bind, Functor.map, Prod.mk, Prod.fst, Prod.snd]]
[Classical.typeDecidableEq,[inferInstance],[DecidableEq]]
[Array.foldr,[Id.run, Array.foldrM],[]]
[IO.Error.mkInvalidArgumentFile,[Function.comp, IO.Error.invalidArgument, Option.some],[IO.Error]]
[Lean.scientificLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Lean.withRef,[Bind.bind, Lean.MonadRef.getRef, Lean.MonadRef.withRef],[]]
[USize.mul,[USize.mk, HMul.hMul, USize.val],[USize]]
[Prod.noConfusionType,[],[]]
[instMonadLiftSTEST,[MonadLift.mk, EStateM.Result, EStateM.Result.ok],[MonadLift, ST, EST]]
[Int.decLe,[Decidable, Int.NonNeg, Decidable.isTrue, Int.NonNeg.mk, Decidable.isFalse, Eq.refl, Int.negSucc, HEq.refl, False, HSub.hSub],[Decidable, LE.le]]
[IO.Error.alreadyExists.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.alreadyExists, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.alreadyExists, And]]
[IO.Error.mkIllegalOperation,[IO.Error.illegalOperation],[IO.Error]]
[Nat.ble_self_eq_true,[Unit.unit, Eq, Nat.ble, Bool.true, rfl, PProd.fst],[Eq, Nat.ble, Bool.true]]
[instToFormatProd,[Std.ToFormat.mk, Std.Format, Std.Format.paren, HAppend.hAppend, Std.ToFormat.format, Std.Format.text, Std.Format.line],[Std.ToFormat, Prod]]
[Nat.foldM.loop,[Pure.pure, Bind.bind, HSub.hSub, OfNat.ofNat, PProd.fst],[]]
[EStateM.tryCatch,[EStateM.Result.ok, EStateM.Result, EStateM.Backtrackable.restore],[EStateM]]
[String.toSubstring,[Substring.mk, OfNat.ofNat, String.bsize],[Substring]]
[Std.Format.FlattenBehavior.toCtorIdx,[OfNat.ofNat],[Nat]]
[isValidChar,[Or, LT.lt, OfNat.ofNat, And],[]]
[Subarray.forRevM,[Array.forRevM, Subarray.as, Subarray.stop, Subarray.start],[PUnit]]
[forall_congr,[],[Eq]]
[Nat.mul_le_mul,[Nat.le_trans, Nat.mul_le_mul_right, Nat.mul_le_mul_left],[LE.le, HMul.hMul]]
[stdSplit,[StdGen.mk, Prod, StdGen, Prod.mk],[Prod, StdGen]]
[instAddNat,[Add.mk, Nat.add],[Add, Nat]]
[IO.instInhabitedError,[Inhabited.mk, IO.Error.alreadyExists, arbitrary],[Inhabited, IO.Error]]
[List.hasDecEq.proof_5,[absurd],[False]]
[Lean.instInhabitedMacroScopesView,[Inhabited.mk, Lean.MacroScopesView.mk, arbitrary],[Inhabited, Lean.MacroScopesView]]
[IO.Error.resourceVanished.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.resourceVanished, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.resourceVanished, And]]
[List.join,[Unit.unit, List, List.nil, HAppend.hAppend, PProd.fst],[List]]
[«term_×__1»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.bracketedExplicitBinders, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[HAnd.noConfusionType,[],[]]
[List.hasDecEq.proof_1,[rfl],[Eq, List.nil]]
[DoResultPRBC.pure.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultPRBC.pure, HAdd.hAdd, OfNat.ofNat]]
[Array.modifyM,[dite, LT.lt, Array.size, Bind.bind, Pure.pure, Array.set, Array.modifyM.proof_1],[Array]]
[Lean.mkNode,[Lean.Syntax.node, Lean.SourceInfo.none],[Lean.Syntax]]
[coeOfHTCT,[CoeT.mk, CoeHTCT.coe],[CoeT]]
[ReaderT.instMonadReaderT,[Monad.mk],[Monad, ReaderT]]
[Std.Format.indentD,[Std.Format.nestD, HAppend.hAppend, Std.Format.line],[Std.Format]]
[ExceptT.map,[ExceptT.mk, Bind.bind, Except, Pure.pure, Except.ok, Except.error],[ExceptT]]
[instInhabitedReaderT,[Inhabited.mk, arbitrary],[Inhabited, ReaderT]]
[Char.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Char.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Syntax.matchesIdent,[and, Lean.Syntax.isIdent, BEq.beq, Lean.Syntax.getId],[Bool]]
[Lean.Macro.Context.ref,[],[Lean.Syntax]]
[EStateM.modifyGet,[EStateM.Result, EStateM.Result.ok],[EStateM]]
[Std.Format.MonadPrettyFormat.noConfusionType,[],[]]
[«stx_+»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[Classical.typeDecidable,[PSum, False, Classical.propDecidable, Nonempty, PSum.inl, arbitrary, PSum.inr, Classical.typeDecidable.proof_1],[PSum, False]]
[Int.instNegInt,[Neg.mk, Int.neg],[Neg, Int]]
[panicWithPos,[panic, HAppend.hAppend, ToString.toString],[]]
[Lean.Parser.Tactic.Conv.«convEnter[__]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.ParserDescr.const, Lean.Parser.Tactic.Conv.enterArg],[Lean.ParserDescr]]
[Stream.next?,[],[Option, Prod]]
[System.FilePath.pathExists,[Bind.bind, EIO.toBaseIO, System.FilePath.metadata, Pure.pure, Except.toBool],[BaseIO, Bool]]
[Lean.Module.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Module.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Module.mk, And]]
[Except.ok.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Except.ok, HAdd.hAdd, OfNat.ofNat]]
[bool,[Unit.unit, ToBool.toBool],[]]
[String.endsWith,[BEq.beq, Substring.takeRight, String.toSubstring, String.length],[Bool]]
[HAnd.hAnd,[],[]]
[Array.swap,[Array.set, Array.swap.proof_1],[Array]]
[List.length_cons,[rfl],[Eq, List.length, List.cons, Nat.succ]]
[CoeHTCT.noConfusionType,[],[]]
[instLEUInt8,[LE.mk, UInt8.le],[LE, UInt8]]
[Nat.le_refl,[Nat.le.refl],[LE.le]]
[Lean.expandExplicitBindersAux.loop,[Unit.unit, Lean.MacroM, Lean.Syntax, Pure.pure, Lean.Syntax.isIdent, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.MacroM, Lean.Syntax]]
[Std.Format.paren,[Std.Format.bracket],[Std.Format]]
[Lean.Parser.Tactic.locationHyp,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[OptionT.fail,[OptionT.mk, Pure.pure, Option.none],[OptionT]]
[StateT.run_modifyGet,[of_eq_true, eq_self, Pure.pure],[Eq, StateT.run, MonadState.modifyGet, Pure.pure, Prod.mk, Prod.fst, Prod.snd]]
[withPtrEqDecEq.proof_1,[toBoolUsing_eq_true, Unit.unit],[Eq, toBoolUsing, Unit.unit, Bool.true]]
[IO.Error.inappropriateType.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.inappropriateType, HAdd.hAdd, OfNat.ofNat]]
[Substring.nextn,[String.Pos, PProd.fst, Substring.next],[String.Pos]]
[instLTFloat,[LT.mk, Float.lt],[LT, Float]]
[Char.quote,[HAppend.hAppend, Char.quoteCore],[String]]
[Nat.mul_pos,[],[GT.gt, HMul.hMul, OfNat.ofNat]]
[Lean.Parser.Tactic.Conv.arg,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[UInt8.shiftRight,[UInt8.mk, HShiftRight.hShiftRight, UInt8.val, UInt8.modn, OfNat.ofNat],[UInt8]]
[PSum.inr.injEq,[Eq.propIntro, Eq.refl, PSum.inr, Eq.symm, eq_of_heq, HEq.refl],[Eq, PSum.inr]]
[EStateM.bind,[EStateM.Result, EStateM.Result.error],[EStateM]]
[StateCpsT.runK_bind_get,[rfl],[Eq, StateCpsT.runK, Bind.bind, MonadState.get]]
[MonadWithReader.withReader,[],[]]
[UInt64.ofNatCore,[UInt64.mk, Fin.mk],[UInt64]]
[WellFounded.apply.proof_1,[],[Acc]]
[ExceptCpsT.instInhabitedExceptCpsT,[Inhabited.mk, arbitrary],[Inhabited, ExceptCpsT]]
[String.Iterator.s,[],[String]]
[OptionT.instAlternativeOptionT,[Alternative.mk, OptionT.fail, OptionT.orElse],[Alternative, OptionT]]
[ExceptT.instMonadFunctorExceptT,[MonadFunctor.mk, Except],[MonadFunctor, ExceptT]]
[Thunk.map,[Thunk.mk, Thunk.get],[Thunk]]
[Nat.lt_of_le_of_lt,[Nat.le_trans, Nat.succ_le_succ],[LT.lt]]
[or,[Unit.unit, Bool, Bool.true],[Bool]]
[instMonadBaseIO,[inferInstanceAs, Monad, EIO, Empty],[Monad, BaseIO]]
[instOrdFin,[Ord.mk, Ord.compare, Fin.val],[Ord, Fin]]
[Lean.Macro.throwUnsupported,[MonadExcept.throw, Lean.Macro.Exception.unsupportedSyntax],[Lean.MacroM]]
[or_self,[propext, Iff.intro, Or.inl],[Eq, Or]]
[instDecidableEqSum.proof_5,[],[Sum.noConfusionType, False, Sum.inr, Sum.inl]]
[IO.FS.instReprMetadata,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, IO.FS.Metadata.accessed, Std.Format.line, IO.FS.Metadata.modified, IO.FS.Metadata.byteSize, IO.FS.Metadata.type],[Repr, IO.FS.Metadata]]
[MonadLift.monadLift,[],[]]
[hexDigitRepr,[String.singleton, Nat.digitChar],[String]]
[Classical.propDecidable.proof_1,[Nonempty, Decidable, Classical.em, Nonempty.intro, Decidable.isTrue, Decidable.isFalse],[Nonempty, Decidable]]
[Lean.Meta.Simp.ConfigCtx.toConfig,[],[Lean.Meta.Simp.Config]]
[List.concat,[List, List.cons, List.nil, PProd.fst],[List]]
[Option.none.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Option.none, OfNat.ofNat]]
[StateT.run',[Functor.map, Prod.fst],[]]
[Option.some.injEq,[Eq.propIntro, Eq.refl, Option.some, Eq.symm, eq_of_heq, HEq.refl],[Eq, Option.some]]
[unexpandEqRec,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Int.instDecidableEqInt,[Int.decEq],[DecidableEq, Int]]
[ByteArray.instInhabitedByteArray,[Inhabited.mk, ByteArray.empty],[Inhabited, ByteArray]]
[Array.size_mkArray,[List.length_replicate],[Eq, Array.size, Array.mkArray]]
[Subtype.instInhabitedSubtype,[Inhabited.mk, Subtype.mk],[Inhabited, Subtype]]
[UInt16.sub,[UInt16.mk, HSub.hSub, UInt16.val],[UInt16]]
[instReprSourceInfo,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, HAppend.hAppend, Std.Format.text, Std.Format.line, reprArg, Std.Format.FlattenBehavior.allOrNone],[Repr, Lean.SourceInfo]]
[bfix4,[PProd.fst],[]]
[instShiftLeftUSize,[ShiftLeft.mk, USize.shiftLeft],[ShiftLeft, USize]]
[EStateM.seqRight,[EStateM.Result, Unit.unit, EStateM.Result.error],[EStateM]]
[Array.foldrM.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure],[]]
[Lean.Name.mkSimple,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Name]]
[Lean.Syntax.decodeNatLitVal?,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Option.none, Char.ofNat, Option.some, or, Char.isDigit],[Option, Nat]]
[EStateM.set,[EStateM.Result.ok, PUnit.unit],[EStateM, PUnit]]
[String.takeRight,[Substring.toString, Substring.takeRight, String.toSubstring],[String]]
[USize.val,[],[Fin, USize.size]]
[IO.Process.SpawnArgs.args,[],[Array, String]]
[instInhabitedSort,[Inhabited.mk, PUnit],[Inhabited]]
[ByteArray.toUInt64LE!,[ite, Eq, BEq.beq, ByteArray.size, OfNat.ofNat, Bool.true, HOr.hOr, HShiftLeft.hShiftLeft, UInt8.toUInt64, ByteArray.get!, panicWithPosWithDecl, HAppend.hAppend],[UInt64]]
[UInt32.ofNat,[UInt32.mk, Fin.ofNat],[UInt32]]
[Nat.succ_mul,[rfl, Eq.mpr, Eq.refl, Eq, HMul.hMul, Nat.succ, HAdd.hAdd, Nat.mul_succ, Nat.add_succ, Nat.add_right_comm],[Eq, HMul.hMul, Nat.succ, HAdd.hAdd]]
[ByteArray.getOp,[ByteArray.get!],[UInt8]]
[List.getLast?,[Unit.unit, Option, Option.none, Option.some, List.getLast, List.cons, List.getLast?.proof_1],[Option]]
[UInt32.size,[OfNat.ofNat],[Nat]]
[Or.intro_right,[Or.inr],[Or]]
[Lean.Quote.quote,[],[Lean.Syntax]]
[List.reverse,[List.reverseAux, List.nil],[List]]
[ReaderT.instMonadExceptOfReaderT,[MonadExceptOf.mk, liftM, MonadExcept.throw, tryCatchThe],[MonadExceptOf, ReaderT]]
[PUnit.unit.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, PUnit.unit, OfNat.ofNat]]
[iff_true,[propext, Iff.intro, Iff.mpr, trivial],[Eq, Iff, True]]
[IO.AccessRight.flags,[UInt32.lor],[UInt32]]
[Prod.lt_def,[rfl],[Eq, LT.lt, Or, Prod.fst, And, Prod.snd]]
[Lean.Meta.Rewrite.Config.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Rewrite.Config.mk, HAdd.hAdd, OfNat.ofNat]]
[eq_true_of_decide,[propext, Iff.intro, trivial, of_decide_eq_true],[Eq, True]]
[Lean.MacroScopesView.scopes,[],[List, Lean.MacroScope]]
[Classical.inhabited_of_exists,[Classical.inhabited_of_nonempty, Classical.inhabited_of_exists.proof_1],[Inhabited]]
[instShiftRightUInt8,[ShiftRight.mk, UInt8.shiftRight],[ShiftRight, UInt8]]
[instInhabitedList,[Inhabited.mk, List.nil],[Inhabited, List]]
[Ordering.toCtorIdx,[OfNat.ofNat],[Nat]]
[Lean.Parser.Tactic.Conv.convRight,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Subrelation,[],[]]
[Lean.Parser.Tactic.injection,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Substring.extract,[Substring, ite, GE.ge, Substring.mk, OfNat.ofNat, Nat.min, HAdd.hAdd],[Substring]]
[«term_<*>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[EIO.toBaseIO,[EStateM.Result, Empty, IO.RealWorld, Except, EStateM.Result.ok, Except.ok, Except.error],[BaseIO, Except]]
[Substring.dropRightWhile,[Substring, Substring.mk],[Substring]]
[Array.allM,[Bind.bind, Array.anyM, Pure.pure, not, OfNat.ofNat, Array.size],[Bool]]
[Nat.anyAux,[Unit.unit, Bool, Bool.false, or, HSub.hSub, Nat.succ, PProd.fst],[Bool]]
[Lean.Macro.Context.currRecDepth,[],[Nat]]
[addParenHeuristic,[ite, Eq, or, String.isPrefixOf, Bool.true, not, String.any, Char.isWhitespace, HAppend.hAppend],[String]]
[IO.Process.SpawnArgs.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Process.SpawnArgs.mk, HAdd.hAdd, OfNat.ofNat]]
[Array.getD,[dite, LT.lt, Array.size, Array.get, Fin.mk],[]]
[«term{__:_//_}»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Name.appendBefore,[Lean.Name.modifyBase, Unit.unit, Lean.Name, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, Lean.Name.mkNum],[Lean.Name]]
[IO.FileRight.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.FileRight.mk, HAdd.hAdd, OfNat.ofNat]]
[UInt8.toUInt32,[Nat.toUInt32, UInt8.toNat],[UInt32]]
[«term{}»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Nat.pred,[Unit.unit, Nat, OfNat.ofNat],[Nat]]
[Lean.Parser.Attr.simp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.simpPre, Lean.Parser.Tactic.simpPost, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Acc.noConfusionType,[],[]]
[Subtype.existsOfSubtype,[Subtype.existsOfSubtype.proof_1],[Exists]]
[IO.FS.FileType.noConfusionType,[noConfusionTypeEnum, IO.FS.FileType.toCtorIdx],[]]
[IO.Error.inappropriateType.inj,[And.intro],[And, Eq]]
[Xor.noConfusionType,[],[]]
[fixCore2,[bfix2, USize.size],[]]
[USize.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd],[USize]]
[EStateM.Backtrackable.save,[],[]]
[if_neg,[Eq, ite, absurd, rfl],[Eq, ite]]
[StateCpsT.runK_get,[rfl],[Eq, StateCpsT.runK, MonadState.get]]
[StateCpsT.instLawfulMonadStateCpsT,[StateCpsT.instLawfulMonadStateCpsT.proof_1],[LawfulMonad, StateCpsT]]
[Char.isValidUInt32,[LT.lt, UInt32.size, Nat.lt_trans, of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, UInt32.size]]
[HAppend.hAppend,[],[]]
[System.SearchPath.separator,[ite, Eq, System.Platform.isWindows, Bool.true, Char.ofNat],[Char]]
[PNonScalar.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, PNonScalar.mk, HAdd.hAdd, OfNat.ofNat]]
[Float.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Float.mk, HAdd.hAdd, OfNat.ofNat]]
[instBEq,[BEq.mk, Decidable.decide, Eq],[BEq]]
[IO.Error.resourceExhausted.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.resourceExhausted, HAdd.hAdd, OfNat.ofNat]]
[System.FilePath.pathSeparator,[ite, Eq, System.Platform.isWindows, Bool.true, Char.ofNat],[Char]]
[Nat.zero_mod,[Eq.mpr, Eq.refl, Eq, HMod.hMod, OfNat.ofNat, Nat.mod_eq],[Eq, HMod.hMod, OfNat.ofNat]]
[Subrelation.wf,[Subrelation.wf.proof_1],[WellFounded]]
[instReprSubstring,[Repr.mk, Std.Format.text, HAppend.hAppend, String.quote, Substring.toString],[Repr, Substring]]
[absurd,[False.elim],[]]
[OptionT.run,[],[Option]]
[instInhabitedNat,[Inhabited.mk, Nat.zero],[Inhabited, Nat]]
[IO.Error.mkInvalidArgument,[IO.Error.invalidArgument, Option.none],[IO.Error]]
[instDecidableOr,[Decidable, Or, Decidable.isTrue, Or.inl, Or.inr, Decidable.isFalse, instDecidableOr.proof_1],[Decidable, Or]]
[Lean.Meta.Rewrite.Config.offsetCnstrs,[],[Bool]]
[List.getLast.proof_2,[],[List.noConfusionType, False, List.cons, List.nil]]
[instHXor,[HXor.mk, Xor.xor],[HXor]]
[HAdd.noConfusionType,[],[]]
[Lean.Parser.Tactic.tacticRepeat_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[IO.FS.Metadata.modified,[],[IO.FS.SystemTime]]
[Quot.indep,[PSigma.mk, Quot.mk],[PSigma]]
[inline,[],[]]
[Classical.propDecidable,[Classical.choice, Classical.propDecidable.proof_1],[Decidable]]
[StateT.run_map,[of_eq_true, Eq.trans, congrArg, Eq, Bind.bind, Pure.pure, Prod.mk, map_eq_pure_bind, Prod.fst, Prod.snd, eq_self],[Eq, StateT.run, Functor.map, Prod.mk, Prod.fst, Prod.snd]]
[List.instAppendList,[Append.mk, List.append],[Append, List]]
[List.toStringAux,[Bool.false, Bool.true, String, HAppend.hAppend, ToString.toString, PProd.fst],[String]]
[Nat.mod_self,[Eq.mpr, Eq.refl, Eq, HMod.hMod, OfNat.ofNat, Nat.mod_eq_sub_mod, Nat.le_refl, HSub.hSub, Nat.sub_self, Nat.zero_mod, rfl],[Eq, HMod.hMod, OfNat.ofNat]]
[ExceptT.seqLeft_eq,[],[Eq, SeqLeft.seqLeft, Seq.seq, Functor.map, Function.const]]
[ExceptCpsT.run_lift,[rfl],[Eq, ExceptCpsT.run, ExceptCpsT.lift, Bind.bind, Pure.pure, Except.ok]]
[Nat.add_right_cancel,[Nat.add_left_cancel, Eq.mp, Eq.refl, Eq, HAdd.hAdd, Nat.add_comm],[Eq]]
[List.filter,[List.filterAux, List.nil],[List]]
[Char.isLower,[and, Decidable.decide, GE.ge, Char.val, OfNat.ofNat, LE.le],[Bool]]
[Nat.sub_succ,[rfl],[Eq, HSub.hSub, Nat.succ, Nat.pred]]
[Array.map,[Id.run, Array.mapM],[Array]]
[IO.Process.StdioConfig.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Process.StdioConfig.mk, HAdd.hAdd, OfNat.ofNat]]
[Alternative.toApplicative,[],[Applicative]]
[Lean.Name.toStringWithSep.maybeEscape,[ite, Eq, Bool.true, Option.getD, Lean.Name.escapePart],[String]]
[Eq.mp,[],[]]
[Acc.ndrecOn,[],[]]
[Nat.instOrOpNat,[OrOp.mk, Nat.lor],[OrOp, Nat]]
[instHOr,[HOr.mk, OrOp.or],[HOr]]
[Nat.add_le_add_right,[Eq.mpr, Eq.refl, LE.le, HAdd.hAdd, Nat.add_comm, Nat.add_le_add_left],[LE.le, HAdd.hAdd]]
[List.map,[Unit.unit, List, List.nil, List.cons, PProd.fst],[List]]
[UInt32.toUInt16,[Nat.toUInt16, UInt32.toNat],[UInt16]]
[Lean.Meta.Simp.ConfigCtx.noConfusionType,[],[]]
[EST,[EStateM],[]]
[MonadReaderOf.noConfusionType,[],[]]
[IO.bindTask,[EIO.bindTask],[BaseIO, Task, Except, IO.Error]]
[List.reverseAux_reverseAux,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, List.cons, List.reverseAux, List.nil, eq_self],[Eq, List.reverseAux, List.nil]]
[and_self,[propext, Iff.intro, And.left, And.intro],[Eq, And]]
[Nat.pred_le,[Unit.unit, LE.le, Nat.pred, Nat.le.refl, Nat.le_succ, Nat.succ],[LE.le, Nat.pred]]
[Array.foldrM.fold.proof_1,[Nat.lt_of_lt_of_le, Nat.lt_succ_self],[LT.lt, Array.size]]
[GE.ge,[LE.le],[]]
[instDecidableLt,[UInt32.decLt],[Decidable, LT.lt]]
[OrOp.or,[],[]]
[Sum.inr.inj,[],[Eq]]
[stdRange,[Prod.mk, OfNat.ofNat],[Prod, Nat]]
[String.startsWith,[BEq.beq, Substring.take, String.toSubstring, String.length],[Bool]]
[Eq.mpr,[Eq.symm],[]]
[IO.FS.FileType.other.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.FileType.other, OfNat.ofNat]]
[Lean.PrettyPrinter.Unexpander,[Lean.PrettyPrinter.UnexpandM, Lean.Syntax],[]]
[Array.shrink.loop,[Array, PProd.fst, Array.pop],[Array]]
[Array.qsort,[Array.qsort.sort],[Array]]
[Nat.le_trans,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, LE.le, Nat.le.step, PProd.fst],[LE.le]]
[Equivalence.trans,[],[]]
[Lean.Syntax.instToStringSyntax,[ToString.mk, Function.comp, ToString.toString, Std.ToFormat.format],[ToString, Lean.Syntax]]
[MonadStateOf.set,[],[PUnit]]
[Nat.add_right_comm,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Nat.add_assoc, Nat.add_comm, Eq.symm, rfl],[Eq, HAdd.hAdd]]
[Int.toNat,[Nat, OfNat.ofNat],[Nat]]
[Lean.Parser.Syntax.addPrec,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Nat.instAndOpNat,[AndOp.mk, Nat.land],[AndOp, Nat]]
[Lean.Syntax.getTrailingSize,[Option.none, Option.some, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Nat, Lean.Syntax.getTailInfo?, Substring.bsize, OfNat.ofNat],[Nat]]
[instInhabitedPUnit,[Inhabited.mk, PUnit.unit],[Inhabited, PUnit]]
[instLawfulMonadStateRefT',[instLawfulMonadStateRefT'.proof_1],[LawfulMonad, StateRefT']]
[instReprAtomNat,[ReprAtom.mk],[ReprAtom, Nat]]
[Char.toUpper,[ite, And, GE.ge, OfNat.ofNat, LE.le, Char.ofNat, HSub.hSub],[Char]]
[MonadFunctorT.monadMap,[],[]]
[Sum.inr.injEq,[Eq.propIntro, Eq.refl, Sum.inr, Eq.symm, eq_of_heq, HEq.refl],[Eq, Sum.inr]]
[WellFounded.apply,[WellFounded.apply.proof_1],[Acc]]
[StateCpsT.runK_set,[rfl],[Eq, StateCpsT.runK, MonadStateOf.set, PUnit.unit]]
[BEq.noConfusionType,[],[]]
[Lean.instInhabitedSyntax,[Inhabited.mk, Lean.Syntax.missing],[Inhabited, Lean.Syntax]]
[instOrElse,[OrElse.mk, Alternative.orElse],[OrElse]]
[dite,[],[]]
[Array.eraseIdx,[ite, LT.lt, Array.size, Array.eraseIdxAux, HAdd.hAdd, OfNat.ofNat],[Array]]
[EStateM.orElse',[EStateM.Result.ok, EStateM.Result, EStateM.Backtrackable.restore, EStateM.Result.error, ite, Eq, Bool.true],[EStateM]]
[Lean.Syntax.SepArray.ofElems,[Lean.Syntax.SepArray.mk, Lean.mkSepArray, Lean.mkAtom],[Lean.Syntax.SepArray]]
[Nat.instXorNat,[Xor.mk, Nat.xor],[Xor, Nat]]
[Subarray.toArray,[Array.ofSubarray],[Array]]
[Classical.choose,[Subtype.val, Classical.indefiniteDescription],[]]
[Lean.MacroScopesView.noConfusionType,[],[]]
[BaseIO.toEIO,[EStateM.Result.error, EStateM.Result, IO.RealWorld, EStateM.Result.ok],[EIO]]
[List.length_replicate.aux,[of_eq_true, Eq.trans, congrArg, Eq, List.length, congrFun, HAdd.hAdd, Nat.zero_eq, Nat.zero_add, eq_self, congr, List.cons, List.length_cons, Nat.add_succ, Nat.succ_add, Nat.succ],[Eq, List.length, List.replicate.loop, HAdd.hAdd]]
[instDecidableLt_1,[UInt8.decLt],[Decidable, LT.lt]]
[instToStringDecidable,[ToString.mk, String],[ToString, Decidable]]
[LawfulApplicative.pure_seq,[],[Eq, Seq.seq, Pure.pure, Functor.map]]
[Iff.symm,[Iff.intro, Iff.mpr, Iff.mp],[Iff]]
[DoResultPR.pure.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultPR.pure, HAdd.hAdd, OfNat.ofNat]]
[tacticFunext__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Array.filterMap,[Id.run, Array.filterMapM],[Array]]
[cast_heq,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, HEq, cast],[HEq, cast]]
[FloatSpec.float,[],[]]
[Nat.forRevM.loop,[Unit.unit, Unit, Pure.pure, Bind.bind, PProd.fst],[Unit]]
[DoResultSBC.break.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultSBC.break, HAdd.hAdd, OfNat.ofNat]]
[Lean.isIdEndEscape,[Decidable.decide, Eq, Lean.idEndEscape],[Bool]]
[ExceptT.bind_pure_comp,[rfl],[Eq, Bind.bind, Function.comp, Pure.pure, Functor.map]]
[UInt16.noConfusionType,[],[]]
[Lean.strLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Subarray.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Subarray.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat.lt_of_lt_of_le],[LT.lt]]
[Subarray.popFront.proof_1,[Nat.le_of_lt_succ, Nat.add_lt_add_right, OfNat.ofNat],[LE.le, HAdd.hAdd, Subarray.start, OfNat.ofNat, Subarray.stop]]
[HEq.rfl,[HEq.rfl.proof_1],[HEq]]
[fix1,[fixCore1, arbitrary],[]]
[instShiftRightUInt64,[ShiftRight.mk, UInt64.shiftRight],[ShiftRight, UInt64]]
[instShiftLeftUInt16,[ShiftLeft.mk, UInt16.shiftLeft],[ShiftLeft, UInt16]]
[Lean.mkIdentFrom,[Lean.Syntax.ident, Lean.SourceInfo.fromRef, String.toSubstring, ToString.toString, List.nil],[Lean.Syntax]]
[Lean.Module.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Module.mk, HAdd.hAdd, OfNat.ofNat]]
[MonadControlT.restoreM,[],[]]
[List.reverse_reverse,[Eq.mpr, Eq.refl, Eq, List.reverseAux, List.nil, List.reverseAux_reverseAux_nil, rfl],[Eq, List.reverse]]
[Functor.mapConst,[],[]]
[ByteArray.mk.inj,[],[Eq]]
[String.all,[not, String.any],[Bool]]
[Array.filterSepElemsM,[OfNat.ofNat, List.toArray, List.nil],[Array, Lean.Syntax]]
[LawfulFunctor.map_const,[],[Eq, Functor.mapConst, Function.comp, Functor.map, Function.const]]
[unexpandListNil,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.PrettyPrinter.Unexpander]]
[And.left,[],[]]
[IO.eprintln,[IO.eprint, String.push, ToString.toString, Char.ofNat],[IO, Unit]]
[Monad.noConfusionType,[],[]]
[Char.utf8Size.proof_2,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[InvImage.accessible,[InvImage.accessible.proof_1],[Acc, InvImage]]
[Quot.hrecOn.proof_1,[eq_of_heq],[Eq, Quot.sound]]
[instXorUInt8,[Xor.mk, UInt8.xor],[Xor, UInt8]]
[instReprList_1,[Repr.mk, Std.Format, List.cons, Std.Format.text, Std.Format.bracketFill, Std.Format.joinSep, HAppend.hAppend, Std.Format.line],[Repr, List]]
[UInt64.mul,[UInt64.mk, HMul.hMul, UInt64.val],[UInt64]]
[strictAnd,[and],[Bool]]
[instShiftLeftUInt64,[ShiftLeft.mk, UInt64.shiftLeft],[ShiftLeft, UInt64]]
[PProd.noConfusionType,[],[]]
[Lean.Parser.Tactic.tacticErw__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[HEq.symm,[HEq.ndrecOn, HEq.refl],[HEq]]
[FloatArray.foldlMUnsafe.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bind.bind, FloatArray.uget, lcProof, FloatArray.foldlMUnsafe.fold, HAdd.hAdd, OfNat.ofNat],[]]
[ST.Ref.ptrEq,[liftM, ST.Prim.Ref.ptrEq],[Bool]]
[MonadLiftT.noConfusionType,[],[]]
[Lean.Syntax.getTailInfo,[Option.getD, Lean.Syntax.getTailInfo?, Lean.SourceInfo.none],[Lean.SourceInfo]]
[UInt16.land,[UInt16.mk, Fin.land, UInt16.val],[UInt16]]
[ExceptCpsT.instLawfulMonadExceptCpsT.proof_1,[LawfulMonad.mk, rfl],[LawfulMonad, ExceptCpsT]]
[precLead,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[instMonadExceptOfExcept,[MonadExceptOf.mk, Except.error, Except.tryCatch],[MonadExceptOf, Except]]
[String.capitalize,[String.set, OfNat.ofNat, Char.toUpper, String.get],[String]]
[Std.Format.MonadPrettyFormat.pushOutput,[],[Unit]]
[EStateM.dummyRestore,[],[]]
[Lean.version.minor,[Unit.unit],[Nat]]
[Except.pure,[Except.ok],[Except]]
[Lean.Parser.Tactic.Conv.ext,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[false_implies,[propext, Iff.intro, trivial, absurd, of_decide_eq_false, Eq.refl, Decidable.decide, False],[Eq, True]]
[unexpandProdMk,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[StateT.run_bind,[of_eq_true, eq_self, Bind.bind],[Eq, StateT.run, Bind.bind, Prod.fst, Prod.snd]]
[Char.ne_of_val_ne,[absurd, Char.val_eq_of_eq],[Not, Eq]]
[max,[ite, LT.lt],[]]
[Lean.Macro.getMethodsImp,[Bind.bind, MonadReader.read, Pure.pure, unsafeCast, Lean.Macro.Context.methods],[Lean.MacroM, Lean.Macro.Methods]]
[Nat.mod_le,[LE.le, HMod.hMod, Nat.lt_or_ge, Eq.mpr, Eq.refl, Nat.mod_eq_of_lt, Nat.le_refl, Nat.eq_zero_or_pos, OfNat.ofNat, Nat.mod_zero, Nat.le_trans, Nat.le_of_lt, Nat.mod_lt],[LE.le, HMod.hMod]]
[IO.AccessRight.noConfusionType,[],[]]
[Nat.forRevM,[Nat.forRevM.loop],[Unit]]
[StateT.failure,[Alternative.failure],[StateT]]
[EStateM.fromStateM,[EStateM.Result, StateT.run, EStateM.Result.ok],[EStateM]]
[instDecidableEqSum,[Decidable, Eq, dite, Decidable.isTrue, instDecidableEqSum.proof_1, Decidable.isFalse, instDecidableEqSum.proof_2, instDecidableEqSum.proof_3, instDecidableEqSum.proof_4, instDecidableEqSum.proof_5, instDecidableEqSum.proof_6],[DecidableEq, Sum]]
[Char.isDigit,[and, Decidable.decide, GE.ge, Char.val, OfNat.ofNat, LE.le],[Bool]]
[IO.Error.inappropriateType.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.inappropriateType, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.inappropriateType, And]]
[Substring.prevn,[String.Pos, PProd.fst, Substring.prev],[String.Pos]]
[MonadWithReaderOf.noConfusionType,[],[]]
[String.Iterator.remainingBytes,[Nat, HSub.hSub, String.bsize],[Nat]]
[Applicative.toSeqLeft,[],[SeqLeft]]
[Array.get!,[Array.getD, arbitrary],[]]
[List.hasDecEq.proof_6,[absurd],[False]]
[IO.AccessRight.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.AccessRight.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.AccessRight.mk, And]]
[Substring.toString,[String, String.extract],[String]]
[IO.mapTasks,[EIO.mapTasks],[BaseIO, Task, Except, IO.Error]]
[Squash.lift.proof_1,[Subsingleton.elim],[Eq]]
[Fin.instInhabitedFinHAdd,[Inhabited.mk, OfNat.ofNat],[Inhabited, Fin]]
[List.mapTRAux,[List, List.reverse, PProd.fst, List.cons],[List]]
[Char.noConfusionType,[],[]]
[IO.FS.lines,[Bind.bind, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.false, List.toArray, List.nil, IO.FS.lines.read],[IO, Array, String]]
[ExceptCpsT.runCatch_bind_lift,[rfl],[Eq, ExceptCpsT.runCatch, Bind.bind, ExceptCpsT.lift]]
[or_false,[propext, Iff.intro, False.elim, Or.inl],[Eq, Or, False]]
[Nat.repeat,[Nat.repeat.loop],[]]
[Mul.mul,[],[]]
[Fin.val,[],[Nat]]
[Functor.discard,[Functor.mapConst, PUnit.unit],[PUnit]]
[Unit,[PUnit],[]]
[Acc.inv.proof_1,[],[Acc]]
[Lean.Parser.Tactic.Conv.nestedTacticCore,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Substring.isNat,[Substring.all, Char.isDigit],[Bool]]
[Sum.inr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Sum.inr, HAdd.hAdd, OfNat.ofNat]]
[Classical.byContradiction,[Decidable.byContradiction],[]]
[UInt32.xor,[UInt32.mk, Fin.xor, UInt32.val],[UInt32]]
[USize.ofNat,[USize.mk, Fin.ofNat', usize_size_gt_zero],[USize]]
[Lean.Meta.Simp.Config.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Simp.Config.mk, HAdd.hAdd, OfNat.ofNat]]
[IO.Error.permissionDenied.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.permissionDenied, HAdd.hAdd, OfNat.ofNat]]
[instHashable,[Hashable.mk, OfNat.ofNat],[Hashable]]
[FloatSpec.noConfusionType,[],[]]
[Lean.Meta.TransparencyMode.instances.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.TransparencyMode.instances, OfNat.ofNat]]
[Lean.Name.appendAfter,[Lean.Name.modifyBase, Lean.Name.anonymous, Lean.Name.num, Lean.Name, Lean.Name.mkStr, HAppend.hAppend],[Lean.Name]]
[Fin.ofNat,[Fin.mk, HMod.hMod, Nat.succ, Fin.ofNat.proof_1],[Fin, Nat.succ]]
[System.FilePath.pathSeparators,[ite, Eq, System.Platform.isWindows, Bool.true, List.cons, Char.ofNat, List.nil],[List, Char]]
[Std.Format.append.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.Format.append, HAdd.hAdd, OfNat.ofNat]]
[Array.foldlM.proof_1,[Nat.le_refl, Array.size],[LE.le, Array.size]]
[PSum.inl.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, PSum.inl, HAdd.hAdd, OfNat.ofNat]]
[OptionM.run,[],[Option]]
[Array.anyM,[dite, LE.le, Array.size, Array.anyM.proof_1],[Bool]]
[IO.FS.withFile,[Bind.bind, IO.FS.Handle.mk, Bool.true],[IO]]
[Array.extLit,[Array.ext, Eq.trans, Eq.symm],[Eq]]
[Lean.Parser.Tactic.generalizeArg,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[Std.Format.pretty,[Prod.snd],[String]]
[Quotient.ind₂,[Quotient.ind],[]]
[Int.ofNat.inj,[],[Eq]]
[IO.Error.unsupportedOperation.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.unsupportedOperation, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.unsupportedOperation, And]]
[Lean.NameGenerator.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.NameGenerator.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.NameGenerator.mk, And]]
[IO.Error.toString,[Unit.unit, String, IO.Error.fopenErrorToString, Option.some, IO.Error.otherErrorToString, Option.none],[String]]
[ReaderT.bind,[Bind.bind],[ReaderT]]
[«term_++_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Char.instDecidableLt,[UInt32.decLt, Char.val],[Decidable, LT.lt]]
[instAddUInt32,[Add.mk, UInt32.add],[Add, UInt32]]
[Nat.le_succ,[Nat.le.step, Nat.le.refl],[LE.le, Nat.succ]]
[IO.Error.mkAlreadyExistsFile,[Function.comp, IO.Error.alreadyExists, Option.some],[IO.Error]]
[Lean.Quote.noConfusionType,[],[]]
[Nat.lt.base,[Nat.lt.base.proof_1],[LT.lt, Nat.succ]]
[and_true,[propext, Iff.intro, And.left, And.intro, trivial],[Eq, And, True]]
[ToBool.toBool,[],[Bool]]
[UInt8.add,[UInt8.mk, HAdd.hAdd, UInt8.val],[UInt8]]
[UInt16.modn,[UInt16.mk, HMod.hMod, UInt16.val],[UInt16]]
[BaseIO.mapTasks,[List.nil, BaseIO.mapTasks.go],[BaseIO, Task]]
[Iff.subst,[Eq.subst, propext],[]]
[ne_false_of_self,[],[Ne, False]]
[List.head,[absurd, Eq.refl, List.nil],[]]
[IO.FS.readFile,[Bind.bind, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.false, IO.FS.Handle.readToEnd],[IO, String]]
[instDecidableEqUInt16,[UInt16.decEq],[DecidableEq, UInt16]]
[List.length,[Unit.unit, Nat, OfNat.ofNat, HAdd.hAdd, PProd.fst],[Nat]]
[IO.FileRight.other,[],[IO.AccessRight]]
[List.rangeAux,[List, Nat, PProd.fst, List.cons],[List, Nat]]
[ST.Ref.mk.inj,[],[Eq]]
[List.foldr,[Unit.unit, PProd.fst],[]]
[Lean.Meta.instReprTransparencyMode,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone],[Repr, Lean.Meta.TransparencyMode]]
[Array.append,[Array.foldl, Array.push, OfNat.ofNat, Array.size],[Array]]
[IO.FS.Stream.Buffer.noConfusionType,[],[]]
[Substring.contains,[Substring.any, BEq.beq],[Bool]]
[Repr.addAppParen,[ite, GE.ge, OfNat.ofNat, Std.Format.paren],[Std.Format]]
[Quot.liftIndepPr1,[Quot.ind, rfl],[Eq, PSigma.fst, Quot.lift, Quot.indep, Quot.indepCoherent]]
[IO.Error.noFileOrDirectory.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.noFileOrDirectory, HAdd.hAdd, OfNat.ofNat]]
[Classical.epsilon_spec_aux,[Subtype.property, Classical.strongIndefiniteDescription],[Classical.epsilon]]
[Lean.Parser.Tactic.Conv.simpMatch,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[String.firstDiffPos,[OfNat.ofNat, String.firstDiffPos.loop],[String.Pos]]
[Coe.noConfusionType,[],[]]
[IO.FS.instReprDirEntry,[Repr.mk, Std.Format.bracket, HAppend.hAppend, Std.Format.nil, Std.Format.text, repr, IO.FS.DirEntry.root, Std.Format.line, IO.FS.DirEntry.fileName],[Repr, IO.FS.DirEntry]]
[Array.foldlM,[dite, LE.le, Array.size, Array.foldlM.proof_1],[]]
[Classical.axiomOfChoice,[Exists.intro, Classical.choose, Classical.choose_spec],[Exists]]
[coeTrans,[CoeTC.mk, coeB, coeTC],[CoeTC]]
[Lean.instInhabitedName,[Inhabited.mk, Lean.Name.anonymous],[Inhabited, Lean.Name]]
[StateCpsT.run,[StateCpsT.runK, Pure.pure, Prod.mk],[Prod]]
[Subsingleton.helim,[Subsingleton.helim.proof_1],[HEq]]
[Nat.mul_one,[Nat.zero_add],[Eq, HMul.hMul, OfNat.ofNat]]
[instToStreamListList,[ToStream.mk],[ToStream, List]]
[instLENat,[LE.mk, Nat.le],[LE, Nat]]
[ReaderT.run_pure,[rfl],[Eq, ReaderT.run, Pure.pure]]
[«term_≥_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Std.Format.instBEqFlattenBehavior,[BEq.mk, BEq.beq, Std.Format.FlattenBehavior.toCtorIdx],[BEq, Std.Format.FlattenBehavior]]
[Array.findSomeRevM?.find.proof_1,[Nat.lt_of_lt_of_le, Nat.lt_succ_self],[LT.lt, Array.size]]
[IO.Error.mkInterrupted,[IO.Error.interrupted],[IO.Error]]
[instReprAtomChar,[ReprAtom.mk],[ReprAtom, Char]]
[boolToSort,[CoeSort.mk, Eq, Bool.true],[CoeSort, Bool]]
[instInhabitedOrdering,[Inhabited.mk, Ordering.lt],[Inhabited, Ordering]]
[Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat.lt_of_le_of_lt],[LT.lt]]
[FloatArray.get?,[dite, LT.lt, FloatArray.size, Option.some, FloatArray.get, Fin.mk, Option.none],[Option, Float]]
[Lean.NameGenerator.mkChild,[Prod.mk, Lean.NameGenerator.mk, Lean.Name.mkNum, Lean.NameGenerator.namePrefix, Lean.NameGenerator.idx, OfNat.ofNat, HAdd.hAdd],[Prod, Lean.NameGenerator]]
[Lean.MonadNameGenerator.setNGen,[],[Unit]]
[Fin.sub.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, HAdd.hAdd, HSub.hSub]]
[Lean.Name.instReprName,[Repr.mk, Lean.Name.reprPrec],[Repr, Lean.Name]]
[PSigma.lex.proof_1,[WellFounded.intro, Acc, PSigma.Lex, PSigma.lexAccessible, WellFounded.apply],[WellFounded, PSigma.Lex]]
[Substring.bsize,[Nat, Nat.sub],[Nat]]
[Nat.instShiftRightNat,[ShiftRight.mk, Nat.shiftRight],[ShiftRight, Nat]]
[ExceptT.instMonadExceptT,[Monad.mk],[Monad, ExceptT]]
[Lean.NameGenerator.noConfusionType,[],[]]
[Std.instToFormatString,[Std.ToFormat.mk, Std.Format.text],[Std.ToFormat, String]]
[Nat.gcd.proof_1,[WellFoundedRelation.wf, measure, id],[WellFounded, WellFoundedRelation.rel, measure, id]]
[List.reverseAux,[List, PProd.fst, List.cons],[List]]
[Classical.choose_spec,[Subtype.property, Classical.indefiniteDescription],[Classical.choose]]
[List.getLast.proof_1,[rfl],[Eq, List.nil]]
[FloatArray.getOp,[FloatArray.get!],[Float]]
[Nat.lt.base.proof_1,[Nat.le_refl, Nat.succ],[LE.le, Nat.succ]]
[Subtype.eta,[rfl, Eq.symm, Eq.refl],[Eq, Subtype.mk, Subtype.val]]
[«stx_,+»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[instInhabitedSubstring,[Inhabited.mk, Substring.mk, OfNat.ofNat],[Inhabited, Substring]]
[instSubsingletonForall.proof_1,[Subsingleton.intro, funext, Subsingleton.elim],[Subsingleton]]
[false_or,[propext, Iff.intro, False.elim, Or.inr],[Eq, Or, False]]
[Substring.posOf,[String.Pos, HSub.hSub, String.posOfAux],[String.Pos]]
[Quotient.inductionOn,[Quot.inductionOn],[]]
[System.FilePath.isCaseInsensitive,[or, System.Platform.isWindows, System.Platform.isOSX],[Bool]]
[Nat.mul_le_mul_right,[Nat.mul_le_mul_left, Nat.mul_comm],[LE.le, HMul.hMul]]
[PSigma.lexNdep,[PSigma.Lex],[]]
[modify,[MonadState.modifyGet, Prod.mk, PUnit.unit],[PUnit]]
[List.map₂,[List.nil, List.cons, List, PProd.fst],[List]]
[EStateM.instReprResult,[Repr.mk, Std.Format, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg],[Repr, EStateM.Result]]
[IO.Process.Output.noConfusionType,[],[]]
[List.forIn_cons,[rfl],[Eq, ForIn.forIn, List.cons, Bind.bind, Pure.pure]]
[coeBase,[CoeTC.mk, coeB],[CoeTC]]
[String.Iterator.curr,[Char, String.get],[Char]]
[Except.bind,[Except, Except.error],[Except]]
[Array.back,[Array.get!, HSub.hSub, Array.size, OfNat.ofNat],[]]
[instSubsingleton.proof_1,[Subsingleton.intro, proofIrrel],[Subsingleton]]
[List.tailD,[List],[List]]
[Fin.instShiftLeftFin,[ShiftLeft.mk, Fin.shiftLeft],[ShiftLeft, Fin]]
[Nat.right_distrib,[],[Eq, HMul.hMul, HAdd.hAdd]]
[Std.Format.ibelow,[True, And],[]]
[Std.Format.prefixJoin,[Unit.unit, Std.Format, Std.Format.nil, HAppend.hAppend, Std.ToFormat.format, PProd.fst],[Std.Format]]
[List.hasDecidableLt.proof_3,[Eq.symm, eq_of_heq, Eq.refl, List.cons, HEq.refl, False, absurd],[False]]
[And.noConfusionType,[],[]]
[Alternative.noConfusionType,[],[]]
[UInt64.toUInt32,[Nat.toUInt32, UInt64.toNat],[UInt32]]
[IO.appDir,[Bind.bind, IO.appPath, Pure.pure, System.FilePath.parent, Option.none, IO, System.FilePath, IO.FS.realPath, MonadExcept.throw, IO.userError, HAppend.hAppend, ToString.toString],[IO, System.FilePath]]
[instInhabitedUSize,[Inhabited.mk, USize.ofNatCore, OfNat.ofNat, instInhabitedUSize.proof_1],[Inhabited, USize]]
[Lean.«termMacro.trace[__]_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Pure.pure,[],[]]
[ByteArray.data,[],[Array, UInt8]]
[Lean.Name.modifyBase,[ite, Eq, Lean.Name.hasMacroScopes, Bool.true, Lean.MacroScopesView.review, Lean.MacroScopesView.mk, Lean.MacroScopesView.name, Lean.MacroScopesView.imported, Lean.MacroScopesView.mainModule, Lean.MacroScopesView.scopes],[Lean.Name]]
[IO.FS.Metadata.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.FS.Metadata.mk, HAdd.hAdd, OfNat.ofNat]]
[Classical.epsilon,[Subtype.val, Classical.strongIndefiniteDescription],[]]
[IO.FS.Handle.mk,[IO.FS.Handle.mkPrim, HAppend.hAppend],[IO, IO.FS.Handle]]
[instDivFloat,[Div.mk, Float.div],[Div, Float]]
[ExceptCpsT.instMonadExceptOfExceptCpsT,[MonadExceptOf.mk],[MonadExceptOf, ExceptCpsT]]
[id,[],[]]
[List.getLast!,[Unit.unit, panicWithPosWithDecl, OfNat.ofNat, List.getLast, List.cons, List.getLast!.proof_1],[]]
[instDecidableNot,[Decidable, Not, Decidable.isFalse, absurd, Decidable.isTrue],[Decidable, Not]]
[List.reverseAux_reverseAux_nil,[rfl, of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.cons, List.reverseAux, eq_self],[Eq, List.reverseAux, List.nil]]
[Nat.gcd_succ,[rfl],[Eq, Nat.gcd, Nat.succ, HMod.hMod]]
[IO.Error.mkNoFileOrDirectory,[IO.Error.noFileOrDirectory],[IO.Error]]
[Array.eraseIdx'.proof_1,[rfl],[Eq, Array.size]]
[UInt8.val,[],[Fin, UInt8.size]]
[Int.instSubInt,[Sub.mk, Int.sub],[Sub, Int]]
[USize.ofNatCore,[USize.mk, Fin.mk],[USize]]
[Nat.forM,[Nat.forM.loop],[Unit]]
[emptyWf,[WellFoundedRelation.mk, emptyRelation, emptyWf.proof_1],[WellFoundedRelation]]
[instHModUSizeNatUSize,[HMod.mk, USize.modn],[HMod, USize, Nat]]
[bfix5,[PProd.fst],[]]
[UInt16.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, UInt16.mk, HAdd.hAdd, OfNat.ofNat]]
[UInt32.decLe,[Decidable, LE.le, inferInstanceAs],[Decidable, LE.le]]
[instAndOpUInt16,[AndOp.mk, UInt16.land],[AndOp, UInt16]]
[Array.«term__[_:]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[let_congr,[],[Eq]]
[Lean.Meta.Simp.defaultMaxSteps,[OfNat.ofNat],[Nat]]
[instOrOpUInt16,[OrOp.mk, UInt16.lor],[OrOp, UInt16]]
[Array.foldlM.loop,[dite, LT.lt, Unit.unit, Pure.pure, Bind.bind, Array.get, Fin.mk, Array.foldlM.loop.proof_1, PProd.fst, HAdd.hAdd, OfNat.ofNat],[]]
[Nat.zero_ne_one,[],[Ne, OfNat.ofNat]]
[UInt32.shiftRight,[UInt32.mk, HShiftRight.hShiftRight, UInt32.val, UInt32.modn, OfNat.ofNat],[UInt32]]
[of_decide_eq_true,[absurd, ne_true_of_eq_false, decide_eq_false],[]]
[IO.sleep,[dbgSleep, EStateM.Result.ok, Unit.unit],[IO, Unit]]
[LawfulApplicative.toLawfulFunctor,[],[LawfulFunctor]]
[usize_size_eq,[],[Or, Eq, USize.size, OfNat.ofNat]]
[IO.mapTask,[EIO.mapTask],[BaseIO, Task, Except, IO.Error]]
[Subtype.mk.injEq,[Eq.propIntro, Eq.refl, Subtype.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Subtype.mk]]
[Sigma.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Sigma.mk, HAdd.hAdd, OfNat.ofNat]]
[IO.Error.permissionDenied.inj,[And.intro],[And, Eq]]
[Array.findIdx?,[Array.size, OfNat.ofNat, rfl, Array.findIdx?.loop],[Option, Nat]]
[Lean.Parser.Tactic.Conv.congr,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[UInt32.ofNatCore,[UInt32.mk, Fin.mk],[UInt32]]
[Char.instLTChar,[LT.mk, Char.lt],[LT, Char]]
[rfl,[rfl.proof_1],[Eq]]
[Lean.Parser.Tactic.Conv.first,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[StateT.run_get,[rfl],[Eq, StateT.run, MonadState.get, Pure.pure, Prod.mk]]
[Lean.Name.sizeOf,[Unit.unit, Nat, OfNat.ofNat, HAdd.hAdd, PProd.fst, SizeOf.sizeOf],[Nat]]
[Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1],[Trans, LE.le, LT.lt]]
[AndOp.noConfusionType,[],[]]
[Prod.lex.proof_1,[WellFounded.intro, Acc, Prod.Lex, WellFoundedRelation.rel, Prod.lexAccessible, WellFounded.apply, WellFoundedRelation.wf],[WellFounded, Prod.Lex, WellFoundedRelation.rel]]
[unsafeBaseIO,[EStateM.Result.error, EStateM.run, Unit.unit],[]]
[Lean.instQuoteString,[Lean.Quote.mk, Lean.Syntax.mkStrLit, Lean.SourceInfo.none],[Lean.Quote, String]]
[Nonempty.elim,[Nonempty.elim.proof_1],[]]
[instInhabitedUSize.proof_1,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, OfNat.ofNat, HEq.refl, LT.lt, USize.size, usize_size_eq, of_decide_eq_true, Bool.true],[LT.lt, OfNat.ofNat, USize.size]]
[IO.FileRight.flags,[UInt32.lor],[UInt32]]
[ExceptCpsT.instMonadExceptCpsT,[Monad.mk],[Monad, ExceptCpsT]]
[EStateM.map,[EStateM.Result, EStateM.Result.ok, EStateM.Result.error],[EStateM]]
[Nat.add_le_add,[Nat.le_trans, Nat.add_le_add_right, Nat.add_le_add_left],[LE.le, HAdd.hAdd]]
[WellFounded.fix_eq,[WellFounded.fixFEq, WellFounded.apply],[Eq, WellFounded.fix]]
[STWorld.noConfusionType,[],[]]
[ForInStep.yield.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, ForInStep.yield, HAdd.hAdd, OfNat.ofNat]]
[Lean.interpolatedStrLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Lean.Macro.throwErrorAt,[Lean.withRef, Lean.Macro.throwError],[Lean.MacroM]]
[ByteArray.foldlM,[dite, LE.le, ByteArray.size, ByteArray.foldlM.proof_1],[]]
[FloatArray.forIn.loop,[Pure.pure],[]]
[Lean.Parser.Tactic.refine,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[PSum.noConfusionType,[],[]]
[Array.mk.injEq,[Eq.propIntro, Eq.refl, Array.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Array.mk]]
[Array.getEvenElems,[Prod.snd, Array.foldl, Prod, Bool, Array, ite, Eq, Bool.true, Prod.mk, Bool.false, Array.push, Array.empty, OfNat.ofNat, Array.size],[Array]]
[Nat.eq_or_lt_of_le,[Or, Eq, LT.lt, Or.inl, rfl, Or.inr, Nat.succ_le_succ, Nat.zero_le, absurd, Nat.not_succ_le_zero],[Or, Eq, LT.lt]]
[instReprTupleProd,[ReprTuple.mk, List, Std.Format, ReprTuple.reprTuple, List.cons, repr],[ReprTuple, Prod]]
[String.pushn,[Nat.repeat, String.push],[String]]
[Lean.isLetterLike,[or, and, Decidable.decide, LE.le, OfNat.ofNat, Char.val, Ne],[Bool]]
[HSub.hSub,[],[]]
[WellFounded.noConfusionType,[],[]]
[IO.Error.timeExpired.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.timeExpired, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.timeExpired, And]]
[StateRefT'.instAlternativeStateRefT',[inferInstanceAs, Alternative, ReaderT, ST.Ref],[Alternative, StateRefT']]
[MProd.snd,[],[]]
[Lean.Parser.Tactic.inductionAlt,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.groupKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Array.swapAt!,[dite, LT.lt, Array.size, Array.swapAt, Fin.mk],[Prod, Array]]
[Lean.nameLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[instOfNatNat,[OfNat.mk],[OfNat, Nat]]
[Lean.isIdBeginEscape,[Decidable.decide, Eq, Lean.idBeginEscape],[Bool]]
[instDecidableIff.proof_2,[Iff.mp],[False]]
[Prod.foldI,[Nat.foldAux, Prod.snd, HSub.hSub, Prod.fst],[]]
[type_eq_of_heq,[type_eq_of_heq.proof_1],[Eq]]
[instDecidableLe_1,[UInt8.decLe],[Decidable, LE.le]]
[StateCpsT.runK,[],[]]
[Quotient.ind,[Quot.ind],[]]
[instReprAtomUInt64,[ReprAtom.mk],[ReprAtom, UInt64]]
[Array.«term__[_:_]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Parser.Tactic.tacticRefine_lift_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Tactic.allGoals,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Meta.TransparencyMode.toCtorIdx,[OfNat.ofNat],[Nat]]
[ByteArray.forInUnsafe,[OfNat.ofNat, ByteArray.forInUnsafe.loop],[]]
[instDecidableLt_4,[USize.decLt],[Decidable, LT.lt]]
[Equivalence.symm,[],[]]
[UInt16.mod,[UInt16.mk, HMod.hMod, UInt16.val],[UInt16]]
[Subarray.any,[Id.run, Subarray.anyM],[Bool]]
[IO.FS.FileType.file.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.FileType.file, OfNat.ofNat]]
[instDecidableEqString,[String.decEq],[DecidableEq, String]]
[instHShiftRight,[HShiftRight.mk, ShiftRight.shiftRight],[HShiftRight]]
[Prod.RProdSubLex,[Prod.RProdSubLex.proof_1],[Prod.Lex]]
[Float.val,[],[FloatSpec.float, floatSpec]]
[termWithout_expected_type_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Exists.elim,[],[]]
[implies,[],[]]
[instOrOpUSize,[OrOp.mk, USize.lor],[OrOp, USize]]
[ULift.up_down,[Eq, ULift.up, ULift.down, rfl],[Eq, ULift.up, ULift.down]]
[HShiftLeft.noConfusionType,[],[]]
[ByteArray.instEmptyCollectionByteArray,[EmptyCollection.mk, ByteArray.empty],[EmptyCollection, ByteArray]]
[Float.noConfusionType,[],[]]
[Nat.not_le_of_gt,[False, Nat.lt_or_ge, absurd, Nat.lt_trans, Nat.lt_irrefl],[Not, LE.le]]
[Lean.Syntax.node.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Syntax.node, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Syntax.node, And]]
[«term_+_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[IO.Process.Stdio.noConfusionType,[noConfusionTypeEnum, IO.Process.Stdio.toCtorIdx],[]]
[IO.Process.SpawnArgs.cwd,[],[Option, System.FilePath]]
[InvImage.wf,[InvImage.wf.proof_1],[WellFounded, InvImage]]
[Std.Range.«term[:_:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Std.Format.append.inj,[And.intro],[And, Eq]]
[Bool.or_self,[rfl, Eq.symm, Eq.refl],[Eq, or]]
[Array.toSubarray.proof_1,[Nat.le_refl, Array.size],[LE.le, Array.size]]
[DoResultPRBC.noConfusionType,[],[]]
[IO.FS.Mode.read.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.Mode.read, OfNat.ofNat]]
[Mod.noConfusionType,[],[]]
[HShiftRight.noConfusionType,[],[]]
[Lean.Syntax.decodeNameLit,[ite, Eq, BEq.beq, String.get, OfNat.ofNat, Char.ofNat, Bool.true, Unit.unit, List.cons, Option, Lean.Name, Substring.drop, String.toSubstring, List.nil, Option.none, Option.some, List.foldr, Lean.isIdBeginEscape, String.front, Lean.Name.mkStr, String.dropRight, String.drop, Lean.Name.anonymous],[Option, Lean.Name]]
[Lean.Meta.Simp.ConfigCtx.mk.inj,[],[Eq]]
[StateT.instLawfulMonadStateT,[StateT.instLawfulMonadStateT.proof_1],[LawfulMonad, StateT]]
[Nat.zero_lt_of_lt,[LT.lt, OfNat.ofNat],[LT.lt, OfNat.ofNat]]
[Quotient,[Quot, Setoid.r],[]]
[Lean.Parser.Tactic.Conv.convDone,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[List.append_nil,[rfl, of_eq_true, Eq.trans, congrFun, congrArg, Eq, List.cons, id, eq_self],[Eq, HAppend.hAppend, List.nil]]
[Substring.atEnd,[Bool, BEq.beq, HAdd.hAdd],[Bool]]
[String.decLt,[List.hasDecidableLt, String.data],[Decidable, LT.lt]]
[Int.instMulInt,[Mul.mk, Int.mul],[Mul, Int]]
[instToStringChar,[ToString.mk, Char.toString],[ToString, Char]]
[true_implies,[propext, Iff.intro, trivial],[Eq]]
[withTheReader,[MonadWithReaderOf.withReader],[]]
[Option.some.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Option.some, HAdd.hAdd, OfNat.ofNat]]
[UInt16.toNat,[Fin.val, UInt16.val],[Nat]]
[Lean.Parser.Syntax.subPrio,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Parser.Tactic.«tacticHave__:=_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[StateT.bind,[Bind.bind, Prod],[StateT]]
[dite_false,[rfl],[Eq, dite, False, not_false]]
[EStateM.instMonadFinallyEStateM,[MonadFinally.mk, EStateM.Result, Prod, Option.some, EStateM.Result.ok, Prod.mk, EStateM.Result.error, Option.none],[MonadFinally, EStateM]]
[instInhabitedTask,[Inhabited.mk, Task.pure, arbitrary],[Inhabited, Task]]
[UInt64.div,[UInt64.mk, HDiv.hDiv, UInt64.val],[UInt64]]
[List.tail!,[Unit.unit, List, panicWithPosWithDecl, OfNat.ofNat],[List]]
[FloatArray.mkEmpty,[FloatArray.mk, List.toArray, List.nil],[FloatArray]]
[Std.Format.appendEx,[Std.Format.append],[Std.Format]]
[instToFormatList,[Std.ToFormat.mk, List.format],[Std.ToFormat, List]]
[instHasEquiv,[HasEquiv.mk, Setoid.r],[HasEquiv]]
[UInt8.toUInt16,[Nat.toUInt16, UInt8.toNat],[UInt16]]
[«stx_<|>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instInhabitedUInt8.proof_1,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt8.size]]
[IO.Error.mkProtocolError,[IO.Error.protocolError],[IO.Error]]
[instTransEq.proof_1,[Eq.symm],[]]
[Array.all,[Id.run, Array.allM],[Bool]]
[Nat.foldAux,[PProd.fst, HSub.hSub, Nat.succ],[]]
[instNegFloat,[Neg.mk, Float.neg],[Neg, Float]]
[Lean.Syntax.instCoeArraySyntaxSepArray,[Coe.mk, Lean.Syntax.SepArray.ofElems],[Coe, Array, Lean.Syntax, Lean.Syntax.SepArray]]
[Std.Format.text.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.Format.text, HAdd.hAdd, OfNat.ofNat]]
[instDecidableEqNat,[Nat.decEq],[DecidableEq, Nat]]
[Lean.Syntax.isOfKind,[BEq.beq, Lean.Syntax.getKind],[Bool]]
[Nat.succ_sub_succ,[Nat.succ_sub_succ_eq_sub],[Eq, HSub.hSub, Nat.succ]]
[String.instInhabitedString,[Inhabited.mk],[Inhabited, String]]
[Nat.ble,[Unit.unit, Bool, Bool.true, Bool.false, PProd.fst],[Bool]]
[Lean.Parser.Tactic.Conv.convSeqBracketed,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[Std.Range.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.Range.mk, HAdd.hAdd, OfNat.ofNat]]
[PSigma.skipLeft.proof_1,[PSigma.revLex, WellFoundedRelation.wf, emptyWf],[WellFounded, PSigma.RevLex, emptyRelation, WellFoundedRelation.rel]]
[Lean.Parser.Tactic.Conv.convLeft,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[FloatArray.isEmpty,[BEq.beq, FloatArray.size, OfNat.ofNat],[Bool]]
[instComplementUInt8,[Complement.mk, UInt8.complement],[Complement, UInt8]]
[IO.FS.DirEntry.mk.inj,[And.intro],[And, Eq]]
[Char.val_ne_of_ne,[absurd, Char.eq_of_val_eq],[Not, Eq, Char.val]]
[List.isSuffixOf,[List.isPrefixOf, List.reverse],[Bool]]
[ExceptCpsT.runCatch_pure,[rfl],[Eq, ExceptCpsT.runCatch, Pure.pure]]
[Lean.NameGenerator.next,[Lean.NameGenerator.mk, Lean.NameGenerator.namePrefix, HAdd.hAdd, Lean.NameGenerator.idx, OfNat.ofNat],[Lean.NameGenerator]]
[Lean.Macro.Context.currMacroScope,[],[Lean.MacroScope]]
[Option.format,[Unit.unit, Std.Format, Std.Format.text, HAppend.hAppend, Std.ToFormat.format],[Std.Format]]
[«term_>>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Nat.pos_pow_of_pos,[Nat.pow_le_pow_of_le_right, Nat.zero_le],[LT.lt, OfNat.ofNat, HPow.hPow]]
[Lean.Parser.Tactic.rwRule,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[String.takeRightWhile,[Substring.toString, Substring.takeRightWhile, String.toSubstring],[String]]
[Std.Format.text.inj,[],[Eq]]
[Subsingleton.allEq,[],[Eq]]
[WellFounded.fixFEq,[WellFounded.fixFEq.proof_1],[Eq, WellFounded.fixF, Acc.inv]]
[Nat.lt.step.proof_1,[Nat.le_step],[LE.le, Nat.succ]]
[Array.insertionSort,[OfNat.ofNat, Array.size, Array.insertionSort.traverse, Array.insertionSort.swapLoop],[Array]]
[Lean.Macro.Context.methods,[],[PointedType.type]]
[Classical.indefiniteDescription.proof_1,[Nonempty, Subtype, Nonempty.intro, Subtype.mk],[Nonempty, Subtype]]
[System.FilePath.withExtension,[Unit.unit, System.FilePath, System.FilePath.fileStem, System.FilePath.withFileName, ite, Eq, String.isEmpty, Bool.true, HAppend.hAppend],[System.FilePath]]
[StateT.run_modify,[rfl],[Eq, StateT.run, modify, Pure.pure, Prod.mk, PUnit.unit]]
[Nat.lt_trans,[Nat.le_trans, Nat.le_step],[LT.lt]]
[StateCpsT.runK_lift,[rfl],[Eq, StateCpsT.runK, StateCpsT.lift, Bind.bind]]
[List.cons.injEq,[Eq.propIntro, And.intro, Eq.refl, List.cons, Eq.symm, eq_of_heq, HEq.refl],[Eq, List.cons, And]]
[Nat.le.intro,[Nat.le_add_right],[LE.le]]
[LawfulMonad.bind_map,[],[Eq, Bind.bind, Functor.map, Seq.seq]]
[«term_|||_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instOfNatFloat,[OfNat.mk, Float.ofNat],[OfNat, Float]]
[UInt32.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, UInt32.mk, HAdd.hAdd, OfNat.ofNat]]
[StateCpsT.instMonadLiftStateCpsT,[MonadLift.mk, StateCpsT.lift],[MonadLift, StateCpsT]]
[instHashableUSize,[Hashable.mk, USize.toUInt64],[Hashable, USize]]
[IO.Ref,[ST.Ref, IO.RealWorld],[]]
[StateT,[Prod],[]]
[IO.FS.FileType.symlink.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.FileType.symlink, OfNat.ofNat]]
[Lean.mkHole,[Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkAtomFrom, List.nil],[Lean.Syntax]]
[leOfOrd,[LE.mk, Eq, Ordering.isLE, Ord.compare, Bool.true],[LE]]
[instDecidableEqPUnit,[Decidable.isTrue, PUnit.subsingleton],[DecidableEq, PUnit]]
[instReprAtomString,[ReprAtom.mk],[ReprAtom, String]]
[Subarray.foldl,[Id.run, Subarray.foldlM],[]]
[of_eq_true,[trivial, Eq.symm],[]]
[StateT.instLawfulMonadStateT.proof_1,[LawfulMonad.mk, StateT.ext, Eq.mpr, congr, congrArg, Eq, Eq.trans, StateT.run_bind, Pure.pure, Bind.bind, StateT.run, funext, StateT.run_pure, Prod.fst, Prod.snd, StateT.run_map, LawfulMonad.bind_pure_comp, Prod.mk, rfl, of_eq_true, congrFun, LawfulMonad.pure_bind, eq_self, LawfulMonad.bind_assoc],[LawfulMonad, StateT]]
[List.length_replicate,[List.nil, List.length_replicate.aux],[Eq, List.length, List.replicate]]
[orM,[Bind.bind, Unit.unit, ToBool.toBool, Pure.pure],[]]
[Int.instLTInt,[LT.mk, Int.lt],[LT, Int]]
[List.enum,[List.enumFrom, OfNat.ofNat],[List, Prod, Nat]]
[LawfulMonad.pure_bind,[],[Eq, Bind.bind, Pure.pure]]
[Lean.Parser.Tactic.simpStar,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[MProd.mk.inj,[And.intro],[And, Eq]]
[LT.noConfusionType,[],[]]
[EStateM.adaptExcept,[EStateM.Result, EStateM.Result.error, EStateM.Result.ok],[EStateM]]
[Nat.ble_eq_true_of_le,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Eq, Nat.ble, Bool.true, Nat.ble_self_eq_true, Nat.ble_succ_eq_true, PProd.fst],[Eq, Nat.ble, Bool.true]]
[instToStringUInt8,[ToString.mk, ToString.toString, UInt8.toNat],[ToString, UInt8]]
[String.toFormat,[Std.Format.joinSep, String.splitOn, Std.Format.line],[Std.Format]]
[«term_<&&>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[HAndThen.noConfusionType,[],[]]
[Lean.Parser.Tactic.tacticAdmit,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.choiceKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Ne,[Not, Eq],[]]
[Bool.false_or,[rfl, Eq.symm, Eq.refl],[Eq, or, Bool.false]]
[Lean.Syntax.isInterpolatedStrLit?,[Unit.unit, Option, String, Lean.Syntax.isLit?, Lean.interpolatedStrLitKind, Option.none, OfNat.ofNat],[Option, String]]
[sizeOfWFRel,[measure, SizeOf.sizeOf],[WellFoundedRelation]]
[HSub.noConfusionType,[],[]]
[List.replicate.loop,[List, PProd.fst, List.cons],[List]]
[instXorUInt32,[Xor.mk, UInt32.xor],[Xor, UInt32]]
[String.split,[String.splitAux, OfNat.ofNat, List.nil],[List, String]]
[Std.Range.stop,[],[Nat]]
[ST.Prim.Ref.modifyGetUnsafe,[Bind.bind, ST.Prim.Ref.take, ST, ST.Prim.Ref.set, Pure.pure],[ST]]
[Lean.instQuoteBool,[Lean.Quote.mk, Unit.unit, Lean.Syntax, Lean.mkCIdent, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Quote, Bool]]
[Lean.Parser.Tactic.tacticSorry,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[notM,[Functor.map, not],[Bool]]
[Char.utf8Size.proof_1,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[Array.findM?,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, PUnit.unit, ite, Eq, Bool.true, Pure.pure, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, Option, MProd.fst],[Option]]
[StateT.run,[],[Prod]]
[IO.FileRight.user,[],[IO.AccessRight]]
[String.Iterator.i,[],[String.Pos]]
[dbgTraceIfShared,[],[]]
[false_iff,[propext, Iff.intro, Iff.mpr, False.elim],[Eq, Iff, False, Not]]
[instReprPUnit,[Repr.mk, Std.Format.text],[Repr, PUnit]]
[ForM.forM,[],[PUnit]]
[Array.foldrMUnsafe.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bind.bind, Array.uget, HSub.hSub, OfNat.ofNat, lcProof, Array.foldrMUnsafe.fold],[]]
[UInt64.size,[OfNat.ofNat],[Nat]]
[Ne.irrefl,[rfl],[False]]
[Iff.rfl,[Iff.refl],[Iff]]
[List.eraseReps,[Unit.unit, List, List.nil, List.eraseRepsAux],[List]]
[LT.lt,[],[]]
[or_true,[propext, Iff.intro, trivial, Or.inr],[Eq, Or, True]]
[typedExpr,[],[]]
[Classical.strongIndefiniteDescription,[dite, Exists, Subtype.mk, Classical.choice, Classical.strongIndefiniteDescription.proof_2],[Subtype]]
[HMod.noConfusionType,[],[]]
[IO.Error.alreadyExists.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.alreadyExists, HAdd.hAdd, OfNat.ofNat]]
[Array.mkEmpty,[Array.mk, List.nil],[Array]]
[Nat.repr,[List.asString, Nat.toDigits, OfNat.ofNat],[String]]
[fixCore3,[bfix3, USize.size],[]]
[instInhabitedDepArrow,[Inhabited.mk, arbitrary],[Inhabited]]
[List.get?,[Nat.zero, List.nil, Nat.succ, Option, Option.some, PProd.fst, Option.none],[Option]]
[PSigma.revLex.proof_1,[WellFounded.intro, Acc, PSigma.RevLex, PSigma.revLexAccessible, WellFounded.apply],[WellFounded, PSigma.RevLex]]
[UInt16.lor,[UInt16.mk, Fin.lor, UInt16.val],[UInt16]]
[Subarray.mk.inj,[And.intro],[And, Eq]]
[Substring.all,[not, Substring.any],[Bool]]
[IO.Process.SpawnArgs.noConfusionType,[],[]]
[Lean.instMonadQuotation,[Lean.MonadQuotation.mk, liftM, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, MonadFunctorT.monadMap, Lean.MonadQuotation.withFreshMacroScope],[Lean.MonadQuotation]]
[Substring.takeRight,[Substring.mk, Substring, HAdd.hAdd, Substring.prevn, Substring.bsize],[Substring]]
[Id.hasBind,[inferInstance],[Bind, Id]]
[FloatSpec.le,[],[]]
[Lean.Module.commands,[],[Array, Lean.Syntax]]
[IO.FS.Stream.ofHandle,[IO.FS.Stream.mk, liftM, IO.FS.Handle.isEof, IO.FS.Handle.flush, IO.FS.Handle.read, IO.FS.Handle.write, IO.FS.Handle.getLine, IO.FS.Handle.putStr],[IO.FS.Stream]]
[Id.pure_eq,[rfl],[Eq, Pure.pure]]
[Lean.Parser.Tactic.Conv.«conv·._»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[StdGen.s1,[],[Nat]]
[IO.Error.mkUnsatisfiedConstraints,[IO.Error.unsatisfiedConstraints],[IO.Error]]
[Lean.Syntax.SepArray.ofElemsUsingRef,[Bind.bind, Lean.MonadRef.getRef, Pure.pure, Lean.Syntax.SepArray.mk, Lean.mkSepArray, Lean.mkAtomFrom],[Lean.Syntax.SepArray]]
[Array.isPrefixOf,[dite, LE.le, Array.size, Array.isPrefixOfAux, OfNat.ofNat, Bool.false],[Bool]]
[unsafeCast,[cast, unsafeCast.proof_1, PUnit],[]]
[Prod.allI,[Nat.anyAux, not, Prod.snd, HSub.hSub, Prod.fst],[Bool]]
[Function.comp,[],[]]
[Nat.div.inductionOn,[WellFounded.fix, WellFoundedRelation.wf, measure, id, dite, And, LT.lt, OfNat.ofNat, LE.le, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le],[]]
[ST.Ref.set,[liftM, ST.Prim.Ref.set],[Unit]]
[Iff.comm,[Iff.intro, Iff.symm],[Iff]]
[ST.Ref.modify,[liftM, ST.Prim.Ref.modify],[Unit]]
[Nat.toUInt64,[UInt64.ofNat],[UInt64]]
[instBEqOrdering,[BEq.mk, BEq.beq, Ordering.toCtorIdx],[BEq, Ordering]]
[Std.Format.tag.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Std.Format.tag, HAdd.hAdd, OfNat.ofNat]]
[instToStringPUnit,[ToString.mk],[ToString, PUnit]]
[Nat.succ_ne_zero,[],[Ne, Nat.succ, OfNat.ofNat]]
[System.FilePath.extension,[Option.bind, System.FilePath.fileName, Unit.unit, dite, Eq, Eq.symm, Option, String, String.revPosOf, Char.ofNat, Option.none, Option.some, String.extract, HAdd.hAdd, OfNat.ofNat, String.bsize],[Option, String]]
[instDecidableIff.proof_1,[Iff.intro],[Iff]]
[Lean.isSubScriptAlnum,[or, Lean.isNumericSubscript, and, Decidable.decide, LE.le, OfNat.ofNat, Char.val],[Bool]]
[Lean.Syntax.getSepArgs,[Array.getSepElems, Lean.Syntax.getArgs],[Array, Lean.Syntax]]
[unexpandEqNDRec,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Array.modifyM.proof_1,[Eq.symm, Array.size_set, Fin.mk, arbitrary],[Eq, Array.size, Array.set, Fin.mk, arbitrary]]
[Except.error.injEq,[Eq.propIntro, Eq.refl, Except.error, Eq.symm, eq_of_heq, HEq.refl],[Eq, Except.error]]
[«term_≠_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Squash.mk,[Quot.mk, True],[Squash]]
[ByteArray.foldlMUnsafe.fold,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bind.bind, ByteArray.uget, lcProof, ByteArray.foldlMUnsafe.fold, HAdd.hAdd, OfNat.ofNat],[]]
[instToBoolOption,[ToBool.mk, Option.toBool],[ToBool, Option]]
[Lean.MonadNameGenerator.noConfusionType,[],[]]
[Lean.Name.instAppendName,[Append.mk, Lean.Name.append],[Append, Lean.Name]]
[true_iff,[propext, Iff.intro, Iff.mp, trivial],[Eq, Iff, True]]
[UInt32.div,[UInt32.mk, HDiv.hDiv, UInt32.val],[UInt32]]
[HShiftRight.hShiftRight,[],[]]
[String.prev,[String.Pos, ite, Eq, OfNat.ofNat, PProd.fst],[String.Pos]]
[Append.noConfusionType,[],[]]
[«stx_*»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[System.Platform.isOSX,[System.Platform.getIsOSX, Unit.unit],[Bool]]
[IO.FS.DirEntry.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.FS.DirEntry.mk, HAdd.hAdd, OfNat.ofNat]]
[List.rotateLeft,[ite, LE.le, OfNat.ofNat, HAppend.hAppend],[List]]
[List.lengthTRAux,[Nat, PProd.fst, Nat.succ],[Nat]]
[Lean.Syntax.mkScientificLit,[Lean.Syntax.mkLit, Lean.scientificLitKind],[Lean.Syntax]]
[solve,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[StateT.run_set,[rfl],[Eq, StateT.run, MonadStateOf.set, Pure.pure, Prod.mk, PUnit.unit]]
[Nat.ctor_eq_zero,[rfl],[Eq, Nat.zero, OfNat.ofNat]]
[CoeTC.coe,[],[]]
[Ne.elim,[],[False]]
[Nat.lt_of_lt_of_eq,[],[LT.lt]]
[Lean.Syntax.unsetTrailing,[Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Lean.Syntax, Lean.Syntax.getTailInfo, Lean.Syntax.setTailInfo, Lean.SourceInfo.original, String.toSubstring],[Lean.Syntax]]
[ite,[],[]]
[Fin.instHModFinNatFin,[HMod.mk, Fin.modn],[HMod, Fin, Nat]]
[Lean.Parser.Tactic.Conv.convRepeat_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[IO.Error.illegalOperation.inj,[And.intro],[And, Eq]]
[String.instAppendString,[Append.mk, String.append],[Append, String]]
[instHashableUInt16,[Hashable.mk, UInt16.toUInt64],[Hashable, UInt16]]
[OptionT.instMonadExceptOfOptionT,[MonadExceptOf.mk, OptionT.mk, throwThe, tryCatchThe],[MonadExceptOf, OptionT]]
[List.format,[Unit.unit, List.cons, Std.Format, Std.Format.text, Std.Format.sbracket, Std.Format.joinSep, HAppend.hAppend, Std.Format.line],[Std.Format]]
[Std.Range.step,[],[Nat]]
[BaseIO.toIO,[liftM],[IO]]
[Lean.Parser.Tactic.skip,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[UInt16.toUInt32,[Nat.toUInt32, UInt16.toNat],[UInt32]]
[instToStringExcept,[ToString.mk, String, HAppend.hAppend, ToString.toString],[ToString, Except]]
[Lean.Syntax.noConfusionType,[],[]]
[FloatArray.forInUnsafe.loop,[ite, LT.lt, Bind.bind, Pure.pure, FloatArray.forInUnsafe.loop, HAdd.hAdd, OfNat.ofNat],[]]
[Lean.Syntax.toNat,[Unit.unit, Nat, Lean.Syntax.isNatLit?, OfNat.ofNat],[Nat]]
[Subtype.instDecidableEqSubtype,[Decidable, Eq, Subtype.mk, dite, Decidable.isTrue, Subtype.instDecidableEqSubtype.proof_1, Decidable.isFalse, Subtype.instDecidableEqSubtype.proof_2],[DecidableEq, Subtype]]
[instHashableUInt32,[Hashable.mk, UInt32.toUInt64],[Hashable, UInt32]]
[Lean.Macro.Methods.hasDecl,[],[Lean.MacroM, Bool]]
[Nat.succ_eq_add_one,[rfl],[Eq, Nat.succ, HAdd.hAdd, OfNat.ofNat]]
[Array.binInsertM,[ite, Eq, Array.isEmpty, Bool.true, Bind.bind, Unit.unit, Pure.pure, Array.push, Array.get!, OfNat.ofNat, Array.insertAt, not, Array.modifyM, Array.back, HSub.hSub, Array.size],[Array]]
[Fin.mul,[Fin, Fin.mk, HMod.hMod, HMul.hMul, Fin.mul.proof_1],[Fin]]
[monadFunctorRefl,[MonadFunctorT.mk],[MonadFunctorT]]
[Nat.mul_eq,[rfl],[Eq, Nat.mul, HMul.hMul]]
[ByteArray.push,[ByteArray, ByteArray.mk, Array.push],[ByteArray]]
[Nat.add_zero,[rfl],[Eq, HAdd.hAdd, OfNat.ofNat]]
[dif_eq_if,[Eq, dite, ite, rfl],[Eq, dite, ite]]
[instHAndThen,[HAndThen.mk, AndThen.andThen],[HAndThen]]
[instMonadWithReaderOf,[MonadWithReaderOf.mk, MonadFunctorT.monadMap, withTheReader],[MonadWithReaderOf]]
[StateRefT'.lift,[],[StateRefT']]
[Lean.Parser.Tactic.Conv.reduce,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Decidable.decide,[Bool.false, Bool.true],[Bool]]
[Array.findIdx?.loop.proof_2,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, OfNat.ofNat, Array.size, Eq.symm, Nat.add_comm, Nat.add_assoc, rfl],[Eq, HAdd.hAdd, OfNat.ofNat, Array.size]]
[ByteArray.forIn.loop.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self],[LE.le, ByteArray.size]]
[Lean.mkIdentFromRef,[Bind.bind, Lean.MonadRef.getRef, Pure.pure, Lean.mkIdentFrom],[Lean.Syntax]]
[Lean.Syntax.node.sizeOf_spec,[congrArg, Nat.add, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf, Eq.trans, Eq.refl, List.nil, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec],[Eq, SizeOf.sizeOf, Lean.Syntax.node, HAdd.hAdd, OfNat.ofNat]]
[charToHex,[HAppend.hAppend, hexDigitRepr],[String]]
[System.FilePath.mk.injEq,[Eq.propIntro, Eq.refl, System.FilePath.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, System.FilePath.mk]]
[map_eq_pure_bind,[Eq.mpr, Eq.refl, Eq, Functor.map, Bind.bind, Pure.pure, Eq.symm, LawfulMonad.bind_pure_comp, rfl],[Eq, Functor.map, Bind.bind, Pure.pure]]
[String.length,[Nat, List.length],[Nat]]
[IO.FS.withIsolatedStreams,[Bind.bind, liftM, IO.mkRef, IO.FS.Stream.Buffer.mk, IO.withStdin, IO.FS.Stream.ofBuffer, IO.withStdout, IO.withStderr, ST.Ref.get, Pure.pure, Prod.mk],[Prod, String]]
[List.forA,[Unit.unit, PUnit, Pure.pure, PUnit.unit, SeqRight.seqRight, PProd.fst],[PUnit]]
[UInt8.toUInt64,[Nat.toUInt64, UInt8.toNat],[UInt64]]
[IO.FS.Stream.Buffer.data,[],[ByteArray]]
[String.str,[String.push],[String]]
[MonadExcept.orElse,[MonadExcept.tryCatch, Unit.unit],[]]
[Subsingleton.noConfusionType,[],[]]
[HMod.hMod,[],[]]
[liftCoeM,[Bind.bind, liftM, Pure.pure, coe],[]]
[Lean.Macro.State.noConfusionType,[],[]]
[List.head?,[Unit.unit, Option, Option.none, Option.some],[Option]]
[System.instDecidableEqFilePath,[Decidable, Eq, dite, Decidable.isTrue, rfl, Decidable.isFalse],[DecidableEq, System.FilePath]]
[ForIn.noConfusionType,[],[]]
[fix,[fixCore1, arbitrary],[]]
[decPropToBool,[CoeDep.mk, Decidable.decide],[CoeDep, Bool]]
[Lean.Parser.Tactic.casesTarget,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[Array.mapSepElemsM,[OfNat.ofNat, List.toArray, List.nil],[Array, Lean.Syntax]]
[instSubUInt16,[Sub.mk, UInt16.sub],[Sub, UInt16]]
[String.toLower,[String.map, Char.toLower],[String]]
[floatDecLe,[Float.decLe],[Decidable, LE.le]]
[Array.toArrayLit.proof_1,[Nat.le_refl, Array.size],[LE.le, Array.size]]
[Lean.Macro.addMacroScope,[Bind.bind, MonadReader.read, Pure.pure, Lean.addMacroScope, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope],[Lean.MacroM, Lean.Name]]
[Lean.MonadQuotation.withFreshMacroScope,[],[]]
[Lean.Parser.Tactic.rwSeq,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Int.ofNat.injEq,[Eq.propIntro, Eq.refl, Int.ofNat, Eq.symm, eq_of_heq, HEq.refl],[Eq, Int.ofNat]]
[Lean.Parser.Tactic.anyGoals,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Float.ofInt,[Float, Float.ofNat, Float.neg, Nat.succ],[Float]]
[UInt8.decEq.proof_1,[rfl],[Eq, UInt8.mk]]
[MonadFunctor.noConfusionType,[],[]]
[instDivUInt16,[Div.mk, UInt16.div],[Div, UInt16]]
[Mul.noConfusionType,[],[]]
[Substring.isEmpty,[BEq.beq, Substring.bsize, OfNat.ofNat],[Bool]]
[PSigma.noConfusionType,[],[]]
[Nat.lt_eq,[rfl],[Eq, Nat.lt, LT.lt]]
[UInt32.toUInt8,[Nat.toUInt8, UInt32.toNat],[UInt8]]
[Lean.Parser.Tactic.tacticLet_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Except.tryCatch,[Except, Except.ok],[Except]]
[Nat.sub_self,[Unit.unit, Eq, HSub.hSub, OfNat.ofNat, Eq.mpr, Eq.refl, Nat.sub_zero, rfl, Nat.succ, Nat.succ_sub_succ, PProd.fst],[Eq, HSub.hSub, OfNat.ofNat]]
[instCoeTail,[CoeTail.mk, coeFun],[CoeTail]]
[Except.toBool,[Bool, Bool.true, Bool.false],[Bool]]
[Bool.and_self,[rfl, Eq.symm, Eq.refl],[Eq, and]]
[Array.mapIdxM.map.proof_2,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, OfNat.ofNat, Array.size, Eq.symm, Nat.add_comm, Nat.add_assoc, rfl],[Eq, HAdd.hAdd, OfNat.ofNat, Array.size]]
[CoeTail.coe,[],[]]
[Substring.startPos,[],[String.Pos]]
[FloatArray.data,[],[Array, Float]]
[«term#[_,]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false],[Lean.ParserDescr]]
[ByteArray.foldl,[Id.run, ByteArray.foldlM],[]]
[Decidable.not_and_iff_or_not,[Iff.intro, Decidable.isFalse, Decidable.isTrue, Or, Not, absurd, And.intro, Or.inr, Or.inl, False],[Iff, Not, And, Or]]
[Lean.Parser.Syntax.addPrio,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[List.eraseRepsAux,[List, List.reverse, List.cons, Unit.unit, BEq.beq, PProd.fst],[List]]
[Iff.mp,[],[]]
[«term_∨_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[StateCpsT.runK_bind_modify,[rfl],[Eq, StateCpsT.runK, Bind.bind, modify, PUnit.unit]]
[Lean.NameGenerator.mk.inj,[And.intro],[And, Eq]]
[Lean.«command_Unif_hint___Where_|-⊢_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.unifConstraintElem, Lean.unifConstraint],[Lean.ParserDescr]]
[not_false,[id],[Not, False]]
[UInt8.ofNatCore,[UInt8.mk, Fin.mk],[UInt8]]
[Classical.skolem,[Iff.intro, Classical.axiomOfChoice, Exists, Exists.intro],[Iff, Exists]]
[instDecidableEqChar,[Decidable, Eq, decEq, Char.val, Decidable.isTrue, Char.eq_of_val_eq, Decidable.isFalse, Char.ne_of_val_ne],[DecidableEq, Char]]
[instOrOpUInt8,[OrOp.mk, UInt8.lor],[OrOp, UInt8]]
[instOrdUInt8,[Ord.mk, compareOfLessAndEq],[Ord, UInt8]]
[Functor.noConfusionType,[],[]]
[instMonadFinallyEIO,[inferInstanceAs, MonadFinally, EStateM, IO.RealWorld],[MonadFinally, EIO]]
[PointedType.type,[],[]]
[Lean.Parser.Tactic.changeWith,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[MonadExceptOf.noConfusionType,[],[]]
[Lean.Macro.Methods.resolveNamespace?,[],[Lean.MacroM, Option, Lean.Name]]
[«term_<->_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Syntax.mkStrLit,[Lean.Syntax.mkLit, Lean.strLitKind, String.quote],[Lean.Syntax]]
[decide_eq_true,[Eq, Decidable.decide, Bool.true, rfl, absurd],[Eq, Decidable.decide, Bool.true]]
[Lean.Syntax.decodeScientificLitVal?,[ite, Eq, BEq.beq, OfNat.ofNat, Bool.true, Option.none, Char.isDigit, Lean.Syntax.decodeScientificLitVal?.decodeAfterExp, Lean.Syntax.decodeScientificLitVal?.decodeExp, Lean.Syntax.decodeScientificLitVal?.decodeAfterDot, Lean.Syntax.decodeScientificLitVal?.decode],[Option, Prod, Nat, Bool]]
[Nat.decLt,[Nat.decLe, Nat.succ],[Decidable, LT.lt]]
[MonadState.modifyGet,[],[]]
[Array.findIdxM?,[Bind.bind, ForIn.forIn, MProd.mk, Option.none, ite, Eq, Bool.true, Pure.pure, ForInStep.done, Option.some, PUnit.unit, Unit.unit, Option, Nat, MProd.fst],[Option, Nat]]
[invImage,[WellFoundedRelation.mk, InvImage, WellFoundedRelation.rel, invImage.proof_1],[WellFoundedRelation]]
[Array.getIdx?,[Array.findIdx?, BEq.beq],[Option, Nat]]
[Array.set!,[Array.setD],[Array]]
[Nat.mul,[Nat, OfNat.ofNat, Nat.add, PProd.fst],[Nat]]
[CoeSort.noConfusionType,[],[]]
[Array.find?,[Id.run, Array.findM?],[Option]]
[instDecidableEqUInt32,[UInt32.decEq],[DecidableEq, UInt32]]
[Lean.Parser.Tactic.Conv.nestedTactic,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[List.allM,[Unit.unit, Bool, Pure.pure, Bool.true, Bind.bind, PProd.fst, Bool.false],[Bool]]
[instSizeOfName,[SizeOf.mk, Lean.Name.sizeOf],[SizeOf, Lean.Name]]
[Bool.and_false,[rfl, Eq.symm, Eq.refl],[Eq, and, Bool.false]]
[Nat.not_succ_le_zero,[False, Eq.refl, OfNat.ofNat, HEq.refl],[False]]
[instHashableString,[Hashable.mk, String.hash],[Hashable, String]]
[Array.filterMapM,[Array.foldlM, Bind.bind, Unit.unit, Array, Pure.pure, Array.push, List.toArray, List.nil],[Array]]
[Nat.allM,[Nat.allM.loop],[Bool]]
[Nat.pow,[Unit.unit, Nat, OfNat.ofNat, Nat.mul, PProd.fst],[Nat]]
[instReprAtomUSize,[ReprAtom.mk],[ReprAtom, USize]]
[PProd.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, PProd.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, PProd.mk, And]]
[String.get,[Char, arbitrary, ite, Eq, PProd.fst, HAdd.hAdd, String.csize, OfNat.ofNat],[Char]]
[prioMid,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[cond,[Unit.unit],[]]
[Nat.le_antisymm,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Eq, rfl, absurd, Nat.lt_of_le_of_lt, Nat.lt_irrefl],[Eq]]
[instDecidableEqUSize,[USize.decEq],[DecidableEq, USize]]
[default.sizeOf,[OfNat.ofNat],[Nat]]
[Array.elem,[Array.contains],[Bool]]
[Array.forIn.loop.proof_1,[Nat.lt_of_le_of_lt, Nat.sub_le, HSub.hSub, Array.size, OfNat.ofNat, Nat.sub_lt, Nat.zero_lt_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self, of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, HSub.hSub, Array.size, OfNat.ofNat]]
[Hashable.noConfusionType,[],[]]
[HDiv.noConfusionType,[],[]]
[observing,[MonadExcept.tryCatch, Bind.bind, Pure.pure, Except.ok, Except.error],[Except]]
[Pow.noConfusionType,[],[]]
[FloatArray.forIn.loop.proof_1,[Nat.lt_of_le_of_lt, Nat.sub_le, HSub.hSub, FloatArray.size, OfNat.ofNat, Nat.sub_lt, Nat.zero_lt_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self, of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, HSub.hSub, FloatArray.size, OfNat.ofNat]]
[Lean.Parser.Tactic.failIfSuccess,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Array.toListLitAux.proof_2,[Nat.lt_of_lt_of_eq, Nat.lt_of_lt_of_le, Nat.lt_succ_self],[LT.lt]]
[instModUInt16,[Mod.mk, UInt16.mod],[Mod, UInt16]]
[modifyThe,[MonadStateOf.modifyGet, Prod.mk, PUnit.unit],[PUnit]]
[ReaderT.run_map,[rfl],[Eq, ReaderT.run, Functor.map]]
[Array.insertionSort.traverse,[Unit.unit, Array, dite, LT.lt, Array.size, PProd.fst, Array.insertionSort.swapLoop, HAdd.hAdd, OfNat.ofNat],[Array]]
[ReaderT.instAlternativeReaderT,[Alternative.mk, ReaderT.failure, ReaderT.orElse],[Alternative, ReaderT]]
[IO.FS.Stream.noConfusionType,[],[]]
[List.foldrM,[Pure.pure, Bind.bind, PProd.fst],[]]
[Quot.inductionOn,[Quot.ind],[]]
[StateT.orElse,[HOrElse.hOrElse, Unit.unit],[StateT]]
[Except.instMonadExcept,[Monad.mk],[Monad, Except]]
[Fin.shiftLeft,[Fin, Fin.mk, HMod.hMod, HShiftLeft.hShiftLeft, Fin.shiftLeft.proof_1],[Fin]]
[Lean.Syntax.isMissing,[Unit.unit, Lean.Syntax.node, Lean.Syntax.atom, Lean.Syntax.ident, Bool, Bool.true, Bool.false],[Bool]]
[instReprTuple,[ReprTuple.mk, List.cons, repr],[ReprTuple]]
[Subrelation.accessible,[Subrelation.accessible.proof_1],[Acc]]
[List.getLastD,[List.getLast, List.cons, List.getLastD.proof_1],[]]
[Array.foldrMUnsafe,[ite, LE.le, Array.size, LT.lt, USize.ofNat, Pure.pure, Array.foldrMUnsafe.fold],[]]
[instToStringList,[ToString.mk, List.toString],[ToString, List]]
[Array.instCoeSubarrayArray,[Coe.mk, Array.ofSubarray],[Coe, Subarray, Array]]
[Task.get,[],[]]
[UInt16.decLe,[Decidable, LE.le, inferInstanceAs],[Decidable, LE.le]]
[instDecidableEqUInt8,[UInt8.decEq],[DecidableEq, UInt8]]
[FloatArray.instForInFloatArrayFloat,[ForIn.mk, FloatArray.forIn],[ForIn, FloatArray, Float]]
[Quot.indBeta,[rfl],[Eq, Quot.ind, Quot.mk]]
[instHModUInt64NatUInt64,[HMod.mk, UInt64.modn],[HMod, UInt64, Nat]]
[ExceptCpsT.runCatch,[Pure.pure],[]]
[Id.instMonadId,[Monad.mk],[Monad, Id]]
[instToStreamSubarraySubarray,[ToStream.mk],[ToStream, Subarray]]
[«term_^_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Prod.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Prod.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Prod.mk, And]]
[Thunk.bind,[Thunk.mk, Thunk.get],[Thunk]]
[RandomGen.split,[],[Prod]]
[HPow.noConfusionType,[],[]]
[stx!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[fix6,[fixCore6, arbitrary],[]]
[Option.map,[Option.bind, Function.comp, Option.some],[Option]]
[StateRefT'.run',[Bind.bind, StateRefT'.run, Pure.pure],[]]
[instReprSubarray,[Repr.mk, HAppend.hAppend, repr, Subarray.toArray, Std.Format.text],[Repr, Subarray]]
[Array.instReprArray,[Repr.mk, Std.Format, ite, Eq, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Std.Format.text, Std.Format.bracketFill, Std.Format.joinSep, Array.toList, HAppend.hAppend, Std.Format.line],[Repr, Array]]
[Lean.Meta.Simp.Config.etaStruct,[],[Bool]]
[seq_eq_bind_map,[Eq.mpr, Eq.refl, Eq, Seq.seq, Bind.bind, Functor.map, Eq.symm, LawfulMonad.bind_map, rfl],[Eq, Seq.seq, Bind.bind, Functor.map]]
[«term_↔_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[ite_congr,[Decidable.em, Eq.mpr, Eq.refl, Eq, ite, if_pos, Eq.symm, if_neg],[Eq, ite]]
[instReprUnit,[Repr.mk, Std.Format.text],[Repr, Unit]]
[Setoid.trans,[Equivalence.trans, Setoid.iseqv],[HasEquiv.Equiv]]
[instLTUInt32,[LT.mk, LT.lt, UInt32.val],[LT, UInt32]]
[Nat.log2,[WellFounded.fix, Nat.log2.proof_1, dite, GE.ge, OfNat.ofNat, HAdd.hAdd, HDiv.hDiv, Eq.refl, Nat.zero, HEq.refl, absurd, of_decide_eq_false, Decidable.decide, Nat.succ, LT.lt, of_decide_eq_true, Bool.true, Eq.mpr, Nat.div_eq, ite, And, LE.le, HSub.hSub, if_pos, And.intro, Nat.succ_lt_succ, Nat.zero_lt_succ, Nat.lt_trans, PProd.fst, PProd.snd, Nat.lt_succ_self],[Nat]]
[instModUInt8,[Mod.mk, UInt8.mod],[Mod, UInt8]]
[instDivUInt32,[Div.mk, UInt32.div],[Div, UInt32]]
[StateCpsT.run',[StateCpsT.runK, Pure.pure],[]]
[Iff.trans,[Iff.intro, Iff.mp, Iff.mpr],[Iff]]
[«term_::_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Fin.lor,[Fin, Fin.mk, HMod.hMod, Nat.lor, Fin.lor.proof_1],[Fin]]
[instOrdChar,[Ord.mk, compareOfLessAndEq],[Ord, Char]]
[Std.Format.defUnicode,[Bool.true],[Bool]]
[coeFun,[CoeFun.coe],[]]
[UInt16.lt,[LT.lt, UInt16.val],[]]
[Lean.Macro.throwError,[Bind.bind, Lean.MonadRef.getRef, MonadExcept.throw, Lean.Macro.Exception.error],[Lean.MacroM]]
[OptionT.instMonadExceptOfUnitOptionT,[MonadExceptOf.mk, OptionT.fail, OptionT.tryCatch],[MonadExceptOf, Unit, OptionT]]
[Array.getSepElems,[Array.getEvenElems],[Array]]
[UInt16.xor,[UInt16.mk, Fin.xor, UInt16.val],[UInt16]]
[IO.Process.Output.stdout,[],[String]]
[System.FilePath.isDir,[Bind.bind, EIO.toBaseIO, System.FilePath.metadata, BaseIO, Bool, Pure.pure, BEq.beq, IO.FS.Metadata.type, IO.FS.FileType.dir, Bool.false],[BaseIO, Bool]]
[String.Iterator.next,[String.Iterator, String.Iterator.mk, String.next],[String.Iterator]]
[Substring.str,[],[String]]
[Array.size_push,[List.length_concat, Array.data],[Eq, Array.size, Array.push, HAdd.hAdd, OfNat.ofNat]]
[instXorUInt16,[Xor.mk, UInt16.xor],[Xor, UInt16]]
[List.cons_append,[rfl],[Eq, HAppend.hAppend, List.cons]]
[System.instReprFilePath,[Repr.mk, Repr.addAppParen, HAppend.hAppend, Std.Format.text, repr, System.FilePath.toString],[Repr, System.FilePath]]
[Nat.ibelow,[True, And],[]]
[Lean.MonadQuotation.getMainModule,[],[Lean.Name]]
[Fin.instOfNatFinHAdd,[OfNat.mk, Fin.ofNat],[OfNat, Fin]]
[Array.noConfusionType,[],[]]
[eq_false',[propext, Iff.intro, absurd, False.elim],[Eq, False]]
[IO.Error.noFileOrDirectory.inj,[And.intro],[And, Eq]]
[USize.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, USize.mk, HAdd.hAdd, OfNat.ofNat]]
[Array.get?,[dite, LT.lt, Array.size, Option.some, Array.get, Fin.mk, Option.none],[Option]]
[ByteArray.forIn.loop.proof_1,[Nat.lt_of_le_of_lt, Nat.sub_le, HSub.hSub, ByteArray.size, OfNat.ofNat, Nat.sub_lt, Nat.zero_lt_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self, of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, HSub.hSub, ByteArray.size, OfNat.ofNat]]
[FloatSpec.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, FloatSpec.mk, Eq.symm, eq_of_heq, DecidableRel, HEq.refl],[Eq, FloatSpec.mk, And, HEq]]
[Applicative.toPure,[],[Pure]]
[Substring.hasBeq,[BEq.mk, Substring.beq],[BEq, Substring]]
[Nat.succ_sub_succ_eq_sub,[rfl, congrArg, Nat.pred],[Eq, HSub.hSub, Nat.succ]]
[Fin.modn_lt,[LT.lt, Fin.val, HMod.hMod, Nat.lt_of_le_of_lt, Nat.mod_le, Nat.mod_lt],[LT.lt, Fin.val, HMod.hMod]]
[«term_<&>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[inferInstance,[],[]]
[instAndOpUInt32,[AndOp.mk, UInt32.land],[AndOp, UInt32]]
[ExceptCpsT.run_bind_throw,[rfl],[Eq, ExceptCpsT.run, Bind.bind, MonadExcept.throw]]
[Nat.sub_lt,[LT.lt, HSub.hSub, absurd, Nat.lt_irrefl, OfNat.ofNat, Eq.symm, Nat.succ_sub_succ_eq_sub],[LT.lt, HSub.hSub]]
[LE.le,[],[]]
[unexpandExists,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[fixCore4,[bfix4, USize.size],[]]
[«term↑_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Array.extract,[Array.ofSubarray, Array.toSubarray],[Array]]
[bind_pure_unit,[Eq.mpr, Eq.refl, Eq, Bind.bind, Pure.pure, PUnit.unit, bind_pure, rfl],[Eq, Bind.bind, Pure.pure, PUnit.unit]]
[OrElse.noConfusionType,[],[]]
[Lean.mkNullNode,[Lean.mkNode, Lean.nullKind],[Lean.Syntax]]
[Lean.Name.below,[PUnit, PProd],[]]
[instSubsingletonDecidable,[instSubsingletonDecidable.proof_1],[Subsingleton, Decidable]]
[instShiftLeftUInt32,[ShiftLeft.mk, UInt32.shiftLeft],[ShiftLeft, UInt32]]
[Stream.noConfusionType,[],[]]
[String.instDecidableEqIterator,[Decidable, Eq, dite, Decidable.isTrue, rfl, Decidable.isFalse],[DecidableEq, String.Iterator]]
[IO.RealWorld,[Unit],[]]
[UInt16.div,[UInt16.mk, HDiv.hDiv, UInt16.val],[UInt16]]
[repr,[Repr.reprPrec, OfNat.ofNat],[Std.Format]]
[String.find,[String.findAux, String.bsize, OfNat.ofNat],[String.Pos]]
[Nat.gcd_zero_right,[of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, Nat.gcd, Nat.zero_eq, OfNat.ofNat, Nat.gcd_zero_left, eq_true_of_decide, Eq.refl, Bool.true, Eq.symm, Nat.gcd_succ, Nat.zero_mod, Nat.succ, eq_self],[Eq, Nat.gcd, OfNat.ofNat]]
[instToStringFloatArray,[ToString.mk, List.toString, FloatArray.toList],[ToString, FloatArray]]
[Lean.mkFreshId,[Bind.bind, Lean.MonadNameGenerator.getNGen, Lean.MonadNameGenerator.setNGen, Lean.NameGenerator.next, Pure.pure],[Lean.Name]]
[instSubsingletonStateM,[instSubsingletonStateM.proof_1],[Subsingleton, StateM]]
[List.toString,[Unit.unit, String, HAppend.hAppend, List.toStringAux, Bool.true, List.cons],[String]]
[IO.Error.mkOtherError,[IO.Error.otherError],[IO.Error]]
[coeTail,[CoeTail.coe],[]]
[List.eraseDupsAux,[List, List.reverse, Unit.unit, List.elem, PProd.fst, List.cons],[List]]
[List.instLTList,[LT.mk, List.lt],[LT, List]]
[decEq,[],[Decidable, Eq]]
[Lean.Syntax.setArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.node],[Lean.Syntax]]
[HasEquiv.Equiv,[],[]]
[Nat.instDivNat,[Div.mk, Nat.div],[Div, Nat]]
[Nat.add_left_cancel,[Eq.mpr, implies_congr, congr, congrArg, Eq, Eq.trans, congrFun, HAdd.hAdd, Nat.zero_eq, Nat.zero_add, Eq.refl, Nat.succ_add, Nat.succ.injEq],[Eq]]
[TC.accessible.proof_1,[Acc.intro, Acc.inv],[Acc, TC]]
[List.below,[PUnit, PProd],[]]
[Nat.gcd_one_left,[Eq.mpr, Eq.refl, Eq, Nat.gcd, OfNat.ofNat, Nat.gcd_succ, HMod.hMod, Nat.succ, Nat.mod_one, rfl],[Eq, Nat.gcd, OfNat.ofNat]]
[«term_&&&_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.interpolatedStrKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[IO.Error.mkResourceVanished,[IO.Error.resourceVanished],[IO.Error]]
[Sub.sub,[],[]]
[Array.setD,[dite, LT.lt, Array.size, Array.set, Fin.mk],[Array]]
[Id.instOfNatId,[inferInstanceAs, OfNat],[OfNat, Id]]
[MonadLiftT.monadLift,[],[]]
[instShiftRightUInt16,[ShiftRight.mk, UInt16.shiftRight],[ShiftRight, UInt16]]
[Lean.Name.toStringWithSep,[Unit.unit, Lean.Name.str, Lean.Name.num, String, Lean.Name.toStringWithSep.maybeEscape, ToString.toString, HAppend.hAppend, PProd.fst, Nat.repr],[String]]
[Lean.Syntax.isStrLit?,[Option.none, Option, String, Lean.Syntax.isLit?, Lean.strLitKind, Lean.Syntax.decodeStrLit],[Option, String]]
[Prod.lex,[WellFoundedRelation.mk, Prod.Lex, WellFoundedRelation.rel, Prod.lex.proof_1],[WellFoundedRelation, Prod]]
[ExceptT.pure,[ExceptT.mk, Pure.pure, Except.ok],[ExceptT]]
[«term_==_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Nat.mul_lt_mul_of_pos_right,[Nat.mul_lt_mul_of_pos_left, Nat.mul_comm],[LT.lt, HMul.hMul]]
[EStateM.instMonadExceptOfEStateM,[MonadExceptOf.mk, EStateM.throw, EStateM.tryCatch],[MonadExceptOf, EStateM]]
[instDecidableEqSum.proof_3,[rfl],[Eq, Sum.inr]]
[instDecidableDite,[Decidable, dite],[Decidable, dite]]
[Option.some.inj,[],[Eq]]
[PUnit.subsingleton,[rfl, Eq.symm, Eq.refl],[Eq]]
[FloatArray.foldlMUnsafe,[ite, LT.lt, LE.le, FloatArray.size, USize.ofNat, Pure.pure, FloatArray.foldlMUnsafe.fold],[]]
[Lean.MacroScopesView.review,[Unit.unit, Lean.Name, Lean.MacroScopesView.scopes, Lean.MacroScopesView.name, List.foldl, Lean.Name.mkNum],[Lean.Name]]
[Lean.instEval,[Lean.Eval.mk, IO.println, ToString.toString, Unit.unit],[Lean.Eval]]
[instSubsingletonSquash,[instSubsingletonSquash.proof_1],[Subsingleton, Squash]]
[Nat.lt_of_succ_lt,[Nat.le_of_succ_le],[LT.lt]]
[Nat.all,[not, Nat.any],[Bool]]
[Std.Format.instAppendFormat,[Append.mk, Std.Format.append],[Append, Std.Format]]
[USize.decLe,[Decidable, LE.le, inferInstanceAs],[Decidable, LE.le]]
[Classical.exists_true_of_nonempty,[Exists, True, Exists.intro, trivial],[Exists, True]]
[Lean.ParserDescr.noConfusionType,[],[]]
[Array.sequenceMap,[Array.size, OfNat.ofNat, Array.empty, Array.sequenceMap.loop],[Array]]
[noConfusionEnum.proof_1,[Eq.symm, if_pos],[Eq, ite]]
[Char.le,[LE.le, Char.val],[]]
[instMonadST,[inferInstanceAs, Monad, EST, Empty],[Monad, ST]]
[List.toArrayAux,[Array, PProd.fst, Array.push],[Array]]
[Subtype.existsOfSubtype.proof_1,[Exists, Exists.intro],[Exists]]
[Subarray.stop,[],[Nat]]
[UInt8.mod,[UInt8.mk, HMod.hMod, UInt8.val],[UInt8]]
[StateT.instMonadExceptOfStateT,[MonadExceptOf.mk, Function.comp, StateT.lift, throwThe, tryCatchThe],[MonadExceptOf, StateT]]
[IO.FS.Stream.flush,[],[IO, Unit]]
[instReprAtomUInt8,[ReprAtom.mk],[ReprAtom, UInt8]]
[Lean.fieldIdxKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[instAndOpUInt8,[AndOp.mk, UInt8.land],[AndOp, UInt8]]
[Array.appendList,[List.foldl, Array.push],[Array]]
[List.intercalate,[List.join, List.intersperse],[List]]
[StateCpsT,[],[]]
[Std.Format.nil.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Std.Format.nil, OfNat.ofNat]]
[Lean.Parser.Tactic.intros,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[IO.AccessRight.read,[],[Bool]]
[Task.Priority.max,[OfNat.ofNat],[Task.Priority]]
[instDecidableEqProd.proof_2,[absurd],[False]]
[IO.Process.Output.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Process.Output.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Process.Output.mk, And]]
[Lean.withHeadRefOnly,[Bind.bind, Lean.MonadRef.getRef, Unit.unit, Lean.Syntax.getHead?, Lean.withRef],[]]
[StateT.run_lift,[rfl],[Eq, StateT.run, StateT.lift, Bind.bind, Pure.pure, Prod.mk]]
[«termExists_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[PSigma.fst,[],[]]
[Std.Format.joinSuffix,[Std.Format, Std.Format.nil, HAppend.hAppend, Std.ToFormat.format, PProd.fst],[Std.Format]]
[Lean.ParserDescr.ibelow,[True, And],[]]
[instDecidableEqSum.proof_1,[rfl],[Eq, Sum.inl]]
[instToStringSubtype,[ToString.mk, ToString.toString, Subtype.val],[ToString, Subtype]]
[Function.const,[],[]]
[Nat.pow_zero,[rfl],[Eq, HPow.hPow, OfNat.ofNat]]
[StateT.lift,[Bind.bind, Pure.pure, Prod.mk],[StateT]]
[Nat.lt,[Nat.le, Nat.succ],[]]
[Nat.fold,[Nat.foldAux],[]]
[instReprUInt64,[Repr.mk, repr, UInt64.toNat],[Repr, UInt64]]
[Setoid.symm,[Equivalence.symm, Setoid.iseqv],[HasEquiv.Equiv]]
[Fin.elim0,[absurd, Nat.not_lt_zero],[]]
[Classical.propComplete,[Or, Eq, True, False, Classical.em, Or.inl, propext, Iff.intro, True.intro, Or.inr, False.elim],[Or, Eq, True, False]]
[instInhabitedExceptT,[Inhabited.mk, MonadExcept.throw, arbitrary],[Inhabited, ExceptT]]
[instMulUSize,[Mul.mk, USize.mul],[Mul, USize]]
[ReprAtom.noConfusionType,[],[]]
[Lean.Parser.Tactic.simp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpStar, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[DoResultPRBC.break.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultPRBC.break, HAdd.hAdd, OfNat.ofNat]]
[IO.Error.mkResourceBusy,[IO.Error.resourceBusy],[IO.Error]]
[Acc.brecOn,[Acc.below.intro],[]]
[UInt64.le,[LE.le, UInt64.val],[]]
[Array.reverse,[OfNat.ofNat, Array.reverse.rev],[Array]]
[List.span,[List.spanAux, List.nil],[Prod, List]]
[Lean.unifConstraintElem,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.unifConstraint, Lean.ParserDescr.unary, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[DoResultBC.break.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultBC.break, HAdd.hAdd, OfNat.ofNat]]
[instReprULift,[Repr.mk, Repr.addAppParen, HAppend.hAppend, Std.Format.text, reprArg, ULift.down],[Repr, ULift]]
[IO.eprint,[Bind.bind, liftM, IO.getStderr, IO.FS.Stream.putStr, ToString.toString],[IO, Unit]]
[Int.lt,[LE.le, HAdd.hAdd, OfNat.ofNat],[]]
[Array.toListLitAux,[List, PProd.fst, Array.toListLitAux.proof_1, List.cons, Array.getLit, Array.toListLitAux.proof_2],[List]]
[ExceptT.run_throw,[rfl],[Eq, ExceptT.run, MonadExcept.throw, Pure.pure, Except.error]]
[IO.Error.unsupportedOperation.inj,[And.intro],[And, Eq]]
[instDecidableLe,[UInt32.decLe],[Decidable, LE.le]]
[instSubFloat,[Sub.mk, Float.sub],[Sub, Float]]
[Array.any,[Id.run, Array.anyM],[Bool]]
[«term_<_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Quotient.recOnSubsingleton₂.proof_2,[],[Subsingleton, Quotient.mk]]
[ForM.noConfusionType,[],[]]
[System.FilePath.toString,[],[String]]
[Lean.Meta.Simp.Config.mk.inj,[And.intro],[And, Eq]]
[Bool.or_false,[rfl, Eq.symm, Eq.refl],[Eq, or, Bool.false]]
[Nat.pow_le_pow_of_le_right,[LE.le, HPow.hPow, Nat.succ, Nat.lt_or_eq_or_le_succ, Nat.le_refl, Eq.symm],[LE.le, HPow.hPow]]
[Int.negOfNat,[Unit.unit, Int, OfNat.ofNat, Int.negSucc],[Int]]
[instInhabitedNonScalar,[Inhabited.mk, NonScalar.mk, arbitrary],[Inhabited, NonScalar]]
[Array.get,[List.get, Array.data, Fin.val, Array.get.proof_1],[]]
[instReprUInt32,[Repr.mk, repr, UInt32.toNat],[Repr, UInt32]]
[panicWithPosWithDecl,[panic, HAppend.hAppend, ToString.toString],[]]
[Lean.Meta.Simp.Config.noConfusionType,[],[]]
[Eq.propIntro,[propext, Iff.intro],[Eq]]
[Char.isAlphanum,[or, Char.isAlpha, Char.isDigit],[Bool]]
[UInt8.size,[OfNat.ofNat],[Nat]]
[PSigma.revLexAccessible,[PSigma.revLexAccessible.proof_1],[Acc, PSigma.RevLex, PSigma.mk]]
[Nat.div.proof_1,[WellFoundedRelation.wf, measure, id],[WellFounded, WellFoundedRelation.rel, measure, id]]
[Lean.expandBrackedBinders,[Bind.bind, Lean.MonadRef.getRef, Lean.expandBrackedBindersAux, List.toArray, List.cons, List.nil],[Lean.MacroM, Lean.Syntax]]
[controlAt,[Bind.bind, MonadControlT.liftWith, MonadControlT.restoreM],[]]
[FloatArray.foldlM,[dite, LE.le, FloatArray.size, FloatArray.foldlM.proof_1],[]]
[UInt16.toUInt64,[Nat.toUInt64, UInt16.toNat],[UInt64]]
[OptionT.orElse,[OptionT.mk, Bind.bind, Option.none, Option, Pure.pure, Option.some, Unit.unit],[OptionT]]
[instDecidableEqSum.proof_4,[absurd],[False]]
[Measure,[InvImage, LT.lt],[]]
[Lean.Parser.Tactic.delta,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Std.ToFormat.noConfusionType,[],[]]
[ofBoolUsing_eq_false,[of_decide_eq_false],[Not]]
[Prod.anyI,[Nat.anyAux, Prod.snd, HSub.hSub, Prod.fst],[Bool]]
[UInt64.mod,[UInt64.mk, HMod.hMod, UInt64.val],[UInt64]]
[Nat.min,[ite, LE.le],[Nat]]
[Nat.max,[ite, LE.le],[Nat]]
[String.Iterator.prevn,[String.Iterator, PProd.fst, String.Iterator.prev],[String.Iterator]]
[String.nextUntil,[String.nextWhile, not],[String.Pos]]
[emptyWf.proof_1,[WellFounded.intro, Acc.intro, Acc, emptyRelation, Eq.refl],[WellFounded, emptyRelation]]
[instSubsingleton,[instSubsingleton.proof_1],[Subsingleton]]
[instHashableProd,[Hashable.mk, UInt64, mixHash, Hashable.hash],[Hashable, Prod]]
[Lean.Parser.Tactic.simpLemma,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.Parser.Tactic.simpPre, Lean.Parser.Tactic.simpPost, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[Task.noConfusionType,[],[]]
[HMul.noConfusionType,[],[]]
[Decidable.of_not_not,[Decidable.byContradiction, absurd],[]]
[IO.FS.SystemTime.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FS.SystemTime.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.FS.SystemTime.mk, And]]
[withPtrEqUnsafe,[ite, Eq, BEq.beq, ptrAddrUnsafe, Bool.true, Unit.unit],[Bool]]
[ExceptCpsT.run_throw,[rfl],[Eq, ExceptCpsT.run, MonadExcept.throw, Pure.pure, Except.error]]
[instDecidableEqFin,[Decidable, Eq, decEq, Fin.val, Decidable.isTrue, Fin.eq_of_val_eq, Decidable.isFalse, Fin.ne_of_val_ne],[DecidableEq, Fin]]
[ByteArray.append,[ByteArray.copySlice, OfNat.ofNat, ByteArray.size, Bool.false],[ByteArray]]
[instSubsingletonDecidable.proof_1,[Subsingleton.intro, Eq, Decidable.isTrue, rfl, absurd, Decidable.isFalse],[Subsingleton, Decidable]]
[instDecidableAnd.proof_2,[And.left],[False]]
[map_congr,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Functor.map, funext, eq_self],[Eq, Functor.map]]
[Lean.Option.hasQuote,[Lean.Quote.mk, Unit.unit, Lean.Syntax, Lean.mkIdent, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.mkCApp, List.toArray, List.cons, Lean.Quote.quote, List.nil],[Lean.Quote, Option]]
[unsafeEIO,[unsafeBaseIO, EIO.toBaseIO],[Except]]
[List.redLength,[Unit.unit, Nat, OfNat.ofNat, Nat.succ, PProd.fst],[Nat]]
[optParam,[],[]]
[withPtrAddrUnsafe,[ptrAddrUnsafe],[]]
[Fin.mul.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, HMul.hMul]]
[Subarray.allM,[Array.allM, Subarray.as, Subarray.start, Subarray.stop],[Bool]]
[IO.FS.FileType.dir.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.FileType.dir, OfNat.ofNat]]
[IO.FS.Metadata.accessed,[],[IO.FS.SystemTime]]
[decidableOfDecidableOfIff,[dite, Decidable.isTrue, Iff.mp, Decidable.isFalse, decidableOfDecidableOfIff.proof_1],[Decidable]]
[Coe.coe,[],[]]
[LawfulFunctor.noConfusionType,[],[]]
[«termΣ_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Syntax.getNumArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Nat, Array.size, OfNat.ofNat],[Nat]]
[Array.forIn.loop.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self],[LE.le, Array.size]]
[Array.singleton,[Array.mkArray, OfNat.ofNat],[Array]]
[StateT.map,[Bind.bind, Prod, Pure.pure, Prod.mk],[StateT]]
[Fin.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Fin.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.case,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary],[Lean.ParserDescr]]
[ne_eq,[rfl],[Eq, Ne, Not]]
[Char.toNat,[UInt32.toNat, Char.val],[Nat]]
[instOrOpUInt64,[OrOp.mk, UInt64.lor],[OrOp, UInt64]]
[UInt16.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd],[UInt16]]
[Lean.githash,[Lean.getGithash, Unit.unit],[String]]
[Except.error.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Except.error, HAdd.hAdd, OfNat.ofNat]]
[Nat.mul_lt_mul_of_pos_left,[Nat.lt_of_lt_of_le, Nat.add_lt_add_left, Nat.mul, Nat.mul_le_mul_left, Nat.succ_le_of_lt, Nat.mul_succ],[LT.lt, HMul.hMul]]
[instMulNat,[Mul.mk, Nat.mul],[Mul, Nat]]
[instHAppend,[HAppend.mk, Append.append],[HAppend]]
[Lean.version.specialDesc,[Lean.version.getSpecialDesc, Unit.unit],[String]]
[instReprChar,[Repr.mk, Std.Format.text, Char.quote],[Repr, Char]]
[Lean.MacroM,[ReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State],[]]
[Lean.Parser.Tactic.existsIntro,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[instDecidableRelLeLeOfOrd,[inferInstanceAs, DecidableRel, Eq, Ordering.isLE, Ord.compare, Bool.true],[DecidableRel, LE.le]]
[OrOp.noConfusionType,[],[]]
[«stx_,+,?»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[Lean.Syntax.getSubstring?,[Lean.SourceInfo.original, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Option, Substring, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo, Option.some, Substring.mk, Substring.str, ite, Eq, Bool.true, Substring.startPos, Substring.stopPos, Option.none],[Option, Substring]]
[Nat.forM.loop,[Unit.unit, Unit, Pure.pure, Bind.bind, HSub.hSub, OfNat.ofNat, PProd.fst],[Unit]]
[instInhabitedUInt16,[Inhabited.mk, UInt16.ofNatCore, OfNat.ofNat, instInhabitedUInt16.proof_1],[Inhabited, UInt16]]
[UInt8.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, UInt8.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.MonadRef.withRef,[],[]]
[Nat.succ_pos,[Nat.zero_lt_succ],[LT.lt, OfNat.ofNat, Nat.succ]]
[instOrOpUInt32,[OrOp.mk, UInt32.lor],[OrOp, UInt32]]
[String.csize,[UInt32.toNat, Char.utf8Size],[Nat]]
[StateCpsT.runK_modify,[rfl],[Eq, StateCpsT.runK, modify, PUnit.unit]]
[ExceptCpsT.runCatch_bind_throw,[rfl],[Eq, ExceptCpsT.runCatch, Bind.bind, MonadExcept.throw, Pure.pure]]
[String.nextWhile,[String.bsize],[String.Pos]]
[instLEUSize,[LE.mk, USize.le],[LE, USize]]
[Lean.Syntax.isAtom,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Bool, Bool.true, Bool.false],[Bool]]
[StateRefT',[ReaderT, ST.Ref],[]]
[instOfNatUSize,[OfNat.mk, USize.ofNat],[OfNat, USize]]
[instDecidableEqProd.proof_3,[absurd],[False]]
[Except.noConfusionType,[],[]]
[System.FilePath.normalize,[ite, Eq, and, BEq.beq, List.length, System.FilePath.pathSeparators, OfNat.ofNat, not, Bool.true, System.FilePath.mk, String.map, List.contains, System.FilePath.pathSeparator, Char.toLower, System.FilePath.toString],[System.FilePath]]
[UInt16.decEq.proof_1,[rfl],[Eq, UInt16.mk]]
[ReaderT.run_read,[rfl],[Eq, ReaderT.run, ReaderT.read, Pure.pure]]
[instModUInt64,[Mod.mk, UInt64.mod],[Mod, UInt64]]
[Array.size_swap,[],[Eq, Array.size, Array.swap]]
[String.trimLeft,[Substring.toString, Substring.trimLeft, String.toSubstring],[String]]
[instReprSigma,[Repr.mk, Std.Format, Std.Format.bracket, HAppend.hAppend, repr, Std.Format.text],[Repr, Sigma]]
[instMonadControlT,[MonadControlT.mk, MonadControlT.stM, MonadControl.stM, MonadControl.liftWith, MonadControlT.liftWith, Function.comp, MonadControl.restoreM, MonadControlT.restoreM],[MonadControlT]]
[IO.FS.instLTSystemTime,[ltOfOrd],[LT, IO.FS.SystemTime]]
[Fin.ofNat',[Fin.mk, HMod.hMod, Nat.mod_lt],[Fin]]
[IO.FileRight.mk.inj,[And.intro],[And, Eq]]
[«termIfLet_:=_Then_Else_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[coeOfTC,[CoeHTCT.mk, coeTC],[CoeHTCT]]
[StateT.run_seqRight,[],[Eq, StateT.run, SeqRight.seqRight, Bind.bind, Prod.snd]]
[instLTUInt8,[LT.mk, UInt8.lt],[LT, UInt8]]
[«term~~~_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[ByteArray.noConfusionType,[],[]]
[System.instCoeStringFilePath,[Coe.mk, System.FilePath.mk],[Coe, String, System.FilePath]]
[«term_<|_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instToStringULift,[ToString.mk, ToString.toString, ULift.down],[ToString, ULift]]
[Quotient.sound.proof_1,[Quot.sound],[Eq, Quot.mk, HasEquiv.Equiv]]
[instMonadReaderOfReaderT,[MonadReaderOf.mk, ReaderT.read],[MonadReaderOf, ReaderT]]
[List.dropWhile,[Unit.unit, List, List.nil, PProd.fst, List.cons],[List]]
[IO.Error.resourceVanished.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.resourceVanished, HAdd.hAdd, OfNat.ofNat]]
[instDecidableArrow.proof_3,[absurd],[]]
[And.right,[],[]]
[System.SearchPath.parse,[List.map, System.FilePath.mk, String.split, BEq.beq, System.SearchPath.separator],[System.SearchPath]]
[IO.FS.readBinFile,[Bind.bind, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.true, IO.FS.Handle.readBinToEnd],[IO, ByteArray]]
[Nat.foldRev,[Nat.foldRev.loop],[]]
[String.revFind,[ite, Eq, BEq.beq, String.bsize, OfNat.ofNat, Bool.true, Option.none, String.revFindAux, String.prev],[Option, String.Pos]]
[Classical.byCases,[Decidable.byCases],[]]
[System.FilePath.parent,[Functor.map, System.FilePath.mk, String.extract, System.FilePath.toString, OfNat.ofNat, String.revFind, List.contains, System.FilePath.pathSeparators],[Option, System.FilePath]]
[Classical.epsilon_spec,[Classical.epsilon_spec_aux, nonempty_of_exists],[Classical.epsilon]]
[Lean.Name.beq,[Unit.unit, Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, Bool, Bool.true, and, BEq.beq, PProd.fst, Bool.false],[Bool]]
[fix5,[fixCore5, arbitrary],[]]
[List.nil_append,[rfl],[Eq, HAppend.hAppend, List.nil]]
[IO.FS.Metadata.byteSize,[],[UInt64]]
[instInhabitedPointedType,[Inhabited.mk, PointedType.mk, PUnit, PUnit.unit],[Inhabited, PointedType]]
[HShiftLeft.hShiftLeft,[],[]]
[IO.Error.unsatisfiedConstraints.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.unsatisfiedConstraints, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.unsatisfiedConstraints, And]]
[MonadControl.restoreM,[],[]]
[instSubUInt8,[Sub.mk, UInt8.sub],[Sub, UInt8]]
[Lean.Parser.Tactic.Conv.whnf,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[IO.Process.Child.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Process.Child.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Process.Child.mk, And]]
[RandomGen.noConfusionType,[],[]]
[iff_self,[propext, Iff.intro, trivial, id],[Eq, Iff, True]]
[MonadFinally.tryFinally',[],[Prod]]
[Array.insertionSort.swapLoop.proof_1,[Nat.lt_trans, Nat.lt_succ_self, Eq.symm],[LT.lt, Array.size]]
[trivial,[True.intro],[True]]
[IO.FS.Handle.readBinToEnd,[ByteArray.empty, IO.FS.Handle.readBinToEnd.loop],[IO, ByteArray]]
[Nat.shiftLeft,[Nat, PProd.fst, HMul.hMul, OfNat.ofNat],[Nat]]
[Lean.NameGenerator.curr,[Lean.Name.mkNum, Lean.NameGenerator.namePrefix, Lean.NameGenerator.idx],[Lean.Name]]
[HXor.noConfusionType,[],[]]
[guard,[ite, Pure.pure, Unit.unit, Alternative.failure],[Unit]]
[ExceptT.lift,[ExceptT.mk, Functor.map, Except.ok],[ExceptT]]
[Lean.Meta.Simp.Config.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Simp.Config.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Simp.Config.mk, And]]
[instToStringString,[ToString.mk],[ToString, String]]
[IO.withStderr,[Bind.bind, liftM, IO.setStderr, tryFinally, Functor.discard],[]]
[Lean.Meta.Simp.Config.iota,[],[Bool]]
[Lean.Syntax.mkCApp,[Lean.Syntax.mkApp, Lean.mkCIdent],[Lean.Syntax]]
[IO.Error.timeExpired.inj,[And.intro],[And, Eq]]
[instToStringOption,[ToString.mk, Unit.unit, String, HAppend.hAppend, addParenHeuristic, ToString.toString],[ToString, Option]]
[UInt64.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, UInt64.mk, HAdd.hAdd, OfNat.ofNat]]
[IO.Error.mkInappropriateType,[IO.Error.inappropriateType, Option.none],[IO.Error]]
[Quot.recOnSubsingleton,[Quot.rec, Quot.recOnSubsingleton.proof_1],[]]
[Array.back?,[Array.get?, HSub.hSub, Array.size, OfNat.ofNat],[Option]]
[IO.Error.noSuchThing.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.noSuchThing, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.noSuchThing, And]]
[MonadExcept.orelse',[MonadExcept.tryCatch, MonadExcept.throw, ite, Eq, Bool.true],[]]
[reprArg,[Repr.reprPrec, OfNat.ofNat],[Std.Format]]
[Except.orElseLazy,[Except, Except.ok, Unit.unit],[Except]]
[Substring.take,[Substring.mk, Substring, HAdd.hAdd, Substring.nextn, OfNat.ofNat],[Substring]]
[IO.Error.mkInappropriateTypeFile,[Function.comp, IO.Error.inappropriateType, Option.some],[IO.Error]]
[IO.Process.Child.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Process.Child.mk, HAdd.hAdd, OfNat.ofNat]]
[UInt16.decEq,[Decidable, Eq, dite, Decidable.isTrue, UInt16.decEq.proof_1, Decidable.isFalse, UInt16.decEq.proof_2],[Decidable, Eq]]
[autoParam,[],[]]
[ShiftLeft.noConfusionType,[],[]]
[Array.mapMUnsafe,[unsafeCast, OfNat.ofNat, Array.mapMUnsafe.map],[Array]]
[Lean.Parser.Tactic.Conv.lhs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[UInt8.land,[UInt8.mk, Fin.land, UInt8.val],[UInt8]]
[ReaderT.pure,[Pure.pure],[ReaderT]]
[instOrdUSize,[Ord.mk, compareOfLessAndEq],[Ord, USize]]
[Setoid.refl,[Equivalence.refl, Setoid.iseqv],[HasEquiv.Equiv]]
[instReprList,[Repr.mk, Std.Format, List.cons, Std.Format.text, Std.Format.bracket, Std.Format.joinSep, HAppend.hAppend, Std.Format.line],[Repr, List]]
[IO.Process.Child.mk.inj,[And.intro],[And, Eq]]
[prioLow,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Float.ofNat,[OfScientific.ofScientific, Bool.false, OfNat.ofNat],[Float]]
[List.contains,[List.elem],[Bool]]
[String.toList,[String.data],[List, Char]]
[Array.getOp,[Array.get!],[]]
[instCoeTail_1,[CoeTail.mk, coeSort],[CoeTail]]
[List.filterAux,[List, List.reverse, Unit.unit, PProd.fst, List.cons],[List]]
[instReprStdGen,[Repr.mk, Std.Format, Std.Format.bracket, HAppend.hAppend, repr, Std.Format.text],[Repr, StdGen]]
[Int.decLt,[Decidable, Int.NonNeg, Decidable.isTrue, Int.NonNeg.mk, Decidable.isFalse, Eq.refl, Int.negSucc, HEq.refl, False, HSub.hSub, HAdd.hAdd, OfNat.ofNat],[Decidable, LT.lt]]
[String.isInt,[ite, Eq, String.get, OfNat.ofNat, Char.ofNat, Substring.isNat, Substring.drop, String.toSubstring, String.isNat],[Bool]]
[Lean.Parser.Tactic.subst,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[EStateM.Result.noConfusionType,[],[]]
[Lean.Module.header,[],[Lean.Syntax]]
[funext,[],[Eq]]
[Int.add,[Int, Int.ofNat, HAdd.hAdd, Int.subNatNat, Nat.succ, Int.negSucc],[Int]]
[Subtype.instDecidableEqSubtype.proof_1,[rfl],[Eq, Subtype.mk]]
[Nat.eq_zero_or_pos,[Unit.unit, Or, Eq, OfNat.ofNat, GT.gt, Or.inl, rfl, Or.inr, Nat.succ_pos],[Or, Eq, OfNat.ofNat, GT.gt]]
[StateT.pure,[Pure.pure, Prod.mk],[StateT]]
[List.lengthTR,[List.lengthTRAux, OfNat.ofNat],[Nat]]
[eq_false_of_decide,[propext, Iff.intro, absurd, of_decide_eq_false, False.elim],[Eq, False]]
[instDecidableEqQuotient.proof_2,[absurd, Quotient.exact],[False]]
[Alternative.failure,[],[]]
[Applicative.toSeq,[],[Seq]]
[Quot.exists_rep,[Quot.inductionOn, Exists.intro, rfl],[Exists, Eq, Quot.mk]]
[LawfulMonad.toLawfulApplicative,[],[LawfulApplicative]]
[String.noConfusionType,[],[]]
[Nat.mul_add,[Nat.left_distrib],[Eq, HMul.hMul, HAdd.hAdd]]
[StateCpsT.run'_eq,[rfl],[Eq, StateCpsT.run', StateCpsT.runK, Pure.pure]]
[MonadFunctor.monadMap,[],[]]
[EStateM.instInhabitedEStateM,[Inhabited.mk, EStateM.Result.error, arbitrary],[Inhabited, EStateM]]
[DoResultSBC.continue.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultSBC.continue, HAdd.hAdd, OfNat.ofNat]]
[instMonadExceptOfExceptT,[MonadExceptOf.mk, ExceptT.mk, throwThe, tryCatchThe],[MonadExceptOf, ExceptT]]
[Char.utf8Size.proof_6,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[instMonadControlT_1,[MonadControlT.mk, Pure.pure],[MonadControlT]]
[ExceptCpsT.run_bind_lift,[rfl],[Eq, ExceptCpsT.run, Bind.bind, ExceptCpsT.lift]]
[Nonempty.elim.proof_1,[],[]]
[MonadWithReader.noConfusionType,[],[]]
[instDecidableEqOption,[Unit.unit, Decidable, Eq, Decidable.isTrue, rfl, Decidable.isFalse, dite],[DecidableEq, Option]]
[ReaderT.orElse,[HOrElse.hOrElse, Unit.unit],[ReaderT]]
[IO.Process.Stdio.toHandleType,[Unit.unit, IO.FS.Handle, Unit],[]]
[LawfulApplicative.seqRight_eq,[],[Eq, SeqRight.seqRight, Seq.seq, Functor.map, Function.const, id]]
[Fin.mod.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod]]
[instLTUSize,[LT.mk, USize.lt],[LT, USize]]
[Lean.expandBrackedBindersAux,[Array.size, Lean.expandBrackedBindersAux.loop],[Lean.MacroM, Lean.Syntax]]
[IO.print,[Bind.bind, liftM, IO.getStdout, IO.FS.Stream.putStr, ToString.toString],[IO, Unit]]
[Std.Format.MonadPrettyFormat.currColumn,[],[Nat]]
[IO.FS.Mode.noConfusion,[noConfusionEnum, IO.FS.Mode.toCtorIdx],[IO.FS.Mode.noConfusionType]]
[Std.Range.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.Range.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.Range.mk, And]]
[ExceptT.seqRight_eq,[],[Eq, SeqRight.seqRight, Seq.seq, Functor.map, Function.const, id]]
[LawfulApplicative.seq_pure,[],[Eq, Seq.seq, Pure.pure, Functor.map]]
[Fin.decLe,[Nat.decLe, Fin.val],[Decidable, LE.le]]
[Char.ofNat.proof_2,[Or.inl, of_decide_eq_true, Eq.refl, Bool.true],[Or, LT.lt, UInt32.toNat, UInt32.mk, Fin.mk, OfNat.ofNat, of_decide_eq_true, Eq.refl, Bool.true, And]]
[Char.isWhitespace,[or, Decidable.decide, Eq, Char.ofNat],[Bool]]
[CoeFun.noConfusionType,[],[]]
[Lean.expandExplicitBindersAux,[Array.size, Lean.expandExplicitBindersAux.loop],[Lean.MacroM, Lean.Syntax]]
[Nat.toDigits,[Nat.toDigitsCore, HAdd.hAdd, OfNat.ofNat, List.nil],[List, Char]]
[IO.Error.resourceExhausted.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.resourceExhausted, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.resourceExhausted, And]]
[«term¬_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.idEndEscape,[Char.ofNat],[Char]]
[Std.Format.instInhabitedFlattenBehavior,[Inhabited.mk, Std.Format.FlattenBehavior.allOrNone],[Inhabited, Std.Format.FlattenBehavior]]
[«term_<=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Classical.indefiniteDescription,[Classical.choice, Classical.indefiniteDescription.proof_1],[Subtype]]
[IO.mkRef,[ST.mkRef],[BaseIO, IO.Ref]]
[Array.partition,[Id.run, Bind.bind, ForIn.forIn, MProd.mk, ite, Eq, Bool.true, Pure.pure, PUnit.unit, ForInStep.yield, Id, Prod, Array, Prod.mk],[Prod, Array]]
[Substring.foldr,[String.foldrAux],[]]
[instSubNat,[Sub.mk, Nat.sub],[Sub, Nat]]
[CoeHead.noConfusionType,[],[]]
[MonadStateOf.noConfusionType,[],[]]
[ExceptT.lift_pure,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, ExceptT.mk, LawfulApplicative.map_pure, Except.ok, Pure.pure, eq_self],[Eq, ExceptT.lift, Pure.pure]]
[System.mkFilePath,[System.FilePath.mk, String.intercalate, Char.toString, System.FilePath.pathSeparator],[System.FilePath]]
[Lean.MonadRef.mkInfoFromRefPos,[Bind.bind, Lean.MonadRef.getRef, Pure.pure, Lean.SourceInfo.fromRef],[Lean.SourceInfo]]
[Fin.coeToNat,[Coe.mk, Fin.val],[Coe, Fin, Nat]]
[Lean.Syntax.mkNumLit,[Lean.Syntax.mkLit, Lean.numLitKind],[Lean.Syntax]]
[Equivalence.refl,[],[]]
[instDecidableLe_4,[USize.decLe],[Decidable, LE.le]]
[«command_ClassAbbrev__:_:=__,»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[instInhabitedPNonScalar,[Inhabited.mk, PNonScalar.mk, arbitrary],[Inhabited, PNonScalar]]
[String.isNat,[String.all, Char.isDigit],[Bool]]
[ReaderT.run,[],[]]
[decide_eq_false,[Eq, Decidable.decide, Bool.false, absurd, rfl],[Eq, Decidable.decide, Bool.false]]
[String.trimRight,[Substring.toString, Substring.trimRight, String.toSubstring],[String]]
[Lean.version.major,[Unit.unit],[Nat]]
[Nat.div_eq,[congrFun, WellFounded.fix_eq, WellFoundedRelation.wf, measure, id, dite, And, LT.lt, OfNat.ofNat, LE.le, HAdd.hAdd, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le, Nat.zero, dif_eq_if, HDiv.hDiv],[Eq, HDiv.hDiv, ite, And, LT.lt, OfNat.ofNat, LE.le, HAdd.hAdd, HSub.hSub]]
[IO.Error.resourceVanished.inj,[And.intro],[And, Eq]]
[IO.FS.Mode.readWrite.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.Mode.readWrite, OfNat.ofNat]]
[System.SearchPath.toString,[String.intercalate, Char.toString, System.SearchPath.separator, List.map, System.FilePath.toString],[String]]
[instOfScientificFloat,[OfScientific.mk, ite, Eq, Bool.true, Float.ofBinaryScientific, HSub.hSub, HMul.hMul, Neg.neg, OfNat.ofNat, Int.ofNat, HPow.hPow],[OfScientific, Float]]
[instHashableOption,[Hashable.mk, Unit.unit, UInt64, OfNat.ofNat, mixHash, Hashable.hash],[Hashable, Option]]
[Fin.instShiftRightFin,[ShiftRight.mk, Fin.shiftRight],[ShiftRight, Fin]]
[String.singleton,[String.push],[String]]
[Prod.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Prod.mk, HAdd.hAdd, OfNat.ofNat]]
[Std.Format.MonadPrettyFormat.endTags,[],[Unit]]
[FloatArray.instEmptyCollectionFloatArray,[EmptyCollection.mk, FloatArray.empty],[EmptyCollection, FloatArray]]
[FloatArray.forInUnsafe,[OfNat.ofNat, FloatArray.forInUnsafe.loop],[]]
[MProd.noConfusionType,[],[]]
[Nat.zero_eq,[rfl],[Eq, Nat.zero, OfNat.ofNat]]
[UInt64.toNat,[Fin.val, UInt64.val],[Nat]]
[instDecidableEqBool.proof_2,[],[Bool.noConfusionType, False, Bool.true, Bool.false]]
[String.Iterator.pos,[String.Pos],[String.Pos]]
[Quotient.recOnSubsingleton₂.proof_1,[Quot.recOnSubsingleton],[Subsingleton, Quot.mk, Setoid.r]]
[String.Iterator.hasNext,[Bool, Decidable.decide, LT.lt, String.utf8ByteSize],[Bool]]
[instInhabitedUInt64.proof_1,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt64.size]]
[Std.Format.bracket,[Std.Format.group, Std.Format.nest, Int.ofNat, String.length, HAppend.hAppend, Std.Format.text, Std.Format.FlattenBehavior.allOrNone],[Std.Format]]
[Subtype.property,[],[Subtype.val]]
[Char.quoteCore,[ite, Eq, Char.ofNat, Or, LE.le, Char.toNat, OfNat.ofNat, HAppend.hAppend, charToHex, String.singleton],[String]]
[ByteArray.get!,[UInt8, Array.get!],[UInt8]]
[instCoeNatInt,[Coe.mk, Int.ofNat],[Coe, Nat, Int]]
[IO.Error.instToStringError,[ToString.mk, IO.Error.toString],[ToString, IO.Error]]
[eq_of_heq,[],[Eq]]
[Lean.Syntax.SepArray.elemsAndSeps,[],[Array, Lean.Syntax]]
[Lean.firstFrontendMacroScope,[HAdd.hAdd, Lean.reservedMacroScope, OfNat.ofNat],[Nat]]
[Std.Range.«term[:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[ltOfOrd,[LT.mk, Eq, BEq.beq, Ord.compare, Ordering.lt, Bool.true],[LT]]
[ExceptCpsT.runCatch_throw,[rfl],[Eq, ExceptCpsT.runCatch, MonadExcept.throw, Pure.pure]]
[Lean.Parser.Tactic.Conv.convConvSeq,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[CoeDep.noConfusionType,[],[]]
[instToStringUInt32,[ToString.mk, ToString.toString, UInt32.toNat],[ToString, UInt32]]
[List.instEmptyCollectionList,[EmptyCollection.mk, List.nil],[EmptyCollection, List]]
[IO.Process.Output.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Process.Output.mk, HAdd.hAdd, OfNat.ofNat]]
[Nat.foldM,[Nat.foldM.loop],[]]
[List.set,[List, List.cons, PProd.fst, List.nil],[List]]
[Except.ok.inj,[],[Eq]]
[List.hasDecEq,[Unit.unit, Decidable, Eq, Decidable.isTrue, List.hasDecEq.proof_1, Decidable.isFalse, List.hasDecEq.proof_2, List.hasDecEq.proof_3, List.cons, decEq, PProd.fst, List.hasDecEq.proof_4, List.hasDecEq.proof_5, List.hasDecEq.proof_6],[Decidable, Eq]]
[Nat.mod_zero,[],[Eq, HMod.hMod, OfNat.ofNat]]
[MonadExceptOf.throw,[],[]]
[min,[ite, LE.le],[]]
[Lean.Macro.Exception.noConfusionType,[],[]]
[Subtype.val,[],[]]
[Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1],[Trans, LT.lt]]
[String.set,[String, String.mk, List, Char, List.nil, ite, Eq, List.cons, PProd.fst, HAdd.hAdd, String.csize, OfNat.ofNat],[String]]
[Std.Format.FlattenBehavior.fill.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Std.Format.FlattenBehavior.fill, OfNat.ofNat]]
[IO.FS.Metadata.type,[],[IO.FS.FileType]]
[List.notElem,[not, List.elem],[Bool]]
[Nat.land,[Nat.bitwise, and],[Nat]]
[List.toByteArray,[ByteArray.empty, List.toByteArray.loop],[ByteArray]]
[Eq.trans,[],[Eq]]
[Std.Format.group.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.Format.group, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.Format.group, And]]
[IO.FS.instInhabitedStream,[Inhabited.mk, IO.FS.Stream.mk, arbitrary],[Inhabited, IO.FS.Stream]]
[instForIn,[ForIn.mk, Stream.forIn],[ForIn]]
[instAppendSubarray,[Append.mk, Array.toSubarray, OfNat.ofNat, Array.size],[Append, Subarray]]
[eq_self,[propext, Iff.intro, trivial, rfl],[Eq, True]]
[seqLeft_eq_bind,[Eq.mpr, Eq.refl, Eq, SeqLeft.seqLeft, Bind.bind, Pure.pure, LawfulApplicative.seqLeft_eq, of_eq_true, Eq.trans, congrFun, congrArg, Seq.seq, map_eq_pure_bind, Function.const, seq_eq_bind_map, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, Function.const_apply, eq_self],[Eq, SeqLeft.seqLeft, Bind.bind, Pure.pure]]
[ofBoolUsing_eq_true,[of_decide_eq_true],[]]
[Lean.Meta.TransparencyMode.default.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.TransparencyMode.default, OfNat.ofNat]]
[MProd.fst,[],[]]
[UInt32.toUSize,[Nat.toUSize, UInt32.toNat],[USize]]
[String.atEnd,[Bool, Decidable.decide, GE.ge, String.utf8ByteSize],[Bool]]
[Array.appendCore,[Array.size, OfNat.ofNat, Array.appendCore.loop],[Array]]
[Lean.Parser.Tactic.change,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Nat.xor,[Nat.bitwise, bne],[Nat]]
[USize.decLt,[Decidable, LT.lt, inferInstanceAs],[Decidable, LT.lt]]
[Array.modify,[Id.run, Array.modifyM],[Array]]
[Array.toArrayLit_eq,[sorryAx, Eq, Array.toArrayLit, Bool.false],[Eq, Array.toArrayLit]]
[Ne.intro,[],[Ne]]
[Lean.NameGenerator.idx,[],[Nat]]
[FloatArray.instInhabitedFloatArray,[Inhabited.mk, FloatArray.empty],[Inhabited, FloatArray]]
[unexpandUnit,[Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.PrettyPrinter.Unexpander]]
[Lean.Name.ibelow,[True, And],[]]
[Ne.symm,[Eq.symm],[Ne]]
[FloatArray.foldlM.loop.proof_1,[Nat.lt_of_lt_of_le],[LT.lt, FloatArray.size]]
[List.findSomeM?,[Unit.unit, Option, Pure.pure, Option.none, Bind.bind, Option.some, PProd.fst],[Option]]
[ExceptT.run_bind_lift,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, Bind.bind, map_eq_pure_bind, Except.ok, Except, Pure.pure, Except.error, LawfulMonad.bind_assoc, funext, LawfulMonad.pure_bind, eq_self],[Eq, ExceptT.run, Bind.bind, ExceptT.lift]]
[List.instForMList,[ForM.mk, List.forM],[ForM, List]]
[Lean.Name.str.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Name.str, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Name.str, And]]
[Quotient.lift,[Quot.lift],[]]
[floatDecLt,[Float.decLt],[Decidable, LT.lt]]
[Lean.Name.str.inj,[And.intro],[And, Eq]]
[Int.instLEInt,[LE.mk, Int.le],[LE, Int]]
[Array.qpartition,[Array.qpartition.loop],[Prod, Nat, Array]]
[ByteArray.extract,[ByteArray.copySlice, ByteArray.empty, OfNat.ofNat, HSub.hSub, Bool.true],[ByteArray]]
[«term_<||>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[PSigma.lexAccessible.proof_1,[Acc.intro, PSigma.mk, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, WellFounded.apply],[Acc, PSigma.Lex, PSigma.mk]]
[System.FilePath.mk.inj,[],[Eq]]
[Lean.Parser.Tactic.rotateLeft,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Std.Format.FlattenBehavior.allOrNone.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Std.Format.FlattenBehavior.allOrNone, OfNat.ofNat]]
[Id.map_eq,[rfl],[Eq, Functor.map]]
[IO.AccessRight.execution,[],[Bool]]
[fix3,[fixCore3, arbitrary],[]]
[String.Iterator.hasPrev,[Bool, Decidable.decide, GT.gt, OfNat.ofNat],[Bool]]
[Array.anyMUnsafe.any,[ite, Eq, BEq.beq, Bool.true, Pure.pure, Bool.false, Bind.bind, Array.uget, lcProof, Array.anyMUnsafe.any, HAdd.hAdd, OfNat.ofNat],[Bool]]
[nonempty_of_exists,[Nonempty, Nonempty.intro],[Nonempty]]
[Lean.TrailingParserDescr,[Lean.ParserDescr],[]]
[instHashableFin,[Hashable.mk, Nat.toUInt64, Fin.val],[Hashable, Fin]]
[InvImage.wf.proof_1,[WellFounded.intro, InvImage.accessible, WellFounded.apply],[WellFounded, InvImage]]
[List.beq,[Unit.unit, List.nil, List.cons, Bool, Bool.true, and, BEq.beq, PProd.fst, Bool.false],[Bool]]
[instDecidableArrow,[dite, Decidable.isTrue, instDecidableArrow.proof_1, Decidable.isFalse, instDecidableArrow.proof_2, instDecidableArrow.proof_3],[Decidable]]
[Nat.toFloat,[Float.ofNat],[Float]]
[String.bsize,[String.utf8ByteSize],[Nat]]
[IO.FS.Metadata.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FS.Metadata.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.FS.Metadata.mk, And]]
[optionCoe,[CoeTail.mk, Option.some],[CoeTail, Option]]
[instDecidableArrow.proof_2,[absurd],[False]]
[IO.FileRight.noConfusionType,[],[]]
[Int.decEq.proof_4,[absurd],[False]]
[Lean.Parser.Tactic.induction,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlts],[Lean.ParserDescr]]
[«term[_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false],[Lean.ParserDescr]]
[Int.div,[Int, Int.ofNat, HDiv.hDiv, Neg.neg, Nat.succ],[Int]]
[List.mapM,[Unit.unit, List, Pure.pure, List.nil, Bind.bind, PProd.fst, List.cons],[List]]
[Array.binInsert,[Id.run, Array.binInsertM],[Array]]
[unexpandListCons,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Id.finally,[MonadFinally.mk, Pure.pure, Prod.mk],[MonadFinally, Id]]
[instReprAtomBool,[ReprAtom.mk],[ReprAtom, Bool]]
[instDecidableAnd.proof_1,[And.right],[False]]
[unexpandPSigma,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Subtype.noConfusionType,[],[]]
[mkStdGen,[StdGen.mk, HAdd.hAdd, OfNat.ofNat],[StdGen]]
[Lean.Parser.Tactic.discharger,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[dite_true,[rfl],[Eq, dite, True, True.intro]]
[BaseIO.mapTasks.go,[BaseIO, Task, BaseIO.bindTask, PProd.fst, List.cons, BaseIO.asTask, List.reverse],[BaseIO, Task]]
[Nat.allM.loop,[Unit.unit, Bool, Pure.pure, Bool.true, Bind.bind, HSub.hSub, OfNat.ofNat, PProd.fst, Bool.false],[Bool]]
[instInhabitedArrow,[Inhabited.mk, arbitrary],[Inhabited]]
[cast_eq,[rfl],[Eq, cast]]
[String.toInt!,[Unit.unit, Int, String.toInt?, panic],[Int]]
[IO.lazyPure,[Pure.pure, Unit.unit],[IO]]
[System.FilePath.instDivFilePath,[Div.mk, System.FilePath.join],[Div, System.FilePath]]
[ReaderT,[],[]]
[Fin.lor.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, Nat.lor]]
[instInhabitedUInt32.proof_1,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[instToStringFin,[ToString.mk, ToString.toString, Fin.val],[ToString, Fin]]
[ReaderT.instMonadLiftReaderT,[MonadLift.mk],[MonadLift, ReaderT]]
[Lean.Parser.Tactic.letrec,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Except.mapError,[Except, Except.error, Except.ok],[Except]]
[Lean.Name.isInaccessibleUserName,[Lean.Name.anonymous, Bool, or, String.contains, Char.ofNat, BEq.beq, PProd.fst, Bool.false],[Bool]]
[Std.Format.FlattenBehavior.noConfusionType,[noConfusionTypeEnum, Std.Format.FlattenBehavior.toCtorIdx],[]]
[MonadExcept.tryCatch,[],[]]
[Function.Equiv.symm,[Eq.symm],[Function.Equiv]]
[EStateM.Result.error.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, EStateM.Result.error, HAdd.hAdd, OfNat.ofNat]]
[cast,[],[]]
[Lean.Parser.Tactic.tacticRefine_lift'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Substring.foldl,[String.foldlAux],[]]
[eq_false,[propext, Iff.intro, absurd, False.elim],[Eq, False]]
[Subarray.foldrM,[Array.foldrM, Subarray.as, Subarray.stop, Subarray.start],[]]
[ExceptCpsT.instMonadLiftExceptCpsT,[MonadLift.mk, ExceptCpsT.lift],[MonadLift, ExceptCpsT]]
[Int.instHPowIntNatInt,[HPow.mk, Int.pow],[HPow, Int, Nat]]
[optional,[HOrElse.hOrElse, Functor.map, Option.some, Pure.pure, Option.none],[Option]]
[WellFounded.fix,[WellFounded.fixF, WellFounded.apply],[]]
[Nat.add_one,[rfl],[Eq, HAdd.hAdd, OfNat.ofNat, Nat.succ]]
[Task.spawn,[Task.pure, Unit.unit],[Task]]
[ST.instInhabitedRef.proof_1,[Nonempty.intro, arbitrary],[Nonempty]]
[UInt32.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd],[UInt32]]
[UInt8.sub,[UInt8.mk, HSub.hSub, UInt8.val],[UInt8]]
[instDecidableLt_3,[UInt64.decLt],[Decidable, LT.lt]]
[ByteArray.forInUnsafe.loop,[ite, LT.lt, Bind.bind, Pure.pure, ByteArray.forInUnsafe.loop, HAdd.hAdd, OfNat.ofNat],[]]
[Array.mapIdxM,[Array.size, OfNat.ofNat, rfl, Array.mkEmpty, Array.mapIdxM.map],[Array]]
[Quot.hrecOn,[Quot.recOn, Quot.hrecOn.proof_1],[]]
[OptionT.instMonadOptionT,[Monad.mk],[Monad, OptionT]]
[List.filterMapM,[List.reverse, List.nil, List.filterMapM.loop],[List]]
[prioDefault,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[instMonadEST,[inferInstanceAs, Monad, EStateM],[Monad, EST]]
[Nat.mul_succ,[rfl],[Eq, HMul.hMul, Nat.succ, HAdd.hAdd]]
[IO.FS.writeBinFile,[Bind.bind, IO.FS.Handle.mk, IO.FS.Mode.write, Bool.true, IO.FS.Handle.write],[IO, Unit]]
[Lean.instQuoteNat,[Lean.Quote.mk, Lean.Syntax.mkNumLit, ToString.toString, Lean.SourceInfo.none],[Lean.Quote, Nat]]
[Std.Format.fill,[Std.Format.group, Std.Format.FlattenBehavior.fill],[Std.Format]]
[USize.ofNat32.proof_1,[Unit.unit, Eq.symm, eq_of_heq, Eq.refl, OfNat.ofNat, HEq.refl, LT.lt, USize.size, usize_size_eq, Nat.lt_trans, of_decide_eq_true, Bool.true],[LT.lt, USize.size]]
[Except.error.inj,[],[Eq]]
[Lean.term_Matches_,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[seqRight_eq_bind,[Eq.mpr, Eq.refl, Eq, SeqRight.seqRight, Bind.bind, LawfulApplicative.seqRight_eq, of_eq_true, Eq.trans, congrFun, congrArg, Seq.seq, map_eq_pure_bind, id, seq_eq_bind_map, Pure.pure, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, id_eq, bind_pure, eq_self],[Eq, SeqRight.seqRight, Bind.bind]]
[Fin.land,[Fin, Fin.mk, HMod.hMod, Nat.land, Fin.land.proof_1],[Fin]]
[MonadExcept.throw,[],[]]
[IO.asTask,[EIO.asTask],[BaseIO, Task, Except, IO.Error]]
[PSigma.revLex,[PSigma.revLex.proof_1],[WellFounded, PSigma.RevLex]]
[WellFoundedRelation.wf,[],[WellFounded, WellFoundedRelation.rel]]
[Lean.Parser.Tactic.tacticHave'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Array.forRevM,[Array.foldrM, PUnit.unit],[PUnit]]
[Array.mapSepElems,[Id.run, Array.mapSepElemsM],[Array, Lean.Syntax]]
[ByteArray.instForInByteArrayUInt8,[ForIn.mk, ByteArray.forIn],[ForIn, ByteArray, UInt8]]
[instToStreamRangeRange,[ToStream.mk],[ToStream, Std.Range]]
[Lean.Meta.Simp.instInhabitedConfig,[Inhabited.mk, Lean.Meta.Simp.Config.mk, arbitrary],[Inhabited, Lean.Meta.Simp.Config]]
[Ordering.gt.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Ordering.gt, OfNat.ofNat]]
[USize.toNat,[Fin.val, USize.val],[Nat]]
[Substring.trim,[Substring, Substring.mk],[Substring]]
[System.SearchPath,[List, System.FilePath],[]]
[String.utf8ByteSize,[Nat, PProd.fst, HAdd.hAdd, String.csize, OfNat.ofNat],[Nat]]
[randBool,[Prod, Bool, Prod.mk, Decidable.decide, Eq, OfNat.ofNat],[Prod, Bool]]
[OfNat.ofNat,[],[]]
[HDiv.hDiv,[],[]]
[DecidableRel,[Decidable],[]]
[AndOp.and,[],[]]
[Lean.Meta.Rewrite.Config.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Meta.Rewrite.Config.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Rewrite.Config.mk, And]]
[coeOfDep,[CoeT.mk, coeD],[CoeT]]
[Nat.lt_of_lt_of_le,[Nat.le_trans],[LT.lt]]
[IO.Process.Stdio.null.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.Process.Stdio.null, OfNat.ofNat]]
[EStateM.orElse,[EStateM.Result.ok, EStateM.Result, Unit.unit, EStateM.Backtrackable.restore],[EStateM]]
[Lean.Macro.Methods.expandMacro?,[],[Lean.MacroM, Option, Lean.Syntax]]
[Nat.add_lt_add_right,[Nat.add_lt_add_left, Nat.add_comm],[LT.lt, HAdd.hAdd]]
[Lean.Macro.Methods.noConfusionType,[],[]]
[ReaderT.adapt,[],[ReaderT]]
[Nat.add_mul,[Nat.right_distrib],[Eq, HMul.hMul, HAdd.hAdd]]
[StateRefT'.set,[ST.Ref.set],[StateRefT', PUnit]]
[Quot.liftOn,[Quot.lift],[]]
[withPtrEq,[Unit.unit],[Bool]]
[Lean.Name.instBEqName,[BEq.mk, Lean.Name.beq],[BEq, Lean.Name]]
[Nat.mul_left_comm,[Eq.mpr, Eq.refl, Eq, HMul.hMul, Eq.symm, Nat.mul_assoc, Nat.mul_comm, rfl],[Eq, HMul.hMul]]
[Char.repr,[Char.quote],[String]]
[Substring.front,[Substring.get, OfNat.ofNat],[Char]]
[Lean.Syntax.getOp,[Lean.Syntax.getArg],[Lean.Syntax]]
[instBEqFloat,[BEq.mk, Float.beq],[BEq, Float]]
[String.splitOn,[ite, Eq, BEq.beq, Bool.true, List.cons, List.nil, String.splitOnAux, OfNat.ofNat],[List, String]]
[Array.indexOf?,[Array.indexOfAux, OfNat.ofNat],[Option, Fin, Array.size]]
[Char.toString,[String.singleton],[String]]
[List.getLastD.proof_1,[],[List.noConfusionType, False, List.cons, List.nil]]
[IO.Error.mkNoSuchThingFile,[Function.comp, IO.Error.noSuchThing, Option.some],[IO.Error]]
[Or.elim,[],[]]
[Quotient.exists_rep,[Quot.exists_rep],[Exists, Eq, Quotient.mk]]
[dite_congr,[Decidable.em, Eq.mpr, Eq.refl, Eq, dite, dif_pos, Eq.symm, dif_neg],[Eq, dite]]
[IO.Error.unexpectedEof.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.Error.unexpectedEof, OfNat.ofNat]]
[ExceptT.instLawfulMonadExceptT.proof_1,[LawfulMonad.mk, ExceptT.bind_pure_comp, rfl, ExceptT.ext, of_eq_true, Eq.trans, congrFun, congrArg, Eq, ExceptT.run_bind, Pure.pure, Bind.bind, ExceptT.run_pure, Except, ExceptT.run, Except.error, LawfulMonad.pure_bind, Except.ok, eq_self, Eq.mpr, congr, LawfulMonad.bind_assoc, funext, bind_congr, Eq.symm, Eq.refl],[LawfulMonad, ExceptT]]
[LawfulApplicative.noConfusionType,[],[]]
[Ordering.eq.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Ordering.eq, OfNat.ofNat]]
[Substring.dropWhile,[Substring, Substring.mk],[Substring]]
[ExceptT.instLawfulMonadExceptT,[ExceptT.instLawfulMonadExceptT.proof_1],[LawfulMonad, ExceptT]]
[instOfNatUInt64,[OfNat.mk, UInt64.ofNat],[OfNat, UInt64]]
[List.forIn,[List.forIn.loop],[]]
[String.decEq,[Decidable, Eq, dite, Decidable.isTrue, String.decEq.proof_1, Decidable.isFalse, String.decEq.proof_2],[Decidable, Eq]]
[Lean.Syntax.setInfo,[Unit.unit, Lean.Syntax, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax.node, Lean.Syntax.missing],[Lean.Syntax]]
[StateT.tryFinally,[MonadFinally.mk, Bind.bind, MonadFinally.tryFinally', Unit.unit, Prod, Option.some, Option.none, Pure.pure, Prod.mk],[MonadFinally, StateT]]
[fixCore,[fixCore1],[]]
[instComplementUInt32,[Complement.mk, UInt32.complement],[Complement, UInt32]]
[Decidable.noConfusionType,[],[]]
[IO.withStdout,[Bind.bind, liftM, IO.setStdout, tryFinally, Functor.discard],[]]
[Lean.Syntax.getArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Array, Lean.Syntax, Array.empty],[Array, Lean.Syntax]]
[List.toByteArray.loop,[ByteArray, PProd.fst, ByteArray.push],[ByteArray]]
[PSigma.lexAccessible,[PSigma.lexAccessible.proof_1],[Acc, PSigma.Lex, PSigma.mk]]
[and,[Unit.unit, Bool, Bool.false],[Bool]]
[Lean.Meta.Rewrite.Config.noConfusionType,[],[]]
[FloatArray.set!,[FloatArray, FloatArray.mk, Array.set!],[FloatArray]]
[LawfulMonad.bind_pure_comp,[],[Eq, Bind.bind, Pure.pure, Functor.map]]
[instInhabitedFloat,[Inhabited.mk, Float.mk, FloatSpec.val, floatSpec],[Inhabited, Float]]
[List.iota,[Unit.unit, Nat.succ, List, Nat, List.nil, List.cons, PProd.fst],[List, Nat]]
[DoResultPR.return.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultPR.return, HAdd.hAdd, OfNat.ofNat]]
[instInhabitedProp,[Inhabited.mk, True],[Inhabited]]
[Lean.ParserDescr.below,[PUnit, PProd],[]]
[String.data,[],[List, Char]]
[MonadControlT.stM,[],[]]
[Prod.lexAccessible.proof_1,[Acc.intro, Prod.mk, Eq.symm, eq_of_heq, Eq.refl, HEq.refl],[Acc, Prod.Lex, Prod.mk]]
[Lean.evalOptPrio,[Unit.unit, Lean.MacroM, Nat, Lean.evalPrio, Pure.pure, OfNat.ofNat],[Lean.MacroM, Nat]]
[instHashableInt,[Hashable.mk, UInt64, UInt64.ofNat, HMul.hMul, OfNat.ofNat, HAdd.hAdd],[Hashable, Int]]
[Int.mod,[Int, Int.ofNat, HMod.hMod, Nat.succ, Neg.neg],[Int]]
[List.map_eq_mapTR,[funext, of_eq_true, Eq.trans, congrArg, Eq, List.map, List.mapTRAux_eq, List.nil, congrFun, HAppend.hAppend, List.reverse_nil, List.nil_append, eq_self],[Eq, List.map, List.mapTR]]
[instComplementUInt64,[Complement.mk, UInt64.complement],[Complement, UInt64]]
[UInt16.size,[OfNat.ofNat],[Nat]]
[Array.getMax?,[dite, LT.lt, OfNat.ofNat, Array.size, Option.some, Array.foldl, ite, Eq, Bool.true, Option.none],[Option]]
[ExceptT.run_map,[Eq.mpr, congrArg, Eq, ExceptT.run, ExceptT.mk, Bind.bind, Except, Pure.pure, Except.ok, Except.error, map_eq_pure_bind, Except.map, bind_congr, of_eq_true, eq_self, Eq.symm, Eq.refl],[Eq, ExceptT.run, Functor.map, Except.map]]
[Lean.Syntax.ident.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Syntax.ident, HAdd.hAdd, OfNat.ofNat]]
[Lean.Parser.Tactic.cases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.casesTarget, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlts],[Lean.ParserDescr]]
[Array.ext,[congrArg, Array.mk, Eq.symm, Eq.refl, Array.ext.extAux],[Eq]]
[Lean.Parser.Tactic.paren,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Syntax.isCharLit?,[Option.none, Option, Char, Lean.Syntax.isLit?, Lean.charLitKind, Lean.Syntax.decodeCharLit],[Option, Char]]
[StateRefT'.instMonadExceptOfStateRefT',[MonadExceptOf.mk, Function.comp, StateRefT'.lift, throwThe, tryCatchThe],[MonadExceptOf, StateRefT']]
[List.any,[List.foldr, or, Bool.false],[Bool]]
[PSigma.eta,[rfl],[Eq, PSigma.mk]]
[Option.all,[Unit.unit, Bool, Bool.true],[Bool]]
[List.mapTRAux_eq,[of_eq_true, Eq.trans, congrArg, Eq, List.reverse, List.append_nil, eq_self, Eq.mpr, Eq.refl, List.mapTRAux, List.cons, HAppend.hAppend, List.map, List.reverse_cons, List.nil, List.append_assoc, rfl],[Eq, List.mapTRAux, HAppend.hAppend, List.reverse, List.map]]
[Lean.nullKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Substring.drop,[Substring.mk, Substring, HAdd.hAdd, Substring.nextn, OfNat.ofNat],[Substring]]
[Lean.Parser.Tactic.tacticHave_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[instReprFloat,[Repr.mk, Std.Format.text, Float.toString],[Repr, Float]]
[HOrElse.hOrElse,[],[]]
[List.reverse_nil,[rfl],[Eq, List.reverse, List.nil]]
[«term%[_|_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false],[Lean.ParserDescr]]
[bfix2,[PProd.fst],[]]
[OfScientific.noConfusionType,[],[]]
[Subtype.eq,[Eq.symm, eq_of_heq, Eq.refl, Subtype.val, Subtype.mk, HEq.refl, Eq, rfl],[Eq]]
[Id.instLawfulMonadId.proof_1,[LawfulMonad.mk, rfl],[LawfulMonad, Id]]
[«term-_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Fin.ofNat.proof_1,[Nat.mod_lt, Nat.zero_lt_succ],[LT.lt, HMod.hMod, Nat.succ]]
[MonadState.get,[],[]]
[List.erase,[List, List.nil, Unit.unit, BEq.beq, List.cons, PProd.fst],[List]]
[Nat.le_of_lt,[Nat.le_of_succ_le],[LE.le]]
[Lean.charLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[NonScalar.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, NonScalar.mk, HAdd.hAdd, OfNat.ofNat]]
[Fin.modn,[Fin, Fin.mk, HMod.hMod, Fin.modn.proof_1],[Fin]]
[ExceptT.adapt,[ExceptT.mk, Functor.map, Except.mapError],[ExceptT]]
[instOrdNat,[Ord.mk, compareOfLessAndEq],[Ord, Nat]]
[IO.FS.DirEntry.fileName,[],[String]]
[Setoid.r,[],[]]
[Lean.Name.instReprSyntax,[Repr.mk],[Repr, Lean.Syntax]]
[IO,[EIO, IO.Error],[]]
[instLEFin,[LE.mk, LE.le, Fin.val],[LE, Fin]]
[IO.Process.Child.stdin,[],[IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdin]]
[List.get,[absurd, Nat.not_lt_zero],[]]
[String.Iterator.remainingToString,[String, String.extract, String.bsize],[String]]
[Array.instAppendArray,[Append.mk, Array.append],[Append, Array]]
[HEq.ndrecOn,[],[]]
[instAddUInt16,[Add.mk, UInt16.add],[Add, UInt16]]
[instMonadFinallyStateRefT',[inferInstanceAs, MonadFinally, ReaderT, ST.Ref],[MonadFinally, StateRefT']]
[instToStringUInt64,[ToString.mk, ToString.toString, UInt64.toNat],[ToString, UInt64]]
[Repr.reprPrec,[],[Std.Format]]
[UInt8.lor,[UInt8.mk, Fin.lor, UInt8.val],[UInt8]]
[System.Platform.numBits_eq,[Subtype.property, System.Platform.getNumBits, Unit.unit],[Or, Eq, System.Platform.numBits, OfNat.ofNat]]
[IO.FS.DirEntry.root,[],[System.FilePath]]
[IO.Error.invalidArgument.inj,[And.intro],[And, Eq]]
[IO.FS.Stream.putStr,[],[IO, Unit]]
[OptionT.instMonadLiftOptionT,[MonadLift.mk, OptionT.lift],[MonadLift, OptionT]]
[Bool.true_or,[rfl, Eq.symm, Eq.refl],[Eq, or, Bool.true]]
[Nat.not_succ_le_self,[Unit.unit, Not, LE.le, Nat.succ, Nat.not_succ_le_zero, OfNat.ofNat, absurd, Nat.le_of_succ_le_succ, PProd.fst],[Not, LE.le, Nat.succ]]
[instBEqOption,[BEq.mk, Unit.unit, Option.none, Option.some, Bool, Bool.true, and, BEq.beq, Bool.false],[BEq, Option]]
[PSigma.mkSkipLeft,[PSigma.mkSkipLeft.proof_1],[PSigma.SkipLeft, PSigma.mk]]
[USize.div,[USize.mk, HDiv.hDiv, USize.val],[USize]]
[Nat.zero_add,[Unit.unit, Eq, HAdd.hAdd, OfNat.ofNat, rfl, congrArg, Nat.succ, PProd.fst],[Eq, HAdd.hAdd, OfNat.ofNat]]
[PLift.noConfusionType,[],[]]
[instMulUInt8,[Mul.mk, UInt8.mul],[Mul, UInt8]]
[PSigma.mkSkipLeft.proof_1,[PSigma.RevLex.right],[PSigma.RevLex, emptyRelation, PSigma.mk]]
[Lean.MonadNameGenerator.getNGen,[],[Lean.NameGenerator]]
[Lean.Syntax.ident.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Syntax.ident, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Syntax.ident, And]]
[Nat.foldRevM.loop,[Pure.pure, Bind.bind, PProd.fst],[]]
[Task.map,[Task.pure, Task.get],[Task]]
[Char.val,[],[UInt32]]
[List.elem,[Unit.unit, Bool, Bool.false, BEq.beq, Bool.true, PProd.fst],[Bool]]
[Lean.Syntax.formatStx,[Lean.Syntax.formatStxAux, OfNat.ofNat],[Std.Format]]
[Lean.Macro.resolveGlobalName,[Bind.bind, Lean.Macro.getMethods, Lean.Macro.Methods.resolveGlobalName],[Lean.MacroM, List, Prod, Lean.Name, String]]
[Lean.Eval.noConfusionType,[],[]]
[instHPow,[HPow.mk, Pow.pow],[HPow]]
[String.Iterator.mk.inj,[And.intro],[And, Eq]]
[instShiftRightUSize,[ShiftRight.mk, USize.shiftRight],[ShiftRight, USize]]
[Nat.lt_or_ge,[Unit.unit, Or, LT.lt, GE.ge, Or.inr, Nat.zero_le, Nat.succ, PProd.fst, Or.inl, Nat.le_succ_of_le, Nat.eq_or_lt_of_le, Nat.le_refl],[Or, LT.lt, GE.ge]]
[termS!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Nat.le_of_succ_le,[Nat.le_trans, Nat.le_succ],[LE.le]]
[IO.Error.mkEofError,[IO.Error.unexpectedEof],[IO.Error]]
[IO.Error.permissionDenied.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.permissionDenied, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.permissionDenied, And]]
[Sigma.noConfusionType,[],[]]
[Classical.typeDecidable.proof_1,[absurd, Nonempty.intro],[False]]
[String.intercalate,[Unit.unit, String, String.intercalate.go],[String]]
[FloatArray.uget,[Float, Array.uget],[Float]]
[instToStringInt,[ToString.mk, String, ToString.toString, HAppend.hAppend, Nat.succ],[ToString, Int]]
[Lean.Parser.Tactic.config,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[heq_of_eqRec_eq,[heq_of_eq],[HEq]]
[IO.userError,[IO.Error.userError],[IO.Error]]
[Nat.succ_add,[Eq, HAdd.hAdd, Nat.succ, rfl, congrArg, PProd.fst],[Eq, HAdd.hAdd, Nat.succ]]
[Lean.instHashableName,[Hashable.mk, Lean.Name.hash],[Hashable, Lean.Name]]
[Int.natAbs,[Nat, Nat.succ],[Nat]]
[Quotient.hrecOn,[Quot.hrecOn],[]]
[IO.FS.Stream.read,[],[IO, ByteArray]]
[Array.forM,[Array.foldlM, PUnit.unit],[PUnit]]
[ST,[EST, Empty],[]]
[instMonadLiftT_1,[MonadLiftT.mk],[MonadLiftT]]
[instToBoolBool,[ToBool.mk],[ToBool, Bool]]
[List.forM,[Unit.unit, PUnit, Pure.pure, PUnit.unit, Bind.bind, PProd.fst],[PUnit]]
[instHashableUInt8,[Hashable.mk, UInt8.toUInt64],[Hashable, UInt8]]
[Lean.Parser.Tactic.location,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.Parser.Tactic.locationWildcard, Lean.Parser.Tactic.locationHyp],[Lean.ParserDescr]]
[CoeHTCT.coe,[],[]]
[Subarray.foldr,[Id.run, Subarray.foldrM],[]]
[Lean.MacroScope,[Nat],[]]
[Std.Format.noConfusionType,[],[]]
[List.filterMapM.loop,[List, Pure.pure, Bind.bind, Unit.unit, PProd.fst, List.cons],[List]]
[instToStringNat,[ToString.mk, Nat.repr],[ToString, Nat]]
[ExceptCpsT,[],[]]
[Lean.Macro.mkMethodsImp,[unsafeCast],[PointedType.type]]
[Add.noConfusionType,[],[]]
[FloatArray.set,[FloatArray, FloatArray.mk, Array.set],[FloatArray]]
[Char.instInhabitedChar,[Inhabited.mk, Char.ofNat],[Inhabited, Char]]
[Nat.mod.proof_1,[WellFoundedRelation.wf, measure, id],[WellFounded, WellFoundedRelation.rel, measure, id]]
[Subarray.forInUnsafe.loop,[ite, LT.lt, Bind.bind, Pure.pure, Subarray.forInUnsafe.loop, HAdd.hAdd, OfNat.ofNat],[]]
[IO.Error.userError.inj,[],[Eq]]
[Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat.lt_trans],[LT.lt]]
[List.forM_cons,[rfl],[Eq, ForM.forM, List.cons, Bind.bind]]
[Nat.instModNat,[Mod.mk, Nat.mod],[Mod, Nat]]
[Lean.addMacroScope,[Unit.unit, Lean.Name, Lean.Name.hasMacroScopes, BEq.beq, Lean.MacroScopesView.mainModule, Lean.Name.mkNum, Lean.MacroScopesView.review, Lean.MacroScopesView.mk, Lean.MacroScopesView.name, List.foldl, HAppend.hAppend, Lean.MacroScopesView.imported, Lean.MacroScopesView.scopes, List.cons, List.nil, Lean.Name.mkStr],[Lean.Name]]
[Substring.dropRight,[Substring.mk, Substring, HAdd.hAdd, Substring.prevn, Substring.bsize],[Substring]]
[Subarray.h₁,[],[LE.le, Subarray.start, Subarray.stop]]
[Subsingleton.elim,[Subsingleton.elim.proof_1],[Eq]]
[StateT.set,[Pure.pure, Prod.mk, PUnit.unit],[StateT, PUnit]]
[Lean.Syntax.getPos?,[Lean.SourceInfo.getPos?, Lean.Syntax.getHeadInfo],[Option, String.Pos]]
[NonScalar.val,[],[Nat]]
[UInt64.noConfusionType,[],[]]
[IO.Process.StdioConfig.mk.inj,[And.intro],[And, Eq]]
[USize.ofNat32,[USize.mk, Fin.mk, USize.ofNat32.proof_1],[USize]]
[instDecidableAnd,[Decidable, And, Decidable.isTrue, And.intro, Decidable.isFalse, instDecidableAnd.proof_1, instDecidableAnd.proof_2],[Decidable, And]]
[List.headD,[],[]]
[toBoolUsing_eq_true,[decide_eq_true],[Eq, toBoolUsing, Bool.true]]
[List.length_append,[of_eq_true, Eq.trans, congr, congrArg, Eq, List.length, List.nil_append, congrFun, HAdd.hAdd, List.length_nil, Nat.zero_add, eq_self, List.cons_append, List.length_cons, HAppend.hAppend, Nat.succ, Nat.succ_add],[Eq, List.length, HAppend.hAppend, HAdd.hAdd]]
[ReprTuple.noConfusionType,[],[]]
[ByteArray.toUInt64BE!,[ite, Eq, BEq.beq, ByteArray.size, OfNat.ofNat, Bool.true, HOr.hOr, HShiftLeft.hShiftLeft, UInt8.toUInt64, ByteArray.get!, panicWithPosWithDecl, HAppend.hAppend],[UInt64]]
[Lean.instInhabitedParserDescr,[Inhabited.mk, Lean.ParserDescr.symbol],[Inhabited, Lean.ParserDescr]]
[Prod.RProdSubLex.proof_1,[Prod.Lex.left, Eq.symm, eq_of_heq, Eq.refl, HEq.refl],[Prod.Lex]]
[IO.FS.Stream.ofBuffer,[IO.FS.Stream.mk, Bind.bind, ST.Ref.get, Pure.pure, Decidable.decide, GE.ge, IO.FS.Stream.Buffer.pos, ByteArray.size, IO.FS.Stream.Buffer.data, Unit.unit, ST.Ref.modifyGet, Prod.mk, IO.FS.Stream.Buffer.mk, HAdd.hAdd, ST.Ref.modify, ByteArray.copySlice, OfNat.ofNat, Bool.false, String.fromUTF8Unchecked, ByteArray.extract],[IO.FS.Stream]]
[Lean.Syntax.decodeQuotedChar,[OptionM.run, ite, Eq, BEq.beq, Char.ofNat, Bool.true, Pure.pure, Prod.mk, Bind.bind, and, Decidable.decide, LE.le, Option.some, HSub.hSub, Char.toNat, HAdd.hAdd, OfNat.ofNat, Option.none, OptionM, Prod, Char, String.Pos, HMul.hMul],[Option, Prod, Char, String.Pos]]
[OptionT.tryCatch,[OptionT.mk, Bind.bind, Option.none, Option, Pure.pure, Option.some, Unit.unit],[OptionT]]
[unexpandIte,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[«term_<*_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[MonadReader.read,[],[]]
[StateT.run_monadLift,[rfl],[Eq, StateT.run, MonadLiftT.monadLift, Bind.bind, Pure.pure, Prod.mk]]
[PNonScalar.noConfusionType,[],[]]
[Ordering.lt.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Ordering.lt, OfNat.ofNat]]
[Quotient.inductionOn₃,[Quotient.ind],[]]
[Nat.le_of_eq,[Nat.le_refl],[LE.le]]
[Lean.Syntax.isLit?,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Option, String, ite, Eq, and, BEq.beq, Array.size, OfNat.ofNat, Bool.true, Lean.Syntax.node, Array.get!, Option.some, Option.none],[Option, String]]
[Char.instLEChar,[LE.mk, Char.le],[LE, Char]]
[IO.Error.interrupted.inj,[And.intro],[And, Eq]]
[Pow.pow,[],[]]
[SizeOf.noConfusionType,[],[]]
[IO.FS.writeFile,[Bind.bind, IO.FS.Handle.mk, IO.FS.Mode.write, Bool.false, IO.FS.Handle.putStr],[IO, Unit]]
[UInt32.sub,[UInt32.mk, HSub.hSub, UInt32.val],[UInt32]]
[Float.ofBinaryScientific,[Float.scaleB, UInt64.toFloat],[Float]]
[instToFormatOption,[Std.ToFormat.mk, Option.format],[Std.ToFormat, Option]]
[instStreamSubstringChar,[Stream.mk, ite, LT.lt, Substring.startPos, Substring.stopPos, Option.some, Prod.mk, String.get, Substring.str, Substring.mk, String.next, Option.none],[Stream, Substring, Char]]
[instInhabitedOption,[Inhabited.mk, Option.none],[Inhabited, Option]]
[Lean.mkCIdentFrom,[Lean.Syntax.ident, Lean.SourceInfo.fromRef, String.toSubstring, ToString.toString, List.cons, Prod.mk, List.nil],[Lean.Syntax]]
[Nat.gcd_self,[of_eq_true, Eq.trans, congr, congrArg, Eq, Nat.gcd, Nat.zero_eq, Nat.gcd_zero_right, OfNat.ofNat, eq_true_of_decide, Eq.refl, Bool.true, Eq.symm, congrFun, Nat.gcd_succ, Nat.succ, Nat.mod_self, Nat.gcd_zero_left, eq_self],[Eq, Nat.gcd]]
[coeSortToCoeTail,[CoeTail.mk, CoeSort.coe],[CoeTail]]
[true_ne_false,[ne_false_of_self, trivial],[Not, Eq, True, False]]
[instPowFloatFloat,[Pow.mk, Float.pow],[Pow, Float]]
[instReprUInt8,[Repr.mk, repr, UInt8.toNat],[Repr, UInt8]]
[instOfNatUInt32,[OfNat.mk, UInt32.ofNat],[OfNat, UInt32]]
[Lean.Name.mkNum.proof_1,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt64.size]]
[StateRefT'.instMonadLiftStateRefT',[MonadLift.mk, StateRefT'.lift],[MonadLift, StateRefT']]
[readThe,[MonadReaderOf.read],[]]
[OptionT.bind,[OptionT.mk, Bind.bind, Unit.unit, Option, Pure.pure, Option.none],[OptionT]]
[Lean.Parser.Tactic.injections,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[unexpandSorryAx,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Lean.Syntax.hasArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Bool, Decidable.decide, GT.gt, Array.size, OfNat.ofNat, Bool.false],[Bool]]
[StateCpsT.instMonadStateCpsT,[Monad.mk],[Monad, StateCpsT]]
[String.foldr,[String.foldrAux, String.bsize, OfNat.ofNat],[]]
[Fin.instAndOpFin,[AndOp.mk, Fin.land],[AndOp, Fin]]
[EStateM.Result.ok.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, EStateM.Result.ok, HAdd.hAdd, OfNat.ofNat]]
[ReaderT.run_seqRight,[Eq.mpr, Eq.refl, Eq, ReaderT.run, SeqRight.seqRight, seqRight_eq_bind, rfl],[Eq, ReaderT.run, SeqRight.seqRight]]
[Nat.div,[WellFounded.fix, Nat.div.proof_1, dite, And, LT.lt, OfNat.ofNat, LE.le, HAdd.hAdd, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le, Nat.zero],[Nat]]
[instDecidableEqList,[List.hasDecEq],[DecidableEq, List]]
[HEq.noConfusionType,[],[]]
[Not,[False],[]]
[List.spanAux,[Prod, List, Prod.mk, List.reverse, List.nil, Unit.unit, PProd.fst, List.cons],[Prod, List]]
[String.any,[String.anyAux, String.bsize, OfNat.ofNat],[Bool]]
[Lean.Parser.Tactic.locationWildcard,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[OptionM,[OptionT, Id],[]]
[String.trim,[Substring.toString, Substring.trim, String.toSubstring],[String]]
[IO.AccessRight.mk.inj,[And.intro],[And, Eq]]
[instReprDecidable,[Repr.mk, Std.Format, Repr.addAppParen, Std.Format.text],[Repr, Decidable]]
[true_and,[propext, Iff.intro, And.right, And.intro, trivial],[Eq, And, True]]
[Sum.inhabitedLeft,[Inhabited.mk, Sum.inl, arbitrary],[Inhabited, Sum]]
[ExceptT,[Except],[]]
[StateT.get,[Pure.pure, Prod.mk],[StateT]]
[FloatArray.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, FloatArray.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Simp.Config.memoize,[],[Bool]]
[IO.FS.Stream.Buffer.mk.inj,[And.intro],[And, Eq]]
[String.push,[String, String.mk, HAppend.hAppend, List.cons, List.nil],[String]]
[IO.Error.otherError.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.otherError, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.otherError, And]]
[decide_false_eq_false,[Eq, Decidable.decide, False, Bool.false, rfl, False.elim],[Eq, Decidable.decide, False, Bool.false]]
[Nat.anyM,[Nat.anyM.loop],[Bool]]
[Lean.Meta.TransparencyMode.reducible.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.TransparencyMode.reducible, OfNat.ofNat]]
[Lean.Syntax.mkLit,[Lean.mkNode, List.toArray, List.cons, List.nil],[Lean.Syntax]]
[Nat.instShiftLeftNat,[ShiftLeft.mk, Nat.shiftLeft],[ShiftLeft, Nat]]
[instHOrElse,[HOrElse.mk, OrElse.orElse],[HOrElse]]
[Array.allDiff,[OfNat.ofNat],[Bool]]
[List.nil.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, List.nil, OfNat.ofNat]]
[instReprInt,[Repr.mk, Std.Format.text, Int.repr],[Repr, Int]]
[ExceptCpsT.run,[Except, Pure.pure, Except.ok, Except.error],[Except]]
[Array.insertionSort.swapLoop.proof_2,[Eq.mpr, Eq.refl, LT.lt, Array.size, Array.swap, Fin.mk, Nat.lt_trans, Nat.lt_succ_self, Eq.symm, Array.size_swap],[LT.lt, Array.size, Array.swap, Fin.mk, Nat.lt_trans, Nat.lt_succ_self, Eq.symm]]
[instDecidableIte,[Decidable, ite],[Decidable, ite]]
[Lean.Parser.Tactic.tacticTrivial,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Except.map_id,[funext, Eq.mpr, congr, congrArg, Eq, Except, Except.error, Except.ok, id_eq, rfl, Eq.symm, Eq.refl],[Eq, Except.map, id]]
[ReaderT.run_monadLift,[rfl],[Eq, ReaderT.run, MonadLiftT.monadLift]]
[instPowNatNat,[Pow.mk, Nat.pow],[Pow, Nat]]
[RandomGen.next,[],[Prod, Nat]]
[IO.FS.Handle.putStrLn,[IO.FS.Handle.putStr, String.push, Char.ofNat],[IO, Unit]]
[instHashableUInt64,[Hashable.mk],[Hashable, UInt64]]
[UInt64.toUInt8,[Nat.toUInt8, UInt64.toNat],[UInt8]]
[Array.isEmpty,[Decidable.decide, Eq, Array.size, OfNat.ofNat],[Bool]]
[Array.getLit,[Array.get, Fin.mk, Array.getLit.proof_1],[]]
[HAppend.noConfusionType,[],[]]
[Lean.mkIdent,[Lean.Syntax.ident, Lean.SourceInfo.none, String.toSubstring, ToString.toString, List.nil],[Lean.Syntax]]
[False.elim,[],[]]
[Eq.subst,[],[]]
[IO.Process.StdioConfig.stdin,[],[IO.Process.Stdio]]
[Bool.true_and,[rfl, Eq.symm, Eq.refl],[Eq, and, Bool.true]]
[instOrdUInt64,[Ord.mk, compareOfLessAndEq],[Ord, UInt64]]
[IO.FS.instReprFileType,[Repr.mk, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, GE.ge, OfNat.ofNat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone],[Repr, IO.FS.FileType]]
[EIO.mapTasks,[BaseIO.mapTasks, EIO.toBaseIO],[BaseIO, Task, Except]]
[Std.Format.append.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.Format.append, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.Format.append, And]]
[IO.Process.SpawnArgs.env,[],[Array, Prod, String, Option]]
[Int.negSucc.inj,[],[Eq]]
[Fin.isLt,[],[LT.lt, Fin.val]]
[List.reverseAux_eq_append,[of_eq_true, Eq.trans, congrArg, Eq, List.nil_append, eq_self, Eq.mpr, Eq.refl, List.reverseAux, List.cons, HAppend.hAppend, List.nil, List.append_assoc, rfl],[Eq, List.reverseAux, HAppend.hAppend, List.nil]]
[System.FilePath.fileName,[ite, Eq, or, String.isEmpty, BEq.beq, Bool.true, Option.none, Option.some],[Option, String]]
[Lean.Parser.Tactic.simpPre,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[StdGen.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, StdGen.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, StdGen.mk, And]]
[StateT.seqRight_eq,[StateT.ext, Eq.mpr, congr, congrArg, Eq, StateT.run_seqRight, Eq.trans, StateT.run_seq, Functor.map, id, Bind.bind, StateT.run_map, map_eq_pure_bind, Prod.mk, Prod.snd, StateT.run, funext, Prod.fst, LawfulMonad.bind_assoc, Pure.pure, LawfulMonad.pure_bind, congrFun, id_eq, bind_congr, of_eq_true, Prod.ext, bind_pure, eq_self, Eq.symm, Eq.refl],[Eq, SeqRight.seqRight, Seq.seq, Functor.map, Function.const, id]]
[throwThe,[MonadExceptOf.throw],[]]
[Lean.Macro.trace,[modify, Lean.Macro.State.mk, Lean.Macro.State.macroScope, List.cons, Prod.mk, Lean.Macro.State.traceMsgs],[Lean.MacroM, Unit]]
[Nat.le_total,[Or, LE.le, Nat.lt_or_ge, Or.inl, Nat.le_of_lt, Or.inr],[Or, LE.le]]
[Int.pow,[Unit.unit, Int, OfNat.ofNat, HMul.hMul, PProd.fst],[Int]]
[UInt16.ofNatCore,[UInt16.mk, Fin.mk],[UInt16]]
[Lean.Meta.Simp.instBEqConfig,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, Lean.Meta.Simp.Config]]
[EStateM.pure,[EStateM.Result.ok],[EStateM]]
[Lean.Syntax.decodeScientificLitVal?.decodeExp,[ite, Eq, BEq.beq, Char.ofNat, Bool.true, Lean.Syntax.decodeScientificLitVal?.decodeAfterExp, String.next, OfNat.ofNat, Bool.false],[Option, Prod, Nat, Bool]]
[StateCpsT.runK_bind_pure,[rfl],[Eq, StateCpsT.runK, Bind.bind, Pure.pure]]
[Neg.noConfusionType,[],[]]
[instMulUInt32,[Mul.mk, UInt32.mul],[Mul, UInt32]]
[Id.instLawfulMonadId,[Id.instLawfulMonadId.proof_1],[LawfulMonad, Id]]
[instDecidableEqBool.proof_1,[],[Bool.noConfusionType, False, Bool.false, Bool.true]]
[Lean.Syntax.copyHeadTailInfoFrom,[Lean.Syntax.setTailInfo, Lean.Syntax.setHeadInfo, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo],[Lean.Syntax]]
[Quotient.recOnSubsingleton,[Quot.recOnSubsingleton],[]]
[Lean.Syntax.atom.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Syntax.atom, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Syntax.atom, And]]
[IO.FS.Metadata.mk.inj,[And.intro],[And, Eq]]
[instOrdInt,[Ord.mk, compareOfLessAndEq],[Ord, Int]]
[InvImage,[],[]]
[List.and,[List.all, id],[Bool]]
[Array.ofSubarray,[Id.run, Bind.bind, ForIn.forIn, Pure.pure, PUnit.unit, ForInStep.yield],[Array]]
[instBEqProd,[BEq.mk, Bool, and, BEq.beq],[BEq, Prod]]
[FloatSpec.mk.inj,[And.intro],[And, Eq, HEq]]
[Bool.and_true,[rfl, Eq.symm, Eq.refl],[Eq, and, Bool.true]]
[Lean.Syntax.getKind,[Unit.unit, Lean.SyntaxNodeKind, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Name.mkSimple, Lean.identKind],[Lean.SyntaxNodeKind]]
[Lean.instQuoteList,[Lean.Quote.mk, Unit.unit, Lean.Syntax, Lean.mkCIdent, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.mkCApp, List.toArray, List.cons, Lean.Quote.quote, PProd.fst, List.nil],[Lean.Quote, List]]
[System.Platform.getNumBits.proof_1,[Or.inr, rfl],[Or, Eq, OfNat.ofNat]]
[IO.Error.mkTimeExpired,[IO.Error.timeExpired],[IO.Error]]
[Subarray.start,[],[Nat]]
[Task.pure.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Task.pure, HAdd.hAdd, OfNat.ofNat]]
[of_decide_eq_false,[Not, absurd, ne_false_of_eq_true, decide_eq_true],[Not]]
[UInt64.toUInt16,[Nat.toUInt16, UInt64.toNat],[UInt16]]
[IO.Error.protocolError.inj,[And.intro],[And, Eq]]
[List.isEqv,[List.nil, List.cons, Bool, Bool.true, and, PProd.fst, Bool.false],[Bool]]
[instCoeStringError,[Coe.mk, IO.userError],[Coe, String, IO.Error]]
[Int.noConfusionType,[],[]]
[instReprUSize,[Repr.mk, repr, USize.toNat],[Repr, USize]]
[String.intercalate.go,[Unit.unit, String, PProd.fst, HAppend.hAppend],[String]]
[Quotient.recOnSubsingleton₂,[Quot.recOnSubsingleton],[]]
[Decidable.byCases,[],[]]
[precMin1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[termPrintln!__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[flip,[],[]]
[calcStep,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary],[Lean.ParserDescr]]
[Char.isValidCharNat,[Or, LT.lt, OfNat.ofNat, And],[]]
[Array.sequenceMap.loop,[dite, LT.lt, Array.size, Unit.unit, Array, Pure.pure, Bind.bind, Array.get, Fin.mk, PProd.fst, HAdd.hAdd, OfNat.ofNat, Array.push],[Array]]
[«term_|>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[UInt16.decEq.proof_2,[absurd],[False]]
[Lean.Parser.Tactic.Conv.convRw__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq],[Lean.ParserDescr]]
[ReaderT.run_monadMap,[rfl],[Eq, ReaderT.run, MonadFunctorT.monadMap]]
[instReprFin,[Repr.mk, repr, Fin.val],[Repr, Fin]]
[Array.forInUnsafe,[OfNat.ofNat, Array.forInUnsafe.loop],[]]
[HasEquiv.noConfusionType,[],[]]
[instTransEq_1,[Trans.mk, instTransEq_1.proof_1],[Trans, Eq]]
[control,[controlAt],[]]
[Std.Format.nest.injEq,[Eq.propIntro, And.intro, Eq.refl, Std.Format.nest, Eq.symm, eq_of_heq, HEq.refl],[Eq, Std.Format.nest, And]]
[instDecidableOr.proof_1,[False],[False]]
[ShiftRight.shiftRight,[],[]]
[IO.Error.mkHardwareFault,[IO.Error.hardwareFault],[IO.Error]]
[ExceptCpsT.instLawfulMonadExceptCpsT,[ExceptCpsT.instLawfulMonadExceptCpsT.proof_1],[LawfulMonad, ExceptCpsT]]
[Fin.xor.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, Nat.xor]]
[Option.lt,[Option.none, Option.some, True, False],[]]
[EStateM.Result.ok.injEq,[Eq.propIntro, And.intro, Eq.refl, EStateM.Result.ok, Eq.symm, eq_of_heq, HEq.refl],[Eq, EStateM.Result.ok, And]]
[Nat.isValidChar,[Or, LT.lt, OfNat.ofNat, And],[]]
[List.find?,[Unit.unit, Option, Option.none, Option.some, PProd.fst],[Option]]
[UInt32.lor,[UInt32.mk, Fin.lor, UInt32.val],[UInt32]]
[Task.Priority.dedicated,[OfNat.ofNat],[Task.Priority]]
[instStreamSubarray.proof_1,[Nat.succ_le_of_lt],[LE.le, Nat.succ, Subarray.start, Subarray.stop]]
[Array.zipWith,[Array.zipWithAux, OfNat.ofNat, List.toArray, List.nil],[Array]]
[Lean.Macro.Methods.getCurrNamespace,[],[Lean.MacroM, Lean.Name]]
[seq_eq_bind,[Eq.mpr, Eq.refl, Eq, Seq.seq, Bind.bind, Functor.map, LawfulMonad.bind_map, rfl],[Eq, Seq.seq, Bind.bind, Functor.map]]
[Char.ofNat.proof_1,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt32.size]]
[«stx_,*»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[Monad.toBind,[],[Bind]]
[instReprAtomInt,[ReprAtom.mk],[ReprAtom, Int]]
[FloatArray.mk.injEq,[Eq.propIntro, Eq.refl, FloatArray.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, FloatArray.mk]]
[HXor.hXor,[],[]]
[let_body_congr,[],[Eq]]
[Fin.mod,[Fin, Fin.mk, HMod.hMod, Fin.mod.proof_1],[Fin]]
[«term_!=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instHSub,[HSub.mk, Sub.sub],[HSub]]
[Fin.add.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, HAdd.hAdd]]
[Nat.mod_eq_of_lt,[],[Eq, HMod.hMod]]
[Lean.termEval_prec_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[IO.Error.timeExpired.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.timeExpired, HAdd.hAdd, OfNat.ofNat]]
[Lean.Meta.Simp.Config.maxSteps,[],[Nat]]
[Nat.le_add_left,[Nat.le_add_right, Nat.add_comm],[LE.le, HAdd.hAdd]]
[Lean.identKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Lean.Parser.Tactic.withReducible,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[IO.Error.mkNoSuchThing,[IO.Error.noSuchThing, Option.none],[IO.Error]]
[System.FilePath.extSeparator,[Char.ofNat],[Char]]
[Sum.inl.injEq,[Eq.propIntro, Eq.refl, Sum.inl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Sum.inl]]
[Lean.Name.hash.proof_1,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt64.size]]
[Lean.Macro.expandMacro?,[Bind.bind, Lean.Macro.getMethods, Lean.Macro.Methods.expandMacro?],[Lean.MacroM, Option, Lean.Syntax]]
[«term_∘_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[FloatArray.get,[Float, Array.get],[Float]]
[CoeT.noConfusionType,[],[]]
[ByteArray.uset,[ByteArray, ByteArray.mk, Array.uset],[ByteArray]]
[String.foldl,[String.foldlAux, String.bsize, OfNat.ofNat],[]]
[ne_false_of_eq_true,[Not, Eq, Bool.false],[Not, Eq, Bool.false]]
[IO.Error.otherErrorToString,[Unit.unit, String, HAppend.hAppend, String.modify, OfNat.ofNat, Char.toLower, ToString.toString],[String]]
[Lean.Meta.Simp.Config.maxDischargeDepth,[],[Nat]]
[Lean.Syntax.mkApp,[dite, Eq, Array.size, Unit.unit, Eq.symm, Array.toArrayLit_eq, Eq.refl, Lean.Syntax, Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkNullNode, List.nil],[Lean.Syntax]]
[FloatArray.foldlM.loop,[dite, LT.lt, Unit.unit, Pure.pure, Bind.bind, FloatArray.get, Fin.mk, FloatArray.foldlM.loop.proof_1, PProd.fst, HAdd.hAdd, OfNat.ofNat],[]]
[List.hasDecidableLt.proof_2,[Eq.refl, List.cons, List.nil, HEq.refl, False],[False]]
[Lean.Syntax.decodeCharLit,[OptionM.run, ite, Eq, BEq.beq, Char.ofNat, Bool.true, Bind.bind, Lean.Syntax.decodeQuotedChar, OfNat.ofNat, OptionM, Char, Pure.pure],[Option, Char]]
[List.unzip,[Unit.unit, Prod, List, Prod.mk, List.nil, PProd.fst, List.cons],[Prod, List]]
[String.toUpper,[String.map, Char.toUpper],[String]]
[Lean.idBeginEscape,[Char.ofNat],[Char]]
[invImage.proof_1,[InvImage.wf, WellFoundedRelation.wf],[WellFounded, InvImage, WellFoundedRelation.rel]]
[Array.uget,[Array.get, Fin.mk, USize.toNat],[]]
[Lean.Parser.Tactic.Conv.nestedConv,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.Parser.Tactic.Conv.convSeqBracketed],[Lean.ParserDescr]]
[List.maximum?,[Unit.unit, Option, Option.none, Option.some, List.foldl, max],[Option]]
[Array.insertionSort.swapLoop,[Array, Eq.refl],[Array]]
[instDecidableLe_2,[UInt16.decLe],[Decidable, LE.le]]
[decidableOfDecidableOfEq,[],[Decidable]]
[String.decEq.proof_2,[absurd],[False]]
[UInt32.mod,[UInt32.mk, HMod.hMod, UInt32.val],[UInt32]]
[Lean.Macro.Context.noConfusionType,[],[]]
[Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1],[Trans, LT.lt, LE.le]]
[IO.Error.resourceBusy.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.resourceBusy, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.resourceBusy, And]]
[Substring.takeWhile,[Substring, Substring.mk],[Substring]]
[MonadState.set,[],[PUnit]]
[congrFun,[rfl],[Eq]]
[IO.Error.fopenErrorToString,[Unit.unit, String, HAppend.hAppend, String.modify, OfNat.ofNat, Char.toLower, ToString.toString],[String]]
[EIO.catchExceptions,[EStateM.Result, Empty, IO.RealWorld, EStateM.Result.ok],[BaseIO]]
[UInt32.land,[UInt32.mk, Fin.land, UInt32.val],[UInt32]]
[UInt8.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd],[UInt8]]
[Lean.Name.simpMacroScopes,[Unit.unit, Lean.Name, Lean.Name.hasMacroScopes, Lean.Name.anonymous, Lean.Name.str, Lean.Name.mkNum, PProd.fst, BEq.beq],[Lean.Name]]
[String.front,[String.get, OfNat.ofNat],[Char]]
[Nat.toDigitsCore,[List, Char, ite, Eq, OfNat.ofNat, List.cons, PProd.fst],[List, Char]]
[instHAdd,[HAdd.mk, Add.add],[HAdd]]
[DoResultSBC.pureReturn.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, DoResultSBC.pureReturn, HAdd.hAdd, OfNat.ofNat]]
[and_false,[propext, Iff.intro, And.right, False.elim],[Eq, And, False]]
[ToBool.noConfusionType,[],[]]
[Lean.Name.hasMacroScopes,[Lean.Name.anonymous, Bool, BEq.beq, PProd.fst, Bool.false],[Bool]]
[tryCatchThe,[MonadExceptOf.tryCatch],[]]
[ExceptT.run_lift,[rfl],[Eq, ExceptT.run, ExceptT.lift, Functor.map, Except.ok]]
[Substring.get,[Char, String.get, HAdd.hAdd],[Char]]
[recSubsingleton,[Subsingleton],[Subsingleton]]
[StateCpsT.run_eq,[rfl],[Eq, StateCpsT.run, StateCpsT.runK, Pure.pure, Prod.mk]]
[instInhabitedForInStep,[Inhabited.mk, ForInStep.done, arbitrary],[Inhabited, ForInStep]]
[Nat.add_lt_add_left,[Nat.lt_of_succ_le, Nat.add_le_add_left, Nat.succ_le_of_lt, Nat.add_succ],[LT.lt, HAdd.hAdd]]
[Nat.mul_assoc,[Eq, HMul.hMul, rfl],[Eq, HMul.hMul]]
[ExceptT.seq_eq,[rfl],[Eq, Seq.seq, Bind.bind, Functor.map]]
[UInt32.decEq,[Decidable, Eq, dite, Decidable.isTrue, UInt32.decEq.proof_1, Decidable.isFalse, UInt32.decEq.proof_2],[Decidable, Eq]]
[Lean.runEval,[IO.FS.withIsolatedStreams, liftM, EIO.toBaseIO, Lean.Eval.eval, Bool.false],[IO, Prod, String, Except, IO.Error, Unit]]
[ReaderT.ext,[funext, id],[Eq]]
[instReprAtomUInt32,[ReprAtom.mk],[ReprAtom, UInt32]]
[EIO.bindTask,[BaseIO.bindTask, EIO.catchExceptions, Pure.pure, Task.pure, Except.error],[BaseIO, Task, Except]]
[Lean.mkAtom,[Lean.Syntax.atom, Lean.SourceInfo.none],[Lean.Syntax]]
[RandomGen.range,[],[Prod, Nat]]
[instSubUInt32,[Sub.mk, UInt32.sub],[Sub, UInt32]]
[instAddUInt8,[Add.mk, UInt8.add],[Add, UInt8]]
[Option.isSome,[Unit.unit, Bool, Bool.true, Bool.false],[Bool]]
[Array.shrink,[HSub.hSub, Array.size, Array.shrink.loop],[Array]]
[Array.findIdx?.loop.proof_1,[absurd, Eq.mp, Eq.refl, LT.lt, Array.size, Eq, HAdd.hAdd, OfNat.ofNat, Nat.zero_add, Nat.lt_irrefl],[False]]
[instDecidableEqBool,[Unit.unit, Decidable, Eq, Decidable.isTrue, rfl, Decidable.isFalse, instDecidableEqBool.proof_1, instDecidableEqBool.proof_2],[DecidableEq, Bool]]
[instInhabitedStdGen,[Inhabited.mk, StdGen.mk, OfNat.ofNat],[Inhabited, StdGen]]
[subtypeCoe,[CoeHead.mk, Subtype.val],[CoeHead, Subtype]]
[iff_false,[propext, Iff.intro, Iff.mp, False.elim],[Eq, Iff, False, Not]]
[List.lookup,[Option, Option.none, Unit.unit, BEq.beq, Option.some, PProd.fst],[Option]]
[IO.Process.output,[Bind.bind, IO.Process.spawn, IO.Process.SpawnArgs.mk, IO.Process.StdioConfig.mk, IO.Process.StdioConfig.stdin, IO.Process.SpawnArgs.toStdioConfig, IO.Process.Stdio.piped, IO.Process.SpawnArgs.cmd, IO.Process.SpawnArgs.args, IO.Process.SpawnArgs.cwd, IO.Process.SpawnArgs.env, liftM, IO.asTask, IO.FS.Handle.readToEnd, IO.Process.Child.stdout, Task.Priority.dedicated, IO.Process.Child.stderr, IO.Process.Child.wait, IO.ofExcept, Task.get, Pure.pure, IO.Process.Output.mk],[IO, IO.Process.Output]]
[Lean.Parser.Tactic.rewriteSeq,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[runEST,[Except, Unit, Unit.unit, Except.ok, Except.error],[Except]]
[Lean.Macro.Context.mainModule,[],[Lean.Name]]
[Fin.val_eq_of_eq,[rfl],[Eq, Fin.val]]
[Sub.noConfusionType,[],[]]
[dbgSleep,[Unit.unit],[]]
[UInt64.lor,[UInt64.mk, Fin.lor, UInt64.val],[UInt64]]
[Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp.proof_1,[Nat.le_trans],[LE.le]]
[Lean.Parser.Tactic.«tactic·._»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[List.hasDecidableLt.proof_4,[Eq.symm, eq_of_heq, Eq.refl, List.cons, HEq.refl, False, absurd],[False]]
[DoResultSBC.noConfusionType,[],[]]
[optParam_eq,[rfl],[Eq, optParam]]
[Lean.Parser.Tactic.tacticRfl,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[StateT.instMonadFunctorStateT,[MonadFunctor.mk, Prod],[MonadFunctor, StateT]]
[String.toNat?,[ite, Eq, String.isNat, Bool.true, Option.some, String.foldl, HAdd.hAdd, HMul.hMul, OfNat.ofNat, HSub.hSub, Char.toNat, Char.ofNat, Option.none],[Option, Nat]]
[Lean.Parser.Tactic.apply,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Name.appendIndexAfter,[Lean.Name.modifyBase, Lean.Name.anonymous, Lean.Name.num, Lean.Name, Lean.Name.mkStr, HAppend.hAppend, ToString.toString],[Lean.Name]]
[List.ibelow,[True, And],[]]
[MonadFunctorT.noConfusionType,[],[]]
[IO.FS.Stream.write,[],[IO, Unit]]
[rfl.proof_1,[Eq.refl],[Eq]]
[Fin.div,[Fin, Fin.mk, HMod.hMod, HDiv.hDiv, Fin.div.proof_1],[Fin]]
[instMonadLiftBaseIOEIO,[MonadLift.mk, BaseIO.toEIO],[MonadLift, BaseIO, EIO]]
[StateT.instAlternativeStateT,[Alternative.mk, StateT.failure, StateT.orElse],[Alternative, StateT]]
[instDecidableTrue,[Decidable.isTrue, trivial],[Decidable, True]]
[Nat.le_of_succ_le_succ,[Nat.pred_le_pred],[LE.le]]
[ByteArray.forIn.loop,[Pure.pure],[]]
[ST.Ref.mk.injEq,[Eq.propIntro, Eq.refl, ST.Ref.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, ST.Ref.mk]]
[termDepIfThenElse,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[IO.Process.SpawnArgs.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Process.SpawnArgs.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Process.SpawnArgs.mk, And]]
[decide_true_eq_true,[Eq, Decidable.decide, True, Bool.true, rfl, False.elim, True.intro],[Eq, Decidable.decide, True, Bool.true]]
[Nat.lt_wfRel.proof_1,[WellFounded.intro, Acc.intro, OfNat.ofNat, absurd, Nat.not_lt_zero, Nat.succ],[WellFounded, Nat.lt]]
[termIfThenElse,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.const],[Lean.ParserDescr]]
[IO.Process.SpawnArgs.mk.inj,[And.intro],[And, Eq]]
[ULift.down_up,[rfl],[Eq, ULift.down, ULift.up]]
[SizeOf.sizeOf,[],[Nat]]
[instHDiv,[HDiv.mk, Div.div],[HDiv]]
[IO.Error.noFileOrDirectory.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.noFileOrDirectory, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.noFileOrDirectory, And]]
[List.foldl,[PProd.fst],[]]
[SizeOfRef,[Measure, SizeOf.sizeOf],[]]
[Nat.toUSize,[USize.ofNat],[USize]]
[instReprId_1,[inferInstanceAs, Repr],[Repr, Id]]
[Lean.Meta.Simp.Config.decide,[],[Bool]]
[Nat.mul_zero,[rfl],[Eq, HMul.hMul, OfNat.ofNat]]
[UInt64.sub,[UInt64.mk, HSub.hSub, UInt64.val],[UInt64]]
[unexpandSigma,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, cond, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[String.foldlAux,[String.foldlAux.loop],[]]
[System.FilePath.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, System.FilePath.mk, HAdd.hAdd, OfNat.ofNat]]
[ExceptT.bind_throw,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, LawfulMonad.pure_bind, Except.error, Except, Pure.pure, eq_self],[Eq, Bind.bind, MonadExcept.throw]]
[ReaderT.run_seqLeft,[Eq.mpr, Eq.refl, Eq, ReaderT.run, SeqLeft.seqLeft, seqLeft_eq_bind, rfl],[Eq, ReaderT.run, SeqLeft.seqLeft]]
[Array.ext.extAux,[rfl, Eq.symm, Eq.mp, Eq.refl, Eq, List.length, List.nil, List.cons, List.length_cons],[Eq]]
[Lean.Syntax.SepArray.noConfusionType,[],[]]
[Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp,[Trans.mk, Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp.proof_1],[Trans, LE.le]]
[EStateM.run',[Option, EStateM.run, Option.some, Option.none],[Option]]
[List.instBEqList,[BEq.mk, List.beq],[BEq, List]]
[Lean.Name.reprPrec,[Unit.unit, Std.Format, Std.Format.text, Repr.addAppParen, HAppend.hAppend, PProd.fst, OfNat.ofNat, repr, ite, Eq, Bool, Bool.false, Bool.true, Lean.Name.toString],[Std.Format]]
[Array.split,[Array.foldl, Prod, Array, ite, Eq, Bool.true, Prod.mk, Array.push, List.toArray, List.nil, OfNat.ofNat, Array.size],[Prod, Array]]
[Thunk.get,[Unit.unit],[]]
[Nat.toSuperscriptString,[List.asString, Nat.toSuperDigits],[String]]
[IO.Error.otherError.inj,[And.intro],[And, Eq]]
[FloatArray.foldl,[Id.run, FloatArray.foldlM],[]]
[USize.size,[HPow.hPow, OfNat.ofNat, System.Platform.numBits],[Nat]]
[instToStringIterator,[ToString.mk, String.Iterator.remainingToString],[ToString, String.Iterator]]
[Std.Range.mk.inj,[And.intro],[And, Eq]]
[Bind.noConfusionType,[],[]]
[Lean.reservedMacroScope,[OfNat.ofNat],[Nat]]
[SeqRight.noConfusionType,[],[]]
[Nat.le.brecOn,[Nat.le.below.refl, Nat.le.below.step],[]]
[Substring.splitOn,[ite, Eq, BEq.beq, Bool.true, List.cons, List.nil, OfNat.ofNat, Substring.splitOn.loop],[List, Substring]]
[Quot.rec,[Quot.liftIndepPr1, PSigma.snd, Quot.lift, Quot.indep, Quot.indepCoherent],[]]
[Lean.Parser.Tactic.rotateRight,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Parser.Tactic.exact,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[true_or,[propext, Iff.intro, trivial, Or.inl],[Eq, Or, True]]
[System.Platform.isEmscripten,[System.Platform.getIsEmscripten, Unit.unit],[Bool]]
[Lean.Syntax.setArg,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.node, Array.setD],[Lean.Syntax]]
[Nat.ne_of_beq_eq_false,[False],[Not, Eq]]
[Std.Format.isNil,[Unit.unit, Std.Format.line, Std.Format.text, Std.Format.nest, Std.Format.append, Std.Format.group, Std.Format.tag, Bool, Bool.true, Bool.false],[Bool]]
[ex_of_PSigma,[Exists, Exists.intro],[Exists]]
[Subarray.instForInSubarray,[ForIn.mk, Subarray.forIn],[ForIn, Subarray]]
[modifyGetThe,[MonadStateOf.modifyGet],[]]
[Nat.ble_succ_eq_true,[Eq.refl, Bool.true, HEq.refl, Eq, Nat.ble, Nat.succ, rfl, PProd.fst],[Eq, Nat.ble, Nat.succ, Bool.true]]
[MonadControlT.liftWith,[],[]]
[Quot.indepCoherent,[PSigma.eta, Quot.sound],[Eq, Quot.indep]]
[UInt8.mul,[UInt8.mk, HMul.hMul, UInt8.val],[UInt8]]
[UInt64.complement,[HSub.hSub, OfNat.ofNat, HAdd.hAdd],[UInt64]]
[StateRefT'.modifyGet,[ST.Ref.modifyGet],[StateRefT']]
[IO.FS.Stream.Buffer.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FS.Stream.Buffer.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.FS.Stream.Buffer.mk, And]]
[ULift.down,[],[]]
[Std.Format.defWidth,[OfNat.ofNat],[Nat]]
[EIO,[EStateM, IO.RealWorld],[]]
[List.lt.brecOn,[List.lt.below.nil, List.lt.below.head, List.lt.below.tail],[]]
[instDecidableRelLtLtOfOrd,[inferInstanceAs, DecidableRel, Eq, BEq.beq, Ord.compare, Ordering.lt, Bool.true],[DecidableRel, LT.lt]]
[«termΣ'_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[List.isPrefixOf,[List.nil, List.cons, Bool, Bool.true, Bool.false, and, BEq.beq, PProd.fst],[Bool]]
[ByteArray.foldlMUnsafe,[ite, LT.lt, LE.le, ByteArray.size, USize.ofNat, Pure.pure, ByteArray.foldlMUnsafe.fold],[]]
[Std.Range.«term[_:_:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[«term_^^^_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[String.Iterator.forward,[String.Iterator, PProd.fst, String.Iterator.next],[String.Iterator]]
[instToStringId_1,[inferInstanceAs, ToString],[ToString, Id]]
[Array.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Array.mk, HAdd.hAdd, OfNat.ofNat]]
[Lean.Syntax.ibelow,[True, And],[]]
[IO.FS.SystemTime.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.FS.SystemTime.mk, HAdd.hAdd, OfNat.ofNat]]
[Array.modifyOp,[Array.modify],[Array]]
[StateRefT'.instMonadFunctorStateRefT',[inferInstanceAs, MonadFunctor, ReaderT, ST.Ref],[MonadFunctor, StateRefT']]
[instToStringBool,[ToString.mk, cond],[ToString, Bool]]
[Subarray.h₂,[],[LE.le, Subarray.stop, Array.size, Subarray.as]]
[Nat.lt_of_le_and_ne,[LT.lt, Nat.eq_or_lt_of_le, absurd],[LT.lt]]
[System.FilePath.isAbsolute,[or, List.contains, System.FilePath.pathSeparators, String.front, System.FilePath.toString, and, System.Platform.isWindows, Decidable.decide, GE.ge, String.bsize, OfNat.ofNat, BEq.beq, String.getOp, Char.ofNat],[Bool]]
[IO.Process.Stdio.piped.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.Process.Stdio.piped, OfNat.ofNat]]
[Lean.Parser.Tactic.Conv.simp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpStar, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma],[Lean.ParserDescr]]
[Prod.mk.inj,[And.intro],[And, Eq]]
[Subarray.forInUnsafe,[USize.ofNat, Subarray.start, Subarray.forInUnsafe.loop],[]]
[Lean.instEval_1,[Lean.Eval.mk, IO.println, repr, Unit.unit],[Lean.Eval]]
[Nat.mod,[WellFounded.fix, Nat.mod.proof_1, dite, And, LT.lt, OfNat.ofNat, LE.le, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le],[Nat]]
[EIO.toIO,[EStateM.adaptExcept],[IO]]
[List.partitionAux,[Prod, List, Prod.mk, List.reverse, Unit.unit, PProd.fst, List.cons],[Prod, List]]
[Fin.decLt,[Nat.decLt, Fin.val],[Decidable, LT.lt]]
[USize.lt,[LT.lt, USize.val],[]]
[Lean.Name.eraseMacroScopes,[Unit.unit, Lean.Name, Lean.Name.hasMacroScopes, BEq.beq, PProd.fst, Lean.Name.anonymous],[Lean.Name]]
[UInt64.xor,[UInt64.mk, Fin.xor, UInt64.val],[UInt64]]
[Thunk.pure,[Thunk.mk],[Thunk]]
[IO.FS.Stream.isEof,[],[IO, Bool]]
[UInt32.ofNat',[UInt32.mk, Fin.mk],[UInt32]]
[LE.noConfusionType,[],[]]
[Lean.unifConstraint,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[MonadControl.stM,[],[]]
[Lean.Syntax.find?,[Lean.Syntax.findAux],[Option, Lean.Syntax]]
[Lean.PrettyPrinter.UnexpandM,[EStateM, Unit],[]]
[outParam,[],[]]
[ReprTuple.reprTuple,[],[List, Std.Format]]
[instDecidableFalse,[Decidable.isFalse, not_false],[Decidable, False]]
[StdGen.s2,[],[Nat]]
[instSTWorld,[STWorld.mk],[STWorld]]
[Lean.Parser.Tactic.Conv.pattern,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Inhabited.default,[],[]]
[Lean.Parser.Tactic.Conv.convSeq,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.Parser.Tactic.Conv.convSeq1Indented, Lean.Parser.Tactic.Conv.convSeqBracketed],[Lean.ParserDescr]]
[Xor.xor,[],[]]
[Lean.Syntax.isFieldIdx?,[Option.none, Option, Nat, Lean.Syntax.isLit?, Lean.Syntax.decodeNatLitVal?, Lean.fieldIdxKind],[Option, Nat]]
[«prec(_)»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.isIdFirst,[or, Char.isAlpha, Decidable.decide, Eq, Char.ofNat, Lean.isLetterLike],[Bool]]
[MonadControlT.noConfusionType,[],[]]
[instInhabitedArrow_1,[Inhabited.mk, Pure.pure],[Inhabited]]
[Lean.Parser.Tactic.contradiction,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[StateT.monadControl,[MonadControl.mk, Prod, Bind.bind, MonadState.get, liftM, StateT.run, StateT, MonadStateOf.set, Pure.pure],[MonadControl, StateT]]
[Int.decEq.proof_2,[absurd],[False]]
[unexpandListToArray,[ite, Eq, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, Lean.Syntax.matchesNull, OfNat.ofNat, Bind.bind, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.getCurrMacroScope, Lean.MonadQuotation.getMainModule, Pure.pure, Lean.Syntax.node, Lean.SourceInfo.none, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Std.Range.start,[],[Nat]]
[LawfulApplicative.seq_assoc,[],[Eq, Seq.seq, Functor.map, Function.comp]]
[Std.Format.group.inj,[And.intro],[And, Eq]]
[IO.setRandSeed,[ST.Ref.set, IO.stdGenRef, mkStdGen],[IO, Unit]]
[if_pos,[Eq, ite, rfl, absurd],[Eq, ite]]
[Lean.instQuoteSyntax,[Lean.Quote.mk, id],[Lean.Quote, Lean.Syntax]]
[Nat.lt_wfRel,[WellFoundedRelation.mk, Nat.lt, Nat.lt_wfRel.proof_1],[WellFoundedRelation, Nat]]
[USize.decEq,[Decidable, Eq, dite, Decidable.isTrue, USize.decEq.proof_1, Decidable.isFalse, USize.decEq.proof_2],[Decidable, Eq]]
[instOrdString,[Ord.mk, compareOfLessAndEq],[Ord, String]]
[ExceptT.run,[],[Except]]
[List.filterRevM,[List.filterAuxM, List.reverse, List.nil],[List]]
[UInt8.decEq,[Decidable, Eq, dite, Decidable.isTrue, UInt8.decEq.proof_1, Decidable.isFalse, UInt8.decEq.proof_2],[Decidable, Eq]]
[Nat.le_step,[Nat.le.step],[LE.le, Nat.succ]]
[Or.intro_left,[Or.inl],[Or]]
[Nat.lt_succ_self,[Nat.lt.base],[LT.lt, Nat.succ]]
[List.forIn.loop,[Pure.pure, Bind.bind, PProd.fst],[]]
[Subarray.noConfusionType,[],[]]
[instInhabitedEIO,[inferInstanceAs, Inhabited, EStateM, IO.RealWorld],[Inhabited, EIO]]
[PointedType.noConfusionType,[],[]]
[Lean.mkOptionalNode,[Unit.unit, Lean.Syntax, Lean.mkNullNode, List.toArray, List.cons, List.nil],[Lean.Syntax]]
[Int.decEq.proof_5,[],[Int.noConfusionType, False, Int.ofNat, Int.negSucc]]
[Nat.lt_irrefl,[Nat.not_succ_le_self],[Not, LT.lt]]
[List.isEmpty,[Unit.unit, Bool, Bool.true, Bool.false],[Bool]]
[IO.Error.mkPermissionDenied,[IO.Error.permissionDenied, Option.none],[IO.Error]]
[List.rotateRight,[ite, LE.le, OfNat.ofNat, HAppend.hAppend],[List]]
[fix2,[fixCore2, arbitrary],[]]
[instAddUSize,[Add.mk, USize.add],[Add, USize]]
[LawfulFunctor.comp_map,[],[Eq, Functor.map, Function.comp]]
[Int.instModInt,[Mod.mk, Int.mod],[Mod, Int]]
[PLift.up_down,[Eq, PLift.up, PLift.down, rfl],[Eq, PLift.up, PLift.down]]
[ForIn.forIn,[],[]]
[Lean.unbracketedExplicitBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.binderIdent, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[Lean.isGreek,[and, Decidable.decide, LE.le, OfNat.ofNat, Char.val],[Bool]]
[UInt32.isValidChar,[Nat.isValidChar, UInt32.toNat],[]]
[Classical.«tacticByCases__:_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[List.append,[List, List.cons, PProd.fst],[List]]
[Array.mapIdx,[Id.run, Array.mapIdxM],[Array]]
[Bool.false.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Bool.false, OfNat.ofNat]]
[WellFounded.recursion,[WellFounded.apply],[]]
[instMonadWithReader,[MonadWithReader.mk, withTheReader],[MonadWithReader]]
[Nat.succ_le_of_lt,[],[LE.le, Nat.succ]]
[Lean.Syntax.setHeadInfo,[Unit.unit, Lean.Syntax, Lean.Syntax.setHeadInfoAux],[Lean.Syntax]]
[List.getLast,[absurd, List.getLast.proof_1, PProd.fst, List.getLast.proof_2],[]]
[AndThen.noConfusionType,[],[]]
[UInt32.mul,[UInt32.mk, HMul.hMul, UInt32.val],[UInt32]]
[eqRec_heq,[Eq.symm, eq_of_heq, Eq.refl, HEq.refl, HEq],[HEq]]
[instComplementUSize,[Complement.mk, USize.complement],[Complement, USize]]
[String.Iterator.prev,[String.Iterator, String.Iterator.mk, String.prev],[String.Iterator]]
[Std.Range.«term[_:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.explicitBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.bracketedExplicitBinders, Lean.unbracketedExplicitBinders],[Lean.ParserDescr]]
[USize.shiftRight,[USize.mk, HShiftRight.hShiftRight, USize.val, USize.modn, System.Platform.numBits],[USize]]
[List.mapA,[Unit.unit, List, Pure.pure, List.nil, Seq.seq, Functor.map, List.cons, PProd.fst],[List]]
[Array.mapM,[Array.foldlM, Bind.bind, Pure.pure, Array.push, Array.mkEmpty, Array.size, OfNat.ofNat],[Array]]
[Array.filter,[Array.foldl, ite, Eq, Bool.true, Array.push, List.toArray, List.nil],[Array]]
[instInhabitedUInt16.proof_1,[of_decide_eq_true, Eq.refl, Bool.true],[LT.lt, OfNat.ofNat, UInt16.size]]
[IO.FS.Stream.mk.inj,[And.intro],[And, Eq]]
[List.mapTR,[List.mapTRAux, List.nil],[List]]
[Sigma.snd,[],[Sigma.fst]]
[Nat.lt_of_succ_le,[],[LT.lt]]
[Option.bind,[Option, Option.none],[Option]]
[UInt32.shiftLeft,[UInt32.mk, HShiftLeft.hShiftLeft, UInt32.val, UInt32.modn, OfNat.ofNat],[UInt32]]
[ReaderT.map,[Functor.map],[ReaderT]]
[dbgTraceVal,[dbgTrace, ToString.toString],[]]
[Lean.Meta.TransparencyMode.all.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Meta.TransparencyMode.all, OfNat.ofNat]]
[EStateM.instInhabitedResult,[Inhabited.mk, EStateM.Result.error, arbitrary],[Inhabited, EStateM.Result]]
[Int.negSucc.injEq,[Eq.propIntro, Eq.refl, Int.negSucc, Eq.symm, eq_of_heq, HEq.refl],[Eq, Int.negSucc]]
[Lean.Name.instToStringName,[ToString.mk, Lean.Name.toString, Bool.true],[ToString, Lean.Name]]
[WellFoundedRelation.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, WellFoundedRelation.mk, HAdd.hAdd, OfNat.ofNat]]
[List.hasDecEq.proof_3,[],[List.noConfusionType, False, List.nil, List.cons]]
[IO.Error.interrupted.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.interrupted, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.interrupted, And]]
[Lean.Syntax.missing.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Lean.Syntax.missing, OfNat.ofNat]]
[Array.forIn.loop,[Pure.pure],[]]
[Lean.Syntax.isScientificLit?,[Option.none, Option, Prod, Nat, Bool, Lean.Syntax.isLit?, Lean.scientificLitKind, Lean.Syntax.decodeScientificLitVal?],[Option, Prod, Nat, Bool]]
[prodHasDecidableLt,[inferInstanceAs, Decidable, Or, LT.lt, Prod.fst, And, Eq, Prod.snd],[Decidable, LT.lt]]
[Hashable.hash,[],[UInt64]]
[Div.noConfusionType,[],[]]
[randNat,[Prod, Nat, Prod.mk],[Prod, Nat]]
[Array.anyMUnsafe,[ite, LT.lt, LE.le, Array.size, USize.ofNat, Pure.pure, Bool.false, Array.anyMUnsafe.any],[Bool]]
[instOfNatUInt8,[OfNat.mk, UInt8.ofNat],[OfNat, UInt8]]
[Std.Format.line.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, Std.Format.line, OfNat.ofNat]]
[Lean.version.isRelease,[Lean.version.getIsRelease, Unit.unit],[Bool]]
[IO.Error.protocolError.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.protocolError, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.protocolError, And]]
[instMonadState,[MonadState.mk, getThe, MonadStateOf.set, MonadStateOf.modifyGet],[MonadState]]
[Lean.Parser.Tactic.«tacticHave'__:=_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[instMonadStateOfStateT,[MonadStateOf.mk, StateT.get, StateT.set, StateT.modifyGet],[MonadStateOf, StateT]]
[instTransEq_1.proof_1,[],[]]
[List.groupByAux,[List.nil, List.cons, List, Unit.unit, PProd.fst, List.reverse],[List]]
[UInt16.val,[],[Fin, UInt16.size]]
[Lean.Parser.Tactic.inductionAlts,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat, OfNat.ofNat, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlt],[Lean.ParserDescr]]
[Bind.bind,[],[]]
[USize.lor,[USize.mk, Fin.lor, USize.val],[USize]]
[Float.le,[FloatSpec.le, floatSpec, Float.val],[]]
[StateM,[StateT, Id],[]]
[Function.comp_apply,[rfl],[Eq, Function.comp]]
[Std.Format.bracketFill,[Std.Format.fill, Std.Format.nest, Int.ofNat, String.length, HAppend.hAppend, Std.Format.text],[Std.Format]]
[Lean.Macro.instInhabitedState,[Inhabited.mk, Lean.Macro.State.mk, arbitrary],[Inhabited, Lean.Macro.State]]
[FloatArray.empty,[FloatArray.mkEmpty, OfNat.ofNat],[FloatArray]]
[Subrelation.wf.proof_1,[WellFounded.intro, Subrelation.accessible, WellFounded.apply],[WellFounded]]
[Std.Format.instMonadPrettyFormatStateMState,[Std.Format.MonadPrettyFormat.mk, modify, HAppend.hAppend, HAdd.hAdd, String.length, String.pushn, Char.ofNat, Bind.bind, MonadState.get, Pure.pure, Unit.unit],[Std.Format.MonadPrettyFormat, StateM]]
[Subarray.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, Subarray.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Subarray.mk, And]]
[Subarray.foldlM,[Array.foldlM, Subarray.as, Subarray.start, Subarray.stop],[]]
[Substring.any,[Bool, String.anyAux],[Bool]]
[instToStringFormat,[ToString.mk, Std.Format.pretty, Std.Format.defWidth],[ToString, Std.Format]]
[System.Platform.isWindows,[System.Platform.getIsWindows, Unit.unit],[Bool]]
[Lean.Syntax.SepArray.instCoeTailSepArrayArraySyntax,[CoeTail.mk, Lean.Syntax.SepArray.getElems],[CoeTail, Lean.Syntax.SepArray, Array, Lean.Syntax]]
[Lean.Macro.withFreshMacroScope,[Bind.bind, MonadState.modifyGet, Prod.mk, Lean.Macro.State.macroScope, Lean.Macro.State.mk, HAdd.hAdd, OfNat.ofNat, Lean.Macro.State.traceMsgs, MonadWithReader.withReader, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth, Lean.Macro.Context.ref],[Lean.MacroM]]
[Quotient.inductionOn₂,[Quotient.ind],[]]
[USize.modn_lt,[LT.lt, USize.toNat, HMod.hMod, Fin.modn_lt],[LT.lt, USize.toNat, HMod.hMod]]
[LawfulApplicative.map_pure,[],[Eq, Functor.map, Pure.pure]]
[Lean.SourceInfo.getPos?,[Lean.SourceInfo.synthetic, Bool.true, Lean.SourceInfo.none, Option, String.Pos, Option.some, Option.none],[Option, String.Pos]]
[PSum.inl.injEq,[Eq.propIntro, Eq.refl, PSum.inl, Eq.symm, eq_of_heq, HEq.refl],[Eq, PSum.inl]]
[EmptyCollection.noConfusionType,[],[]]
[MonadExcept.instOrElse,[OrElse.mk, MonadExcept.orElse],[OrElse]]
[IO.FS.SystemTime.sec,[],[Int]]
[Nat.gcd_zero_left,[rfl],[Eq, Nat.gcd, OfNat.ofNat]]
[Std.instInhabitedFormat,[Inhabited.mk, Std.Format.nil],[Inhabited, Std.Format]]
[UInt8.noConfusionType,[],[]]
[StateCpsT.runK_monadLift,[rfl],[Eq, StateCpsT.runK, MonadLiftT.monadLift, Bind.bind]]
[Nat.decLe,[dite, Eq, Nat.ble, Bool.true, Decidable.isTrue, Nat.le_of_ble_eq_true, Decidable.isFalse, Nat.not_le_of_not_ble_eq_true],[Decidable, LE.le]]
[String.replace,[OfNat.ofNat, String.replace.loop],[String]]
[List.noConfusionType,[],[]]
[EStateM.run,[],[EStateM.Result]]
[Eq.mpr_prop,[Eq.symm],[]]
[instReprUInt16,[Repr.mk, repr, UInt16.toNat],[Repr, UInt16]]
[IO.AccessRight.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.AccessRight.mk, HAdd.hAdd, OfNat.ofNat]]
[Array.size_set,[List.length_set, Array.data, Fin.val],[Eq, Array.size, Array.set]]
[Lean.Meta.TransparencyMode.noConfusionType,[noConfusionTypeEnum, Lean.Meta.TransparencyMode.toCtorIdx],[]]
[StateT.run'_eq,[rfl],[Eq, StateT.run', Functor.map, Prod.fst, StateT.run]]
[IO.Error.hardwareFault.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Error.hardwareFault, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.hardwareFault, And]]
[Char.instDecidableLe,[UInt32.decLe, Char.val],[Decidable, LE.le]]
[type_eq_of_heq.proof_1,[HEq.ndrecOn, Eq.refl],[Eq]]
[Std.Format.groupEx,[Std.Format.group, Std.Format.FlattenBehavior.allOrNone],[Std.Format]]
[Lean.PrettyPrinter.instMonadQuotationUnexpandM,[Lean.MonadQuotation.mk, Pure.pure, OfNat.ofNat, Lean.Name.mkStr, Lean.Name.anonymous, id],[Lean.MonadQuotation, Lean.PrettyPrinter.UnexpandM]]
[DecidableEq,[Decidable, Eq],[]]
[ByteArray.forIn,[ByteArray.size, Nat.le_refl, ByteArray.forIn.loop],[]]
[IO.FS.instBEqFileType,[BEq.mk, BEq.beq, IO.FS.FileType.toCtorIdx],[BEq, IO.FS.FileType]]
[ExceptCpsT.lift,[Bind.bind],[ExceptCpsT]]
[Lean.Parser.Tactic.simpErase,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat],[Lean.ParserDescr]]
[MonadControl.liftWith,[],[]]
[Lean.Parser.Tactic.rwRuleSeq,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.rwRule, Bool.true],[Lean.ParserDescr]]
[Array.swap!,[dite, LT.lt, Array.size, Array.swap, Fin.mk, panicWithPosWithDecl, OfNat.ofNat],[Array]]
[IO.FS.instBEqSystemTime,[BEq.mk, Bool, and, Bool.true, BEq.beq, Bool.false],[BEq, IO.FS.SystemTime]]
[USize.decEq.proof_2,[absurd],[False]]
[Nat.succ.inj,[],[Eq]]
[IO.FS.DirEntry.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.FS.DirEntry.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.FS.DirEntry.mk, And]]
[Array.empty,[Array.mkEmpty, OfNat.ofNat],[Array]]
[IO.Process.StdioConfig.stderr,[],[IO.Process.Stdio]]
[Nat.le_of_lt_succ,[Nat.le_of_succ_le_succ],[LE.le]]
[Char.toLower,[ite, And, GE.ge, OfNat.ofNat, LE.le, Char.ofNat, HAdd.hAdd],[Char]]
[MonadExcept.noConfusionType,[],[]]
[instLEUInt32,[LE.mk, LE.le, UInt32.val],[LE, UInt32]]
[System.FilePath.fileStem,[Option.map, Unit.unit, dite, Eq, Eq.symm, String, String.revPosOf, Char.ofNat, String.extract, OfNat.ofNat, System.FilePath.fileName],[Option, String]]
[ByteArray.get,[UInt8, Array.get],[UInt8]]
[instReprSubtype,[Repr.mk, Repr.reprPrec, Subtype.val],[Repr, Subtype]]
[Nat.lt_of_le_of_ne,[LT.lt, Nat.lt_or_ge, absurd, Nat.le_antisymm],[LT.lt]]
[Unit.unit,[PUnit.unit],[Unit]]
[«term_&&_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instStreamSubarray,[Stream.mk, dite, LT.lt, Subarray.start, Subarray.stop, Option.none],[Stream, Subarray]]
[eq_false_of_ne_true,[Eq, Bool.false, False.elim, rfl],[Eq, Bool.false]]
[String.extract,[String, ite, GE.ge, String.mk, List.nil, List.cons, List, Char, Eq, PProd.fst, HAdd.hAdd, String.csize, OfNat.ofNat],[String]]
[StateT.run_monadMap,[rfl],[Eq, StateT.run, MonadFunctorT.monadMap]]
[instInhabitedBool,[Inhabited.mk, Bool.false],[Inhabited, Bool]]
[bfix6,[PProd.fst],[]]
[Lean.Parser.Tactic.Conv.conv.quot,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[IO.FS.Mode.toCtorIdx,[OfNat.ofNat],[Nat]]
[UInt8.toNat,[Fin.val, UInt8.val],[Nat]]
[Nat.le_eq,[rfl],[Eq, Nat.le, LE.le]]
[Lean.evalPrec,[Lean.Macro.withIncRecDepth, Bind.bind, Lean.expandMacros, cond, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Option.getD, Lean.Syntax.isNatLit?, OfNat.ofNat, Lean.Macro.throwErrorAt],[Lean.MacroM, Nat]]
[Lean.MonadQuotation.getCurrMacroScope,[],[Lean.MacroScope]]
[USize.land,[USize.mk, Fin.land, USize.val],[USize]]
[Lean.Syntax.matchesNull,[Lean.Syntax.isNodeOf, Lean.nullKind],[Bool]]
[MonadLift.noConfusionType,[],[]]
[IO.Error.resourceBusy.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.resourceBusy, HAdd.hAdd, OfNat.ofNat]]
[AndThen.andThen,[],[]]
[namedPattern,[],[]]
[LawfulMonad.bind_assoc,[],[Eq, Bind.bind]]
[Lean.Syntax.isNatLit?,[Option.none, Option, Nat, Lean.Syntax.isLit?, Lean.Syntax.decodeNatLitVal?, Lean.numLitKind],[Option, Nat]]
[Option.isNone,[Unit.unit, Bool, Bool.false, Bool.true],[Bool]]
[withPtrEqDecEq.proof_2,[ofBoolUsing_eq_true],[Eq]]
[IO.FS.Stream.getLine,[],[IO, String]]
[Lean.Macro.getCurrNamespace,[Bind.bind, Lean.Macro.getMethods, Lean.Macro.Methods.getCurrNamespace],[Lean.MacroM, Lean.Name]]
[MonadWithReaderOf.withReader,[],[]]
[List.findSome?,[Unit.unit, Option, Option.none, Option.some, PProd.fst],[Option]]
[Repr.noConfusionType,[],[]]
[Substring.prev,[String.Pos, ite, Eq, HSub.hSub, String.prev],[String.Pos]]
[id_eq,[rfl],[Eq, id]]
[List.append_assoc,[rfl, of_eq_true, Eq.trans, congr, congrArg, Eq, congrFun, HAppend.hAppend, List.cons_append, List.cons, eq_self],[Eq, HAppend.hAppend]]
[IO.FS.Stream.putStrLn,[IO.FS.Stream.putStr, String.push, Char.ofNat],[IO, Unit]]
[PSum.inr.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, PSum.inr, HAdd.hAdd, OfNat.ofNat]]
[id_map',[LawfulFunctor.id_map],[Eq, Functor.map]]
[List.eraseDups,[List.eraseDupsAux, List.nil],[List]]
[Lean.Meta.Simp.Config.contextual,[],[Bool]]
[instToStringId,[inferInstanceAs, ToString],[ToString, id]]
[USize.modn,[USize.mk, HMod.hMod, USize.val],[USize]]
[Quotient.lift₂.proof_1,[Setoid.refl],[Eq]]
[WellFoundedRelation.rel,[],[]]
[Std.Format.below,[PUnit, PProd],[]]
[Char.isAlpha,[or, Char.isUpper, Char.isLower],[Bool]]
[Array.concatMapM,[Array.foldlM, Bind.bind, Pure.pure, HAppend.hAppend, Array.empty, OfNat.ofNat, Array.size],[Array]]
[String.Iterator.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, String.Iterator.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, String.Iterator.mk, And]]
[Subarray.anyM,[Array.anyM, Subarray.as, Subarray.start, Subarray.stop],[Bool]]
[HPow.hPow,[],[]]
[OrElse.orElse,[],[]]
[List.instLEList,[LE.mk, List.le],[LE, List]]
[PSum.inr.inj,[],[Eq]]
[Array.findSomeRevM?.find.proof_2,[Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.lt_succ_self],[LE.le, Array.size]]
[String.toNat!,[ite, Eq, String.isNat, Bool.true, String.foldl, HAdd.hAdd, HMul.hMul, OfNat.ofNat, HSub.hSub, Char.toNat, Char.ofNat, panicWithPosWithDecl],[Nat]]
[Nat.add_left_comm,[Eq.mpr, Eq.refl, Eq, HAdd.hAdd, Eq.symm, Nat.add_assoc, Nat.add_comm, rfl],[Eq, HAdd.hAdd]]
[instMonadReader,[MonadReader.mk, readThe],[MonadReader]]
[instNonempty.proof_1,[Nonempty.intro, arbitrary],[Nonempty]]
[IO.Error.mkAlreadyExists,[IO.Error.alreadyExists, Option.none],[IO.Error]]
[IO.FS.instOrdSystemTime,[Ord.mk, Ordering, Unit.unit, Ord.compare, Ordering.lt, Ordering.gt, Ordering.eq],[Ord, IO.FS.SystemTime]]
[implies_congr,[rfl],[Eq]]
[ByteArray.findIdx?,[ByteArray.findIdx?.loop],[Option, Nat]]
[UInt64.val,[],[Fin, UInt64.size]]
[getThe,[MonadStateOf.get],[]]
[List.groupBy,[Unit.unit, List, List.nil, List.groupByAux, List.cons],[List]]
[heq_of_heq_of_eq,[HEq.trans, heq_of_eq],[HEq]]
[FloatArray.uset,[FloatArray, FloatArray.mk, Array.uset],[FloatArray]]
[ReaderT.instLawfulMonadReaderT.proof_1,[LawfulMonad.mk, ReaderT.ext, Eq.mpr, congr, congrArg, Eq, Eq.trans, ReaderT.run_bind, Pure.pure, Bind.bind, ReaderT.run, funext, ReaderT.run_pure, ReaderT.run_map, LawfulMonad.bind_pure_comp, rfl, of_eq_true, congrFun, LawfulMonad.pure_bind, eq_self, LawfulMonad.bind_assoc],[LawfulMonad, ReaderT]]
[Lean.MacroScopesView.mainModule,[],[Lean.Name]]
[fixCore1,[bfix1, USize.size],[]]
[FloatArray.push,[FloatArray, FloatArray.mk, Array.push],[FloatArray]]
[Bool.false_and,[rfl, Eq.symm, Eq.refl],[Eq, and, Bool.false]]
[PProd.snd,[],[]]
[IO.Process.SpawnArgs.toStdioConfig,[],[IO.Process.StdioConfig]]
[Prod.rprod,[WellFoundedRelation.mk, Prod.RProd, WellFoundedRelation.rel, Prod.rprod.proof_1],[WellFoundedRelation, Prod]]
[ByteArray.set,[ByteArray, ByteArray.mk, Array.set],[ByteArray]]
[EIO.asTask,[BaseIO.asTask, EIO.toBaseIO],[BaseIO, Task, Except]]
[Lean.Syntax.isToken,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Bool, BEq.beq, String.trim, Bool.false],[Bool]]
[StateT.run_pure,[rfl],[Eq, StateT.run, Pure.pure, Prod.mk]]
[ne_true_of_eq_false,[Not, Eq, Bool.true],[Not, Eq, Bool.true]]
[List.length_dropLast,[Unit.unit, Eq, List.length, List.dropLast, HSub.hSub, OfNat.ofNat, rfl],[Eq, List.length, List.dropLast, HSub.hSub, OfNat.ofNat]]
[ForInStep.done.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, ForInStep.done, HAdd.hAdd, OfNat.ofNat]]
[Quotient.liftOn₂,[Quotient.lift₂],[]]
[ByteArray.mk.injEq,[Eq.propIntro, Eq.refl, ByteArray.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, ByteArray.mk]]
[Nat.mod_eq,[congrFun, WellFounded.fix_eq, WellFoundedRelation.wf, measure, id, dite, And, LT.lt, OfNat.ofNat, LE.le, HSub.hSub, Nat.sub_lt, Nat.lt_of_lt_of_le, dif_eq_if, HMod.hMod],[Eq, HMod.hMod, ite, And, LT.lt, OfNat.ofNat, LE.le, HSub.hSub]]
[Eq.symm,[rfl],[Eq]]
[Option.map_id,[funext, Unit.unit, Eq, Option.map, id, rfl],[Eq, Option.map, id]]
[UInt64.add,[UInt64.mk, HAdd.hAdd, UInt64.val],[UInt64]]
[List.instForInList,[ForIn.mk, List.forIn],[ForIn, List]]
[UInt16.decLt,[Decidable, LT.lt, inferInstanceAs],[Decidable, LT.lt]]
[Option.getD,[],[]]
[String.next,[HAdd.hAdd, String.csize],[String.Pos]]
[IO.Process.StdioConfig.mk.injEq,[Eq.propIntro, And.intro, Eq.refl, IO.Process.StdioConfig.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Process.StdioConfig.mk, And]]
[Std.Format.MonadPrettyFormat.startTag,[],[Unit]]
[IO.AccessRight.write,[],[Bool]]
[instHModUInt32NatUInt32,[HMod.mk, UInt32.modn],[HMod, UInt32, Nat]]
[Sum.noConfusionType,[],[]]
[List.replicate,[List.nil, List.replicate.loop],[List]]
[Lean.numLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Fin.instMulFin,[Mul.mk, Fin.mul],[Mul, Fin]]
[instToStringByteArray,[ToString.mk, List.toString, ByteArray.toList],[ToString, ByteArray]]
[OfScientific.ofScientific,[],[]]
[String.decapitalize,[String.set, OfNat.ofNat, Char.toLower, String.get],[String]]
[instToStringSigma,[ToString.mk, String, HAppend.hAppend, ToString.toString],[ToString, Sigma]]
[stx_?,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[IO.FS.Handle.readToEnd,[IO.FS.Handle.readToEnd.loop],[IO, String]]
[List.or,[List.any, id],[Bool]]
[DecidablePred,[Decidable],[]]
[List.asString,[String.mk],[String]]
[List.reverse_cons,[Eq.mpr, Eq.refl, Eq, List.reverseAux, List.cons, List.nil, HAppend.hAppend, Eq.symm, List.reverseAux_eq_append, rfl],[Eq, List.reverse, List.cons, HAppend.hAppend, List.nil]]
[ByteArray.copySlice,[ByteArray.mk, HAppend.hAppend, Array.extract, ByteArray.data, OfNat.ofNat, HAdd.hAdd, Array.size],[ByteArray]]
[Option.any,[Unit.unit, Bool, Bool.false],[Bool]]
[Lean.instQuoteSubstring,[Lean.Quote.mk, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Quote.quote, Substring.toString, List.nil],[Lean.Quote, Substring]]
[UInt16.ofNat,[UInt16.mk, Fin.ofNat],[UInt16]]
[Lean.Name.capitalize,[Lean.Name.anonymous, Lean.Name.num, Lean.Name, Lean.Name.mkStr, String.capitalize],[Lean.Name]]
[Quotient.lift₂.proof_2,[Quotient.ind, Setoid.refl],[Eq, Quotient.lift, Setoid.refl]]
[instDecidableIff.proof_4,[Iff.intro, absurd],[Iff]]
[Option.instFunctorOption,[Functor.mk, Option.map],[Functor, Option]]
[Nat.toUInt32,[UInt32.ofNat],[UInt32]]
[Lean.Syntax.decodeStrLit,[Lean.Syntax.decodeStrLitAux, OfNat.ofNat],[Option, String]]
[Int.decEq.proof_6,[],[Int.noConfusionType, False, Int.negSucc, Int.ofNat]]
[instSubUSize,[Sub.mk, USize.sub],[Sub, USize]]
[Float.lt,[FloatSpec.lt, floatSpec],[]]
[instToStringUSize,[ToString.mk, ToString.toString, USize.toNat],[ToString, USize]]
[UInt8.decEq.proof_2,[absurd],[False]]
[Nat.mod.inductionOn,[Nat.div.inductionOn],[]]
[List.zip,[List.zipWith, Prod.mk],[List, Prod]]
[Quot.liftBeta,[rfl],[Eq, Quot.lift, Quot.mk]]
[IO.Error.mkPermissionDeniedFile,[Function.comp, IO.Error.permissionDenied, Option.some],[IO.Error]]
[Lean.Meta.Simp.Config.beta,[],[Bool]]
[IO.FS.Mode.noConfusionType,[noConfusionTypeEnum, IO.FS.Mode.toCtorIdx],[]]
[Nat.shiftRight,[Nat, HDiv.hDiv, PProd.fst, OfNat.ofNat],[Nat]]
[Lean.SourceInfo.noConfusionType,[],[]]
[String.offsetOfPos,[String.offsetOfPosAux, OfNat.ofNat],[Nat]]
[Classical.decidableInhabited,[Inhabited.mk, inferInstance],[Inhabited, Decidable]]
[Lean.Parser.Tactic.«tacticNext___=>_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Meta.instInhabitedTransparencyMode,[Inhabited.mk, Lean.Meta.TransparencyMode.all],[Inhabited, Lean.Meta.TransparencyMode]]
[instShiftLeftUInt8,[ShiftLeft.mk, UInt8.shiftLeft],[ShiftLeft, UInt8]]
[Nat.pred_le_pred,[Nat.zero, Eq.symm, eq_of_heq, Eq.refl, HEq.refl, Nat.succ, LE.le, Nat.pred, Nat.le.refl, Nat.le_trans, Nat.le_succ],[LE.le, Nat.pred]]
[Lean.mkCIdent,[Lean.mkCIdentFrom, Lean.Syntax.missing],[Lean.Syntax]]
[UInt32.noConfusionType,[],[]]
[Lean.MacroScopesView.name,[],[Lean.Name]]
[List.eraseIdx,[List, List.nil, List.cons, PProd.fst],[List]]
[String.substrEq,[and, Decidable.decide, LE.le, HAdd.hAdd, String.bsize, String.substrEq.loop],[Bool]]
[Std.Format.defIndent,[OfNat.ofNat],[Nat]]
[Lean.Meta.Simp.ConfigCtx.mk.injEq,[Eq.propIntro, Eq.refl, Lean.Meta.Simp.ConfigCtx.mk, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Meta.Simp.ConfigCtx.mk]]
[Neg.neg,[],[]]
[instLEUInt16,[LE.mk, UInt16.le],[LE, UInt16]]
[compareOfLessAndEq,[ite, LT.lt, Ordering.lt, Eq, Ordering.eq, Ordering.gt],[Ordering]]
[Nat.mod_lt,[Nat.mod.inductionOn],[LT.lt, HMod.hMod]]
[Prod.lexAccessible,[Prod.lexAccessible.proof_1],[Acc, Prod.Lex, Prod.mk]]
[USize.mod,[USize.mk, HMod.hMod, USize.val],[USize]]
[WellFoundedRelation.noConfusionType,[],[]]
[Subtype.mk.inj,[],[Eq]]
[Nat.add_succ,[rfl],[Eq, HAdd.hAdd, Nat.succ]]
[WellFoundedRelation.mk.inj,[],[Eq]]
[Ordering.noConfusionType,[noConfusionTypeEnum, Ordering.toCtorIdx],[]]
[IO.Process.StdioConfig.stdout,[],[IO.Process.Stdio]]
[Function.Equiv,[Eq],[]]
[Quot.recOnSubsingleton.proof_1,[Subsingleton.elim, Quot.sound],[Eq, Quot.sound]]
[instToStringProd,[ToString.mk, String, HAppend.hAppend, ToString.toString],[ToString, Prod]]
[Array.instInhabitedArray,[Inhabited.mk, Array.empty],[Inhabited, Array]]
[Array.instForInArray,[ForIn.mk, Array.forIn],[ForIn, Array]]
[Ordering.noConfusion,[noConfusionEnum, Ordering.toCtorIdx],[Ordering.noConfusionType]]
[EStateM.Backtrackable.noConfusionType,[],[]]
[Lean.Meta.Simp.ConfigCtx.mk.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Meta.Simp.ConfigCtx.mk, HAdd.hAdd, OfNat.ofNat]]
[Array.toList,[Array.foldr, List.cons, List.nil, Array.size, OfNat.ofNat],[List]]
[StateT.instMonadStateT,[Monad.mk],[Monad, StateT]]
[Nat.below,[PUnit, PProd],[]]
[List.cons.inj,[And.intro],[And, Eq]]
[SeqRight.seqRight,[],[]]
[Pure.noConfusionType,[],[]]
[Std.Range.forIn.loop,[ite, GE.ge, Std.Range.stop, Pure.pure, Unit.unit, Bind.bind, PProd.fst, HAdd.hAdd, Std.Range.step],[]]
[Fin.shiftRight.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, HShiftRight.hShiftRight]]
[Substring.stopPos,[],[String.Pos]]
[ST.Ref.h,[],[Nonempty]]
[FloatSpec.decLe,[],[DecidableRel, FloatSpec.le]]
[coeSort,[CoeSort.coe],[]]
[Lean.instInhabitedSourceInfo,[Inhabited.mk, Lean.SourceInfo.none],[Inhabited, Lean.SourceInfo]]
[Lean.Parser.Tactic.traceState,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[USize.shiftLeft,[USize.mk, HShiftLeft.hShiftLeft, USize.val, USize.modn, System.Platform.numBits],[USize]]
[instToStringUnit,[ToString.mk],[ToString, Unit]]
[ReaderT.read,[Pure.pure],[ReaderT]]
[instInhabitedUInt64,[Inhabited.mk, UInt64.ofNatCore, OfNat.ofNat, instInhabitedUInt64.proof_1],[Inhabited, UInt64]]
[Array.unzip,[Array.foldl, Prod, Array, Prod.mk, Array.push, List.toArray, List.nil, OfNat.ofNat, Array.size],[Prod, Array]]
[instSTWorldEST,[STWorld.mk],[STWorld, EST]]
[Lean.Syntax.atom.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, Lean.Syntax.atom, HAdd.hAdd, OfNat.ofNat]]
[Array.anyM.proof_1,[Nat.le_refl, Array.size],[LE.le, Array.size]]
[StateCpsT.instLawfulMonadStateCpsT.proof_1,[LawfulMonad.mk, rfl],[LawfulMonad, StateCpsT]]
[ST.Prim.Ref.modifyUnsafe,[Bind.bind, ST.Prim.Ref.take, ST.Prim.Ref.set],[ST, Unit]]
[instDecidableEqQuotient.proof_1,[instSubsingletonDecidable, Eq, Quotient.mk],[Subsingleton, Decidable, Eq, Quotient.mk]]
[HEq.trans,[HEq.subst],[HEq]]
[Lean.Meta.Simp.Config.eta,[],[Bool]]
[Fin.shiftLeft.proof_1,[LT.lt, HMod.hMod, Nat.mod_lt],[LT.lt, HMod.hMod, HShiftLeft.hShiftLeft]]
[StateCpsT.lift,[Bind.bind],[StateCpsT]]
[«term_||_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Fin.noConfusionType,[],[]]
[NonScalar.noConfusionType,[],[]]
[Subarray.all,[Id.run, Subarray.allM],[Bool]]
[instLEUInt64,[LE.mk, UInt64.le],[LE, UInt64]]
[EStateM.Result.ok.inj,[And.intro],[And, Eq]]
[Lean.Syntax.isNone,[Unit.unit, Lean.Syntax.atom, Lean.Syntax.ident, Bool, and, BEq.beq, Lean.nullKind, Array.size, OfNat.ofNat, Bool.true, Bool.false],[Bool]]
[fixCore5,[bfix5, USize.size],[]]
[«term_/\_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.replaceRef,[Option.none, Lean.Syntax, Lean.Syntax.getPos?, Bool.false],[Lean.Syntax]]
[Nat.lor,[Nat.bitwise, or],[Nat]]
[Lean.Syntax.expandInterpolatedStrChunks,[Bind.bind, ForIn.forIn, MProd.mk, Unit.unit, Lean.MacroM, ForInStep, MProd, Nat, Lean.Syntax, Lean.Syntax.isInterpolatedStrLit?, Lean.Syntax.mkStrLit, Lean.SourceInfo.none, Pure.pure],[Lean.MacroM, Lean.Syntax]]
[instLTUInt16,[LT.mk, UInt16.lt],[LT, UInt16]]
[instComplementUInt16,[Complement.mk, UInt16.complement],[Complement, UInt16]]
[String.Iterator.nextn,[String.Iterator, PProd.fst, String.Iterator.next],[String.Iterator]]
[IO.FS.Mode.append.sizeOf_spec,[Eq.refl, OfNat.ofNat],[Eq, SizeOf.sizeOf, IO.FS.Mode.append, OfNat.ofNat]]
[Lean.Parser.Tactic.withReducibleAndInstances,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[CoeTC.noConfusionType,[],[]]
[withPtrAddr,[OfNat.ofNat],[]]
[System.Platform.numBits,[Subtype.val, System.Platform.getNumBits, Unit.unit],[Nat]]
[EStateM.instMonadEStateM,[Monad.mk],[Monad, EStateM]]
[UInt64.land,[UInt64.mk, Fin.land, UInt64.val],[UInt64]]
[pure_id_seq,[of_eq_true, Eq.trans, congrFun, congrArg, Eq, LawfulApplicative.pure_seq, id, LawfulFunctor.id_map, eq_self],[Eq, Seq.seq, Pure.pure, id]]
[instMulFloat,[Mul.mk, Float.mul],[Mul, Float]]
[Lean.Eval.eval,[],[IO, Unit]]
[Lean.Name.num.injEq,[Eq.propIntro, And.intro, Eq.refl, Lean.Name.num, Eq.symm, eq_of_heq, HEq.refl],[Eq, Lean.Name.num, And]]
[Lean.Parser.Tactic.Conv.convTrace_state,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Substring.takeRightWhile,[Substring, Substring.mk],[Substring]]
[Lean.maxRecDepthErrorMessage,[],[String]]
[List.getD,[Option.getD, List.get?],[]]
[IO.Process.Child.stderr,[],[IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stderr]]
[instMulUInt64,[Mul.mk, UInt64.mul],[Mul, UInt64]]
[Lean.Name.getRoot,[Unit.unit, Lean.Name.str, Lean.Name.anonymous, Lean.Name.num, Lean.Name, PProd.fst],[Lean.Name]]
[EStateM.Result.error.inj,[And.intro],[And, Eq]]
[WellFounded.fixFEq.proof_1,[rfl],[Eq, WellFounded.fixF, Acc.inv]]
[Std.Format.instCoeStringFormat,[Coe.mk, Std.Format.text],[Coe, String, Std.Format]]
[IO.Error.hardwareFault.inj,[And.intro],[And, Eq]]
[Lean.Macro.instMonadQuotationMacroM,[Lean.MonadQuotation.mk, Pure.pure, Lean.Macro.Context.currMacroScope, Lean.Macro.Context.mainModule, Lean.Macro.withFreshMacroScope],[Lean.MonadQuotation, Lean.MacroM]]
[proofIrrel,[rfl],[Eq]]
[coeId,[CoeT.mk],[CoeT]]
[Nat.one_ne_zero,[],[Ne, OfNat.ofNat]]
[Array.swapAt,[Prod.mk],[Prod, Array]]
[Int.natMod,[Int.toNat, HMod.hMod],[Nat]]
[«term_<|>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instInhabitedUInt32,[Inhabited.mk, UInt32.ofNatCore, OfNat.ofNat, instInhabitedUInt32.proof_1],[Inhabited, UInt32]]
[Except.ok.injEq,[Eq.propIntro, Eq.refl, Except.ok, Eq.symm, eq_of_heq, HEq.refl],[Eq, Except.ok]]
[IO.Error.unsatisfiedConstraints.sizeOf_spec,[Eq.refl, HAdd.hAdd, OfNat.ofNat, SizeOf.sizeOf],[Eq, SizeOf.sizeOf, IO.Error.unsatisfiedConstraints, HAdd.hAdd, OfNat.ofNat]]
[PUnit.eq_punit,[PUnit.subsingleton, PUnit.unit],[Eq, PUnit.unit]]
[UInt8.modn,[UInt8.mk, HMod.hMod, UInt8.val],[UInt8]]
[Array.mapIdxM.map.proof_1,[Eq.mpr, Eq.refl, LT.lt, Array.size, Eq.symm, HAdd.hAdd, OfNat.ofNat, Nat.add_assoc, Nat.add_comm, Nat.le_add_right, Nat.succ],[LT.lt, Array.size]]
[String.posOf,[String.posOfAux, String.bsize, OfNat.ofNat],[String.Pos]]
[HMul.hMul,[],[]]
[Int.subNatNat,[Unit.unit, Int, HSub.hSub, Int.ofNat, Int.negSucc],[Int]]
[instReprOption,[Repr.mk, Std.Format, Std.Format.text, Repr.addAppParen, HAppend.hAppend, reprArg],[Repr, Option]]
[Array.foldlMUnsafe,[ite, LT.lt, LE.le, Array.size, USize.ofNat, Pure.pure, Array.foldlMUnsafe.fold],[]]
[instToFormatArray,[Std.ToFormat.mk, HAppend.hAppend, Std.Format.text, Std.ToFormat.format, Array.toList],[Std.ToFormat, Array]]
[Nat.beq,[Unit.unit, Bool, Bool.true, Bool.false, PProd.fst],[Bool]]
[instHashableBool,[Hashable.mk, Unit.unit, UInt64, OfNat.ofNat],[Hashable, Bool]]
[Array.findRevM?,[Array.findSomeRevM?, Bind.bind, Pure.pure, ite, Eq, Bool.true, Option.some, Option.none],[Option]]
[Lean.MonadQuotation.toMonadRef,[],[Lean.MonadRef]]
[Sum.inhabitedRight,[Inhabited.mk, Sum.inr, arbitrary],[Inhabited, Sum]]
[IO.Error.userError.injEq,[Eq.propIntro, Eq.refl, IO.Error.userError, Eq.symm, eq_of_heq, HEq.refl],[Eq, IO.Error.userError]]
[instToStringFloat,[ToString.mk, Float.toString],[ToString, Float]]
[USize.decEq.proof_1,[rfl],[Eq, USize.mk]]
[String.getOp,[String.get],[Char]]
[ite_false,[rfl],[Eq, ite, False]]
[instDecidableLe_3,[UInt64.decLe],[Decidable, LE.le]]
[Quotient.recOn,[Quot.recOn],[]]
[Nat.le_of_ble_eq_true,[Eq.refl, Bool.true, HEq.refl, LE.le, Nat.zero_le, Nat.succ_le_succ, PProd.fst],[LE.le]]
[IO.Error.unsatisfiedConstraints.inj,[And.intro],[And, Eq]]
[Lean.Syntax.getArg,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Array.getD],[Lean.Syntax]]
[EIO.mapTask,[BaseIO.mapTask, EIO.toBaseIO],[BaseIO, Task, Except]]
[false_of_ne,[Ne.irrefl],[False]]
[UInt16.toUInt8,[Nat.toUInt8, UInt16.toNat],[UInt8]]
[IO.Process.run,[Bind.bind, IO.Process.output, ite, Eq, bne, IO.Process.Output.exitCode, OfNat.ofNat, Bool.true, MonadExcept.throw, IO.userError, HAppend.hAppend, IO.Process.SpawnArgs.cmd, ToString.toString, Pure.pure, PUnit.unit],[IO, String]]
[Array.findSomeRev?,[Id.run, Array.findSomeRevM?],[Option]]
