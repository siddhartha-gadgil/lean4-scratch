[PProd.noConfusionType,[PProd, Eq],[PProd]]
[Id.hasBind,[inferInstance, Bind, Id, Monad.toBind, Id.instMonadId],[Bind, Id]]
[Lean.identKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[MonadState.noConfusionType,[outParam, MonadState, PUnit, Prod, Eq],[outParam, MonadState]]
[ToString.noConfusionType,[ToString, String, Eq],[ToString]]
[String.Iterator.mk.sizeOf_spec,[String, String.Pos, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[String, String.Pos, Eq, Nat, SizeOf.sizeOf, String.Iterator, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, String.Iterator.mk]]
[Nat.toUInt8,[UInt8.ofNat],[UInt8]]
[ByteArray.noConfusionType,[ByteArray, Array, UInt8, Eq],[ByteArray]]
[ExceptCpsT.run_bind_throw,[Monad, ExceptCpsT, rfl, Except, ExceptCpsT.run, Bind.bind, Monad.toBind, ExceptCpsT.instMonadExceptCpsT, MonadExcept.throw, instMonadExcept, ExceptCpsT.instMonadExceptOfExceptCpsT],[Monad, ExceptCpsT, Eq, Except, ExceptCpsT.run, Bind.bind, Monad.toBind, ExceptCpsT.instMonadExceptCpsT, MonadExcept.throw, instMonadExcept, ExceptCpsT.instMonadExceptOfExceptCpsT]]
[List.append_eq_appendTR,[funext, List, List.append, List.appendTR, Eq, List.reverseAux, List.nil, rfl, of_eq_true, List.cons, Eq.trans, True, congr, congrArg, List.reverseAux_reverseAux, eq_self],[Eq, List, List.append, List.appendTR]]
[Lean.isIdRest,[Char, or, Char.isAlphanum, Decidable.decide, Eq, Char.ofNat, instDecidableEqChar, BEq.beq, instBEq, Lean.isLetterLike, Lean.isSubScriptAlnum],[Char, Bool]]
[List.spanAux,[Bool, List, Prod, List.below, List.nil, Prod.mk, List.reverse, List.cons, Unit, PProd.fst, PUnit, PProd],[Bool, List, Prod]]
[instInhabitedUSize.proof_1,[Nat, USize.size, Or, Eq, OfNat.ofNat, instOfNatNat, usize_size_eq, LT.lt, instLTNat, Unit, of_decide_eq_true, Nat.decLt, Eq.refl, Bool, Bool.true],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, USize.size]]
[Array.instForInArray,[ForIn.mk, Array, Monad, Array.forIn],[ForIn, Array]]
[List.getLastD,[List, List.getLast, List.cons, List.getLastD.proof_1],[List]]
[Eq.mpr_not,[Eq, Not, Eq.symm],[Eq, Not]]
[Not,[False],[]]
[OptionT.pure,[Monad, OptionT.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, Option, Option.some],[Monad, OptionT]]
[Nat.toSuperDigits,[Nat, Nat.toSuperDigitsAux, List.nil, Char],[Nat, List, Char]]
[EStateM.pure,[EStateM.Result.ok],[EStateM]]
[Subtype.val,[Subtype],[Subtype]]
[Functor.mapRev,[Functor, Functor.map],[Functor]]
[Lean.Syntax.getSepArgs,[Lean.Syntax, Array.getSepElems, Lean.Syntax.getArgs],[Lean.Syntax, Array]]
[LawfulFunctor.id_map,[Functor, LawfulFunctor],[Functor, LawfulFunctor, Eq, Functor.map, id]]
[ULift.down_up,[rfl, ULift.down, ULift.up],[Eq, ULift.down, ULift.up]]
[HMul.noConfusionType,[outParam, HMul, Eq],[outParam, HMul]]
[instInhabitedFloat,[Inhabited.mk, Float, Float.mk, FloatSpec.val, floatSpec],[Inhabited, Float]]
[ExceptCpsT.run_pure,[Monad, rfl, Except, ExceptCpsT.run, Pure.pure, ExceptCpsT, Applicative.toPure, Monad.toApplicative, ExceptCpsT.instMonadExceptCpsT],[Monad, Eq, Except, ExceptCpsT.run, Pure.pure, ExceptCpsT, Applicative.toPure, Monad.toApplicative, ExceptCpsT.instMonadExceptCpsT, Except.ok]]
[IO.Error.hardwareFault.inj,[UInt32, String, Eq, IO.Error, IO.Error.hardwareFault, And, And.intro],[UInt32, String, Eq, IO.Error, IO.Error.hardwareFault, And]]
[PSum.noConfusionType,[PSum, Eq],[PSum]]
[instOrElse,[Alternative, OrElse.mk, Alternative.orElse],[Alternative, OrElse]]
[Array.filterSepElemsM,[Monad, Array, Lean.Syntax, Bool, OfNat.ofNat, Nat, instOfNatNat, List.toArray, List.nil],[Monad, Array, Lean.Syntax, Bool]]
[USize.le,[USize, LE.le, Fin, USize.size, instLEFin, USize.val],[USize]]
[instReprExcept,[Repr, Repr.mk, Except, Nat, Std.Format, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, reprArg],[Repr, Except]]
[EStateM,[EStateM.Result],[]]
[Subrelation.wf,[Subrelation.wf.proof_1],[Subrelation, WellFounded]]
[String.intercalate.go,[String, List, List.below, List.cons, PProd.fst, PUnit, PProd, HAppend.hAppend, instHAppend, String.instAppendString, Unit, List.nil],[String, List]]
[Lean.choiceKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Array.toArrayLit_eq,[Array, Nat, Eq, Array.size, sorryAx, Array.toArrayLit, Bool.false],[Array, Nat, Eq, Array.size, Array.toArrayLit]]
[StateT.seqRight_eq,[Monad, LawfulMonad, StateT, StateT.ext, SeqRight.seqRight, Applicative.toSeqRight, Monad.toApplicative, StateT.instMonadStateT, Unit, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const, id, Eq.mpr, Eq, Prod, StateT.run, Bind.bind, Monad.toBind, Prod.snd, Pure.pure, Applicative.toPure, Prod.mk, Prod.fst, congr, congrArg, StateT.run_seqRight, Eq.trans, StateT.run_seq, StateT.run_map, map_eq_pure_bind, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, congrFun, id_eq, bind_congr, of_eq_true, True, Prod.ext, bind_pure, eq_self, Eq.symm, Eq.refl],[Monad, LawfulMonad, StateT, Eq, SeqRight.seqRight, Applicative.toSeqRight, Monad.toApplicative, StateT.instMonadStateT, Unit, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const, id]]
[Decidable.of_not_not,[Decidable, Not, Decidable.byContradiction, absurd, False],[Decidable, Not]]
[instToStringList,[ToString, ToString.mk, List, List.toString],[ToString, List]]
[Lean.Syntax.isIdOrAtom?,[Lean.Syntax, Option, String, Lean.SourceInfo, Option.some, Substring, Lean.Name, List, Prod, Substring.toString, Option.none],[Lean.Syntax, Option, String]]
[Nat.le_of_succ_le,[Nat, LE.le, instLENat, Nat.succ, Nat.le_trans, Nat.le_succ],[Nat, LE.le, instLENat, Nat.succ]]
[instOfNatUInt16,[Nat, OfNat.mk, UInt16, UInt16.ofNat],[Nat, OfNat, UInt16]]
[Char.le,[Char, LE.le, UInt32, instLEUInt32, Char.val],[Char]]
[Std.Format.fill,[Std.Format, Std.Format.group, Std.Format.FlattenBehavior.fill],[Std.Format]]
[Nat.toDigitsCore,[Nat, List, Char, Nat.below, Nat.succ, Nat.digitChar, HMod.hMod, instHMod, Nat.instModNat, HDiv.hDiv, instHDiv, Nat.instDivNat, ite, Eq, OfNat.ofNat, instOfNatNat, instDecidableEqNat, List.cons, PProd.fst, PUnit, PProd],[Nat, List, Char]]
[ST,[EST, Empty],[]]
[Nat.succ_eq_add_one,[Nat, rfl, Nat.succ],[Nat, Eq, Nat.succ, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
[Equivalence.trans,[Equivalence],[Equivalence]]
[String.foldr,[Char, String, String.foldrAux, String.bsize, OfNat.ofNat, String.Pos, instOfNatNat],[Char, String]]
[instInhabitedEST,[Inhabited, inferInstanceAs, EStateM, EStateM.instInhabitedEStateM],[Inhabited, EST]]
[IO.FS.readBinFile,[System.FilePath, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle, ByteArray, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.true, IO.FS.Handle.readBinToEnd],[System.FilePath, IO, ByteArray]]
[Lean.Parser.Tactic.focus,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[unexpandIte,[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[USize.decLe,[USize, Decidable, LE.le, instLEUSize, Fin, USize.size, inferInstanceAs, instLEFin, Fin.decLe],[USize, Decidable, LE.le, instLEUSize]]
[List.hasDecEq.proof_2,[List, Eq, List.cons, List.nil, False],[List, Eq, List.cons, List.nil, List.noConfusionType, False]]
[implies,[],[]]
[Char.eq_of_val_eq,[Char, Eq, UInt32, Char.val, UInt32.isValidChar, rfl, Char.mk],[Char, Eq, UInt32, Char.val]]
[Subsingleton.helim,[Subsingleton.helim.proof_1],[Subsingleton, Eq, HEq]]
[HEq.subst,[HEq, HEq.ndrecOn],[HEq]]
[Subarray.h₂,[Subarray],[Subarray, LE.le, Nat, instLENat, Subarray.stop, Array.size, Subarray.as]]
[Std.Format.MonadPrettyFormat.noConfusionType,[Std.Format.MonadPrettyFormat, String, Unit, Nat, Eq],[Std.Format.MonadPrettyFormat]]
[Nat.instShiftLeftNat,[ShiftLeft.mk, Nat, Nat.shiftLeft],[ShiftLeft, Nat]]
[emptyRelation,[False],[]]
[bind_pure,[Monad, LawfulMonad],[Monad, LawfulMonad, Eq, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[ST.Prim.Ref.modify,[ST.Ref, Bind.bind, ST, Monad.toBind, instMonadST, Unit, ST.Prim.Ref.get, ST.Prim.Ref.set],[ST.Ref, ST, Unit]]
[Nat.lt_of_le_of_lt,[Nat, LE.le, instLENat, LT.lt, instLTNat, Nat.le_trans, Nat.succ, Nat.succ_le_succ],[Nat, LE.le, instLENat, LT.lt, instLTNat]]
[Lean.monadNameGeneratorLift,[MonadLift, Lean.MonadNameGenerator, Lean.MonadNameGenerator.mk, liftM, instMonadLiftT, instMonadLiftT_1, Lean.NameGenerator, Lean.MonadNameGenerator.getNGen, Unit, Lean.MonadNameGenerator.setNGen],[MonadLift, Lean.MonadNameGenerator]]
[ExceptCpsT.instMonadExceptOfExceptCpsT,[MonadExceptOf.mk, ExceptCpsT],[MonadExceptOf, ExceptCpsT]]
[decidableOfDecidableOfIff,[Decidable, Iff, dite, Decidable.isTrue, Iff.mp, Not, Decidable.isFalse, decidableOfDecidableOfIff.proof_1],[Decidable, Iff]]
[String.trim,[String, Substring.toString, Substring.trim, String.toSubstring],[String]]
[instPowFloatFloat,[Pow.mk, Float, Float.pow],[Pow, Float]]
[Pow.noConfusionType,[Pow, Eq],[Pow]]
[bind_congr,[Bind, Eq, of_eq_true, Bind.bind, Eq.trans, True, congrFun, congrArg, funext, eq_self],[Bind, Eq, Bind.bind]]
[Nat.decEq.proof_1,[Eq.refl, Bool, Nat.beq],[Eq, Bool, Nat.beq]]
[StateCpsT.runK_lift,[Monad, rfl, StateCpsT.runK, StateCpsT.lift],[Monad, Eq, StateCpsT.runK, StateCpsT.lift, Bind.bind, Monad.toBind]]
[EStateM.instMonadEStateM,[Monad.mk, EStateM, Applicative.mk, Functor.mk, EStateM.map, Pure.mk, EStateM.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, EStateM.seqRight, Bind.mk, EStateM.bind],[Monad, EStateM]]
[instOrOpUInt8,[OrOp.mk, UInt8, UInt8.lor],[OrOp, UInt8]]
[Nat.min,[Nat, ite, LE.le, instLENat, Nat.decLe],[Nat]]
[instReprTuple,[Repr, ReprTuple.mk, List, Std.Format, List.cons, repr],[Repr, ReprTuple]]
[IO.FS.SystemTime.nsec,[IO.FS.SystemTime],[IO.FS.SystemTime, UInt32]]
[ReaderT.read,[Monad, Pure.pure, Applicative.toPure, Monad.toApplicative],[Monad, ReaderT]]
[FloatArray.toList,[FloatArray, Nat, List, Float, OfNat.ofNat, instOfNatNat, List.nil, FloatArray.toList.loop],[FloatArray, List, Float]]
[USize.size,[HPow.hPow, Nat, instHPow, instPowNatNat, OfNat.ofNat, instOfNatNat, System.Platform.numBits],[Nat]]
[And.left,[And],[And]]
[«term_<*_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[unexpandUnit,[Lean.Syntax, Bind.bind, Lean.PrettyPrinter.UnexpandM, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.PrettyPrinter.Unexpander]]
[instMonadFinallyEIO,[inferInstanceAs, MonadFinally, EStateM, IO.RealWorld, EStateM.instMonadFinallyEStateM],[MonadFinally, EIO]]
[IO.FS.Metadata.modified,[IO.FS.Metadata],[IO.FS.Metadata, IO.FS.SystemTime]]
[Lean.Syntax.SepArray.ofElems,[String, Array, Lean.Syntax, Lean.Syntax.SepArray.mk, Lean.mkSepArray, Lean.mkAtom],[String, Array, Lean.Syntax, Lean.Syntax.SepArray]]
[CoeHTCT.coe,[CoeHTCT],[CoeHTCT]]
[Array.reverse,[Array, Nat, Array.size, HDiv.hDiv, instHDiv, Nat.instDivNat, OfNat.ofNat, instOfNatNat, Array.reverse.rev],[Array]]
[instHashableUInt64,[Hashable.mk, UInt64],[Hashable, UInt64]]
[Lean.Syntax.isNodeOf,[Lean.Syntax, Lean.SyntaxNodeKind, Nat, and, Lean.Syntax.isOfKind, BEq.beq, instBEq, instDecidableEqNat, Lean.Syntax.getNumArgs],[Lean.Syntax, Lean.SyntaxNodeKind, Nat, Bool]]
[Std.Format.MonadPrettyFormat.pushOutput,[Std.Format.MonadPrettyFormat],[Std.Format.MonadPrettyFormat, String, Unit]]
[PProd.snd,[PProd],[PProd]]
[USize.decEq.proof_2,[Fin, USize.size, Not, Eq, USize, USize.mk, False, absurd],[Fin, USize.size, Not, Eq, USize, USize.mk, False]]
[System.FilePath.parent,[System.FilePath, Functor.map, Option, Option.instFunctorOption, String, System.FilePath.mk, String.Pos, String.extract, System.FilePath.toString, OfNat.ofNat, instOfNatNat, String.revFind, List.contains, Char, instBEq, instDecidableEqChar, System.FilePath.pathSeparators],[System.FilePath, Option]]
[Fin.sub.proof_1,[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, HSub.hSub, instHSub, instSubNat],[Nat, LT.lt, instLTNat, HMod.hMod, instHMod, Nat.instModNat, HAdd.hAdd, instHAdd, instAddNat, HSub.hSub, instHSub, instSubNat]]
[stdSplit,[StdGen, Prod, Nat, ite, Eq, OfNat.ofNat, instOfNatNat, instDecidableEqNat, HAdd.hAdd, instHAdd, instAddNat, HSub.hSub, instHSub, instSubNat, Prod.snd, stdNext, StdGen.mk, StdGen.s2, StdGen.s1, Prod.mk],[StdGen, Prod]]
[Stream.noConfusionType,[outParam, Stream, Option, Prod, Eq],[outParam, Stream]]
[Quotient.inductionOn₃,[Setoid, Quotient, Quotient.mk, Quotient.ind],[Setoid, Quotient, Quotient.mk]]
[Lean.Eval.noConfusionType,[Lean.Eval, Unit, optParam, Bool, Bool.true, IO, Eq],[Lean.Eval]]
[CoeFun.noConfusionType,[outParam, CoeFun, Eq],[outParam, CoeFun]]
[Stream.forIn,[outParam, Stream, Monad, ForInStep, Stream.forIn.visit],[outParam, Stream, Monad, ForInStep]]
[Lean.instInhabitedMacroScopesView,[Inhabited.mk, Lean.MacroScopesView, Lean.MacroScopesView.mk, arbitrary, Lean.Name, Lean.instInhabitedName, List, Lean.MacroScope, instInhabitedList],[Inhabited, Lean.MacroScopesView]]
[instOfNatUInt8,[Nat, OfNat.mk, UInt8, UInt8.ofNat],[Nat, OfNat, UInt8]]
[Nat.digitChar,[Nat, ite, Char, Eq, OfNat.ofNat, instOfNatNat, instDecidableEqNat, Char.ofNat],[Nat, Char]]
[IO.Error.inappropriateType.inj,[Option, String, UInt32, Eq, IO.Error, IO.Error.inappropriateType, And, And.intro],[Option, String, UInt32, Eq, IO.Error, IO.Error.inappropriateType, And]]
[ForIn.forIn,[ForIn],[ForIn, Monad, ForInStep]]
[Complement.complement,[Complement],[Complement]]
[Lean.Syntax.node.injEq,[Lean.SyntaxNodeKind, Array, Lean.Syntax, Eq.propIntro, Eq, Lean.Syntax.node, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Lean.SyntaxNodeKind, Array, Lean.Syntax, Eq, Lean.Syntax.node, And]]
[Array.noConfusionType,[Array, List, Eq],[Array]]
[IO.FS.Stream.Buffer.mk.injEq,[ByteArray, Nat, Eq.propIntro, Eq, IO.FS.Stream.Buffer, IO.FS.Stream.Buffer.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[ByteArray, Nat, Eq, IO.FS.Stream.Buffer, IO.FS.Stream.Buffer.mk, And]]
[Lean.Parser.Tactic.Conv.lhs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[instReprSourceInfo,[Repr.mk, Lean.SourceInfo, Nat, Substring, String.Pos, Lean.SourceInfo.original, Lean.SourceInfo.synthetic, Unit, Lean.SourceInfo.none, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, Int, GE.ge, instLENat, OfNat.ofNat, instOfNatNat, Nat.decLe, Int.instOfNatInt, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, Std.Format.line, reprArg, instReprSubstring, instReprNat, Std.Format.FlattenBehavior.allOrNone],[Repr, Lean.SourceInfo]]
[instOrOpUInt16,[OrOp.mk, UInt16, UInt16.lor],[OrOp, UInt16]]
[fix1,[Inhabited, fixCore1, arbitrary],[Inhabited]]
[Lean.Parser.Tactic.tacticRefine_lift'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[instLEFin,[Nat, LE.mk, Fin, LE.le, instLENat, Fin.val],[Nat, LE, Fin]]
[Std.Format.pretty,[Std.Format, optParam, Nat, Std.Format.defWidth, StateM, Unit, Std.Format.prettyM, OfNat.ofNat, instOfNatNat, StateT.instMonadStateT, Id, Id.instMonadId, Std.Format.instMonadPrettyFormatStateMState, Prod.snd],[Std.Format, optParam, Nat, Std.Format.defWidth, String]]
[Char.isWhitespace,[Char, or, Decidable.decide, Eq, Char.ofNat, instDecidableEqChar],[Char, Bool]]
[StateT.pure,[Monad, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod, Prod.mk],[Monad, StateT]]
[StateRefT'.instMonadStateOfStateRefT',[MonadLiftT, ST, Monad, MonadStateOf.mk, StateRefT', StateRefT'.get, StateRefT'.set, StateRefT'.modifyGet],[MonadLiftT, ST, Monad, MonadStateOf, StateRefT']]
[Array.mk.inj,[List, Eq, Array, Array.mk],[List, Eq, Array, Array.mk]]
[instToStringUInt8,[ToString.mk, UInt8, ToString.toString, Nat, instToStringNat, UInt8.toNat],[ToString, UInt8]]
[IO.Process.Child.stdin,[IO.Process.StdioConfig, IO.Process.Child],[IO.Process.StdioConfig, IO.Process.Child, IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdin]]
[IO.Error.invalidArgument.sizeOf_spec,[Option, String, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[Option, String, UInt32, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.invalidArgument]]
[List.get.proof_1,[List, Nat, LT.lt, instLTNat, Nat.succ, List.length, List.cons, Nat.le_of_succ_le_succ, List.length_cons],[List, Nat, LT.lt, instLTNat, Nat.succ, List.length, List.cons, LE.le, instLENat]]
[ULift.noConfusionType,[ULift, Eq],[ULift]]
[Fin.isLt,[Nat, Fin],[Nat, Fin, LT.lt, instLTNat, Fin.val]]
[Lean.Parser.Tactic.tacticTrivial,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[EStateM.instMonadFinallyEStateM,[MonadFinally.mk, EStateM, Option, EStateM.Result, Prod, Option.some, EStateM.Result.ok, Prod.mk, EStateM.Result.error, Option.none],[MonadFinally, EStateM]]
[Lean.NameGenerator.idx,[Lean.NameGenerator],[Lean.NameGenerator, Nat]]
[UInt64.ofNatCore,[LT.lt, Nat, instLTNat, UInt64.size, UInt64.mk, Fin.mk],[LT.lt, Nat, instLTNat, UInt64.size, UInt64]]
[Lean.numLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Lean.Syntax.mkNameLit,[String, optParam, Lean.SourceInfo, Lean.SourceInfo.none, Lean.Syntax.mkLit, Lean.nameLitKind],[String, optParam, Lean.SourceInfo, Lean.SourceInfo.none, Lean.Syntax]]
[congrArg,[Eq, rfl],[Eq]]
[Array.mapMUnsafe.map,[Monad, USize, Array, NonScalar, ite, PNonScalar, LT.lt, instLTUSize, instDecidableLt_4, Array.uget, lcProof, Nat, instLTNat, USize.toNat, Array.size, Array.uset, arbitrary, instInhabitedNonScalar, Bind.bind, Monad.toBind, unsafeCast, Array.mapMUnsafe.map, HAdd.hAdd, instHAdd, instAddUSize, OfNat.ofNat, instOfNatUSize, Pure.pure, Applicative.toPure, Monad.toApplicative],[Monad, USize, Array, NonScalar, PNonScalar]]
[instToStreamSubarraySubarray,[ToStream.mk, Subarray],[ToStream, Subarray]]
[Char.toNat,[Char, UInt32.toNat, Char.val],[Char, Nat]]
[Functor.map,[Functor],[Functor]]
[List.tailD,[List],[List]]
[EStateM.Backtrackable.restore,[EStateM.Backtrackable],[EStateM.Backtrackable]]
[instNonempty,[instNonempty.proof_1],[Inhabited, Nonempty]]
[instReprAtomUInt16,[ReprAtom.mk, UInt16],[ReprAtom, UInt16]]
[IO.Error.interrupted.injEq,[String, UInt32, Eq.propIntro, Eq, IO.Error, IO.Error.interrupted, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[String, UInt32, Eq, IO.Error, IO.Error.interrupted, And]]
[Lean.Syntax.getOptionalIdent?,[Lean.Syntax, Option, Lean.Name, Lean.Syntax.getOptional?, Option.some, Lean.Syntax.getId, Unit, Option.none],[Lean.Syntax, Option, Lean.Name]]
[List.below,[List, PUnit, PProd],[List]]
[Iff.noConfusionType,[Iff],[Iff]]
[coeOfTail,[CoeTail, CoeHTCT.mk, coeTail],[CoeTail, CoeHTCT]]
[invImage,[WellFoundedRelation, WellFoundedRelation.mk, InvImage, WellFoundedRelation.rel, invImage.proof_1],[WellFoundedRelation]]
[IO.FS.instReprFileType,[Repr.mk, IO.FS.FileType, Nat, Unit, IO.FS.FileType.dir, IO.FS.FileType.file, IO.FS.FileType.symlink, IO.FS.FileType.other, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, Int, GE.ge, instLENat, OfNat.ofNat, instOfNatNat, Nat.decLe, Int.instOfNatInt, Std.Format.text, Std.Format.FlattenBehavior.allOrNone],[Repr, IO.FS.FileType]]
[Lean.Parser.Attr.simp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.simpPre, Lean.Parser.Tactic.simpPost, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Quot.inductionOn,[Quot, Quot.mk, Quot.ind],[Quot, Quot.mk]]
[Lean.Syntax.SepArray.noConfusionType,[String, Lean.Syntax.SepArray, Array, Lean.Syntax, Eq],[String, Lean.Syntax.SepArray]]
[List.findM?,[Monad, Bool, List, Option, List.below, Unit, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.none, List.cons, Bind.bind, Monad.toBind, Option.some, PProd.fst, PUnit, PProd],[Monad, Bool, List, Option]]
[GT.gt,[LT, LT.lt],[LT]]
[LE.le,[LE],[LE]]
[Lean.Parser.Tactic.config,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat],[Lean.ParserDescr]]
[Hashable.hash,[Hashable],[Hashable, UInt64]]
[Substring.trimRight,[Substring, Substring.dropRightWhile, Char.isWhitespace],[Substring]]
[instModUInt64,[Mod.mk, UInt64, UInt64.mod],[Mod, UInt64]]
[rfl.proof_1,[Eq.refl],[Eq]]
[coeOfTCOfTail,[CoeTail, CoeTC, CoeHTCT.mk, coeTail, coeTC],[CoeTail, CoeTC, CoeHTCT]]
[EStateM.throw,[EStateM.Result.error],[EStateM]]
[MonadLiftT.noConfusionType,[MonadLiftT, Eq],[MonadLiftT]]
[Nat.add_le_add_left,[Nat, LE.le, instLENat, Exists, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.le.dest],[Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat]]
[instOfNatFloat,[Nat, OfNat.mk, Float, Float.ofNat],[Nat, OfNat, Float]]
[UInt16.toUInt8,[UInt16, Nat.toUInt8, UInt16.toNat],[UInt16, UInt8]]
[StateCpsT.runK_bind_get,[Monad, StateCpsT, rfl, StateCpsT.runK, Bind.bind, Monad.toBind, StateCpsT.instMonadStateCpsT, MonadState.get, instMonadState, StateCpsT.instMonadStateOfStateCpsT],[Monad, StateCpsT, Eq, StateCpsT.runK, Bind.bind, Monad.toBind, StateCpsT.instMonadStateCpsT, MonadState.get, instMonadState, StateCpsT.instMonadStateOfStateCpsT]]
[false_and,[propext, And, False, Iff.intro, And.left, False.elim],[Eq, And, False]]
[List.forIn_cons,[Monad, ForInStep, List, rfl, ForIn.forIn, List.instForInList, List.cons],[Monad, ForInStep, List, Eq, ForIn.forIn, List.instForInList, List.cons, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[Array.extLit,[Nat, Array, Eq, Array.size, LT.lt, instLTNat, Array.getLit, Array.ext, Eq.trans, Eq.symm],[Nat, Array, Eq, Array.size, LT.lt, instLTNat, Array.getLit]]
[ByteArray.extract,[ByteArray, Nat, ByteArray.copySlice, ByteArray.empty, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Bool.true],[ByteArray, Nat]]
[FloatArray.get,[Float, Array, Fin, FloatArray.size, FloatArray.mk, Array.get],[Float]]
[TC.accessible,[TC.accessible.proof_1],[Acc, TC]]
[Lean.Meta.Simp.instInhabitedConfig,[Inhabited.mk, Lean.Meta.Simp.Config, Lean.Meta.Simp.Config.mk, arbitrary, Nat, instInhabitedNat, Bool, instInhabitedBool],[Inhabited, Lean.Meta.Simp.Config]]
[StateCpsT.instMonadLiftStateCpsT,[Monad, MonadLift.mk, StateCpsT, StateCpsT.lift],[Monad, MonadLift, StateCpsT]]
[CoeSort.coe,[CoeSort],[CoeSort]]
[OptionT.tryCatch,[Monad, OptionT, Unit, OptionT.mk, Bind.bind, Monad.toBind, Option, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.some, Unit.unit],[Monad, OptionT, Unit]]
[instToStringFormat,[ToString.mk, Std.Format, Std.Format.pretty, Std.Format.defWidth],[ToString, Std.Format]]
[Fin.modn_lt,[Nat, Fin, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, LT.lt, Fin.val, HMod.hMod, Fin.instHModFinNatFin, Nat.lt_of_le_of_lt, Fin.mk, instHMod, Nat.instModNat, Nat.mod_le, Nat.mod_lt],[Nat, Fin, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, LT.lt, Fin.val, HMod.hMod, Fin.instHModFinNatFin]]
[Classical.strongIndefiniteDescription,[Nonempty, dite, Subtype, Exists, Classical.propDecidable, Not, Subtype.mk, Classical.choice, Classical.strongIndefiniteDescription.proof_2],[Nonempty, Subtype, Exists]]
[IO.Process.Stdio.inherit.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, IO.Process.Stdio, SizeOf.mk, OfNat.ofNat, instOfNatNat, IO.Process.Stdio.inherit]]
[instMonadLiftT_1,[MonadLiftT.mk],[MonadLiftT]]
[Unit.unit,[PUnit.unit],[Unit]]
[List.partitionAux,[Bool, List, Prod, List.below, List.nil, Prod.mk, List.reverse, List.cons, Unit, PProd.fst, PUnit, PProd],[Bool, List, Prod]]
[Std.Format.nestD,[Std.Format, Std.Format.nest, Int.ofNat, Std.Format.defIndent],[Std.Format]]
[Lean.Name.mkNum.proof_1,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt64.size, Nat.decLt, Eq.refl, Bool, Bool.true],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt64.size]]
[String.intercalate,[String, List, Unit, String.intercalate.go],[String, List]]
[instInhabitedUInt64,[Inhabited.mk, UInt64, UInt64.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, instInhabitedUInt64.proof_1],[Inhabited, UInt64]]
[Except.ok.injEq,[Eq.propIntro, Eq, Except, Except.ok, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Except, Except.ok]]
[Fin.ofNat,[Nat, Fin.mk, Nat.succ, HMod.hMod, instHMod, Nat.instModNat, Fin.ofNat.proof_1],[Nat, Fin, Nat.succ]]
[IO.Process.Child.mk.inj,[IO.Process.StdioConfig, IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdin, IO.Process.StdioConfig.stdout, IO.Process.StdioConfig.stderr, Eq, IO.Process.Child, IO.Process.Child.mk, And, And.intro],[IO.Process.StdioConfig, IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdin, IO.Process.StdioConfig.stdout, IO.Process.StdioConfig.stderr, Eq, IO.Process.Child, IO.Process.Child.mk, And]]
[Ord.noConfusionType,[Ord, Ordering, Eq],[Ord]]
[instToStringSigma,[ToString, ToString.mk, Sigma, String, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString],[ToString, Sigma]]
[IO.FS.Stream.read,[IO.FS.Stream],[IO.FS.Stream, USize, IO, ByteArray]]
[WellFounded.fixFEq,[WellFounded.fixFEq.proof_1],[Acc, Eq, WellFounded.fixF, Acc.inv]]
[Fin.ofNat',[Nat, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt],[Nat, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, Fin]]
[Lean.Parser.Tactic.constructor,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Option.instFunctorOption,[Functor.mk, Option, Option.map],[Functor, Option]]
[Lean.Parser.Tactic.Conv.«convEnter[__]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.ParserDescr.const, Lean.Parser.Tactic.Conv.enterArg],[Lean.ParserDescr]]
[List.rangeAux,[Nat, List, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, List.cons],[Nat, List]]
[ByteArray.toList,[ByteArray, Nat, List, UInt8, OfNat.ofNat, instOfNatNat, List.nil, ByteArray.toList.loop],[ByteArray, List, UInt8]]
[Lean.Parser.Tactic.Conv.pattern,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Tactic.Conv.simpMatch,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Macro.resolveGlobalName,[Lean.Name, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, List, Prod, String, Lean.Macro.getMethods, Lean.Macro.Methods.resolveGlobalName],[Lean.Name, Lean.MacroM, List, Prod, String]]
[ReaderT.pure,[Monad, Pure.pure, Applicative.toPure, Monad.toApplicative],[Monad, ReaderT]]
[Exists.elim,[Exists],[Exists]]
[Lean.Macro.Context.currRecDepth,[Lean.Macro.Context],[Lean.Macro.Context, Nat]]
[Lean.Syntax.getArg,[Lean.Syntax, Nat, Lean.SyntaxNodeKind, Array, Array.getD, Lean.Syntax.missing],[Lean.Syntax, Nat]]
[List.forM,[Monad, List, PUnit, List.below, Unit, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, List.cons, Bind.bind, Monad.toBind, PProd.fst, PProd],[Monad, List, PUnit]]
[List.find?,[Bool, List, Option, List.below, Unit, List.nil, Option.none, List.cons, Option.some, PProd.fst, PUnit, PProd],[Bool, List, Option]]
[Int.decEq.proof_6,[Nat, Eq, Int, Int.negSucc, Int.ofNat, False],[Nat, Eq, Int, Int.negSucc, Int.ofNat, Int.noConfusionType, False]]
[USize.lt,[USize, LT.lt, Fin, USize.size, instLTFin, USize.val],[USize]]
[instReprList_1,[Repr, ReprAtom, Repr.mk, List, Nat, Std.ToFormat, Std.ToFormat.mk, repr, Std.Format, Std.Format.text, Std.Format.bracketFill, Std.Format.joinSep, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.line],[Repr, ReprAtom, List]]
[termIfThenElse,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.const],[Lean.ParserDescr]]
[ExceptT.lift,[Monad, ExceptT.mk, Functor.map, Applicative.toFunctor, Monad.toApplicative, Except, Except.ok],[Monad, ExceptT]]
[Nat.gcd,[WellFounded.fix, Nat, WellFoundedRelation.rel, measure, id, Nat.gcd.proof_1, Unit, Nat.succ, Unit.unit, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, Nat.zero_lt_succ],[Nat]]
[Char.quote,[Char, HAppend.hAppend, String, instHAppend, String.instAppendString, Char.quoteCore],[Char, String]]
[instToFormatProd,[Std.ToFormat, Std.ToFormat.mk, Prod, Std.Format, Std.Format.paren, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.ToFormat.format, Std.Format.text, Std.Format.line],[Std.ToFormat, Prod]]
[EIO.catchExceptions,[EIO, Empty, IO.RealWorld, EStateM.Result, EStateM.Result.ok],[EIO, Empty]]
[Array.elem,[BEq, Array, Array.contains],[BEq, Array, Bool]]
[Lean.isIdBeginEscape,[Char, Decidable.decide, Eq, Lean.idBeginEscape, instDecidableEqChar],[Char, Bool]]
[FloatArray.mk.injEq,[Array, Float, Eq.propIntro, Eq, FloatArray, FloatArray.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Array, Float, Eq, FloatArray, FloatArray.mk]]
[instToStringUnit,[ToString.mk, Unit],[ToString, Unit]]
[Lean.Parser.Tactic.locationHyp,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Nat.one_mul,[Nat, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, Eq, Nat.mul_one, Nat.mul_comm],[Nat, Eq, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat]]
[UInt8.decEq.proof_2,[Fin, UInt8.size, Not, Eq, UInt8, UInt8.mk, False, absurd],[Fin, UInt8.size, Not, Eq, UInt8, UInt8.mk, False]]
[Ne.symm,[Ne, Eq, Eq.symm],[Ne]]
[Lean.Name.mkNum,[Lean.Name, Nat, Lean.Name.num, mixHash, Hashable.hash, Lean.instHashableName, dite, UInt64, LT.lt, instLTNat, UInt64.size, Nat.decLt, UInt64.ofNatCore, Not, OfNat.ofNat, instOfNatNat, Lean.Name.mkNum.proof_1],[Lean.Name, Nat]]
[Classical.inhabited_of_nonempty,[Nonempty, Inhabited.mk, Classical.choice],[Nonempty, Inhabited]]
[ByteArray.mk.injEq,[Array, UInt8, Eq.propIntro, Eq, ByteArray, ByteArray.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Array, UInt8, Eq, ByteArray, ByteArray.mk]]
[Lean.Meta.Simp.Config.memoize,[Lean.Meta.Simp.Config],[Lean.Meta.Simp.Config, Bool]]
[randNat,[RandomGen, Nat, ite, GT.gt, instLTNat, Nat.decLt, Prod, RandomGen.range, HAdd.hAdd, instHAdd, instAddNat, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, HMul.hMul, instHMul, instMulNat, Prod.mk, HMod.hMod, instHMod, Nat.instModNat],[RandomGen, Nat, Prod]]
[Fin.decLe,[Nat, Fin, Nat.decLe, Fin.val],[Nat, Fin, Decidable, LE.le, instLEFin]]
[Int.toNat,[Int, Nat, OfNat.ofNat, instOfNatNat],[Int, Nat]]
[Lean.PrettyPrinter.Unexpander,[Lean.Syntax, Lean.PrettyPrinter.UnexpandM],[]]
[EStateM.instOrElseEStateM,[outParam, EStateM.Backtrackable, OrElse.mk, EStateM, EStateM.orElse],[outParam, EStateM.Backtrackable, OrElse, EStateM]]
[Lean.Parser.Tactic.exact,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[«term_++_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[let_body_congr,[Eq],[Eq]]
[Classical.choose,[Exists, Subtype.val, Classical.indefiniteDescription],[Exists]]
[Int.instHPowIntNatInt,[HPow.mk, Int, Nat, Int.pow],[HPow, Int, Nat]]
[Except.instMonadExcept,[Monad.mk, Except, Applicative.mk, Functor.mk, Except.map, Pure.mk, Except.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk, Except.bind],[Monad, Except]]
[bne,[BEq, not, BEq.beq],[BEq, Bool]]
[flip,[],[]]
[Subarray.forM,[Monad, PUnit, Subarray, Array.forM, Subarray.as, Subarray.start, Subarray.stop],[Monad, PUnit, Subarray]]
[Nat.eq_or_lt_of_le,[Nat, LE.le, instLENat, Or, Eq, LT.lt, instLTNat, Nat.below, Nat.zero, Or.inl, rfl, Nat.succ, Or.inr, Nat.succ_le_succ, Nat.zero_le, absurd, Nat.not_succ_le_zero],[Nat, LE.le, instLENat, Or, Eq, LT.lt, instLTNat]]
[UInt8.modn,[UInt8, UInt8.mk, HMod.hMod, Fin, UInt8.size, Nat, Fin.instHModFinNatFin, UInt8.val],[UInt8]]
[Lean.Syntax.getTailInfo,[Lean.Syntax, Option.getD, Lean.SourceInfo, Lean.Syntax.getTailInfo?, Lean.SourceInfo.none],[Lean.Syntax, Lean.SourceInfo]]
[List.range,[Nat, List.rangeAux, List.nil],[Nat, List]]
[List.get!,[Inhabited, Nat, List, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, panicWithPosWithDecl, OfNat.ofNat, instOfNatNat],[Inhabited, Nat, List]]
[fixCore1,[bfix1, USize.size],[]]
[IO.Error.protocolError.injEq,[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.protocolError, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[UInt32, String, Eq, IO.Error, IO.Error.protocolError, And]]
[String.contains,[String, Char, String.any, BEq.beq, instBEq, instDecidableEqChar],[String, Char, Bool]]
[Std.Range.instForMRangeNat,[ForM.mk, Std.Range, Nat, Monad, Std.Range.forM],[ForM, Std.Range, Nat]]
[System.Platform.numBits_eq,[Subtype.property, Nat, Or, Eq, OfNat.ofNat, instOfNatNat, System.Platform.getNumBits, Unit.unit],[Or, Eq, Nat, System.Platform.numBits, OfNat.ofNat, instOfNatNat]]
[System.FilePath.noConfusionType,[System.FilePath, String, Eq],[System.FilePath]]
[Div.noConfusionType,[Div, Eq],[Div]]
[Substring.toNat?,[Substring, ite, Option, Nat, Eq, Bool, Substring.isNat, Bool.true, instDecidableEqBool, Option.some, Substring.foldl, Char, HAdd.hAdd, instHAdd, instAddNat, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Char.toNat, Char.ofNat, Option.none],[Substring, Option, Nat]]
[IO.Error.resourceExhausted.inj,[Option, String, UInt32, Eq, IO.Error, IO.Error.resourceExhausted, And, And.intro],[Option, String, UInt32, Eq, IO.Error, IO.Error.resourceExhausted, And]]
[Nat.add_one,[Nat, rfl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat],[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Nat.succ]]
[IO.FS.SystemTime.mk.sizeOf_spec,[Int, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, instSizeOfNat, Fin, UInt32.size, LT.lt, instLTNat, instSizeOf],[Int, UInt32, Eq, Nat, SizeOf.sizeOf, IO.FS.SystemTime, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, instSizeOfNat, Fin, UInt32.size, LT.lt, instLTNat, instSizeOf, IO.FS.SystemTime.mk]]
[bfix3,[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd],[Nat]]
[Lean.Syntax.ident.inj,[Lean.SourceInfo, Substring, Lean.Name, List, Prod, String, Eq, Lean.Syntax, Lean.Syntax.ident, And, And.intro],[Lean.SourceInfo, Substring, Lean.Name, List, Prod, String, Eq, Lean.Syntax, Lean.Syntax.ident, And]]
[Array.concatMapM,[Monad, Array, Array.foldlM, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, HAppend.hAppend, instHAppend, Array.instAppendArray, Array.empty, OfNat.ofNat, Nat, instOfNatNat, Array.size],[Monad, Array]]
[ByteArray.empty,[ByteArray.mkEmpty, OfNat.ofNat, Nat, instOfNatNat],[ByteArray]]
[UInt16.decLt,[UInt16, Decidable, LT.lt, instLTUInt16, Fin, UInt16.size, inferInstanceAs, instLTFin, Fin.decLt],[UInt16, Decidable, LT.lt, instLTUInt16]]
[Int.instOfNatInt,[Nat, OfNat.mk, Int, Int.ofNat],[Nat, OfNat, Int]]
[Lean.Parser.Tactic.assumption,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Prod.map,[Prod, Prod.mk],[Prod]]
[coeSortToCoeTail,[outParam, CoeSort, CoeTail.mk, CoeSort.coe],[outParam, CoeSort, CoeTail]]
[Quotient.rec,[Setoid, Quotient, Quotient.mk, HasEquiv.Equiv, instHasEquiv, Eq, Quotient.sound, Quot.rec, Setoid.r],[Setoid, Quotient, Quotient.mk, HasEquiv.Equiv, instHasEquiv, Eq, Quotient.sound]]
[and_false,[propext, And, False, Iff.intro, And.right, False.elim],[Eq, And, False]]
[Float.le,[Float, FloatSpec.le, floatSpec, Float.val],[Float]]
[IO.FileRight.mk.sizeOf_spec,[IO.AccessRight, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Bool],[IO.AccessRight, Eq, Nat, SizeOf.sizeOf, IO.FileRight, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Bool, IO.FileRight.mk]]
[decide_true_eq_true,[Decidable, True, Eq, Bool, Decidable.decide, Bool.true, rfl, Decidable.isTrue, Not, False.elim, Decidable.isFalse, True.intro],[Decidable, True, Eq, Bool, Decidable.decide, Bool.true]]
[notM,[Applicative, Bool, Functor.map, Applicative.toFunctor, not],[Applicative, Bool]]
[UInt64.decEq.proof_2,[Fin, UInt64.size, Not, Eq, UInt64, UInt64.mk, False, absurd],[Fin, UInt64.size, Not, Eq, UInt64, UInt64.mk, False]]
[Lean.groupKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[UInt64.mod,[UInt64, UInt64.mk, HMod.hMod, Fin, UInt64.size, instHMod, Fin.instModFin, UInt64.val],[UInt64]]
[StateT.tryFinally,[MonadFinally, Monad, MonadFinally.mk, StateT, Option, Bind.bind, Monad.toBind, Prod, MonadFinally.tryFinally', Option.some, Unit, Option.none, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk],[MonadFinally, Monad, StateT]]
[Lean.Parser.Tactic.simpPost,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[EStateM.Result.error.inj,[Eq, EStateM.Result, EStateM.Result.error, And, And.intro],[Eq, EStateM.Result, EStateM.Result.error, And]]
[IO.FS.instBEqSystemTime,[BEq.mk, IO.FS.SystemTime, Int, UInt32, IO.FS.SystemTime.mk, Bool, and, Bool.true, BEq.beq, instBEq, Int.instDecidableEqInt, instDecidableEqUInt32, Bool.false],[BEq, IO.FS.SystemTime]]
[Lean.defaultMaxRecDepth,[OfNat.ofNat, Nat, instOfNatNat],[Nat]]
[Lean.Syntax.isIdent,[Lean.Syntax, Bool, Lean.SourceInfo, Substring, Lean.Name, List, Prod, String, Bool.true, Bool.false],[Lean.Syntax, Bool]]
[Array.eraseIdx'.proof_1,[Array, rfl, Nat, Array.size],[Array, Eq, Nat, Array.size]]
[StateT.bind,[Monad, StateT, Bind.bind, Monad.toBind, Prod],[Monad, StateT]]
[Substring.any,[Substring, Char, Bool, String, String.Pos, String.anyAux],[Substring, Char, Bool]]
[Int.natMod,[Int, Int.toNat, HMod.hMod, instHMod, Int.instModInt],[Int, Nat]]
[Measure,[InvImage, Nat, LT.lt, instLTNat],[Nat]]
[eq_of_heq,[HEq],[HEq, Eq]]
[Lean.Parser.Tactic.simpErase,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Array.swapAt,[Array, Fin, Array.size, Array.get, Array.set, Prod.mk],[Array, Fin, Array.size, Prod]]
[Nat.zero_lt_succ,[Nat, Nat.succ_le_succ, OfNat.ofNat, instOfNatNat, Nat.zero_le],[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, Nat.succ]]
[Fin.mod.proof_1,[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt],[Nat, LT.lt, instLTNat, HMod.hMod, instHMod, Nat.instModNat]]
[Lean.Name.noConfusionType,[Lean.Name, String, UInt64, Nat, Eq],[Lean.Name]]
[«term_≠_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[SeqRight.seqRight,[SeqRight],[SeqRight, Unit]]
[ST.Ref.take,[MonadLiftT, ST, ST.Ref, liftM, ST.Prim.Ref.take],[MonadLiftT, ST, ST.Ref]]
[Task.bind,[Task, optParam, Task.Priority, Task.Priority.default, Task.pure, Task.get],[Task, optParam, Task.Priority, Task.Priority.default]]
[USize.ofNat32.proof_1,[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, USize.size, Or, Eq, usize_size_eq, Unit, Nat.lt_trans, of_decide_eq_true, Nat.decLt, Eq.refl, Bool, Bool.true],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, USize.size]]
[UInt32.mod,[UInt32, UInt32.mk, HMod.hMod, Fin, UInt32.size, instHMod, Fin.instModFin, UInt32.val],[UInt32]]
[Nat.add_lt_add_left,[Nat, LT.lt, instLTNat, Nat.lt_of_succ_le, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, LE.le, instLENat, Nat.add_le_add_left, Nat.succ_le_of_lt, Nat.add_succ],[Nat, LT.lt, instLTNat, HAdd.hAdd, instHAdd, instAddNat]]
[instInhabitedUInt16.proof_1,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt16.size, Nat.decLt, Eq.refl, Bool, Bool.true],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt16.size]]
[Quot.liftBeta,[Eq, rfl, Quot.lift, Quot.mk],[Eq, Quot.lift, Quot.mk]]
[optParam,[],[]]
[IO.Process.Stdio.noConfusion,[IO.Process.Stdio, Eq, noConfusionEnum, Nat, instDecidableEqNat, IO.Process.Stdio.toCtorIdx],[IO.Process.Stdio, Eq, IO.Process.Stdio.noConfusionType]]
[instStreamRangeNat,[Stream.mk, Std.Range, Nat, ite, Option, Prod, LT.lt, instLTNat, Std.Range.start, Std.Range.stop, Nat.decLt, Option.some, Prod.mk, Std.Range.mk, HAdd.hAdd, instHAdd, instAddNat, Std.Range.step, Option.none],[Stream, Std.Range, Nat]]
[bool,[ToBool, Bool, ToBool.toBool, Unit],[ToBool]]
[UInt16.toUInt64,[UInt16, Nat.toUInt64, UInt16.toNat],[UInt16, UInt64]]
[instInhabitedEIO,[Inhabited, inferInstanceAs, EStateM, IO.RealWorld, EStateM.instInhabitedEStateM],[Inhabited, EIO]]
[ByteArray.append,[ByteArray, ByteArray.copySlice, OfNat.ofNat, Nat, instOfNatNat, ByteArray.size, Bool.false],[ByteArray]]
[Lean.version.major,[Unit.unit],[Nat]]
[instMonadEIO,[inferInstanceAs, Monad, EStateM, IO.RealWorld, EStateM.instMonadEStateM],[Monad, EIO]]
[modifyThe,[MonadStateOf, MonadStateOf.modifyGet, PUnit, Prod.mk, PUnit.unit],[MonadStateOf, PUnit]]
[LawfulMonad.toLawfulApplicative,[Monad, LawfulMonad],[Monad, LawfulMonad, LawfulApplicative, Monad.toApplicative]]
[Prod.snd,[Prod],[Prod]]
[String.foldlAux,[Char, String, String.Pos, String.foldlAux.loop],[Char, String, String.Pos]]
[«term_||_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[System.mkFilePath,[List, String, System.FilePath.mk, String.intercalate, Char.toString, System.FilePath.pathSeparator],[List, String, System.FilePath]]
[Lean.isLetterLike,[Char, or, and, Decidable.decide, LE.le, UInt32, instLEUInt32, OfNat.ofNat, instOfNatUInt32, Char.val, instDecidableLe, Ne, instDecidableNot, Eq, instDecidableEqUInt32],[Char, Bool]]
[IO.FS.Stream.write,[IO.FS.Stream],[IO.FS.Stream, ByteArray, IO, Unit]]
[Thunk.mk.sizeOf_spec,[SizeOf, Unit, Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[SizeOf, Unit, Eq, Nat, SizeOf.sizeOf, Thunk, SizeOf.mk, OfNat.ofNat, instOfNatNat, Thunk.mk]]
[«term_<&>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instReprList,[Repr, Repr.mk, List, Nat, Std.ToFormat, Std.ToFormat.mk, repr, Std.Format, Std.Format.text, Std.Format.bracket, Std.Format.joinSep, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.line],[Repr, List]]
[StdGen.mk.injEq,[Nat, Eq.propIntro, Eq, StdGen, StdGen.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Nat, Eq, StdGen, StdGen.mk, And]]
[UInt64.div,[UInt64, UInt64.mk, HDiv.hDiv, Fin, UInt64.size, instHDiv, Fin.instDivFin, UInt64.val],[UInt64]]
[String.back,[String, String.get, String.prev, String.bsize],[String, Char]]
[tryFinally,[MonadFinally, Functor, Prod, MonadFinally.tryFinally', Option, Functor.map, Prod.fst],[MonadFinally, Functor]]
[List.beq,[BEq, List, Bool, List.below, Unit, List.nil, Bool.true, List.cons, and, BEq.beq, PProd.fst, PUnit, PProd, Bool.false],[BEq, List, Bool]]
[List.length_replicate.aux,[Nat, List, Eq, List.length, List.replicate.loop, HAdd.hAdd, instHAdd, instAddNat, of_eq_true, Nat.zero, Eq.trans, True, congrArg, OfNat.ofNat, instOfNatNat, congrFun, Nat.zero_eq, Nat.zero_add, eq_self, List.cons, Nat.succ, congr, List.length_cons, Nat.add_succ, Nat.succ_add],[Nat, List, Eq, List.length, List.replicate.loop, HAdd.hAdd, instHAdd, instAddNat]]
[FloatArray.empty,[FloatArray.mkEmpty, OfNat.ofNat, Nat, instOfNatNat],[FloatArray]]
[Lean.Macro.withIncRecDepth,[Lean.Syntax, Lean.MacroM, Bind.bind, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, MonadReader.read, instMonadReader, instMonadReaderOfReaderT, Bool, BEq.beq, Nat, instBEq, instDecidableEqNat, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth, Unit, MonadExcept.throw, instMonadExcept, ReaderT.instMonadExceptOfReaderT, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Lean.Macro.Exception.error, Lean.maxRecDepthErrorMessage, MonadWithReader.withReader, instMonadWithReader, instMonadWithReaderOfReaderT, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Lean.Macro.Context.ref],[Lean.Syntax, Lean.MacroM]]
[Nat.mod.inductionOn,[Nat, And, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, HSub.hSub, instHSub, instSubNat, Not, Nat.div.inductionOn],[Nat, And, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, HSub.hSub, instHSub, instSubNat, Not]]
[instInhabitedDepArrow,[Inhabited, Inhabited.mk, arbitrary],[Inhabited]]
[instDecidableEqUInt64,[UInt64.decEq],[DecidableEq, UInt64]]
[ExceptT.seqLeft_eq,[Monad, LawfulMonad, ExceptT],[Monad, LawfulMonad, ExceptT, Eq, SeqLeft.seqLeft, Applicative.toSeqLeft, Monad.toApplicative, ExceptT.instMonadExceptT, Unit, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const]]
[Lean.Parser.Tactic.tacticShow_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[ofBoolUsing_eq_true,[Decidable, Eq, Bool, toBoolUsing, Bool.true, of_decide_eq_true],[Decidable, Eq, Bool, toBoolUsing, Bool.true]]
[Lean.instQuoteSyntax,[Lean.Quote.mk, Lean.Syntax, id],[Lean.Quote, Lean.Syntax]]
[SeqLeft.seqLeft,[SeqLeft],[SeqLeft, Unit]]
[Quotient.ind₂,[Setoid, Quotient, Quotient.mk, Quotient.ind],[Setoid, Quotient, Quotient.mk]]
[Std.Format.text.inj,[String, Eq, Std.Format, Std.Format.text],[String, Eq, Std.Format, Std.Format.text]]
[Lean.Syntax.ident.sizeOf_spec,[Lean.SourceInfo, Substring, Lean.Name, List, Prod, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOf, SizeOf.mk, String.Pos, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOfName],[Lean.SourceInfo, Substring, Lean.Name, List, Prod, String, Eq, Nat, SizeOf.sizeOf, Lean.Syntax, SizeOf.mk, Array, OfNat.ofNat, instOfNatNat, Lean.SyntaxNodeKind, HAdd.hAdd, instHAdd, instAddNat, instSizeOfName, instSizeOf, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, String.Pos, Lean.Syntax.ident]]
[rfl,[rfl.proof_1],[Eq]]
[List.length_replicate,[Nat, List, Eq, List.length, List.replicate.loop, HAdd.hAdd, instHAdd, instAddNat, List.nil, List.length_replicate.aux],[Nat, Eq, List.length, List.replicate]]
[Except.ok.inj,[Eq, Except, Except.ok],[Eq, Except, Except.ok]]
[Lean.Parser.Tactic.anyGoals,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[unexpandProdMk,[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, Lean.Syntax.SepArray, Lean.Syntax.SepArray.mk, Lean.Syntax.getArgs, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Nat.sub_succ,[Nat, rfl, HSub.hSub, instHSub, instSubNat, Nat.succ],[Nat, Eq, HSub.hSub, instHSub, instSubNat, Nat.succ, Nat.pred]]
[Std.Range.forIn.loop,[Monad, Std.Range, Nat, ForInStep, Nat.below, ite, GE.ge, instLENat, Std.Range.stop, Nat.decLe, Pure.pure, Applicative.toPure, Monad.toApplicative, Unit, Nat.succ, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, Std.Range.step],[Monad, Std.Range, Nat, ForInStep]]
[ByteArray.size,[ByteArray, Nat, Array, UInt8, Array.size],[Nat]]
[Nat.decEq,[Bool, Eq, Nat.beq, Decidable, Nat, Nat.decEq.proof_1, Bool.true, Decidable.isTrue, Nat.eq_of_beq_eq_true, Bool.false, Decidable.isFalse, Nat.ne_of_beq_eq_false],[Decidable, Eq, Nat]]
[List.forIn_nil,[Monad, ForInStep, rfl, ForIn.forIn, List, List.instForInList, List.nil],[Monad, ForInStep, Eq, ForIn.forIn, List, List.instForInList, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[Nat.mod_eq,[Nat, dite, And, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HMod.hMod, instHMod, Nat.instModNat, HSub.hSub, instHSub, instSubNat, Not, Eq, congrFun, WellFounded.fix, WellFoundedRelation.rel, measure, id, WellFoundedRelation.wf, And.intro, Nat.sub_lt, Nat.lt_of_lt_of_le, WellFounded.fix_eq, ite, dif_eq_if],[Nat, Eq, HMod.hMod, instHMod, Nat.instModNat, ite, And, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HSub.hSub, instHSub, instSubNat]]
[optionCoe,[CoeTail.mk, Option, Option.some],[CoeTail, Option]]
[Array.forIn.loop,[Monad, Array, ForInStep, Nat, LE.le, instLENat, Array.size, Nat.below, OfNat.ofNat, instOfNatNat, Pure.pure, Applicative.toPure, Monad.toApplicative, HAdd.hAdd, instHAdd, instAddNat, Nat.succ],[Monad, Array, ForInStep, Nat, LE.le, instLENat, Array.size]]
[Int.decLt,[Decidable, Int.NonNeg, Nat, Decidable.isTrue, Int.ofNat, Int.NonNeg.mk, Decidable.isFalse, Int.negSucc, Int, Eq, HEq, Eq.refl, HEq.refl, False, HSub.hSub, instHSub, Int.instSubInt, HAdd.hAdd, instHAdd, Int.instAddInt, OfNat.ofNat, hasOfNatOfCoe, instCoeNatInt, instOfNatNat],[Decidable, LT.lt, Int, Int.instLTInt]]
[Array.toListLitAux.proof_1,[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Nat.le_of_succ_le],[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size]]
[LawfulFunctor.noConfusionType,[Functor, LawfulFunctor, Eq, Functor.mapConst, Function.comp, Functor.map, Function.const, id],[Functor, LawfulFunctor]]
[Lean.Syntax.isAtom,[Lean.Syntax, Bool, Lean.SourceInfo, String, Bool.true, Bool.false],[Lean.Syntax, Bool]]
[ReprTuple.noConfusionType,[ReprTuple, List, Std.Format, Eq],[ReprTuple]]
[Nat.lt_wfRel,[WellFoundedRelation.mk, Nat, Nat.lt, Nat.lt_wfRel.proof_1],[WellFoundedRelation, Nat]]
[String.str,[String.push],[String, Char]]
[MonadControl.liftWith,[MonadControl],[MonadControl, MonadControl.stM]]
[instMonadState,[MonadStateOf, MonadState.mk, getThe, MonadStateOf.set, Prod, MonadStateOf.modifyGet],[MonadStateOf, MonadState]]
[UInt8.decEq,[UInt8, Decidable, Eq, Fin, UInt8.size, dite, UInt8.mk, instDecidableEqFin, Decidable.isTrue, UInt8.decEq.proof_1, Not, Decidable.isFalse, UInt8.decEq.proof_2],[UInt8, Decidable, Eq]]
[instAndOpUSize,[AndOp.mk, USize, USize.land],[AndOp, USize]]
[instReprAtomNat,[ReprAtom.mk, Nat],[ReprAtom, Nat]]
[instHashableUInt32,[Hashable.mk, UInt32, UInt32.toUInt64],[Hashable, UInt32]]
[instComplementUInt8,[Complement.mk, UInt8, UInt8.complement],[Complement, UInt8]]
[List.reverse_append,[List, Eq, List.reverse, HAppend.hAppend, instHAppend, List.instAppendList, of_eq_true, List.nil, Eq.trans, True, congr, congrArg, List.nil_append, List.reverse_nil, List.append_nil, eq_self, Eq.mpr, List.cons, List.cons_append, List.reverse_cons, congrFun, Eq.refl, List.append_assoc, rfl],[List, Eq, List.reverse, HAppend.hAppend, instHAppend, List.instAppendList]]
[instHashableProd,[Hashable, Hashable.mk, Prod, UInt64, mixHash, Hashable.hash],[Hashable, Prod]]
[IO.FS.instLESystemTime,[leOfOrd, IO.FS.SystemTime, IO.FS.instOrdSystemTime],[LE, IO.FS.SystemTime]]
[Lean.Syntax.setArgs,[Lean.Syntax, Array, Lean.SyntaxNodeKind, Lean.Syntax.node],[Lean.Syntax, Array]]
[String.Iterator.mk.injEq,[String, String.Pos, Eq.propIntro, Eq, String.Iterator, String.Iterator.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[String, String.Pos, Eq, String.Iterator, String.Iterator.mk, And]]
[Monad.toBind,[Monad],[Monad, Bind]]
[Eq.mpr_prop,[Eq, Eq.symm],[Eq]]
[IO.Error.mkResourceBusy,[IO.Error.resourceBusy],[UInt32, String, IO.Error]]
[StateT.instLawfulMonadStateT.proof_1,[Monad, LawfulMonad, LawfulMonad.mk, StateT, StateT.instMonadStateT, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, StateT.ext, Functor.map, id, of_eq_true, Eq, Prod, StateT.run, Eq.trans, True, congrFun, congrArg, Prod.mk, Prod.fst, Prod.snd, StateT.run_map, funext, id_eq, Prod.ext, id_map', LawfulApplicative.toLawfulFunctor, LawfulMonad.toLawfulApplicative, eq_self, StateT.seqLeft_eq, StateT.seqRight_eq, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, Unit, congr, Bind.bind, Monad.toBind, StateT.run_seq, StateT.run_pure, LawfulMonad.pure_bind, Function.comp, Eq.mpr, StateT.run_bind, LawfulMonad.bind_pure_comp, LawfulMonad.bind_assoc],[Monad, LawfulMonad, StateT, StateT.instMonadStateT]]
[Array.findSome!,[Inhabited, Array, Option, Array.findSome?, Unit, panicWithPosWithDecl, OfNat.ofNat, Nat, instOfNatNat],[Inhabited, Array, Option]]
[StateRefT'.run',[Monad, MonadLiftT, ST, StateRefT', Bind.bind, Monad.toBind, Prod, StateRefT'.run, Pure.pure, Applicative.toPure, Monad.toApplicative],[Monad, MonadLiftT, ST, StateRefT']]
[UInt16.div,[UInt16, UInt16.mk, HDiv.hDiv, Fin, UInt16.size, instHDiv, Fin.instDivFin, UInt16.val],[UInt16]]
[«term%[_|_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false],[Lean.ParserDescr]]
[Id.pure_eq,[rfl, Id, Pure.pure, Applicative.toPure, Monad.toApplicative, Id.instMonadId],[Eq, Id, Pure.pure, Applicative.toPure, Monad.toApplicative, Id.instMonadId]]
[EStateM.orElse,[outParam, EStateM.Backtrackable, EStateM, Unit, EStateM.Backtrackable.save, EStateM.Result, Unit.unit, EStateM.Backtrackable.restore],[outParam, EStateM.Backtrackable, EStateM, Unit]]
[List.drop,[Nat, List, Nat.below, Nat.succ, List.nil, PProd.fst, PUnit, PProd],[Nat, List]]
[Nat.lt.base.proof_1,[Nat, Nat.le_refl, Nat.succ],[Nat, LE.le, instLENat, Nat.succ]]
[ptrAddrUnsafe,[OfNat.ofNat, USize, instOfNatUSize],[USize]]
[Char.ofNat.proof_1,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size]]
[System.instInhabitedFilePath,[Inhabited.mk, System.FilePath, System.FilePath.mk, arbitrary, String, String.instInhabitedString],[Inhabited, System.FilePath]]
[Std.Format.below,[Std.Format, PUnit, String, Int, PProd, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone, Nat],[Std.Format]]
[Lean.ParserDescr.noConfusionType,[Lean.ParserDescr, Lean.Name, Eq, Lean.SyntaxNodeKind, Nat, String, Bool, optParam, Bool.false],[Lean.ParserDescr]]
[Classical.propComplete,[Or, Not, Classical.em, Eq, True, False, Or.inl, propext, Iff.intro, True.intro, Or.inr, False.elim],[Or, Eq, True, False]]
[instMonadWithReaderOfReaderT,[Monad, MonadWithReaderOf.mk, ReaderT],[Monad, MonadWithReaderOf, ReaderT]]
[EStateM.dummySave,[PUnit.unit],[PUnit]]
[Array.shrink,[Array, Nat, HSub.hSub, instHSub, instSubNat, Array.size, Array.shrink.loop],[Array, Nat]]
[System.FilePath.pathSeparator,[ite, Char, Eq, Bool, System.Platform.isWindows, Bool.true, instDecidableEqBool, Char.ofNat],[Char]]
[instBEqOrdering,[BEq.mk, Ordering, BEq.beq, Nat, instBEq, instDecidableEqNat, Ordering.toCtorIdx],[BEq, Ordering]]
[EmptyCollection.emptyCollection,[EmptyCollection],[EmptyCollection]]
[List.toArray,[List, List.toArrayAux, Array.mkEmpty, List.redLength],[List, Array]]
[instModUInt8,[Mod.mk, UInt8, UInt8.mod],[Mod, UInt8]]
[Array.forIn.loop.proof_2,[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.succ, Nat.lt_succ_self],[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size]]
[«term_<<<_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instToStringProd,[ToString, ToString.mk, Prod, String, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString],[ToString, Prod]]
[Array.shrink.loop,[Nat, Array, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, Array.pop],[Nat, Array]]
[Lean.Syntax.isFieldIdx?,[Lean.Syntax, Lean.SyntaxNodeKind, Option, String, Option.some, Option.none, Nat, Lean.Syntax.isLit?, Lean.Syntax.decodeNatLitVal?, Lean.fieldIdxKind],[Lean.Syntax, Option, Nat]]
[ST.instInhabitedRef.proof_1,[Inhabited, Nonempty.intro, arbitrary],[Inhabited, Nonempty]]
[IO.Error.mkIllegalOperation,[IO.Error.illegalOperation],[UInt32, String, IO.Error]]
[Function.comp,[],[]]
[Nat.add,[Nat, Nat.below, Nat.zero, Nat.succ, PProd.fst, PUnit, PProd],[Nat]]
[precMin,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Fin.land.proof_1,[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, Nat.land],[Nat, LT.lt, instLTNat, HMod.hMod, instHMod, Nat.instModNat, Nat.land]]
[Lean.NameGenerator.mk.injEq,[Lean.Name, Nat, Eq.propIntro, Eq, Lean.NameGenerator, Lean.NameGenerator.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Lean.Name, Nat, Eq, Lean.NameGenerator, Lean.NameGenerator.mk, And]]
[instReprChar,[Repr.mk, Char, Nat, Std.Format.text, Char.quote],[Repr, Char]]
[Subsingleton.elim.proof_1,[Subsingleton, Subsingleton.allEq],[Subsingleton, Eq]]
[Prod.rprod,[WellFoundedRelation, WellFoundedRelation.mk, Prod, Prod.RProd, WellFoundedRelation.rel, Prod.rprod.proof_1],[WellFoundedRelation, Prod]]
[Subrelation.accessible.proof_1,[Subrelation, Acc, Acc.intro],[Subrelation, Acc]]
[Classical.byContradiction,[Not, False, Decidable.byContradiction, Classical.propDecidable],[Not, False]]
[Except.pure,[Except.ok],[Except]]
[String.trimRight,[String, Substring.toString, Substring.trimRight, String.toSubstring],[String]]
[IO.Error.unsupportedOperation.sizeOf_spec,[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar],[UInt32, String, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, Option, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.unsupportedOperation]]
[Nat.max,[Nat, ite, LE.le, instLENat, Nat.decLe],[Nat]]
[Std.Range.start,[Std.Range],[Std.Range, Nat]]
[Int.mod,[Int, Nat, Int.ofNat, HMod.hMod, instHMod, Nat.instModNat, Nat.succ, Neg.neg, Int.instNegInt],[Int]]
[Array.mapMUnsafe,[Monad, Array, USize, USize.ofNat, Array.size, NonScalar, PNonScalar, unsafeCast, OfNat.ofNat, instOfNatUSize, Array.mapMUnsafe.map],[Monad, Array]]
[Std.Format.MonadPrettyFormat.endTags,[Std.Format.MonadPrettyFormat],[Std.Format.MonadPrettyFormat, Nat, Unit]]
[IO.FS.SystemTime.sec,[IO.FS.SystemTime],[IO.FS.SystemTime, Int]]
[IO.FileRight.mk.injEq,[IO.AccessRight, Eq.propIntro, Eq, IO.FileRight, IO.FileRight.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[IO.AccessRight, Eq, IO.FileRight, IO.FileRight.mk, And]]
[Std.Format.ibelow,[Std.Format, True, String, Int, And, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone, Nat],[Std.Format]]
[Lean.Macro.Context.currMacroScope,[Lean.Macro.Context],[Lean.Macro.Context, Lean.MacroScope]]
[Array.instReprArray,[Repr, Repr.mk, Array, Nat, Std.ToFormat, Std.ToFormat.mk, repr, Std.Format, ite, Eq, Bool, BEq.beq, instBEq, instDecidableEqNat, Array.size, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Std.Format.text, Std.Format.bracketFill, Std.Format.joinSep, Array.toList, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.line],[Repr, Array]]
[FloatSpec.float,[FloatSpec],[FloatSpec]]
[Acc.brecOn,[Acc, Acc.below, Acc.below.intro],[Acc, Acc.below]]
[instSubsingletonStateM.proof_1,[Subsingleton, Subsingleton.intro, StateM, funext, Id, Prod, Eq, Eq.mpr, Prod.mk, Eq.refl, Subsingleton.elim, rfl],[Subsingleton, StateM]]
[Lean.mkNullNode,[optParam, Array, Lean.Syntax, List.toArray, List.nil, Lean.Syntax.node, Lean.nullKind],[optParam, Array, Lean.Syntax, List.toArray, List.nil]]
[Lean.expandBrackedBindersAux.loop,[Lean.Syntax, Array, Nat, Lean.MacroM, Nat.below, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Nat.succ, Lean.Syntax.getArgs, Lean.Syntax.getOp, Array.getOp, Lean.instInhabitedSyntax, OfNat.ofNat, instOfNatNat, Bind.bind, Monad.toBind, Lean.expandExplicitBindersAux, Option.some, PProd.fst, PUnit, PProd],[Lean.Syntax, Array, Nat, Lean.MacroM]]
[MProd.fst,[MProd],[MProd]]
[IO.Error.mkInvalidArgumentFile,[Function.comp, String, Option, UInt32, IO.Error, IO.Error.invalidArgument, Option.some],[String, UInt32, IO.Error]]
[ExceptCpsT.instLawfulMonadExceptCpsT,[ExceptCpsT.instLawfulMonadExceptCpsT.proof_1],[LawfulMonad, ExceptCpsT, ExceptCpsT.instMonadExceptCpsT]]
[instXorUSize,[Xor.mk, USize, USize.xor],[Xor, USize]]
[instToStringIterator,[ToString.mk, String.Iterator, String.Iterator.remainingToString],[ToString, String.Iterator]]
[Lean.Macro.instMonadRefMacroM,[Lean.MonadRef.mk, Lean.MacroM, Bind.bind, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Syntax, MonadReader.read, instMonadReader, instMonadReaderOfReaderT, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Macro.Context.ref, MonadWithReader.withReader, instMonadWithReader, instMonadWithReaderOfReaderT, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth],[Lean.MonadRef, Lean.MacroM]]
[Squash.lift.proof_1,[Subsingleton, True, Subsingleton.elim],[Subsingleton, True, Eq]]
[Std.Format.instCoeStringFormat,[Coe.mk, String, Std.Format, Std.Format.text],[Coe, String, Std.Format]]
[ReprTuple.reprTuple,[ReprTuple],[ReprTuple, List, Std.Format]]
[instDivUSize,[Div.mk, USize, USize.div],[Div, USize]]
[Quotient.mk,[Setoid, Quot.mk, Setoid.r],[Setoid, Quotient]]
[instDecidableEqUInt8,[UInt8.decEq],[DecidableEq, UInt8]]
[Nat.instAndOpNat,[AndOp.mk, Nat, Nat.land],[AndOp, Nat]]
[instReprUInt8,[Repr.mk, UInt8, Nat, repr, instReprNat, UInt8.toNat],[Repr, UInt8]]
[IO.Error.resourceExhausted.sizeOf_spec,[Option, String, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[Option, String, UInt32, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.resourceExhausted]]
[Lean.Parser.Tactic.Conv.arg,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Option.isSome,[Option, Bool, Bool.true, Unit, Bool.false],[Option, Bool]]
[ShiftLeft.shiftLeft,[ShiftLeft],[ShiftLeft]]
[List.init,[List, List.below, Unit, List.nil, List.cons, PProd.fst, PUnit, PProd],[List]]
[IO.println,[ToString, IO.print, String, instToStringString, String.push, ToString.toString, Char.ofNat],[ToString, IO, Unit]]
[Array.swap!,[Array, dite, LT.lt, Nat, instLTNat, Array.size, Nat.decLt, Array.swap, Fin.mk, Not, panicWithPosWithDecl, Array.instInhabitedArray, OfNat.ofNat, instOfNatNat],[Array]]
[IO.Error.mkNoSuchThingFile,[Function.comp, String, Option, UInt32, IO.Error, IO.Error.noSuchThing, Option.some],[String, UInt32, IO.Error]]
[Lean.Syntax.getOptional?,[Lean.Syntax, Option, Lean.SyntaxNodeKind, Array, ite, Eq, Bool, and, BEq.beq, Lean.Name.instBEqName, Lean.nullKind, Nat, instBEq, instDecidableEqNat, Array.size, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Option.some, Array.get!, Lean.instInhabitedSyntax, Option.none],[Lean.Syntax, Option]]
[Char.lt,[Char, LT.lt, UInt32, instLTUInt32, Char.val],[Char]]
[instAndOpUInt32,[AndOp.mk, UInt32, UInt32.land],[AndOp, UInt32]]
[FloatSpec.val,[FloatSpec],[FloatSpec, FloatSpec.float]]
[instHashableString,[Hashable.mk, String, String.hash],[Hashable, String]]
[IO.Error.mkAlreadyExistsFile,[Function.comp, String, Option, UInt32, IO.Error, IO.Error.alreadyExists, Option.some],[String, UInt32, IO.Error]]
[IO.FS.Mode.write.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, IO.FS.Mode, SizeOf.mk, OfNat.ofNat, instOfNatNat, IO.FS.Mode.write]]
[ExceptCpsT.instMonadExceptCpsT,[Monad.mk, ExceptCpsT, Applicative.mk, Functor.mk, Pure.mk, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk],[Monad, ExceptCpsT]]
[instDecidableIff,[Decidable, dite, Iff, Decidable.isTrue, instDecidableIff.proof_1, Not, Decidable.isFalse, instDecidableIff.proof_2, instDecidableIff.proof_3, instDecidableIff.proof_4],[Decidable, Iff]]
[String.map,[Char, String, String.mapAux, OfNat.ofNat, String.Pos, instOfNatNat],[Char, String]]
[Lean.Parser.Tactic.Conv.convRight,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[instLTUInt8,[LT.mk, UInt8, UInt8.lt],[LT, UInt8]]
[DoResultBC.break.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, DoResultBC, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, DoResultBC.break]]
[Lean.expandBrackedBinders,[Lean.Name, Lean.Syntax, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.MonadRef.getRef, Lean.Macro.instMonadRefMacroM, Lean.mkIdentFrom, Lean.expandBrackedBindersAux, List.toArray, List.cons, List.nil],[Lean.Name, Lean.Syntax, Lean.MacroM]]
[Nat.lt_of_succ_lt,[Nat, Nat.le_of_succ_le, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat],[Nat, LT.lt, instLTNat, Nat.succ]]
[«term↑_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Name.toString,[Lean.Name, optParam, Bool, Bool.true, Lean.Name.toStringWithSep, and, not, Lean.Name.isInaccessibleUserName, Lean.Name.hasMacroScopes, Lean.Name.toString.maybePseudoSyntax],[Lean.Name, optParam, Bool, Bool.true, String]]
[Nat.succ.injEq,[Nat, Eq.propIntro, Eq, Nat.succ, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Nat, Eq, Nat.succ]]
[Int.neg,[Int, Nat, Int.negOfNat, Int.ofNat, Nat.succ],[Int]]
[ReaderT.instLawfulMonadReaderT.proof_1,[Monad, LawfulMonad, LawfulMonad.mk, ReaderT, ReaderT.instMonadReaderT, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, ReaderT.ext, Functor.map, id, of_eq_true, Eq, ReaderT.run, Eq.trans, True, congrFun, congrArg, ReaderT.run_map, LawfulFunctor.id_map, LawfulApplicative.toLawfulFunctor, LawfulMonad.toLawfulApplicative, eq_self, SeqLeft.seqLeft, Applicative.toSeqLeft, Unit, Seq.seq, Applicative.toSeq, Function.const, Eq.mpr, congr, ReaderT.run_seqLeft, ReaderT.run_seq, LawfulApplicative.seqLeft_eq, SeqRight.seqRight, Applicative.toSeqRight, ReaderT.run_seqRight, LawfulApplicative.seqRight_eq, Pure.pure, Applicative.toPure, ReaderT.run_pure, LawfulApplicative.pure_seq, Bind.bind, Monad.toBind, Function.comp, ReaderT.run_bind, funext, LawfulMonad.bind_pure_comp, LawfulMonad.pure_bind, LawfulMonad.bind_assoc],[Monad, LawfulMonad, ReaderT, ReaderT.instMonadReaderT]]
[Lean.MonadRef.withRef,[Lean.MonadRef],[Lean.MonadRef, Lean.Syntax]]
[Nat.allM.loop,[Monad, Nat, Bool, Nat.below, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.true, Nat.succ, Bind.bind, Monad.toBind, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, PProd.fst, PUnit, PProd, Bool.false],[Monad, Nat, Bool]]
[HEq.rfl,[HEq.rfl.proof_1],[HEq]]
[StateT.run_bind,[Monad, StateT, bind_congr, Prod, Monad.toBind, Prod.fst, Prod.snd, Eq, Prod.mk, rfl, Eq.symm, Eq.refl],[Monad, StateT, Eq, Prod, StateT.run, Bind.bind, Monad.toBind, StateT.instMonadStateT, Prod.fst, Prod.snd]]
[UInt8.toNat,[UInt8, Fin.val, UInt8.size, UInt8.val],[UInt8, Nat]]
[IO.AccessRight.write,[IO.AccessRight],[IO.AccessRight, Bool]]
[Lean.Syntax.instToStringSyntax,[ToString.mk, Lean.Syntax, Function.comp, Std.Format, String, ToString.toString, instToStringFormat, Std.ToFormat.format, Lean.Syntax.instToFormatSyntax],[ToString, Lean.Syntax]]
[«term_>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Name.isInaccessibleUserName,[Lean.Name, Bool, Lean.Name.below, String, UInt64, Lean.Name.str, or, String.contains, Char.ofNat, BEq.beq, instBEq, instDecidableEqString, Nat, Lean.Name.num, PProd.fst, PUnit, PProd, Bool.false],[Lean.Name, Bool]]
[UInt32.val,[UInt32],[UInt32, Fin, UInt32.size]]
[List.any,[List, Bool, List.foldr, or, Bool.false],[List, Bool]]
[Nat.toSuperscriptString,[Nat, List.asString, Nat.toSuperDigits],[Nat, String]]
[Id.finally,[MonadFinally.mk, Id, Option, Option.some, Pure.pure, Applicative.toPure, Monad.toApplicative, Id.instMonadId, Prod, Prod.mk],[MonadFinally, Id]]
[EStateM.nonBacktrackable,[EStateM.Backtrackable.mk, PUnit, EStateM.dummySave, EStateM.dummyRestore],[EStateM.Backtrackable, PUnit]]
[UInt64.add,[UInt64, UInt64.mk, HAdd.hAdd, Fin, UInt64.size, instHAdd, Fin.instAddFin, UInt64.val],[UInt64]]
[instDecidableEqProd,[DecidableEq, Prod, Decidable, Eq, Prod.mk, decEq, Decidable.isTrue, instDecidableEqProd.proof_1, Not, Decidable.isFalse, instDecidableEqProd.proof_2, instDecidableEqProd.proof_3],[DecidableEq, Prod]]
[List.unzip,[List, Prod, List.below, Unit, List.nil, Prod.mk, List.cons, PProd.fst, PUnit, PProd],[List, Prod]]
[Nat.gt_of_not_le,[Nat, Not, LE.le, instLENat, Or, LT.lt, instLTNat, GE.ge, Nat.lt_or_ge, GT.gt, absurd],[Nat, Not, LE.le, instLENat, GT.gt, instLTNat]]
[Bool.toUInt64,[Bool, ite, UInt64, Eq, Bool.true, instDecidableEqBool, OfNat.ofNat, instOfNatUInt64],[Bool, UInt64]]
[emptyWf.proof_1,[WellFounded.intro, emptyRelation, Acc.intro, False, Eq, Acc, Eq.refl],[WellFounded, emptyRelation]]
[Quot.recOnSubsingleton,[Quot, Subsingleton, Quot.mk, Quot.rec, Quot.recOnSubsingleton.proof_1],[Quot, Subsingleton, Quot.mk]]
[StateCpsT.runK_bind_pure,[Monad, StateCpsT, rfl, StateCpsT.runK, Bind.bind, Monad.toBind, StateCpsT.instMonadStateCpsT, Pure.pure, Applicative.toPure, Monad.toApplicative],[Monad, StateCpsT, Eq, StateCpsT.runK, Bind.bind, Monad.toBind, StateCpsT.instMonadStateCpsT, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[USize.div,[USize, USize.mk, HDiv.hDiv, Fin, USize.size, instHDiv, Fin.instDivFin, USize.val],[USize]]
[CoeFun.coe,[CoeFun],[CoeFun]]
[Array.set,[Array, Array.mk, List.set, Array.data, Fin.val, Array.size],[Array]]
[Array.map,[Array, Id.run, Array.mapM, Id, Id.instMonadId],[Array]]
[instDecidableEqSum.proof_2,[Not, Eq, Sum, Sum.inl, False, absurd],[Not, Eq, Sum, Sum.inl, False]]
[Int.instLEInt,[LE.mk, Int, Int.le],[LE, Int]]
[FloatSpec.lt,[FloatSpec],[FloatSpec, FloatSpec.float]]
[OptionT.instMonadExceptOfUnitOptionT,[Monad, MonadExceptOf.mk, Unit, OptionT, OptionT.fail, OptionT.tryCatch],[Monad, MonadExceptOf, Unit, OptionT]]
[Array.mapM,[Monad, Array, Array.foldlM, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.push, Array.mkEmpty, Array.size, OfNat.ofNat, Nat, instOfNatNat],[Monad, Array]]
[Array.getD,[Array, Nat, dite, LT.lt, instLTNat, Array.size, Nat.decLt, Array.get, Fin.mk, Not],[Array, Nat]]
[System.instDecidableEqFilePath,[System.FilePath, String, System.FilePath.mk, Decidable, Eq, dite, instDecidableEqString, Decidable.isTrue, rfl, Not, Decidable.isFalse, False],[DecidableEq, System.FilePath]]
[Lean.nameLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[reprArg,[Repr, Repr.reprPrec, OfNat.ofNat, Nat, instOfNatNat],[Repr, Std.Format]]
[Array.mkEmpty,[Array.mk, List.nil],[Array]]
[Or.intro_left,[Or.inl],[Or]]
[Ne.elim,[Ne],[Ne, Eq, False]]
[ST.mkRef,[MonadLiftT, ST, liftM, ST.Ref, ST.Prim.mkRef],[MonadLiftT, ST, ST.Ref]]
[Subarray.start,[Subarray],[Subarray, Nat]]
[Eq.substr,[Eq, Eq.symm],[Eq]]
[Array.sequenceMap.loop,[Monad, Array, Nat, Nat.below, dite, LT.lt, instLTNat, Array.size, Nat.decLt, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Nat.succ, Bind.bind, Monad.toBind, Array.get, Fin.mk, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.push, Not],[Monad, Array, Nat]]
[instDecidableEqUInt32,[UInt32.decEq],[DecidableEq, UInt32]]
[hasOfNatOfCoe,[Nat, Coe, OfNat, OfNat.mk, coe, OfNat.ofNat, coeOfHTCT, coeOfTC, coeBase],[Nat, Coe, OfNat]]
[String.nextUntil,[String, Char, Bool, String.Pos, String.nextWhile, not],[String, Char, Bool, String.Pos]]
[«stx_<|>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Syntax.toNat,[Lean.Syntax, Option, Nat, Lean.Syntax.isNatLit?, Unit, OfNat.ofNat, instOfNatNat],[Lean.Syntax, Nat]]
[MonadExceptOf.tryCatch,[MonadExceptOf],[MonadExceptOf]]
[PSigma.lexNdepWf.proof_1,[WellFounded, WellFounded.intro, PSigma, PSigma.lexNdep, Acc, PSigma.lexAccessible, WellFounded.apply],[WellFounded, PSigma, PSigma.lexNdep]]
[IO.Error.unsupportedOperation.injEq,[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.unsupportedOperation, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[UInt32, String, Eq, IO.Error, IO.Error.unsupportedOperation, And]]
[ReaderT.run_monadLift,[MonadLiftT, rfl, ReaderT.run, MonadLiftT.monadLift, ReaderT, instMonadLiftT, ReaderT.instMonadLiftReaderT],[MonadLiftT, Eq, ReaderT.run, MonadLiftT.monadLift, ReaderT, instMonadLiftT, ReaderT.instMonadLiftReaderT]]
[Lean.unbracketedExplicitBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.binderIdent, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat],[Lean.ParserDescr]]
[Fin.decLt,[Nat, Fin, Nat.decLt, Fin.val],[Nat, Fin, Decidable, LT.lt, instLTFin]]
[HShiftRight.noConfusionType,[outParam, HShiftRight, Eq],[outParam, HShiftRight]]
[Lean.Name.num.injEq,[Lean.Name, Nat, UInt64, Eq.propIntro, Eq, Lean.Name.num, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Lean.Name, Nat, UInt64, Eq, Lean.Name.num, And]]
[List.filterM,[Monad, Bool, List, Bind.bind, Monad.toBind, List.filterAuxM, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, List.reverse],[Monad, Bool, List]]
[instXorUInt16,[Xor.mk, UInt16, UInt16.xor],[Xor, UInt16]]
[PSigma.lexAccessible,[PSigma.lexAccessible.proof_1],[Acc, WellFounded, PSigma, PSigma.Lex, PSigma.mk]]
[Nat.forM.loop,[Monad, Nat, Unit, Nat.below, Pure.pure, Applicative.toPure, Monad.toApplicative, Unit.unit, Nat.succ, Bind.bind, Monad.toBind, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, PUnit, PProd.fst, PProd],[Monad, Nat, Unit]]
[PUnit.unit.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, PUnit, SizeOf.mk, OfNat.ofNat, instOfNatNat, PUnit.unit]]
[List.isEqv,[List, Bool, List.below, List.nil, Bool.true, List.cons, and, PProd.fst, PUnit, PProd, Bool.false],[List, Bool]]
[Nat.mul_lt_mul_of_pos_right,[Nat, LT.lt, instLTNat, GT.gt, OfNat.ofNat, instOfNatNat, HMul.hMul, instHMul, instMulNat, Nat.mul_lt_mul_of_pos_left, Nat.mul_comm],[Nat, LT.lt, instLTNat, GT.gt, OfNat.ofNat, instOfNatNat, HMul.hMul, instHMul, instMulNat]]
[IO.Error.mkAlreadyExists,[IO.Error.alreadyExists, Option.none, String],[UInt32, String, IO.Error]]
[unexpandSorryAx,[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Nat.mul,[Nat, Nat.below, OfNat.ofNat, instOfNatNat, Nat.succ, Nat.add, PProd.fst, PUnit, PProd],[Nat]]
[Nat.add_right_cancel,[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.add_left_cancel, Eq.mp, Eq.refl, Nat.add_comm],[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat]]
[Substring.splitOn,[Substring, optParam, String, ite, List, Eq, Bool, BEq.beq, instBEq, instDecidableEqString, Bool.true, instDecidableEqBool, List.cons, List.nil, String.Pos, OfNat.ofNat, instOfNatNat, Substring.splitOn.loop],[Substring, optParam, String, List]]
[Lean.Syntax.decodeNatLitVal?,[String, Nat, String.length, ite, Option, Eq, Bool, BEq.beq, instBEq, instDecidableEqNat, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Option.none, Char, String.get, String.Pos, instDecidableEqChar, Char.ofNat, Option.some, or, Char.isDigit],[String, Option, Nat]]
[ite_congr,[Decidable, Eq, Not, Or, Decidable.em, ite, Or.inl, Eq.mpr, Eq.refl, if_pos, Eq.symm, Or.inr, if_neg],[Decidable, Eq, Not, ite]]
[Lean.replaceRef,[Lean.Syntax, Option, String.Pos, Lean.Syntax.getPos?, Bool.false],[Lean.Syntax]]
[instReprUInt64,[Repr.mk, UInt64, Nat, repr, instReprNat, UInt64.toNat],[Repr, UInt64]]
[instDecidableEqChar,[Char, Decidable, Eq, UInt32, Char.val, decEq, instDecidableEqUInt32, Decidable.isTrue, Char.eq_of_val_eq, Not, Decidable.isFalse, Char.ne_of_val_ne],[DecidableEq, Char]]
[instToStringPUnit,[ToString.mk, PUnit],[ToString, PUnit]]
[Lean.Meta.Simp.Config.decide,[Lean.Meta.Simp.Config],[Lean.Meta.Simp.Config, Bool]]
[OptionT.instMonadOptionT,[Monad, Monad.mk, OptionT, Applicative.mk, Functor.mk, Pure.mk, OptionT.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk, OptionT.bind],[Monad, OptionT]]
[Lean.Syntax.mkStrLit,[String, optParam, Lean.SourceInfo, Lean.SourceInfo.none, Lean.Syntax.mkLit, Lean.strLitKind, String.quote],[String, optParam, Lean.SourceInfo, Lean.SourceInfo.none, Lean.Syntax]]
[instXorUInt8,[Xor.mk, UInt8, UInt8.xor],[Xor, UInt8]]
[Lean.nullKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Option.toBool,[Option, Bool, Bool.true, Unit, Bool.false],[Option, Bool]]
[true_or,[propext, Or, True, Iff.intro, trivial, Or.inl],[Eq, Or, True]]
[instTransEq_1,[Trans.mk, Eq, instTransEq_1.proof_1],[Trans, Eq]]
[ForInStep.yield.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, ForInStep, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, ForInStep.yield]]
[Lean.Name.modifyBase,[Lean.Name, ite, Eq, Bool, Lean.Name.hasMacroScopes, Bool.true, instDecidableEqBool, Lean.MacroScopesView, Lean.extractMacroScopes, Lean.MacroScopesView.review, Lean.MacroScopesView.mk, Lean.MacroScopesView.name, Lean.MacroScopesView.imported, Lean.MacroScopesView.mainModule, Lean.MacroScopesView.scopes],[Lean.Name]]
[IO.Error.mkEofError,[Unit, IO.Error.unexpectedEof],[Unit, IO.Error]]
[Array.data,[Array],[Array, List]]
[instToStringId_1,[ToString, inferInstanceAs],[ToString, Id]]
[ST.Ref.ptrEq,[MonadLiftT, ST, ST.Ref, liftM, Bool, ST.Prim.Ref.ptrEq],[MonadLiftT, ST, ST.Ref, Bool]]
[String.find,[String, Char, Bool, String.findAux, String.bsize, OfNat.ofNat, String.Pos, instOfNatNat],[String, Char, Bool, String.Pos]]
[Array.insertionSort.swapLoop.proof_2,[Nat, Array, LT.lt, instLTNat, Array.size, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Eq.mpr, Array.swap, Fin.mk, Nat.lt_trans, Nat.succ, Nat.lt_succ_self, Eq.symm, Eq.refl, Array.size_swap],[Nat, Array, LT.lt, instLTNat, Array.size, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.swap, Fin.mk, Nat.lt_trans, Nat.succ, Nat.lt_succ_self, Eq.symm]]
[Lean.expandExplicitBindersAux,[Lean.Syntax, Array, Option, Nat, Lean.MacroM, Array.size, Lean.expandExplicitBindersAux.loop],[Lean.Syntax, Array, Option, Lean.MacroM]]
[id_map',[Functor, LawfulFunctor, LawfulFunctor.id_map],[Functor, LawfulFunctor, Eq, Functor.map]]
[Lean.Parser.Tactic.refine',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Meta.Rewrite.Config.mk.inj,[Lean.Meta.TransparencyMode, Bool, Eq, Lean.Meta.Rewrite.Config, Lean.Meta.Rewrite.Config.mk, And, And.intro],[Lean.Meta.TransparencyMode, Bool, Eq, Lean.Meta.Rewrite.Config, Lean.Meta.Rewrite.Config.mk, And]]
[ExceptT.run_map,[Monad, LawfulMonad, ExceptT, Eq.mpr, Eq, Except, ExceptT.run, Functor.map, Applicative.toFunctor, Monad.toApplicative, ExceptT.instMonadExceptT, Except.map, ExceptT.mk, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Except.ok, Except.error, congrArg, map_eq_pure_bind, bind_congr, of_eq_true, eq_self, Eq.symm, Eq.refl],[Monad, LawfulMonad, ExceptT, Eq, Except, ExceptT.run, Functor.map, Applicative.toFunctor, Monad.toApplicative, ExceptT.instMonadExceptT, Except.map]]
[Array.insertAt,[Array, Nat, ite, GT.gt, instLTNat, Array.size, Nat.decLt, panicWithPosWithDecl, Array.instInhabitedArray, OfNat.ofNat, instOfNatNat, Array.push, Array.insertAtAux],[Array, Nat]]
[Lean.MonadRef.noConfusionType,[Lean.MonadRef, Lean.Syntax, Eq],[Lean.MonadRef]]
[instOrdUInt8,[Ord.mk, UInt8, compareOfLessAndEq, instLTUInt8, instDecidableLt_1, instDecidableEqUInt8],[Ord, UInt8]]
[Array.foldrM.fold.proof_2,[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.succ, Nat.lt_succ_self],[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size]]
[Nat.toDigits,[Nat, Nat.toDigitsCore, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, List.nil, Char],[Nat, List, Char]]
[UInt8.decEq.proof_1,[Fin, UInt8.size, Eq, UInt8, UInt8.mk, rfl],[Fin, UInt8.size, Eq, UInt8, UInt8.mk]]
[WellFounded.fixFEq.proof_1,[Acc, Eq, WellFounded.fixF, Acc.inv, rfl, Acc.intro],[Acc, Eq, WellFounded.fixF, Acc.inv]]
[Std.instInhabitedFormat,[Inhabited.mk, Std.Format, Std.Format.nil],[Inhabited, Std.Format]]
[instDecidableEqPUnit,[PUnit, Decidable.isTrue, Eq, PUnit.subsingleton],[DecidableEq, PUnit]]
[ShiftLeft.noConfusionType,[ShiftLeft, Eq],[ShiftLeft]]
[UInt8.ofNatCore,[LT.lt, Nat, instLTNat, UInt8.size, UInt8.mk, Fin.mk],[LT.lt, Nat, instLTNat, UInt8.size, UInt8]]
[List.length_concat,[List, Eq, Nat, List.length, List.concat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, rfl, List.nil, of_eq_true, List.cons, Eq.trans, Nat.succ, True, congr, congrArg, List.length_cons, congrFun, eq_self],[List, Eq, Nat, List.length, List.concat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
[System.Platform.isOSX,[System.Platform.getIsOSX, Unit.unit],[Bool]]
[Lean.Name.toStringWithSep,[String, Bool, Lean.Name, Lean.Name.below, Unit, Lean.Name.anonymous, UInt64, Lean.Name.str, Lean.Name.toStringWithSep.maybeEscape, Nat, Lean.Name.num, ToString.toString, instToStringNat, HAppend.hAppend, instHAppend, String.instAppendString, PProd.fst, PUnit, PProd, Nat.repr],[String, Bool, Lean.Name]]
[EStateM.bind,[EStateM, EStateM.Result, EStateM.Result.error],[EStateM]]
[Lean.Parser.Tactic.injection,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[USize.land,[USize, USize.mk, Fin.land, USize.size, USize.val],[USize]]
[Lean.Parser.Tactic.done,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Parser.Tactic.tacticErw__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[IO.Process.SpawnArgs.toStdioConfig,[IO.Process.SpawnArgs],[IO.Process.SpawnArgs, IO.Process.StdioConfig]]
[Array.ofSubarray,[Subarray, Array, Array.mkEmpty, HSub.hSub, Nat, instHSub, instSubNat, Subarray.stop, Subarray.start, Bind.bind, Id, Monad.toBind, Id.instMonadId, ForIn.forIn, Subarray.instForInSubarray, Array.push, PUnit, ForInStep, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, ForInStep.yield],[Subarray, Array]]
[instToStringFloatArray,[ToString.mk, FloatArray, List.toString, Float, instToStringFloat, FloatArray.toList],[ToString, FloatArray]]
[«term~~~_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Array.findIdx?.loop,[Array, Bool, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Array.size, Option, Nat.below, dite, LT.lt, instLTNat, Nat.decLt, OfNat.ofNat, instOfNatNat, False.elim, Array.findIdx?.loop.proof_1, Nat.succ, ite, Array.get, Fin.mk, Bool.true, instDecidableEqBool, Option.some, Not, Option.none],[Array, Bool, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Array.size, Option]]
[Option.eq_none_of_isNone,[Option, Eq, Bool, Option.isNone, Bool.true, Option.none, rfl],[Option, Eq, Bool, Option.isNone, Bool.true, Option.none]]
[Sum.inr.inj,[Eq, Sum, Sum.inr],[Eq, Sum, Sum.inr]]
[PSigma.snd,[PSigma],[PSigma, PSigma.fst]]
[Nat.mod,[WellFounded.fix, Nat, WellFoundedRelation.rel, measure, id, Nat.mod.proof_1, LT.lt, instLTNat, dite, And, OfNat.ofNat, instOfNatNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HSub.hSub, instHSub, instSubNat, And.intro, Nat.sub_lt, Nat.lt_of_lt_of_le, Not],[Nat]]
[StateRefT'.lift,[ST.Ref],[StateRefT']]
[IO.FS.Mode.toCtorIdx,[IO.FS.Mode, Nat, OfNat.ofNat, instOfNatNat],[IO.FS.Mode, Nat]]
[Array.pop,[Array, Array.mk, List.dropLast, Array.data],[Array]]
[«term¬_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Nat.add_left_comm,[Nat, Eq.mpr, Eq, HAdd.hAdd, instHAdd, instAddNat, Eq.refl, Eq.symm, Nat.add_assoc, Nat.add_comm, rfl],[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat]]
[Lean.SourceInfo.getPos?,[Lean.SourceInfo, optParam, Bool, Bool.false, Option, String.Pos, Substring, Option.some, Option.none],[Lean.SourceInfo, optParam, Bool, Bool.false, Option, String.Pos]]
[CoeDep.noConfusionType,[CoeDep, Eq],[CoeDep]]
[Lean.Meta.Simp.ConfigCtx.noConfusionType,[Lean.Meta.Simp.ConfigCtx, Lean.Meta.Simp.Config, Eq],[Lean.Meta.Simp.ConfigCtx]]
[Std.Format.instInhabitedSpaceResult,[Inhabited.mk, arbitrary, Bool, instInhabitedBool, Nat, instInhabitedNat],[Inhabited]]
[Fin.instInhabitedFinHAdd,[Nat, Inhabited.mk, Fin, OfNat.ofNat, Fin.instOfNatFinHAdd],[Nat, Inhabited, Fin]]
[Lean.Syntax.node.sizeOf_spec,[Lean.SyntaxNodeKind, Array, Lean.Syntax, congrArg, Nat, List, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, SizeOf.sizeOf, instSizeOfName, Lean.SourceInfo, String, instSizeOf, SizeOf.mk, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, Substring, Lean.Name, Prod, String.Pos, Nat.add, Eq, Eq.trans, Array.mk, Eq.refl, List.nil, List.cons, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec],[Lean.SyntaxNodeKind, Array, Lean.Syntax, Eq, Nat, SizeOf.sizeOf, SizeOf.mk, List, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, instSizeOfName, Lean.SourceInfo, String, instSizeOf, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, Substring, Lean.Name, Prod, String.Pos, Lean.Syntax.node]]
[Lean.Parser.Tactic.tacticAdmit,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[type_eq_of_heq.proof_1,[HEq, HEq.ndrecOn, Eq, Eq.refl],[HEq, Eq]]
[Prod.anyI,[Nat, Bool, Prod, Nat.anyAux, Prod.snd, HSub.hSub, instHSub, instSubNat, Prod.fst],[Nat, Bool, Prod]]
[Lean.Parser.Tactic.clear,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Macro,[Lean.Syntax, Lean.MacroM],[]]
[UInt32.add,[UInt32, UInt32.mk, HAdd.hAdd, Fin, UInt32.size, instHAdd, Fin.instAddFin, UInt32.val],[UInt32]]
[Nat.mod_lt,[Nat, Nat.mod.inductionOn, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, LT.lt, HMod.hMod, instHMod, Nat.instModNat, And, LE.le, instLENat, HSub.hSub, instHSub, instSubNat, Not],[Nat, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, LT.lt, HMod.hMod, instHMod, Nat.instModNat]]
[HasEquiv.Equiv,[HasEquiv],[HasEquiv]]
[Repr.reprPrec,[Repr],[Repr, Nat, Std.Format]]
[StateT.orElse,[Alternative, StateT, Unit, HOrElse.hOrElse, Prod, instHOrElse, instOrElse, Unit.unit],[Alternative, StateT, Unit]]
[Lean.Parser.Tactic.Conv.convApply_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Except.error.inj,[Eq, Except, Except.error],[Eq, Except, Except.error]]
[Lean.instQuoteBool,[Lean.Quote.mk, Bool, Lean.Syntax, Unit, Lean.mkCIdent, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Quote, Bool]]
[Std.Range.«term[_:_:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Char.noConfusionType,[Char, UInt32, UInt32.isValidChar, Eq],[Char]]
[Int.instAddInt,[Add.mk, Int, Int.add],[Add, Int]]
[Array.forRevM,[Monad, PUnit, Array, optParam, Nat, Array.size, OfNat.ofNat, instOfNatNat, Array.foldrM, PUnit.unit],[Monad, PUnit, Array, optParam, Nat, Array.size, OfNat.ofNat, instOfNatNat]]
[Classical.typeDecidableEq,[inferInstance, Decidable, Eq, Classical.propDecidable],[DecidableEq]]
[instForIn,[outParam, Stream, ForIn.mk, Monad, Stream.forIn],[outParam, Stream, ForIn]]
[Nat.lt_succ_of_le,[Nat, Nat.succ_le_succ],[Nat, LE.le, instLENat, LT.lt, instLTNat, Nat.succ]]
[instReprAtomUInt32,[ReprAtom.mk, UInt32],[ReprAtom, UInt32]]
[Complement.noConfusionType,[Complement, Eq],[Complement]]
[IO.Error.protocolError.sizeOf_spec,[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar],[UInt32, String, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, Option, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.protocolError]]
[IO.mapTasks,[List, IO, Task, optParam, Task.Priority, Task.Priority.default, Except, IO.Error, List.nil, IO.mapTasks.go],[List, IO, Task, optParam, Task.Priority, Task.Priority.default, Except, IO.Error]]
[IO.Error.alreadyExists.injEq,[Option, String, UInt32, Eq.propIntro, Eq, IO.Error, IO.Error.alreadyExists, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Option, String, UInt32, Eq, IO.Error, IO.Error.alreadyExists, And]]
[instOfNatUInt32,[Nat, OfNat.mk, UInt32, UInt32.ofNat],[Nat, OfNat, UInt32]]
[instDecidableArrow.proof_3,[Not, absurd],[Not]]
[UInt32.toNat,[UInt32, Fin.val, UInt32.size, UInt32.val],[UInt32, Nat]]
[Eq.propIntro,[propext, Iff.intro],[Eq]]
[LawfulApplicative.noConfusionType,[Applicative, LawfulApplicative, LawfulFunctor, Applicative.toFunctor, Eq, SeqLeft.seqLeft, Applicative.toSeqLeft, Unit, Seq.seq, Applicative.toSeq, Functor.map, Function.const, SeqRight.seqRight, Applicative.toSeqRight, id, Pure.pure, Applicative.toPure, Function.comp],[Applicative, LawfulApplicative]]
[Quotient.exact,[Setoid, Eq, Quotient, Quotient.mk, Quotient.liftOn₂, HasEquiv.Equiv, instHasEquiv, propext, Iff.intro, Setoid.trans, Setoid.symm, Quot.inductionOn, Setoid.r, Quot, Setoid.refl],[Setoid, Eq, Quotient, Quotient.mk, HasEquiv.Equiv, instHasEquiv]]
[Array.swap.proof_1,[Array, Eq.symm, Nat, Array.size, Array.set, Array.get, Array.size_set],[Array, Eq, Nat, Array.size, Array.set, Array.get]]
[«term_>=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Char.instDecidableLe,[Char, UInt32.decLe, Char.val],[Char, Decidable, LE.le, Char.instLEChar]]
[ByteArray.findIdx?,[ByteArray, UInt8, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, Option, ByteArray.findIdx?.loop],[ByteArray, UInt8, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, Option]]
[Lean.Name.hasMacroScopes,[Lean.Name, Bool, Lean.Name.below, String, UInt64, Lean.Name.str, BEq.beq, instBEq, instDecidableEqString, Nat, Lean.Name.num, PProd.fst, PUnit, PProd, Bool.false],[Lean.Name, Bool]]
[Array.instCoeSubarrayArray,[Coe.mk, Subarray, Array, Array.ofSubarray],[Coe, Subarray, Array]]
[instMonadLiftT,[MonadLift, MonadLiftT, MonadLiftT.mk, MonadLift.monadLift, MonadLiftT.monadLift],[MonadLift, MonadLiftT]]
[Std.Format.tag.inj,[Nat, Std.Format, Eq, Std.Format.tag, And, And.intro],[Nat, Std.Format, Eq, Std.Format.tag, And]]
[Nat.gcd.proof_1,[WellFoundedRelation.wf, Nat, measure, id],[WellFounded, Nat, WellFoundedRelation.rel, measure, id]]
[Applicative.toPure,[Applicative],[Applicative, Pure]]
[strictOr,[Bool, or],[Bool]]
[IO.FS.writeFile,[System.FilePath, String, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle, Unit, IO.FS.Handle.mk, IO.FS.Mode.write, Bool.false, IO.FS.Handle.putStr],[System.FilePath, String, IO, Unit]]
[Nat.lt_or_ge,[Nat, Or, LT.lt, instLTNat, GE.ge, instLENat, Nat.below, Unit, Nat.zero, Or.inr, Nat.zero_le, Nat.succ, PProd.fst, PUnit, PProd, Or.inl, Nat.le_succ_of_le, Eq, Nat.eq_or_lt_of_le, Nat.le_refl],[Nat, Or, LT.lt, instLTNat, GE.ge, instLENat]]
[IO.FS.SystemTime.mk.injEq,[Int, UInt32, Eq.propIntro, Eq, IO.FS.SystemTime, IO.FS.SystemTime.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Int, UInt32, Eq, IO.FS.SystemTime, IO.FS.SystemTime.mk, And]]
[Lean.Parser.Tactic.Conv.conv.quot,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[String.Iterator.mk.inj,[String, String.Pos, Eq, String.Iterator, String.Iterator.mk, And, And.intro],[String, String.Pos, Eq, String.Iterator, String.Iterator.mk, And]]
[instLEUInt8,[LE.mk, UInt8, UInt8.le],[LE, UInt8]]
[Id,[],[]]
[IO.Error.invalidArgument.inj,[Option, String, UInt32, Eq, IO.Error, IO.Error.invalidArgument, And, And.intro],[Option, String, UInt32, Eq, IO.Error, IO.Error.invalidArgument, And]]
[Add.noConfusionType,[Add, Eq],[Add]]
[ne_false_of_eq_true,[Bool, Eq, Bool.true, Not, Bool.false, False],[Bool, Eq, Bool.true, Not, Bool.false]]
[toBoolUsing,[Decidable, Decidable.decide],[Decidable, Bool]]
[Xor.xor,[Xor],[Xor]]
[Std.Format.noConfusionType,[Std.Format, String, Int, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone, Nat, Eq],[Std.Format]]
[Lean.Name.below,[Lean.Name, PUnit, String, UInt64, PProd, Nat],[Lean.Name]]
[Substring.hasBeq,[BEq.mk, Substring, Substring.beq],[BEq, Substring]]
[Array.appendList,[Array, List, List.foldl, Array.push],[Array, List]]
[System.FilePath.isRelative,[System.FilePath, not, System.FilePath.isAbsolute],[System.FilePath, Bool]]
[Char.toUpper,[Char, Nat, Char.toNat, ite, And, GE.ge, instLENat, OfNat.ofNat, instOfNatNat, LE.le, instDecidableAnd, Nat.decLe, Char.ofNat, HSub.hSub, instHSub, instSubNat],[Char]]
[IO.print,[ToString, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Stream, Unit, IO.getStdout, IO.FS.Stream.putStr, ToString.toString],[ToString, IO, Unit]]
[Prod.ext,[Prod, Eq, Prod.mk, Prod.fst, Prod.snd, rfl, Eq.symm, Eq.refl],[Prod, Eq, Prod.mk, Prod.fst, Prod.snd]]
[instDecidableEqSum.proof_4,[Not, Eq, Sum, Sum.inr, False, absurd],[Not, Eq, Sum, Sum.inr, False]]
[List.toFloatArray.loop,[List, Float, FloatArray, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd, FloatArray.push],[List, Float, FloatArray]]
[String.decEq,[Decidable, Eq, String, List, Char, dite, String.mk, instDecidableEqList, instDecidableEqChar, Decidable.isTrue, String.decEq.proof_1, Not, Decidable.isFalse, String.decEq.proof_2],[Decidable, Eq, String]]
[IO.FS.Mode.read.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, IO.FS.Mode, SizeOf.mk, OfNat.ofNat, instOfNatNat, IO.FS.Mode.read]]
[id.def,[rfl, id],[Eq, id]]
[System.FilePath.mk.injEq,[String, Eq.propIntro, Eq, System.FilePath, System.FilePath.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[String, Eq, System.FilePath, System.FilePath.mk]]
[StateT.ext,[StateT, Eq, Prod, StateT.run, funext],[StateT, Eq, Prod, StateT.run]]
[Char.ofNat,[Nat, dite, Char, Nat.isValidChar, instDecidableOr, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, And, Nat.decLt, instDecidableAnd, Char.mk, UInt32.mk, Fin.mk, UInt32.size, Or.inl, Or.inr, And.intro, Nat.lt_trans, of_decide_eq_true, Eq.refl, Bool, Bool.true, Not, Char.ofNat.proof_1, Char.ofNat.proof_2],[Nat, Char]]
[Subarray.anyM,[Monad, Bool, Subarray, Array.anyM, Subarray.as, Subarray.start, Subarray.stop],[Monad, Bool, Subarray]]
[instDecidableLt_2,[UInt16, UInt16.decLt],[UInt16, Decidable, LT.lt, instLTUInt16]]
[Prod.mk.inj,[Eq, Prod, Prod.mk, And, And.intro],[Eq, Prod, Prod.mk, And]]
[Array.qsort,[Inhabited, Array, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Array.size, Array.qsort.sort],[Inhabited, Array, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Array.size]]
[subtypeCoe,[CoeHead.mk, Subtype, Subtype.val],[CoeHead, Subtype]]
[pure_id_seq,[Applicative, LawfulApplicative, of_eq_true, Eq, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, id, Unit, Eq.trans, True, congrFun, congrArg, Functor.map, Applicative.toFunctor, LawfulApplicative.pure_seq, LawfulFunctor.id_map, LawfulApplicative.toLawfulFunctor, eq_self],[Applicative, LawfulApplicative, Eq, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, id, Unit]]
[Char.ofNat.proof_2,[Or.inl, LT.lt, Nat, instLTNat, UInt32.toNat, UInt32.mk, Fin.mk, UInt32.size, OfNat.ofNat, instOfNatNat, of_decide_eq_true, Nat.decLt, Eq.refl, Bool, Bool.true, And],[Or, LT.lt, Nat, instLTNat, UInt32.toNat, UInt32.mk, Fin.mk, UInt32.size, OfNat.ofNat, instOfNatNat, of_decide_eq_true, Nat.decLt, Eq.refl, Bool, Bool.true, And]]
[Subsingleton.helim.proof_1,[Subsingleton, Eq, HEq, heq_of_eq, Subsingleton.elim],[Subsingleton, Eq, HEq]]
[withPtrEqDecEq.proof_3,[Unit, Decidable, Eq, Bool, withPtrEq, toBoolUsing, Unit.unit, withPtrEqDecEq.proof_1, Bool.false, ofBoolUsing_eq_false],[Unit, Decidable, Eq, Bool, withPtrEq, toBoolUsing, Unit.unit, withPtrEqDecEq.proof_1, Bool.false, Not]]
[«term_<|>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Parser.Tactic.rwRuleSeq,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.rwRule, Bool.true],[Lean.ParserDescr]]
[instHAnd,[AndOp, HAnd.mk, AndOp.and],[AndOp, HAnd]]
[Lean.MacroScope,[Nat],[]]
[Lean.Parser.Tactic.discharger,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Div.div,[Div],[Div]]
[Std.Format.text.sizeOf_spec,[String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[String, Eq, Nat, SizeOf.sizeOf, Std.Format, SizeOf.mk, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, Int, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone, Std.Format.text]]
[Nat.below,[Nat, PUnit, PProd],[Nat]]
[String.get,[String, String.Pos, Char, List, List.below, List.nil, List.cons, arbitrary, Char.instInhabitedChar, ite, Eq, instDecidableEqNat, PProd.fst, PUnit, PProd, HAdd.hAdd, Nat, instHAdd, instAddNat, String.csize, OfNat.ofNat, instOfNatNat],[Char]]
[map_eq_pure_bind,[Monad, LawfulMonad, Eq.mpr, Eq, Functor.map, Applicative.toFunctor, Monad.toApplicative, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Function.comp, Eq.refl, Eq.symm, LawfulMonad.bind_pure_comp, rfl],[Monad, LawfulMonad, Eq, Functor.map, Applicative.toFunctor, Monad.toApplicative, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure]]
[Lean.Parser.Tactic.first,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Classical.«tacticByCases__:_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[List.foldl,[List, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd],[List]]
[«stx_,+»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[ReaderT.run_bind,[Monad, ReaderT, rfl, ReaderT.run, Bind.bind, Monad.toBind, ReaderT.instMonadReaderT],[Monad, ReaderT, Eq, ReaderT.run, Bind.bind, Monad.toBind, ReaderT.instMonadReaderT]]
[instModUInt16,[Mod.mk, UInt16, UInt16.mod],[Mod, UInt16]]
[Lean.Meta.instReprTransparencyMode,[Repr.mk, Lean.Meta.TransparencyMode, Nat, Unit, Lean.Meta.TransparencyMode.all, Lean.Meta.TransparencyMode.default, Lean.Meta.TransparencyMode.reducible, Lean.Meta.TransparencyMode.instances, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, Int, GE.ge, instLENat, OfNat.ofNat, instOfNatNat, Nat.decLe, Int.instOfNatInt, Std.Format.text, Std.Format.FlattenBehavior.allOrNone],[Repr, Lean.Meta.TransparencyMode]]
[Char.utf8Size.proof_4,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size]]
[Nat.add_lt_add,[Nat, LT.lt, instLTNat, Nat.lt_trans, HAdd.hAdd, instHAdd, instAddNat, Nat.add_lt_add_right, Nat.add_lt_add_left],[Nat, LT.lt, instLTNat, HAdd.hAdd, instHAdd, instAddNat]]
[instInhabitedUInt32.proof_1,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size]]
[Lean.Parser.Tactic.expandRwSeq,[Lean.Parser.Tactic.rwWithRfl, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.Macro]]
[«term_^_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Float.ofInt,[Int, Float, Nat, Float.ofNat, Float.neg, Nat.succ],[Int, Float]]
[UInt8.le,[UInt8, LE.le, Fin, UInt8.size, instLEFin, UInt8.val],[UInt8]]
[forall_congr,[Eq],[Eq]]
[Repr.noConfusionType,[Repr, Nat, Std.Format, Eq],[Repr]]
[List.reverseAux_reverseAux,[List, Eq, List.reverseAux, List.nil, rfl, of_eq_true, List.cons, Eq.trans, True, congr, congrArg, eq_self],[List, Eq, List.reverseAux, List.nil]]
[panicWithPosWithDecl,[Inhabited, String, Nat, panic, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString, instToStringNat],[Inhabited, String, Nat]]
[unsafeCast,[cast, unsafeCast.proof_1, PUnit],[]]
[ST.Ref.mk.injEq,[PointedType.type, ST.RefPointed, Nonempty, Eq.propIntro, Eq, ST.Ref, ST.Ref.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[PointedType.type, ST.RefPointed, Nonempty, Eq, ST.Ref, ST.Ref.mk]]
[PSigma.skipLeft,[WellFoundedRelation, WellFoundedRelation.mk, PSigma, PSigma.SkipLeft, WellFoundedRelation.rel, PSigma.skipLeft.proof_1],[WellFoundedRelation, PSigma]]
[ExceptCpsT.runCatch_bind_lift,[Monad, ExceptCpsT, rfl, ExceptCpsT.runCatch, Bind.bind, Monad.toBind, ExceptCpsT.instMonadExceptCpsT, ExceptCpsT.lift],[Monad, ExceptCpsT, Eq, ExceptCpsT.runCatch, Bind.bind, Monad.toBind, ExceptCpsT.instMonadExceptCpsT, ExceptCpsT.lift]]
[Nat.mod_eq_of_lt,[Nat, LT.lt, instLTNat],[Nat, LT.lt, instLTNat, Eq, HMod.hMod, instHMod, Nat.instModNat]]
[FloatArray.data,[FloatArray],[FloatArray, Array, Float]]
[usize_size_gt_zero,[Nat.pos_pow_of_pos, OfNat.ofNat, Nat, instOfNatNat, System.Platform.numBits, Nat.zero_lt_succ],[GT.gt, Nat, instLTNat, USize.size, OfNat.ofNat, instOfNatNat]]
[StateCpsT.run',[Monad, StateCpsT, StateCpsT.runK, Pure.pure, Applicative.toPure, Monad.toApplicative],[Monad, StateCpsT]]
[LawfulApplicative.map_pure,[Applicative, LawfulApplicative],[Applicative, LawfulApplicative, Eq, Functor.map, Applicative.toFunctor, Pure.pure, Applicative.toPure]]
[ReaderT.adapt,[Monad, ReaderT],[Monad, ReaderT]]
[IO.Error.protocolError.inj,[UInt32, String, Eq, IO.Error, IO.Error.protocolError, And, And.intro],[UInt32, String, Eq, IO.Error, IO.Error.protocolError, And]]
[UInt32.complement,[UInt32, HSub.hSub, instHSub, instSubUInt32, OfNat.ofNat, instOfNatUInt32, HAdd.hAdd, instHAdd, instAddUInt32],[UInt32]]
[Subtype.eta,[Subtype, Subtype.val, Eq, Subtype.mk, rfl, Eq.symm, Eq.refl],[Subtype, Subtype.val, Eq, Subtype.mk]]
[IO.Error.invalidArgument.injEq,[Option, String, UInt32, Eq.propIntro, Eq, IO.Error, IO.Error.invalidArgument, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Option, String, UInt32, Eq, IO.Error, IO.Error.invalidArgument, And]]
[Fin.mk.sizeOf_spec,[Nat, LT.lt, instLTNat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat, instSizeOf],[Nat, LT.lt, instLTNat, Eq, SizeOf.sizeOf, Fin, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, instSizeOfNat, instSizeOf, Fin.mk]]
[UInt16.toNat,[UInt16, Fin.val, UInt16.size, UInt16.val],[UInt16, Nat]]
[Array.insertionSort.swapLoop.proof_1,[Nat, Array, LT.lt, instLTNat, Array.size, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Nat.lt_trans, Nat.succ, Nat.lt_succ_self, Eq.symm],[Nat, Array, LT.lt, instLTNat, Array.size, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
[emptyWf,[WellFoundedRelation.mk, emptyRelation, emptyWf.proof_1],[WellFoundedRelation]]
[Lean.Parser.Tactic.locationWildcard,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[List.replicate.loop,[Nat, List, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, List.cons],[Nat, List]]
[namedPattern,[],[]]
[Nat.toUInt32,[UInt32.ofNat],[UInt32]]
[List.getLast!.proof_1,[List, Eq, List.cons, List.nil, False],[List, Eq, List.cons, List.nil, List.noConfusionType, False]]
[Lean.evalOptPrio,[Option, Lean.Syntax, Lean.MacroM, Nat, Lean.evalPrio, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, OfNat.ofNat, instOfNatNat],[Option, Lean.Syntax, Lean.MacroM, Nat]]
[Nat.succ_sub_succ_eq_sub,[Nat, Eq, HSub.hSub, instHSub, instSubNat, Nat.succ, rfl, Nat.zero, congrArg, Nat.pred],[Nat, Eq, HSub.hSub, instHSub, instSubNat, Nat.succ]]
[instToStringBool,[ToString.mk, Bool, cond, String],[ToString, Bool]]
[ReaderT.run,[ReaderT],[ReaderT]]
[UInt64.decLt,[UInt64, Decidable, LT.lt, instLTUInt64, Fin, UInt64.size, inferInstanceAs, instLTFin, Fin.decLt],[UInt64, Decidable, LT.lt, instLTUInt64]]
[String.quote,[String, ite, Eq, Bool, String.isEmpty, Bool.true, instDecidableEqBool, HAppend.hAppend, instHAppend, String.instAppendString, String.foldl, Char, Char.quoteCore],[String]]
[IO.FS.Mode.readWrite.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, IO.FS.Mode, SizeOf.mk, OfNat.ofNat, instOfNatNat, IO.FS.Mode.readWrite]]
[MonadStateOf.modifyGet,[MonadStateOf],[MonadStateOf, Prod]]
[UInt8.noConfusionType,[UInt8, Fin, UInt8.size, Eq],[UInt8]]
[Lean.Parser.Syntax.addPrio,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Fin.ofNat.proof_1,[Nat, Nat.mod_lt, Nat.succ, Nat.zero_lt_succ],[Nat, LT.lt, instLTNat, HMod.hMod, instHMod, Nat.instModNat, Nat.succ]]
[Nat.ibelow,[Nat, True, And],[Nat]]
[Lean.MonadRef.getRef,[Lean.MonadRef],[Lean.MonadRef, Lean.Syntax]]
[CoeT.noConfusionType,[CoeT, Eq],[CoeT]]
[IO.AccessRight.mk.sizeOf_spec,[Bool, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk],[Bool, Eq, Nat, SizeOf.sizeOf, IO.AccessRight, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, IO.AccessRight.mk]]
[outParam,[],[]]
[Classical.choose_spec,[Exists, Subtype.property, Classical.indefiniteDescription],[Exists, Classical.choose]]
[Lean.«command_Unif_hint___Where_|-⊢_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.unifConstraintElem, Lean.unifConstraint],[Lean.ParserDescr]]
[instToStringUInt32,[ToString.mk, UInt32, ToString.toString, Nat, instToStringNat, UInt32.toNat],[ToString, UInt32]]
[Fin.val,[Nat, Fin],[Nat, Fin]]
[Quotient.recOn,[Setoid, Quotient, Quotient.mk, HasEquiv.Equiv, instHasEquiv, Eq, Quotient.sound, Quot.recOn, Setoid.r],[Setoid, Quotient, Quotient.mk, HasEquiv.Equiv, instHasEquiv, Eq, Quotient.sound]]
[UInt64.noConfusionType,[UInt64, Fin, UInt64.size, Eq],[UInt64]]
[Nat.succ_lt_succ,[Nat, Nat.succ_le_succ, Nat.succ],[Nat, LT.lt, instLTNat, Nat.succ]]
[measure,[Nat, invImage, Nat.lt_wfRel],[Nat, WellFoundedRelation]]
[Lean.Meta.Rewrite.Config.noConfusionType,[Lean.Meta.Rewrite.Config, Lean.Meta.TransparencyMode, Bool, Eq],[Lean.Meta.Rewrite.Config]]
[Array.binInsertM,[Monad, Inhabited, Bool, Unit, Array, ite, Eq, Array.isEmpty, Bool.true, instDecidableEqBool, Bind.bind, Monad.toBind, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.push, Array.get!, OfNat.ofNat, Nat, instOfNatNat, Array.insertAt, not, Array.modifyM, Array.back, HSub.hSub, instHSub, instSubNat, Array.size],[Monad, Inhabited, Bool, Unit, Array]]
[Lean.Syntax.expandInterpolatedStr,[Lean.Syntax, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Syntax.expandInterpolatedStrChunks, Lean.Syntax.getArgs, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.Macro.instMonadRefMacroM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Macro.instMonadQuotationMacroM, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.Syntax, Lean.MacroM]]
[ST.Prim.Ref.modifyUnsafe,[ST.Ref, Bind.bind, ST, Monad.toBind, instMonadST, Unit, ST.Prim.Ref.take, ST.Prim.Ref.set],[ST.Ref, ST, Unit]]
[MonadFinally.tryFinally',[MonadFinally],[MonadFinally, Option, Prod]]
[instLawfulMonadStateRefT',[instLawfulMonadStateRefT'.proof_1],[Monad, LawfulMonad, StateRefT', StateRefT'.instMonadStateRefT']]
[Option.format,[Std.ToFormat, Option, Std.Format, Unit, Std.Format.text, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.ToFormat.format],[Std.ToFormat, Option, Std.Format]]
[MonadLiftT.monadLift,[MonadLiftT],[MonadLiftT]]
[Lean.Quote.quote,[Lean.Quote],[Lean.Quote, Lean.Syntax]]
[instCoeTail,[CoeFun, CoeTail.mk, coeFun],[CoeFun, CoeTail]]
[ReaderT.run_map,[Monad, ReaderT, rfl, ReaderT.run, Functor.map, Applicative.toFunctor, Monad.toApplicative, ReaderT.instMonadReaderT],[Monad, ReaderT, Eq, ReaderT.run, Functor.map, Applicative.toFunctor, Monad.toApplicative, ReaderT.instMonadReaderT]]
[Char.toLower,[Char, Nat, Char.toNat, ite, And, GE.ge, instLENat, OfNat.ofNat, instOfNatNat, LE.le, instDecidableAnd, Nat.decLe, Char.ofNat, HAdd.hAdd, instHAdd, instAddNat],[Char]]
[instStreamSubarray,[Stream.mk, Subarray, dite, Option, Prod, LT.lt, Nat, instLTNat, Subarray.start, Subarray.stop, Nat.decLt, Not, Option.none],[Stream, Subarray]]
[Sum.inl.inj,[Eq, Sum, Sum.inl],[Eq, Sum, Sum.inl]]
[instDecidableEqSum.proof_6,[Eq, Sum, Sum.inl, Sum.inr, False],[Eq, Sum, Sum.inl, Sum.inr, Sum.noConfusionType, False]]
[StateCpsT.instMonadStateCpsT,[Monad.mk, StateCpsT, Applicative.mk, Functor.mk, Pure.mk, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk],[Monad, StateCpsT]]
[Lean.Parser.Tactic.Conv.rhs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[IO.FS.writeBinFile,[System.FilePath, ByteArray, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle, Unit, IO.FS.Handle.mk, IO.FS.Mode.write, Bool.true, IO.FS.Handle.write],[System.FilePath, ByteArray, IO, Unit]]
[Except.tryCatch,[Except, Except.ok],[Except]]
[List.all,[List, Bool, List.foldr, and, Bool.true],[List, Bool]]
[ExceptCpsT.runCatch_lift,[Monad, LawfulMonad, of_eq_true, Eq, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Eq.trans, True, congrFun, congrArg, bind_pure, eq_self],[Monad, LawfulMonad, Eq, ExceptCpsT.runCatch, ExceptCpsT.lift]]
[Except.bind,[Except, Except.error],[Except]]
[Nat.div.inductionOn,[Nat, And, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, HSub.hSub, instHSub, instSubNat, Not, WellFounded.fix, WellFoundedRelation.rel, measure, id, WellFoundedRelation.wf, dite, instDecidableAnd, Nat.decLt, Nat.decLe, And.intro, Nat.sub_lt, Nat.lt_of_lt_of_le],[Nat, And, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, HSub.hSub, instHSub, instSubNat, Not]]
[ExceptT.bind_throw,[Monad, LawfulMonad, ExceptT, of_eq_true, Eq, Bind.bind, Monad.toBind, Except, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.error, Eq.trans, True, congrFun, congrArg, LawfulMonad.pure_bind, eq_self],[Monad, LawfulMonad, ExceptT, Eq, Bind.bind, Monad.toBind, ExceptT.instMonadExceptT, MonadExcept.throw, instMonadExcept, instMonadExceptOfExceptT_1]]
[Pure.noConfusionType,[Pure, Eq],[Pure]]
[Lean.Parser.Tactic.revert,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[StateT.seqLeft_eq,[Monad, LawfulMonad, StateT, StateT.ext, SeqLeft.seqLeft, Applicative.toSeqLeft, Monad.toApplicative, StateT.instMonadStateT, Unit, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const, of_eq_true, Eq, Prod, StateT.run, Eq.trans, Bind.bind, Monad.toBind, Prod.snd, Pure.pure, Applicative.toPure, Prod.mk, Prod.fst, True, congr, congrArg, StateT.run_seqLeft, StateT.run_seq, StateT.run_map, map_eq_pure_bind, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, eq_self],[Monad, LawfulMonad, StateT, Eq, SeqLeft.seqLeft, Applicative.toSeqLeft, Monad.toApplicative, StateT.instMonadStateT, Unit, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const]]
[Lean.Name.reprPrec,[Lean.Name, Nat, Std.Format, Lean.Name.below, Unit, Lean.Name.anonymous, UInt64, Lean.Name.num, String, Lean.Name.str, Unit.unit, Std.Format.text, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, PProd.fst, PUnit, PProd, OfNat.ofNat, instOfNatNat, repr, instReprNat, ite, Eq, Bool, Bool.false, Bool.true, instDecidableEqBool, instReprString, Lean.Name.toString],[Lean.Name, Nat, Std.Format]]
[instReprAtomUSize,[ReprAtom.mk, USize],[ReprAtom, USize]]
[Lean.Parser.Tactic.allGoals,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[MonadStateOf.get,[MonadStateOf],[MonadStateOf]]
[Lean.Name.mkStr,[Lean.Name, String, Lean.Name.str, mixHash, Hashable.hash, Lean.instHashableName, instHashableString],[Lean.Name, String]]
[Lean.Parser.Tactic.traceState,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[«term_-_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instReprAtomUInt64,[ReprAtom.mk, UInt64],[ReprAtom, UInt64]]
[Array.getLit.proof_1,[Nat, Array, Eq, Array.size, LT.lt, instLTNat, Eq.symm],[Nat, Array, Eq, Array.size, LT.lt, instLTNat]]
[PLift.down_up,[rfl, PLift.down, PLift.up],[Eq, PLift.down, PLift.up]]
[String.any,[String, Char, Bool, String.anyAux, String.bsize, OfNat.ofNat, String.Pos, instOfNatNat],[String, Char, Bool]]
[Lean.mkCIdentFrom,[Lean.Syntax, Lean.Name, Lean.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous, Lean.reservedMacroScope, Lean.Syntax.ident, Lean.SourceInfo.fromRef, String.toSubstring, ToString.toString, Lean.Name.instToStringName, List.cons, Prod, List, String, Prod.mk, List.nil],[Lean.Syntax, Lean.Name]]
[Std.Format.MonadPrettyFormat.currColumn,[Std.Format.MonadPrettyFormat],[Std.Format.MonadPrettyFormat, Nat]]
[Stream.next?,[Stream],[Stream, Option, Prod]]
[Substring.dropRightWhile,[Substring, Char, Bool, String, String.Pos, Substring.mk],[Substring, Char, Bool]]
[List.noConfusionType,[List, Eq],[List]]
[IO.Error.mkInvalidArgument,[IO.Error.invalidArgument, Option.none, String],[UInt32, String, IO.Error]]
[Seq.seq,[Seq],[Seq, Unit]]
[String.revPosOf,[String, Char, ite, Option, String.Pos, Eq, Bool, BEq.beq, Nat, instBEq, instDecidableEqNat, String.bsize, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Option.none, String.revPosOfAux, String.prev],[String, Char, Option, String.Pos]]
[MonadStateOf.noConfusionType,[MonadStateOf, PUnit, Prod, Eq],[MonadStateOf]]
[HShiftLeft.noConfusionType,[outParam, HShiftLeft, Eq],[outParam, HShiftLeft]]
[Array.eraseIdxSzAuxInstance,[Array, Inhabited.mk, Subtype, Eq, Nat, Array.size, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, Subtype.mk, Array.pop, Array.size_pop],[Array, Inhabited, Subtype, Eq, Nat, Array.size, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat]]
[Lean.Name.hash,[Lean.Name, UInt64, Unit, UInt64.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, Lean.Name.hash.proof_1, String],[Lean.Name, UInt64]]
[instLEFloat,[LE.mk, Float, Float.le],[LE, Float]]
[instLEUInt16,[LE.mk, UInt16, UInt16.le],[LE, UInt16]]
[Lean.Parser.Tactic.Conv.reduce,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[instReprUnit,[Repr.mk, Unit, Nat, Std.Format.text],[Repr, Unit]]
[Array.findIdx?,[Array, Bool, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Array.size, Option, OfNat.ofNat, instOfNatNat, rfl, Array.findIdx?.loop],[Array, Bool, Option, Nat]]
[Nat.add_eq,[Nat, rfl, Nat.add],[Nat, Eq, Nat.add, HAdd.hAdd, instHAdd, instAddNat]]
[MonadFunctor.monadMap,[MonadFunctor],[MonadFunctor]]
[List.eraseRepsAux,[BEq, List, List.below, List.nil, List.reverse, List.cons, Bool, BEq.beq, Unit, PProd.fst, PUnit, PProd],[BEq, List]]
[bfix2,[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd],[Nat]]
[IO.Error.noSuchThing.sizeOf_spec,[Option, String, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[Option, String, UInt32, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.noSuchThing]]
[Nat.le_total,[Nat, Or, LT.lt, instLTNat, GE.ge, instLENat, Nat.lt_or_ge, LE.le, Or.inl, Nat.le_of_lt, Or.inr],[Nat, Or, LE.le, instLENat]]
[LawfulApplicative.seq_pure,[Applicative, LawfulApplicative],[Applicative, LawfulApplicative, Eq, Seq.seq, Applicative.toSeq, Unit, Pure.pure, Applicative.toPure, Functor.map, Applicative.toFunctor]]
[Char.val,[Char],[Char, UInt32]]
[Alternative.toApplicative,[Alternative],[Alternative, Applicative]]
[String.decEq.proof_2,[List, Char, Not, Eq, String, String.mk, False, absurd],[List, Char, Not, Eq, String, String.mk, False]]
[Bool.and_true,[Bool, Eq, and, Bool.true, Bool.false, rfl, Eq.symm, Eq.refl],[Bool, Eq, and, Bool.true]]
[Lean.Syntax.getTrailingSize,[Lean.Syntax, Option, Lean.SourceInfo, Nat, Lean.Syntax.getTailInfo?, Substring, String.Pos, Substring.bsize, OfNat.ofNat, instOfNatNat],[Lean.Syntax, Nat]]
[String.Iterator.noConfusionType,[String.Iterator, String, String.Pos, Eq],[String.Iterator]]
[Lean.Parser.Tactic.paren,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Array.isEqv,[Array, Bool, dite, Eq, Nat, Array.size, instDecidableEqNat, Array.isEqvAux, OfNat.ofNat, instOfNatNat, Not, Bool.false],[Array, Bool]]
[precLead,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[UInt16.le,[UInt16, LE.le, Fin, UInt16.size, instLEFin, UInt16.val],[UInt16]]
[Array.foldrM.fold.proof_1,[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Nat.lt_of_lt_of_le, Nat.succ, Nat.lt_succ_self],[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, LT.lt, instLTNat]]
[Lean.Syntax.expandInterpolatedStrChunks,[Array, Lean.Syntax, Lean.MacroM, Nat, OfNat.ofNat, instOfNatNat, Lean.Syntax.missing, Bind.bind, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, MProd, ForIn.forIn, Array.instForInArray, MProd.mk, MProd.fst, MProd.snd, ForInStep, PUnit, HAdd.hAdd, instHAdd, instAddNat, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, ForInStep.yield, ite, Eq, Bool, BEq.beq, instBEq, instDecidableEqNat, Bool.true, instDecidableEqBool, Option, String, Lean.Syntax.isInterpolatedStrLit?, Unit, Lean.Syntax.mkStrLit, Lean.SourceInfo.none],[Array, Lean.Syntax, Lean.MacroM]]
[eq_true_of_decide,[Decidable, Eq, Bool, Decidable.decide, Bool.true, propext, True, Iff.intro, trivial, of_decide_eq_true],[Decidable, Eq, Bool, Decidable.decide, Bool.true, True]]
[Lean.NameGenerator.noConfusionType,[Lean.NameGenerator, Lean.Name, Nat, Eq],[Lean.NameGenerator]]
[Array.empty,[Array.mkEmpty, OfNat.ofNat, Nat, instOfNatNat],[Array]]
[Array.foldl,[Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Id.run, Array.foldlM, Id, Id.instMonadId],[Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size]]
[iff_self,[propext, Iff, True, Iff.intro, trivial, id],[Eq, Iff, True]]
[Fin.instModFin,[Nat, Mod.mk, Fin, Fin.mod],[Nat, Mod, Fin]]
[Array.«term__[_:_]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Squash,[Quot, True],[]]
[List.map,[List, List.below, Unit, List.nil, List.cons, PProd.fst, PUnit, PProd],[List]]
[Fin.xor,[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, Nat.xor, Fin.xor.proof_1],[Nat, Fin]]
[StateT.run_seqLeft,[Monad, LawfulMonad, StateT],[Monad, LawfulMonad, StateT, Eq, Prod, StateT.run, SeqLeft.seqLeft, Applicative.toSeqLeft, Monad.toApplicative, StateT.instMonadStateT, Unit, Bind.bind, Monad.toBind, Prod.snd, Pure.pure, Applicative.toPure, Prod.mk, Prod.fst]]
[IO.Process.SpawnArgs.cmd,[IO.Process.SpawnArgs],[IO.Process.SpawnArgs, String]]
[Lean.Name.appendAfter,[Lean.Name, String, Lean.Name.modifyBase, UInt64, Lean.Name.mkStr, HAppend.hAppend, instHAppend, String.instAppendString],[Lean.Name, String]]
[FloatArray.instInhabitedFloatArray,[Inhabited.mk, FloatArray, FloatArray.empty],[Inhabited, FloatArray]]
[IO.Error.alreadyExists.sizeOf_spec,[Option, String, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[Option, String, UInt32, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.alreadyExists]]
[instReprUSize,[Repr.mk, USize, Nat, repr, instReprNat, USize.toNat],[Repr, USize]]
[IO.Error.mkResourceExhausted,[IO.Error.resourceExhausted, Option.none, String],[UInt32, String, IO.Error]]
[Lean.charLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Lean.Parser.Tactic.contradiction,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[instReprBool,[Repr.mk, Bool, Nat, Std.Format, Std.Format.text],[Repr, Bool]]
[String.trimLeft,[String, Substring.toString, Substring.trimLeft, String.toSubstring],[String]]
[StateT.run_seq,[Monad, LawfulMonad, StateT],[Monad, LawfulMonad, StateT, Eq, Prod, StateT.run, Seq.seq, Applicative.toSeq, Monad.toApplicative, StateT.instMonadStateT, Unit, Bind.bind, Monad.toBind, Functor.map, Applicative.toFunctor, Prod.mk, Prod.fst, Prod.snd]]
[Nat.isValidChar,[Nat, Or, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, And],[Nat]]
[Lean.Meta.Simp.Config.singlePass,[Lean.Meta.Simp.Config],[Lean.Meta.Simp.Config, Bool]]
[StateT.run_modifyGet,[Monad, Prod, Eq, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk, Prod.fst, Prod.snd, rfl, Eq.symm, Eq.refl],[Monad, Prod, Eq, StateT.run, MonadState.modifyGet, StateT, instMonadState, instMonadStateOfStateT, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk, Prod.fst, Prod.snd]]
[«stx_*»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[fixCore6,[bfix6, USize.size],[]]
[StateCpsT.runK_bind_modify,[Monad, PUnit, StateCpsT, rfl, StateCpsT.runK, Bind.bind, Monad.toBind, StateCpsT.instMonadStateCpsT, modify, instMonadState, StateCpsT.instMonadStateOfStateCpsT],[Monad, PUnit, StateCpsT, Eq, StateCpsT.runK, Bind.bind, Monad.toBind, StateCpsT.instMonadStateCpsT, modify, instMonadState, StateCpsT.instMonadStateOfStateCpsT, PUnit.unit]]
[ByteArray.instAppendByteArray,[Append.mk, ByteArray, ByteArray.append],[Append, ByteArray]]
[instOrdFin,[Nat, Ord.mk, Fin, Ord.compare, instOrdNat, Fin.val],[Nat, Ord, Fin]]
[FloatArray.get?,[FloatArray, Nat, dite, Option, Float, LT.lt, instLTNat, FloatArray.size, Nat.decLt, Option.some, FloatArray.get, Fin.mk, Not, Option.none],[FloatArray, Nat, Option, Float]]
[Lean.instQuoteString,[Lean.Quote.mk, String, Lean.Syntax.mkStrLit, Lean.SourceInfo.none],[Lean.Quote, String]]
[Lean.Parser.Tactic.withReducibleAndInstances,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[List.cons_append,[List, rfl, HAppend.hAppend, instHAppend, List.instAppendList, List.cons],[List, Eq, HAppend.hAppend, instHAppend, List.instAppendList, List.cons]]
[Nat.forM,[Monad, Nat, Unit, Nat.forM.loop],[Monad, Nat, Unit]]
[USize.toUInt32,[USize, Nat.toUInt32, USize.toNat],[USize, UInt32]]
[SizeOfRef,[SizeOf, Measure, SizeOf.sizeOf],[SizeOf]]
[Prod.RProdSubLex.proof_1,[Prod, Prod.RProd, Eq, HEq, Prod.Lex, Prod.mk, Prod.RProd.intro, Prod.Lex.left, Eq.symm, eq_of_heq, Eq.refl, HEq.refl],[Prod, Prod.RProd, Prod.Lex]]
[instReprAtomInt,[ReprAtom.mk, Int],[ReprAtom, Int]]
[UInt8.xor,[UInt8, UInt8.mk, Fin.xor, UInt8.size, UInt8.val],[UInt8]]
[Int.negSucc.inj,[Nat, Eq, Int, Int.negSucc],[Nat, Eq, Int, Int.negSucc]]
[Std.Range.mk.sizeOf_spec,[Nat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat],[Nat, Eq, SizeOf.sizeOf, Std.Range, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, instSizeOfNat, Std.Range.mk]]
[Substring.posOf,[Substring, Char, String.Pos, String, HSub.hSub, instHSub, instSubNat, String.posOfAux],[Substring, Char, String.Pos]]
[IO.Error.noFileOrDirectory.inj,[String, UInt32, Eq, IO.Error, IO.Error.noFileOrDirectory, And, And.intro],[String, UInt32, Eq, IO.Error, IO.Error.noFileOrDirectory, And]]
[Lean.instInhabitedName,[Inhabited.mk, Lean.Name, Lean.Name.anonymous],[Inhabited, Lean.Name]]
[List.map_eq_mapTR,[funext, List, List.map, List.mapTR, of_eq_true, Eq, List.mapTRAux, List.nil, Eq.trans, True, congrArg, HAppend.hAppend, instHAppend, List.instAppendList, List.reverse, List.mapTRAux_eq, congrFun, List.reverse_nil, List.nil_append, eq_self],[Eq, List, List.map, List.mapTR]]
[OptionM,[OptionT, Id],[]]
[IO.FileRight.group,[IO.FileRight],[IO.FileRight, IO.AccessRight]]
[UInt16.shiftLeft,[UInt16, UInt16.mk, HShiftLeft.hShiftLeft, Fin, UInt16.size, instHShiftLeft, Fin.instShiftLeftFin, UInt16.val, UInt16.modn, OfNat.ofNat, Nat, instOfNatNat],[UInt16]]
[List.erase,[BEq, List, List.below, List.nil, List.cons, Bool, BEq.beq, Unit, PProd.fst, PUnit, PProd],[BEq, List]]
[Substring.front,[Substring, Substring.get, OfNat.ofNat, String.Pos, instOfNatNat],[Substring, Char]]
[Nat.land,[Nat.bitwise, and],[Nat]]
[IO.FS.Stream.Buffer.mk.sizeOf_spec,[ByteArray, Nat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Array, UInt8, SizeOf, List, Fin, UInt8.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[ByteArray, Nat, Eq, SizeOf.sizeOf, IO.FS.Stream.Buffer, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array, UInt8, SizeOf, List, Fin, UInt8.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.FS.Stream.Buffer.mk]]
[Int.ofNat.injEq,[Nat, Eq.propIntro, Eq, Int, Int.ofNat, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Nat, Eq, Int, Int.ofNat]]
[Array.sequenceMap,[Monad, Array, Nat, Array.size, OfNat.ofNat, instOfNatNat, Array.empty, Array.sequenceMap.loop],[Monad, Array]]
[getThe,[MonadStateOf, MonadStateOf.get],[MonadStateOf]]
[Nat.eq_zero_of_le_zero,[Nat, LE.le, instLENat, OfNat.ofNat, instOfNatNat, Nat.le_antisymm, Nat.zero_le],[Nat, LE.le, instLENat, OfNat.ofNat, instOfNatNat, Eq]]
[stdRange,[Prod.mk, Nat, OfNat.ofNat, instOfNatNat],[Prod, Nat]]
[Int.natAbs,[Nat, Nat.succ],[Nat]]
[Nat.anyM,[Monad, Nat, Bool, Nat.anyM.loop],[Monad, Nat, Bool]]
[Nat.mod_one,[Nat],[Nat, Eq, HMod.hMod, instHMod, Nat.instModNat, OfNat.ofNat, instOfNatNat]]
[OptionT.instMonadLiftOptionT,[Monad, MonadLift.mk, OptionT, OptionT.lift],[Monad, MonadLift, OptionT]]
[Array.findM?,[Monad, Array, Bool, Bind.bind, Monad.toBind, MProd, Option, PUnit, ForIn.forIn, Array.instForInArray, MProd.mk, Option.none, PUnit.unit, ForInStep, ite, Eq, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, ForInStep.done, Option.some, ForInStep.yield, MProd.fst, Unit],[Monad, Array, Bool, Option]]
[instDivFloat,[Div.mk, Float, Float.div],[Div, Float]]
[Bool.false_or,[Bool, Eq, or, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl],[Bool, Eq, or, Bool.false]]
[Nat.sub,[Nat, Nat.below, Nat.succ, Nat.pred, PProd.fst, PUnit, PProd],[Nat]]
[Lean.MonadNameGenerator.getNGen,[Lean.MonadNameGenerator],[Lean.MonadNameGenerator, Lean.NameGenerator]]
[Lean.Parser.Tactic.specialize,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[UInt64.xor,[UInt64, UInt64.mk, Fin.xor, UInt64.size, UInt64.val],[UInt64]]
[Char.isLower,[Char, and, Decidable.decide, GE.ge, UInt32, instLEUInt32, Char.val, OfNat.ofNat, instOfNatUInt32, instDecidableLe, LE.le],[Char, Bool]]
[instMulUInt64,[Mul.mk, UInt64, UInt64.mul],[Mul, UInt64]]
[Lean.Syntax.instBEqSyntax,[BEq.mk, Lean.Syntax, Lean.Syntax.structEq],[BEq, Lean.Syntax]]
[Squash.lift,[Subsingleton, Squash, Quot.lift, True, Squash.lift.proof_1],[Subsingleton, Squash]]
[Int.add,[Int, Nat, Int.ofNat, HAdd.hAdd, instHAdd, instAddNat, Int.subNatNat, Nat.succ, Int.negSucc],[Int]]
[IO.FS.Stream.Buffer.data,[IO.FS.Stream.Buffer],[IO.FS.Stream.Buffer, ByteArray]]
[Fin.instShiftRightFin,[Nat, ShiftRight.mk, Fin, Fin.shiftRight],[Nat, ShiftRight, Fin]]
[max,[LT, DecidableRel, LT.lt, ite],[LT, DecidableRel, LT.lt]]
[IO.Error.mkTimeExpired,[IO.Error.timeExpired],[UInt32, String, IO.Error]]
[String.Iterator.s,[String.Iterator],[String.Iterator, String]]
[Lean.binderIdent,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[IO.withStdin,[Monad, MonadFinally, MonadLiftT, IO, IO.FS.Stream, Bind.bind, Monad.toBind, liftM, EIO, IO.Error, IO.setStdin, tryFinally, PUnit, Applicative.toFunctor, Monad.toApplicative, Functor.discard],[Monad, MonadFinally, MonadLiftT, IO, IO.FS.Stream]]
[Lean.Syntax.isStrLit?,[Lean.Syntax, Option, String, Option.some, Option.none, Lean.Syntax.isLit?, Lean.strLitKind, Lean.Syntax.decodeStrLit],[Lean.Syntax, Option, String]]
[Function.Equiv.refl,[rfl],[Function.Equiv]]
[instToStringNat,[ToString.mk, Nat, Nat.repr],[ToString, Nat]]
[Lean.Syntax.instToFormatSyntax,[Std.ToFormat.mk, Lean.Syntax, Lean.Syntax.formatStx, Option.none, Nat, Bool.false],[Std.ToFormat, Lean.Syntax]]
[Lean.Parser.Tactic.Conv.convTrace_state,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Subarray.forRevM,[Monad, PUnit, Subarray, Array.forRevM, Subarray.as, Subarray.stop, Subarray.start],[Monad, PUnit, Subarray]]
[UInt16.toUInt32,[UInt16, Nat.toUInt32, UInt16.toNat],[UInt16, UInt32]]
[instInhabitedPointedType,[Inhabited.mk, PointedType, PointedType.mk, PUnit, PUnit.unit],[Inhabited, PointedType]]
[Std.Range.instForInRangeNat,[ForIn.mk, Std.Range, Nat, Monad, Std.Range.forIn],[ForIn, Std.Range, Nat]]
[instHashableUSize,[Hashable.mk, USize, USize.toUInt64],[Hashable, USize]]
[EStateM.Result.ok.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, EStateM.Result, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, EStateM.Result.ok]]
[GE.ge,[LE, LE.le],[LE]]
[List.reverseAux_eq_append,[List, Eq, List.reverseAux, HAppend.hAppend, instHAppend, List.instAppendList, List.nil, of_eq_true, Eq.trans, True, congrArg, List.nil_append, eq_self, Eq.mpr, List.cons, Eq.refl, List.append_assoc, rfl],[List, Eq, List.reverseAux, HAppend.hAppend, instHAppend, List.instAppendList, List.nil]]
[IO.Error.userError.inj,[String, Eq, IO.Error, IO.Error.userError],[String, Eq, IO.Error, IO.Error.userError]]
[Lean.Macro.Methods.resolveNamespace?,[Lean.Macro.Methods],[Lean.Macro.Methods, Lean.Name, Lean.MacroM, Option]]
[IO.Error.timeExpired.injEq,[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.timeExpired, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[UInt32, String, Eq, IO.Error, IO.Error.timeExpired, And]]
[ReaderT.instMonadExceptOfReaderT,[MonadExceptOf, MonadExceptOf.mk, ReaderT, liftM, instMonadLiftT, ReaderT.instMonadLiftReaderT, instMonadLiftT_1, MonadExcept.throw, instMonadExcept, tryCatchThe],[MonadExceptOf, ReaderT]]
[ExceptT.seq_eq,[Monad, ExceptT, rfl, Seq.seq, Applicative.toSeq, Monad.toApplicative, ExceptT.instMonadExceptT, Unit],[Monad, ExceptT, Eq, Seq.seq, Applicative.toSeq, Monad.toApplicative, ExceptT.instMonadExceptT, Unit, Bind.bind, Monad.toBind, Functor.map, Applicative.toFunctor]]
[IO.Process.SpawnArgs.mk.sizeOf_spec,[IO.Process.StdioConfig, String, Array, Option, System.FilePath, Prod, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, IO.Process.Stdio, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[IO.Process.StdioConfig, String, Array, Option, System.FilePath, Prod, Eq, Nat, SizeOf.sizeOf, IO.Process.SpawnArgs, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, IO.Process.Stdio, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Process.SpawnArgs.mk]]
[StateCpsT.instLawfulMonadStateCpsT,[StateCpsT.instLawfulMonadStateCpsT.proof_1],[LawfulMonad, StateCpsT, StateCpsT.instMonadStateCpsT]]
[FloatArray.mkEmpty,[FloatArray.mk, List.toArray, Float, List.nil],[FloatArray]]
[«term_*_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Nat.instOrOpNat,[OrOp.mk, Nat, Nat.lor],[OrOp, Nat]]
[Nat.add_lt_add_right,[Nat, LT.lt, instLTNat, HAdd.hAdd, instHAdd, instAddNat, Nat.add_lt_add_left, Nat.add_comm],[Nat, LT.lt, instLTNat, HAdd.hAdd, instHAdd, instAddNat]]
[ExceptCpsT.run_bind_lift,[Monad, ExceptCpsT, rfl, Except, ExceptCpsT.run, Bind.bind, Monad.toBind, ExceptCpsT.instMonadExceptCpsT, ExceptCpsT.lift],[Monad, ExceptCpsT, Eq, Except, ExceptCpsT.run, Bind.bind, Monad.toBind, ExceptCpsT.instMonadExceptCpsT, ExceptCpsT.lift]]
[IO.Process.Output.exitCode,[IO.Process.Output],[IO.Process.Output, UInt32]]
[Lean.Meta.Simp.Config.iota,[Lean.Meta.Simp.Config],[Lean.Meta.Simp.Config, Bool]]
[Subarray.foldlM,[Monad, Subarray, Array.foldlM, Subarray.as, Subarray.start, Subarray.stop],[Monad, Subarray]]
[HasEquiv.noConfusionType,[HasEquiv, Eq],[HasEquiv]]
[instReprStdGen,[Repr.mk, StdGen, Nat, Std.Format, Std.Format.bracket, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, repr, instReprNat, Std.Format.text],[Repr, StdGen]]
[IO.AccessRight.execution,[IO.AccessRight],[IO.AccessRight, Bool]]
[Int.instLTInt,[LT.mk, Int, Int.lt],[LT, Int]]
[Quotient.lift₂,[Setoid, HasEquiv.Equiv, instHasEquiv, Eq, Quotient, Quotient.lift, Quotient.lift₂.proof_1, Quotient.lift₂.proof_2],[Setoid, HasEquiv.Equiv, instHasEquiv, Eq, Quotient]]
[Lean.Syntax.mkLit,[Lean.SyntaxNodeKind, String, optParam, Lean.SourceInfo, Lean.SourceInfo.none, Lean.Syntax, Lean.Syntax.atom, Lean.Syntax.node, List.toArray, List.cons, List.nil],[Lean.SyntaxNodeKind, String, optParam, Lean.SourceInfo, Lean.SourceInfo.none, Lean.Syntax]]
[Lean.Parser.Tactic.«tacticHave'__:=_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[instStreamSubarray.proof_1,[Subarray, LT.lt, Nat, instLTNat, Subarray.start, Subarray.stop, Nat.succ_le_of_lt],[Subarray, LT.lt, Nat, instLTNat, Subarray.start, Subarray.stop, LE.le, instLENat, Nat.succ]]
[Bool.or_false,[Bool, Eq, or, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl],[Bool, Eq, or, Bool.false]]
[Lean.Macro.Methods.getCurrNamespace,[Lean.Macro.Methods],[Lean.Macro.Methods, Lean.MacroM, Lean.Name]]
[ne_true_of_not,[Not, Eq, True],[Not, Ne, True]]
[Fin.eq_of_val_eq,[Nat, Fin, Eq, Fin.val, LT.lt, instLTNat, rfl, Fin.mk],[Nat, Fin, Eq, Fin.val]]
[Sum.inr.injEq,[Eq.propIntro, Eq, Sum, Sum.inr, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Sum, Sum.inr]]
[PSigma.mkSkipLeft,[PSigma.mkSkipLeft.proof_1],[PSigma.SkipLeft, PSigma.mk]]
[List.replicate,[Nat, List, List.nil, List.replicate.loop],[Nat, List]]
[Lean.Meta.TransparencyMode.noConfusion,[Lean.Meta.TransparencyMode, Eq, noConfusionEnum, Nat, instDecidableEqNat, Lean.Meta.TransparencyMode.toCtorIdx],[Lean.Meta.TransparencyMode, Eq, Lean.Meta.TransparencyMode.noConfusionType]]
[«term_×'_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.bracketedExplicitBinders, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[nonempty_of_exists,[Exists, Nonempty, Nonempty.intro],[Exists, Nonempty]]
[Std.Format.tag.injEq,[Nat, Std.Format, Eq.propIntro, Eq, Std.Format.tag, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Nat, Std.Format, Eq, Std.Format.tag, And]]
[instToStringSubstring,[ToString.mk, Substring, Substring.toString],[ToString, Substring]]
[FloatArray.mk.inj,[Array, Float, Eq, FloatArray, FloatArray.mk],[Array, Float, Eq, FloatArray, FloatArray.mk]]
[ExceptT.instMonadFunctorExceptT,[MonadFunctor.mk, ExceptT, Except],[MonadFunctor, ExceptT]]
[Unit,[PUnit],[]]
[IO.Error.resourceVanished.sizeOf_spec,[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar],[UInt32, String, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, Option, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.resourceVanished]]
[List.instListDecidableLe,[LT, DecidableRel, LT.lt, List, inferInstanceAs, Decidable, Not, List.instLTList, instDecidableNot, List.hasDecidableLt],[LT, DecidableRel, LT.lt, List, Decidable, LE.le, List.instLEList]]
[precMax,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Meta.Simp.instBEqConfig,[BEq.mk, Lean.Meta.Simp.Config, Nat, Bool, Lean.Meta.Simp.Config.mk, and, Bool.true, BEq.beq, instBEq, instDecidableEqNat, instDecidableEqBool, Bool.false],[BEq, Lean.Meta.Simp.Config]]
[Lean.Macro.throwError,[String, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Syntax, Lean.MonadRef.getRef, Lean.Macro.instMonadRefMacroM, MonadExcept.throw, instMonadExcept, ReaderT.instMonadExceptOfReaderT, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Lean.Macro.Exception.error],[String, Lean.MacroM]]
[EStateM.Result.error.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, EStateM.Result, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, EStateM.Result.error]]
[Nat.all,[Nat, Bool, not, Nat.any],[Nat, Bool]]
[WellFoundedRelation.mk.sizeOf_spec,[SizeOf, WellFounded, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOf],[SizeOf, WellFounded, Eq, Nat, SizeOf.sizeOf, WellFoundedRelation, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, instSizeOf, WellFoundedRelation.mk]]
[ST.Prim.Ref.modifyGet,[ST.Ref, Prod, Bind.bind, ST, Monad.toBind, instMonadST, ST.Prim.Ref.get, Unit, ST.Prim.Ref.set, PUnit, Pure.pure, Applicative.toPure, Monad.toApplicative],[ST.Ref, Prod, ST]]
[eq_false',[False, propext, Iff.intro, absurd, False.elim],[False, Eq]]
[id,[],[]]
[String.foldl,[Char, String, String.foldlAux, String.bsize, OfNat.ofNat, String.Pos, instOfNatNat],[Char, String]]
[Char.mk.sizeOf_spec,[UInt32, UInt32.isValidChar, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[UInt32, UInt32.isValidChar, Eq, Nat, SizeOf.sizeOf, Char, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, Char.mk]]
[coeOfHead,[CoeHead, CoeHTCT.mk, coeHead],[CoeHead, CoeHTCT]]
[instInhabitedNat,[Inhabited.mk, Nat, Nat.zero],[Inhabited, Nat]]
[StateT.get,[Monad, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod, Prod.mk],[Monad, StateT]]
[SizeOf.sizeOf,[SizeOf],[SizeOf, Nat]]
[Lean.Parser.Tactic.withReducible,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[DoResultPR.return.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, DoResultPR, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, DoResultPR.return]]
[FloatSpec.noConfusionType,[FloatSpec, DecidableRel, Eq, HEq],[FloatSpec]]
[IO.Error.alreadyExists.inj,[Option, String, UInt32, Eq, IO.Error, IO.Error.alreadyExists, And, And.intro],[Option, String, UInt32, Eq, IO.Error, IO.Error.alreadyExists, And]]
[IO.Error.mkInappropriateType,[IO.Error.inappropriateType, Option.none, String],[UInt32, String, IO.Error]]
[Nat.add_succ,[Nat, rfl, HAdd.hAdd, instHAdd, instAddNat, Nat.succ],[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.succ]]
[EStateM.modifyGet,[Prod, EStateM.Result, EStateM.Result.ok],[Prod, EStateM]]
[Fin.val_eq_of_eq,[Nat, Fin, Eq, Fin.val, rfl],[Nat, Fin, Eq, Fin.val]]
[Fin.mul,[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, HMul.hMul, instHMul, instMulNat, Fin.mul.proof_1],[Nat, Fin]]
[instInhabitedStdGen,[Inhabited.mk, StdGen, StdGen.mk, OfNat.ofNat, Nat, instOfNatNat],[Inhabited, StdGen]]
[ReaderT.failure,[Alternative, Alternative.failure],[Alternative, ReaderT]]
[instDivUInt8,[Div.mk, UInt8, UInt8.div],[Div, UInt8]]
[instMonadControlT_1,[Pure, MonadControlT.mk, Pure.pure],[Pure, MonadControlT]]
[CoeTail.noConfusionType,[CoeTail, Eq],[CoeTail]]
[instAndOpUInt64,[AndOp.mk, UInt64, UInt64.land],[AndOp, UInt64]]
[instLawfulMonadStateRefT'.proof_1,[Monad, LawfulMonad, inferInstanceAs, ReaderT, ST.Ref, ReaderT.instMonadReaderT, ReaderT.instLawfulMonadReaderT],[Monad, LawfulMonad, ReaderT, ST.Ref, ReaderT.instMonadReaderT]]
[StateRefT'.instMonadExceptOfStateRefT',[MonadExceptOf, MonadExceptOf.mk, StateRefT', Function.comp, StateRefT'.lift, throwThe, ST.Ref, tryCatchThe],[MonadExceptOf, StateRefT']]
[Nat.le_add_left,[Nat, HAdd.hAdd, instHAdd, instAddNat, LE.le, instLENat, Nat.le_add_right, Nat.add_comm],[Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat]]
[Std.Range.«term[:_:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[implies.trans,[implies],[implies]]
[Lean.Meta.Simp.Config.noConfusionType,[Lean.Meta.Simp.Config, Nat, Bool, Eq],[Lean.Meta.Simp.Config]]
[instTransEq_1.proof_1,[Eq],[Eq]]
[Substring.prevn,[Substring, String.Pos, Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, Substring.prev],[Substring, String.Pos, Nat]]
[StdGen.mk.inj,[Nat, Eq, StdGen, StdGen.mk, And, And.intro],[Nat, Eq, StdGen, StdGen.mk, And]]
[Lean.Macro.trace,[Lean.Name, String, modify, Lean.Macro.State, Lean.MacroM, instMonadState, instMonadStateOf, EStateM, Lean.Macro.Exception, ReaderT.instMonadLiftReaderT, Lean.Macro.Context, EStateM.instMonadStateOfEStateM, Lean.Macro.State.mk, Lean.Macro.State.macroScope, List.cons, Prod, Prod.mk, Lean.Macro.State.traceMsgs],[Lean.Name, String, Lean.MacroM, Unit]]
[IO.Process.Child.stderr,[IO.Process.StdioConfig, IO.Process.Child],[IO.Process.StdioConfig, IO.Process.Child, IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stderr]]
[EStateM.Result.error.injEq,[Eq.propIntro, Eq, EStateM.Result, EStateM.Result.error, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Eq, EStateM.Result, EStateM.Result.error, And]]
[HOr.noConfusionType,[outParam, HOr, Eq],[outParam, HOr]]
[bfix6,[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd],[Nat]]
[WellFoundedRelation.wf,[WellFoundedRelation],[WellFoundedRelation, WellFounded, WellFoundedRelation.rel]]
[Std.Format.defIndent,[OfNat.ofNat, Nat, instOfNatNat],[Nat]]
[MProd.noConfusionType,[MProd, Eq],[MProd]]
[Int.ofNat.inj,[Nat, Eq, Int, Int.ofNat],[Nat, Eq, Int, Int.ofNat]]
[Lean.Meta.Simp.Config.maxSteps,[Lean.Meta.Simp.Config],[Lean.Meta.Simp.Config, Nat]]
[IO.Error.mkProtocolError,[IO.Error.protocolError],[UInt32, String, IO.Error]]
[Option.none.sizeOf_spec,[SizeOf, Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[SizeOf, Eq, Nat, SizeOf.sizeOf, Option, SizeOf.mk, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Option.none]]
[ReaderT.run_seqRight,[Monad, LawfulMonad, ReaderT, Eq.mpr, Eq, ReaderT.run, SeqRight.seqRight, Applicative.toSeqRight, Monad.toApplicative, ReaderT.instMonadReaderT, Unit, Bind.bind, Monad.toBind, Eq.refl, seqRight_eq_bind, rfl],[Monad, LawfulMonad, ReaderT, Eq, ReaderT.run, SeqRight.seqRight, Applicative.toSeqRight, Monad.toApplicative, ReaderT.instMonadReaderT, Unit]]
[IO.Error.timeExpired.inj,[UInt32, String, Eq, IO.Error, IO.Error.timeExpired, And, And.intro],[UInt32, String, Eq, IO.Error, IO.Error.timeExpired, And]]
[StateT.instMonadFunctorStateT,[Monad, MonadFunctor.mk, StateT, Prod],[Monad, MonadFunctor, StateT]]
[instReprNat,[Repr.mk, Nat, Std.Format.text, Nat.repr],[Repr, Nat]]
[IO.Process.Child.mk.injEq,[IO.Process.StdioConfig, IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdin, IO.Process.StdioConfig.stdout, IO.Process.StdioConfig.stderr, Eq.propIntro, Eq, IO.Process.Child, IO.Process.Child.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[IO.Process.StdioConfig, IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdin, IO.Process.StdioConfig.stdout, IO.Process.StdioConfig.stderr, Eq, IO.Process.Child, IO.Process.Child.mk, And]]
[ReaderT.instMonadLiftReaderT,[MonadLift.mk, ReaderT],[MonadLift, ReaderT]]
[List.zipWith,[List, List.below, List.cons, PProd.fst, PUnit, PProd, List.nil],[List]]
[Lean.Syntax.getHeadInfo,[Lean.Syntax, Option, Lean.SourceInfo, Lean.Syntax.getHeadInfo?, Unit, Lean.SourceInfo.none],[Lean.Syntax, Lean.SourceInfo]]
[instShiftLeftUInt64,[ShiftLeft.mk, UInt64, UInt64.shiftLeft],[ShiftLeft, UInt64]]
[IO.FS.instReprSystemTime,[Repr.mk, IO.FS.SystemTime, Nat, Std.Format.bracket, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.nil, Std.Format.text, repr, Int, instReprInt, IO.FS.SystemTime.sec, Std.Format.line, UInt32, instReprUInt32, IO.FS.SystemTime.nsec],[Repr, IO.FS.SystemTime]]
[List.findSomeM?,[Monad, Option, List, List.below, Unit, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.none, List.cons, Bind.bind, Monad.toBind, Option.some, PProd.fst, PUnit, PProd],[Monad, Option, List]]
[HMod.noConfusionType,[outParam, HMod, Eq],[outParam, HMod]]
[String.toSubstring,[String, Substring.mk, OfNat.ofNat, String.Pos, instOfNatNat, String.bsize],[String, Substring]]
[instOrdNat,[Ord.mk, Nat, compareOfLessAndEq, instLTNat, Nat.decLt, instDecidableEqNat],[Ord, Nat]]
[StateT.run_monadMap,[Monad, MonadFunctor, StateT, rfl, Prod, StateT.run, MonadFunctorT.monadMap, instMonadFunctorT, StateT.instMonadFunctorStateT, monadFunctorRefl],[Monad, MonadFunctor, StateT, Eq, Prod, StateT.run, MonadFunctorT.monadMap, instMonadFunctorT, StateT.instMonadFunctorStateT, monadFunctorRefl]]
[Task.Priority.dedicated,[OfNat.ofNat, Task.Priority, instOfNatNat],[Task.Priority]]
[IO.FS.withIsolatedStreams,[Monad, MonadFinally, MonadExceptOf, IO.Error, MonadLiftT, IO, Bind.bind, Monad.toBind, IO.Ref, IO.FS.Stream.Buffer, Prod, String, Except, liftM, EIO, IO.mkRef, IO.FS.Stream.Buffer.mk, IO.withStdin, IO.FS.Stream.ofBuffer, IO.withStdout, IO.withStderr, observing, instMonadExcept, ST.Ref.get, IO.RealWorld, instMonadLiftT, ST, IO.instMonadLiftSTRealWorldEIO, instMonadLiftT_1, String.fromUTF8Unchecked, IO.FS.Stream.Buffer.data, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk],[Monad, MonadFinally, MonadExceptOf, IO.Error, MonadLiftT, IO, Prod, String, Except]]
[Lean.Name.capitalize,[Lean.Name, String, UInt64, Lean.Name.mkStr, String.capitalize],[Lean.Name]]
[Array.foldlMUnsafe,[Monad, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, USize, ite, LT.lt, instLTNat, Nat.decLt, LE.le, instLENat, Nat.decLe, USize.ofNat, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.foldlMUnsafe.fold],[Monad, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size]]
[MonadState.modifyGet,[MonadState],[MonadState, Prod]]
[instDecidableArrow.proof_1,[],[]]
[Nat.lt_of_le_of_ne,[Nat, LE.le, instLENat, Not, Eq, Or, LT.lt, instLTNat, GE.ge, Nat.lt_or_ge, absurd, Nat.le_antisymm],[Nat, LE.le, instLENat, Not, Eq, LT.lt, instLTNat]]
[ExceptT.run_lift,[Monad, rfl, Except, ExceptT.run, ExceptT.lift],[Monad, Eq, Except, ExceptT.run, ExceptT.lift, Functor.map, Applicative.toFunctor, Monad.toApplicative, Except.ok]]
[instHAndThen,[AndThen, HAndThen.mk, Unit, AndThen.andThen],[AndThen, HAndThen]]
[«term-_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[decPropToBool,[Decidable, CoeDep.mk, Bool, Decidable.decide],[Decidable, CoeDep, Bool]]
[Bool.and_false,[Bool, Eq, and, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl],[Bool, Eq, and, Bool.false]]
[LawfulApplicative.pure_seq,[Applicative, LawfulApplicative],[Applicative, LawfulApplicative, Eq, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, Unit, Functor.map, Applicative.toFunctor]]
[Lean.Name.append,[Lean.Name, Lean.Name.below, Lean.Name.anonymous, String, UInt64, Lean.Name.str, Lean.Name.mkStr, PProd.fst, PUnit, PProd, Nat, Lean.Name.num, Lean.Name.mkNum],[Lean.Name]]
[List.hasDecEq.proof_4,[List, Eq, List.cons, rfl],[List, Eq, List.cons]]
[Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat, LT.lt, instLTNat, LE.le, instLENat, Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1],[Trans, Nat, LT.lt, instLTNat, LE.le, instLENat]]
[StateRefT',[ReaderT, ST.Ref],[]]
[StateT.run_bind_lift,[Monad, LawfulMonad, StateT, of_eq_true, Eq, Prod, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk, Eq.trans, True, congrFun, congrArg, LawfulMonad.bind_assoc, funext, LawfulMonad.pure_bind, eq_self],[Monad, LawfulMonad, StateT, Eq, Prod, StateT.run, Bind.bind, Monad.toBind, StateT.instMonadStateT, StateT.lift]]
[StateRefT'.run,[Monad, MonadLiftT, ST, StateRefT', Bind.bind, Monad.toBind, ST.Ref, Prod, ST.mkRef, ST.Ref.get, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk],[Monad, MonadLiftT, ST, StateRefT', Prod]]
[Lean.Macro.Context.noConfusionType,[Lean.Macro.Context, PointedType.type, Lean.Name, Lean.MacroScope, Nat, Lean.Syntax, Eq],[Lean.Macro.Context]]
[instSubUInt64,[Sub.mk, UInt64, UInt64.sub],[Sub, UInt64]]
[Option.bind,[Option, Option.none],[Option]]
[«term_>>=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[MonadReaderOf.noConfusionType,[MonadReaderOf, Eq],[MonadReaderOf]]
[UInt8.land,[UInt8, UInt8.mk, Fin.land, UInt8.size, UInt8.val],[UInt8]]
[ReaderT.run_seq,[Monad, LawfulMonad, ReaderT, Eq.mpr, Eq, ReaderT.run, Seq.seq, Applicative.toSeq, Monad.toApplicative, ReaderT.instMonadReaderT, Unit, Bind.bind, Monad.toBind, Functor.map, Applicative.toFunctor, Eq.refl, seq_eq_bind, rfl],[Monad, LawfulMonad, ReaderT, Eq, ReaderT.run, Seq.seq, Applicative.toSeq, Monad.toApplicative, ReaderT.instMonadReaderT, Unit]]
[fixCore,[fixCore1],[]]
[Lean.Meta.Rewrite.Config.mk.sizeOf_spec,[Lean.Meta.TransparencyMode, Bool, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk],[Lean.Meta.TransparencyMode, Bool, Eq, Nat, SizeOf.sizeOf, Lean.Meta.Rewrite.Config, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Lean.Meta.Rewrite.Config.mk]]
[Bool.or_true,[Bool, Eq, or, Bool.true, Bool.false, rfl, Eq.symm, Eq.refl],[Bool, Eq, or, Bool.true]]
[«term‹_›»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[PSigma.mk.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, PSigma, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, PSigma.mk]]
[False.elim,[False],[False]]
[String.next,[Char, String.get, HAdd.hAdd, String.Pos, Nat, instHAdd, instAddNat, String.csize],[String.Pos]]
[Quot.indep,[Quot, Quot.mk, PSigma.mk],[Quot, Quot.mk, PSigma]]
[Lean.Parser.Tactic.inductionAlt,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Alternative.failure,[Alternative],[Alternative]]
[instStreamProdProd,[outParam, Stream, Stream.mk, Prod, Option, Stream.next?, Unit, Option.none, Option.some, Prod.mk],[outParam, Stream, Prod]]
[instLEUInt32,[LE.mk, UInt32, LE.le, Fin, UInt32.size, instLEFin, UInt32.val],[LE, UInt32]]
[Quotient.inductionOn,[Setoid, Quotient, Quotient.mk, Quot.inductionOn, Setoid.r],[Setoid, Quotient, Quotient.mk]]
[ite_true,[rfl, ite, True, instDecidableTrue],[Eq, ite, True, instDecidableTrue]]
[instDecidableEqFin,[Nat, Fin, Decidable, Eq, Fin.val, decEq, instDecidableEqNat, Decidable.isTrue, Fin.eq_of_val_eq, Not, Decidable.isFalse, Fin.ne_of_val_ne],[Nat, DecidableEq, Fin]]
[Fin.elim0,[Fin, OfNat.ofNat, Nat, instOfNatNat, LT.lt, instLTNat, absurd, Nat.not_lt_zero],[Fin, OfNat.ofNat, Nat, instOfNatNat]]
[USize.xor,[USize, USize.mk, Fin.xor, USize.size, USize.val],[USize]]
[Lean.Syntax.SepArray.elemsAndSeps,[String, Lean.Syntax.SepArray],[String, Lean.Syntax.SepArray, Array, Lean.Syntax]]
[Nat.lt_of_lt_of_eq,[Nat, LT.lt, instLTNat, Eq],[Nat, LT.lt, instLTNat, Eq]]
[Prod.mk.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, Prod, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Prod.mk]]
[recSubsingleton,[Decidable, Not, Subsingleton],[Decidable, Not, Subsingleton]]
[IO.Process.Output.mk.sizeOf_spec,[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar],[UInt32, String, Eq, Nat, SizeOf.sizeOf, IO.Process.Output, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar, IO.Process.Output.mk]]
[ReaderT.run_monadMap,[Monad, MonadFunctor, ReaderT, rfl, ReaderT.run, MonadFunctorT.monadMap, instMonadFunctorT, ReaderT.instMonadFunctorReaderT, monadFunctorRefl],[Monad, MonadFunctor, ReaderT, Eq, ReaderT.run, MonadFunctorT.monadMap, instMonadFunctorT, ReaderT.instMonadFunctorReaderT, monadFunctorRefl]]
[Int.instInhabitedInt,[Inhabited.mk, Int, Int.ofNat, OfNat.ofNat, Nat, instOfNatNat],[Inhabited, Int]]
[optParam_eq,[rfl, optParam],[Eq, optParam]]
[instDecidableAnd.proof_2,[Not, And, And.left],[Not, And, False]]
[EStateM.orElse',[outParam, EStateM.Backtrackable, EStateM, optParam, Bool, Bool.true, EStateM.Backtrackable.save, EStateM.Result, EStateM.Backtrackable.restore, EStateM.Result.error, ite, Eq, instDecidableEqBool],[outParam, EStateM.Backtrackable, EStateM, optParam, Bool, Bool.true]]
[System.SearchPath.separator,[ite, Char, Eq, Bool, System.Platform.isWindows, Bool.true, instDecidableEqBool, Char.ofNat],[Char]]
[Array.foldlM.loop,[Monad, Array, Nat, LE.le, instLENat, Array.size, Nat.below, dite, LT.lt, instLTNat, Nat.decLt, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Nat.succ, Bind.bind, Monad.toBind, Array.get, Fin.mk, Array.foldlM.loop.proof_1, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Not],[Monad, Array, Nat, LE.le, instLENat, Array.size]]
[Lean.Syntax.getId,[Lean.Syntax, Lean.Name, Lean.SourceInfo, Substring, List, Prod, String, Lean.Name.anonymous],[Lean.Syntax, Lean.Name]]
[MonadControl.restoreM,[MonadControl],[MonadControl, MonadControl.stM]]
[DecidableRel,[Decidable],[]]
[Id.run,[Id],[Id]]
[Quotient.sound,[Quotient.sound.proof_1],[Setoid, HasEquiv.Equiv, instHasEquiv, Eq, Quotient, Quotient.mk]]
[List.anyM,[Monad, Bool, List, List.below, Unit, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.false, List.cons, Bind.bind, Monad.toBind, Bool.true, PProd.fst, PUnit, PProd],[Monad, Bool, List]]
[CoeTC.noConfusionType,[CoeTC, Eq],[CoeTC]]
[Lean.Meta.TransparencyMode.default.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, Lean.Meta.TransparencyMode, SizeOf.mk, OfNat.ofNat, instOfNatNat, Lean.Meta.TransparencyMode.default]]
[instMonadReaderOfReaderT,[Monad, MonadReaderOf.mk, ReaderT, ReaderT.read],[Monad, MonadReaderOf, ReaderT]]
[fixCore3,[bfix3, USize.size],[]]
[instReprAtomUInt8,[ReprAtom.mk, UInt8],[ReprAtom, UInt8]]
[String.split,[String, Char, Bool, String.splitAux, OfNat.ofNat, String.Pos, instOfNatNat, List.nil],[String, Char, Bool, List]]
[Array.erase,[BEq, Array, Option, Fin, Array.size, Array.indexOf?, Unit, Array.feraseIdx],[BEq, Array]]
[Lean.interpolatedStrLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Lean.Name.instBEqName,[BEq.mk, Lean.Name, Lean.Name.beq],[BEq, Lean.Name]]
[Quot.indBeta,[Quot, Quot.mk, rfl, Quot.ind],[Quot, Quot.mk, Eq, Quot.ind]]
[ReaderT.ext,[Monad, ReaderT, Eq, ReaderT.run, funext, id],[Monad, ReaderT, Eq, ReaderT.run]]
[UInt16.noConfusionType,[UInt16, Fin, UInt16.size, Eq],[UInt16]]
[«term_∘_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Inhabited.default,[Inhabited],[Inhabited]]
[UInt32.decEq.proof_2,[Fin, UInt32.size, Not, Eq, UInt32, UInt32.mk, False, absurd],[Fin, UInt32.size, Not, Eq, UInt32, UInt32.mk, False]]
[«term_<||>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Array.filterSepElems,[Array, Lean.Syntax, Bool, Id.run, Array.filterSepElemsM, Id, Id.instMonadId],[Array, Lean.Syntax, Bool]]
[Lean.Meta.Simp.Config.mk.inj,[Nat, Bool, Eq, Lean.Meta.Simp.Config, Lean.Meta.Simp.Config.mk, And, And.intro],[Nat, Bool, Eq, Lean.Meta.Simp.Config, Lean.Meta.Simp.Config.mk, And]]
[Lean.strLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[instShiftRightUInt32,[ShiftRight.mk, UInt32, UInt32.shiftRight],[ShiftRight, UInt32]]
[MonadState.get,[MonadState],[MonadState]]
[dite_congr,[Decidable, Not, Eq, Eq.mpr_prop, Eq.mpr_not, Or, Decidable.em, dite, Or.inl, Eq.mpr, Eq.refl, dif_pos, Eq.symm, Or.inr, dif_neg],[Decidable, Not, Eq, Eq.mpr_prop, Eq.mpr_not, dite]]
[Lean.Syntax.setHeadInfo,[Lean.Syntax, Lean.SourceInfo, Option, Lean.Syntax.setHeadInfoAux, Unit],[Lean.Syntax, Lean.SourceInfo]]
[Char.ne_of_val_ne,[Char, Not, Eq, UInt32, Char.val, absurd, False, Char.val_eq_of_eq],[Char, Not, Eq, UInt32, Char.val]]
[instModUInt32,[Mod.mk, UInt32, UInt32.mod],[Mod, UInt32]]
[Lean.PrettyPrinter.instMonadQuotationUnexpandM,[Lean.MonadQuotation.mk, Lean.PrettyPrinter.UnexpandM, Lean.MonadRef.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, EStateM.instMonadEStateM, Unit, Lean.Syntax, Lean.Syntax.missing, id, Lean.MacroScope, OfNat.ofNat, instOfNatNat, Lean.Name, Lean.Name.mkStr, Lean.Name.anonymous],[Lean.MonadQuotation, Lean.PrettyPrinter.UnexpandM]]
[USize.add,[USize, USize.mk, HAdd.hAdd, Fin, USize.size, instHAdd, Fin.instAddFin, USize.val],[USize]]
[Lean.Parser.Tactic.tacticSuffices_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[NonScalar.mk.sizeOf_spec,[Nat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat],[Nat, Eq, SizeOf.sizeOf, NonScalar, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, instSizeOfNat, NonScalar.mk]]
[termMax_prec,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Int.pow,[Int, Nat, Nat.below, Unit, OfNat.ofNat, Int.instOfNatInt, Nat.succ, HMul.hMul, instHMul, Int.instMulInt, PProd.fst, PUnit, PProd],[Int, Nat]]
[Option.orElse,[Option, Unit, Option.some, Unit.unit],[Option, Unit]]
[Lean.Syntax.SepArray.getElems,[String, Lean.Syntax.SepArray, Array.getSepElems, Lean.Syntax, Lean.Syntax.SepArray.elemsAndSeps],[String, Lean.Syntax.SepArray, Array, Lean.Syntax]]
[Nat.mul_zero,[Nat, rfl, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat],[Nat, Eq, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat]]
[IO.Process.SpawnArgs.noConfusionType,[IO.Process.SpawnArgs, IO.Process.StdioConfig, String, Array, Option, System.FilePath, Prod, Eq],[IO.Process.SpawnArgs]]
[Lean.SourceInfo.fromRef,[Lean.Syntax, Option, String.Pos, Lean.SourceInfo, Lean.Syntax.getPos?, Bool.false, Lean.Syntax.getTailPos?, Lean.SourceInfo.synthetic, Lean.SourceInfo.none],[Lean.Syntax, Lean.SourceInfo]]
[«term_⊕_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Fin.shiftRight.proof_1,[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, HShiftRight.hShiftRight, instHShiftRight, Nat.instShiftRightNat],[Nat, LT.lt, instLTNat, HMod.hMod, instHMod, Nat.instModNat, HShiftRight.hShiftRight, instHShiftRight, Nat.instShiftRightNat]]
[of_eq_true,[Eq, True, trivial, Eq.symm],[Eq, True]]
[Lean.version.patch,[Unit.unit],[Nat]]
[Lean.Parser.Tactic.tacticHave'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[System.FilePath.exeExtension,[ite, String, Eq, Bool, System.Platform.isWindows, Bool.true, instDecidableEqBool],[String]]
[Acc.inv,[Acc.inv.proof_1],[Acc]]
[Monad.noConfusionType,[Monad, Applicative, Bind, Eq],[Monad]]
[UInt64.ofNat,[UInt64.mk, Fin.ofNat, OfNat.ofNat, Nat, instOfNatNat],[UInt64]]
[instMonadExceptOfExceptT,[Monad, MonadExceptOf, MonadExceptOf.mk, ExceptT, ExceptT.mk, throwThe, Except, tryCatchThe],[Monad, MonadExceptOf, ExceptT]]
[Option.filter,[Bool, Option, ite, Eq, Bool.true, instDecidableEqBool, Option.some, Option.none, Unit],[Bool, Option]]
[List.enumFrom,[Nat, List, Prod, List.below, List.nil, List.cons, Prod.mk, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat],[Nat, List, Prod]]
[instDecidableIff.proof_2,[Not, Iff, Iff.mp],[Not, Iff, False]]
[UInt64.land,[UInt64, UInt64.mk, Fin.land, UInt64.size, UInt64.val],[UInt64]]
[instSubUInt16,[Sub.mk, UInt16, UInt16.sub],[Sub, UInt16]]
[Lean.Macro.withFreshMacroScope,[Lean.MacroM, Bind.bind, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.MacroScope, MonadState.modifyGet, instMonadState, instMonadStateOf, ReaderT.instMonadLiftReaderT, EStateM.instMonadStateOfEStateM, Prod.mk, Lean.Macro.State.macroScope, Lean.Macro.State.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Lean.Macro.State.traceMsgs, MonadWithReader.withReader, instMonadWithReader, instMonadWithReaderOfReaderT, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth, Lean.Macro.Context.ref],[Lean.MacroM]]
[Std.Format.bracketFill,[String, Std.Format, Std.Format.fill, Std.Format.nest, Int.ofNat, String.length, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text],[String, Std.Format]]
[Nat.lt_of_le_and_ne,[Nat, LE.le, instLENat, Ne, Or, Eq, LT.lt, instLTNat, Nat.eq_or_lt_of_le, absurd],[Nat, LE.le, instLENat, Ne, LT.lt, instLTNat]]
[MonadFunctorT.monadMap,[MonadFunctorT],[MonadFunctorT]]
[Lean.Parser.Tactic.Conv.convSeq,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.Parser.Tactic.Conv.convSeq1Indented, Lean.Parser.Tactic.Conv.convSeqBracketed],[Lean.ParserDescr]]
[Lean.Syntax.decodeScientificLitVal?,[String, String.Pos, Nat, Bool, Option, Prod, String.length, ite, Eq, BEq.beq, instBEq, instDecidableEqNat, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Option.none, Char, String.get, Char.isDigit, Lean.Syntax.decodeScientificLitVal?.decodeAfterExp, Lean.Syntax.decodeScientificLitVal?.decodeExp, Lean.Syntax.decodeScientificLitVal?.decodeAfterDot, Lean.Syntax.decodeScientificLitVal?.decode],[String, Option, Prod, Nat, Bool]]
[IO.Error.mkInappropriateTypeFile,[Function.comp, String, Option, UInt32, IO.Error, IO.Error.inappropriateType, Option.some],[String, UInt32, IO.Error]]
[eq_true_of_ne_false,[Bool, Not, Eq, Bool.false, Bool.true, rfl, False.elim],[Bool, Not, Eq, Bool.false, Bool.true]]
[DoResultPR.noConfusionType,[DoResultPR, Eq],[DoResultPR]]
[IO.Error.mkHardwareFault,[IO.Error.hardwareFault],[UInt32, String, IO.Error]]
[Lean.Syntax.setTailInfo,[Lean.Syntax, Lean.SourceInfo, Option, Lean.Syntax.setTailInfoAux, Unit],[Lean.Syntax, Lean.SourceInfo]]
[Lean.Syntax.matchesNull,[Lean.Syntax, Nat, Lean.Syntax.isNodeOf, Lean.nullKind],[Lean.Syntax, Nat, Bool]]
[Char.isAlpha,[Char, or, Char.isUpper, Char.isLower],[Char, Bool]]
[Monad.toApplicative,[Monad],[Monad, Applicative]]
[PUnit.eq_punit,[PUnit, PUnit.subsingleton, PUnit.unit],[PUnit, Eq, PUnit.unit]]
[List.filterAux,[Bool, List, List.below, List.nil, List.reverse, List.cons, Unit, PProd.fst, PUnit, PProd],[Bool, List]]
[UInt64.mk.sizeOf_spec,[Fin, UInt64.size, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[Fin, UInt64.size, Eq, Nat, SizeOf.sizeOf, UInt64, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, LT.lt, instLTNat, instSizeOfNat, instSizeOf, UInt64.mk]]
[Substring.atEnd,[Substring, String.Pos, Bool, String, BEq.beq, instBEq, instDecidableEqNat, HAdd.hAdd, instHAdd, instAddNat],[Substring, String.Pos, Bool]]
[Nat.succ_pos,[Nat, Nat.zero_lt_succ],[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, Nat.succ]]
[Sub.sub,[Sub],[Sub]]
[instDivUInt64,[Div.mk, UInt64, UInt64.div],[Div, UInt64]]
[Option.get!,[Inhabited, Option, Unit, panicWithPosWithDecl, OfNat.ofNat, Nat, instOfNatNat],[Inhabited, Option]]
[if_neg,[Decidable, Not, Eq, ite, absurd, Decidable.isTrue, rfl, Decidable.isFalse],[Decidable, Not, Eq, ite]]
[Lean.Name.str.inj,[Lean.Name, String, UInt64, Eq, Lean.Name.str, And, And.intro],[Lean.Name, String, UInt64, Eq, Lean.Name.str, And]]
[Or.intro_right,[Or.inr],[Or]]
[Nat.sub_lt,[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, absurd, Nat.lt_irrefl, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Eq.symm, Nat.succ_sub_succ_eq_sub],[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat]]
[instToStringSum,[ToString, ToString.mk, Sum, String, HAppend.hAppend, instHAppend, String.instAppendString, addParenHeuristic, ToString.toString],[ToString, Sum]]
[instToStringUInt16,[ToString.mk, UInt16, ToString.toString, Nat, instToStringNat, UInt16.toNat],[ToString, UInt16]]
[USize.sub,[USize, USize.mk, HSub.hSub, Fin, USize.size, instHSub, Fin.instSubFin, USize.val],[USize]]
[List.eraseReps,[BEq, List, Unit, List.nil, List.eraseRepsAux],[BEq, List]]
[Nat.any,[Nat, Bool, Nat.anyAux],[Nat, Bool]]
[Subarray.mk.sizeOf_spec,[SizeOf, Array, Nat, LE.le, instLENat, Array.size, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, instSizeOfNat, instSizeOf],[SizeOf, Array, Nat, LE.le, instLENat, Array.size, Eq, SizeOf.sizeOf, Subarray, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, List, instSizeOfNat, instSizeOf, Subarray.mk]]
[reprStr,[Repr, Std.Format.pretty, Repr.reprPrec, OfNat.ofNat, Nat, instOfNatNat, Std.Format.defWidth],[Repr, String]]
[Lean.Syntax.below,[Lean.Syntax, Array, List, PUnit, Lean.SyntaxNodeKind, PProd, Lean.SourceInfo, String, Substring, Lean.Name, Prod],[Lean.Syntax, Array, List]]
[StateT.instLawfulMonadStateT,[StateT.instLawfulMonadStateT.proof_1],[Monad, LawfulMonad, StateT, StateT.instMonadStateT]]
[OfScientific.noConfusionType,[OfScientific, Nat, Bool, Eq],[OfScientific]]
[Subtype.instInhabitedSubtype,[Inhabited.mk, Subtype, Subtype.mk],[Inhabited, Subtype]]
[instReprId_1,[Repr, inferInstanceAs],[Repr, Id]]
[ExceptT.ext,[Monad, ExceptT, Eq, Except, ExceptT.run, id],[Monad, ExceptT, Eq, Except, ExceptT.run]]
[List.replace,[BEq, List, List.below, List.nil, List.cons, Bool, BEq.beq, Unit, PProd.fst, PUnit, PProd],[BEq, List]]
[Lean.Parser.Tactic.tacticRefine_lift_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Nat.fold,[Nat, Nat.foldAux],[Nat]]
[Lean.Syntax.copyHeadTailInfoFrom,[Lean.Syntax, Lean.Syntax.setTailInfo, Lean.Syntax.setHeadInfo, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo],[Lean.Syntax]]
[MonadReaderOf.read,[MonadReaderOf],[MonadReaderOf]]
[BEq.beq,[BEq],[BEq, Bool]]
[instSubsingleton.proof_1,[Subsingleton.intro, proofIrrel],[Subsingleton]]
[Nat.succ_add,[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.below, rfl, OfNat.ofNat, instOfNatNat, congrArg, Nat.add, PProd.fst, PUnit, PProd],[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.succ]]
[Function.Equiv.trans,[Function.Equiv, Eq.trans],[Function.Equiv]]
[String.Iterator.isPrefixOfRemaining,[String.Iterator, String, String.Pos, String.Iterator.mk, Bool, Decidable.decide, Eq, String.extract, String.bsize, HAdd.hAdd, Nat, instHAdd, instAddNat, HSub.hSub, instHSub, instSubNat, instDecidableEqString],[String.Iterator, Bool]]
[List.append_nil,[List, Eq, HAppend.hAppend, instHAppend, List.instAppendList, List.nil, rfl, of_eq_true, List.cons, List.append, Eq.trans, True, congrFun, congrArg, id, eq_self],[List, Eq, HAppend.hAppend, instHAppend, List.instAppendList, List.nil]]
[Bool.false_and,[Bool, Eq, and, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl],[Bool, Eq, and, Bool.false]]
[Lean.Parser.Tactic.simpPre,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Name.instReprName,[Repr.mk, Lean.Name, Lean.Name.reprPrec],[Repr, Lean.Name]]
[Array.forInUnsafe,[Monad, Array, ForInStep, USize, USize.ofNat, Array.size, OfNat.ofNat, instOfNatUSize, Array.forInUnsafe.loop],[Monad, Array, ForInStep]]
[Char.utf8Size,[Char, UInt32, Char.val, ite, LE.le, instLEUInt32, UInt32.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, Char.utf8Size.proof_1, instDecidableLe, Char.utf8Size.proof_2, Char.utf8Size.proof_3, Char.utf8Size.proof_4, Char.utf8Size.proof_5, Char.utf8Size.proof_6, Char.utf8Size.proof_7],[Char, UInt32]]
[Ordering.isLE,[Ordering, Bool, Unit, Bool.true, Bool.false],[Ordering, Bool]]
[PointedType.type,[PointedType],[PointedType]]
[Iff.rfl,[Iff.refl],[Iff]]
[prodHasDecidableLt,[LT, DecidableEq, Decidable, LT.lt, Prod, inferInstanceAs, Or, Prod.fst, And, Eq, Prod.snd, instDecidableOr, instDecidableAnd],[LT, DecidableEq, Decidable, LT.lt, Prod, instLTProd]]
[Substring.toIterator,[Substring, String.Iterator, String, String.Pos, String.Iterator.mk],[Substring, String.Iterator]]
[Float.noConfusionType,[Float, FloatSpec.float, floatSpec, Eq],[Float]]
[Array.foldlM.proof_1,[Array, Nat.le_refl, Array.size],[Array, LE.le, Nat, instLENat, Array.size]]
[dite,[Decidable, Not],[Decidable, Not]]
[IO.Process.Output.stderr,[IO.Process.Output],[IO.Process.Output, String]]
[List.mapM,[Monad, List, List.below, Unit, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, List.cons, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd],[Monad, List]]
[Task.spawn,[Unit, optParam, Task.Priority, Task.Priority.default, Task.pure, Unit.unit],[Unit, optParam, Task.Priority, Task.Priority.default, Task]]
[IO.Error.interrupted.inj,[String, UInt32, Eq, IO.Error, IO.Error.interrupted, And, And.intro],[String, UInt32, Eq, IO.Error, IO.Error.interrupted, And]]
[Subarray.foldl,[Subarray, Id.run, Subarray.foldlM, Id, Id.instMonadId],[Subarray]]
[Int.instDecidableEqInt,[Int.decEq],[DecidableEq, Int]]
[coeOfHeafOfTCOfTail,[CoeHead, CoeTail, CoeTC, CoeHTCT.mk, coeTail, coeTC, coeHead],[CoeHead, CoeTail, CoeTC, CoeHTCT]]
[instInhabitedOption,[Inhabited.mk, Option, Option.none],[Inhabited, Option]]
[List.instLTList,[LT, LT.mk, List, List.lt],[LT, List]]
[List.tail?,[List, Option, Unit, Option.none, Option.some],[List, Option]]
[floatDecLt,[Float, Float.decLt],[Float, Decidable, LT.lt, instLTFloat]]
[Bool.noConfusionType,[Bool],[Bool]]
[Fin.mk.inj,[Nat, LT.lt, instLTNat, Eq, Fin, Fin.mk],[Nat, LT.lt, instLTNat, Eq, Fin, Fin.mk]]
[CoeSort.noConfusionType,[outParam, CoeSort, Eq],[outParam, CoeSort]]
[UInt32.modn,[UInt32, UInt32.mk, HMod.hMod, Fin, UInt32.size, Nat, Fin.instHModFinNatFin, UInt32.val],[UInt32]]
[«term_::_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instReprString,[Repr.mk, String, Nat, Std.Format.text, String.quote],[Repr, String]]
[instAddNat,[Add.mk, Nat, Nat.add],[Add, Nat]]
[USize.ofNat,[USize.mk, Fin.ofNat', USize.size, usize_size_gt_zero],[USize]]
[List.reverse_nil,[rfl, List, List.reverse, List.nil],[Eq, List, List.reverse, List.nil]]
[Lean.Parser.Tactic.simpStar,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[System.instReprFilePath,[Repr.mk, System.FilePath, Repr.addAppParen, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.text, repr, String, instReprString, System.FilePath.toString],[Repr, System.FilePath]]
[PSum.inl.inj,[Eq, PSum, PSum.inl],[Eq, PSum, PSum.inl]]
[«term_=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[EIO.toIO',[EIO, EIO.toIO, Except, panicWithPosWithDecl, IO.Error, IO.instInhabitedError, OfNat.ofNat, Nat, instOfNatNat, observing, instMonadEIO, instMonadExcept, instMonadExceptOfEIO],[EIO, IO, Except]]
[Lean.Parser.Tactic.tacticLet'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.MonadQuotation.addMacroScope,[Lean.MonadQuotation, Monad, Lean.Name, Bind.bind, Monad.toBind, Lean.MonadQuotation.getMainModule, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.addMacroScope],[Lean.MonadQuotation, Monad, Lean.Name]]
[instReprUInt16,[Repr.mk, UInt16, Nat, repr, instReprNat, UInt16.toNat],[Repr, UInt16]]
[StateT.map,[Monad, StateT, Bind.bind, Monad.toBind, Prod, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk],[Monad, StateT]]
[Subtype.mk.inj,[Eq, Subtype, Subtype.mk],[Eq, Subtype, Subtype.mk]]
[instDivUInt32,[Div.mk, UInt32, UInt32.div],[Div, UInt32]]
[ExceptT.map,[Monad, ExceptT, ExceptT.mk, Bind.bind, Monad.toBind, Except, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.ok, Except.error],[Monad, ExceptT]]
[IO.FS.Stream.flush,[IO.FS.Stream],[IO.FS.Stream, IO, Unit]]
[Array.anyMUnsafe,[Monad, Bool, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, USize, ite, LT.lt, instLTNat, Nat.decLt, LE.le, instLENat, Nat.decLe, USize.ofNat, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.false, Array.anyMUnsafe.any],[Monad, Bool, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size]]
[Lean.Syntax.ibelow,[Lean.Syntax, Array, List, True, Lean.SyntaxNodeKind, And, Lean.SourceInfo, String, Substring, Lean.Name, Prod],[Lean.Syntax, Array, List]]
[ExceptCpsT.runCatch_throw,[Monad, rfl, ExceptCpsT.runCatch, MonadExcept.throw, ExceptCpsT, instMonadExcept, ExceptCpsT.instMonadExceptOfExceptCpsT],[Monad, Eq, ExceptCpsT.runCatch, MonadExcept.throw, ExceptCpsT, instMonadExcept, ExceptCpsT.instMonadExceptOfExceptCpsT, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[String.Iterator.extract,[String.Iterator, String, String.Pos, String.Iterator.mk, ite, Eq, Bool, or, Decidable.decide, Ne, instDecidableNot, instDecidableEqString, GT.gt, instLTNat, Nat.decLt, Bool.true, instDecidableEqBool, String.extract],[String.Iterator, String]]
[Ne,[Not, Eq],[]]
[IO.Error.permissionDenied.injEq,[Option, String, UInt32, Eq.propIntro, Eq, IO.Error, IO.Error.permissionDenied, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Option, String, UInt32, Eq, IO.Error, IO.Error.permissionDenied, And]]
[HAnd.hAnd,[HAnd],[HAnd]]
[List.mapA,[Applicative, List, List.below, Unit, List.nil, Pure.pure, Applicative.toPure, List.cons, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, PProd.fst, PUnit, PProd],[Applicative, List]]
[Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat, Nat.lt_of_lt_of_le],[Nat, LT.lt, instLTNat, LE.le, instLENat]]
[instInhabitedPNonScalar,[Inhabited.mk, PNonScalar, PNonScalar.mk, arbitrary, Nat, instInhabitedNat],[Inhabited, PNonScalar]]
[UInt16.mk.sizeOf_spec,[Fin, UInt16.size, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[Fin, UInt16.size, Eq, Nat, SizeOf.sizeOf, UInt16, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, LT.lt, instLTNat, instSizeOfNat, instSizeOf, UInt16.mk]]
[Classical.epsilon,[Nonempty, Subtype.val, Exists, Classical.strongIndefiniteDescription],[Nonempty]]
[instReprId,[Repr, inferInstanceAs],[Repr, id]]
[EStateM.map,[EStateM, EStateM.Result, EStateM.Result.ok, EStateM.Result.error],[EStateM]]
[ExceptT,[Except],[]]
[EStateM.instToStringResult,[ToString, ToString.mk, EStateM.Result, String, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString],[ToString, EStateM.Result]]
[guard,[Alternative, Decidable, ite, Unit, Pure.pure, Applicative.toPure, Alternative.toApplicative, Unit.unit, Alternative.failure],[Alternative, Decidable, Unit]]
[Decidable.em,[Decidable, Decidable.byCases, Or, Not, Or.inl, Or.inr],[Decidable, Or, Not]]
[IO.Error.illegalOperation.sizeOf_spec,[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar],[UInt32, String, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, Option, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.illegalOperation]]
[Array.modifyM.proof_1,[Inhabited, Array, Nat, LT.lt, instLTNat, Array.size, Eq.symm, Array.set, Fin.mk, arbitrary, Array.size_set],[Inhabited, Array, Nat, LT.lt, instLTNat, Array.size, Eq, Array.set, Fin.mk, arbitrary]]
[unsafeEIO,[EIO, EStateM.Result, IO.RealWorld, Except, EStateM.run, Unit.unit, Except.ok, Except.error],[EIO, Except]]
[instOrdInt,[Ord.mk, Int, compareOfLessAndEq, Int.instLTInt, Int.decLt, Int.instDecidableEqInt],[Ord, Int]]
[eq_true,[propext, True, Iff.intro, trivial],[Eq, True]]
[Array.eraseIdx,[Array, Nat, ite, LT.lt, instLTNat, Array.size, Nat.decLt, Array.eraseIdxAux, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat],[Array, Nat]]
[EStateM.run',[EStateM, EStateM.Result, Option, EStateM.run, Option.some, Option.none],[EStateM, Option]]
[IO.Error.illegalOperation.inj,[UInt32, String, Eq, IO.Error, IO.Error.illegalOperation, And, And.intro],[UInt32, String, Eq, IO.Error, IO.Error.illegalOperation, And]]
[String.atEnd,[String, String.Pos, Bool, Decidable.decide, GE.ge, instLENat, String.utf8ByteSize, Nat.decLe],[Bool]]
[List.hasDecidableLt,[LT, DecidableRel, LT.lt, List, Decidable, List.instLTList, List.below, Unit, List.nil, Decidable.isFalse, List.hasDecidableLt.proof_1, Decidable.isTrue, List.cons, List.lt.nil, List.hasDecidableLt.proof_2, List.lt.head, Not, List.hasDecidableLt.proof_3, PProd.fst, PUnit, PProd, List.lt.tail, List.hasDecidableLt.proof_4],[LT, DecidableRel, LT.lt, List, Decidable, List.instLTList]]
[String.splitOn,[String, optParam, ite, List, Eq, Bool, BEq.beq, instBEq, instDecidableEqString, Bool.true, instDecidableEqBool, List.cons, List.nil, String.splitOnAux, OfNat.ofNat, String.Pos, instOfNatNat],[String, optParam, List]]
[«termΣ'_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Thunk.noConfusionType,[Thunk, Unit, Eq],[Thunk]]
[Quotient.recOnSubsingleton₂.proof_1,[Setoid, Quotient, Subsingleton, Quotient.mk, Quot.recOnSubsingleton, Setoid.r, Quot.mk, inferInstance, instSubsingleton],[Setoid, Quotient, Subsingleton, Quotient.mk, Quot.mk, Setoid.r]]
[EStateM.adaptExcept,[EStateM, EStateM.Result, EStateM.Result.error, EStateM.Result.ok],[EStateM]]
[Subrelation.wf.proof_1,[Subrelation, WellFounded, WellFounded.intro, Subrelation.accessible, WellFounded.apply],[Subrelation, WellFounded]]
[isValidChar,[UInt32, Or, LT.lt, instLTUInt32, OfNat.ofNat, instOfNatUInt32, And],[UInt32]]
[instSubUInt8,[Sub.mk, UInt8, UInt8.sub],[Sub, UInt8]]
[Nat.succ_mul,[Nat, Eq, HMul.hMul, instHMul, instMulNat, Nat.succ, HAdd.hAdd, instHAdd, instAddNat, rfl, Nat.zero, Eq.mpr, Eq.refl, Nat.mul_succ, Nat.add_succ, Nat.add_right_comm],[Nat, Eq, HMul.hMul, instHMul, instMulNat, Nat.succ, HAdd.hAdd, instHAdd, instAddNat]]
[UInt16.decEq,[UInt16, Decidable, Eq, Fin, UInt16.size, dite, UInt16.mk, instDecidableEqFin, Decidable.isTrue, UInt16.decEq.proof_1, Not, Decidable.isFalse, UInt16.decEq.proof_2],[UInt16, Decidable, Eq]]
[Substring.isEmpty,[Substring, BEq.beq, Nat, instBEq, instDecidableEqNat, Substring.bsize, OfNat.ofNat, instOfNatNat],[Substring, Bool]]
[String.join,[List, String, List.foldl, HAppend.hAppend, instHAppend, String.instAppendString],[List, String]]
[Int.instModInt,[Mod.mk, Int, Int.mod],[Mod, Int]]
[instToStringSubarray,[ToString, ToString.mk, Subarray, ToString.toString, Array, Array.instToStringArray, Subarray.toArray],[ToString, Subarray]]
[UInt8.mk.sizeOf_spec,[Fin, UInt8.size, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[Fin, UInt8.size, Eq, Nat, SizeOf.sizeOf, UInt8, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, LT.lt, instLTNat, instSizeOfNat, instSizeOf, UInt8.mk]]
[PSigma.noConfusionType,[PSigma, Eq, HEq],[PSigma]]
[Lean.Syntax.getPos?,[Lean.Syntax, optParam, Bool, Bool.false, Lean.SourceInfo.getPos?, Lean.Syntax.getHeadInfo],[Lean.Syntax, optParam, Bool, Bool.false, Option, String.Pos]]
[instToStreamArraySubarray,[ToStream.mk, Array, Subarray, Array.toSubarray, OfNat.ofNat, optParam, Nat, instOfNatNat, Array.size],[ToStream, Array, Subarray]]
[Float.mk.injEq,[FloatSpec.float, floatSpec, Eq.propIntro, Eq, Float, Float.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[FloatSpec.float, floatSpec, Eq, Float, Float.mk]]
[instHXor,[Xor, HXor.mk, Xor.xor],[Xor, HXor]]
[instHMod,[Mod, HMod.mk, Mod.mod],[Mod, HMod]]
[Array.appendCore.loop,[Array, Nat, Nat.below, dite, LT.lt, instLTNat, Array.size, Nat.decLt, Unit, Nat.succ, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.push, Array.get, Fin.mk, Not],[Array, Nat]]
[and_self,[propext, And, Iff.intro, And.left, And.intro],[Eq, And]]
[HMul.hMul,[HMul],[HMul]]
[implies_congr,[Eq, rfl],[Eq]]
[Lean.version.minor,[Unit.unit],[Nat]]
[List.reverseAux_reverseAux_nil,[List, Eq, List.reverseAux, List.nil, rfl, of_eq_true, List.cons, Eq.trans, True, congrFun, congrArg, eq_self],[List, Eq, List.reverseAux, List.nil]]
[List.toArrayAux,[List, Array, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd, Array.push],[List, Array]]
[Lean.withRef,[Monad, Lean.MonadRef, Lean.Syntax, Bind.bind, Monad.toBind, Lean.MonadRef.getRef, Lean.replaceRef, Lean.MonadRef.withRef],[Monad, Lean.MonadRef, Lean.Syntax]]
[«termΣ_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[UInt16.mul,[UInt16, UInt16.mk, HMul.hMul, Fin, UInt16.size, instHMul, Fin.instMulFin, UInt16.val],[UInt16]]
[String.revFind,[String, Char, Bool, ite, Option, String.Pos, Eq, BEq.beq, Nat, instBEq, instDecidableEqNat, String.bsize, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Option.none, String.revFindAux, String.prev],[String, Char, Bool, Option, String.Pos]]
[Nat.le_step,[Nat, LE.le, instLENat, Nat.le.step],[Nat, LE.le, instLENat, Nat.succ]]
[Lean.unifConstraintElem,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.unifConstraint, Lean.ParserDescr.unary, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Nat.mod_zero,[Nat],[Nat, Eq, HMod.hMod, instHMod, Nat.instModNat, OfNat.ofNat, instOfNatNat]]
[Char.utf8Size.proof_7,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size]]
[DoResultSBC.break.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, DoResultSBC, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, DoResultSBC.break]]
[EStateM.dummyRestore,[PUnit],[PUnit]]
[instMonadControlStateRefT',[inferInstanceAs, MonadControl, ReaderT, ST.Ref, instMonadControlReaderT],[MonadControl, StateRefT']]
[List.allM,[Monad, Bool, List, List.below, Unit, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.true, List.cons, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd, Bool.false],[Monad, Bool, List]]
[Quotient.exists_rep,[Setoid, Quotient, Quot.exists_rep, Setoid.r],[Setoid, Quotient, Exists, Eq, Quotient.mk]]
[List.length,[List, Nat, List.below, Unit, List.nil, OfNat.ofNat, instOfNatNat, List.cons, HAdd.hAdd, instHAdd, instAddNat, PProd.fst, PUnit, PProd],[List, Nat]]
[Coe.coe,[Coe],[Coe]]
[IO.FileRight.noConfusionType,[IO.FileRight, IO.AccessRight, Eq],[IO.FileRight]]
[Std.Format.joinSuffix,[Std.ToFormat, List, Std.Format, List.below, List.nil, Std.Format.nil, List.cons, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.ToFormat.format, PProd.fst, PUnit, PProd],[Std.ToFormat, List, Std.Format]]
[Array.mapIdxM.map.proof_1,[Array, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Eq.mpr, LT.lt, instLTNat, Eq.refl, Eq.symm, Nat.add_assoc, Nat.add_comm, Nat.le_add_right, Nat.succ],[Array, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, LT.lt, instLTNat]]
[StateT.run_set,[Monad, rfl, Prod, PUnit, StateT.run, MonadStateOf.set, StateT, instMonadStateOfStateT],[Monad, Eq, Prod, PUnit, StateT.run, MonadStateOf.set, StateT, instMonadStateOfStateT, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk, PUnit.unit]]
[Subtype.existsOfSubtype.proof_1,[Subtype, Exists, Exists.intro],[Subtype, Exists]]
[Nat.instModNat,[Mod.mk, Nat, Nat.mod],[Mod, Nat]]
[IO.Process.SpawnArgs.mk.injEq,[IO.Process.StdioConfig, String, Array, Option, System.FilePath, Prod, Eq.propIntro, Eq, IO.Process.SpawnArgs, IO.Process.SpawnArgs.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[IO.Process.StdioConfig, String, Array, Option, System.FilePath, Prod, Eq, IO.Process.SpawnArgs, IO.Process.SpawnArgs.mk, And]]
[List.instLEList,[LT, LE.mk, List, List.le],[LT, LE, List]]
[andM,[Monad, ToBool, Bind.bind, Monad.toBind, Bool, ToBool.toBool, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative],[Monad, ToBool]]
[Std.Format.append.inj,[Std.Format, Eq, Std.Format.append, And, And.intro],[Std.Format, Eq, Std.Format.append, And]]
[Bind.bind,[Bind],[Bind]]
[Quot.hrecOn.proof_1,[Quot, Quot.mk, HEq, eq_of_heq, Quot.sound],[Quot, Quot.mk, HEq, Eq, Quot.sound]]
[Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp.proof_1,[Nat, Nat.le_trans],[Nat, LE.le, instLENat]]
[Lean.Macro.instInhabitedState,[Inhabited.mk, Lean.Macro.State, Lean.Macro.State.mk, arbitrary, Lean.MacroScope, instInhabitedNat, List, Prod, Lean.Name, String, instInhabitedList],[Inhabited, Lean.Macro.State]]
[Array.mk.sizeOf_spec,[SizeOf, List, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk],[SizeOf, List, Eq, Nat, SizeOf.sizeOf, Array, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.mk]]
[Lean.MonadQuotation.toMonadRef,[Lean.MonadQuotation],[Lean.MonadQuotation, Lean.MonadRef]]
[bfix4,[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd],[Nat]]
[Squash.mk,[Quot.mk, True],[Squash]]
[Prod.lexAccessible.proof_1,[Acc, Prod, Prod.Lex, Prod.mk, Acc.intro, Eq, HEq, Prod.Lex.left, Eq.symm, eq_of_heq, Prod.Lex.right, Eq.refl, HEq.refl],[Acc, Prod, Prod.Lex, Prod.mk]]
[StateT.run_lift,[Monad, rfl, Prod, StateT.run, StateT.lift],[Monad, Eq, Prod, StateT.run, StateT.lift, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk]]
[«term_!=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[DoResultBC.continue.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, DoResultBC, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, DoResultBC.continue]]
[Lean.MonadQuotation.withFreshMacroScope,[Lean.MonadQuotation],[Lean.MonadQuotation]]
[Fin.instShiftLeftFin,[Nat, ShiftLeft.mk, Fin, Fin.shiftLeft],[Nat, ShiftLeft, Fin]]
[LawfulFunctor.comp_map,[Functor, LawfulFunctor],[Functor, LawfulFunctor, Eq, Functor.map, Function.comp]]
[Nat.toUInt64,[UInt64.ofNat],[UInt64]]
[Lean.Parser.Tactic.tacticRepeat_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[StateT.instMonadStateT,[Monad, Monad.mk, StateT, Applicative.mk, Functor.mk, StateT.map, Pure.mk, StateT.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk, StateT.bind],[Monad, StateT]]
[instOrdUInt16,[Ord.mk, UInt16, compareOfLessAndEq, instLTUInt16, instDecidableLt_2, instDecidableEqUInt16],[Ord, UInt16]]
[UInt16.shiftRight,[UInt16, UInt16.mk, HShiftRight.hShiftRight, Fin, UInt16.size, instHShiftRight, Fin.instShiftRightFin, UInt16.val, UInt16.modn, OfNat.ofNat, Nat, instOfNatNat],[UInt16]]
[Char.isValidChar_zero,[Or.inl, LT.lt, UInt32, instLTUInt32, OfNat.ofNat, instOfNatUInt32, And, of_decide_eq_true, instDecidableLt, Eq.refl, Bool, Bool.true],[isValidChar, OfNat.ofNat, UInt32, instOfNatUInt32]]
[instOrdUInt32,[Ord.mk, UInt32, compareOfLessAndEq, instLTUInt32, instDecidableLt, instDecidableEqUInt32],[Ord, UInt32]]
[LawfulApplicative.seqLeft_eq,[Applicative, LawfulApplicative],[Applicative, LawfulApplicative, Eq, SeqLeft.seqLeft, Applicative.toSeqLeft, Unit, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const]]
[ReaderT.bind,[Monad, ReaderT, Bind.bind, Monad.toBind],[Monad, ReaderT]]
[Squash.ind,[Squash, Squash.mk, Quot.ind, True],[Squash, Squash.mk]]
[Fin.instMulFin,[Nat, Mul.mk, Fin, Fin.mul],[Nat, Mul, Fin]]
[EStateM.instInhabitedResult,[Inhabited, Inhabited.mk, EStateM.Result, EStateM.Result.error, arbitrary],[Inhabited, EStateM.Result]]
[Applicative.toSeqRight,[Applicative],[Applicative, SeqRight]]
[Std.Format.group.inj,[Std.Format, Std.Format.FlattenBehavior, Eq, Std.Format.group, And, optParam, Std.Format.FlattenBehavior.allOrNone, And.intro],[Std.Format, Std.Format.FlattenBehavior, Eq, Std.Format.group, And]]
[Quot.liftOn,[Quot, Eq, Quot.lift],[Quot, Eq]]
[strictAnd,[Bool, and],[Bool]]
[Nat.right_distrib,[Nat],[Nat, Eq, HMul.hMul, instHMul, instMulNat, HAdd.hAdd, instHAdd, instAddNat]]
[Array.isPrefixOf,[BEq, Array, dite, Bool, LE.le, Nat, instLENat, Array.size, Nat.decLe, Array.isPrefixOfAux, OfNat.ofNat, instOfNatNat, Not, Bool.false],[BEq, Array, Bool]]
[instInhabitedArrow_1,[Monad, Inhabited.mk, Pure.pure, Applicative.toPure, Monad.toApplicative],[Monad, Inhabited]]
[Lean.Parser.Tactic.rotateLeft,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[dif_pos,[Decidable, Not, Eq, dite, rfl, Decidable.isTrue, absurd, Decidable.isFalse],[Decidable, Not, Eq, dite]]
[solve,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[instToStringFin,[Nat, ToString.mk, Fin, ToString.toString, instToStringNat, Fin.val],[Nat, ToString, Fin]]
[instCoeTail_1,[outParam, CoeSort, CoeTail.mk, coeSort],[outParam, CoeSort, CoeTail]]
[Lean.Parser.Tactic.tacticTry_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[instOrdString,[Ord.mk, String, compareOfLessAndEq, String.instLTString, String.decLt, instDecidableEqString],[Ord, String]]
[instDecidableEqProd.proof_2,[Not, Eq, Prod, Prod.mk, False, absurd],[Not, Eq, Prod, Prod.mk, False]]
[throwThe,[MonadExceptOf, MonadExceptOf.throw],[MonadExceptOf]]
[WellFounded.apply,[WellFounded.apply.proof_1],[WellFounded, Acc]]
[fixCore2,[bfix2, USize.size],[]]
[IO.FileRight.user,[IO.FileRight],[IO.FileRight, IO.AccessRight]]
[UInt32.decEq,[UInt32, Decidable, Eq, Fin, UInt32.size, dite, UInt32.mk, instDecidableEqFin, Decidable.isTrue, UInt32.decEq.proof_1, Not, Decidable.isFalse, UInt32.decEq.proof_2],[UInt32, Decidable, Eq]]
[Lean.mkFreshId,[Monad, Lean.MonadNameGenerator, Bind.bind, Monad.toBind, Lean.NameGenerator, Lean.Name, Lean.MonadNameGenerator.getNGen, Lean.NameGenerator.curr, Unit, Lean.MonadNameGenerator.setNGen, Lean.NameGenerator.next, PUnit, Pure.pure, Applicative.toPure, Monad.toApplicative],[Monad, Lean.MonadNameGenerator, Lean.Name]]
[Sigma.noConfusionType,[Sigma, Eq, HEq],[Sigma]]
[List.lengthTRAux,[List, Nat, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd, Nat.succ],[List, Nat]]
[Nonempty.elim.proof_1,[Nonempty],[Nonempty]]
[Bool.true.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, Bool, SizeOf.mk, OfNat.ofNat, instOfNatNat, Bool.true]]
[autoParam,[Lean.Syntax],[Lean.Syntax]]
[IO.FS.instLTSystemTime,[ltOfOrd, IO.FS.SystemTime, IO.FS.instOrdSystemTime],[LT, IO.FS.SystemTime]]
[Substring.trim,[Substring, String, String.Pos, Char.isWhitespace, Substring.mk],[Substring]]
[Subarray.any,[Bool, Subarray, Id.run, Subarray.anyM, Id, Id.instMonadId],[Bool, Subarray]]
[Subsingleton.elim,[Subsingleton.elim.proof_1],[Subsingleton, Eq]]
[IO.FS.FileType.symlink.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, IO.FS.FileType, SizeOf.mk, OfNat.ofNat, instOfNatNat, IO.FS.FileType.symlink]]
[String.Iterator.curr,[String.Iterator, Char, String, String.Pos, String.get],[String.Iterator, Char]]
[ST.Ref.mk.sizeOf_spec,[SizeOf, PointedType.type, ST.RefPointed, Nonempty, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOf],[SizeOf, PointedType.type, ST.RefPointed, Nonempty, Eq, Nat, SizeOf.sizeOf, ST.Ref, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, instSizeOf, ST.Ref.mk]]
[MonadWithReader.withReader,[MonadWithReader],[MonadWithReader]]
[instHShiftRight,[ShiftRight, HShiftRight.mk, ShiftRight.shiftRight],[ShiftRight, HShiftRight]]
[OptionT.bind,[Monad, OptionT, OptionT.mk, Bind.bind, Monad.toBind, Option, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.none],[Monad, OptionT]]
[HXor.noConfusionType,[outParam, HXor, Eq],[outParam, HXor]]
[ite_false,[rfl, ite, False, instDecidableFalse],[Eq, ite, False, instDecidableFalse]]
[PLift.up_down,[PLift, Eq, PLift.up, PLift.down, rfl],[PLift, Eq, PLift.up, PLift.down]]
[System.FilePath.fileStem,[System.FilePath, Option.map, String, Option, String.Pos, String.revPosOf, Char.ofNat, Unit, String.extract, OfNat.ofNat, instOfNatNat, System.FilePath.fileName],[System.FilePath, Option, String]]
[Char.val_ne_of_ne,[Char, Not, Eq, UInt32, Char.val, absurd, False, Char.eq_of_val_eq],[Char, Not, Eq, UInt32, Char.val]]
[instInhabitedSort,[Inhabited.mk, PUnit],[Inhabited]]
[ShiftRight.noConfusionType,[ShiftRight, Eq],[ShiftRight]]
[Array.binSearchContains,[Inhabited, Array, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Array.size, ite, LT.lt, instLTNat, Nat.decLt, Array.binSearchAux, instInhabitedBool, Option.isSome, Bool.false],[Inhabited, Array, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Array.size]]
[Lean.Parser.Tactic.intros,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[instSubsingletonStateM,[instSubsingletonStateM.proof_1],[Subsingleton, StateM]]
[boolToProp,[Coe.mk, Bool, Eq, Bool.true],[Coe, Bool]]
[«term_≈_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[ReaderT.run_pure,[Monad, rfl, ReaderT.run, Pure.pure, ReaderT, Applicative.toPure, Monad.toApplicative, ReaderT.instMonadReaderT],[Monad, Eq, ReaderT.run, Pure.pure, ReaderT, Applicative.toPure, Monad.toApplicative, ReaderT.instMonadReaderT]]
[Fin.shiftLeft,[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, HShiftLeft.hShiftLeft, instHShiftLeft, Nat.instShiftLeftNat, Fin.shiftLeft.proof_1],[Nat, Fin]]
[Lean.Syntax.getKind,[Lean.Syntax, Lean.SyntaxNodeKind, Array, Unit, Lean.Name.mkStr, Lean.Name.anonymous, Lean.SourceInfo, String, Lean.Name.mkSimple, Substring, Lean.Name, List, Prod, Lean.identKind],[Lean.Syntax, Lean.SyntaxNodeKind]]
[Std.Range.mk.injEq,[Nat, Eq.propIntro, Eq, Std.Range, Std.Range.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Nat, Eq, Std.Range, Std.Range.mk, And]]
[MonadControlT.stM,[MonadControlT],[MonadControlT]]
[instShiftLeftUInt8,[ShiftLeft.mk, UInt8, UInt8.shiftLeft],[ShiftLeft, UInt8]]
[liftCoeM,[MonadLiftT, CoeT, Monad, Bind.bind, Monad.toBind, liftM, Pure.pure, Applicative.toPure, Monad.toApplicative, coe],[MonadLiftT, CoeT, Monad]]
[String.csize,[Char, UInt32.toNat, Char.utf8Size],[Char, Nat]]
[Sigma.fst,[Sigma],[Sigma]]
[Array.mapSepElemsM,[Monad, Array, Lean.Syntax, OfNat.ofNat, Nat, instOfNatNat, List.toArray, List.nil],[Monad, Array, Lean.Syntax]]
[EStateM.Backtrackable.noConfusionType,[outParam, EStateM.Backtrackable, Eq],[outParam, EStateM.Backtrackable]]
[List.get,[List, Nat, LT.lt, instLTNat, List.length, List.below, List.nil, absurd, Nat.not_lt_zero, OfNat.ofNat, instOfNatNat, List.cons, Nat.succ],[List, Nat, LT.lt, instLTNat, List.length]]
[IO.withStdout,[Monad, MonadFinally, MonadLiftT, IO, IO.FS.Stream, Bind.bind, Monad.toBind, liftM, EIO, IO.Error, IO.setStdout, tryFinally, PUnit, Applicative.toFunctor, Monad.toApplicative, Functor.discard],[Monad, MonadFinally, MonadLiftT, IO, IO.FS.Stream]]
[Lean.Parser.Tactic.inductionAlts,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlt],[Lean.ParserDescr]]
[HAdd.noConfusionType,[outParam, HAdd, Eq],[outParam, HAdd]]
[USize.noConfusionType,[USize, Fin, USize.size, Eq],[USize]]
[instHMul,[Mul, HMul.mk, Mul.mul],[Mul, HMul]]
[id_eq,[rfl, id],[Eq, id]]
[Append.noConfusionType,[Append, Eq],[Append]]
[IO.AccessRight.mk.injEq,[Bool, Eq.propIntro, Eq, IO.AccessRight, IO.AccessRight.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Bool, Eq, IO.AccessRight, IO.AccessRight.mk, And]]
[Array.modifyOp,[Inhabited, Array, Nat, Array.modify],[Inhabited, Array, Nat]]
[usize_size_eq,[],[Or, Eq, Nat, USize.size, OfNat.ofNat, instOfNatNat]]
[UInt64.toUInt16,[UInt64, Nat.toUInt16, UInt64.toNat],[UInt64, UInt16]]
[Int.instNegInt,[Neg.mk, Int, Int.neg],[Neg, Int]]
[String.isPrefixOf,[String, String.Pos, Bool, and, Decidable.decide, LE.le, Nat, instLENat, String.length, Nat.decLe, OfNat.ofNat, instOfNatNat, String.isPrefixOf.loop],[String, Bool]]
[IO.Process.SpawnArgs.mk.inj,[IO.Process.StdioConfig, String, Array, Option, System.FilePath, Prod, Eq, IO.Process.SpawnArgs, IO.Process.SpawnArgs.mk, And, And.intro],[IO.Process.StdioConfig, String, Array, Option, System.FilePath, Prod, Eq, IO.Process.SpawnArgs, IO.Process.SpawnArgs.mk, And]]
[instInhabitedExceptT,[Monad, Inhabited, Inhabited.mk, ExceptT, MonadExcept.throw, instMonadExcept, instMonadExceptOfExceptT_1, arbitrary],[Monad, Inhabited, ExceptT]]
[Lean.Name.replacePrefix,[Lean.Name, Lean.Name.below, Lean.Name.anonymous, String, UInt64, namedPattern, Lean.Name.str, ite, Eq, Bool, BEq.beq, Lean.Name.instBEqName, Bool.true, instDecidableEqBool, Lean.Name.mkStr, PProd.fst, PUnit, PProd, Nat, Lean.Name.num, Lean.Name.mkNum],[Lean.Name]]
[Lean.Syntax.isNatLit?,[Lean.Syntax, Lean.SyntaxNodeKind, Option, String, Option.some, Option.none, Nat, Lean.Syntax.isLit?, Lean.Syntax.decodeNatLitVal?, Lean.numLitKind],[Lean.Syntax, Option, Nat]]
[IO.Process.Output.noConfusionType,[IO.Process.Output, UInt32, String, Eq],[IO.Process.Output]]
[instDecidableLe_2,[UInt16, UInt16.decLe],[UInt16, Decidable, LE.le, instLEUInt16]]
[instPowNatNat,[Pow.mk, Nat, Nat.pow],[Pow, Nat]]
[Array.foldrMUnsafe.fold,[Monad, Array, USize, ite, Eq, Bool, BEq.beq, instBEq, instDecidableEqUSize, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, Bind.bind, Monad.toBind, Array.uget, HSub.hSub, instHSub, instSubUSize, OfNat.ofNat, instOfNatUSize, lcProof, LT.lt, Nat, instLTNat, USize.toNat, Array.size, Array.foldrMUnsafe.fold],[Monad, Array, USize]]
[calc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, calcStep, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Option.getD,[Option],[Option]]
[heq_of_heq_of_eq,[HEq, Eq, HEq.trans, heq_of_eq],[HEq, Eq]]
[Nat.add_comm,[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.below, Eq.symm, OfNat.ofNat, instOfNatNat, Nat.zero_add, Nat.succ],[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat]]
[Std.Format.isNil,[Std.Format, Bool, Unit, Bool.true, Bool.false],[Std.Format, Bool]]
[instToStringExcept,[ToString, ToString.mk, Except, String, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString],[ToString, Except]]
[instSubsingletonPUnit,[Subsingleton.intro, PUnit, PUnit.subsingleton],[Subsingleton, PUnit]]
[Std.Format.FlattenBehavior.noConfusionType,[Std.Format.FlattenBehavior, noConfusionTypeEnum, Nat, instDecidableEqNat, Std.Format.FlattenBehavior.toCtorIdx],[Std.Format.FlattenBehavior]]
[Char.repr,[Char, Char.quote],[Char, String]]
[Subtype.property,[Subtype],[Subtype, Subtype.val]]
[Lean.Parser.Tactic.«tactic·._»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[MonadReader.noConfusionType,[outParam, MonadReader, Eq],[outParam, MonadReader]]
[ExceptCpsT.instLawfulMonadExceptCpsT.proof_1,[LawfulMonad.mk, ExceptCpsT, ExceptCpsT.instMonadExceptCpsT, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, Functor.map, id, Function.comp, SeqLeft.seqLeft, Applicative.toSeqLeft, Unit, SeqRight.seqRight, Applicative.toSeqRight, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, Bind.bind, Monad.toBind],[LawfulMonad, ExceptCpsT, ExceptCpsT.instMonadExceptCpsT]]
[Lean.Parser.Tactic.rewriteSeq,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Array.foldlM,[Monad, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, LE.le, instLENat, HSub.hSub, instHSub, instSubNat, Array.foldlM.loop, dite, Nat.decLe, Not, Array.foldlM.proof_1],[Monad, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size]]
[OfNat.ofNat,[Nat, OfNat],[Nat, OfNat]]
[System.FilePath.withFileName,[System.FilePath, String, Option, System.FilePath.parent, Unit, System.FilePath.mk, HDiv.hDiv, System.FilePath.instHDivFilePathStringFilePath],[System.FilePath, String]]
[IO.FS.Stream.mk.injEq,[IO, Bool, Unit, USize, ByteArray, String, Eq.propIntro, Eq, IO.FS.Stream, IO.FS.Stream.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[IO, Bool, Unit, USize, ByteArray, String, Eq, IO.FS.Stream, IO.FS.Stream.mk, And]]
[UInt64.val,[UInt64],[UInt64, Fin, UInt64.size]]
[Array.append,[Array, Array.foldl, Array.push, OfNat.ofNat, Nat, instOfNatNat, Array.size],[Array]]
[instInhabitedUInt16,[Inhabited.mk, UInt16, UInt16.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, instInhabitedUInt16.proof_1],[Inhabited, UInt16]]
[List.span,[Bool, List, List.spanAux, List.nil],[Bool, List, Prod]]
[Ordering.eq.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, Ordering, SizeOf.mk, OfNat.ofNat, instOfNatNat, Ordering.eq]]
[«term_×__1»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.bracketedExplicitBinders, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Function.Equiv.symm,[Function.Equiv, Eq.symm],[Function.Equiv]]
[Lean.Syntax.unsetTrailing,[Lean.Syntax, Lean.SourceInfo, Lean.Syntax.getTailInfo, Substring, String.Pos, Lean.Syntax.setTailInfo, Lean.SourceInfo.original, String.toSubstring],[Lean.Syntax]]
[IO.FileRight.mk.inj,[IO.AccessRight, Eq, IO.FileRight, IO.FileRight.mk, And, And.intro],[IO.AccessRight, Eq, IO.FileRight, IO.FileRight.mk, And]]
[StateCpsT.runK,[StateCpsT],[StateCpsT]]
[Int.mul,[Int, Nat, Int.ofNat, HMul.hMul, instHMul, instMulNat, Int.negOfNat, Nat.succ],[Int]]
[ExceptT.instLawfulMonadExceptT.proof_1,[Monad, LawfulMonad, LawfulMonad.mk, ExceptT, ExceptT.instMonadExceptT, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, ExceptT.ext, Functor.map, id, of_eq_true, Eq, Except, ExceptT.run, Eq.trans, True, congrFun, congrArg, Except.map, ExceptT.run_map, Except.map_id, LawfulFunctor.id_map, LawfulApplicative.toLawfulFunctor, LawfulMonad.toLawfulApplicative, eq_self, ExceptT.seqLeft_eq, ExceptT.seqRight_eq, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, Unit, Except.ok, Except.error, congr, Bind.bind, Monad.toBind, ExceptT.seq_eq, ExceptT.run_bind, ExceptT.run_pure, funext, LawfulMonad.pure_bind, ExceptT.bind_pure_comp, Eq.mpr, LawfulMonad.bind_assoc, bind_congr, Eq.symm, Eq.refl],[Monad, LawfulMonad, ExceptT, ExceptT.instMonadExceptT]]
[IO.Process.StdioConfig.stderr,[IO.Process.StdioConfig],[IO.Process.StdioConfig, IO.Process.Stdio]]
[Substring.startPos,[Substring],[Substring, String.Pos]]
[Lean.Parser.Tactic.failIfSuccess,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Nat.lt_trans,[Nat, LT.lt, instLTNat, Nat.le_trans, Nat.succ, Nat.le_step],[Nat, LT.lt, instLTNat]]
[observing,[Monad, MonadExcept, MonadExcept.tryCatch, Except, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.ok, Except.error],[Monad, MonadExcept, Except]]
[Nat.lt_succ_self,[Nat, Nat.lt.base],[Nat, LT.lt, instLTNat, Nat.succ]]
[decide_false_eq_false,[Decidable, False, Eq, Bool, Decidable.decide, Bool.false, Not, rfl, Decidable.isFalse, False.elim, Decidable.isTrue],[Decidable, False, Eq, Bool, Decidable.decide, Bool.false]]
[StateCpsT.runK_modify,[PUnit, rfl, StateCpsT.runK, modify, StateCpsT, instMonadState, StateCpsT.instMonadStateOfStateCpsT],[PUnit, Eq, StateCpsT.runK, modify, StateCpsT, instMonadState, StateCpsT.instMonadStateOfStateCpsT, PUnit.unit]]
[Array.all,[Array, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Id.run, Array.allM, Id, Id.instMonadId],[Array, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size]]
[Lean.MacroScopesView.mainModule,[Lean.MacroScopesView],[Lean.MacroScopesView, Lean.Name]]
[instDecidableRelLtLtOfOrd,[Ord, inferInstanceAs, DecidableRel, Eq, Bool, BEq.beq, Ordering, instBEqOrdering, Ord.compare, Ordering.lt, Bool.true, instDecidableEqBool],[Ord, DecidableRel, LT.lt, ltOfOrd]]
[mkStdGen,[optParam, Nat, OfNat.ofNat, instOfNatNat, HDiv.hDiv, instHDiv, Nat.instDivNat, HMod.hMod, instHMod, Nat.instModNat, StdGen.mk, HAdd.hAdd, instHAdd, instAddNat],[optParam, Nat, OfNat.ofNat, instOfNatNat, StdGen]]
[unsafeCast.proof_1,[lcProof, Eq],[Eq]]
[IO.eprint,[ToString, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Stream, Unit, IO.getStderr, IO.FS.Stream.putStr, ToString.toString],[ToString, IO, Unit]]
[Lean.Syntax.atom.injEq,[Lean.SourceInfo, String, Eq.propIntro, Eq, Lean.Syntax, Lean.Syntax.atom, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Lean.SourceInfo, String, Eq, Lean.Syntax, Lean.Syntax.atom, And]]
[Std.Format.FlattenBehavior.allOrNone.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, Std.Format.FlattenBehavior, SizeOf.mk, OfNat.ofNat, instOfNatNat, Std.Format.FlattenBehavior.allOrNone]]
[Lean.Parser.Syntax.subPrec,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Subsingleton.noConfusionType,[Subsingleton, Eq],[Subsingleton]]
[instComplementUInt64,[Complement.mk, UInt64, UInt64.complement],[Complement, UInt64]]
[Iff.subst,[Iff, Eq.subst, propext],[Iff]]
[Decidable.noConfusionType,[Decidable, Not],[Decidable]]
[List.forM_nil,[Monad, PUnit, rfl, ForM.forM, List, List.instForMList, List.nil],[Monad, PUnit, Eq, ForM.forM, List, List.instForMList, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit]]
[IO.Process.Output.mk.injEq,[UInt32, String, Eq.propIntro, Eq, IO.Process.Output, IO.Process.Output.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[UInt32, String, Eq, IO.Process.Output, IO.Process.Output.mk, And]]
[Applicative.toSeqLeft,[Applicative],[Applicative, SeqLeft]]
[Option.isEqSome,[BEq, Option, Bool, BEq.beq, Bool.false],[BEq, Option, Bool]]
[instInhabitedUInt8.proof_1,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt8.size, Nat.decLt, Eq.refl, Bool, Bool.true],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt8.size]]
[Lean.expandExplicitBindersAux.loop,[Lean.Syntax, Array, Option, Nat, Lean.MacroM, Nat.below, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Nat.succ, Lean.Syntax.getOp, Array.getOp, Lean.instInhabitedSyntax, OfNat.ofNat, instOfNatNat, PProd.fst, PUnit, PProd, Bool, Lean.Syntax.isIdent, Bind.bind, Monad.toBind, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.Macro.instMonadRefMacroM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Macro.instMonadQuotationMacroM, Lean.Name, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.Syntax, Array, Option, Nat, Lean.MacroM]]
[HEq.ndrec,[HEq],[HEq]]
[Lean.Parser.Tactic.simpAll,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma],[Lean.ParserDescr]]
[coe,[CoeT, CoeT.coe],[CoeT]]
[UInt8.shiftRight,[UInt8, UInt8.mk, HShiftRight.hShiftRight, Fin, UInt8.size, instHShiftRight, Fin.instShiftRightFin, UInt8.val, UInt8.modn, OfNat.ofNat, Nat, instOfNatNat],[UInt8]]
[Lean.Syntax.decodeScientificLitVal?.decodeExp,[String, String.Pos, Nat, Char, String.get, ite, Option, Prod, Bool, Eq, BEq.beq, instBEq, instDecidableEqChar, Char.ofNat, Bool.true, instDecidableEqBool, Lean.Syntax.decodeScientificLitVal?.decodeAfterExp, String.next, OfNat.ofNat, instOfNatNat, Bool.false],[String, String.Pos, Nat, Option, Prod, Bool]]
[Classical.indefiniteDescription,[Exists, Classical.choice, Subtype, Classical.indefiniteDescription.proof_1],[Exists, Subtype]]
[IO.FS.Handle.mk,[System.FilePath, IO.FS.Mode, optParam, Bool, Bool.true, IO.FS.Handle.mkPrim, String, Unit, IO.FS.Mode.read, IO.FS.Mode.write, IO.FS.Mode.readWrite, IO.FS.Mode.append, Unit.unit, ite, Eq, instDecidableEqBool, HAppend.hAppend, instHAppend, String.instAppendString],[System.FilePath, IO.FS.Mode, optParam, Bool, Bool.true, IO, IO.FS.Handle]]
[ST.Ref.modifyGet,[MonadLiftT, ST, ST.Ref, Prod, liftM, ST.Prim.Ref.modifyGet],[MonadLiftT, ST, ST.Ref, Prod]]
[modify,[MonadState, MonadState.modifyGet, PUnit, Prod.mk, PUnit.unit],[MonadState, PUnit]]
[StateT.monadControl,[Monad, MonadControl.mk, StateT, Prod, Bind.bind, Monad.toBind, StateT.instMonadStateT, MonadState.get, instMonadState, instMonadStateOfStateT, liftM, instMonadLiftT, StateT.instMonadLiftStateT, instMonadLiftT_1, StateT.run, PUnit, MonadStateOf.set, Pure.pure, Applicative.toPure, Monad.toApplicative],[Monad, MonadControl, StateT]]
[Nat.lt_wfRel.proof_1,[WellFounded.intro, Nat, Nat.lt, Acc, Acc.intro, OfNat.ofNat, instOfNatNat, absurd, Nat.not_lt_zero, Nat.succ],[WellFounded, Nat, Nat.lt]]
[Substring.beq,[Substring, and, BEq.beq, Nat, instBEq, instDecidableEqNat, Substring.bsize, String, instDecidableEqString, Substring.toString],[Substring, Bool]]
[instReprFloat,[Repr.mk, Float, Nat, Std.Format.text, Float.toString],[Repr, Float]]
[Std.Format.defWidth,[OfNat.ofNat, Nat, instOfNatNat],[Nat]]
[IO.FS.Mode.noConfusionType,[IO.FS.Mode, noConfusionTypeEnum, Nat, instDecidableEqNat, IO.FS.Mode.toCtorIdx],[IO.FS.Mode]]
[PSum.inl.injEq,[Eq.propIntro, Eq, PSum, PSum.inl, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Eq, PSum, PSum.inl]]
[UInt32.toUInt64,[UInt32, Nat.toUInt64, UInt32.toNat],[UInt32, UInt64]]
[Substring.foldr,[Char, Substring, String, String.Pos, String.foldrAux],[Char, Substring]]
[Nat.sub_zero,[Nat, rfl, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat],[Nat, Eq, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat]]
[Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat, LE.le, instLENat, LT.lt, instLTNat, Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1],[Trans, Nat, LE.le, instLENat, LT.lt, instLTNat]]
[String.pushn,[String, Char, Nat, Nat.repeat, String.push],[String, Char, Nat]]
[FloatArray.isEmpty,[FloatArray, BEq.beq, Nat, instBEq, instDecidableEqNat, FloatArray.size, OfNat.ofNat, instOfNatNat],[FloatArray, Bool]]
[Fin.val_ne_of_ne,[Nat, Fin, Ne, Eq, Fin.val, absurd, False, Fin.eq_of_val_eq],[Nat, Fin, Ne, Fin.val]]
[instInhabitedUInt64.proof_1,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt64.size, Nat.decLt, Eq.refl, Bool, Bool.true],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt64.size]]
[Nat.repr,[Nat, List.asString, Nat.toDigits, OfNat.ofNat, instOfNatNat],[Nat, String]]
[instReprSigma,[Repr, Repr.mk, Sigma, Nat, Std.Format, Std.Format.bracket, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, repr, Std.Format.text],[Repr, Sigma]]
[String.data,[String],[String, List, Char]]
[Lean.Parser.Tactic.Conv.convSkip,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[ST.Ref.swap,[MonadLiftT, ST, ST.Ref, liftM, ST.Prim.Ref.swap],[MonadLiftT, ST, ST.Ref]]
[Lean.unifConstraint,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Array.foldrM.fold,[Monad, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, Array.size, Nat.below, ite, Eq, Bool, BEq.beq, instBEq, instDecidableEqNat, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, HAdd.hAdd, instHAdd, instAddNat, Nat.succ],[Monad, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, Array.size]]
[IO.FS.FileType.file.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, IO.FS.FileType, SizeOf.mk, OfNat.ofNat, instOfNatNat, IO.FS.FileType.file]]
[UInt32.noConfusionType,[UInt32, Fin, UInt32.size, Eq],[UInt32]]
[List.isPrefixOf,[BEq, List, Bool, List.below, List.nil, Bool.true, Bool.false, List.cons, and, BEq.beq, PProd.fst, PUnit, PProd],[BEq, List, Bool]]
[IO.Process.StdioConfig.mk.injEq,[IO.Process.Stdio, Eq.propIntro, Eq, IO.Process.StdioConfig, IO.Process.StdioConfig.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[IO.Process.Stdio, Eq, IO.Process.StdioConfig, IO.Process.StdioConfig.mk, And]]
[Array.modify,[Inhabited, Array, Nat, Id.run, Array.modifyM, Id, Id.instMonadId],[Inhabited, Array, Nat]]
[Mod.noConfusionType,[Mod, Eq],[Mod]]
[instDecidableRelLeLeOfOrd,[Ord, inferInstanceAs, DecidableRel, Eq, Bool, Ordering.isLE, Ord.compare, Bool.true, instDecidableEqBool],[Ord, DecidableRel, LE.le, leOfOrd]]
[Lean.NameGenerator.curr,[Lean.NameGenerator, Lean.Name.mkNum, Lean.NameGenerator.namePrefix, Lean.NameGenerator.idx],[Lean.NameGenerator, Lean.Name]]
[Except.toBool,[Except, Bool, Bool.true, Bool.false],[Except, Bool]]
[IO.Error.mkOtherError,[IO.Error.otherError],[UInt32, String, IO.Error]]
[Classical.typeDecidable,[Decidable, Nonempty, PSum, False, Classical.propDecidable, PSum.inl, arbitrary, Classical.inhabited_of_nonempty, Not, PSum.inr, Classical.typeDecidable.proof_1],[PSum, False]]
[ST.instInhabitedRef,[Inhabited, Inhabited.mk, ST.Ref, ST.Ref.mk, PointedType.val, ST.RefPointed, ST.instInhabitedRef.proof_1],[Inhabited, ST.Ref]]
[List.map₂,[List, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd],[List]]
[List.set,[List, Nat, List.below, List.cons, PProd.fst, PUnit, PProd, List.nil],[List, Nat]]
[HOr.hOr,[HOr],[HOr]]
[Array.zipWith,[Array, Array.zipWithAux, OfNat.ofNat, Nat, instOfNatNat, List.toArray, List.nil],[Array]]
[PProd.fst,[PProd],[PProd]]
[LawfulMonad.bind_map,[Monad, LawfulMonad],[Monad, LawfulMonad, Eq, Bind.bind, Monad.toBind, Functor.map, Applicative.toFunctor, Monad.toApplicative, Seq.seq, Applicative.toSeq, Unit]]
[List.hasDecidableLt.proof_2,[LT, List, LT.lt, List.instLTList, List.cons, List.nil, False],[LT, List, LT.lt, List.instLTList, List.cons, List.nil, False]]
[Eq.symm,[Eq, rfl],[Eq]]
[UInt8.sub,[UInt8, UInt8.mk, HSub.hSub, Fin, UInt8.size, instHSub, Fin.instSubFin, UInt8.val],[UInt8]]
[String.toLower,[String, String.map, Char.toLower],[String]]
[UInt16.decEq.proof_2,[Fin, UInt16.size, Not, Eq, UInt16, UInt16.mk, False, absurd],[Fin, UInt16.size, Not, Eq, UInt16, UInt16.mk, False]]
[Std.Format.tag.sizeOf_spec,[Nat, Std.Format, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat, SizeOf.mk, String, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOf, Int, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone],[Nat, Std.Format, Eq, SizeOf.sizeOf, SizeOf.mk, OfNat.ofNat, instOfNatNat, String, HAdd.hAdd, instHAdd, instAddNat, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, Int, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone, Std.Format.tag]]
[ExceptT.run_bind_lift,[Monad, LawfulMonad, ExceptT, of_eq_true, Eq, Except, Bind.bind, Monad.toBind, Functor.map, Applicative.toFunctor, Monad.toApplicative, Except.ok, Pure.pure, Applicative.toPure, Except.error, Eq.trans, True, congrFun, congrArg, map_eq_pure_bind, LawfulMonad.bind_assoc, funext, LawfulMonad.pure_bind, eq_self],[Monad, LawfulMonad, ExceptT, Eq, Except, ExceptT.run, Bind.bind, Monad.toBind, ExceptT.instMonadExceptT, ExceptT.lift]]
[unexpandListToArray,[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, Lean.Syntax.SepArray, Lean.Syntax.SepArray.mk, Lean.Syntax.getArgs, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[instToStringString,[ToString.mk, String],[ToString, String]]
[IO.FS.SystemTime.mk.inj,[Int, UInt32, Eq, IO.FS.SystemTime, IO.FS.SystemTime.mk, And, And.intro],[Int, UInt32, Eq, IO.FS.SystemTime, IO.FS.SystemTime.mk, And]]
[InvImage.wf.proof_1,[WellFounded, WellFounded.intro, InvImage, InvImage.accessible, WellFounded.apply],[WellFounded, InvImage]]
[IO.FS.instReprDirEntry,[Repr.mk, IO.FS.DirEntry, Nat, Std.Format.bracket, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.nil, Std.Format.text, repr, System.FilePath, System.instReprFilePath, IO.FS.DirEntry.root, Std.Format.line, String, instReprString, IO.FS.DirEntry.fileName],[Repr, IO.FS.DirEntry]]
[instOfScientificFloat,[OfScientific.mk, Float, Nat, Bool, Float.ofScientific],[OfScientific, Float]]
[Nat.pow_zero,[Nat, rfl, HPow.hPow, instHPow, instPowNatNat, OfNat.ofNat, instOfNatNat],[Nat, Eq, HPow.hPow, instHPow, instPowNatNat, OfNat.ofNat, instOfNatNat]]
[EmptyCollection.noConfusionType,[EmptyCollection, Eq],[EmptyCollection]]
[Nat.le_of_ble_eq_true,[Nat, Eq, Bool, Nat.ble, Bool.true, LE.le, instLENat, Nat.below, OfNat.ofNat, instOfNatNat, Nat.zero_le, Nat.succ, Nat.succ_le_succ, PProd.fst, PUnit, PProd],[Nat, Eq, Bool, Nat.ble, Bool.true, LE.le, instLENat]]
[Array.binSearch,[Inhabited, Array, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Array.size, ite, Option, LT.lt, instLTNat, Nat.decLt, Array.binSearchAux, instInhabitedOption, id, Option.none],[Inhabited, Array, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Array.size, Option]]
[«term∅»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Std.Format.appendEx,[Std.Format, Std.Format.append],[Std.Format]]
[dbgTraceVal,[ToString, dbgTrace, ToString.toString, Unit],[ToString]]
[Nat.le_succ,[Nat, Nat.le.step, Nat.le.refl],[Nat, LE.le, instLENat, Nat.succ]]
[instComplementUSize,[Complement.mk, USize, USize.complement],[Complement, USize]]
[instHOrElse,[OrElse, HOrElse.mk, Unit, OrElse.orElse],[OrElse, HOrElse]]
[DoResultPRBC.break.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, DoResultPRBC, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, DoResultPRBC.break]]
[Lean.Parser.Tactic.case,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary],[Lean.ParserDescr]]
[ExceptT.bind,[Monad, ExceptT, ExceptT.mk, Bind.bind, Monad.toBind, Except, ExceptT.bindCont],[Monad, ExceptT]]
[instDecidableLt_3,[UInt64, UInt64.decLt],[UInt64, Decidable, LT.lt, instLTUInt64]]
[Ordering.gt.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, Ordering, SizeOf.mk, OfNat.ofNat, instOfNatNat, Ordering.gt]]
[Classical.inhabited_of_exists.proof_1,[Exists, Exists.elim, Nonempty, Nonempty.intro],[Exists, Nonempty]]
[MonadExceptOf.noConfusionType,[MonadExceptOf, Eq],[MonadExceptOf]]
[ByteArray.mk.inj,[Array, UInt8, Eq, ByteArray, ByteArray.mk],[Array, UInt8, Eq, ByteArray, ByteArray.mk]]
[Fin.noConfusionType,[Nat, Fin, LT.lt, instLTNat, Eq],[Nat, Fin]]
[Option.any,[Bool, Option, Unit, Bool.false],[Bool, Option]]
[Float.val,[Float],[Float, FloatSpec.float, floatSpec]]
[String.instInhabitedString,[Inhabited.mk, String],[Inhabited, String]]
[mt,[Not],[Not]]
[instAddFloat,[Add.mk, Float, Float.add],[Add, Float]]
[Acc.inv.proof_1,[Acc],[Acc]]
[UInt8.mod,[UInt8, UInt8.mk, HMod.hMod, Fin, UInt8.size, instHMod, Fin.instModFin, UInt8.val],[UInt8]]
[instInhabitedReaderT,[Inhabited, Inhabited.mk, ReaderT, arbitrary],[Inhabited, ReaderT]]
[LT.noConfusionType,[LT, Eq],[LT]]
[StdGen.noConfusionType,[StdGen, Nat, Eq],[StdGen]]
[IO.setRandSeed,[Nat, ST.Ref.set, IO.RealWorld, IO, instMonadLiftT, ST, IO.instMonadLiftSTRealWorldEIO, IO.Error, instMonadLiftT_1, StdGen, IO.stdGenRef, mkStdGen],[Nat, IO, Unit]]
[Lean.MacroScopesView.imported,[Lean.MacroScopesView],[Lean.MacroScopesView, Lean.Name]]
[HDiv.hDiv,[HDiv],[HDiv]]
[EStateM.instReprResult,[Repr, Repr.mk, EStateM.Result, Nat, Std.Format, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, reprArg],[Repr, EStateM.Result]]
[instOrOpUInt64,[OrOp.mk, UInt64, UInt64.lor],[OrOp, UInt64]]
[UInt64.complement,[UInt64, HSub.hSub, instHSub, instSubUInt64, OfNat.ofNat, instOfNatUInt64, HAdd.hAdd, instHAdd, instAddUInt64],[UInt64]]
[IO.FS.Mode.append.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, IO.FS.Mode, SizeOf.mk, OfNat.ofNat, instOfNatNat, IO.FS.Mode.append]]
[Lean.Parser.Tactic.Conv.convSeq1Indented,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Macro.mkMethodsImp,[Lean.Macro.Methods, unsafeCast, PointedType.type],[Lean.Macro.Methods, PointedType.type]]
[Lean.Macro.Methods.hasDecl,[Lean.Macro.Methods],[Lean.Macro.Methods, Lean.Name, Lean.MacroM, Bool]]
[instHasEquiv,[Setoid, HasEquiv.mk, Setoid.r],[Setoid, HasEquiv]]
[Prod.noConfusionType,[Prod, Eq],[Prod]]
[ReaderT.run_read,[Monad, rfl, ReaderT.run, ReaderT.read],[Monad, Eq, ReaderT.run, ReaderT.read, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[ForInStep.done.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, ForInStep, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, ForInStep.done]]
[Nat.succ.inj,[Nat, Eq, Nat.succ],[Nat, Eq, Nat.succ]]
[Lean.Syntax.getArgs,[Lean.Syntax, Array, Lean.SyntaxNodeKind, Array.empty],[Lean.Syntax, Array]]
[IO.Error.otherError.sizeOf_spec,[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar],[UInt32, String, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, Option, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.otherError]]
[OfNat.noConfusionType,[Nat, OfNat, Eq],[Nat, OfNat]]
[IO.Error.resourceVanished.injEq,[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.resourceVanished, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[UInt32, String, Eq, IO.Error, IO.Error.resourceVanished, And]]
[List.iota,[Nat, List, Nat.below, Unit, List.nil, namedPattern, Nat.succ, List.cons, PProd.fst, PUnit, PProd],[Nat, List]]
[ST.Ref.modify,[MonadLiftT, ST, ST.Ref, liftM, Unit, ST.Prim.Ref.modify],[MonadLiftT, ST, ST.Ref, Unit]]
[Lean.Name.instReprSyntax,[Repr.mk, Lean.Syntax],[Repr, Lean.Syntax]]
[«stx_,+,?»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[String.take,[String, Nat, Substring.toString, Substring.take, String.toSubstring],[String, Nat]]
[StateT.instAlternativeStateT,[Monad, Alternative, Alternative.mk, StateT, Monad.toApplicative, StateT.instMonadStateT, StateT.failure, StateT.orElse],[Monad, Alternative, StateT]]
[unexpandListNil,[Lean.Syntax, Bind.bind, Lean.PrettyPrinter.UnexpandM, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil],[Lean.PrettyPrinter.Unexpander]]
[Nat.pred_le,[Nat, LE.le, instLENat, Nat.pred, Unit, Nat.le.refl, Nat.zero, Nat.le_succ, Nat.succ],[Nat, LE.le, instLENat, Nat.pred]]
[IO.Error.illegalOperation.injEq,[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.illegalOperation, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[UInt32, String, Eq, IO.Error, IO.Error.illegalOperation, And]]
[Lean.runEval,[Lean.Eval, Unit, IO.FS.withIsolatedStreams, IO, instMonadEIO, IO.Error, instMonadFinallyEIO, instMonadExceptOfEIO, instMonadLiftT_1, Lean.Eval.eval, Bool.false],[Lean.Eval, Unit, IO, Prod, String, Except, IO.Error]]
[typedExpr,[],[]]
[List.notElem,[BEq, List, not, List.elem],[BEq, List, Bool]]
[Subarray.popFront,[Subarray, dite, LT.lt, Nat, instLTNat, Subarray.start, Subarray.stop, Nat.decLt, Subarray.mk, Subarray.as, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Subarray.popFront.proof_1, Subarray.h₂, Not],[Subarray]]
[Array.instBEqArray,[BEq, BEq.mk, Array, Array.isEqv, BEq.beq],[BEq, Array]]
[OptionT.mk,[Option],[Option, OptionT]]
[instToStreamRangeRange,[ToStream.mk, Std.Range],[ToStream, Std.Range]]
[Std.Format.defUnicode,[Bool.true],[Bool]]
[Nat.ble_self_eq_true,[Nat, Eq, Bool, Nat.ble, Bool.true, Nat.below, Unit, rfl, OfNat.ofNat, instOfNatNat, Nat.succ, PProd.fst, PUnit, PProd],[Nat, Eq, Bool, Nat.ble, Bool.true]]
[Substring.dropWhile,[Substring, Char, Bool, String, String.Pos, Substring.mk],[Substring, Char, Bool]]
[instMulUInt32,[Mul.mk, UInt32, UInt32.mul],[Mul, UInt32]]
[System.FilePath.instHDivFilePathStringFilePath,[HDiv.mk, System.FilePath, String, System.FilePath.join, System.FilePath.mk],[HDiv, System.FilePath, String]]
[Lean.Name.instToStringName,[ToString.mk, Lean.Name, Lean.Name.toString, Bool.true],[ToString, Lean.Name]]
[HShiftLeft.hShiftLeft,[HShiftLeft],[HShiftLeft]]
[List.tail!,[List, Unit, panicWithPosWithDecl, instInhabitedList, OfNat.ofNat, Nat, instOfNatNat],[List]]
[HEq.ndrecOn,[HEq],[HEq]]
[Lean.Meta.Rewrite.Config.transparency,[Lean.Meta.Rewrite.Config],[Lean.Meta.Rewrite.Config, Lean.Meta.TransparencyMode]]
[instHashableNat,[Hashable.mk, Nat, UInt64.ofNat],[Hashable, Nat]]
[MonadExcept.orelse',[MonadExcept, optParam, Bool, Bool.true, MonadExcept.tryCatch, MonadExcept.throw, ite, Eq, instDecidableEqBool],[MonadExcept, optParam, Bool, Bool.true]]
[Quot.exists_rep,[Quot, Quot.inductionOn, Exists, Eq, Quot.mk, Exists.intro, rfl],[Quot, Exists, Eq, Quot.mk]]
[ne_false_of_self,[Eq, False],[Ne, False]]
[Lean.instQuoteNat,[Lean.Quote.mk, Nat, Lean.Syntax.mkNumLit, ToString.toString, instToStringNat, Lean.SourceInfo.none],[Lean.Quote, Nat]]
[Lean.Parser.Tactic.generalize,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.generalizeArg, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[String.Iterator.forward,[String.Iterator, Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, String.Iterator.next],[String.Iterator, Nat]]
[Sum.inhabitedRight,[Inhabited, Inhabited.mk, Sum, Sum.inr, arbitrary],[Inhabited, Sum]]
[Lean.Name.sizeOf,[Lean.Name, Nat, Lean.Name.below, Unit, Lean.Name.anonymous, OfNat.ofNat, instOfNatNat, String, UInt64, Lean.Name.str, HAdd.hAdd, instHAdd, instAddNat, PProd.fst, PUnit, PProd, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, Lean.Name.num],[Lean.Name, Nat]]
[instLTUInt32,[LT.mk, UInt32, LT.lt, Fin, UInt32.size, instLTFin, UInt32.val],[LT, UInt32]]
[Array.getEvenElems,[Array, Prod, Bool, Prod.snd, Array.foldl, ite, Eq, Bool.true, instDecidableEqBool, Prod.mk, Bool.false, Array.push, Array.empty, OfNat.ofNat, Nat, instOfNatNat, Array.size],[Array]]
[List.length_append,[List, Eq, Nat, List.length, HAppend.hAppend, instHAppend, List.instAppendList, HAdd.hAdd, instHAdd, instAddNat, of_eq_true, List.nil, Eq.trans, True, congr, congrArg, List.nil_append, OfNat.ofNat, instOfNatNat, congrFun, List.length_nil, Nat.zero_add, eq_self, List.cons, Nat.succ, List.cons_append, List.length_cons, Nat.succ_add],[List, Eq, Nat, List.length, HAppend.hAppend, instHAppend, List.instAppendList, HAdd.hAdd, instHAdd, instAddNat]]
[Std.Range.«term[:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[«term_∨_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Array.modifyM,[Monad, Inhabited, Array, Nat, dite, LT.lt, instLTNat, Array.size, Nat.decLt, Fin, Fin.mk, Array.get, Array.set, arbitrary, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.modifyM.proof_1, Not],[Monad, Inhabited, Array, Nat]]
[Lean.Parser.Tactic.Conv.convSeqBracketed,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat],[Lean.ParserDescr]]
[List.toString,[ToString, List, String, Unit, HAppend.hAppend, instHAppend, String.instAppendString, List.toStringAux, Bool.true, List.cons],[ToString, List, String]]
[MonadControl.stM,[MonadControl],[MonadControl]]
[Array.findIdx?.loop.proof_1,[Array, Nat, LT.lt, instLTNat, Array.size, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, absurd, False, Eq.mp, Eq.refl, Nat.zero_add, Nat.lt_irrefl],[Array, Nat, LT.lt, instLTNat, Array.size, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, False]]
[ReaderT.instLawfulMonadReaderT,[ReaderT.instLawfulMonadReaderT.proof_1],[Monad, LawfulMonad, ReaderT, ReaderT.instMonadReaderT]]
[Lean.instEval,[ToString, Lean.Eval.mk, Unit, optParam, Bool, Bool.true, IO.println, String, instToStringString, ToString.toString, Unit.unit],[ToString, Lean.Eval]]
[Std.Format.nest.inj,[Int, Std.Format, Eq, Std.Format.nest, And, And.intro],[Int, Std.Format, Eq, Std.Format.nest, And]]
[OptionT.lift,[Monad, OptionT.mk, Bind.bind, Monad.toBind, Option, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.some],[Monad, OptionT]]
[Std.Format.FlattenBehavior.toCtorIdx,[Std.Format.FlattenBehavior, Nat, OfNat.ofNat, instOfNatNat],[Std.Format.FlattenBehavior, Nat]]
[Lean.Meta.Rewrite.Config.mk.injEq,[Lean.Meta.TransparencyMode, Bool, Eq.propIntro, Eq, Lean.Meta.Rewrite.Config, Lean.Meta.Rewrite.Config.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Lean.Meta.TransparencyMode, Bool, Eq, Lean.Meta.Rewrite.Config, Lean.Meta.Rewrite.Config.mk, And]]
[Lean.fieldIdxKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[Lean.Option.hasQuote,[Lean.Quote, Lean.Quote.mk, Option, Unit, Option.none, Option.some, Unit.unit, Lean.Syntax, Lean.mkIdent, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.mkCApp, List.toArray, List.cons, Lean.Quote.quote, List.nil],[Lean.Quote, Option]]
[«term[_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false],[Lean.ParserDescr]]
[Lean.isSubScriptAlnum,[Char, or, Lean.isNumericSubscript, and, Decidable.decide, LE.le, UInt32, instLEUInt32, OfNat.ofNat, instOfNatUInt32, Char.val, instDecidableLe],[Char, Bool]]
[List.toFloatArray,[List, Float, FloatArray, FloatArray.empty, List.toFloatArray.loop],[List, Float, FloatArray]]
[String.getOp,[String, String.Pos, String.get],[String, String.Pos, Char]]
[Lean.Parser.Tactic.Conv.convIntro___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Lean.Parser.Tactic.intro,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Setoid.refl,[Setoid, Equivalence.refl, Setoid.r, Setoid.iseqv],[Setoid, HasEquiv.Equiv, instHasEquiv]]
[UInt16.sub,[UInt16, UInt16.mk, HSub.hSub, Fin, UInt16.size, instHSub, Fin.instSubFin, UInt16.val],[UInt16]]
[String.toUpper,[String, String.map, Char.toUpper],[String]]
[Lean.Syntax.noConfusionType,[Lean.Syntax, Lean.SyntaxNodeKind, Array, Lean.SourceInfo, String, Substring, Lean.Name, List, Prod, Eq],[Lean.Syntax]]
[CoeHead.coe,[CoeHead],[CoeHead]]
[seq_eq_bind,[Monad, LawfulMonad, Eq.mpr, Eq, Seq.seq, Applicative.toSeq, Monad.toApplicative, Unit, Bind.bind, Monad.toBind, Functor.map, Applicative.toFunctor, Eq.refl, LawfulMonad.bind_map, rfl],[Monad, LawfulMonad, Eq, Seq.seq, Applicative.toSeq, Monad.toApplicative, Unit, Bind.bind, Monad.toBind, Functor.map, Applicative.toFunctor]]
[Lean.Syntax.SepArray.instCoeTailSepArrayArraySyntax,[String, CoeTail.mk, Lean.Syntax.SepArray, Array, Lean.Syntax, Lean.Syntax.SepArray.getElems],[String, CoeTail, Lean.Syntax.SepArray, Array, Lean.Syntax]]
[PSigma.revLexAccessible.proof_1,[Acc, PSigma, PSigma.RevLex, PSigma.mk, Acc.intro, Eq, HEq, PSigma.RevLex.left, Eq.symm, eq_of_heq, PSigma.RevLex.right, Eq.refl, HEq.refl],[Acc, PSigma, PSigma.RevLex, PSigma.mk]]
[instOfNatUInt64,[Nat, OfNat.mk, UInt64, UInt64.ofNat],[Nat, OfNat, UInt64]]
[WellFoundedRelation.noConfusionType,[WellFoundedRelation, WellFounded, Eq],[WellFoundedRelation]]
[instMonadStateOfStateT,[Monad, MonadStateOf.mk, StateT, StateT.get, StateT.set, StateT.modifyGet],[Monad, MonadStateOf, StateT]]
[withPtrEqDecEq.proof_1,[Unit, Decidable, Eq, toBoolUsing_eq_true, Unit.unit],[Unit, Decidable, Eq, Bool, toBoolUsing, Unit.unit, Bool.true]]
[DoResultSBC.pureReturn.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, DoResultSBC, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, DoResultSBC.pureReturn]]
[instReprAtomChar,[ReprAtom.mk, Char],[ReprAtom, Char]]
[PSigma.skipLeft.proof_1,[WellFoundedRelation, PSigma.revLex, emptyRelation, WellFoundedRelation.rel, WellFoundedRelation.wf, emptyWf],[WellFoundedRelation, WellFounded, PSigma, PSigma.RevLex, emptyRelation, WellFoundedRelation.rel]]
[instSubUSize,[Sub.mk, USize, USize.sub],[Sub, USize]]
[instMonadReader,[MonadReaderOf, MonadReader.mk, readThe],[MonadReaderOf, MonadReader]]
[Lean.Syntax.matchesIdent,[Lean.Syntax, Lean.Name, and, Lean.Syntax.isIdent, BEq.beq, Lean.Name.instBEqName, Lean.Syntax.getId],[Lean.Syntax, Lean.Name, Bool]]
[HPow.hPow,[HPow],[HPow]]
[instDecidableEqBool.proof_2,[Eq, Bool, Bool.true, Bool.false, False],[Eq, Bool, Bool.true, Bool.false, Bool.noConfusionType, False]]
[instReprTupleProd,[Repr, ReprTuple, ReprTuple.mk, Prod, List, Std.Format, ReprTuple.reprTuple, List.cons, repr],[Repr, ReprTuple, Prod]]
[instDecidableOr.proof_1,[Not, Or, False],[Not, Or, False]]
[congr,[Eq, rfl],[Eq]]
[Nat.decLt,[Nat.decLe, Nat.succ],[Decidable, LT.lt, Nat, instLTNat]]
[FloatSpec.decLe,[FloatSpec],[FloatSpec, DecidableRel, FloatSpec.float, FloatSpec.le]]
[StateCpsT.runK_pure,[rfl, StateCpsT.runK, Pure.pure, StateCpsT, Applicative.toPure, Monad.toApplicative, StateCpsT.instMonadStateCpsT],[Eq, StateCpsT.runK, Pure.pure, StateCpsT, Applicative.toPure, Monad.toApplicative, StateCpsT.instMonadStateCpsT]]
[withPtrEqDecEq.proof_2,[Unit, Decidable, Eq, Bool, withPtrEq, toBoolUsing, Unit.unit, withPtrEqDecEq.proof_1, Bool.true, ofBoolUsing_eq_true],[Unit, Decidable, Eq, Bool, withPtrEq, toBoolUsing, Unit.unit, withPtrEqDecEq.proof_1, Bool.true]]
[«prio(_)»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[IO.Process.StdioConfig.stdout,[IO.Process.StdioConfig],[IO.Process.StdioConfig, IO.Process.Stdio]]
[Classical.propDecidable,[Classical.choice, Decidable, Classical.propDecidable.proof_1],[Decidable]]
[String.decLt,[List.hasDecidableLt, Char, Char.instLTChar, Char.instDecidableLt, String.data],[Decidable, LT.lt, String, String.instLTString]]
[noConfusionEnum.proof_2,[Eq, Not, congrArg],[Eq, Not, False]]
[List.length_reverse,[List, Eq, Nat, List.length, List.reverse, rfl, List.nil, of_eq_true, List.cons, Eq.trans, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, OfNat.ofNat, instOfNatNat, True, congr, congrArg, HAppend.hAppend, instHAppend, List.instAppendList, List.reverse_cons, List.length_append, List.length_cons, List.length_nil, eq_self],[List, Eq, Nat, List.length, List.reverse]]
[Setoid.noConfusionType,[Setoid, Equivalence, Eq],[Setoid]]
[Lean.expandBrackedBindersAux,[Lean.Syntax, Array, Nat, Lean.MacroM, Array.size, Lean.expandBrackedBindersAux.loop],[Lean.Syntax, Array, Lean.MacroM]]
[IO.Process.Stdio.null.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, IO.Process.Stdio, SizeOf.mk, OfNat.ofNat, instOfNatNat, IO.Process.Stdio.null]]
[IO.Error.noFileOrDirectory.sizeOf_spec,[String, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[String, UInt32, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, Option, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.noFileOrDirectory]]
[PSigma.lexNdep,[PSigma.Lex],[PSigma]]
[StateCpsT.instLawfulMonadStateCpsT.proof_1,[LawfulMonad.mk, StateCpsT, StateCpsT.instMonadStateCpsT, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, Functor.map, id, Function.comp, SeqLeft.seqLeft, Applicative.toSeqLeft, Unit, SeqRight.seqRight, Applicative.toSeqRight, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, Bind.bind, Monad.toBind],[LawfulMonad, StateCpsT, StateCpsT.instMonadStateCpsT]]
[String.Iterator.next,[String.Iterator, String, String.Pos, String.Iterator.mk, String.next],[String.Iterator]]
[Lean.Parser.Syntax.addPrec,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instDecidableLe,[UInt32, UInt32.decLe],[UInt32, Decidable, LE.le, instLEUInt32]]
[instLTUSize,[LT.mk, USize, USize.lt],[LT, USize]]
[instMonadExceptOfExcept,[MonadExceptOf.mk, Except, Except.error, Except.tryCatch],[MonadExceptOf, Except]]
[Subarray.stop,[Subarray],[Subarray, Nat]]
[ForM.forM,[ForM],[ForM, Monad, PUnit]]
[Char.isValidChar_of_isValidChar_Nat,[Nat, Char.isValidCharNat, isValidChar, UInt32.ofNat', Char.isValidUInt32, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, Or.inl, UInt32, instLTUInt32, And, instOfNatUInt32, Or.inr, And.intro],[Nat, Char.isValidCharNat, isValidChar, UInt32.ofNat', Char.isValidUInt32]]
[FloatSpec.mk.injEq,[DecidableRel, Eq.propIntro, Eq, FloatSpec, FloatSpec.mk, And, HEq, And.intro, Eq.refl, HEq.refl, Eq.symm, eq_of_heq],[DecidableRel, Eq, FloatSpec, FloatSpec.mk, And, HEq]]
[MonadWithReader.noConfusionType,[outParam, MonadWithReader, Eq],[outParam, MonadWithReader]]
[fix5,[Inhabited, fixCore5, arbitrary],[Inhabited]]
[Nat.toUInt16,[UInt16.ofNat],[UInt16]]
[Lean.idBeginEscape,[Char.ofNat],[Char]]
[IO.Process.SpawnArgs.env,[IO.Process.SpawnArgs],[IO.Process.SpawnArgs, Array, Prod, String, Option]]
[Classical.propDecidable.proof_1,[Or, Not, Classical.em, Nonempty, Decidable, Nonempty.intro, Decidable.isTrue, Decidable.isFalse],[Nonempty, Decidable]]
[ne_true_of_eq_false,[Bool, Eq, Bool.false, Not, Bool.true, False],[Bool, Eq, Bool.false, Not, Bool.true]]
[EST,[EStateM],[]]
[IO.lazyPure,[Unit, Pure.pure, IO, Applicative.toPure, Monad.toApplicative, instMonadEIO, IO.Error, Unit.unit],[Unit, IO]]
[ExceptT.instMonadExceptT,[Monad, Monad.mk, ExceptT, Applicative.mk, Functor.mk, ExceptT.map, Pure.mk, ExceptT.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk, ExceptT.bind],[Monad, ExceptT]]
[IO.FS.withFile,[System.FilePath, IO.FS.Mode, IO.FS.Handle, IO, Bind.bind, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle.mk, Bool.true],[System.FilePath, IO.FS.Mode, IO.FS.Handle, IO]]
[floatDecLe,[Float, Float.decLe],[Float, Decidable, LE.le, instLEFloat]]
[instBEq,[DecidableEq, BEq.mk, Decidable.decide, Eq],[DecidableEq, BEq]]
[IO.FS.Stream.Buffer.noConfusionType,[IO.FS.Stream.Buffer, ByteArray, Nat, Eq],[IO.FS.Stream.Buffer]]
[instShiftRightUInt8,[ShiftRight.mk, UInt8, UInt8.shiftRight],[ShiftRight, UInt8]]
[Int.sub,[HAdd.hAdd, Int, instHAdd, Int.instAddInt, Neg.neg, Int.instNegInt],[Int]]
[IO.FS.Stream.isEof,[IO.FS.Stream],[IO.FS.Stream, IO, Bool]]
[Lean.PrettyPrinter.UnexpandM,[EStateM, Unit],[]]
[IO.AccessRight.flags,[IO.AccessRight, UInt32, ite, Eq, Bool, IO.AccessRight.read, Bool.true, instDecidableEqBool, OfNat.ofNat, instOfNatUInt32, IO.AccessRight.write, IO.AccessRight.execution, UInt32.lor],[IO.AccessRight, UInt32]]
[Char.valid,[Char],[Char, UInt32.isValidChar, Char.val]]
[StateCpsT.run,[Monad, StateCpsT, StateCpsT.runK, Prod, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk],[Monad, StateCpsT, Prod]]
[List.or,[List, Bool, List.any, id],[List, Bool]]
[Lean.Syntax.setArg,[Lean.Syntax, Nat, Lean.SyntaxNodeKind, Array, Lean.Syntax.node, Array.setD],[Lean.Syntax, Nat]]
[Lean.«termMacro.trace[__]_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[ULift.up_down,[ULift, Eq, ULift.up, ULift.down, rfl],[ULift, Eq, ULift.up, ULift.down]]
[prioMid,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Or.elim,[Or],[Or]]
[IO.eprintln,[ToString, IO.eprint, String, instToStringString, String.push, ToString.toString, Char.ofNat],[ToString, IO, Unit]]
[instHDiv,[Div, HDiv.mk, Div.div],[Div, HDiv]]
[Lean.Parser.Tactic.Conv.nestedTactic,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Nat.lt_of_succ_lt_succ,[Nat, Nat.le_of_succ_le_succ, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat],[Nat, LT.lt, instLTNat, Nat.succ]]
[Lean.Parser.Tactic.tacticUnhygienic_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Alternative.noConfusionType,[Alternative, Applicative, Unit, Eq],[Alternative]]
[instToFormatArray,[Std.ToFormat, Std.ToFormat.mk, Array, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.text, Std.ToFormat.format, List, instToFormatList, Array.toList],[Std.ToFormat, Array]]
[StateRefT'.set,[Monad, MonadLiftT, ST, ST.Ref, ST.Ref.set],[Monad, MonadLiftT, ST, StateRefT', PUnit]]
[Quotient.recOnSubsingleton₂,[Setoid, Quotient, Subsingleton, Quotient.mk, Quot.recOnSubsingleton, Setoid.r, Quotient.recOnSubsingleton₂.proof_1, Quot.mk, Quotient.recOnSubsingleton₂.proof_2],[Setoid, Quotient, Subsingleton, Quotient.mk]]
[Lean.Macro.Context.ref,[Lean.Macro.Context],[Lean.Macro.Context, Lean.Syntax]]
[Prod.mk.injEq,[Eq.propIntro, Eq, Prod, Prod.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Prod, Prod.mk, And]]
[instDecidableEqSum,[DecidableEq, Sum, Decidable, Eq, dite, Sum.inl, Decidable.isTrue, instDecidableEqSum.proof_1, Not, Decidable.isFalse, instDecidableEqSum.proof_2, Sum.inr, instDecidableEqSum.proof_3, instDecidableEqSum.proof_4, instDecidableEqSum.proof_5, instDecidableEqSum.proof_6],[DecidableEq, Sum]]
[instLTUInt64,[LT.mk, UInt64, UInt64.lt],[LT, UInt64]]
[instShiftRightUInt64,[ShiftRight.mk, UInt64, UInt64.shiftRight],[ShiftRight, UInt64]]
[Lean.Parser.Tactic.tacticRfl,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[coeHead,[CoeHead, CoeHead.coe],[CoeHead]]
[ExceptT.seqRight_eq,[Monad, LawfulMonad, ExceptT],[Monad, LawfulMonad, ExceptT, Eq, SeqRight.seqRight, Applicative.toSeqRight, Monad.toApplicative, ExceptT.instMonadExceptT, Unit, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const, id]]
[Lean.termEval_prec_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[IO.toEIO,[IO.Error, IO, EStateM.adaptExcept, IO.RealWorld],[IO.Error, IO, EIO]]
[instReprUInt32,[Repr.mk, UInt32, Nat, repr, instReprNat, UInt32.toNat],[Repr, UInt32]]
[instDivUInt16,[Div.mk, UInt16, UInt16.div],[Div, UInt16]]
[instToStringUSize,[ToString.mk, USize, ToString.toString, Nat, instToStringNat, USize.toNat],[ToString, USize]]
[System.instCoeStringFilePath,[Coe.mk, String, System.FilePath, System.FilePath.mk],[Coe, String, System.FilePath]]
[MonadWithReaderOf.noConfusionType,[MonadWithReaderOf, Eq],[MonadWithReaderOf]]
[List.contains,[BEq, List, List.elem],[BEq, List, Bool]]
[instDecidableIff.proof_4,[Not, Iff.intro, absurd],[Not, Iff]]
[Pure.pure,[Pure],[Pure]]
[IO.Error.noSuchThing.injEq,[Option, String, UInt32, Eq.propIntro, Eq, IO.Error, IO.Error.noSuchThing, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Option, String, UInt32, Eq, IO.Error, IO.Error.noSuchThing, And]]
[instDecidableLe_4,[USize, USize.decLe],[USize, Decidable, LE.le, instLEUSize]]
[Array.ext.extAux,[List, Eq, Nat, List.length, LT.lt, instLTNat, List.get, List.nil, rfl, Eq.symm, List.cons, Nat.succ, Eq.mp, Eq.refl, List.length_cons],[List, Eq, Nat, List.length, LT.lt, instLTNat, List.get]]
[List.length_cons,[List, rfl, Nat, List.length, List.cons],[List, Eq, Nat, List.length, List.cons, Nat.succ]]
[Lean.mkNode,[Lean.SyntaxNodeKind, Array, Lean.Syntax, Lean.Syntax.node],[Lean.SyntaxNodeKind, Array, Lean.Syntax]]
[Nat.zero_ne_one,[Eq, Nat, OfNat.ofNat, instOfNatNat, False],[Ne, Nat, OfNat.ofNat, instOfNatNat]]
[ST.Prim.Ref.modifyGetUnsafe,[ST.Ref, Prod, Bind.bind, ST, Monad.toBind, instMonadST, ST.Prim.Ref.take, Unit, ST.Prim.Ref.set, PUnit, Pure.pure, Applicative.toPure, Monad.toApplicative],[ST.Ref, Prod, ST]]
[Classical.strongIndefiniteDescription.proof_1,[Exists, Subtype.property, Classical.indefiniteDescription],[Exists, Subtype.val, Classical.indefiniteDescription]]
[StateRefT'.modifyGet,[Monad, MonadLiftT, ST, Prod, ST.Ref, ST.Ref.modifyGet],[Monad, MonadLiftT, ST, Prod, StateRefT']]
[instSubsingletonDecidable,[instSubsingletonDecidable.proof_1],[Subsingleton, Decidable]]
[prioLow,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[IO.Error.resourceVanished.inj,[UInt32, String, Eq, IO.Error, IO.Error.resourceVanished, And, And.intro],[UInt32, String, Eq, IO.Error, IO.Error.resourceVanished, And]]
[IO.Error.otherError.inj,[UInt32, String, Eq, IO.Error, IO.Error.otherError, And, And.intro],[UInt32, String, Eq, IO.Error, IO.Error.otherError, And]]
[List.dropLast,[List, List.below, Unit, List.nil, List.cons, PProd.fst, PUnit, PProd],[List]]
[if_pos,[Decidable, Eq, ite, rfl, Decidable.isTrue, Not, absurd, Decidable.isFalse],[Decidable, Eq, ite]]
[Lean.Parser.Tactic.Conv.convLeft,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[List.maximum?,[LT, DecidableRel, LT.lt, List, Option, Unit, Option.none, Option.some, List.foldl, max],[LT, DecidableRel, LT.lt, List, Option]]
[Char.utf8Size.proof_3,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size]]
[UInt16.lor,[UInt16, UInt16.mk, Fin.lor, UInt16.size, UInt16.val],[UInt16]]
[Nat.shiftRight,[Nat, Nat.below, Nat.succ, HDiv.hDiv, instHDiv, Nat.instDivNat, PProd.fst, PUnit, PProd, OfNat.ofNat, instOfNatNat],[Nat]]
[Quotient.liftOn₂,[Setoid, Quotient, HasEquiv.Equiv, instHasEquiv, Eq, Quotient.lift₂],[Setoid, Quotient, HasEquiv.Equiv, instHasEquiv, Eq]]
[Lean.Parser.Tactic.Conv.convRw__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq],[Lean.ParserDescr]]
[modifyGetThe,[MonadStateOf, Prod, MonadStateOf.modifyGet],[MonadStateOf, Prod]]
[Lean.evalPrec,[Lean.Syntax, Lean.Macro.withIncRecDepth, Nat, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.expandMacros, cond, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.getD, Lean.Syntax.isNatLit?, OfNat.ofNat, instOfNatNat, Lean.Macro.throwErrorAt],[Lean.Syntax, Lean.MacroM, Nat]]
[Array.findSomeRevM?.find,[Monad, Array, Option, Nat, LE.le, instLENat, Array.size, Nat.below, OfNat.ofNat, instOfNatNat, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.none, HAdd.hAdd, instHAdd, instAddNat, Nat.succ],[Monad, Array, Option, Nat, LE.le, instLENat, Array.size]]
[Std.ToFormat.format,[Std.ToFormat],[Std.ToFormat, Std.Format]]
[StateCpsT.runK_bind_set,[Monad, PUnit, StateCpsT, rfl, StateCpsT.runK, Bind.bind, Monad.toBind, StateCpsT.instMonadStateCpsT, MonadStateOf.set, StateCpsT.instMonadStateOfStateCpsT],[Monad, PUnit, StateCpsT, Eq, StateCpsT.runK, Bind.bind, Monad.toBind, StateCpsT.instMonadStateCpsT, MonadStateOf.set, StateCpsT.instMonadStateOfStateCpsT, PUnit.unit]]
[instInhabitedList,[Inhabited.mk, List, List.nil],[Inhabited, List]]
[Std.Format.prefixJoin,[Std.ToFormat, Std.Format, List, List.below, Unit, List.nil, Std.Format.nil, List.cons, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.ToFormat.format, PProd.fst, PUnit, PProd],[Std.ToFormat, Std.Format, List]]
[addParenHeuristic,[String, ite, Eq, Bool, or, String.isPrefixOf, Bool.true, instDecidableEqBool, not, String.any, Char.isWhitespace, HAppend.hAppend, instHAppend, String.instAppendString],[String]]
[Setoid.iseqv,[Setoid],[Setoid, Equivalence, Setoid.r]]
[«term_|>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Id.instMonadId,[Monad.mk, Id, Applicative.mk, Functor.mk, Pure.mk, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk],[Monad, Id]]
[Iff.mp,[Iff],[Iff]]
[coeOfTC,[CoeTC, CoeHTCT.mk, coeTC],[CoeTC, CoeHTCT]]
[MonadLift.noConfusionType,[MonadLift, Eq],[MonadLift]]
[PSigma.revLexAccessible,[PSigma.revLexAccessible.proof_1],[Acc, PSigma, PSigma.RevLex, PSigma.mk]]
[Lean.termEval_prio_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[IO.Error.userError.sizeOf_spec,[String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[String, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, Option, UInt32, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.userError]]
[String.startsWith,[String, BEq.beq, Substring, Substring.hasBeq, Substring.take, String.toSubstring, String.length],[String, Bool]]
[IO.FS.DirEntry.mk.inj,[System.FilePath, String, Eq, IO.FS.DirEntry, IO.FS.DirEntry.mk, And, And.intro],[System.FilePath, String, Eq, IO.FS.DirEntry, IO.FS.DirEntry.mk, And]]
[UInt32.shiftRight,[UInt32, UInt32.mk, HShiftRight.hShiftRight, Fin, UInt32.size, instHShiftRight, Fin.instShiftRightFin, UInt32.val, UInt32.modn, OfNat.ofNat, Nat, instOfNatNat],[UInt32]]
[Lean.Parser.Tactic.«tactic_<;>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[HAndThen.noConfusionType,[outParam, HAndThen, Unit, Eq],[outParam, HAndThen]]
[instMonadFunctorT,[MonadFunctor, MonadFunctorT, MonadFunctorT.mk, MonadFunctor.monadMap, MonadFunctorT.monadMap],[MonadFunctor, MonadFunctorT]]
[true_iff,[propext, Iff, True, Iff.intro, Iff.mp, trivial],[Eq, Iff, True]]
[instReprInt,[Repr.mk, Int, Nat, Std.Format.text, Int.repr],[Repr, Int]]
[MonadExcept.orElse,[MonadExcept, Unit, MonadExcept.tryCatch, Unit.unit],[MonadExcept, Unit]]
[WellFounded.induction,[WellFounded, WellFounded.recursion],[WellFounded]]
[«term#[_,]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false],[Lean.ParserDescr]]
[Ordering.toCtorIdx,[Ordering, Nat, OfNat.ofNat, instOfNatNat],[Ordering, Nat]]
[IO.FS.lines,[System.FilePath, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle, Array, String, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.false, List.toArray, List.nil, IO.FS.lines.read],[System.FilePath, IO, Array, String]]
[Lean.Parser.Tactic.letrec,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Substring.extract,[Substring, String.Pos, String, ite, GE.ge, instLENat, Nat.decLe, Substring.mk, OfNat.ofNat, instOfNatNat, Nat.min, HAdd.hAdd, instHAdd, instAddNat],[Substring, String.Pos]]
[IO.instInhabitedError,[Inhabited.mk, IO.Error, IO.Error.alreadyExists, arbitrary, Option, String, instInhabitedOption, UInt32, instInhabitedUInt32, String.instInhabitedString],[Inhabited, IO.Error]]
[Nat.allM,[Monad, Nat, Bool, Nat.allM.loop],[Monad, Nat, Bool]]
[panic,[Inhabited, String, panicCore],[Inhabited, String]]
[IO.FS.Stream.putStr,[IO.FS.Stream],[IO.FS.Stream, String, IO, Unit]]
[Lean.Parser.Tactic.locationTargets,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Eq.mpr,[Eq, Eq.symm],[Eq]]
[FloatArray.noConfusionType,[FloatArray, Array, Float, Eq],[FloatArray]]
[String.mkIterator,[String, String.Iterator.mk, OfNat.ofNat, String.Pos, instOfNatNat],[String, String.Iterator]]
[Std.Format.append.sizeOf_spec,[Std.Format, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, String, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, Int, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone],[Std.Format, Eq, Nat, SizeOf.sizeOf, SizeOf.mk, OfNat.ofNat, instOfNatNat, String, HAdd.hAdd, instHAdd, instAddNat, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, Int, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone, Std.Format.append]]
[Substring.prev,[Substring, String.Pos, String, HAdd.hAdd, instHAdd, instAddNat, ite, Eq, instDecidableEqNat, HSub.hSub, instHSub, instSubNat, String.prev],[Substring, String.Pos]]
[System.FilePath.join,[System.FilePath, ite, Eq, Bool, System.FilePath.isAbsolute, Bool.true, instDecidableEqBool, System.FilePath.mk, HAppend.hAppend, String, instHAppend, String.instAppendString, System.FilePath.toString, Char.toString, System.FilePath.pathSeparator],[System.FilePath]]
[readThe,[MonadReaderOf, MonadReaderOf.read],[MonadReaderOf]]
[IO.Process.Stdio.toCtorIdx,[IO.Process.Stdio, Nat, OfNat.ofNat, instOfNatNat],[IO.Process.Stdio, Nat]]
[Lean.mkHole,[Lean.Syntax, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkAtomFrom, List.nil],[Lean.Syntax]]
[Lean.Parser.Tactic.change,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[List.isSuffixOf,[BEq, List, List.isPrefixOf, List.reverse],[BEq, List, Bool]]
[StateT.instMonadLiftStateT,[Monad, MonadLift.mk, StateT, StateT.lift],[Monad, MonadLift, StateT]]
[Array.zip,[Array, Array.zipWith, Prod, Prod.mk],[Array, Prod]]
[Prod.lex,[WellFoundedRelation, WellFoundedRelation.mk, Prod, Prod.Lex, WellFoundedRelation.rel, Prod.lex.proof_1],[WellFoundedRelation, Prod]]
[Char.instLEChar,[LE.mk, Char, Char.le],[LE, Char]]
[Nat.le_add_right,[Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, Nat.below, Nat.le_refl, Nat.succ, Nat.le_succ_of_le, Nat.add, PProd.fst, PUnit, PProd],[Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat]]
[List.nil_append,[List, rfl, HAppend.hAppend, instHAppend, List.instAppendList, List.nil],[List, Eq, HAppend.hAppend, instHAppend, List.instAppendList, List.nil]]
[Array.size_push,[Array, List.length_concat, Array.data],[Array, Eq, Nat, Array.size, Array.push, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
[NonScalar.noConfusionType,[NonScalar, Nat, Eq],[NonScalar]]
[List.hasDecEq,[DecidableEq, List, Decidable, Eq, List.below, Unit, List.nil, Decidable.isTrue, List.hasDecEq.proof_1, List.cons, Decidable.isFalse, List.hasDecEq.proof_2, List.hasDecEq.proof_3, decEq, PProd.fst, PUnit, PProd, List.hasDecEq.proof_4, Not, List.hasDecEq.proof_5, List.hasDecEq.proof_6],[DecidableEq, List, Decidable, Eq]]
[Lean.Module.mk.injEq,[Lean.Syntax, Array, Eq.propIntro, Eq, Lean.Module, Lean.Module.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Lean.Syntax, Array, Eq, Lean.Module, Lean.Module.mk, And]]
[Nat.pred_le_pred,[Nat, LE.le, instLENat, Nat.pred, Nat.le.refl, Nat.le, OfNat.ofNat, instOfNatNat, Nat.succ, Nat.le_trans, Nat.le_succ],[Nat, LE.le, instLENat, Nat.pred]]
[String.isInt,[String, ite, Bool, Eq, Char, String.get, OfNat.ofNat, String.Pos, instOfNatNat, Char.ofNat, instDecidableEqChar, Substring.isNat, Substring.drop, String.toSubstring, Nat, String.isNat],[String, Bool]]
[«term{}»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[System.Platform.isWindows,[System.Platform.getIsWindows, Unit.unit],[Bool]]
[Mod.mod,[Mod],[Mod]]
[Except.orElseLazy,[Except, Unit, Except.ok, Unit.unit],[Except, Unit]]
[Std.Format.instAppendFormat,[Append.mk, Std.Format, Std.Format.append],[Append, Std.Format]]
[Char.val_eq_of_eq,[Char, Eq, UInt32, Char.val, rfl],[Char, Eq, UInt32, Char.val]]
[USize.decLt,[USize, Decidable, LT.lt, instLTUSize, Fin, USize.size, inferInstanceAs, instLTFin, Fin.decLt],[USize, Decidable, LT.lt, instLTUSize]]
[Lean.Parser.Syntax.subPrio,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[ExceptT.lift_pure,[Monad, LawfulMonad, of_eq_true, Eq, ExceptT, ExceptT.mk, Functor.map, Applicative.toFunctor, Monad.toApplicative, Except, Except.ok, Pure.pure, Applicative.toPure, Eq.trans, True, congrFun, congrArg, LawfulApplicative.map_pure, LawfulMonad.toLawfulApplicative, eq_self],[Monad, LawfulMonad, Eq, ExceptT, ExceptT.lift, Pure.pure, Applicative.toPure, Monad.toApplicative, ExceptT.instMonadExceptT]]
[UInt32.toUInt8,[UInt32, Nat.toUInt8, UInt32.toNat],[UInt32, UInt8]]
[List.firstM,[Monad, Alternative, List, List.below, Unit, List.nil, Alternative.failure, List.cons, HOrElse.hOrElse, instHOrElse, instOrElse, PProd.fst, PUnit, PProd],[Monad, Alternative, List]]
[List.takeWhile,[Bool, List, List.below, Unit, List.nil, List.cons, PProd.fst, PUnit, PProd],[Bool, List]]
[Int.instMulInt,[Mul.mk, Int, Int.mul],[Mul, Int]]
[Nat.mod_eq_sub_mod,[Nat, GE.ge, instLENat, Or, Eq, OfNat.ofNat, instOfNatNat, GT.gt, instLTNat, Nat.eq_zero_or_pos, HMod.hMod, instHMod, Nat.instModNat, HSub.hSub, instHSub, instSubNat, rfl, Eq.symm, Nat.sub_zero, ite, And, LT.lt, LE.le, instDecidableAnd, Nat.decLt, Nat.decLe, if_pos, And.intro, Nat.mod_eq],[Nat, GE.ge, instLENat, Eq, HMod.hMod, instHMod, Nat.instModNat, HSub.hSub, instHSub, instSubNat]]
[withPtrEqUnsafe,[Unit, Bool, Eq, Unit.unit, Bool.true, ite, BEq.beq, USize, instBEq, instDecidableEqUSize, ptrAddrUnsafe, instDecidableEqBool],[Unit, Bool, Eq, Unit.unit, Bool.true]]
[UInt8.ofNat,[UInt8.mk, Fin.ofNat, OfNat.ofNat, Nat, instOfNatNat],[UInt8]]
[List.dropWhile,[Bool, List, List.below, Unit, List.nil, List.cons, PProd.fst, PUnit, PProd],[Bool, List]]
[IO.Error.permissionDenied.sizeOf_spec,[Option, String, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[Option, String, UInt32, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.permissionDenied]]
[PSigma.revLex.proof_1,[WellFounded, WellFounded.intro, PSigma, PSigma.RevLex, Acc, PSigma.revLexAccessible, WellFounded.apply],[WellFounded, PSigma, PSigma.RevLex]]
[Lean.Syntax.setKind,[Lean.Syntax, Lean.SyntaxNodeKind, Array, Lean.Syntax.node],[Lean.Syntax, Lean.SyntaxNodeKind]]
[MonadFinally.noConfusionType,[MonadFinally, Option, Prod, Eq],[MonadFinally]]
[Lean.Parser.Tactic.refine,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Eq.mp,[Eq],[Eq]]
[Nat.add_zero,[Nat, rfl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat],[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
[Std.Range.forIn,[Monad, Std.Range, Nat, ForInStep, Std.Range.stop, Std.Range.start, Std.Range.forIn.loop],[Monad, Std.Range, Nat, ForInStep]]
[System.FilePath.components,[System.FilePath, String.splitOn, System.FilePath.toString, System.FilePath.normalize, Bool.false, Char.toString, System.FilePath.pathSeparator],[System.FilePath, List, String]]
[Option.some.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, Option, SizeOf.mk, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Option.some]]
[Lean.Parser.Tactic.induction,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlts],[Lean.ParserDescr]]
[Subrelation.accessible,[Subrelation.accessible.proof_1],[Subrelation, Acc]]
[List.eraseDups,[BEq, List, List.eraseDupsAux, List.nil],[BEq, List]]
[List.mapTR,[List, List.mapTRAux, List.nil],[List]]
[IO.Error.mkNoSuchThing,[IO.Error.noSuchThing, Option.none, String],[UInt32, String, IO.Error]]
[Array.size,[List.length, Array.data],[Nat]]
[Coe.noConfusionType,[Coe, Eq],[Coe]]
[Int.negOfNat,[Nat, Int, Unit, OfNat.ofNat, hasOfNatOfCoe, instCoeNatInt, instOfNatNat, Int.negSucc],[Nat, Int]]
[Decidable.byContradiction,[Decidable, Not, False, Decidable.byCases, id, False.elim],[Decidable, Not, False]]
[Subarray.noConfusionType,[Subarray, Array, Nat, LE.le, instLENat, Array.size, Eq],[Subarray]]
[Substring.takeRightWhile,[Substring, Char, Bool, String, String.Pos, Substring.mk],[Substring, Char, Bool]]
[false_implies,[propext, False, True, Iff.intro, trivial, absurd, of_decide_eq_false, instDecidableFalse, Eq.refl, Bool, Decidable.decide],[Eq, False, True]]
[String.anyAux,[String, String.Pos, Char, Bool, String.anyAux.loop],[String, String.Pos, Char, Bool]]
[instHModUInt8NatUInt8,[HMod.mk, UInt8, Nat, UInt8.modn],[HMod, UInt8, Nat]]
[IO.Error.resourceBusy.sizeOf_spec,[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar],[UInt32, String, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, Option, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.resourceBusy]]
[Thunk.get,[Thunk, Unit.unit],[]]
[Array.size_pop,[Array, List.length_dropLast, Array.data],[Array, Eq, Nat, Array.size, Array.pop, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat]]
[leOfOrd,[Ord, LE.mk, Eq, Bool, Ordering.isLE, Ord.compare, Bool.true],[Ord, LE]]
[Applicative.toSeq,[Applicative],[Applicative, Seq]]
[bfix1,[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd],[Nat]]
[Substring.drop,[Substring, Nat, String, String.Pos, Substring.mk, HAdd.hAdd, instHAdd, instAddNat, Substring.nextn, OfNat.ofNat, instOfNatNat],[Substring, Nat]]
[Substring.dropRight,[Substring, Nat, String, String.Pos, Substring.mk, HAdd.hAdd, instHAdd, instAddNat, Substring.prevn, Substring.bsize],[Substring, Nat]]
[Array.get.proof_1,[Fin.isLt, Array.size],[LT.lt, Nat, instLTNat, Fin.val, Array.size]]
[System.SearchPath,[List, System.FilePath],[]]
[Subarray.foldr,[Subarray, Id.run, Subarray.foldrM, Id, Id.instMonadId],[Subarray]]
[Trans.noConfusionType,[outParam, Trans],[outParam, Trans]]
[Equivalence.noConfusionType,[Equivalence],[Equivalence]]
[instInhabitedUInt8,[Inhabited.mk, UInt8, UInt8.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, instInhabitedUInt8.proof_1],[Inhabited, UInt8]]
[«term_≥_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Name.str.injEq,[Lean.Name, String, UInt64, Eq.propIntro, Eq, Lean.Name.str, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Lean.Name, String, UInt64, Eq, Lean.Name.str, And]]
[List.append_assoc,[List, Eq, HAppend.hAppend, instHAppend, List.instAppendList, rfl, List.nil, of_eq_true, List.cons, Eq.trans, True, congr, congrArg, congrFun, List.cons_append, eq_self],[List, Eq, HAppend.hAppend, instHAppend, List.instAppendList]]
[Char.instLTChar,[LT.mk, Char, Char.lt],[LT, Char]]
[coeTC,[CoeTC, CoeTC.coe],[CoeTC]]
[«term_+_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[«term_<*>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instReprSum,[Repr, Repr.mk, Sum, Nat, Std.Format, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, reprArg],[Repr, Sum]]
[IO.Error.mkResourceVanished,[IO.Error.resourceVanished],[UInt32, String, IO.Error]]
[stdNext,[StdGen, Prod, Nat, Int, Int.ofNat, HDiv.hDiv, instHDiv, Int.instDivInt, OfNat.ofNat, Int.instOfNatInt, HSub.hSub, instHSub, Int.instSubInt, HMul.hMul, instHMul, Int.instMulInt, ite, LT.lt, Int.instLTInt, Int.decLt, HAdd.hAdd, instHAdd, Int.instAddInt, HMod.hMod, instHMod, Int.instModInt, Prod.mk, Int.toNat, StdGen.mk],[StdGen, Prod, Nat]]
[instAndOpUInt8,[AndOp.mk, UInt8, UInt8.land],[AndOp, UInt8]]
[«stx_+»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[Nat.add_assoc,[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.below, rfl, OfNat.ofNat, instOfNatNat, Nat.succ, congrArg, Nat.add, PProd.fst, PUnit, PProd],[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat]]
[LawfulApplicative.seq_assoc,[Applicative, LawfulApplicative],[Applicative, LawfulApplicative, Eq, Seq.seq, Applicative.toSeq, Unit, Functor.map, Applicative.toFunctor, Function.comp]]
[ExceptCpsT.instInhabitedExceptCpsT,[Inhabited, Inhabited.mk, ExceptCpsT, arbitrary],[Inhabited, ExceptCpsT]]
[Nat.forRevM,[Monad, Nat, Unit, Nat.forRevM.loop],[Monad, Nat, Unit]]
[StateRefT'.instMonadStateRefT',[Monad, inferInstanceAs, ReaderT, ST.Ref, ReaderT.instMonadReaderT],[Monad, StateRefT']]
[UInt16.mod,[UInt16, UInt16.mk, HMod.hMod, Fin, UInt16.size, instHMod, Fin.instModFin, UInt16.val],[UInt16]]
[Decidable.decide,[Decidable, Bool, Not, Bool.false, Bool.true],[Decidable, Bool]]
[ExceptT.instMonadLiftExceptExceptT,[Monad, MonadLift.mk, Except, ExceptT, ExceptT.mk, Pure.pure, Applicative.toPure, Monad.toApplicative],[Monad, MonadLift, Except, ExceptT]]
[Nat.le.brecOn,[Nat, Nat.le, Nat.le.below, Nat.le.below.refl, Nat.le.below.step],[Nat, Nat.le, Nat.le.below]]
[Std.Format.nil.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, Std.Format, SizeOf.mk, OfNat.ofNat, instOfNatNat, String, HAdd.hAdd, instHAdd, instAddNat, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, Int, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone, Std.Format.nil]]
[Nat.xor,[Nat.bitwise, bne, Bool, instBEq, instDecidableEqBool],[Nat]]
[Option.toMonad,[Monad, Alternative, Option, Unit, Alternative.failure, Pure.pure, Applicative.toPure, Alternative.toApplicative],[Monad, Alternative, Option]]
[instInhabitedExcept,[Inhabited, Inhabited.mk, Except, Except.error, arbitrary],[Inhabited, Except]]
[List.and,[List, Bool, List.all, id],[List, Bool]]
[List.groupBy,[Bool, List, Unit, List.nil, List.groupByAux, List.cons],[Bool, List]]
[Acc.ndrec,[Acc],[Acc]]
[UInt8.div,[UInt8, UInt8.mk, HDiv.hDiv, Fin, UInt8.size, instHDiv, Fin.instDivFin, UInt8.val],[UInt8]]
[Lean.bracketedExplicitBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.binderIdent, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat],[Lean.ParserDescr]]
[Fin.instOrOpFin,[Nat, OrOp.mk, Fin, Fin.lor],[Nat, OrOp, Fin]]
[instLTUInt16,[LT.mk, UInt16, UInt16.lt],[LT, UInt16]]
[Pow.pow,[Pow],[Pow]]
[Lean.Parser.Tactic.renameI,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[IO.FS.Metadata.byteSize,[IO.FS.Metadata],[IO.FS.Metadata, UInt64]]
[StateCpsT.instMonadStateOfStateCpsT,[MonadStateOf.mk, StateCpsT, PUnit, PUnit.unit, Prod],[MonadStateOf, StateCpsT]]
[StateCpsT.runK_bind_lift,[Monad, StateCpsT, rfl, StateCpsT.runK, Bind.bind, Monad.toBind, StateCpsT.instMonadStateCpsT, StateCpsT.lift],[Monad, StateCpsT, Eq, StateCpsT.runK, Bind.bind, Monad.toBind, StateCpsT.instMonadStateCpsT, StateCpsT.lift]]
[Array.anyM.loop,[Monad, Bool, Array, Nat, LE.le, instLENat, Array.size, Nat.below, dite, LT.lt, instLTNat, Nat.decLt, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.false, Nat.succ, Bind.bind, Monad.toBind, Array.get, Fin.mk, Array.anyM.loop.proof_1, ite, Eq, Bool.true, instDecidableEqBool, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Not],[Monad, Bool, Array, Nat, LE.le, instLENat, Array.size]]
[Std.Range.forM.loop,[Monad, Std.Range, Nat, PUnit, Nat.below, ite, GE.ge, instLENat, Std.Range.stop, Nat.decLe, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, Unit, Nat.succ, Bind.bind, Monad.toBind, PProd.fst, PProd, HAdd.hAdd, instHAdd, instAddNat, Std.Range.step],[Monad, Std.Range, Nat, PUnit]]
[Nat.div_eq,[Nat, dite, And, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HAdd.hAdd, instHAdd, instAddNat, HDiv.hDiv, instHDiv, Nat.instDivNat, HSub.hSub, instHSub, instSubNat, Not, Eq, congrFun, WellFounded.fix, WellFoundedRelation.rel, measure, id, WellFoundedRelation.wf, And.intro, Nat.sub_lt, Nat.lt_of_lt_of_le, Nat.zero, WellFounded.fix_eq, ite, dif_eq_if],[Nat, Eq, HDiv.hDiv, instHDiv, Nat.instDivNat, ite, And, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HAdd.hAdd, instHAdd, instAddNat, HSub.hSub, instHSub, instSubNat]]
[Setoid.symm,[Setoid, HasEquiv.Equiv, instHasEquiv, Equivalence.symm, Setoid.r, Setoid.iseqv],[Setoid, HasEquiv.Equiv, instHasEquiv]]
[System.FilePath.pathSeparators,[ite, List, Char, Eq, Bool, System.Platform.isWindows, Bool.true, instDecidableEqBool, List.cons, Char.ofNat, List.nil],[List, Char]]
[Float.mk.sizeOf_spec,[FloatSpec.float, floatSpec, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOf],[FloatSpec.float, floatSpec, Eq, Nat, SizeOf.sizeOf, Float, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, instSizeOf, Float.mk]]
[MProd.mk.inj,[Eq, MProd, MProd.mk, And, And.intro],[Eq, MProd, MProd.mk, And]]
[Lean.Parser.Tactic.apply,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Nat.shiftLeft,[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat],[Nat]]
[instHAppend,[Append, HAppend.mk, Append.append],[Append, HAppend]]
[Int.div,[Int, Nat, Int.ofNat, HDiv.hDiv, instHDiv, Nat.instDivNat, Neg.neg, Int.instNegInt, Nat.succ],[Int]]
[instSubsingletonSquash,[instSubsingletonSquash.proof_1],[Subsingleton, Squash]]
[Char.utf8Size.proof_2,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size]]
[MonadControlT.noConfusionType,[MonadControlT, Eq, HEq],[MonadControlT]]
[«term_≤_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[stx_?,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[Option.eq_of_eq_some,[Option, Iff, Eq, Option.some, Option.none, rfl, Iff.mpr, Iff.mp, congrArg],[Option, Iff, Eq, Option.some]]
[Lean.Name.simpMacroScopes,[Lean.Name, Bool, Lean.Name.hasMacroScopes, Unit, Lean.Name.below, Nat, UInt64, Lean.Name.num, Lean.Name.anonymous, String, Lean.Name.str, Lean.Name.mkNum, PProd.fst, PUnit, PProd, Unit.unit, BEq.beq, instBEq, instDecidableEqString],[Lean.Name]]
[Lean.SourceInfo.noConfusionType,[Lean.SourceInfo, Substring, String.Pos, Eq],[Lean.SourceInfo]]
[true_implies,[propext, True, Iff.intro, trivial],[Eq, True]]
[Bool.and_self,[Bool, Eq, and, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl],[Bool, Eq, and]]
[EStateM.get,[EStateM.Result.ok],[EStateM]]
[Nat.mul_comm,[Nat, Eq, HMul.hMul, instHMul, instMulNat, Nat.below, OfNat.ofNat, instOfNatNat, rfl, Eq.symm, Nat.mul_zero, Nat.zero_mul, Nat.succ, HAdd.hAdd, instHAdd, instAddNat, PProd.fst, PUnit, PProd, Nat.succ_mul, Nat.mul_succ],[Nat, Eq, HMul.hMul, instHMul, instMulNat]]
[Lean.withHeadRefOnly,[Monad, Lean.MonadRef, Bind.bind, Monad.toBind, Lean.Syntax, Lean.MonadRef.getRef, Option, Lean.Syntax.getHead?, Unit, Lean.withRef],[Monad, Lean.MonadRef]]
[Reader,[ReaderT, Id],[]]
[Sum.inl.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, Sum, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Sum.inl]]
[UInt32.decLt,[UInt32, Decidable, LT.lt, instLTUInt32, Fin, UInt32.size, inferInstanceAs, instLTFin, Fin.decLt],[UInt32, Decidable, LT.lt, instLTUInt32]]
[USize.decEq,[USize, Decidable, Eq, Fin, USize.size, dite, USize.mk, instDecidableEqFin, Decidable.isTrue, USize.decEq.proof_1, Not, Decidable.isFalse, USize.decEq.proof_2],[USize, Decidable, Eq]]
[congrFun,[Eq, rfl],[Eq]]
[instMonadControlOptionT,[Monad, MonadControl.mk, OptionT, Option, liftM, instMonadLiftT, OptionT.instMonadLiftOptionT, instMonadLiftT_1, OptionT.run],[Monad, MonadControl, OptionT]]
[Substring.noConfusionType,[Substring, String, String.Pos, Eq],[Substring]]
[instAddUInt16,[Add.mk, UInt16, UInt16.add],[Add, UInt16]]
[List.zip,[List.zipWith, Prod, Prod.mk],[List, Prod]]
[List.getLast.proof_2,[List, Eq, List.cons, List.nil, False],[List, Eq, List.cons, List.nil, List.noConfusionType, False]]
[MonadExcept.tryCatch,[MonadExcept],[MonadExcept]]
[seq_eq_bind_map,[Monad, LawfulMonad, Eq.mpr, Eq, Seq.seq, Applicative.toSeq, Monad.toApplicative, Unit, Bind.bind, Monad.toBind, Functor.map, Applicative.toFunctor, Eq.refl, Eq.symm, LawfulMonad.bind_map, rfl],[Monad, LawfulMonad, Eq, Seq.seq, Applicative.toSeq, Monad.toApplicative, Unit, Bind.bind, Monad.toBind, Functor.map, Applicative.toFunctor]]
[Array.findIdx?.loop.proof_2,[Array, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Eq.mpr, Eq.refl, Eq.symm, Nat.add_comm, Nat.add_assoc, rfl],[Array, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size]]
[instShiftLeftUInt32,[ShiftLeft.mk, UInt32, UInt32.shiftLeft],[ShiftLeft, UInt32]]
[Nat.pow_le_pow_of_le_right,[Nat, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, HPow.hPow, instHPow, instPowNatNat, Nat.below, Nat.succ, Or, Eq, Nat.lt_or_eq_or_le_succ, Nat.le_refl, Eq.symm],[Nat, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, HPow.hPow, instHPow, instPowNatNat]]
[«term_⊕'_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Int.repr,[Int, String, Nat, Nat.repr, HAppend.hAppend, instHAppend, String.instAppendString, Nat.succ],[Int, String]]
[List.filter,[Bool, List, List.filterAux, List.nil],[Bool, List]]
[Std.Format.group.injEq,[Std.Format, Std.Format.FlattenBehavior, Eq.propIntro, Eq, Std.Format.group, And, optParam, Std.Format.FlattenBehavior.allOrNone, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Std.Format, Std.Format.FlattenBehavior, Eq, Std.Format.group, And]]
[UInt16.land,[UInt16, UInt16.mk, Fin.land, UInt16.size, UInt16.val],[UInt16]]
[IO.Error.userError.injEq,[String, Eq.propIntro, Eq, IO.Error, IO.Error.userError, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[String, Eq, IO.Error, IO.Error.userError]]
[Neg.noConfusionType,[Neg, Eq],[Neg]]
[Lean.Parser.Tactic.cases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.casesTarget, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlts],[Lean.ParserDescr]]
[Array.filterMap,[Option, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Id.run, Array.filterMapM, Id, Id.instMonadId],[Option, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size]]
[instAddUInt8,[Add.mk, UInt8, UInt8.add],[Add, UInt8]]
[IO.Error.resourceBusy.inj,[UInt32, String, Eq, IO.Error, IO.Error.resourceBusy, And, And.intro],[UInt32, String, Eq, IO.Error, IO.Error.resourceBusy, And]]
[Lean.Parser.Tactic.Conv.nestedConv,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.Parser.Tactic.Conv.convSeqBracketed],[Lean.ParserDescr]]
[Fin.mul.proof_1,[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, HMul.hMul, instHMul, instMulNat],[Nat, LT.lt, instLTNat, HMod.hMod, instHMod, Nat.instModNat, HMul.hMul, instHMul, instMulNat]]
[Prod.allI,[Nat, Bool, Prod, Nat.anyAux, not, Prod.snd, HSub.hSub, instHSub, instSubNat, Prod.fst],[Nat, Bool, Prod]]
[USize.shiftLeft,[USize, USize.mk, HShiftLeft.hShiftLeft, Fin, USize.size, instHShiftLeft, Fin.instShiftLeftFin, USize.val, USize.modn, System.Platform.numBits],[USize]]
[Lean.Parser.Tactic.Conv.conv,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[UInt64.toNat,[UInt64, Fin.val, UInt64.size, UInt64.val],[UInt64, Nat]]
[String.takeWhile,[String, Char, Bool, Substring.toString, Substring.takeWhile, String.toSubstring],[String, Char, Bool]]
[IO.withStderr,[Monad, MonadFinally, MonadLiftT, IO, IO.FS.Stream, Bind.bind, Monad.toBind, liftM, EIO, IO.Error, IO.setStderr, tryFinally, PUnit, Applicative.toFunctor, Monad.toApplicative, Functor.discard],[Monad, MonadFinally, MonadLiftT, IO, IO.FS.Stream]]
[List.rotateRight,[List, optParam, Nat, OfNat.ofNat, instOfNatNat, List.length, ite, LE.le, instLENat, Nat.decLe, HSub.hSub, instHSub, instSubNat, HMod.hMod, instHMod, Nat.instModNat, List.take, List.drop, HAppend.hAppend, instHAppend, List.instAppendList],[List, optParam, Nat, OfNat.ofNat, instOfNatNat]]
[List.concat,[List, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd],[List]]
[Std.Format.group.sizeOf_spec,[Std.Format, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, String, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, Int],[Std.Format, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone, Eq, Nat, SizeOf.sizeOf, SizeOf.mk, OfNat.ofNat, instOfNatNat, String, HAdd.hAdd, instHAdd, instAddNat, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, Int, Std.Format.group]]
[Nat.mul_le_mul_left,[Nat, LE.le, instLENat, Exists, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.le.dest, HMul.hMul, instHMul, instMulNat],[Nat, LE.le, instLENat, HMul.hMul, instHMul, instMulNat]]
[instMonadExceptOfEST,[inferInstanceAs, MonadExceptOf, EStateM, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable],[MonadExceptOf, EST]]
[List.hasDecEq.proof_3,[List, Eq, List.nil, List.cons, False],[List, Eq, List.nil, List.cons, List.noConfusionType, False]]
[String.Iterator.prevn,[String.Iterator, Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, String.Iterator.prev],[String.Iterator, Nat]]
[DecidablePred,[Decidable],[]]
[StateT.run_map,[Monad, LawfulMonad, StateT, Eq.mpr, Eq, Prod, StateT.run, Functor.map, Applicative.toFunctor, Monad.toApplicative, StateT.instMonadStateT, Prod.mk, Prod.fst, Prod.snd, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, congrArg, map_eq_pure_bind, bind_congr, rfl, Eq.symm, Eq.refl],[Monad, LawfulMonad, StateT, Eq, Prod, StateT.run, Functor.map, Applicative.toFunctor, Monad.toApplicative, StateT.instMonadStateT, Prod.mk, Prod.fst, Prod.snd]]
[Nat.sub_self,[Nat, Eq, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, Nat.below, Unit, Eq.mpr, Eq.refl, Nat.sub_zero, rfl, Nat.succ, Nat.succ_sub_succ, PProd.fst, PUnit, PProd],[Nat, Eq, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat]]
[Array.uset,[Array, USize, LT.lt, Nat, instLTNat, USize.toNat, Array.size, Array.set, Fin.mk],[Array, USize, LT.lt, Nat, instLTNat, USize.toNat, Array.size]]
[Xor.noConfusionType,[Xor, Eq],[Xor]]
[Fin.add,[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, HAdd.hAdd, instHAdd, instAddNat, Fin.add.proof_1],[Nat, Fin]]
[calcStep,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary],[Lean.ParserDescr]]
[UInt64.modn,[UInt64, UInt64.mk, HMod.hMod, Fin, UInt64.size, Nat, Fin.instHModFinNatFin, UInt64.val],[UInt64]]
[Lean.Parser.Tactic.Conv.change,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[ofBoolUsing_eq_false,[Decidable, Eq, Bool, toBoolUsing, Bool.false, of_decide_eq_false],[Decidable, Eq, Bool, toBoolUsing, Bool.false, Not]]
[UInt16.ofNatCore,[LT.lt, Nat, instLTNat, UInt16.size, UInt16.mk, Fin.mk],[LT.lt, Nat, instLTNat, UInt16.size, UInt16]]
[Array.setD,[Array, Nat, dite, LT.lt, instLTNat, Array.size, Nat.decLt, Array.set, Fin.mk, Not],[Array, Nat]]
[Id.instLawfulMonadId.proof_1,[LawfulMonad.mk, Id, Id.instMonadId, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, Functor.map, id, Function.comp, SeqLeft.seqLeft, Applicative.toSeqLeft, Unit, SeqRight.seqRight, Applicative.toSeqRight, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, Bind.bind, Monad.toBind],[LawfulMonad, Id, Id.instMonadId]]
[Array.size_set,[Array, Fin, Array.size, List.length_set, Array.data, Fin.val],[Array, Fin, Array.size, Eq, Nat, Array.set]]
[Lean.Meta.Rewrite.Config.offsetCnstrs,[Lean.Meta.Rewrite.Config],[Lean.Meta.Rewrite.Config, Bool]]
[Int.decEq.proof_3,[Nat, Eq, Int, Int.negSucc, rfl],[Nat, Eq, Int, Int.negSucc]]
[List.reverse_reverse,[List, Eq.mpr, Eq, List.reverseAux, List.nil, Eq.refl, List.reverseAux_reverseAux_nil, rfl],[List, Eq, List.reverse]]
[Array.any,[Array, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Id.run, Array.anyM, Id, Id.instMonadId],[Array, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size]]
[instShiftRightUInt16,[ShiftRight.mk, UInt16, UInt16.shiftRight],[ShiftRight, UInt16]]
[instDecidableEqString,[String.decEq],[DecidableEq, String]]
[Char.utf8Size.proof_6,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size]]
[Nat.zero_mul,[Nat, Eq, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, Nat.below, Unit, rfl, Nat.succ, HAdd.hAdd, instHAdd, instAddNat, Eq.symm, PProd.fst, PUnit, PProd, Nat.mul_succ],[Nat, Eq, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat]]
[Std.Format.instInhabitedFlattenBehavior,[Inhabited.mk, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone],[Inhabited, Std.Format.FlattenBehavior]]
[instXorUInt64,[Xor.mk, UInt64, UInt64.xor],[Xor, UInt64]]
[UInt32.size,[OfNat.ofNat, Nat, instOfNatNat],[Nat]]
[UInt64.decLe,[UInt64, Decidable, LE.le, instLEUInt64, Fin, UInt64.size, inferInstanceAs, instLEFin, Fin.decLe],[UInt64, Decidable, LE.le, instLEUInt64]]
[Int.noConfusionType,[Int, Nat, Eq],[Int]]
[Nat.le_of_eq,[Nat, Eq, LE.le, instLENat, Nat.le_refl],[Nat, Eq, LE.le, instLENat]]
[Char.isDigit,[Char, and, Decidable.decide, GE.ge, UInt32, instLEUInt32, Char.val, OfNat.ofNat, instOfNatUInt32, instDecidableLe, LE.le],[Char, Bool]]
[Lean.instQuoteList,[Lean.Quote, Lean.Quote.mk, List, Lean.Syntax, List.below, Unit, List.nil, List.cons, Unit.unit, Lean.mkCIdent, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.mkCApp, List.toArray, Lean.Quote.quote, PProd.fst, PUnit, PProd],[Lean.Quote, List]]
[Lean.Parser.Tactic.rwSeq,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[ExceptT.instLawfulMonadExceptT,[ExceptT.instLawfulMonadExceptT.proof_1],[Monad, LawfulMonad, ExceptT, ExceptT.instMonadExceptT]]
[PSum.inr.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, PSum, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, PSum.inr]]
[EStateM.set,[EStateM.Result.ok, PUnit, PUnit.unit],[EStateM, PUnit]]
[Array.swap,[Array, Array.get, Array.set, Nat, Array.size, Array.swap.proof_1],[Array]]
[ExceptT.bind_pure_comp,[Monad, LawfulMonad, ExceptT, rfl, Bind.bind, Monad.toBind, ExceptT.instMonadExceptT, Function.comp, Pure.pure, Applicative.toPure, Monad.toApplicative],[Monad, LawfulMonad, ExceptT, Eq, Bind.bind, Monad.toBind, ExceptT.instMonadExceptT, Function.comp, Pure.pure, Applicative.toPure, Monad.toApplicative, Functor.map, Applicative.toFunctor]]
[orM,[Monad, ToBool, Bind.bind, Monad.toBind, Bool, ToBool.toBool, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative],[Monad, ToBool]]
[UInt16.decEq.proof_1,[Fin, UInt16.size, Eq, UInt16, UInt16.mk, rfl],[Fin, UInt16.size, Eq, UInt16, UInt16.mk]]
[Lean.instEval_1,[Repr, Lean.Eval.mk, Unit, optParam, Bool, Bool.true, IO.println, Std.Format, instToStringFormat, repr, Unit.unit],[Repr, Lean.Eval]]
[Lean.firstFrontendMacroScope,[HAdd.hAdd, Nat, instHAdd, instAddNat, Lean.reservedMacroScope, OfNat.ofNat, instOfNatNat],[Nat]]
[instHashableOption,[Hashable, Hashable.mk, Option, UInt64, Unit, OfNat.ofNat, instOfNatUInt64, mixHash, Hashable.hash],[Hashable, Option]]
[CoeTC.coe,[CoeTC],[CoeTC]]
[Repr.addAppParen,[Std.Format, Nat, ite, GE.ge, instLENat, OfNat.ofNat, instOfNatNat, Nat.decLe, Std.Format.paren],[Std.Format, Nat]]
[List.instForInList,[ForIn.mk, List, Monad, List.forIn],[ForIn, List]]
[false_of_ne,[Ne.irrefl],[Ne, False]]
[HPow.noConfusionType,[outParam, HPow, Eq],[outParam, HPow]]
[Sum.inr.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, Sum, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Sum.inr]]
[instDecidableEqSum.proof_1,[Eq, Sum, Sum.inl, rfl],[Eq, Sum, Sum.inl]]
[USize.mul,[USize, USize.mk, HMul.hMul, Fin, USize.size, instHMul, Fin.instMulFin, USize.val],[USize]]
[instInhabitedTrue,[Inhabited.mk, True, True.intro],[Inhabited, True]]
[WellFounded.fix_eq,[WellFounded, WellFounded.fixFEq, WellFounded.apply],[WellFounded, Eq, WellFounded.fix]]
[instSizeOfName,[SizeOf.mk, Lean.Name, Lean.Name.sizeOf],[SizeOf, Lean.Name]]
[Fin.instDivFin,[Nat, Div.mk, Fin, Fin.div],[Nat, Div, Fin]]
[Array.foldrMUnsafe,[Monad, Array, optParam, Nat, Array.size, OfNat.ofNat, instOfNatNat, USize, ite, LE.le, instLENat, Nat.decLe, LT.lt, instLTNat, Nat.decLt, USize.ofNat, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.foldrMUnsafe.fold],[Monad, Array, optParam, Nat, Array.size, OfNat.ofNat, instOfNatNat]]
[HAppend.hAppend,[HAppend],[HAppend]]
[Functor.discard,[Functor, Functor.mapConst, PUnit, PUnit.unit],[Functor, PUnit]]
[Subtype.mk.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, Subtype, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Subtype.mk]]
[Lean.Module.mk.inj,[Lean.Syntax, Array, Eq, Lean.Module, Lean.Module.mk, And, And.intro],[Lean.Syntax, Array, Eq, Lean.Module, Lean.Module.mk, And]]
[Subarray.forInUnsafe.loop,[Monad, Subarray, ForInStep, USize, ite, LT.lt, instLTUSize, instDecidableLt_4, Array.uget, Subarray.as, lcProof, Nat, instLTNat, USize.toNat, Array.size, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Subarray.forInUnsafe.loop, HAdd.hAdd, instHAdd, instAddUSize, OfNat.ofNat, instOfNatUSize],[Monad, Subarray, ForInStep, USize]]
[Lean.Syntax.setInfo,[Lean.SourceInfo, Lean.Syntax, String, Lean.Syntax.atom, Substring, Lean.Name, List, Prod, Lean.Syntax.ident],[Lean.SourceInfo, Lean.Syntax]]
[instComplementUInt16,[Complement.mk, UInt16, UInt16.complement],[Complement, UInt16]]
[IO.Error.noSuchThing.inj,[Option, String, UInt32, Eq, IO.Error, IO.Error.noSuchThing, And, And.intro],[Option, String, UInt32, Eq, IO.Error, IO.Error.noSuchThing, And]]
[instToStringByteArray,[ToString.mk, ByteArray, List.toString, UInt8, instToStringUInt8, ByteArray.toList],[ToString, ByteArray]]
[instSubsingletonSquash.proof_1,[Subsingleton.intro, Squash, Squash.ind, Eq, Squash.mk, Quot.sound, True, True.intro],[Subsingleton, Squash]]
[UInt32.ofNatCore,[LT.lt, Nat, instLTNat, UInt32.size, UInt32.mk, Fin.mk],[LT.lt, Nat, instLTNat, UInt32.size, UInt32]]
[term!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Nat.gcd_zero_right,[Nat, Eq, Nat.gcd, OfNat.ofNat, instOfNatNat, Nat.zero, of_eq_true, Eq.trans, True, congr, congrArg, congrFun, Nat.zero_eq, Nat.gcd_zero_left, eq_true_of_decide, instDecidableEqNat, Eq.refl, Bool, Bool.true, Eq.symm, Nat.succ, HMod.hMod, instHMod, Nat.instModNat, Nat.gcd_succ, Nat.zero_mod, eq_self],[Nat, Eq, Nat.gcd, OfNat.ofNat, instOfNatNat]]
[System.Platform.numBits,[Subtype.val, Nat, Or, Eq, OfNat.ofNat, instOfNatNat, System.Platform.getNumBits, Unit.unit],[Nat]]
[instDecidableEqUSize,[USize.decEq],[DecidableEq, USize]]
[instMulUInt16,[Mul.mk, UInt16, UInt16.mul],[Mul, UInt16]]
[instOrdBool,[Ord.mk, Bool, Ordering, Unit, Ordering.lt, Ordering.gt, Ordering.eq],[Ord, Bool]]
[String.append,[String, List, Char, String.mk, HAppend.hAppend, instHAppend, List.instAppendList],[String]]
[instHashableBool,[Hashable.mk, Bool, UInt64, Unit, OfNat.ofNat, instOfNatUInt64],[Hashable, Bool]]
[String.Iterator.prev,[String.Iterator, String, String.Pos, String.Iterator.mk, String.prev],[String.Iterator]]
[List.appendTR,[List, List.reverseAux, List.reverse],[List]]
[Nat.decLe,[dite, Decidable, LE.le, Nat, instLENat, Eq, Bool, Nat.ble, Bool.true, instDecidableEqBool, Decidable.isTrue, Nat.le_of_ble_eq_true, Not, Decidable.isFalse, Nat.not_le_of_not_ble_eq_true],[Decidable, LE.le, Nat, instLENat]]
[IO.Error.hardwareFault.sizeOf_spec,[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar],[UInt32, String, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, Option, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.hardwareFault]]
[«term_∧_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[AndOp.noConfusionType,[AndOp, Eq],[AndOp]]
[ByteArray.isEmpty,[ByteArray, BEq.beq, Nat, instBEq, instDecidableEqNat, ByteArray.size, OfNat.ofNat, instOfNatNat],[ByteArray, Bool]]
[Lean.NameGenerator.mk.inj,[Lean.Name, Nat, Eq, Lean.NameGenerator, Lean.NameGenerator.mk, And, And.intro],[Lean.Name, Nat, Eq, Lean.NameGenerator, Lean.NameGenerator.mk, And]]
[Thunk.pure,[Thunk.mk, Unit],[Thunk]]
[Std.Format.joinSep,[Std.ToFormat, List, Std.Format, List.below, List.nil, Std.Format.nil, List.cons, Std.ToFormat.format, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, PProd.fst, PUnit, PProd],[Std.ToFormat, List, Std.Format]]
[StateCpsT,[],[]]
[Mul.noConfusionType,[Mul, Eq],[Mul]]
[HEq.trans,[HEq, HEq.subst],[HEq]]
[instDecidableEqUInt16,[UInt16.decEq],[DecidableEq, UInt16]]
[Array.mapIdx,[Array, Fin, Array.size, Id.run, Array.mapIdxM, Id, Id.instMonadId],[Array, Fin, Array.size]]
[List.length_nil,[rfl, Nat, List.length, List.nil],[Eq, Nat, List.length, List.nil, OfNat.ofNat, instOfNatNat]]
[Array.mk.injEq,[List, Eq.propIntro, Eq, Array, Array.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[List, Eq, Array, Array.mk]]
[List.partition,[Bool, List, List.partitionAux, Prod.mk, List.nil],[Bool, List, Prod]]
[Lean.instInhabitedParserDescr,[Inhabited.mk, Lean.ParserDescr, Lean.ParserDescr.symbol],[Inhabited, Lean.ParserDescr]]
[Lean.Syntax.ident.injEq,[Lean.SourceInfo, Substring, Lean.Name, List, Prod, String, Eq.propIntro, Eq, Lean.Syntax, Lean.Syntax.ident, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Lean.SourceInfo, Substring, Lean.Name, List, Prod, String, Eq, Lean.Syntax, Lean.Syntax.ident, And]]
[Nat.gcd_succ,[Nat, rfl, Nat.gcd, Nat.succ],[Nat, Eq, Nat.gcd, Nat.succ, HMod.hMod, instHMod, Nat.instModNat]]
[Option.all,[Bool, Option, Unit, Bool.true],[Bool, Option]]
[«term_*>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Int.negSucc.injEq,[Nat, Eq.propIntro, Eq, Int, Int.negSucc, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Nat, Eq, Int, Int.negSucc]]
[IO.FS.FileType.dir.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, IO.FS.FileType, SizeOf.mk, OfNat.ofNat, instOfNatNat, IO.FS.FileType.dir]]
[IO.FS.Handle.putStrLn,[IO.FS.Handle, String, IO.FS.Handle.putStr, String.push, Char.ofNat],[IO.FS.Handle, String, IO, Unit]]
[instHModUSizeNatUSize,[HMod.mk, USize, Nat, USize.modn],[HMod, USize, Nat]]
[StateT.run,[StateT],[StateT, Prod]]
[Lean.Parser.Tactic.changeWith,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[ExceptT.mk,[Except],[Except, ExceptT]]
[Lean.Name.instAppendName,[Append.mk, Lean.Name, Lean.Name.append],[Append, Lean.Name]]
[String.push,[String, Char, List, String.mk, HAppend.hAppend, instHAppend, List.instAppendList, List.cons, List.nil],[String, Char]]
[Option.instDecidableRelLt,[DecidableRel, Option, Decidable, Option.lt, Decidable.isTrue, Option.none, Option.some, trivial, Decidable.isFalse, not_false, Unit],[DecidableRel, Option, Option.lt]]
[UInt64.shiftRight,[UInt64, UInt64.mk, HShiftRight.hShiftRight, Fin, UInt64.size, instHShiftRight, Fin.instShiftRightFin, UInt64.val, UInt64.modn, OfNat.ofNat, Nat, instOfNatNat],[UInt64]]
[Char.isUpper,[Char, and, Decidable.decide, GE.ge, UInt32, instLEUInt32, Char.val, OfNat.ofNat, instOfNatUInt32, instDecidableLe, LE.le],[Char, Bool]]
[String.instLTString,[LT.mk, String, LT.lt, List, Char, List.instLTList, Char.instLTChar, String.data],[LT, String]]
[EStateM.Result.ok.injEq,[Eq.propIntro, Eq, EStateM.Result, EStateM.Result.ok, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Eq, EStateM.Result, EStateM.Result.ok, And]]
[List.getD,[Nat, List, Option.getD, List.get?],[Nat, List]]
[MProd.snd,[MProd],[MProd]]
[IO.FS.Stream.ofHandle,[IO.FS.Handle, IO.FS.Stream.mk, IO.FS.Handle.isEof, IO.FS.Handle.flush, IO.FS.Handle.read, IO.FS.Handle.write, IO.FS.Handle.getLine, IO.FS.Handle.putStr],[IO.FS.Handle, IO.FS.Stream]]
[IO.Error.fopenErrorToString,[String, UInt32, Option, HAppend.hAppend, instHAppend, String.instAppendString, String.modify, OfNat.ofNat, String.Pos, instOfNatNat, Char.toLower, ToString.toString, instToStringUInt32, Unit],[String, UInt32, Option]]
[Lean.instQuoteArray,[Lean.Quote, Lean.Quote.mk, Array, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, Lean.Syntax, List.cons, Lean.Quote.quote, List, Lean.instQuoteList, Array.toList, List.nil],[Lean.Quote, Array]]
[IO.FS.Mode.noConfusion,[IO.FS.Mode, Eq, noConfusionEnum, Nat, instDecidableEqNat, IO.FS.Mode.toCtorIdx],[IO.FS.Mode, Eq, IO.FS.Mode.noConfusionType]]
[ForIn.noConfusionType,[outParam, ForIn, Monad, ForInStep, Eq],[outParam, ForIn]]
[ToString.toString,[ToString],[ToString, String]]
[Array.anyM.loop.proof_1,[Array, Nat, LE.le, instLENat, Array.size, LT.lt, instLTNat, Nat.lt_of_lt_of_le],[Array, Nat, LE.le, instLENat, Array.size, LT.lt, instLTNat]]
[Acc.ndrecOn,[Acc],[Acc]]
[Quot.recOnSubsingleton.proof_1,[Quot, Subsingleton, Quot.mk, Subsingleton.elim, Quot.sound],[Quot, Subsingleton, Quot.mk, Eq, Quot.sound]]
[String.utf8ByteSize,[String, Nat, List, Char, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, String.csize, OfNat.ofNat, instOfNatNat],[Nat]]
[UInt32.sub,[UInt32, UInt32.mk, HSub.hSub, Fin, UInt32.size, instHSub, Fin.instSubFin, UInt32.val],[UInt32]]
[iff_iff_implies_and_implies,[Iff.intro, Iff, And, And.intro, Iff.mp, Iff.mpr, And.left, And.right],[Iff, And]]
[StdGen.s1,[StdGen],[StdGen, Nat]]
[Array.findRevM?,[Monad, Array, Bool, Array.findSomeRevM?, Bind.bind, Monad.toBind, Option, Pure.pure, Applicative.toPure, Monad.toApplicative, ite, Eq, Bool.true, instDecidableEqBool, Option.some, Option.none],[Monad, Array, Bool, Option]]
[System.SearchPath.toString,[System.SearchPath, String.intercalate, Char.toString, System.SearchPath.separator, List.map, System.FilePath, String, System.FilePath.toString],[System.SearchPath, String]]
[Array.instHAppendArrayListArray,[HAppend.mk, Array, List, Array.appendList],[HAppend, Array, List]]
[IO.FS.FileType.toCtorIdx,[IO.FS.FileType, Nat, OfNat.ofNat, instOfNatNat],[IO.FS.FileType, Nat]]
[Nat.lt,[Nat, Nat.le, Nat.succ],[Nat]]
[of_decide_eq_false,[Decidable, Eq, Bool, Decidable.decide, Bool.false, Not, absurd, ne_false_of_eq_true, decide_eq_true],[Decidable, Eq, Bool, Decidable.decide, Bool.false, Not]]
[StateT.run_monadLift,[Monad, MonadLiftT, rfl, Prod, StateT.run, MonadLiftT.monadLift, StateT, instMonadLiftT, StateT.instMonadLiftStateT],[Monad, MonadLiftT, Eq, Prod, StateT.run, MonadLiftT.monadLift, StateT, instMonadLiftT, StateT.instMonadLiftStateT, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk]]
[Bool.or_self,[Bool, Eq, or, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl],[Bool, Eq, or]]
[LawfulMonad.bind_assoc,[Monad, LawfulMonad],[Monad, LawfulMonad, Eq, Bind.bind, Monad.toBind]]
[Mul.mul,[Mul],[Mul]]
[EStateM.instMonadStateOfEStateM,[MonadStateOf.mk, EStateM, EStateM.get, EStateM.set, EStateM.modifyGet],[MonadStateOf, EStateM]]
[List.instEmptyCollectionList,[EmptyCollection.mk, List, List.nil],[EmptyCollection, List]]
[UInt16.xor,[UInt16, UInt16.mk, Fin.xor, UInt16.size, UInt16.val],[UInt16]]
[UInt64.toUInt32,[UInt64, Nat.toUInt32, UInt64.toNat],[UInt64, UInt32]]
[instLTFloat,[LT.mk, Float, Float.lt],[LT, Float]]
[List.length_eq_lenghtTR,[funext, List, Nat, List.length, List.lengthTR, of_eq_true, Eq, List.lengthTRAux, OfNat.ofNat, instOfNatNat, Eq.trans, True, congrArg, HAdd.hAdd, instHAdd, instAddNat, Eq.symm, List.length_add_eq_lengthTRAux, Nat.add_zero, eq_self],[Eq, List, Nat, List.length, List.lengthTR]]
[System.FilePath.extSeparator,[Char.ofNat],[Char]]
[Lean.Macro.instMonadQuotationMacroM,[Lean.MonadQuotation.mk, Lean.MacroM, Lean.Macro.instMonadRefMacroM, Lean.Macro.Context, Pure.pure, EStateM, Lean.Macro.Exception, Lean.Macro.State, Applicative.toPure, Monad.toApplicative, EStateM.instMonadEStateM, Lean.MacroScope, Lean.Macro.Context.currMacroScope, Lean.Name, Lean.Macro.Context.mainModule, Lean.Macro.withFreshMacroScope],[Lean.MonadQuotation, Lean.MacroM]]
[List.cons.injEq,[List, Eq.propIntro, Eq, List.cons, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[List, Eq, List.cons, And]]
[instInhabitedProp,[Inhabited.mk, True],[Inhabited]]
[ReaderT.instMonadReaderT,[Monad, Monad.mk, ReaderT, Applicative.mk, Functor.mk, ReaderT.map, Pure.mk, ReaderT.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk, ReaderT.bind],[Monad, ReaderT]]
[Lean.Syntax.mkNumLit,[String, optParam, Lean.SourceInfo, Lean.SourceInfo.none, Lean.Syntax.mkLit, Lean.numLitKind],[String, optParam, Lean.SourceInfo, Lean.SourceInfo.none, Lean.Syntax]]
[Nat.pow_succ,[Nat, rfl, HPow.hPow, instHPow, instPowNatNat, Nat.succ],[Nat, Eq, HPow.hPow, instHPow, instPowNatNat, Nat.succ, HMul.hMul, instHMul, instMulNat]]
[Lean.MonadRef.mkInfoFromRefPos,[Monad, Lean.MonadRef, Bind.bind, Monad.toBind, Lean.Syntax, Lean.SourceInfo, Lean.MonadRef.getRef, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.SourceInfo.fromRef],[Monad, Lean.MonadRef, Lean.SourceInfo]]
[Std.Format.FlattenBehavior.fill.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, Std.Format.FlattenBehavior, SizeOf.mk, OfNat.ofNat, instOfNatNat, Std.Format.FlattenBehavior.fill]]
[OptionM.run,[OptionM],[OptionM, Option]]
[Lean.ParserDescr.ibelow,[Lean.ParserDescr, Lean.Name, True, And, Lean.SyntaxNodeKind, Nat, String, Bool, optParam, Bool.false],[Lean.ParserDescr]]
[instDecidableEqProd.proof_1,[Eq, Prod, Prod.mk, rfl],[Eq, Prod, Prod.mk]]
[instSizeOf,[SizeOf.mk, default.sizeOf],[SizeOf]]
[DoResultPRBC.pure.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, DoResultPRBC, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, DoResultPRBC.pure]]
[Lean.Syntax.decodeQuotedChar,[String, String.Pos, OptionM.run, Prod, Char, String.get, String.next, ite, OptionM, Eq, Bool, BEq.beq, instBEq, instDecidableEqChar, Char.ofNat, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Alternative.toApplicative, OptionT.instAlternativeOptionT, Id, Id.instMonadId, Prod.mk, Bind.bind, Monad.toBind, OptionT.instMonadOptionT, Nat, Option, and, Decidable.decide, LE.le, Char.instLEChar, Char.instDecidableLe, Option.some, HSub.hSub, instHSub, instSubNat, Char.toNat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Option.none, HMul.hMul, instHMul, instMulNat],[String, String.Pos, Option, Prod, Char]]
[HAndThen.hAndThen,[HAndThen],[HAndThen, Unit]]
[String.foldrAux,[Char, String, String.Pos, String.foldrAux.loop],[Char, String, String.Pos]]
[cond,[Bool, Unit],[Bool]]
[«term_%_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Array.get?,[Array, Nat, dite, Option, LT.lt, instLTNat, Array.size, Nat.decLt, Option.some, Array.get, Fin.mk, Not, Option.none],[Array, Nat, Option]]
[Substring.bsize,[Substring, Nat, String, String.Pos, Nat.sub],[Substring, Nat]]
[Char.quoteCore,[Char, ite, String, Eq, Char.ofNat, instDecidableEqChar, Or, LE.le, Nat, instLENat, Char.toNat, OfNat.ofNat, instOfNatNat, instDecidableOr, Nat.decLe, HAppend.hAppend, instHAppend, String.instAppendString, charToHex, String.singleton],[Char, String]]
[Lean.Name.hash.proof_1,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt64.size, Nat.decLt, Eq.refl, Bool, Bool.true],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt64.size]]
[Array.findSomeM?,[Monad, Array, Option, Bind.bind, Monad.toBind, MProd, PUnit, ForIn.forIn, Array.instForInArray, MProd.mk, Option.none, PUnit.unit, ForInStep, Pure.pure, Applicative.toPure, Monad.toApplicative, ForInStep.done, Option.some, ForInStep.yield, MProd.fst, Unit],[Monad, Array, Option]]
[«term_>>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Std.Format.bracket,[String, Std.Format, Std.Format.group, Std.Format.nest, Int.ofNat, String.length, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone],[String, Std.Format]]
[instMonadLiftSTEST,[MonadLift.mk, ST, EST, EStateM.Result, Empty, EStateM.Result.ok],[MonadLift, ST, EST]]
[UInt32.decEq.proof_1,[Fin, UInt32.size, Eq, UInt32, UInt32.mk, rfl],[Fin, UInt32.size, Eq, UInt32, UInt32.mk]]
[OrOp.or,[OrOp],[OrOp]]
[trivial,[True.intro],[True]]
[Lean.Meta.Simp.instReprConfig,[Repr.mk, Lean.Meta.Simp.Config, Nat, Std.Format.bracket, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.nil, Std.Format.text, repr, instReprNat, Lean.Meta.Simp.Config.maxSteps, Std.Format.line, Lean.Meta.Simp.Config.maxDischargeDepth, Bool, instReprBool, Lean.Meta.Simp.Config.contextual, Lean.Meta.Simp.Config.memoize, Lean.Meta.Simp.Config.singlePass, Lean.Meta.Simp.Config.zeta, Lean.Meta.Simp.Config.beta, Lean.Meta.Simp.Config.eta, Lean.Meta.Simp.Config.iota, Lean.Meta.Simp.Config.proj, Lean.Meta.Simp.Config.decide],[Repr, Lean.Meta.Simp.Config]]
[withTheReader,[MonadWithReaderOf, MonadWithReaderOf.withReader],[MonadWithReaderOf]]
[Lean.Macro.resolveNamespace?,[Lean.Name, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, Option, Lean.Macro.getMethods, Lean.Macro.Methods.resolveNamespace?],[Lean.Name, Lean.MacroM, Option]]
[Lean.mkOptionalNode,[Option, Lean.Syntax, Lean.Syntax.node, Lean.nullKind, List.toArray, List.cons, List.nil, Unit],[Option, Lean.Syntax]]
[Sigma.mk.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, Sigma, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Sigma.mk]]
[Subarray.as,[Subarray],[Subarray, Array]]
[Array.insertionSort.traverse,[Bool, Array, Nat, Nat.below, Unit, Nat.succ, dite, LT.lt, instLTNat, Array.size, Nat.decLt, PProd.fst, PUnit, PProd, Array.insertionSort.swapLoop, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Not],[Bool, Array, Nat]]
[Substring.toString,[Substring, String, String.Pos, String.extract],[Substring, String]]
[Lean.Meta.Simp.Config.eta,[Lean.Meta.Simp.Config],[Lean.Meta.Simp.Config, Bool]]
[ExceptT.run,[ExceptT],[ExceptT, Except]]
[Nat.toFloat,[Nat, Float.ofNat],[Nat, Float]]
[Std.Format.nest.injEq,[Int, Std.Format, Eq.propIntro, Eq, Std.Format.nest, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Int, Std.Format, Eq, Std.Format.nest, And]]
[Subarray.allM,[Monad, Bool, Subarray, Array.allM, Subarray.as, Subarray.start, Subarray.stop],[Monad, Bool, Subarray]]
[Lean.Macro.Context.maxRecDepth,[Lean.Macro.Context],[Lean.Macro.Context, Nat]]
[IO.FS.Handle.readBinToEnd,[IO.FS.Handle, ByteArray, IO, ByteArray.empty, IO.FS.Handle.readBinToEnd.loop],[IO.FS.Handle, IO, ByteArray]]
[Lean.Syntax.hasArgs,[Lean.Syntax, Bool, Lean.SyntaxNodeKind, Array, Decidable.decide, GT.gt, Nat, instLTNat, Array.size, OfNat.ofNat, instOfNatNat, Nat.decLt, Bool.false],[Lean.Syntax, Bool]]
[String.posOf,[String, Char, String.posOfAux, String.bsize, OfNat.ofNat, String.Pos, instOfNatNat],[String, Char, String.Pos]]
[Option.lt,[Option, True, False],[Option]]
[Array.forIn.loop.proof_1,[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Nat.lt_of_le_of_lt, HSub.hSub, instHSub, instSubNat, Nat.sub_le, Nat.sub_lt, LT.lt, instLTNat, Nat.below, Nat.succ, Nat.zero, Nat.lt_of_lt_of_le, Nat.lt_succ_self, of_decide_eq_true, Nat.decLt, Eq.refl, Bool, Bool.true],[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, LT.lt, instLTNat, HSub.hSub, instHSub, instSubNat]]
[Array.mkArray,[Nat, Array.mk, List.replicate],[Nat, Array]]
[instDecidableEqQuotient,[Setoid, Decidable, HasEquiv.Equiv, instHasEquiv, Quotient, Quotient.recOnSubsingleton₂, Eq, instDecidableEqQuotient.proof_1, Quotient.mk, Decidable.isTrue, Quotient.sound, Not, Decidable.isFalse, instDecidableEqQuotient.proof_2],[Setoid, Decidable, HasEquiv.Equiv, instHasEquiv, DecidableEq, Quotient]]
[Except.map,[Except, Except.error, Except.ok],[Except]]
[List.reverse_cons,[List, Eq.mpr, Eq, List.reverseAux, List.cons, List.nil, HAppend.hAppend, instHAppend, List.instAppendList, Eq.refl, Eq.symm, List.reverseAux_eq_append, rfl],[List, Eq, List.reverse, List.cons, HAppend.hAppend, instHAppend, List.instAppendList, List.nil]]
[Lean.MonadNameGenerator.noConfusionType,[Lean.MonadNameGenerator, Lean.NameGenerator, Unit, Eq],[Lean.MonadNameGenerator]]
[Int.instDivInt,[Div.mk, Int, Int.div],[Div, Int]]
[CoeTail.coe,[CoeTail],[CoeTail]]
[Nat.not_succ_le_self,[Nat, Not, LE.le, instLENat, Nat.succ, Nat.below, Unit, Nat.not_succ_le_zero, OfNat.ofNat, instOfNatNat, absurd, HAdd.hAdd, instHAdd, instAddNat, False, Nat.le_of_succ_le_succ, PProd.fst, PUnit, PProd],[Nat, Not, LE.le, instLENat, Nat.succ]]
[«command_ClassAbbrev__:_:=__,»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[MonadFunctorT.noConfusionType,[MonadFunctorT, Eq],[MonadFunctorT]]
[Fin.lor.proof_1,[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, Nat.lor],[Nat, LT.lt, instLTNat, HMod.hMod, instHMod, Nat.instModNat, Nat.lor]]
[Except.toOption,[Except, Option, Option.some, Option.none],[Except, Option]]
[String.instAppendString,[Append.mk, String, String.append],[Append, String]]
[Fin.sub,[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, HAdd.hAdd, instHAdd, instAddNat, HSub.hSub, instHSub, instSubNat, Fin.sub.proof_1],[Nat, Fin]]
[Char.toString,[Char, String.singleton],[Char, String]]
[MonadLift.monadLift,[MonadLift],[MonadLift]]
[Functor.noConfusionType,[Functor, Eq],[Functor]]
[instHashableInt,[Hashable.mk, Int, UInt64, Nat, UInt64.ofNat, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat],[Hashable, Int]]
[AndThen.noConfusionType,[AndThen, Unit, Eq],[AndThen]]
[Lean.Meta.TransparencyMode.noConfusionType,[Lean.Meta.TransparencyMode, noConfusionTypeEnum, Nat, instDecidableEqNat, Lean.Meta.TransparencyMode.toCtorIdx],[Lean.Meta.TransparencyMode]]
[Except.error.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, Except, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Except.error]]
[List.filterMap,[Option, List, List.below, Unit, List.nil, List.cons, PProd.fst, PUnit, PProd],[Option, List]]
[Lean.Parser.Tactic.rename,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[USize.modn_lt,[Nat, USize, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, LT.lt, USize.toNat, HMod.hMod, instHModUSizeNatUSize, Fin, USize.size, Fin.modn_lt],[Nat, USize, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, LT.lt, USize.toNat, HMod.hMod, instHModUSizeNatUSize]]
[Subtype.existsOfSubtype,[Subtype.existsOfSubtype.proof_1],[Subtype, Exists]]
[DecidableEq,[Decidable, Eq],[]]
[String.dropRightWhile,[String, Char, Bool, Substring.toString, Substring.dropRightWhile, String.toSubstring],[String, Char, Bool]]
[UInt32.shiftLeft,[UInt32, UInt32.mk, HShiftLeft.hShiftLeft, Fin, UInt32.size, instHShiftLeft, Fin.instShiftLeftFin, UInt32.val, UInt32.modn, OfNat.ofNat, Nat, instOfNatNat],[UInt32]]
[instDecidableEqNat,[Nat.decEq],[DecidableEq, Nat]]
[InvImage.accessible,[InvImage.accessible.proof_1],[Acc, InvImage]]
[PSigma.eta,[Eq, PSigma, PSigma.mk, Eq.refl, rfl],[Eq, PSigma, PSigma.mk]]
[instComplementUInt32,[Complement.mk, UInt32, UInt32.complement],[Complement, UInt32]]
[FloatSpec.mk.sizeOf_spec,[DecidableRel, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOf],[DecidableRel, Eq, Nat, SizeOf.sizeOf, FloatSpec, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, instSizeOf, FloatSpec.mk]]
[ltOfOrd,[Ord, LT.mk, Eq, Bool, BEq.beq, Ordering, instBEqOrdering, Ord.compare, Ordering.lt, Bool.true],[Ord, LT]]
[instLEUSize,[LE.mk, USize, USize.le],[LE, USize]]
[IO.Process.Stdio.piped.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, IO.Process.Stdio, SizeOf.mk, OfNat.ofNat, instOfNatNat, IO.Process.Stdio.piped]]
[Nat.le_succ_of_le,[Nat, LE.le, instLENat, Nat.le_trans, Nat.succ, Nat.le_succ],[Nat, LE.le, instLENat, Nat.succ]]
[«termIfLet_:=_Then_Else_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Bool.false.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, Bool, SizeOf.mk, OfNat.ofNat, instOfNatNat, Bool.false]]
[Array.insertionSort.swapLoop,[Bool, Array, Nat, LT.lt, instLTNat, Array.size, Nat.below, Eq, Eq.refl, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ],[Bool, Array, Nat, LT.lt, instLTNat, Array.size]]
[ByteArray.data,[ByteArray],[ByteArray, Array, UInt8]]
[String.noConfusionType,[String, List, Char, Eq],[String]]
[Nat.instXorNat,[Xor.mk, Nat, Nat.xor],[Xor, Nat]]
[instLTNat,[LT.mk, Nat, Nat.lt],[LT, Nat]]
[instDecidableArrow,[Decidable, dite, Decidable.isTrue, instDecidableArrow.proof_1, Not, Decidable.isFalse, instDecidableArrow.proof_2, instDecidableArrow.proof_3],[Decidable]]
[Array.unzip,[Array, Prod, Array.foldl, Prod.mk, Array.push, List.toArray, List.nil, OfNat.ofNat, Nat, instOfNatNat, Array.size],[Array, Prod]]
[Nat.one_ne_zero,[Eq, Nat, OfNat.ofNat, instOfNatNat, False],[Ne, Nat, OfNat.ofNat, instOfNatNat]]
[UInt32.mk.sizeOf_spec,[Fin, UInt32.size, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[Fin, UInt32.size, Eq, Nat, SizeOf.sizeOf, UInt32, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, LT.lt, instLTNat, instSizeOfNat, instSizeOf, UInt32.mk]]
[Quotient.ind,[Setoid, Quotient, Quot.ind, Setoid.r],[Setoid, Quotient, Quotient.mk, Quot, Setoid.r]]
[String.front,[String, String.get, OfNat.ofNat, String.Pos, instOfNatNat],[String, Char]]
[System.FilePath.extension,[System.FilePath, Option.bind, String, System.FilePath.fileName, Option, String.Pos, String.revPosOf, Char.ofNat, Unit, Option.none, Option.some, String.extract, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, String.bsize],[System.FilePath, Option, String]]
[List.nil.sizeOf_spec,[SizeOf, Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[SizeOf, Eq, Nat, SizeOf.sizeOf, List, SizeOf.mk, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, List.nil]]
[IO.Process.output,[IO.Process.SpawnArgs, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.Process.Child, IO.Process.SpawnArgs.toStdioConfig, IO.Process.SpawnArgs.mk, IO.Process.StdioConfig.mk, IO.Process.StdioConfig.stdin, IO.Process.Stdio.piped, IO.Process.SpawnArgs.cmd, IO.Process.SpawnArgs.args, IO.Process.SpawnArgs.cwd, IO.Process.SpawnArgs.env, IO.Process.Output, IO.Process.spawn, Task, Except, String, IO.asTask, IO.FS.Handle.readToEnd, IO.Process.Child.stdout, Task.Priority.dedicated, IO.Process.Child.stderr, UInt32, IO.Process.Child.wait, IO.ofExcept, IO.Error.instToStringError, Task.get, Pure.pure, Applicative.toPure, Monad.toApplicative, IO.Process.Output.mk],[IO.Process.SpawnArgs, IO, IO.Process.Output]]
[coeD,[CoeDep, CoeDep.coe],[CoeDep]]
[instSTWorld,[outParam, MonadLift, STWorld, STWorld.mk],[outParam, MonadLift, STWorld]]
[coeOfHeadOfTC,[CoeHead, CoeTC, CoeHTCT.mk, coeTC, coeHead],[CoeHead, CoeTC, CoeHTCT]]
[StateRefT'.instMonadLiftStateRefT',[MonadLift.mk, StateRefT', StateRefT'.lift],[MonadLift, StateRefT']]
[instDecidableLt,[UInt32, UInt32.decLt],[UInt32, Decidable, LT.lt, instLTUInt32]]
[instReprULift,[Repr, Repr.mk, ULift, Nat, Repr.addAppParen, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.text, reprArg, ULift.down],[Repr, ULift]]
[Lean.Syntax.SepArray.ofElemsUsingRef,[Monad, Lean.MonadRef, String, Array, Lean.Syntax, Bind.bind, Monad.toBind, Lean.Syntax.SepArray, Lean.MonadRef.getRef, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.SepArray.mk, Lean.mkSepArray, Lean.mkAtomFrom],[Monad, Lean.MonadRef, String, Array, Lean.Syntax, Lean.Syntax.SepArray]]
[Substring.contains,[Substring, Char, Substring.any, BEq.beq, instBEq, instDecidableEqChar],[Substring, Char, Bool]]
[StateT.modifyGet,[Monad, Prod, Pure.pure, Applicative.toPure, Monad.toApplicative],[Monad, Prod, StateT]]
[String.bsize,[String, String.utf8ByteSize],[String, Nat]]
[DoResultPRBC.return.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, DoResultPRBC, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, DoResultPRBC.return]]
[Array.instEmptyCollectionArray,[EmptyCollection.mk, Array, Array.empty],[EmptyCollection, Array]]
[Lean.Syntax.isNone,[Lean.Syntax, Bool, Lean.SyntaxNodeKind, Array, and, BEq.beq, Lean.Name.instBEqName, Lean.nullKind, Nat, instBEq, instDecidableEqNat, Array.size, OfNat.ofNat, instOfNatNat, Unit, Bool.true, Bool.false],[Lean.Syntax, Bool]]
[UInt8.toUInt32,[UInt8, Nat.toUInt32, UInt8.toNat],[UInt8, UInt32]]
[String.set,[String, String.Pos, Char, List, String.mk, List.below, List.nil, List.cons, ite, Eq, instDecidableEqNat, PProd.fst, PUnit, PProd, HAdd.hAdd, Nat, instHAdd, instAddNat, String.csize, OfNat.ofNat, instOfNatNat],[String, Char]]
[Nat.foldAux,[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, HSub.hSub, instHSub, instSubNat],[Nat]]
[MProd.mk.injEq,[Eq.propIntro, Eq, MProd, MProd.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Eq, MProd, MProd.mk, And]]
[Lean.instQuoteSubstring,[Lean.Quote.mk, Substring, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, Lean.Syntax, List.cons, Lean.Quote.quote, String, Lean.instQuoteString, Substring.toString, List.nil],[Lean.Quote, Substring]]
[Seq.noConfusionType,[Seq, Unit, Eq],[Seq]]
[IO.Process.StdioConfig.stdin,[IO.Process.StdioConfig],[IO.Process.StdioConfig, IO.Process.Stdio]]
[Subtype.noConfusionType,[Subtype, Eq],[Subtype]]
[fix6,[Inhabited, fixCore6, arbitrary],[Inhabited]]
[Nat.lor,[Nat.bitwise, or],[Nat]]
[ByteArray.mkEmpty,[ByteArray.mk, List.toArray, UInt8, List.nil],[ByteArray]]
[List.toByteArray,[List, UInt8, ByteArray, ByteArray.empty, List.toByteArray.loop],[List, UInt8, ByteArray]]
[Nat.lt.step.proof_1,[Nat, Nat.le_step, Nat.succ],[Nat, LE.le, instLENat, Nat.succ]]
[ByteArray.set!,[ByteArray, Nat, UInt8, Array, ByteArray.mk, Array.set!],[ByteArray, UInt8]]
[instTransEq,[Trans.mk, Eq, instTransEq.proof_1],[Trans, Eq]]
[PLift.noConfusionType,[PLift, Eq],[PLift]]
[Task.get,[Task],[Task]]
[FloatSpec.mk.inj,[DecidableRel, Eq, FloatSpec, FloatSpec.mk, And, HEq, And.intro],[DecidableRel, Eq, FloatSpec, FloatSpec.mk, And, HEq]]
[UInt64.toUInt8,[UInt64, Nat.toUInt8, UInt64.toNat],[UInt64, UInt8]]
[Array.ext,[Array, Eq, Nat, Array.size, LT.lt, instLTNat, Array.get, Fin.mk, List, List.length, List.get, Array.mk, congrArg, Eq.symm, Eq.refl, Array.ext.extAux],[Array, Eq, Nat, Array.size, LT.lt, instLTNat, Array.get, Fin.mk]]
[FloatSpec.le,[FloatSpec],[FloatSpec, FloatSpec.float]]
[instShiftLeftUSize,[ShiftLeft.mk, USize, USize.shiftLeft],[ShiftLeft, USize]]
[IO.Process.Child.mk.sizeOf_spec,[IO.Process.StdioConfig, IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdin, IO.Process.StdioConfig.stdout, IO.Process.StdioConfig.stderr, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOf],[IO.Process.StdioConfig, IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdin, IO.Process.StdioConfig.stdout, IO.Process.StdioConfig.stderr, Eq, Nat, SizeOf.sizeOf, IO.Process.Child, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, instSizeOf, IO.Process.Child.mk]]
[ExceptCpsT.runCatch,[Monad, ExceptCpsT, Pure.pure, Applicative.toPure, Monad.toApplicative],[Monad, ExceptCpsT]]
[Lean.MonadQuotation.getMainModule,[Lean.MonadQuotation],[Lean.MonadQuotation, Lean.Name]]
[IO.Error.unsatisfiedConstraints.sizeOf_spec,[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar],[UInt32, String, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, Option, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.unsatisfiedConstraints]]
[DoResultSBC.noConfusionType,[DoResultSBC, Eq],[DoResultSBC]]
[instSubNat,[Sub.mk, Nat, Nat.sub],[Sub, Nat]]
[instToStreamStringSubstring,[ToStream.mk, String, Substring, String.toSubstring],[ToStream, String, Substring]]
[Lean.Parser.Tactic.rotateRight,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Fin.div.proof_1,[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, HDiv.hDiv, instHDiv, Nat.instDivNat],[Nat, LT.lt, instLTNat, HMod.hMod, instHMod, Nat.instModNat, HDiv.hDiv, instHDiv, Nat.instDivNat]]
[Std.Format.prettyM,[Std.Format, Nat, optParam, OfNat.ofNat, instOfNatNat, Monad, Std.Format.MonadPrettyFormat, List.cons, Bool.false, Std.Format.FlattenBehavior.allOrNone, Int.ofNat, List.nil],[Std.Format, Nat, optParam, OfNat.ofNat, instOfNatNat, Monad, Std.Format.MonadPrettyFormat, Unit]]
[ite,[Decidable, Not],[Decidable]]
[Lean.evalPrio,[Lean.Syntax, Lean.Macro.withIncRecDepth, Nat, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.expandMacros, cond, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.getD, Lean.Syntax.isNatLit?, OfNat.ofNat, instOfNatNat, Lean.Macro.throwErrorAt],[Lean.Syntax, Lean.MacroM, Nat]]
[InvImage.accessible.proof_1,[Acc, Eq, InvImage, Acc.intro, rfl],[Acc, InvImage]]
[ByteArray.mk.sizeOf_spec,[Array, UInt8, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, List, Fin, UInt8.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[Array, UInt8, Eq, Nat, SizeOf.sizeOf, ByteArray, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Fin, UInt8.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, ByteArray.mk]]
[Prod.lex.proof_1,[WellFoundedRelation, WellFounded.intro, Prod, Prod.Lex, WellFoundedRelation.rel, Acc, Prod.lexAccessible, WellFounded.apply, WellFoundedRelation.wf],[WellFoundedRelation, WellFounded, Prod, Prod.Lex, WellFoundedRelation.rel]]
[decide_eq_false,[Decidable, Not, Eq, Bool, Decidable.decide, Bool.false, absurd, Decidable.isTrue, rfl, Decidable.isFalse],[Decidable, Not, Eq, Bool, Decidable.decide, Bool.false]]
[IO.Error.resourceBusy.injEq,[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.resourceBusy, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[UInt32, String, Eq, IO.Error, IO.Error.resourceBusy, And]]
[bind_pure_unit,[Monad, LawfulMonad, PUnit],[Monad, LawfulMonad, PUnit, Eq, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit]]
[Substring.all,[Substring, Char, Bool, not, Substring.any],[Substring, Char, Bool]]
[Nat.not_le_of_not_ble_eq_true,[Nat, Not, Eq, Bool, Nat.ble, Bool.true, LE.le, instLENat, absurd, False, Nat.ble_eq_true_of_le],[Nat, Not, Eq, Bool, Nat.ble, Bool.true, LE.le, instLENat]]
[Nat.div,[WellFounded.fix, Nat, WellFoundedRelation.rel, measure, id, Nat.div.proof_1, LT.lt, instLTNat, dite, And, OfNat.ofNat, instOfNatNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HAdd.hAdd, instHAdd, instAddNat, HSub.hSub, instHSub, instSubNat, And.intro, Nat.sub_lt, Nat.lt_of_lt_of_le, Not, Nat.zero],[Nat]]
[Array.findSomeRevM?.find.proof_2,[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.succ, Nat.lt_succ_self],[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size]]
[Subtype.mk.injEq,[Eq.propIntro, Eq, Subtype, Subtype.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Subtype, Subtype.mk]]
[IO.RealWorld,[Unit],[]]
[String.Iterator.i,[String.Iterator],[String.Iterator, String.Pos]]
[String.toInt!,[String, Option, Int, String.toInt?, Unit, panic, Int.instInhabitedInt],[String, Int]]
[List.head?,[List, Option, Unit, Option.none, Option.some],[List, Option]]
[IO.Error.unsatisfiedConstraints.inj,[UInt32, String, Eq, IO.Error, IO.Error.unsatisfiedConstraints, And, And.intro],[UInt32, String, Eq, IO.Error, IO.Error.unsatisfiedConstraints, And]]
[Nat.gcd_one_left,[Nat, Eq.mpr, Eq, Nat.gcd, OfNat.ofNat, instOfNatNat, HMod.hMod, instHMod, Nat.instModNat, Nat.succ, Eq.refl, Nat.gcd_succ, Nat.mod_one, rfl],[Nat, Eq, Nat.gcd, OfNat.ofNat, instOfNatNat]]
[ShiftRight.shiftRight,[ShiftRight],[ShiftRight]]
[Lean.addMacroScope,[Lean.Name, Lean.MacroScope, Bool, Lean.Name.hasMacroScopes, Unit, Lean.MacroScopesView, Lean.extractMacroScopes, BEq.beq, Lean.Name.instBEqName, Lean.MacroScopesView.mainModule, Lean.Name.mkNum, Lean.MacroScopesView.review, Lean.MacroScopesView.mk, Lean.MacroScopesView.name, List.foldl, Nat, HAppend.hAppend, instHAppend, Lean.Name.instAppendName, Lean.MacroScopesView.imported, Lean.MacroScopesView.scopes, List.cons, List.nil, Lean.Name.mkStr],[Lean.Name, Lean.MacroScope]]
[Function.Equiv.isEquivalence,[Equivalence.mk, Function.Equiv, Function.Equiv.refl, Function.Equiv.symm, Function.Equiv.trans],[Equivalence, Function.Equiv]]
[System.FilePath.mk.sizeOf_spec,[String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[String, Eq, Nat, SizeOf.sizeOf, System.FilePath, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, System.FilePath.mk]]
[Array.qpartition,[Inhabited, Array, Bool, Nat, HDiv.hDiv, instHDiv, Nat.instDivNat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, ite, Eq, Array.get!, Bool.true, instDecidableEqBool, Array.swap!, Prod, Array.qpartition.loop],[Inhabited, Array, Bool, Nat, Prod]]
[List.lt.brecOn,[LT, List, List.lt, List.lt.below, List.lt.below.nil, LT.lt, List.lt.below.head, Not, List.lt.below.tail],[LT, List, List.lt, List.lt.below]]
[UInt64.decEq,[UInt64, Decidable, Eq, Fin, UInt64.size, dite, UInt64.mk, instDecidableEqFin, Decidable.isTrue, UInt64.decEq.proof_1, Not, Decidable.isFalse, UInt64.decEq.proof_2],[UInt64, Decidable, Eq]]
[Char.isAlphanum,[Char, or, Char.isAlpha, Char.isDigit],[Char, Bool]]
[List.forIn,[Monad, List, ForInStep, List.forIn.loop],[Monad, List, ForInStep]]
[List.findSome?,[Option, List, List.below, Unit, List.nil, Option.none, List.cons, Option.some, PProd.fst, PUnit, PProd],[Option, List]]
[Lean.MonadQuotation.getCurrMacroScope,[Lean.MonadQuotation],[Lean.MonadQuotation, Lean.MacroScope]]
[Int.decLe,[Decidable, Int.NonNeg, Nat, Decidable.isTrue, Int.ofNat, Int.NonNeg.mk, Decidable.isFalse, Int.negSucc, Int, Eq, HEq, Eq.refl, HEq.refl, False, HSub.hSub, instHSub, Int.instSubInt],[Decidable, LE.le, Int, Int.instLEInt]]
[USize.toNat,[USize, Fin.val, USize.size, USize.val],[USize, Nat]]
[IO.FS.readFile,[System.FilePath, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle, String, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.false, IO.FS.Handle.readToEnd],[System.FilePath, IO, String]]
[Function.Equiv,[Eq],[]]
[String.singleton,[Char, String.push],[Char, String]]
[IO.Process.Output.stdout,[IO.Process.Output],[IO.Process.Output, String]]
[dif_eq_if,[Decidable, Eq, dite, Not, ite, rfl, Decidable.isTrue, Decidable.isFalse],[Decidable, Eq, dite, Not, ite]]
[LawfulMonad.bind_pure_comp,[Monad, LawfulMonad],[Monad, LawfulMonad, Eq, Bind.bind, Monad.toBind, Function.comp, Pure.pure, Applicative.toPure, Monad.toApplicative, Functor.map, Applicative.toFunctor]]
[Std.Format.instBEqFlattenBehavior,[BEq.mk, Std.Format.FlattenBehavior, BEq.beq, Nat, instBEq, instDecidableEqNat, Std.Format.FlattenBehavior.toCtorIdx],[BEq, Std.Format.FlattenBehavior]]
[Array.mapIdxM,[Monad, Array, Fin, Array.size, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, rfl, Array.mkEmpty, Array.mapIdxM.map],[Monad, Array, Fin, Array.size]]
[List.rotateLeft,[List, optParam, Nat, OfNat.ofNat, instOfNatNat, List.length, ite, LE.le, instLENat, Nat.decLe, HMod.hMod, instHMod, Nat.instModNat, List.take, List.drop, HAppend.hAppend, instHAppend, List.instAppendList],[List, optParam, Nat, OfNat.ofNat, instOfNatNat]]
[Lean.instEvalUnit,[Lean.Eval.mk, Unit, optParam, Bool, Bool.true, ite, IO, Eq, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, instMonadEIO, IO.Error, Unit.unit, IO.println, Std.Format, instToStringFormat, repr, instReprUnit],[Lean.Eval, Unit]]
[IO.Error.interrupted.sizeOf_spec,[String, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[String, UInt32, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, Option, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.interrupted]]
[Std.Format.line.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, Std.Format, SizeOf.mk, OfNat.ofNat, instOfNatNat, String, HAdd.hAdd, instHAdd, instAddNat, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, Int, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone, Std.Format.line]]
[Bind.noConfusionType,[Bind, Eq],[Bind]]
[StateT.run'_eq,[Monad, StateT, rfl, StateT.run', Applicative.toFunctor, Monad.toApplicative],[Monad, StateT, Eq, StateT.run', Applicative.toFunctor, Monad.toApplicative, Functor.map, Prod, Prod.fst, StateT.run]]
[String.toList,[String, String.data],[String, List, Char]]
[WellFoundedRelation.rel,[WellFoundedRelation],[WellFoundedRelation]]
[of_decide_eq_true,[Decidable, Eq, Bool, Decidable.decide, Bool.true, Not, absurd, ne_true_of_eq_false, decide_eq_false],[Decidable, Eq, Bool, Decidable.decide, Bool.true]]
[Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat, Nat.lt_of_le_of_lt],[Nat, LE.le, instLENat, LT.lt, instLTNat]]
[RandomGen.split,[RandomGen],[RandomGen, Prod]]
[termDepIfThenElse,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.explicitBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.bracketedExplicitBinders, Lean.unbracketedExplicitBinders],[Lean.ParserDescr]]
[IO.mkRef,[ST.mkRef, IO.RealWorld, IO, instMonadLiftT, ST, IO.instMonadLiftSTRealWorldEIO, IO.Error, instMonadLiftT_1],[IO, IO.Ref]]
[instAddUInt64,[Add.mk, UInt64, UInt64.add],[Add, UInt64]]
[Lean.reservedMacroScope,[OfNat.ofNat, Nat, instOfNatNat],[Nat]]
[ByteArray.instInhabitedByteArray,[Inhabited.mk, ByteArray, ByteArray.empty],[Inhabited, ByteArray]]
[ByteArray.toUInt64LE!,[ByteArray, ite, UInt64, Eq, Bool, BEq.beq, Nat, instBEq, instDecidableEqNat, ByteArray.size, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, HOr.hOr, instHOr, instOrOpUInt64, HShiftLeft.hShiftLeft, instHShiftLeft, instShiftLeftUInt64, UInt8.toUInt64, ByteArray.get!, instOfNatUInt64, panicWithPosWithDecl, instInhabitedUInt64, HAppend.hAppend, String, instHAppend, String.instAppendString],[ByteArray, UInt64]]
[instLTOption,[LT, LT.mk, Option, Option.lt, LT.lt],[LT, Option]]
[eq_false_of_decide,[Decidable, Eq, Bool, Decidable.decide, Bool.false, propext, False, Iff.intro, absurd, of_decide_eq_false, False.elim],[Decidable, Eq, Bool, Decidable.decide, Bool.false, False]]
[Fin.instHModFinNatFin,[Nat, HMod.mk, Fin, Fin.modn],[Nat, HMod, Fin]]
[Std.Format.paren,[Std.Format, Std.Format.bracket],[Std.Format]]
[instDecidableOr,[Decidable, Or, Decidable.isTrue, Or.inl, Not, Or.inr, Decidable.isFalse, instDecidableOr.proof_1],[Decidable, Or]]
[Lean.Parser.Tactic.subst,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[IO.sleep,[UInt32, IO.RealWorld, dbgSleep, EStateM.Result, IO.Error, Unit, EStateM.Result.ok, Unit.unit],[UInt32, IO, Unit]]
[absurd,[Not, False.elim],[Not]]
[Nat.pow,[Nat, Nat.below, Unit, OfNat.ofNat, instOfNatNat, Nat.succ, Nat.mul, PProd.fst, PUnit, PProd],[Nat]]
[IO.Process.StdioConfig.mk.inj,[IO.Process.Stdio, Eq, IO.Process.StdioConfig, IO.Process.StdioConfig.mk, And, And.intro],[IO.Process.Stdio, Eq, IO.Process.StdioConfig, IO.Process.StdioConfig.mk, And]]
[List.foldr,[List, List.below, Unit, List.nil, List.cons, PProd.fst, PUnit, PProd],[List]]
[«stx_,*,?»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[String.takeRight,[String, Nat, Substring.toString, Substring.takeRight, String.toSubstring],[String, Nat]]
[List.bind,[List, List.join, List.map],[List]]
[ST.Ref.get,[MonadLiftT, ST, ST.Ref, liftM, ST.Prim.Ref.get],[MonadLiftT, ST, ST.Ref]]
[UInt32.mul,[UInt32, UInt32.mk, HMul.hMul, Fin, UInt32.size, instHMul, Fin.instMulFin, UInt32.val],[UInt32]]
[instDecidableLe_3,[UInt64, UInt64.decLe],[UInt64, Decidable, LE.le, instLEUInt64]]
[ByteArray.push,[ByteArray, UInt8, Array, ByteArray.mk, Array.push],[ByteArray, UInt8]]
[LawfulMonad.pure_bind,[Monad, LawfulMonad],[Monad, LawfulMonad, Eq, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[CoeHTCT.noConfusionType,[CoeHTCT, Eq],[CoeHTCT]]
[Lean.Macro.getMethodsImp,[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, MonadReader.read, instMonadReader, instMonadReaderOfReaderT, Pure.pure, Applicative.toPure, Monad.toApplicative, unsafeCast, PointedType.type, Lean.Macro.Context.methods],[Lean.MacroM, Lean.Macro.Methods]]
[compareOfLessAndEq,[LT, Decidable, LT.lt, DecidableEq, ite, Ordering, Ordering.lt, Eq, Ordering.eq, Ordering.gt],[LT, Decidable, LT.lt, DecidableEq, Ordering]]
[ExceptCpsT.run,[Monad, ExceptCpsT, Except, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.ok, Except.error],[Monad, ExceptCpsT, Except]]
[List.toByteArray.loop,[List, UInt8, ByteArray, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd, ByteArray.push],[List, UInt8, ByteArray]]
[UInt16.decLe,[UInt16, Decidable, LE.le, instLEUInt16, Fin, UInt16.size, inferInstanceAs, instLEFin, Fin.decLe],[UInt16, Decidable, LE.le, instLEUInt16]]
[ReaderT.map,[Monad, ReaderT, Functor.map, Applicative.toFunctor, Monad.toApplicative],[Monad, ReaderT]]
[instSubsingletonForall.proof_1,[Subsingleton, Subsingleton.intro, funext, Subsingleton.elim],[Subsingleton]]
[FloatArray.mk.sizeOf_spec,[Array, Float, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, List, FloatSpec.float, floatSpec, instSizeOf],[Array, Float, Eq, Nat, SizeOf.sizeOf, FloatArray, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, FloatSpec.float, floatSpec, instSizeOf, FloatArray.mk]]
[Lean.Name.beq,[Lean.Name, Bool, Lean.Name.below, Unit, Lean.Name.anonymous, Bool.true, String, UInt64, Lean.Name.str, and, BEq.beq, instBEq, instDecidableEqString, PProd.fst, PUnit, PProd, Nat, Lean.Name.num, instDecidableEqNat, Bool.false],[Bool]]
[Prod.lexAccessible,[Prod.lexAccessible.proof_1],[Acc, Prod, Prod.Lex, Prod.mk]]
[instHashableList,[Hashable, Hashable.mk, List, List.foldl, UInt64, mixHash, Hashable.hash, OfNat.ofNat, instOfNatUInt64],[Hashable, List]]
[Array.foldlM.loop.proof_1,[Array, Nat, LE.le, instLENat, Array.size, LT.lt, instLTNat, Nat.lt_of_lt_of_le],[Array, Nat, LE.le, instLENat, Array.size, LT.lt, instLTNat]]
[instReprSubstring,[Repr.mk, Substring, Nat, Std.Format.text, HAppend.hAppend, String, instHAppend, String.instAppendString, String.quote, Substring.toString],[Repr, Substring]]
[Lean.Meta.Simp.ConfigCtx.mk.injEq,[Lean.Meta.Simp.Config, Eq.propIntro, Eq, Lean.Meta.Simp.ConfigCtx, Lean.Meta.Simp.ConfigCtx.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Lean.Meta.Simp.Config, Eq, Lean.Meta.Simp.ConfigCtx, Lean.Meta.Simp.ConfigCtx.mk]]
[IO.Process.Child.noConfusionType,[IO.Process.StdioConfig, IO.Process.Child, IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdin, IO.Process.StdioConfig.stdout, IO.Process.StdioConfig.stderr, Eq],[IO.Process.StdioConfig, IO.Process.Child]]
[Lean.instHashableName,[Hashable.mk, Lean.Name, Lean.Name.hash],[Hashable, Lean.Name]]
[DoResultPRBC.continue.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, DoResultPRBC, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, DoResultPRBC.continue]]
[String.Iterator.nextn,[String.Iterator, Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, String.Iterator.next],[String.Iterator, Nat]]
[Lean.Module.header,[Lean.Module],[Lean.Module, Lean.Syntax]]
[Subtype.instDecidableEqSubtype.proof_2,[Not, Eq, Subtype, Subtype.mk, False, absurd],[Not, Eq, Subtype, Subtype.mk, False]]
[PSigma.lexNdepWf,[PSigma.lexNdepWf.proof_1],[WellFounded, PSigma, PSigma.lexNdep]]
[String.mk.sizeOf_spec,[List, Char, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[List, Char, Eq, Nat, SizeOf.sizeOf, String, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, String.mk]]
[Substring.stopPos,[Substring],[Substring, String.Pos]]
[String.length,[String, Nat, List, Char, List.length],[Nat]]
[Lean.Meta.Simp.defaultMaxSteps,[OfNat.ofNat, Nat, instOfNatNat],[Nat]]
[MonadExcept.instOrElse,[MonadExcept, OrElse.mk, MonadExcept.orElse],[MonadExcept, OrElse]]
[Lean.Meta.Simp.Config.proj,[Lean.Meta.Simp.Config],[Lean.Meta.Simp.Config, Bool]]
[Lean.Parser.Tactic.location,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.Parser.Tactic.locationWildcard, Lean.Parser.Tactic.locationHyp],[Lean.ParserDescr]]
[OrElse.noConfusionType,[OrElse, Unit, Eq],[OrElse]]
[String.Iterator.remainingToString,[String.Iterator, String, String.Pos, String.extract, String.bsize],[String.Iterator, String]]
[Char.utf8Size.proof_1,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size]]
[Array.extract,[Array, Nat, Array.ofSubarray, Array.toSubarray],[Array, Nat]]
[Lean.Macro.throwUnsupported,[MonadExcept.throw, Lean.Macro.Exception, Lean.MacroM, instMonadExcept, ReaderT.instMonadExceptOfReaderT, Lean.Macro.Context, EStateM, Lean.Macro.State, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Lean.Macro.Exception.unsupportedSyntax],[Lean.MacroM]]
[List.forM_cons,[Monad, PUnit, List, rfl, ForM.forM, List.instForMList, List.cons],[Monad, PUnit, List, Eq, ForM.forM, List.instForMList, List.cons, Bind.bind, Monad.toBind]]
[Lean.instInhabitedSyntax,[Inhabited.mk, Lean.Syntax, Lean.Syntax.missing],[Inhabited, Lean.Syntax]]
[List.instAppendList,[Append.mk, List, List.append],[Append, List]]
[funext,[Eq],[Eq]]
[Lean.Meta.Simp.ConfigCtx.mk.sizeOf_spec,[Lean.Meta.Simp.Config, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Bool, instSizeOfNat],[Lean.Meta.Simp.Config, Eq, Nat, SizeOf.sizeOf, Lean.Meta.Simp.ConfigCtx, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Bool, instSizeOfNat, Lean.Meta.Simp.ConfigCtx.mk]]
[tacticCalc_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, calcStep],[Lean.ParserDescr]]
[Array.mapSepElems,[Array, Lean.Syntax, Id.run, Array.mapSepElemsM, Id, Id.instMonadId],[Array, Lean.Syntax]]
[Nat.succ_le_succ,[Nat, LE.le, instLENat, Nat.succ, Nat.below, Unit, Nat.le.refl, Nat.le, Nat.le.step, PProd.fst, PUnit, PProd],[Nat, LE.le, instLENat, Nat.succ]]
[cast_eq,[Eq, rfl, cast],[Eq, cast]]
[Nat.not_le_of_gt,[Nat, GT.gt, instLTNat, LE.le, instLENat, Or, LT.lt, GE.ge, Nat.lt_or_ge, False, absurd, Nat.lt_trans, Nat.lt_irrefl],[Nat, GT.gt, instLTNat, Not, LE.le, instLENat]]
[instInhabitedOrdering,[Inhabited.mk, Ordering, Ordering.lt],[Inhabited, Ordering]]
[dbgTraceIfShared,[String],[String]]
[Option.instOrElseOption,[OrElse.mk, Option, Option.orElse],[OrElse, Option]]
[StateCpsT.runK_get,[rfl, StateCpsT.runK, MonadState.get, StateCpsT, instMonadState, StateCpsT.instMonadStateOfStateCpsT],[Eq, StateCpsT.runK, MonadState.get, StateCpsT, instMonadState, StateCpsT.instMonadStateOfStateCpsT]]
[Nat.le_refl,[Nat, Nat.le.refl],[Nat, LE.le, instLENat]]
[instDecidableLt_4,[USize, USize.decLt],[USize, Decidable, LT.lt, instLTUSize]]
[Nat.zero_add,[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Nat.below, Unit, rfl, Nat.succ, congrArg, Nat.add, PProd.fst, PUnit, PProd],[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
[ExceptT.run_bind,[ExceptT, Monad, rfl, Except, ExceptT.run, Bind.bind, Monad.toBind, ExceptT.instMonadExceptT],[ExceptT, Monad, Eq, Except, ExceptT.run, Bind.bind, Monad.toBind, ExceptT.instMonadExceptT, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.error]]
[Lean.Macro.Methods.expandMacro?,[Lean.Macro.Methods],[Lean.Macro.Methods, Lean.Syntax, Lean.MacroM, Option]]
[coeOfHTCT,[CoeHTCT, CoeT.mk, CoeHTCT.coe],[CoeHTCT, CoeT]]
[Subsingleton.allEq,[Subsingleton],[Subsingleton, Eq]]
[Lean.Syntax.isOfKind,[Lean.Syntax, Lean.SyntaxNodeKind, BEq.beq, Lean.Name.instBEqName, Lean.Syntax.getKind],[Lean.Syntax, Lean.SyntaxNodeKind, Bool]]
[Lean.MacroScopesView.scopes,[Lean.MacroScopesView],[Lean.MacroScopesView, List, Lean.MacroScope]]
[instInhabitedProd,[Inhabited, Inhabited.mk, Prod, Prod.mk, arbitrary],[Inhabited, Prod]]
[Nat.beq,[Nat, Bool, Nat.below, Unit, Nat.zero, Bool.true, Bool.false, Nat.succ, PProd.fst, PUnit, PProd],[Bool]]
[IO.Error.mkInterrupted,[IO.Error.interrupted],[String, UInt32, IO.Error]]
[PProd.mk.inj,[Eq, PProd, PProd.mk, And, And.intro],[Eq, PProd, PProd.mk, And]]
[Nat.eq_of_beq_eq_true,[Nat, Eq, Bool, Nat.beq, Bool.true, Nat.below, Nat.zero, rfl, Nat.succ],[Nat, Eq, Bool, Nat.beq, Bool.true]]
[Nat.ctor_eq_zero,[rfl, Nat, Nat.zero],[Eq, Nat, Nat.zero, OfNat.ofNat, instOfNatNat]]
[Std.Format.indentD,[Std.Format, Std.Format.nestD, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.line],[Std.Format]]
[«term_<$>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Nat.pred,[Nat, Unit, OfNat.ofNat, instOfNatNat],[Nat]]
[CoeDep.coe,[CoeDep],[CoeDep]]
[Lean.ParserDescr.below,[Lean.ParserDescr, Lean.Name, PUnit, PProd, Lean.SyntaxNodeKind, Nat, String, Bool, optParam, Bool.false],[Lean.ParserDescr]]
[STWorld.noConfusionType,[outParam, STWorld],[outParam, STWorld]]
[Lean.version.isRelease,[Lean.version.getIsRelease, Unit.unit],[Bool]]
[PSum.inr.inj,[Eq, PSum, PSum.inr],[Eq, PSum, PSum.inr]]
[PUnit.subsingleton,[PUnit, Eq, PUnit.unit, rfl, Eq.symm, Eq.refl],[PUnit, Eq]]
[Quotient.hrecOn,[Setoid, Quotient, Quotient.mk, HasEquiv.Equiv, instHasEquiv, HEq, Quot.hrecOn, Setoid.r],[Setoid, Quotient, Quotient.mk, HasEquiv.Equiv, instHasEquiv, HEq]]
[instToStringFloat,[ToString.mk, Float, Float.toString],[ToString, Float]]
[FloatSpec.decLt,[FloatSpec],[FloatSpec, DecidableRel, FloatSpec.float, FloatSpec.lt]]
[Nat.le_trans,[Nat, LE.le, instLENat, Nat.below, Nat.le, Nat.le.step, PProd.fst, PUnit, PProd],[Nat, LE.le, instLENat]]
[instBEqProd,[BEq, BEq.mk, Prod, Bool, and, BEq.beq],[BEq, Prod]]
[Subarray.mk.injEq,[Array, Nat, LE.le, instLENat, Array.size, Eq.propIntro, Eq, Subarray, Subarray.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Array, Nat, LE.le, instLENat, Array.size, Eq, Subarray, Subarray.mk, And]]
[IO.FS.Metadata.type,[IO.FS.Metadata],[IO.FS.Metadata, IO.FS.FileType]]
[IO.Error.noFileOrDirectory.injEq,[String, UInt32, Eq.propIntro, Eq, IO.Error, IO.Error.noFileOrDirectory, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[String, UInt32, Eq, IO.Error, IO.Error.noFileOrDirectory, And]]
[FloatArray.push,[FloatArray, Float, Array, FloatArray.mk, Array.push],[FloatArray, Float]]
[ExceptCpsT.runCatch_pure,[Monad, rfl, ExceptCpsT.runCatch, Pure.pure, ExceptCpsT, Applicative.toPure, Monad.toApplicative, ExceptCpsT.instMonadExceptCpsT],[Monad, Eq, ExceptCpsT.runCatch, Pure.pure, ExceptCpsT, Applicative.toPure, Monad.toApplicative, ExceptCpsT.instMonadExceptCpsT]]
[Sub.noConfusionType,[Sub, Eq],[Sub]]
[instToFormatOption,[Std.ToFormat, Std.ToFormat.mk, Option, Option.format],[Std.ToFormat, Option]]
[instHashableFin,[Nat, Hashable.mk, Fin, Nat.toUInt64, Fin.val],[Nat, Hashable, Fin]]
[UInt32.isValidChar,[UInt32, Nat.isValidChar, UInt32.toNat],[UInt32]]
[precMin1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Array.instInhabitedArray,[Inhabited.mk, Array, Array.empty],[Inhabited, Array]]
[instHOr,[OrOp, HOr.mk, OrOp.or],[OrOp, HOr]]
[IO.FS.Metadata.mk.inj,[IO.FS.SystemTime, UInt64, IO.FS.FileType, Eq, IO.FS.Metadata, IO.FS.Metadata.mk, And, And.intro],[IO.FS.SystemTime, UInt64, IO.FS.FileType, Eq, IO.FS.Metadata, IO.FS.Metadata.mk, And]]
[Nat.lt.step,[Nat.lt.step.proof_1],[Nat, LT.lt, instLTNat, Nat.succ]]
[OptionT.run,[OptionT],[OptionT, Option]]
[Prod.RProdSubLex,[Prod.RProdSubLex.proof_1],[Prod, Prod.RProd, Prod.Lex]]
[instDecidableEqProd.proof_3,[Not, Eq, Prod, Prod.mk, False, absurd],[Not, Eq, Prod, Prod.mk, False]]
[dbgTrace,[String, Unit, Unit.unit],[String, Unit]]
[StdGen.mk.sizeOf_spec,[Nat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat],[Nat, Eq, SizeOf.sizeOf, StdGen, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, instSizeOfNat, StdGen.mk]]
[List.getLast?,[List, Option, Unit, Option.none, Option.some, List.getLast, List.cons, List.getLast?.proof_1],[List, Option]]
[ST.Ref.h,[ST.Ref],[ST.Ref, Nonempty]]
[Append.append,[Append],[Append]]
[IO.FS.DirEntry.path,[IO.FS.DirEntry, HDiv.hDiv, System.FilePath, instHDiv, System.FilePath.instDivFilePath, IO.FS.DirEntry.root, System.FilePath.mk, IO.FS.DirEntry.fileName],[IO.FS.DirEntry, System.FilePath]]
[Nat.lt_of_lt_of_le,[Nat, Nat.le_trans, Nat.succ],[Nat, LT.lt, instLTNat, LE.le, instLENat]]
[FloatArray.set,[FloatArray, Float, Array, Fin, FloatArray.size, FloatArray.mk, Array.set],[FloatArray, Float]]
[List.cons.inj,[List, Eq, List.cons, And, And.intro],[List, Eq, List.cons, And]]
[Array.getSepElems,[Array.getEvenElems],[Array]]
[unsafeIO,[IO, unsafeEIO, IO.Error],[IO, Except, IO.Error]]
[Nat.anyM.loop,[Monad, Nat, Bool, Nat.below, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.false, Nat.succ, Bind.bind, Monad.toBind, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, Bool.true, PProd.fst, PUnit, PProd],[Monad, Nat, Bool]]
[Lean.Meta.Simp.Config.contextual,[Lean.Meta.Simp.Config],[Lean.Meta.Simp.Config, Bool]]
[Lean.Parser.Tactic.rwWithRfl,[Lean.SyntaxNodeKind, String, Lean.Syntax, Lean.Syntax.getOp, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.setArg, Lean.mkAtom, Lean.Syntax.setKind, Lean.mkAtomFrom, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.Macro.instMonadRefMacroM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Macro.instMonadQuotationMacroM, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Option.getD, Lean.Syntax.getHeadInfo?, List.nil],[Lean.SyntaxNodeKind, String, Lean.Syntax, Lean.MacroM]]
[Fin.add.proof_1,[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt],[Nat, LT.lt, instLTNat, HMod.hMod, instHMod, Nat.instModNat, HAdd.hAdd, instHAdd, instAddNat]]
[instHShiftLeft,[ShiftLeft, HShiftLeft.mk, ShiftLeft.shiftLeft],[ShiftLeft, HShiftLeft]]
[IO.instMonadLiftSTRealWorldEIO,[MonadLift.mk, ST, IO.RealWorld, EIO, EStateM.Result, Empty, EStateM.Result.ok],[MonadLift, ST, IO.RealWorld, EIO]]
[UInt32.lor,[UInt32, UInt32.mk, Fin.lor, UInt32.size, UInt32.val],[UInt32]]
[Array.forIn,[Monad, Array, ForInStep, Nat, LE.le, instLENat, Array.size, Nat.le_refl, Array.forIn.loop],[Monad, Array, ForInStep]]
[Array.«term__[:_]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[IO.FS.Stream.mk.sizeOf_spec,[IO, Bool, Unit, USize, ByteArray, String, Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[IO, Bool, Unit, USize, ByteArray, String, Eq, Nat, SizeOf.sizeOf, IO.FS.Stream, SizeOf.mk, OfNat.ofNat, instOfNatNat, IO.FS.Stream.mk]]
[and,[Bool, Unit, Bool.false],[Bool]]
[Lean.Macro.throwErrorAt,[Lean.Syntax, String, Lean.withRef, Lean.MacroM, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.instMonadRefMacroM, Lean.Macro.throwError],[Lean.Syntax, String, Lean.MacroM]]
[PLift.down,[PLift],[PLift]]
[toBoolUsing_eq_true,[Decidable, decide_eq_true],[Decidable, Eq, Bool, toBoolUsing, Bool.true]]
[List.format,[Std.ToFormat, List, Std.Format, Unit, Std.Format.text, Std.Format.sbracket, Std.Format.joinSep, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.line],[Std.ToFormat, List, Std.Format]]
[MonadControlT.liftWith,[MonadControlT],[MonadControlT, MonadControlT.stM]]
[ForM.noConfusionType,[outParam, ForM, Monad, PUnit, Eq],[outParam, ForM]]
[fixCore5,[bfix5, USize.size],[]]
[IO,[EIO, IO.Error],[]]
[Nat.foldRev,[Nat, Nat.foldRev.loop],[Nat]]
[Subarray.h₁,[Subarray],[Subarray, LE.le, Nat, instLENat, Subarray.start, Subarray.stop]]
[instSTWorldEST,[outParam, STWorld.mk, EST],[outParam, STWorld, EST]]
[instMonadWithReader,[MonadWithReaderOf, MonadWithReader.mk, withTheReader],[MonadWithReaderOf, MonadWithReader]]
[IO.FS.SystemTime.noConfusionType,[IO.FS.SystemTime, Int, UInt32, Eq],[IO.FS.SystemTime]]
[String.modify,[String, String.Pos, Char, String.set, String.get],[String, String.Pos, Char]]
[unexpandEqNDRec,[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[IO.AccessRight.mk.inj,[Bool, Eq, IO.AccessRight, IO.AccessRight.mk, And, And.intro],[Bool, Eq, IO.AccessRight, IO.AccessRight.mk, And]]
[coeTail,[CoeTail, CoeTail.coe],[CoeTail]]
[Quot.indepCoherent,[Quot, Quot.mk, Eq, Quot.sound, PSigma.eta],[Quot, Quot.mk, Eq, Quot.sound, PSigma, Quot.indep]]
[InvImage,[],[]]
[Fin.modn,[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, Fin.modn.proof_1],[Nat, Fin]]
[Lean.isNumericSubscript,[Char, and, Decidable.decide, LE.le, UInt32, instLEUInt32, OfNat.ofNat, instOfNatUInt32, Char.val, instDecidableLe],[Char, Bool]]
[Classical.exists_true_of_nonempty,[Nonempty, Exists, True, Exists.intro, trivial],[Nonempty, Exists, True]]
[instReprIterator,[Repr.mk, String.Iterator, Nat, Std.Format, String, String.Pos, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, reprArg, instReprString, instReprNat],[Repr, String.Iterator]]
[System.FilePath.isAbsolute,[System.FilePath, or, List.contains, Char, instBEq, instDecidableEqChar, System.FilePath.pathSeparators, String.front, System.FilePath.toString, and, System.Platform.isWindows, Decidable.decide, GE.ge, Nat, instLENat, String.bsize, OfNat.ofNat, instOfNatNat, Nat.decLe, BEq.beq, String.getOp, String.Pos, Char.ofNat],[System.FilePath, Bool]]
[Array.split,[Array, Bool, Array.foldl, Prod, ite, Eq, Bool.true, instDecidableEqBool, Prod.mk, Array.push, List.toArray, List.nil, OfNat.ofNat, Nat, instOfNatNat, Array.size],[Array, Bool, Prod]]
[StateT.run_seqRight,[Monad, LawfulMonad, StateT],[Monad, LawfulMonad, StateT, Eq, Prod, StateT.run, SeqRight.seqRight, Applicative.toSeqRight, Monad.toApplicative, StateT.instMonadStateT, Unit, Bind.bind, Monad.toBind, Prod.snd]]
[Id.instOfNatId,[Nat, OfNat, inferInstanceAs],[Nat, OfNat, Id]]
[Prod.fst,[Prod],[Prod]]
[HAnd.noConfusionType,[outParam, HAnd, Eq],[outParam, HAnd]]
[Classical.inhabited_of_exists,[Exists, Classical.inhabited_of_nonempty, Classical.inhabited_of_exists.proof_1],[Exists, Inhabited]]
[EStateM.Backtrackable.save,[EStateM.Backtrackable],[EStateM.Backtrackable]]
[List.pure,[List.cons, List.nil],[List]]
[String.toFormat,[String, Std.Format.joinSep, Std.instToFormatString, String.splitOn, Std.Format.line],[String, Std.Format]]
[instDecidableArrow.proof_2,[Not, absurd, False],[Not, False]]
[AndThen.andThen,[AndThen],[AndThen, Unit]]
[Lean.Quote.noConfusionType,[Lean.Quote, Lean.Syntax, Eq],[Lean.Quote]]
[IO.Error.inappropriateType.injEq,[Option, String, UInt32, Eq.propIntro, Eq, IO.Error, IO.Error.inappropriateType, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Option, String, UInt32, Eq, IO.Error, IO.Error.inappropriateType, And]]
[IO.FS.Metadata.mk.sizeOf_spec,[IO.FS.SystemTime, UInt64, IO.FS.FileType, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Int, UInt32, instSizeOfNat, Fin, UInt32.size, LT.lt, instLTNat, instSizeOf, UInt64.size],[IO.FS.SystemTime, UInt64, IO.FS.FileType, Eq, Nat, SizeOf.sizeOf, IO.FS.Metadata, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Int, UInt32, instSizeOfNat, Fin, UInt32.size, LT.lt, instLTNat, instSizeOf, UInt64.size, IO.FS.Metadata.mk]]
[instDecidableEqQuotient.proof_1,[Setoid, instSubsingletonDecidable, Eq, Quotient, Quotient.mk],[Setoid, Subsingleton, Decidable, Eq, Quotient, Quotient.mk]]
[Option.some.injEq,[Eq.propIntro, Eq, Option, Option.some, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Option, Option.some]]
[or_true,[propext, Or, True, Iff.intro, trivial, Or.inr],[Eq, Or, True]]
[ExceptT.tryCatch,[Monad, ExceptT, ExceptT.mk, Bind.bind, Monad.toBind, Except, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.ok],[Monad, ExceptT]]
[instDecidableFalse,[Decidable.isFalse, False, not_false],[Decidable, False]]
[LawfulFunctor.map_const,[Functor, LawfulFunctor],[Functor, LawfulFunctor, Eq, Functor.mapConst, Function.comp, Functor.map, Function.const]]
[Classical.epsilon_spec,[Exists, Classical.epsilon_spec_aux, nonempty_of_exists],[Exists, Classical.epsilon, nonempty_of_exists]]
[Lean.Parser.Tactic.Conv.ext,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[LE.noConfusionType,[LE, Eq],[LE]]
[Decidable.byCases,[Decidable, Not],[Decidable, Not]]
[Substring.takeWhile,[Substring, Char, Bool, String, String.Pos, Substring.mk],[Substring, Char, Bool]]
[Nat.repeat.loop,[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd],[Nat]]
[coeOfDep,[CoeDep, CoeT.mk, coeD],[CoeDep, CoeT]]
[IO.FS.DirEntry.fileName,[IO.FS.DirEntry],[IO.FS.DirEntry, String]]
[OptionT.orElse,[Monad, OptionT, Unit, OptionT.mk, Bind.bind, Monad.toBind, Option, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.some, Unit.unit],[Monad, OptionT, Unit]]
[instTransEq.proof_1,[Eq, Eq.symm],[Eq]]
[List.hasDecidableLt.proof_3,[LT, List, Not, LT.lt, List.instLTList, List.cons, False, absurd, List.lt],[LT, List, Not, LT.lt, List.instLTList, List.cons, False]]
[UInt64.lt,[UInt64, LT.lt, Fin, UInt64.size, instLTFin, UInt64.val],[UInt64]]
[IO.FileRight.flags,[IO.FileRight, UInt32, UInt32.shiftLeft, IO.AccessRight.flags, IO.FileRight.user, OfNat.ofNat, instOfNatUInt32, IO.FileRight.group, IO.FileRight.other, UInt32.lor],[IO.FileRight, UInt32]]
[Lean.idEndEscape,[Char.ofNat],[Char]]
[Array.toArrayLit.proof_1,[Array, Nat, Eq, Array.size, LE.le, instLENat, Nat.le_refl],[Array, Nat, Eq, Array.size, LE.le, instLENat]]
[instMonadExcept,[outParam, MonadExceptOf, MonadExcept.mk, throwThe, tryCatchThe],[outParam, MonadExceptOf, MonadExcept]]
[ReaderT.instMonadFunctorReaderT,[Monad, MonadFunctor.mk, ReaderT],[Monad, MonadFunctor, ReaderT]]
[System.FilePath.mk.inj,[String, Eq, System.FilePath, System.FilePath.mk],[String, Eq, System.FilePath, System.FilePath.mk]]
[IO.setAccessRights,[System.FilePath, IO.FileRight, IO.Prim.setAccessRights, IO.FileRight.flags],[System.FilePath, IO.FileRight, IO, Unit]]
[instStreamList,[Stream.mk, List, Option, Prod, Unit, Option.none, Option.some, Prod.mk],[Stream, List]]
[PSigma.lex.proof_1,[WellFounded, WellFounded.intro, PSigma, PSigma.Lex, Acc, PSigma.lexAccessible, WellFounded.apply],[WellFounded, PSigma, PSigma.Lex]]
[IO.Process.Stdio.toHandleType,[IO.Process.Stdio, Unit, IO.FS.Handle],[IO.Process.Stdio]]
[instBEqOption,[BEq, BEq.mk, Option, Unit, Option.none, Option.some, Unit.unit, Bool, Bool.true, and, BEq.beq, Bool.false],[BEq, Option]]
[Array.appendCore,[Array, Nat, Array.size, OfNat.ofNat, instOfNatNat, Array.appendCore.loop],[Array]]
[instShiftRightUSize,[ShiftRight.mk, USize, USize.shiftRight],[ShiftRight, USize]]
[IO.Error.timeExpired.sizeOf_spec,[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar],[UInt32, String, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, Option, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.timeExpired]]
[WellFoundedRelation.mk.inj,[WellFounded, Eq, WellFoundedRelation, WellFoundedRelation.mk],[WellFounded, Eq, WellFoundedRelation, WellFoundedRelation.mk]]
[termS!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[HDiv.noConfusionType,[outParam, HDiv, Eq],[outParam, HDiv]]
[Applicative.noConfusionType,[Applicative, Functor, Pure, Seq, SeqLeft, SeqRight, Eq],[Applicative]]
[Subtype.instDecidableEqSubtype.proof_1,[Eq, Subtype, Subtype.mk, rfl],[Eq, Subtype, Subtype.mk]]
[MonadControlT.restoreM,[MonadControlT],[MonadControlT, MonadControlT.stM]]
[or_false,[propext, Or, False, Iff.intro, False.elim, Or.inl],[Eq, Or, False]]
[Except.mapError,[Except, Except.error, Except.ok],[Except]]
[Classical.indefiniteDescription.proof_1,[Exists, Nonempty, Subtype, Nonempty.intro, Subtype.mk],[Exists, Nonempty, Subtype]]
[Lean.Parser.Tactic.Conv.congr,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Parser.Tactic.tacticInfer_instance,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[USize.val,[USize],[USize, Fin, USize.size]]
[System.FilePath.pathExists,[System.FilePath, HOrElse.hOrElse, IO, Bool, instHOrElse, instOrElseEIO, IO.Error, SeqRight.seqRight, Applicative.toSeqRight, Monad.toApplicative, instMonadEIO, IO.FS.Metadata, System.FilePath.metadata, Unit, Pure.pure, Applicative.toPure, Bool.true, Bool.false],[System.FilePath, IO, Bool]]
[instOfNatNat,[Nat, OfNat.mk],[Nat, OfNat]]
[Lean.Syntax.mkSep,[Array, Lean.Syntax, Lean.mkNullNode, Lean.mkSepArray],[Array, Lean.Syntax]]
[«term_<=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[or,[Bool, Unit, Bool.true],[Bool]]
[IO.Error.mkPermissionDeniedFile,[Function.comp, String, Option, UInt32, IO.Error, IO.Error.permissionDenied, Option.some],[String, UInt32, IO.Error]]
[Lean.Syntax.isNameLit?,[Lean.Syntax, Option, String, Option.some, Option.none, Lean.Name, Lean.Syntax.isLit?, Lean.nameLitKind, Lean.Syntax.decodeNameLit],[Lean.Syntax, Option, Lean.Name]]
[Nat.eq_zero_or_pos,[Nat, Or, Eq, OfNat.ofNat, instOfNatNat, GT.gt, instLTNat, Unit, Or.inl, rfl, Or.inr, HAdd.hAdd, instHAdd, instAddNat, Nat.succ_pos],[Nat, Or, Eq, OfNat.ofNat, instOfNatNat, GT.gt, instLTNat]]
[instReprDecidable,[Repr.mk, Decidable, Nat, Std.Format, Repr.addAppParen, Std.Format.text, Not],[Repr, Decidable]]
[ULift.down,[ULift],[ULift]]
[instReprSubarray,[Repr, Repr.mk, Subarray, Nat, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, repr, Array, Array.instReprArray, Subarray.toArray, Std.Format.text],[Repr, Subarray]]
[Std.Format.append.injEq,[Std.Format, Eq.propIntro, Eq, Std.Format.append, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Std.Format, Eq, Std.Format.append, And]]
[LawfulApplicative.seqRight_eq,[Applicative, LawfulApplicative],[Applicative, LawfulApplicative, Eq, SeqRight.seqRight, Applicative.toSeqRight, Unit, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const, id]]
[IO.FileRight.other,[IO.FileRight],[IO.FileRight, IO.AccessRight]]
[String.Pos,[Nat],[]]
[TC.wf.proof_1,[WellFounded, WellFounded.intro, TC, TC.accessible, WellFounded.apply],[WellFounded, TC]]
[Lean.Syntax.mkCApp,[Lean.Name, Array, Lean.Syntax, Lean.Syntax.mkApp, Lean.mkCIdent],[Lean.Name, Array, Lean.Syntax]]
[Lean.Macro.State.noConfusionType,[Lean.Macro.State, Lean.MacroScope, List, Prod, Lean.Name, String, Eq],[Lean.Macro.State]]
[Array.partition,[Bool, Array, List.toArray, List.nil, Bind.bind, Id, Monad.toBind, Id.instMonadId, MProd, Prod, ForIn.forIn, Array.instForInArray, MProd.mk, MProd.fst, MProd.snd, ite, ForInStep, Eq, Bool.true, instDecidableEqBool, Array.push, PUnit, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, ForInStep.yield, Prod.mk],[Bool, Array, Prod]]
[StateRefT'.get,[Monad, MonadLiftT, ST, ST.Ref, ST.Ref.get],[Monad, MonadLiftT, ST, StateRefT']]
[«term_<_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[ST.Ref.set,[MonadLiftT, ST, ST.Ref, liftM, Unit, ST.Prim.Ref.set],[MonadLiftT, ST, ST.Ref, Unit]]
[IO.FS.Handle.readToEnd,[IO.FS.Handle, String, IO, IO.FS.Handle.readToEnd.loop],[IO.FS.Handle, IO, String]]
[List.headD,[List],[List]]
[Lean.Parser.Tactic.Conv.delta,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[instAddUSize,[Add.mk, USize, USize.add],[Add, USize]]
[String.drop,[String, Nat, Substring.toString, Substring.drop, String.toSubstring],[String, Nat]]
[Lean.Meta.Simp.Config.zeta,[Lean.Meta.Simp.Config],[Lean.Meta.Simp.Config, Bool]]
[Array.foldrM,[Monad, Array, optParam, Nat, Array.size, OfNat.ofNat, instOfNatNat, LE.le, instLENat, dite, Nat.decLe, ite, LT.lt, instLTNat, Nat.decLt, Pure.pure, Applicative.toPure, Monad.toApplicative, Not, Nat.le_refl, Array.foldrM.fold],[Monad, Array, optParam, Nat, Array.size, OfNat.ofNat, instOfNatNat]]
[Lean.Eval.eval,[Lean.Eval],[Lean.Eval, Unit, optParam, Bool, Bool.true, IO]]
[Char.instInhabitedChar,[Inhabited.mk, Char, Char.ofNat],[Inhabited, Char]]
[Lean.Macro.instInhabitedMethodsRef,[Inhabited.mk, PointedType.type, Lean.Macro.mkMethods, arbitrary, Lean.Macro.Methods, Lean.Macro.instInhabitedMethods],[Inhabited, PointedType.type]]
[bfix5,[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd],[Nat]]
[Iff.mpr,[Iff],[Iff]]
[OptionT.fail,[Monad, OptionT.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, Option, Option.none],[Monad, OptionT]]
[Nat.lt_of_succ_le,[Nat, LE.le, instLENat, Nat.succ],[Nat, LE.le, instLENat, Nat.succ, LT.lt, instLTNat]]
[Array.concatMap,[Array, Array.foldl, HAppend.hAppend, instHAppend, Array.instAppendArray, Array.empty, OfNat.ofNat, Nat, instOfNatNat, Array.size],[Array]]
[Nat.ble_succ_eq_true,[Nat, Eq, Bool, Nat.ble, Bool.true, Nat.succ, Nat.below, OfNat.ofNat, instOfNatNat, rfl, PProd.fst, PUnit, PProd],[Nat, Eq, Bool, Nat.ble, Bool.true, Nat.succ]]
[FloatArray.set!,[FloatArray, Nat, Float, Array, FloatArray.mk, Array.set!],[FloatArray, Float]]
[IO.Process.Stdio.noConfusionType,[IO.Process.Stdio, noConfusionTypeEnum, Nat, instDecidableEqNat, IO.Process.Stdio.toCtorIdx],[IO.Process.Stdio]]
[Lean.Parser.Tactic.existsIntro,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Lean.Parser.Tactic.«tacticNext___=>_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[HEq.noConfusionType,[HEq],[HEq]]
[Nat.noConfusionType,[Nat, Eq],[Nat]]
[instSizeOfNat,[SizeOf.mk, Nat],[SizeOf, Nat]]
[List.hasDecEq.proof_1,[rfl, List, List.nil],[Eq, List, List.nil]]
[LawfulMonad.noConfusionType,[Monad, LawfulMonad, LawfulApplicative, Monad.toApplicative, Eq, Bind.bind, Monad.toBind, Function.comp, Pure.pure, Applicative.toPure, Functor.map, Applicative.toFunctor, Seq.seq, Applicative.toSeq, Unit],[Monad, LawfulMonad]]
[instSubUInt32,[Sub.mk, UInt32, UInt32.sub],[Sub, UInt32]]
[Lean.Name.appendBefore,[Lean.Name, String, Lean.Name.modifyBase, Unit, Lean.Name.mkStr, Lean.Name.anonymous, UInt64, HAppend.hAppend, instHAppend, String.instAppendString, Nat, Lean.Name.mkNum],[Lean.Name, String]]
[List.enum,[List.enumFrom, OfNat.ofNat, Nat, instOfNatNat],[List, Prod, Nat]]
[Std.Format.text.injEq,[String, Eq.propIntro, Eq, Std.Format, Std.Format.text, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[String, Eq, Std.Format, Std.Format.text]]
[Nat.lt_or_eq_or_le_succ,[Nat, LE.le, instLENat, Nat.succ, Decidable.byCases, Eq, Or, instDecidableEqNat, Or.inr, Ne],[Nat, LE.le, instLENat, Nat.succ, Or, Eq]]
[WellFounded.noConfusionType,[WellFounded, Acc],[WellFounded]]
[IO.mapTasks.go,[List, IO, optParam, Task.Priority, Task.Priority.default, Task, Except, IO.Error, List.below, List.cons, IO.bindTask, PProd.fst, PUnit, PProd, List.nil, IO.asTask, List.reverse],[List, IO, optParam, Task.Priority, Task.Priority.default, Task, Except, IO.Error]]
[«term_\/_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[«term_/\_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instSubsingletonDecidable.proof_1,[Subsingleton.intro, Decidable, Eq, Decidable.isTrue, rfl, Not, absurd, Decidable.isFalse],[Subsingleton, Decidable]]
[Lean.Parser.Tactic.«tacticHave__:=_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Std.Format.sbracket,[Std.Format, Std.Format.bracket],[Std.Format]]
[Nat.instShiftRightNat,[ShiftRight.mk, Nat, Nat.shiftRight],[ShiftRight, Nat]]
[Nat.toUSize,[USize.ofNat],[USize]]
[Classical.em,[Or, Eq, True, False],[Or, Not]]
[Array.toSubarray,[Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, dite, Subarray, LE.le, instLENat, Nat.decLe, Subarray.mk, Not, Nat.le_refl, Array.toSubarray.proof_1],[Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Subarray]]
[HSub.noConfusionType,[outParam, HSub, Eq],[outParam, HSub]]
[IO.FS.Stream.ofBuffer,[IO.Ref, IO.FS.Stream.Buffer, IO.FS.Stream.mk, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, Bool, ST.Ref.get, IO.RealWorld, instMonadLiftT, ST, IO.instMonadLiftSTRealWorldEIO, instMonadLiftT_1, Pure.pure, Applicative.toPure, Monad.toApplicative, Decidable.decide, GE.ge, Nat, instLENat, IO.FS.Stream.Buffer.pos, ByteArray.size, IO.FS.Stream.Buffer.data, Nat.decLe, Unit, Unit.unit, USize, ST.Ref.modifyGet, ByteArray, ByteArray.extract, HAdd.hAdd, instHAdd, instAddNat, USize.toNat, Prod.mk, IO.FS.Stream.Buffer.mk, ST.Ref.modify, ByteArray.copySlice, OfNat.ofNat, instOfNatNat, Bool.false, String, Option, ByteArray.findIdx?, UInt8, or, BEq.beq, instBEq, instDecidableEqUInt8, instOfNatUInt8, Eq, Nat.toUInt8, Char.toNat, Char.ofNat, ite, ByteArray.get!, Bool.true, instDecidableEqBool, String.fromUTF8Unchecked, String.toUTF8],[IO.Ref, IO.FS.Stream.Buffer, IO.FS.Stream]]
[instOrdUInt64,[Ord.mk, UInt64, compareOfLessAndEq, instLTUInt64, instDecidableLt_3, instDecidableEqUInt64],[Ord, UInt64]]
[Option.noConfusionType,[Option, Eq],[Option]]
[true_ne_false,[ne_false_of_self, True, trivial],[Not, Eq, True, False]]
[Lean.Syntax.getOp,[Lean.Syntax, Nat, Lean.Syntax.getArg],[Lean.Syntax, Nat]]
[«termExists_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[instToStringId,[ToString, inferInstanceAs],[ToString, id]]
[ExceptT.adapt,[Monad, ExceptT, ExceptT.mk, Functor.map, Applicative.toFunctor, Monad.toApplicative, Except, Except.mapError],[Monad, ExceptT]]
[Classical.axiomOfChoice,[Exists, Exists.intro, Classical.choose, Classical.choose_spec],[Exists]]
[Array.allM,[Monad, Bool, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Bind.bind, Monad.toBind, Array.anyM, Pure.pure, Applicative.toPure, Monad.toApplicative, not],[Monad, Bool, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size]]
[Lean.Meta.Simp.Config.mk.injEq,[Nat, Bool, Eq.propIntro, Eq, Lean.Meta.Simp.Config, Lean.Meta.Simp.Config.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Nat, Bool, Eq, Lean.Meta.Simp.Config, Lean.Meta.Simp.Config.mk, And]]
[PSigma.mkSkipLeft.proof_1,[PSigma.RevLex.right, emptyRelation],[PSigma.RevLex, emptyRelation, PSigma.mk]]
[«stx_,*»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol],[Lean.TrailingParserDescr]]
[StdGen.s2,[StdGen],[StdGen, Nat]]
[PSigma.revLex,[PSigma.revLex.proof_1],[WellFounded, PSigma, PSigma.RevLex]]
[String.decEq.proof_1,[List, Char, Eq, congrArg, String, String.mk],[List, Char, Eq, String, String.mk]]
[AndOp.and,[AndOp],[AndOp]]
[Quot.recOn,[Quot, Quot.mk, Eq, Quot.sound, Quot.rec],[Quot, Quot.mk, Eq, Quot.sound]]
[instInhabitedBool,[Inhabited.mk, Bool, Bool.false],[Inhabited, Bool]]
[instBEqFloat,[BEq.mk, Float, Float.beq],[BEq, Float]]
[instMonadEST,[inferInstanceAs, Monad, EStateM, EStateM.instMonadEStateM],[Monad, EST]]
[IO.Error.otherError.injEq,[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.otherError, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[UInt32, String, Eq, IO.Error, IO.Error.otherError, And]]
[OptionT,[Option],[]]
[Std.ToFormat.noConfusionType,[Std.ToFormat, Std.Format, Eq],[Std.ToFormat]]
[Subarray.popFront.proof_1,[Subarray, LT.lt, Nat, instLTNat, Subarray.start, Subarray.stop, Nat.le_of_lt_succ, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Nat.add_lt_add_right],[Subarray, LT.lt, Nat, instLTNat, Subarray.start, Subarray.stop, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
[Classical.strongIndefiniteDescription.proof_2,[Nonempty, Not, Exists, absurd, Classical.choice],[Nonempty, Not, Exists, Classical.choice]]
[Sigma.snd,[Sigma],[Sigma, Sigma.fst]]
[List.minimum?,[LE, DecidableRel, LE.le, List, Option, Unit, Option.none, Option.some, List.foldl, min],[LE, DecidableRel, LE.le, List, Option]]
[String.nextWhile,[String, Char, Bool, String.Pos, String.bsize],[String, Char, Bool, String.Pos]]
[Eq.subst,[Eq],[Eq]]
[inline,[],[]]
[UInt8.toUInt16,[UInt8, Nat.toUInt16, UInt8.toNat],[UInt8, UInt16]]
[instOrOpUSize,[OrOp.mk, USize, USize.lor],[OrOp, USize]]
[Array.uget,[USize, LT.lt, Nat, instLTNat, USize.toNat, Array.size, Array.get, Fin.mk],[USize, LT.lt, Nat, instLTNat, USize.toNat, Array.size]]
[Lean.Parser.Tactic.simpLemma,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.Parser.Tactic.simpPre, Lean.Parser.Tactic.simpPost, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat],[Lean.ParserDescr]]
[not,[Bool, Unit, Bool.false, Bool.true],[Bool]]
[USize.ofNat32,[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, USize.mk, Fin.mk, USize.size, USize.ofNat32.proof_1],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, USize]]
[SeqLeft.noConfusionType,[SeqLeft, Unit, Eq],[SeqLeft]]
[HMod.hMod,[HMod],[HMod]]
[Lean.scientificLitKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[PointedType.noConfusionType,[PointedType, Eq, HEq],[PointedType]]
[ne_eq,[rfl, Ne],[Eq, Ne, Not]]
[System.instToStringFilePath,[ToString.mk, System.FilePath, System.FilePath.toString],[ToString, System.FilePath]]
[Std.Range.mk.inj,[Nat, Eq, Std.Range, Std.Range.mk, And, And.intro],[Nat, Eq, Std.Range, Std.Range.mk, And]]
[Lean.mkIdentFromRef,[Monad, Lean.MonadRef, Lean.Name, Bind.bind, Monad.toBind, Lean.Syntax, Lean.MonadRef.getRef, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.mkIdentFrom],[Monad, Lean.MonadRef, Lean.Name, Lean.Syntax]]
[SizeOf.noConfusionType,[SizeOf, Nat, Eq],[SizeOf]]
[Lean.Macro.Exception.noConfusionType,[Lean.Macro.Exception, Lean.Syntax, String, Eq],[Lean.Macro.Exception]]
[controlAt,[MonadControlT, Bind, MonadControlT.stM, Bind.bind, MonadControlT.liftWith, MonadControlT.restoreM],[MonadControlT, Bind, MonadControlT.stM]]
[Quotient.lift,[Setoid, Quot.lift, HasEquiv.Equiv, instHasEquiv],[Setoid, HasEquiv.Equiv, instHasEquiv, Eq, Quotient]]
[eq_false,[Not, propext, False, Iff.intro, absurd, False.elim],[Not, Eq, False]]
[Array.toListLitAux.proof_2,[Array, Nat, Eq, Array.size, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Nat.lt_of_lt_of_eq, Nat.lt_of_lt_of_le, Nat.succ, Nat.lt_succ_self],[Array, Nat, Eq, Array.size, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, LT.lt, instLTNat]]
[instOfNatUSize,[Nat, OfNat.mk, USize, USize.ofNat],[Nat, OfNat, USize]]
[instReprAtomFloat,[ReprAtom.mk, Float],[ReprAtom, Float]]
[WellFounded.fixF,[Acc],[Acc]]
[Lean.Parser.Tactic.Conv.«conv·._»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq],[Lean.ParserDescr]]
[UInt64.sub,[UInt64, UInt64.mk, HSub.hSub, Fin, UInt64.size, instHSub, Fin.instSubFin, UInt64.val],[UInt64]]
[String.endsWith,[String, BEq.beq, Substring, Substring.hasBeq, Substring.takeRight, String.toSubstring, String.length],[String, Bool]]
[termWithout_expected_type_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Int.le,[Int, Int.NonNeg, HSub.hSub, instHSub, Int.instSubInt],[Int]]
[true_and,[propext, And, True, Iff.intro, And.right, And.intro, trivial],[Eq, And, True]]
[Lean.MacroScopesView.review,[Lean.MacroScopesView, List, Lean.MacroScope, Lean.Name, Lean.MacroScopesView.scopes, Unit, Lean.MacroScopesView.name, Lean.Name.mkStr, HAppend.hAppend, instHAppend, Lean.Name.instAppendName, Lean.MacroScopesView.imported, Lean.MacroScopesView.mainModule, List.foldl, Nat, Lean.Name.mkNum],[Lean.MacroScopesView, Lean.Name]]
[Bool.true_or,[Bool, Eq, or, Bool.true, Bool.false, rfl, Eq.symm, Eq.refl],[Bool, Eq, or, Bool.true]]
[PNonScalar.mk.sizeOf_spec,[Nat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat],[Nat, Eq, SizeOf.sizeOf, PNonScalar, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, instSizeOfNat, PNonScalar.mk]]
[Fin.shiftLeft.proof_1,[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, HShiftLeft.hShiftLeft, instHShiftLeft, Nat.instShiftLeftNat],[Nat, LT.lt, instLTNat, HMod.hMod, instHMod, Nat.instModNat, HShiftLeft.hShiftLeft, instHShiftLeft, Nat.instShiftLeftNat]]
[Lean.Meta.Simp.Config.beta,[Lean.Meta.Simp.Config],[Lean.Meta.Simp.Config, Bool]]
[ByteArray.get!,[ByteArray, Nat, UInt8, Array, Array.get!, instInhabitedUInt8],[UInt8]]
[Lean.Meta.TransparencyMode.all.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, Lean.Meta.TransparencyMode, SizeOf.mk, OfNat.ofNat, instOfNatNat, Lean.Meta.TransparencyMode.all]]
[Lean.version.specialDesc,[Lean.version.getSpecialDesc, Unit.unit],[String]]
[dite_false,[False, Not, rfl, dite, instDecidableFalse],[False, Not, Eq, dite, instDecidableFalse, not_false]]
[«term_/_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[CoeHead.noConfusionType,[CoeHead, Eq],[CoeHead]]
[Option.map,[Option, Option.bind, Function.comp, Option.some],[Option]]
[Nat.succ_ne_zero,[Nat, Eq, Nat.succ, OfNat.ofNat, instOfNatNat, False],[Nat, Ne, Nat.succ, OfNat.ofNat, instOfNatNat]]
[Array.filterMapM,[Monad, Option, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Array.foldlM, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.push, Unit, List.toArray, List.nil],[Monad, Option, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size]]
[instInhabitedUInt32,[Inhabited.mk, UInt32, UInt32.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, instInhabitedUInt32.proof_1],[Inhabited, UInt32]]
[instToStringOption,[ToString, ToString.mk, Option, String, Unit, HAppend.hAppend, instHAppend, String.instAppendString, addParenHeuristic, ToString.toString],[ToString, Option]]
[instMulNat,[Mul.mk, Nat, Nat.mul],[Mul, Nat]]
[StateM,[StateT, Id],[]]
[«term_&&&_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[IO.Error.unsupportedOperation.inj,[UInt32, String, Eq, IO.Error, IO.Error.unsupportedOperation, And, And.intro],[UInt32, String, Eq, IO.Error, IO.Error.unsupportedOperation, And]]
[UInt32.ofNat',[Nat, LT.lt, instLTNat, UInt32.size, UInt32.mk, Fin.mk],[Nat, LT.lt, instLTNat, UInt32.size, UInt32]]
[decidableOfDecidableOfIff.proof_1,[Iff, Not, absurd, False, Iff.mpr],[Iff, Not, False]]
[instMulUInt8,[Mul.mk, UInt8, UInt8.mul],[Mul, UInt8]]
[Lean.Name.mkSimple,[String, Lean.Name.mkStr, Lean.Name.anonymous],[String, Lean.Name]]
[String.Iterator.hasNext,[String.Iterator, Bool, String, String.Pos, Decidable.decide, LT.lt, instLTNat, String.utf8ByteSize, Nat.decLt],[String.Iterator, Bool]]
[String.decapitalize,[String, String.set, OfNat.ofNat, String.Pos, instOfNatNat, Char.toLower, String.get],[String]]
[Array.findSomeRevM?,[Monad, Array, Option, Nat, LE.le, instLENat, Array.size, Nat.le_refl, Array.findSomeRevM?.find],[Monad, Array, Option]]
[IO.Error.mkPermissionDenied,[IO.Error.permissionDenied, Option.none, String],[UInt32, String, IO.Error]]
[instMulFloat,[Mul.mk, Float, Float.mul],[Mul, Float]]
[Nat.ble_eq_true_of_le,[Nat, LE.le, instLENat, Eq, Bool, Nat.ble, Bool.true, Nat.below, Unit, Nat.ble_self_eq_true, Nat.le, Nat.ble_succ_eq_true, PProd.fst, PUnit, PProd],[Nat, LE.le, instLENat, Eq, Bool, Nat.ble, Bool.true]]
[coeM,[CoeT, Monad, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, coe],[CoeT, Monad]]
[instDecidableEqOption,[DecidableEq, Option, Unit, Option.none, Option.some, Unit.unit, Decidable, Eq, Decidable.isTrue, rfl, Decidable.isFalse, False, dite, Not],[DecidableEq, Option]]
[Lean.instMonadQuotation,[MonadFunctor, MonadLift, Lean.MonadQuotation, Lean.MonadQuotation.mk, Lean.instMonadRef, Lean.MonadQuotation.toMonadRef, liftM, instMonadLiftT, instMonadLiftT_1, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, MonadFunctorT.monadMap, instMonadFunctorT, monadFunctorRefl, Lean.MonadQuotation.withFreshMacroScope],[MonadFunctor, MonadLift, Lean.MonadQuotation]]
[Lean.Module.commands,[Lean.Module],[Lean.Module, Array, Lean.Syntax]]
[ExceptT.run_pure,[Monad, rfl, Except, ExceptT.run, Pure.pure, ExceptT, Applicative.toPure, Monad.toApplicative, ExceptT.instMonadExceptT],[Monad, Eq, Except, ExceptT.run, Pure.pure, ExceptT, Applicative.toPure, Monad.toApplicative, ExceptT.instMonadExceptT, Except.ok]]
[List.lengthTR,[List, List.lengthTRAux, OfNat.ofNat, Nat, instOfNatNat],[List, Nat]]
[instXorUInt32,[Xor.mk, UInt32, UInt32.xor],[Xor, UInt32]]
[Fin.xor.proof_1,[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, Nat.xor],[Nat, LT.lt, instLTNat, HMod.hMod, instHMod, Nat.instModNat, Nat.xor]]
[Lean.Parser.Tactic.Conv.simp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpStar, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma],[Lean.ParserDescr]]
[WellFoundedRelation.mk.injEq,[WellFounded, Eq.propIntro, Eq, WellFoundedRelation, WellFoundedRelation.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[WellFounded, Eq, WellFoundedRelation, WellFoundedRelation.mk]]
[Array.findSome?,[Array, Option, Id.run, Array.findSomeM?, Id, Id.instMonadId],[Array, Option]]
[instToStringULift,[ToString, ToString.mk, ULift, ToString.toString, ULift.down],[ToString, ULift]]
[Lean.Syntax.mkApp,[Lean.Syntax, Array, Unit, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkNullNode, List.nil],[Lean.Syntax, Array]]
[Array.forM,[Monad, PUnit, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Array.foldlM, PUnit.unit],[Monad, PUnit, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size]]
[Lean.Syntax.getNumArgs,[Lean.Syntax, Nat, Lean.SyntaxNodeKind, Array, Array.size, OfNat.ofNat, instOfNatNat],[Lean.Syntax, Nat]]
[EStateM.run,[EStateM],[EStateM, EStateM.Result]]
[IO.Error.unexpectedEof.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, Option, String, UInt32, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.unexpectedEof]]
[System.Platform.isEmscripten,[System.Platform.getIsEmscripten, Unit.unit],[Bool]]
[Classical.skolem,[Iff.intro, Exists, Classical.axiomOfChoice, Exists.intro],[Iff, Exists]]
[instReprFin,[Nat, Repr.mk, Fin, repr, instReprNat, Fin.val],[Nat, Repr, Fin]]
[Lean.Parser.Tactic.rwRule,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat],[Lean.ParserDescr]]
[List.redLength,[List, Nat, List.below, Unit, List.nil, OfNat.ofNat, instOfNatNat, List.cons, Nat.succ, PProd.fst, PUnit, PProd],[List, Nat]]
[List.get?,[Nat, List, Option, Nat.below, Option.some, Nat.succ, PProd.fst, PUnit, PProd, Option.none],[Nat, List, Option]]
[Lean.Name.eraseMacroScopes,[Lean.Name, Bool, Lean.Name.hasMacroScopes, Unit, Lean.Name.below, String, UInt64, Lean.Name.str, Nat, Lean.Name.num, Lean.Name.anonymous, Unit.unit, BEq.beq, instBEq, instDecidableEqString, PProd.fst, PUnit, PProd],[Lean.Name]]
[IO.userError,[String, IO.Error.userError],[String, IO.Error]]
[sizeOfWFRel,[SizeOf, measure, SizeOf.sizeOf],[SizeOf, WellFoundedRelation]]
[Lean.MonadNameGenerator.setNGen,[Lean.MonadNameGenerator],[Lean.MonadNameGenerator, Lean.NameGenerator, Unit]]
[Subarray.mk.inj,[Array, Nat, LE.le, instLENat, Array.size, Eq, Subarray, Subarray.mk, And, And.intro],[Array, Nat, LE.le, instLENat, Array.size, Eq, Subarray, Subarray.mk, And]]
[Nat.mul_pos,[Nat, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat],[Nat, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, HMul.hMul, instHMul, instMulNat]]
[List.hasDecidableLt.proof_1,[LT, LT.lt, List, List.instLTList, List.nil, False],[LT, LT.lt, List, List.instLTList, List.nil, False]]
[IO.Error.instToStringError,[ToString.mk, IO.Error, IO.Error.toString],[ToString, IO.Error]]
[instToBoolBool,[ToBool.mk, Bool],[ToBool, Bool]]
[ExceptCpsT.lift,[Monad, Bind.bind, Monad.toBind],[Monad, ExceptCpsT]]
[default.sizeOf,[OfNat.ofNat, Nat, instOfNatNat],[Nat]]
[instMulUSize,[Mul.mk, USize, USize.mul],[Mul, USize]]
[System.FilePath.instDivFilePath,[Div.mk, System.FilePath, System.FilePath.join],[Div, System.FilePath]]
[Quot.liftIndepPr1,[Quot, Quot.mk, Eq, Quot.sound, Quot.ind, PSigma.fst, Quot.lift, PSigma, Quot.indep, Quot.indepCoherent, rfl],[Quot, Quot.mk, Eq, Quot.sound, PSigma.fst, Quot.lift, PSigma, Quot.indep, Quot.indepCoherent]]
[«term_^^^_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[IO.FS.Stream.Buffer.pos,[IO.FS.Stream.Buffer],[IO.FS.Stream.Buffer, Nat]]
[List.forIn.loop,[Monad, ForInStep, List, List.below, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, List.cons, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd],[Monad, ForInStep, List]]
[Lean.Syntax.node.inj,[Lean.SyntaxNodeKind, Array, Lean.Syntax, Eq, Lean.Syntax.node, And, And.intro],[Lean.SyntaxNodeKind, Array, Lean.Syntax, Eq, Lean.Syntax.node, And]]
[Subrelation,[],[]]
[IO.Error.mkUnsupportedOperation,[IO.Error.unsupportedOperation],[UInt32, String, IO.Error]]
[IO.FS.Metadata.noConfusionType,[IO.FS.Metadata, IO.FS.SystemTime, UInt64, IO.FS.FileType, Eq],[IO.FS.Metadata]]
[Array.set!,[Array, Array.setD],[Array]]
[Nonempty.elim,[Nonempty.elim.proof_1],[Nonempty]]
[OptionT.instMonadFunctorOptionT,[MonadFunctor.mk, OptionT, Option],[MonadFunctor, OptionT]]
[DoResultBC.noConfusionType,[DoResultBC, Eq],[DoResultBC]]
[instNegFloat,[Neg.mk, Float, Float.neg],[Neg, Float]]
[Quotient,[Setoid, Quot, Setoid.r],[Setoid]]
[RandomGen.range,[RandomGen],[RandomGen, Prod, Nat]]
[instInhabited,[Monad, Inhabited, Inhabited.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, arbitrary],[Monad, Inhabited]]
[instSubsingletonForall,[instSubsingletonForall.proof_1],[Subsingleton]]
[Lean.Syntax.isScientificLit?,[Lean.Syntax, Option, String, Option.some, Option.none, Prod, Nat, Bool, Lean.Syntax.isLit?, Lean.scientificLitKind, Lean.Syntax.decodeScientificLitVal?],[Lean.Syntax, Option, Prod, Nat, Bool]]
[Quotient.sound.proof_1,[Setoid, Quot.sound, HasEquiv.Equiv, instHasEquiv],[Setoid, HasEquiv.Equiv, instHasEquiv, Eq, Quot, Quot.mk]]
[ExceptT.bindCont,[Monad, ExceptT, Except, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.error],[Monad, ExceptT, Except]]
[IO.AccessRight.read,[IO.AccessRight],[IO.AccessRight, Bool]]
[List.getLastD.proof_1,[List, Eq, List.cons, List.nil, False],[List, Eq, List.cons, List.nil, List.noConfusionType, False]]
[USize.modn,[USize, USize.mk, HMod.hMod, Fin, USize.size, Nat, Fin.instHModFinNatFin, USize.val],[USize]]
[seqLeft_eq_bind,[Monad, LawfulMonad, Eq.mpr, Eq, SeqLeft.seqLeft, Applicative.toSeqLeft, Monad.toApplicative, Unit, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const, Eq.refl, LawfulApplicative.seqLeft_eq, LawfulMonad.toLawfulApplicative, of_eq_true, Eq.trans, True, congrFun, congrArg, map_eq_pure_bind, seq_eq_bind_map, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, eq_self],[Monad, LawfulMonad, Eq, SeqLeft.seqLeft, Applicative.toSeqLeft, Monad.toApplicative, Unit, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure]]
[instHModUInt32NatUInt32,[HMod.mk, UInt32, Nat, UInt32.modn],[HMod, UInt32, Nat]]
[HAdd.hAdd,[HAdd],[HAdd]]
[UInt32.decLe,[UInt32, Decidable, LE.le, instLEUInt32, Fin, UInt32.size, inferInstanceAs, instLEFin, Fin.decLe],[UInt32, Decidable, LE.le, instLEUInt32]]
[unexpandPSigma,[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, cond, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Lean.MacroScopesView.noConfusionType,[Lean.MacroScopesView, Lean.Name, List, Lean.MacroScope, Eq],[Lean.MacroScopesView]]
[Nat.succ_sub_succ,[Nat, Nat.succ_sub_succ_eq_sub],[Nat, Eq, HSub.hSub, instHSub, instSubNat, Nat.succ]]
[UInt16.val,[UInt16],[UInt16, Fin, UInt16.size]]
[IO.FS.instBEqFileType,[BEq.mk, IO.FS.FileType, BEq.beq, Nat, instBEq, instDecidableEqNat, IO.FS.FileType.toCtorIdx],[BEq, IO.FS.FileType]]
[Subtype.eq,[Subtype, Eq, Subtype.val, rfl, Subtype.mk],[Subtype, Eq, Subtype.val]]
[OptionT.instAlternativeOptionT,[Monad, Alternative.mk, OptionT, Monad.toApplicative, OptionT.instMonadOptionT, OptionT.fail, OptionT.orElse],[Monad, Alternative, OptionT]]
[Fin.modn.proof_1,[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt],[Nat, LT.lt, instLTNat, HMod.hMod, instHMod, Nat.instModNat]]
[Lean.Macro.hasDecl,[Lean.Name, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, Bool, Lean.Macro.getMethods, Lean.Macro.Methods.hasDecl],[Lean.Name, Lean.MacroM, Bool]]
[Array.feraseIdx,[Array, Fin, Array.size, Array.eraseIdxAux, HAdd.hAdd, Nat, instHAdd, instAddNat, Fin.val, OfNat.ofNat, instOfNatNat],[Array, Fin, Array.size]]
[ReaderT.orElse,[Alternative, ReaderT, Unit, HOrElse.hOrElse, instHOrElse, instOrElse, Unit.unit],[Alternative, ReaderT, Unit]]
[fixCore4,[bfix4, USize.size],[]]
[List.hasDecEq.proof_6,[List, Not, Eq, List.cons, False, absurd],[List, Not, Eq, List.cons, False]]
[Nat.pow_le_pow_of_le_left,[Nat, LE.le, instLENat, HPow.hPow, instHPow, instPowNatNat, Nat.below, Unit, Nat.le_refl, OfNat.ofNat, instOfNatNat, Nat.succ, Nat.mul_le_mul, Nat.pow, PProd.fst, PUnit, PProd],[Nat, LE.le, instLENat, HPow.hPow, instHPow, instPowNatNat]]
[Nat.ne_of_beq_eq_false,[Nat, Eq, Bool, Nat.beq, Bool.false, False, Nat.below, Nat.zero, Nat.succ],[Nat, Eq, Bool, Nat.beq, Bool.false, Not]]
[MonadFunctor.noConfusionType,[MonadFunctor, Eq],[MonadFunctor]]
[fix3,[Inhabited, fixCore3, arbitrary],[Inhabited]]
[Nat.gcd_self,[Nat, Eq, Nat.gcd, Nat.zero, of_eq_true, Eq.trans, OfNat.ofNat, instOfNatNat, True, congr, congrArg, Nat.zero_eq, Nat.gcd_zero_right, eq_true_of_decide, instDecidableEqNat, Eq.refl, Bool, Bool.true, Eq.symm, Nat.succ, congrFun, HMod.hMod, instHMod, Nat.instModNat, Nat.gcd_succ, Nat.mod_self, Nat.gcd_zero_left, eq_self],[Nat, Eq, Nat.gcd]]
[Lean.Name.appendIndexAfter,[Lean.Name, Nat, Lean.Name.modifyBase, String, UInt64, Lean.Name.mkStr, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString, instToStringNat],[Lean.Name, Nat]]
[String.Iterator.toEnd,[String.Iterator, String, String.Pos, String.Iterator.mk, String.bsize],[String.Iterator]]
[coeB,[Coe, Coe.coe],[Coe]]
[Nat.gcd_zero_left,[Nat, rfl, Nat.gcd, OfNat.ofNat, instOfNatNat],[Nat, Eq, Nat.gcd, OfNat.ofNat, instOfNatNat]]
[Ord.compare,[Ord],[Ord, Ordering]]
[ST.Ref.mk.inj,[PointedType.type, ST.RefPointed, Nonempty, Eq, ST.Ref, ST.Ref.mk],[PointedType.type, ST.RefPointed, Nonempty, Eq, ST.Ref, ST.Ref.mk]]
[ST.Ref.noConfusionType,[ST.Ref, PointedType.type, ST.RefPointed, Nonempty, Eq],[ST.Ref]]
[ReaderT.run_seqLeft,[Monad, LawfulMonad, ReaderT, Eq.mpr, Eq, ReaderT.run, SeqLeft.seqLeft, Applicative.toSeqLeft, Monad.toApplicative, ReaderT.instMonadReaderT, Unit, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Eq.refl, seqLeft_eq_bind, rfl],[Monad, LawfulMonad, ReaderT, Eq, ReaderT.run, SeqLeft.seqLeft, Applicative.toSeqLeft, Monad.toApplicative, ReaderT.instMonadReaderT, Unit]]
[Nat.lt_irrefl,[Nat, Nat.not_succ_le_self],[Nat, Not, LT.lt, instLTNat]]
[List.filterAuxM,[Monad, Bool, List, List.below, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, List.cons, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd, cond],[Monad, Bool, List]]
[System.FilePath.isCaseInsensitive,[or, System.Platform.isWindows, System.Platform.isOSX],[Bool]]
[FloatArray.get!,[FloatArray, Nat, Float, Array, Array.get!, instInhabitedFloat],[Float]]
[Nat.add_mul,[Nat, Nat.right_distrib],[Nat, Eq, HMul.hMul, instHMul, instMulNat, HAdd.hAdd, instHAdd, instAddNat]]
[Lean.Syntax.atom.inj,[Lean.SourceInfo, String, Eq, Lean.Syntax, Lean.Syntax.atom, And, And.intro],[Lean.SourceInfo, String, Eq, Lean.Syntax, Lean.Syntax.atom, And]]
[Bool.true_and,[Bool, Eq, and, Bool.true, Bool.false, rfl, Eq.symm, Eq.refl],[Bool, Eq, and, Bool.true]]
[TC.accessible.proof_1,[Acc, TC, Acc.intro, Acc.inv],[Acc, TC]]
[withPtrAddr,[USize, Eq, OfNat.ofNat, instOfNatUSize],[USize, Eq]]
[Std.Range.«term[_:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[IO.Error.mkUnsatisfiedConstraints,[IO.Error.unsatisfiedConstraints],[UInt32, String, IO.Error]]
[Lean.Parser.Tactic.Conv.convErw_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq],[Lean.ParserDescr]]
[UInt8.toUInt64,[UInt8, Nat.toUInt64, UInt8.toNat],[UInt8, UInt64]]
[List.head!,[Inhabited, List, Unit, panicWithPosWithDecl, OfNat.ofNat, Nat, instOfNatNat],[Inhabited, List]]
[coeFun,[CoeFun, CoeFun.coe],[CoeFun]]
[Array.toListLitAux,[Array, Nat, Eq, Array.size, LE.le, instLENat, List, Nat.below, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, PProd.fst, PUnit, PProd, Array.toListLitAux.proof_1, List.cons, Array.getLit, Array.toListLitAux.proof_2],[Array, Nat, Eq, Array.size, LE.le, instLENat, List]]
[List.isEmpty,[List, Bool, Unit, Bool.true, Bool.false],[List, Bool]]
[List.forA,[Applicative, List, PUnit, List.below, Unit, List.nil, Pure.pure, Applicative.toPure, PUnit.unit, List.cons, SeqRight.seqRight, Applicative.toSeqRight, PProd.fst, PProd],[Applicative, List, PUnit]]
[IO.Error.hardwareFault.injEq,[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.hardwareFault, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[UInt32, String, Eq, IO.Error, IO.Error.hardwareFault, And]]
[USize.mod,[USize, USize.mk, HMod.hMod, Fin, USize.size, instHMod, Fin.instModFin, USize.val],[USize]]
[instAppendSubarray,[Append.mk, Subarray, Array, HAppend.hAppend, instHAppend, Array.instAppendArray, Subarray.toArray, Array.toSubarray, OfNat.ofNat, optParam, Nat, instOfNatNat, Array.size],[Append, Subarray]]
[Array.filter,[Bool, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Array.foldl, ite, Eq, Bool.true, instDecidableEqBool, Array.push, List.toArray, List.nil],[Bool, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size]]
[DoResultSBC.continue.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, DoResultSBC, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, DoResultSBC.continue]]
[Except.ok.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, Except, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Except.ok]]
[IO.Process.Output.mk.inj,[UInt32, String, Eq, IO.Process.Output, IO.Process.Output.mk, And, And.intro],[UInt32, String, Eq, IO.Process.Output, IO.Process.Output.mk, And]]
[Array.push,[Array, Array.mk, List.concat, Array.data],[Array]]
[String.toInt?,[String, OptionM.run, Int, ite, OptionM, Eq, Char, String.get, OfNat.ofNat, String.Pos, instOfNatNat, Char.ofNat, instDecidableEqChar, Bind.bind, Monad.toBind, OptionT.instMonadOptionT, Id, Id.instMonadId, Nat, Substring.toNat?, Substring.drop, String.toSubstring, Pure.pure, Applicative.toPure, Alternative.toApplicative, OptionT.instAlternativeOptionT, Neg.neg, Int.instNegInt, Int.ofNat, Functor.map, Applicative.toFunctor, String.toNat?],[String, Option, Int]]
[MonadExceptOf.throw,[MonadExceptOf],[MonadExceptOf]]
[Classical.epsilon_spec_aux,[Nonempty, Subtype.property, Exists, Classical.strongIndefiniteDescription],[Nonempty, Exists, Classical.epsilon]]
[liftM,[MonadLiftT.monadLift],[MonadLiftT]]
[Nat.mod.proof_1,[WellFoundedRelation.wf, Nat, measure, id],[WellFounded, Nat, WellFoundedRelation.rel, measure, id]]
[Nat.left_distrib,[Nat, Eq, HMul.hMul, instHMul, instMulNat, HAdd.hAdd, instHAdd, instAddNat, Eq.mpr, Nat.zero, OfNat.ofNat, instOfNatNat, Eq.refl, Nat.zero_mul, rfl, Nat.succ, congr, congrArg, Eq.trans, Nat.succ_mul, congrFun, Nat.add_assoc, Nat.add_left_comm],[Nat, Eq, HMul.hMul, instHMul, instMulNat, HAdd.hAdd, instHAdd, instAddNat]]
[Nat.zero_eq,[rfl, Nat, Nat.zero],[Eq, Nat, Nat.zero, OfNat.ofNat, instOfNatNat]]
[Lean.instQuoteProd,[Lean.Quote, Lean.Quote.mk, Prod, Lean.Syntax, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Quote.quote, List.nil],[Lean.Quote, Prod]]
[List.groupByAux,[Bool, List, List.below, List.cons, Unit, PProd.fst, PUnit, PProd, List.nil, List.reverse],[Bool, List]]
[Lean.MacroScopesView.name,[Lean.MacroScopesView],[Lean.MacroScopesView, Lean.Name]]
[List.cons.sizeOf_spec,[SizeOf, List, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk],[SizeOf, List, Eq, Nat, SizeOf.sizeOf, SizeOf.mk, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, List.cons]]
[Float.lt,[Float, FloatSpec.float, floatSpec, FloatSpec.lt],[Float]]
[runEST,[EST, EStateM.Result, Unit, Except, Unit.unit, Except.ok, Except.error],[EST, Except]]
[instHPow,[Pow, HPow.mk, Pow.pow],[Pow, HPow]]
[List.getLast!,[Inhabited, List, Unit, panicWithPosWithDecl, OfNat.ofNat, Nat, instOfNatNat, List.getLast, List.cons, List.getLast!.proof_1],[Inhabited, List]]
[Nat.mul_one,[Nat.zero_add],[Nat, Eq, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat]]
[CoeT.coe,[CoeT],[CoeT]]
[String.Iterator.hasPrev,[String.Iterator, Bool, String, String.Pos, Decidable.decide, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, Nat.decLt],[String.Iterator, Bool]]
[EStateM.instInhabitedEStateM,[Inhabited, Inhabited.mk, EStateM, EStateM.Result.error, arbitrary],[Inhabited, EStateM]]
[Decidable.not_and_iff_or_not,[Decidable, Iff.intro, Not, And, Or, absurd, And.intro, Or.inr, Or.inl, False],[Decidable, Iff, Not, And, Or]]
[«term_==_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Array.getMax?,[Array, Bool, dite, Option, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, Array.size, Nat.decLt, Array.get, Fin.mk, Option.some, Array.foldl, ite, Eq, Bool.true, instDecidableEqBool, optParam, Not, Option.none],[Array, Bool, Option]]
[List.elem,[BEq, List, Bool, List.below, Unit, List.nil, Bool.false, List.cons, BEq.beq, Bool.true, PProd.fst, PUnit, PProd],[BEq, List, Bool]]
[String.dropRight,[String, Nat, Substring.toString, Substring.dropRight, String.toSubstring],[String, Nat]]
[IO.AccessRight.noConfusionType,[IO.AccessRight, Bool, Eq],[IO.AccessRight]]
[List.reverseAux,[List, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd],[List]]
[IO.Error.noConfusionType,[IO.Error, Option, String, UInt32, Eq],[IO.Error]]
[System.FilePath.fileName,[System.FilePath, String, Option, String.Pos, String.revFind, System.FilePath.toString, List.contains, Char, instBEq, instDecidableEqChar, System.FilePath.pathSeparators, String.extract, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, String.bsize, Unit, ite, Eq, Bool, or, String.isEmpty, BEq.beq, instDecidableEqString, Bool.true, instDecidableEqBool, Option.none, Option.some],[System.FilePath, Option, String]]
[ToStream.toStream,[ToStream],[ToStream]]
[unexpandSigma,[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, cond, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[instToStreamListList,[ToStream.mk, List],[ToStream, List]]
[let_val_congr,[Eq, rfl],[Eq]]
[Lean.SyntaxNodeKind,[Lean.Name],[]]
[ExceptCpsT.run_throw,[Monad, rfl, Except, ExceptCpsT.run, MonadExcept.throw, ExceptCpsT, instMonadExcept, ExceptCpsT.instMonadExceptOfExceptCpsT],[Monad, Eq, Except, ExceptCpsT.run, MonadExcept.throw, ExceptCpsT, instMonadExcept, ExceptCpsT.instMonadExceptOfExceptCpsT, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.error]]
[Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat, LT.lt, instLTNat, Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1],[Trans, Nat, LT.lt, instLTNat]]
[Char.utf8Size.proof_5,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size]]
[Lean.Parser.Tactic.Conv.whnf,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[«term{__:_//_}»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[instSubsingleton,[instSubsingleton.proof_1],[Subsingleton]]
[UInt32.div,[UInt32, UInt32.mk, HDiv.hDiv, Fin, UInt32.size, instHDiv, Fin.instDivFin, UInt32.val],[UInt32]]
[Setoid.trans,[Setoid, HasEquiv.Equiv, instHasEquiv, Equivalence.trans, Setoid.r, Setoid.iseqv],[Setoid, HasEquiv.Equiv, instHasEquiv]]
[Nat.add_left_cancel,[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Eq.mpr, Nat.zero, implies_congr, congr, congrArg, Eq.trans, OfNat.ofNat, instOfNatNat, congrFun, Nat.zero_eq, Nat.zero_add, Eq.refl, Nat.succ, Nat.succ_add, Nat.succ.injEq],[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat]]
[implies_true,[propext, True, Iff.intro, trivial, True.intro],[Eq, True]]
[instMonadStateOf,[MonadLift, MonadStateOf, MonadStateOf.mk, liftM, instMonadLiftT, instMonadLiftT_1, MonadStateOf.get, PUnit, MonadStateOf.set, Prod, MonadLiftT.monadLift, MonadState.modifyGet, instMonadState],[MonadLift, MonadStateOf]]
[instHashable,[Hashable.mk, OfNat.ofNat, UInt64, instOfNatUInt64],[Hashable]]
[HSub.hSub,[HSub],[HSub]]
[prioDefault,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[List.lookup,[BEq, List, Prod, Option, List.below, List.nil, Option.none, List.cons, Prod.mk, Bool, BEq.beq, Unit, Option.some, PProd.fst, PUnit, PProd],[BEq, List, Prod, Option]]
[UInt32.toUInt16,[UInt32, Nat.toUInt16, UInt32.toNat],[UInt32, UInt16]]
[Trans.trans,[Trans],[Trans]]
[Lean.mkCIdent,[Lean.Name, Lean.mkCIdentFrom, Lean.Syntax.missing],[Lean.Name, Lean.Syntax]]
[Lean.instInhabitedNameGenerator,[Inhabited.mk, Lean.NameGenerator, Lean.NameGenerator.mk, arbitrary, Lean.Name, Lean.instInhabitedName, Nat, instInhabitedNat],[Inhabited, Lean.NameGenerator]]
[List.length_set,[List, Nat, Eq, List.length, List.set, rfl, List.nil, List.cons, Nat.zero, Eq.symm, Nat.succ, of_eq_true, Eq.trans, True, congr, congrArg, List.length_cons, eq_self, Eq.refl],[List, Nat, Eq, List.length, List.set]]
[StateT.run_modify,[Monad, rfl, Prod, PUnit, StateT.run, modify, StateT, instMonadState, instMonadStateOfStateT],[Monad, Eq, Prod, PUnit, StateT.run, modify, StateT, instMonadState, instMonadStateOfStateT, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk, PUnit.unit]]
[StateCpsT.run'_eq,[Monad, StateCpsT, rfl, StateCpsT.run'],[Monad, StateCpsT, Eq, StateCpsT.run', StateCpsT.runK, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[Except.map_id,[funext, Except, Except.map, id, Eq.mpr, Eq, Except.error, Except.ok, congr, congrArg, id_eq, rfl, Eq.symm, Eq.refl],[Eq, Except, Except.map, id]]
[and_true,[propext, And, True, Iff.intro, And.left, And.intro, trivial],[Eq, And, True]]
[Fin.land,[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, Nat.land, Fin.land.proof_1],[Nat, Fin]]
[ExceptCpsT.runK,[ExceptCpsT],[ExceptCpsT]]
[MonadWithReaderOf.withReader,[MonadWithReaderOf],[MonadWithReaderOf]]
[USize.ofNatCore,[LT.lt, Nat, instLTNat, USize.size, USize.mk, Fin.mk],[LT.lt, Nat, instLTNat, USize.size, USize]]
[Lean.NameGenerator.namePrefix,[Lean.NameGenerator],[Lean.NameGenerator, Lean.Name]]
[Array.foldr,[Array, optParam, Nat, Array.size, OfNat.ofNat, instOfNatNat, Id.run, Array.foldrM, Id, Id.instMonadId],[Array, optParam, Nat, Array.size, OfNat.ofNat, instOfNatNat]]
[String.instDecidableEqIterator,[String.Iterator, String, String.Pos, String.Iterator.mk, Decidable, Eq, dite, instDecidableEqString, instDecidableEqNat, Decidable.isTrue, rfl, Not, Decidable.isFalse, False],[DecidableEq, String.Iterator]]
[instToFormatList,[Std.ToFormat, Std.ToFormat.mk, List, List.format],[Std.ToFormat, List]]
[Lean.Syntax.decodeStrLit,[String, Lean.Syntax.decodeStrLitAux, OfNat.ofNat, String.Pos, instOfNatNat],[String, Option]]
[«term∃_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Quotient.lift₂.proof_2,[Setoid, HasEquiv.Equiv, instHasEquiv, Eq, Quotient, Quotient.ind, Quotient.lift, Setoid.refl],[Setoid, HasEquiv.Equiv, instHasEquiv, Eq, Quotient, Quotient.lift, Setoid.refl]]
[HXor.hXor,[HXor],[HXor]]
[Array.isEmpty,[Array, Decidable.decide, Eq, Nat, Array.size, OfNat.ofNat, instOfNatNat, instDecidableEqNat],[Array, Bool]]
[UInt32.toUSize,[UInt32, Nat.toUSize, UInt32.toNat],[UInt32, USize]]
[instCoeStringError,[Coe.mk, String, IO.Error, IO.userError],[Coe, String, IO.Error]]
[IO.FS.instInhabitedSystemTime,[Inhabited.mk, IO.FS.SystemTime, IO.FS.SystemTime.mk, arbitrary, Int, Int.instInhabitedInt, UInt32, instInhabitedUInt32],[Inhabited, IO.FS.SystemTime]]
[ReprAtom.noConfusionType,[ReprAtom],[ReprAtom]]
[Eq.trans,[Eq],[Eq]]
[List.asString,[List, Char, String.mk],[List, Char, String]]
[Array.find?,[Array, Bool, Id.run, Option, Array.findM?, Id, Id.instMonadId],[Array, Bool, Option]]
[Array.contains,[BEq, Array, Array.any, BEq.beq, OfNat.ofNat, Nat, instOfNatNat, Array.size],[BEq, Array, Bool]]
[proofIrrel,[rfl],[Eq]]
[instDecidableIff.proof_1,[Iff.intro],[Iff]]
[withPtrEqDecEq,[Unit, Decidable, Eq, Bool, withPtrEq, toBoolUsing, Unit.unit, withPtrEqDecEq.proof_1, Eq.refl, Bool.true, Decidable.isTrue, withPtrEqDecEq.proof_2, Bool.false, Decidable.isFalse, withPtrEqDecEq.proof_3],[Unit, Decidable, Eq]]
[List.length_add_eq_lengthTRAux,[List, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, List.length, List.lengthTRAux, of_eq_true, OfNat.ofNat, instOfNatNat, Eq.trans, True, congrFun, congrArg, Nat.zero_add, eq_self, Eq.mpr, List.cons, Nat.succ, congr, Nat.succ_add, Eq.symm, rfl],[List, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, List.length, List.lengthTRAux]]
[hexDigitRepr,[Nat, String.singleton, Nat.digitChar],[Nat, String]]
[instDecidableEqSum.proof_3,[Eq, Sum, Sum.inr, rfl],[Eq, Sum, Sum.inr]]
[Int.decEq.proof_1,[Nat, Eq, Int, Int.ofNat, rfl],[Nat, Eq, Int, Int.ofNat]]
[Substring.trimLeft,[Substring, Substring.dropWhile, Char.isWhitespace],[Substring]]
[Lean.Parser.Tactic.Conv.rewrite,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq],[Lean.ParserDescr]]
[Std.Range.stop,[Std.Range],[Std.Range, Nat]]
[heq_of_eq,[Eq, Eq.subst, HEq, HEq.refl],[Eq, HEq]]
[UInt16.lt,[UInt16, LT.lt, Fin, UInt16.size, instLTFin, UInt16.val],[UInt16]]
[WellFounded.fix,[WellFounded, WellFounded.fixF, WellFounded.apply],[WellFounded]]
[Array.foldlMUnsafe.fold,[Monad, Array, USize, ite, Eq, Bool, BEq.beq, instBEq, instDecidableEqUSize, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, Bind.bind, Monad.toBind, Array.uget, lcProof, LT.lt, Nat, instLTNat, USize.toNat, Array.size, Array.foldlMUnsafe.fold, HAdd.hAdd, instHAdd, instAddUSize, OfNat.ofNat, instOfNatUSize],[Monad, Array, USize]]
[Lean.Parser.Tactic.tacticLet_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[MonadControl.noConfusionType,[MonadControl, Eq, HEq],[MonadControl]]
[IO.FS.Metadata.accessed,[IO.FS.Metadata],[IO.FS.Metadata, IO.FS.SystemTime]]
[Array.findSomeRevM?.find.proof_1,[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Nat.lt_of_lt_of_le, Nat.succ, Nat.lt_succ_self],[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, LT.lt, instLTNat]]
[Lean.Name.toString.maybePseudoSyntax,[Lean.Name, Bool, Lean.Name.getRoot, String, UInt64, or, String.isPrefixOf, Bool.false],[Lean.Name, Bool]]
[Array.getLit,[Nat, Array, Eq, Array.size, LT.lt, instLTNat, Array.get, Fin.mk, Array.getLit.proof_1],[Nat, Array, Eq, Array.size, LT.lt, instLTNat]]
[IO.rand,[Nat, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, StdGen, ST.Ref.get, IO.RealWorld, instMonadLiftT, ST, IO.instMonadLiftSTRealWorldEIO, instMonadLiftT_1, IO.stdGenRef, Prod, randNat, instRandomGenStdGen, Unit, ST.Ref.set, PUnit, Pure.pure, Applicative.toPure, Monad.toApplicative],[Nat, IO]]
[Inhabited.noConfusionType,[Inhabited, Eq],[Inhabited]]
[cast,[Eq],[Eq]]
[Lean.NameGenerator.next,[Lean.NameGenerator, Lean.NameGenerator.mk, Lean.NameGenerator.namePrefix, HAdd.hAdd, Nat, instHAdd, instAddNat, Lean.NameGenerator.idx, OfNat.ofNat, instOfNatNat],[Lean.NameGenerator]]
[Lean.Macro.Methods.noConfusionType,[Lean.Macro.Methods, Lean.Syntax, Lean.MacroM, Option, Lean.Name, Bool, List, Prod, String, Eq],[Lean.Macro.Methods]]
[Lean.Parser.Tactic.tacticSorry,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Char.isValidCharNat,[Nat, Or, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, And],[Nat]]
[HOrElse.hOrElse,[HOrElse],[HOrElse, Unit]]
[System.FilePath.toString,[System.FilePath],[System.FilePath, String]]
[Lean.isGreek,[Char, and, Decidable.decide, LE.le, UInt32, instLEUInt32, OfNat.ofNat, instOfNatUInt32, Char.val, instDecidableLe],[Char, Bool]]
[Functor.mapConst,[Functor],[Functor]]
[Array.allDiff,[BEq, Array, OfNat.ofNat, Nat, instOfNatNat],[BEq, Array, Bool]]
[Prod.foldI,[Nat, Prod, Nat.foldAux, Prod.snd, HSub.hSub, instHSub, instSubNat, Prod.fst],[Nat, Prod]]
[HEq.elim,[HEq, eq_of_heq],[HEq]]
[UInt64.mul,[UInt64, UInt64.mk, HMul.hMul, Fin, UInt64.size, instHMul, Fin.instMulFin, UInt64.val],[UInt64]]
[Array.eraseIdx',[Array, Fin, Array.size, Array.eraseIdxSzAux, HAdd.hAdd, Nat, instHAdd, instAddNat, Fin.val, OfNat.ofNat, instOfNatNat, Array.eraseIdx'.proof_1],[Array, Fin, Array.size, Subtype, Eq, Nat, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat]]
[Ordering.noConfusion,[Ordering, Eq, noConfusionEnum, Nat, instDecidableEqNat, Ordering.toCtorIdx],[Ordering, Eq, Ordering.noConfusionType]]
[IO.FS.DirEntry.mk.injEq,[System.FilePath, String, Eq.propIntro, Eq, IO.FS.DirEntry, IO.FS.DirEntry.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[System.FilePath, String, Eq, IO.FS.DirEntry, IO.FS.DirEntry.mk, And]]
[Nat.foldRevM.loop,[Monad, Nat, Nat.below, Pure.pure, Applicative.toPure, Monad.toApplicative, Nat.succ, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd],[Monad, Nat]]
[Array.getOp,[Inhabited, Array, Nat, Array.get!],[Inhabited, Array, Nat]]
[System.FilePath.normalize,[System.FilePath, optParam, Bool, System.FilePath.isCaseInsensitive, ite, Eq, and, BEq.beq, Nat, instBEq, instDecidableEqNat, List.length, Char, System.FilePath.pathSeparators, OfNat.ofNat, instOfNatNat, not, Bool.true, instDecidableEqBool, System.FilePath.mk, String.map, List.contains, instDecidableEqChar, System.FilePath.pathSeparator, Char.toLower, System.FilePath.toString],[System.FilePath, optParam, Bool, System.FilePath.isCaseInsensitive]]
[ReaderT.tryFinally,[MonadFinally, Monad, MonadFinally.mk, ReaderT, Option, MonadFinally.tryFinally'],[MonadFinally, Monad, ReaderT]]
[StateT.run_get,[Monad, rfl, Prod, StateT.run, MonadState.get, StateT, instMonadState, instMonadStateOfStateT],[Monad, Eq, Prod, StateT.run, MonadState.get, StateT, instMonadState, instMonadStateOfStateT, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk]]
[Lean.Meta.TransparencyMode.instances.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, Lean.Meta.TransparencyMode, SizeOf.mk, OfNat.ofNat, instOfNatNat, Lean.Meta.TransparencyMode.instances]]
[instToStringUInt64,[ToString.mk, UInt64, ToString.toString, Nat, instToStringNat, UInt64.toNat],[ToString, UInt64]]
[Acc.noConfusionType,[Acc, Eq],[Acc]]
[OfScientific.ofScientific,[OfScientific],[OfScientific, Nat, Bool]]
[List.take,[Nat, List, Nat.below, List.nil, Nat.succ, List.cons, PProd.fst, PUnit, PProd],[Nat, List]]
[Nat.forRevM.loop,[Monad, Nat, Unit, Nat.below, Pure.pure, Applicative.toPure, Monad.toApplicative, Unit.unit, Nat.succ, Bind.bind, Monad.toBind, PUnit, PProd.fst, PProd],[Monad, Nat, Unit]]
[Lean.Parser.Tactic.generalizeArg,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat],[Lean.ParserDescr]]
[IO.Process.Child.stdout,[IO.Process.StdioConfig, IO.Process.Child],[IO.Process.StdioConfig, IO.Process.Child, IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdout]]
[Substring.get,[Substring, String.Pos, Char, String, String.get, HAdd.hAdd, instHAdd, instAddNat],[Substring, String.Pos, Char]]
[boolToSort,[CoeSort.mk, Bool, Eq, Bool.true],[CoeSort, Bool]]
[instDecidableIff.proof_3,[Not, Iff, Iff.mpr],[Not, Iff, False]]
[String.Iterator.setCurr,[String.Iterator, Char, String, String.Pos, String.Iterator.mk, String.set],[String.Iterator, Char]]
[List.mapTRAux_eq,[List, Eq, List.mapTRAux, HAppend.hAppend, instHAppend, List.instAppendList, List.reverse, List.map, of_eq_true, List.nil, Eq.trans, True, congrArg, List.append_nil, eq_self, Eq.mpr, List.cons, Eq.refl, List.reverse_cons, List.append_assoc, rfl],[List, Eq, List.mapTRAux, HAppend.hAppend, instHAppend, List.instAppendList, List.reverse, List.map]]
[Ne.intro,[Eq, False],[Eq, False, Ne]]
[instReprAtomString,[ReprAtom.mk, String],[ReprAtom, String]]
[PSum.inl.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, PSum, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, PSum.inl]]
[ExceptT.pure,[Monad, ExceptT.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, Except, Except.ok],[Monad, ExceptT]]
[tacticFunext__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[UInt64.decEq.proof_1,[Fin, UInt64.size, Eq, UInt64, UInt64.mk, rfl],[Fin, UInt64.size, Eq, UInt64, UInt64.mk]]
[WellFounded.recursion,[WellFounded, Acc, WellFounded.apply],[WellFounded]]
[stx!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[Nat.foldRevM,[Monad, Nat, Nat.foldRevM.loop],[Monad, Nat]]
[Task.noConfusionType,[Task, Eq],[Task]]
[PSum.inr.injEq,[Eq.propIntro, Eq, PSum, PSum.inr, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Eq, PSum, PSum.inr]]
[Quotient.recOnSubsingleton₂.proof_2,[Setoid, Quotient, Subsingleton, Quotient.mk],[Setoid, Quotient, Subsingleton, Quotient.mk]]
[Nat.le.intro,[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, LE.le, instLENat, Nat.le_add_right],[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, LE.le, instLENat]]
[EStateM.Result.ok.inj,[Eq, EStateM.Result, EStateM.Result.ok, And, And.intro],[Eq, EStateM.Result, EStateM.Result.ok, And]]
[Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat, Nat.lt_trans],[Nat, LT.lt, instLTNat]]
[fix,[Inhabited, fixCore1, arbitrary],[Inhabited]]
[IO.FS.instOrdSystemTime,[Ord.mk, IO.FS.SystemTime, Int, UInt32, IO.FS.SystemTime.mk, Ordering, Unit, Ordering.lt, Ordering.gt, Ordering.eq, Unit.unit, Ord.compare, instOrdInt, instOrdUInt32],[Ord, IO.FS.SystemTime]]
[Lean.Macro.Methods.resolveGlobalName,[Lean.Macro.Methods],[Lean.Macro.Methods, Lean.Name, Lean.MacroM, List, Prod, String]]
[Classical.typeDecidable.proof_1,[Not, Nonempty, absurd, False, Nonempty.intro],[Not, Nonempty, False]]
[PSigma.fst,[PSigma],[PSigma]]
[Subarray.foldrM,[Monad, Subarray, Array.foldrM, Subarray.as, Subarray.stop, Subarray.start],[Monad, Subarray]]
[instToStringSubtype,[ToString, ToString.mk, Subtype, ToString.toString, Subtype.val],[ToString, Subtype]]
[Array.back?,[Array, Array.get?, HSub.hSub, Nat, instHSub, instSubNat, Array.size, OfNat.ofNat, instOfNatNat],[Array, Option]]
[Lean.mkIdentFrom,[Lean.Syntax, Lean.Name, Lean.Syntax.ident, Lean.SourceInfo.fromRef, String.toSubstring, ToString.toString, Lean.Name.instToStringName, List.nil, Prod, List, String],[Lean.Syntax, Lean.Name]]
[Std.Format.nest.sizeOf_spec,[Int, Std.Format, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, instSizeOfNat, String, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOf, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone],[Int, Std.Format, Eq, Nat, SizeOf.sizeOf, SizeOf.mk, OfNat.ofNat, instOfNatNat, String, HAdd.hAdd, instHAdd, instAddNat, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone, Std.Format.nest]]
[Lean.Syntax.isLit?,[Lean.SyntaxNodeKind, Lean.Syntax, Option, String, Array, ite, Eq, Bool, and, BEq.beq, Lean.Name.instBEqName, Nat, instBEq, instDecidableEqNat, Array.size, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Array.get!, Lean.instInhabitedSyntax, Lean.SourceInfo, Option.some, Option.none],[Lean.SyntaxNodeKind, Lean.Syntax, Option, String]]
[Lean.mkSepArray,[Array, Lean.Syntax, Nat, OfNat.ofNat, instOfNatNat, List.toArray, List.nil, Bind.bind, Id, Monad.toBind, Id.instMonadId, MProd, ForIn.forIn, Array.instForInArray, MProd.mk, MProd.fst, MProd.snd, PUnit, ForInStep, HAdd.hAdd, instHAdd, instAddNat, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, ForInStep.yield, ite, GT.gt, instLTNat, Nat.decLt, Array.push],[Array, Lean.Syntax]]
[UInt8.val,[UInt8],[UInt8, Fin, UInt8.size]]
[or_self,[propext, Or, Iff.intro, Or.inl],[Eq, Or]]
[Std.termF!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[PointedType.val,[PointedType],[PointedType, PointedType.type]]
[Lean.mkCIdentFromRef,[Monad, Lean.MonadRef, Lean.Name, Bind.bind, Monad.toBind, Lean.Syntax, Lean.MonadRef.getRef, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.mkCIdentFrom],[Monad, Lean.MonadRef, Lean.Name, Lean.Syntax]]
[decide_eq_true,[Decidable, Eq, Bool, Decidable.decide, Bool.true, rfl, Decidable.isTrue, Not, absurd, Decidable.isFalse],[Decidable, Eq, Bool, Decidable.decide, Bool.true]]
[Array.insertionSort,[Array, Bool, Nat, LT.lt, instLTNat, Array.size, OfNat.ofNat, instOfNatNat, Array.insertionSort.traverse, Array.insertionSort.swapLoop],[Array, Bool]]
[String.toNat!,[String, ite, Nat, Eq, Bool, String.isNat, Bool.true, instDecidableEqBool, String.foldl, Char, HAdd.hAdd, instHAdd, instAddNat, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Char.toNat, Char.ofNat, panicWithPosWithDecl, instInhabitedNat],[String, Nat]]
[IO.ofExcept,[ToString, Except, IO, Pure.pure, Applicative.toPure, Monad.toApplicative, instMonadEIO, IO.Error, MonadExcept.throw, instMonadExcept, instMonadExceptOfEIO, IO.userError, ToString.toString],[ToString, Except, IO]]
[Id.bind_eq,[Id, id, rfl, Bind.bind, Monad.toBind, Id.instMonadId],[Id, id, Eq, Bind.bind, Monad.toBind, Id.instMonadId]]
[ExceptCpsT.runCatch_bind_throw,[Monad, ExceptCpsT, rfl, ExceptCpsT.runCatch, Bind.bind, Monad.toBind, ExceptCpsT.instMonadExceptCpsT, MonadExcept.throw, instMonadExcept, ExceptCpsT.instMonadExceptOfExceptCpsT],[Monad, ExceptCpsT, Eq, ExceptCpsT.runCatch, Bind.bind, Monad.toBind, ExceptCpsT.instMonadExceptCpsT, MonadExcept.throw, instMonadExcept, ExceptCpsT.instMonadExceptOfExceptCpsT, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[inferInstance,[],[]]
[instMonadControlReaderT,[MonadControl.mk, ReaderT, id],[MonadControl, ReaderT]]
[Lean.Parser.Tactic.tacticHave_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Except.noConfusionType,[Except, Eq],[Except]]
[Lean.Parser.Tactic.split,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Option.map_id,[funext, Option, Option.map, id, Eq, Unit, rfl, Option.none, Option.some],[Eq, Option, Option.map, id]]
[instSubFloat,[Sub.mk, Float, Float.sub],[Sub, Float]]
[Subtype.instDecidableEqSubtype,[DecidableEq, Subtype, Decidable, Eq, Subtype.mk, dite, Decidable.isTrue, Subtype.instDecidableEqSubtype.proof_1, Not, Decidable.isFalse, Subtype.instDecidableEqSubtype.proof_2],[DecidableEq, Subtype]]
[Fin.shiftRight,[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, HShiftRight.hShiftRight, instHShiftRight, Nat.instShiftRightNat, Fin.shiftRight.proof_1],[Nat, Fin]]
[String.extract,[String, String.Pos, List, Char, ite, GE.ge, instLENat, Nat.decLe, String.mk, List.nil, List.below, namedPattern, List.cons, Eq, instDecidableEqNat, PProd.fst, PUnit, PProd, HAdd.hAdd, Nat, instHAdd, instAddNat, String.csize, OfNat.ofNat, instOfNatNat],[String]]
[RandomGen.next,[RandomGen],[RandomGen, Prod, Nat]]
[instLTFin,[Nat, LT.mk, Fin, LT.lt, instLTNat, Fin.val],[Nat, LT, Fin]]
[Array.filterM,[Monad, Bool, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Array.foldlM, Bind.bind, Monad.toBind, ite, Eq, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.push, List.toArray, List.nil],[Monad, Bool, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size]]
[instDecidableEqBool.proof_1,[Eq, Bool, Bool.false, Bool.true, False],[Eq, Bool, Bool.false, Bool.true, Bool.noConfusionType, False]]
[UInt8.mul,[UInt8, UInt8.mk, HMul.hMul, Fin, UInt8.size, instHMul, Fin.instMulFin, UInt8.val],[UInt8]]
[EStateM.fromStateM,[StateM, Id, Prod, EStateM.Result, StateT.run, EStateM.Result.ok],[StateM, EStateM]]
[Lean.Macro.addMacroScope,[Lean.Name, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, MonadReader.read, instMonadReader, instMonadReaderOfReaderT, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.addMacroScope, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope],[Lean.Name, Lean.MacroM]]
[Int.decEq.proof_4,[Nat, Not, Eq, Int, Int.negSucc, False, absurd],[Nat, Not, Eq, Int, Int.negSucc, False]]
[implies_congr_ctx,[Eq, propext, Iff.intro],[Eq]]
[List.removeAll,[BEq, List, List.filter, List.notElem],[BEq, List]]
[instLENat,[LE.mk, Nat, Nat.le],[LE, Nat]]
[seqRight_eq_bind,[Monad, LawfulMonad, Eq.mpr, Eq, SeqRight.seqRight, Applicative.toSeqRight, Monad.toApplicative, Unit, Bind.bind, Monad.toBind, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const, id, Eq.refl, LawfulApplicative.seqRight_eq, LawfulMonad.toLawfulApplicative, of_eq_true, Eq.trans, True, congrFun, congrArg, Pure.pure, Applicative.toPure, map_eq_pure_bind, seq_eq_bind_map, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, id_eq, bind_pure, eq_self],[Monad, LawfulMonad, Eq, SeqRight.seqRight, Applicative.toSeqRight, Monad.toApplicative, Unit, Bind.bind, Monad.toBind]]
[PSigma.SkipLeft,[PSigma.RevLex, emptyRelation],[PSigma]]
[unexpandExists,[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, cond, Array, Lean.Syntax.getArgs, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[invImage.proof_1,[WellFoundedRelation, InvImage.wf, WellFoundedRelation.rel, WellFoundedRelation.wf],[WellFoundedRelation, WellFounded, InvImage, WellFoundedRelation.rel]]
[Task.Priority.max,[OfNat.ofNat, Task.Priority, instOfNatNat],[Task.Priority]]
[Int.decEq,[Decidable, Eq, Int, Nat, Int.ofNat, decEq, instDecidableEqNat, Decidable.isTrue, Int.decEq.proof_1, Not, Decidable.isFalse, Int.decEq.proof_2, Int.negSucc, Int.decEq.proof_3, Int.decEq.proof_4, Int.decEq.proof_5, Int.decEq.proof_6],[Decidable, Eq, Int]]
[Nat.pos_pow_of_pos,[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, Nat.pow_le_pow_of_le_right, Nat.zero_le],[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HPow.hPow, instHPow, instPowNatNat]]
[Iff.trans,[Iff, Iff.intro, Iff.mp, Iff.mpr],[Iff]]
[Option.some.inj,[Eq, Option, Option.some],[Eq, Option, Option.some]]
[Lean.Meta.instInhabitedTransparencyMode,[Inhabited.mk, Lean.Meta.TransparencyMode, Lean.Meta.TransparencyMode.all],[Inhabited, Lean.Meta.TransparencyMode]]
[StateCpsT.run_eq,[Monad, StateCpsT, rfl, Prod, StateCpsT.run],[Monad, StateCpsT, Eq, Prod, StateCpsT.run, StateCpsT.runK, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk]]
[Ne.irrefl,[Ne, rfl],[Ne, False]]
[noConfusionEnum,[DecidableEq, Eq, dite, noConfusionTypeEnum, cast, noConfusionEnum.proof_1, Not, False.elim, noConfusionEnum.proof_2],[DecidableEq, Eq, noConfusionTypeEnum]]
[Nat.le_of_succ_le_succ,[Nat, Nat.pred_le_pred, Nat.succ],[Nat, LE.le, instLENat, Nat.succ]]
[OrElse.orElse,[OrElse],[OrElse, Unit]]
[Quotient.inductionOn₂,[Setoid, Quotient, Quotient.mk, Quotient.ind],[Setoid, Quotient, Quotient.mk]]
[instDecidableEqSum.proof_5,[Eq, Sum, Sum.inr, Sum.inl, False],[Eq, Sum, Sum.inr, Sum.inl, Sum.noConfusionType, False]]
[IO.Error.mkNoFileOrDirectory,[IO.Error.noFileOrDirectory],[String, UInt32, IO.Error]]
[IO.Error.unsatisfiedConstraints.injEq,[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.unsatisfiedConstraints, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[UInt32, String, Eq, IO.Error, IO.Error.unsatisfiedConstraints, And]]
[IO.FS.Stream.putStrLn,[IO.FS.Stream, String, IO.FS.Stream.putStr, String.push, Char.ofNat],[IO.FS.Stream, String, IO, Unit]]
[Sum.inl.injEq,[Eq.propIntro, Eq, Sum, Sum.inl, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Sum, Sum.inl]]
[Fin.instXorFin,[Nat, Xor.mk, Fin, Fin.xor],[Nat, Xor, Fin]]
[instShiftLeftUInt16,[ShiftLeft.mk, UInt16, UInt16.shiftLeft],[ShiftLeft, UInt16]]
[Lean.Meta.TransparencyMode.reducible.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, Lean.Meta.TransparencyMode, SizeOf.mk, OfNat.ofNat, instOfNatNat, Lean.Meta.TransparencyMode.reducible]]
[iff_false,[propext, Iff, False, Not, Iff.intro, Iff.mp, False.elim],[Eq, Iff, False, Not]]
[Lean.Parser.Tactic.Conv.enterArg,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const],[Lean.ParserDescr]]
[String.takeRightWhile,[String, Char, Bool, Substring.toString, Substring.takeRightWhile, String.toSubstring],[String, Char, Bool]]
[instInhabitedForInStep,[Inhabited, Inhabited.mk, ForInStep, ForInStep.done, arbitrary],[Inhabited, ForInStep]]
[panicWithPos,[Inhabited, String, Nat, panic, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString, instToStringNat],[Inhabited, String, Nat]]
[instDecidableEqBool,[Bool, Decidable, Eq, Unit, Decidable.isTrue, Bool.false, rfl, Decidable.isFalse, Bool.true, instDecidableEqBool.proof_1, instDecidableEqBool.proof_2],[DecidableEq, Bool]]
[unexpandSubtype,[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, cond, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[Array.mapIdxM.map,[Monad, Array, Fin, Array.size, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.below, OfNat.ofNat, instOfNatNat, Pure.pure, Applicative.toPure, Monad.toApplicative, Nat.succ],[Monad, Array, Fin, Array.size, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat]]
[Except.error.injEq,[Eq.propIntro, Eq, Except, Except.error, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Eq, Except, Except.error]]
[Nat.le_of_lt,[Nat, LT.lt, instLTNat, Nat.le_of_succ_le],[Nat, LT.lt, instLTNat, LE.le, instLENat]]
[Lean.Macro.Context.mainModule,[Lean.Macro.Context],[Lean.Macro.Context, Lean.Name]]
[EStateM.seqRight,[EStateM, Unit, EStateM.Result, Unit.unit, EStateM.Result.error],[EStateM, Unit]]
[fix4,[Inhabited, fixCore4, arbitrary],[Inhabited]]
[HAppend.noConfusionType,[outParam, HAppend, Eq],[outParam, HAppend]]
[Substring.takeRight,[Substring, Nat, String, String.Pos, Substring.mk, HAdd.hAdd, instHAdd, instAddNat, Substring.prevn, Substring.bsize],[Substring, Nat]]
[map_congr,[Functor, Eq, of_eq_true, Functor.map, Eq.trans, True, congrFun, congrArg, funext, eq_self],[Functor, Eq, Functor.map]]
[Int.decEq.proof_5,[Nat, Eq, Int, Int.ofNat, Int.negSucc, False],[Nat, Eq, Int, Int.ofNat, Int.negSucc, Int.noConfusionType, False]]
[Nat.repeat,[Nat, Nat.repeat.loop],[Nat]]
[List.append,[List, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd],[List]]
[instDecidableAnd,[Decidable, And, Decidable.isTrue, And.intro, Not, Decidable.isFalse, instDecidableAnd.proof_1, instDecidableAnd.proof_2],[Decidable, And]]
[Int.negSucc.sizeOf_spec,[Nat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat],[Nat, Eq, SizeOf.sizeOf, Int, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, instSizeOfNat, Int.negSucc]]
[USize.decEq.proof_1,[Fin, USize.size, Eq, USize, USize.mk, rfl],[Fin, USize.size, Eq, USize, USize.mk]]
[Array.getIdx?,[BEq, Array, Array.findIdx?, BEq.beq],[BEq, Array, Option, Nat]]
[coeId,[CoeT.mk],[CoeT]]
[String.all,[String, Char, Bool, not, String.any],[String, Char, Bool]]
[Fin.coeToNat,[Nat, Coe.mk, Fin, Fin.val],[Nat, Coe, Fin]]
[PSigma.lex,[PSigma.lex.proof_1],[WellFounded, PSigma, PSigma.Lex]]
[Nat.mul_succ,[Nat, rfl, HMul.hMul, instHMul, instMulNat, Nat.succ],[Nat, Eq, HMul.hMul, instHMul, instMulNat, Nat.succ, HAdd.hAdd, instHAdd, instAddNat]]
[Quotient.liftOn,[Setoid, Quotient, HasEquiv.Equiv, instHasEquiv, Eq, Quot.liftOn, Setoid.r],[Setoid, Quotient, HasEquiv.Equiv, instHasEquiv, Eq]]
[ToBool.noConfusionType,[ToBool, Bool, Eq],[ToBool]]
[Std.Format.MonadPrettyFormat.pushNewline,[Std.Format.MonadPrettyFormat],[Std.Format.MonadPrettyFormat, Nat, Unit]]
[EStateM.instMonadExceptOfEStateM,[outParam, EStateM.Backtrackable, MonadExceptOf.mk, EStateM, EStateM.throw, EStateM.tryCatch],[outParam, EStateM.Backtrackable, MonadExceptOf, EStateM]]
[Nat.le.dest,[Nat, LE.le, instLENat, Exists, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.below, Nat.zero, Exists.intro, OfNat.ofNat, instOfNatNat, rfl, Nat.succ, Eq.symm, Nat.add_comm, absurd, Nat.not_succ_le_zero],[Nat, LE.le, instLENat, Exists, Eq, HAdd.hAdd, instHAdd, instAddNat]]
[Array.findSomeRev?,[Array, Option, Id.run, Array.findSomeRevM?, Id, Id.instMonadId],[Array, Option]]
[Alternative.orElse,[Alternative],[Alternative, Unit]]
[Ordering.noConfusionType,[Ordering, noConfusionTypeEnum, Nat, instDecidableEqNat, Ordering.toCtorIdx],[Ordering]]
[dbgSleep,[UInt32, Unit, Unit.unit],[UInt32, Unit]]
[List.foldrM,[Monad, List, List.below, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, List.cons, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd],[Monad, List]]
[instHSub,[Sub, HSub.mk, Sub.sub],[Sub, HSub]]
[Lean.maxRecDepthErrorMessage,[],[String]]
[DoResultPR.pure.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, DoResultPR, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, DoResultPR.pure]]
[String.toNat?,[String, ite, Option, Nat, Eq, Bool, String.isNat, Bool.true, instDecidableEqBool, Option.some, String.foldl, Char, HAdd.hAdd, instHAdd, instAddNat, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Char.toNat, Char.ofNat, Option.none],[String, Option, Nat]]
[Lean.MacroM,[ReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State],[]]
[Nat.mul_le_mul,[Nat, LE.le, instLENat, Nat.le_trans, HMul.hMul, instHMul, instMulNat, Nat.mul_le_mul_right, Nat.mul_le_mul_left],[Nat, LE.le, instLENat, HMul.hMul, instHMul, instMulNat]]
[StateCpsT.runK_set,[PUnit, rfl, StateCpsT.runK, MonadStateOf.set, StateCpsT, StateCpsT.instMonadStateOfStateCpsT],[PUnit, Eq, StateCpsT.runK, MonadStateOf.set, StateCpsT, StateCpsT.instMonadStateOfStateCpsT, PUnit.unit]]
[Lean.Parser.Tactic.Conv.nestedTacticCore,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[instMonadWithReaderOf,[MonadFunctor, MonadWithReaderOf, MonadWithReaderOf.mk, MonadFunctorT.monadMap, instMonadFunctorT, monadFunctorRefl, withTheReader],[MonadFunctor, MonadWithReaderOf]]
[UInt8.decLe,[UInt8, Decidable, LE.le, instLEUInt8, Fin, UInt8.size, inferInstanceAs, instLEFin, Fin.decLe],[UInt8, Decidable, LE.le, instLEUInt8]]
[Lean.Syntax.isToken,[String, Lean.Syntax, Bool, Lean.SourceInfo, BEq.beq, instBEq, instDecidableEqString, String.trim, Bool.false],[String, Lean.Syntax, Bool]]
[instRandomGenStdGen,[RandomGen.mk, StdGen, stdRange, stdNext, stdSplit],[RandomGen, StdGen]]
[Nat.lt.base,[Nat.lt.base.proof_1],[Nat, LT.lt, instLTNat, Nat.succ]]
[instModUSize,[Mod.mk, USize, USize.mod],[Mod, USize]]
[HEq.rfl.proof_1,[HEq.refl],[HEq]]
[false_or,[propext, Or, False, Iff.intro, False.elim, Or.inr],[Eq, Or, False]]
[Nat.zero_le,[Nat, LE.le, instLENat, OfNat.ofNat, instOfNatNat, Nat.below, Unit, Nat.zero, Nat.le.refl, Nat.succ, Nat.le.step, PProd.fst, PUnit, PProd],[Nat, LE.le, instLENat, OfNat.ofNat, instOfNatNat]]
[instDecidableLe_1,[UInt8, UInt8.decLe],[UInt8, Decidable, LE.le, instLEUInt8]]
[Int.ofNat.sizeOf_spec,[Nat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat],[Nat, Eq, SizeOf.sizeOf, Int, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, instSizeOfNat, Int.ofNat]]
[decEq,[DecidableEq],[DecidableEq, Decidable, Eq]]
[LawfulApplicative.toLawfulFunctor,[Applicative, LawfulApplicative],[Applicative, LawfulApplicative, LawfulFunctor, Applicative.toFunctor]]
[EStateM.tryCatch,[outParam, EStateM.Backtrackable, EStateM, EStateM.Backtrackable.save, EStateM.Result, EStateM.Backtrackable.restore],[outParam, EStateM.Backtrackable, EStateM]]
[Array.instAppendArray,[Append.mk, Array, Array.append],[Append, Array]]
[not_not_intro,[Not],[Not]]
[unexpandListCons,[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Syntax.SepArray, Lean.Syntax.SepArray.mk, Lean.Syntax.getArgs, Array.append, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[StateT,[Prod],[]]
[Array.indexOf?,[BEq, Array, Array.indexOfAux, OfNat.ofNat, Nat, instOfNatNat],[BEq, Array, Option, Fin, Array.size]]
[String.isEmpty,[String, BEq.beq, Nat, instBEq, instDecidableEqNat, String.bsize, OfNat.ofNat, instOfNatNat],[String, Bool]]
[List.mapTRAux,[List, List.below, List.nil, List.reverse, List.cons, PProd.fst, PUnit, PProd],[List]]
[Classical.decidableInhabited,[Inhabited.mk, Decidable, inferInstance, Classical.propDecidable],[Inhabited, Decidable]]
[Lean.Meta.TransparencyMode.toCtorIdx,[Lean.Meta.TransparencyMode, Nat, OfNat.ofNat, instOfNatNat],[Lean.Meta.TransparencyMode, Nat]]
[instNonempty.proof_1,[Inhabited, Nonempty.intro, arbitrary],[Inhabited, Nonempty]]
[UInt16.modn,[UInt16, UInt16.mk, HMod.hMod, Fin, UInt16.size, Nat, Fin.instHModFinNatFin, UInt16.val],[UInt16]]
[IO.FS.Stream.getLine,[IO.FS.Stream],[IO.FS.Stream, IO, String]]
[Fin.ne_of_val_ne,[Nat, Fin, Not, Eq, Fin.val, absurd, False, Fin.val_eq_of_eq],[Nat, Fin, Not, Eq, Fin.val]]
[IO.FS.FileType.noConfusion,[IO.FS.FileType, Eq, noConfusionEnum, Nat, instDecidableEqNat, IO.FS.FileType.toCtorIdx],[IO.FS.FileType, Eq, IO.FS.FileType.noConfusionType]]
[coeSort,[CoeSort, CoeSort.coe],[CoeSort]]
[List.toStringAux,[ToString, Bool, List, String, List.below, List.nil, List.cons, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString, PProd.fst, PUnit, PProd, Bool.false],[ToString, Bool, List, String]]
[instHAdd,[Add, HAdd.mk, Add.add],[Add, HAdd]]
[Applicative.toFunctor,[Applicative],[Applicative, Functor]]
[inferInstanceAs,[],[]]
[Lean.Parser.Tactic.casesTarget,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat],[Lean.ParserDescr]]
[Lean.Parser.Tactic.delta,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[Lean.NameGenerator.mkChild,[Lean.NameGenerator, Prod.mk, Lean.NameGenerator.mk, Lean.Name.mkNum, Lean.NameGenerator.namePrefix, Lean.NameGenerator.idx, OfNat.ofNat, Nat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat],[Lean.NameGenerator, Prod]]
[Lean.MonadQuotation.noConfusionType,[Lean.MonadQuotation, Lean.MonadRef, Lean.MacroScope, Lean.Name, Eq],[Lean.MonadQuotation]]
[LT.lt,[LT],[LT]]
[RandomGen.noConfusionType,[RandomGen, Prod, Nat, Eq],[RandomGen]]
[Substring.mk.sizeOf_spec,[String, String.Pos, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[String, String.Pos, Eq, Nat, SizeOf.sizeOf, Substring, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, Substring.mk]]
[ExceptCpsT,[],[]]
[Substring.take,[Substring, Nat, String, String.Pos, Substring.mk, HAdd.hAdd, instHAdd, instAddNat, Substring.nextn, OfNat.ofNat, instOfNatNat],[Substring, Nat]]
[«term_<|_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[instOrElseEIO,[OrElse.mk, EIO, MonadExcept.orElse, instMonadExcept, instMonadExceptOfEIO],[OrElse, EIO]]
[Nat.foldM.loop,[Monad, Nat, Nat.below, Pure.pure, Applicative.toPure, Monad.toApplicative, Nat.succ, Bind.bind, Monad.toBind, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, PProd.fst, PUnit, PProd],[Monad, Nat]]
[StateT.instMonadExceptOfStateT,[Monad, MonadExceptOf, MonadExceptOf.mk, StateT, Function.comp, StateT.lift, throwThe, tryCatchThe, Prod],[Monad, MonadExceptOf, StateT]]
[let_congr,[Eq],[Eq]]
[Lean.isIdEndEscape,[Char, Decidable.decide, Eq, Lean.idEndEscape, instDecidableEqChar],[Char, Bool]]
[rawNatLit,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const],[Lean.ParserDescr]]
[Array.findRev?,[Array, Bool, Id.run, Option, Array.findRevM?, Id, Id.instMonadId],[Array, Bool, Option]]
[instToStringDecidable,[ToString.mk, Decidable, String, Not],[ToString, Decidable]]
[Substring.next,[Substring, String.Pos, String, HAdd.hAdd, instHAdd, instAddNat, ite, Eq, instDecidableEqNat, HSub.hSub, instHSub, instSubNat, String.next],[Substring, String.Pos]]
[ByteArray.copySlice,[Nat, ByteArray, optParam, Bool, Bool.true, ByteArray.mk, HAppend.hAppend, Array, UInt8, instHAppend, Array.instAppendArray, Array.extract, ByteArray.data, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Array.size],[Nat, ByteArray, optParam, Bool, Bool.true]]
[Std.Format.groupEx,[Std.Format, Std.Format.group, Std.Format.FlattenBehavior.allOrNone],[Std.Format]]
[Id.instLawfulMonadId,[Id.instLawfulMonadId.proof_1],[LawfulMonad, Id, Id.instMonadId]]
[instInhabitedPUnit,[Inhabited.mk, PUnit, PUnit.unit],[Inhabited, PUnit]]
[UInt64.shiftLeft,[UInt64, UInt64.mk, HShiftLeft.hShiftLeft, Fin, UInt64.size, instHShiftLeft, Fin.instShiftLeftFin, UInt64.val, UInt64.modn, OfNat.ofNat, Nat, instOfNatNat],[UInt64]]
[UInt8.decLt,[UInt8, Decidable, LT.lt, instLTUInt8, Fin, UInt8.size, inferInstanceAs, instLTFin, Fin.decLt],[UInt8, Decidable, LT.lt, instLTUInt8]]
[ToBool.toBool,[ToBool],[ToBool, Bool]]
[StateT.run',[Functor, StateT, Functor.map, Prod, Prod.fst],[Functor, StateT]]
[Nat.mod_self,[Nat, Eq.mpr, Eq, HMod.hMod, instHMod, Nat.instModNat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Eq.refl, Nat.mod_eq_sub_mod, Nat.le_refl, Nat.sub_self, Nat.zero_mod, rfl],[Nat, Eq, HMod.hMod, instHMod, Nat.instModNat, OfNat.ofNat, instOfNatNat]]
[Lean.Parser.Tactic.Conv.convDone,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[Lean.Macro.State.macroScope,[Lean.Macro.State],[Lean.Macro.State, Lean.MacroScope]]
[ExceptT.run_throw,[Monad, rfl, Except, ExceptT.run, MonadExcept.throw, ExceptT, instMonadExcept, instMonadExceptOfExceptT_1],[Monad, Eq, Except, ExceptT.run, MonadExcept.throw, ExceptT, instMonadExcept, instMonadExceptOfExceptT_1, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.error]]
[Int.lt,[Int, LE.le, Int.instLEInt, HAdd.hAdd, instHAdd, Int.instAddInt, OfNat.ofNat, hasOfNatOfCoe, Nat, instCoeNatInt, instOfNatNat],[Int]]
[Lean.Parser.Tactic.Conv.paren,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.Conv.convSeq, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[And.right,[And],[And]]
[Std.Format.MonadPrettyFormat.startTag,[Std.Format.MonadPrettyFormat],[Std.Format.MonadPrettyFormat, Nat, Unit]]
[Id.map_eq,[Id, rfl, Functor.map, Applicative.toFunctor, Monad.toApplicative, Id.instMonadId],[Id, Eq, Functor.map, Applicative.toFunctor, Monad.toApplicative, Id.instMonadId]]
[Lean.Syntax.missing.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, Lean.Syntax, SizeOf.mk, Array, List, OfNat.ofNat, instOfNatNat, Lean.SyntaxNodeKind, HAdd.hAdd, instHAdd, instAddNat, instSizeOfName, Lean.SourceInfo, String, instSizeOf, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, Substring, Lean.Name, Prod, String.Pos, Lean.Syntax.missing]]
[List.length_dropLast,[List, Eq, Nat, List.length, List.dropLast, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, List.below, Unit, List.nil, rfl, List.cons],[List, Eq, Nat, List.length, List.dropLast, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat]]
[Lean.Meta.Simp.Config.mk.sizeOf_spec,[Nat, Bool, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat, SizeOf.mk],[Nat, Bool, Eq, SizeOf.sizeOf, Lean.Meta.Simp.Config, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, instSizeOfNat, Lean.Meta.Simp.Config.mk]]
[IO.Error.toString,[IO.Error, String, Unit, UInt32, IO.Error.fopenErrorToString, Option.some, IO.Error.otherErrorToString, Option.none],[IO.Error, String]]
[Quotient.recOnSubsingleton,[Setoid, Quotient, Subsingleton, Quotient.mk, Quot.recOnSubsingleton, Setoid.r],[Setoid, Quotient, Subsingleton, Quotient.mk]]
[System.SearchPath.parse,[String, List.map, System.FilePath, System.FilePath.mk, String.split, Char, BEq.beq, instBEq, instDecidableEqChar, System.SearchPath.separator],[String, System.SearchPath]]
[StateT.run_pure,[Monad, rfl, Prod, StateT.run, Pure.pure, StateT, Applicative.toPure, Monad.toApplicative, StateT.instMonadStateT],[Monad, Eq, Prod, StateT.run, Pure.pure, StateT, Applicative.toPure, Monad.toApplicative, StateT.instMonadStateT, Prod.mk]]
[IO.FS.FileType.noConfusionType,[IO.FS.FileType, noConfusionTypeEnum, Nat, instDecidableEqNat, IO.FS.FileType.toCtorIdx],[IO.FS.FileType]]
[IO.Process.StdioConfig.mk.sizeOf_spec,[IO.Process.Stdio, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk],[IO.Process.Stdio, Eq, Nat, SizeOf.sizeOf, IO.Process.StdioConfig, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, IO.Process.StdioConfig.mk]]
[Std.Format.FlattenBehavior.noConfusion,[Std.Format.FlattenBehavior, Eq, noConfusionEnum, Nat, instDecidableEqNat, Std.Format.FlattenBehavior.toCtorIdx],[Std.Format.FlattenBehavior, Eq, Std.Format.FlattenBehavior.noConfusionType]]
[Array.size_mkArray,[Nat, List.length_replicate],[Nat, Eq, Array.size, Array.mkArray]]
[Array.back,[Inhabited, Array, Array.get!, HSub.hSub, Nat, instHSub, instSubNat, Array.size, OfNat.ofNat, instOfNatNat],[Inhabited, Array]]
[UInt16.ofNat,[UInt16.mk, Fin.ofNat, OfNat.ofNat, Nat, instOfNatNat],[UInt16]]
[UInt64.le,[UInt64, LE.le, Fin, UInt64.size, instLEFin, UInt64.val],[UInt64]]
[IO.Process.SpawnArgs.args,[IO.Process.SpawnArgs],[IO.Process.SpawnArgs, Array, String]]
[IO.FS.Metadata.mk.injEq,[IO.FS.SystemTime, UInt64, IO.FS.FileType, Eq.propIntro, Eq, IO.FS.Metadata, IO.FS.Metadata.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[IO.FS.SystemTime, UInt64, IO.FS.FileType, Eq, IO.FS.Metadata, IO.FS.Metadata.mk, And]]
[IO.FS.FileType.other.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, IO.FS.FileType, SizeOf.mk, OfNat.ofNat, instOfNatNat, IO.FS.FileType.other]]
[Add.add,[Add],[Add]]
[HOrElse.noConfusionType,[outParam, HOrElse, Unit, Eq],[outParam, HOrElse]]
[StateT.lift,[Monad, Bind.bind, Monad.toBind, Prod, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk],[Monad, StateT]]
[Nat.zero_mod,[Nat, Eq.mpr, Eq, HMod.hMod, instHMod, Nat.instModNat, OfNat.ofNat, instOfNatNat, ite, And, LT.lt, instLTNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HSub.hSub, instHSub, instSubNat, Eq.refl, Nat.mod_eq],[Nat, Eq, HMod.hMod, instHMod, Nat.instModNat, OfNat.ofNat, instOfNatNat]]
[Lean.Syntax.decodeNameLit,[String, ite, Option, Lean.Name, Eq, Bool, BEq.beq, Char, instBEq, instDecidableEqChar, String.get, OfNat.ofNat, String.Pos, instOfNatNat, Char.ofNat, Bool.true, instDecidableEqBool, List, Substring, Substring.drop, String.toSubstring, Nat, List.nil, Unit, Option.none, Option.some, List.foldr, Substring.toString, Lean.isIdBeginEscape, String.front, Lean.Name.mkStr, String.dropRight, String.drop, Lean.Name.anonymous],[String, Option, Lean.Name]]
[System.FilePath.withExtension,[System.FilePath, String, Option, System.FilePath.fileStem, Unit, System.FilePath.withFileName, ite, Eq, Bool, String.isEmpty, Bool.true, instDecidableEqBool, HAppend.hAppend, instHAppend, String.instAppendString],[System.FilePath, String]]
[Classical.epsilon_singleton,[Classical.epsilon_spec, Eq, Exists.intro, rfl],[Eq, Classical.epsilon, Nonempty.intro]]
[PProd.mk.injEq,[Eq.propIntro, Eq, PProd, PProd.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Eq, PProd, PProd.mk, And]]
[MonadExcept.throw,[MonadExcept],[MonadExcept]]
[UInt8.lor,[UInt8, UInt8.mk, Fin.lor, UInt8.size, UInt8.val],[UInt8]]
[Subarray.all,[Bool, Subarray, Id.run, Subarray.allM, Id, Id.instMonadId],[Bool, Subarray]]
[List.eraseDupsAux,[BEq, List, List.below, List.nil, List.reverse, List.cons, Bool, List.elem, Unit, PProd.fst, PUnit, PProd],[BEq, List]]
[Nat.mul_assoc,[Nat, Eq, HMul.hMul, instHMul, instMulNat, Nat.below, rfl, OfNat.ofNat, instOfNatNat, Nat.succ],[Nat, Eq, HMul.hMul, instHMul, instMulNat]]
[ST.Ref.ref,[ST.Ref],[ST.Ref, PointedType.type, ST.RefPointed]]
[eq_self,[propext, Eq, True, Iff.intro, trivial, rfl],[Eq, True]]
[UInt16.size,[OfNat.ofNat, Nat, instOfNatNat],[Nat]]
[Thunk.map,[Thunk, Thunk.mk, Unit, Thunk.get],[Thunk]]
[Nat.not_lt_zero,[Nat, Nat.not_succ_le_zero],[Nat, Not, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat]]
[Std.instToFormatString,[Std.ToFormat.mk, String, Std.Format.text],[Std.ToFormat, String]]
[Lean.Syntax.isCharLit?,[Lean.Syntax, Option, String, Option.some, Option.none, Char, Lean.Syntax.isLit?, Lean.charLitKind, Lean.Syntax.decodeCharLit],[Lean.Syntax, Option, Char]]
[Neg.neg,[Neg],[Neg]]
[Sum.inhabitedLeft,[Inhabited, Inhabited.mk, Sum, Sum.inl, arbitrary],[Inhabited, Sum]]
[PSigma.lexAccessible.proof_1,[Acc, WellFounded, PSigma, PSigma.Lex, PSigma.mk, Acc.intro, Eq, HEq, PSigma.Lex.left, Eq.symm, eq_of_heq, PSigma.Lex.right, Eq.refl, HEq.refl, WellFounded.apply],[Acc, WellFounded, PSigma, PSigma.Lex, PSigma.mk]]
[Array.mapIdxM.map.proof_2,[Array, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Eq.mpr, Eq.refl, Eq.symm, Nat.add_comm, Nat.add_assoc, rfl],[Array, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size]]
[OrOp.noConfusionType,[OrOp, Eq],[OrOp]]
[Nat.add_le_add,[Nat, LE.le, instLENat, Nat.le_trans, HAdd.hAdd, instHAdd, instAddNat, Nat.add_le_add_right, Nat.add_le_add_left],[Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat]]
[HEq.symm,[HEq, HEq.ndrecOn, HEq.refl],[HEq]]
[List.filterMapM.loop,[Monad, Option, List, List.below, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, List.cons, Bind.bind, Monad.toBind, Unit, PProd.fst, PUnit, PProd],[Monad, Option, List]]
[ex_of_PSigma,[PSigma, Exists, Exists.intro],[PSigma, Exists]]
[instToStringInt,[ToString.mk, Int, String, Nat, ToString.toString, instToStringNat, HAppend.hAppend, instHAppend, String.instAppendString, Nat.succ],[ToString, Int]]
[coeBase,[Coe, CoeTC.mk, coeB],[Coe, CoeTC]]
[List.instBEqList,[BEq, BEq.mk, List, List.beq],[BEq, List]]
[Nat.ble,[Nat, Bool, Nat.below, Unit, Nat.zero, Bool.true, Nat.succ, Bool.false, PProd.fst, PUnit, PProd],[Bool]]
[instLTProd,[LT, LT.mk, Prod, Or, LT.lt, Prod.fst, And, Eq, Prod.snd],[LT, Prod]]
[UInt8.shiftLeft,[UInt8, UInt8.mk, HShiftLeft.hShiftLeft, Fin, UInt8.size, instHShiftLeft, Fin.instShiftLeftFin, UInt8.val, UInt8.modn, OfNat.ofNat, Nat, instOfNatNat],[UInt8]]
[Lean.instMonadRef,[MonadLift, MonadFunctor, Lean.MonadRef, Lean.MonadRef.mk, liftM, instMonadLiftT, instMonadLiftT_1, Lean.Syntax, Lean.MonadRef.getRef, MonadFunctorT.monadMap, instMonadFunctorT, monadFunctorRefl, Lean.MonadRef.withRef],[MonadLift, MonadFunctor, Lean.MonadRef]]
[instDecidableAnd.proof_1,[Not, And, And.right],[Not, And, False]]
[instOrOpUInt32,[OrOp.mk, UInt32, UInt32.lor],[OrOp, UInt32]]
[Array.findIdxM?,[Monad, Array, Bool, Nat, OfNat.ofNat, instOfNatNat, Bind.bind, Monad.toBind, MProd, Option, ForIn.forIn, Array.instForInArray, MProd.mk, Option.none, MProd.snd, ForInStep, PUnit, HAdd.hAdd, instHAdd, instAddNat, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, ForInStep.yield, ite, Eq, Bool.true, instDecidableEqBool, ForInStep.done, Option.some, MProd.fst, Unit],[Monad, Array, Bool, Option, Nat]]
[instToFormat,[ToString, Std.ToFormat.mk, Function.comp, String, Std.Format, Std.Format.text, ToString.toString],[ToString, Std.ToFormat]]
[instAndOpUInt16,[AndOp.mk, UInt16, UInt16.land],[AndOp, UInt16]]
[IO.Ref,[ST.Ref, IO.RealWorld],[]]
[String.Iterator.toString,[String.Iterator, String, String.Pos],[String.Iterator, String]]
[Int.decEq.proof_2,[Nat, Not, Eq, Int, Int.ofNat, False, absurd],[Nat, Not, Eq, Int, Int.ofNat, False]]
[IO.FS.Stream.Buffer.mk.inj,[ByteArray, Nat, Eq, IO.FS.Stream.Buffer, IO.FS.Stream.Buffer.mk, And, And.intro],[ByteArray, Nat, Eq, IO.FS.Stream.Buffer, IO.FS.Stream.Buffer.mk, And]]
[Nat.mul_left_comm,[Nat, Eq.mpr, Eq, HMul.hMul, instHMul, instMulNat, Eq.refl, Eq.symm, Nat.mul_assoc, Nat.mul_comm, rfl],[Nat, Eq, HMul.hMul, instHMul, instMulNat]]
[Iff.comm,[Iff.intro, Iff, Iff.symm],[Iff]]
[Fin.mk.injEq,[Nat, LT.lt, instLTNat, Eq.propIntro, Eq, Fin, Fin.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Nat, LT.lt, instLTNat, Eq, Fin, Fin.mk]]
[Subarray.toArray,[Subarray, Array.ofSubarray],[Subarray, Array]]
[OptionT.instMonadExceptOfOptionT,[Monad, MonadExceptOf, MonadExceptOf.mk, OptionT, OptionT.mk, throwThe, Option, tryCatchThe],[Monad, MonadExceptOf, OptionT]]
[Lean.Parser.Tactic.Conv.convArgs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[IO.Error.resourceExhausted.injEq,[Option, String, UInt32, Eq.propIntro, Eq, IO.Error, IO.Error.resourceExhausted, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl],[Option, String, UInt32, Eq, IO.Error, IO.Error.resourceExhausted, And]]
[Quot.hrecOn,[Quot, Quot.mk, HEq, Quot.recOn, Quot.hrecOn.proof_1],[Quot, Quot.mk, HEq]]
[instReprProd,[Repr, ReprTuple, Repr.mk, Prod, Nat, Std.Format, Std.Format.bracket, Std.Format.joinSep, Std.instToFormatFormat, List.reverse, ReprTuple.reprTuple, List.cons, repr, List.nil, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, Std.Format.line],[Repr, ReprTuple, Prod]]
[Lean.Syntax.splitNameLit,[Substring, List.reverse, List.nil],[Substring, List]]
[control,[MonadControlT, Bind, MonadControlT.stM, controlAt],[MonadControlT, Bind, MonadControlT.stM]]
[Lean.Syntax.instCoeArraySyntaxSepArray,[String, Coe.mk, Array, Lean.Syntax, Lean.Syntax.SepArray, Lean.Syntax.SepArray.ofElems],[String, Coe, Array, Lean.Syntax, Lean.Syntax.SepArray]]
[eq_false_of_ne_true,[Bool, Not, Eq, Bool.true, Bool.false, False.elim, rfl],[Bool, Not, Eq, Bool.true, Bool.false]]
[«term_>>>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[IO.FS.DirEntry.root,[IO.FS.DirEntry],[IO.FS.DirEntry, System.FilePath]]
[instDecidableDite,[Not, Decidable, dite],[Not, Decidable, dite]]
[Lean.Name.getRoot,[Lean.Name, Lean.Name.below, Unit, Lean.Name.anonymous, String, UInt64, namedPattern, Lean.Name.str, Nat, Lean.Name.num, PProd.fst, PUnit, PProd],[Lean.Name]]
[Lean.extractMacroScopes,[Lean.Name, Bool, Lean.MacroScopesView, Lean.Name.hasMacroScopes, Unit, List, Lean.MacroScope, Lean.Name.below, Nat, UInt64, Lean.Name.num, String, Lean.Name.str, Lean.Name.anonymous, PProd.fst, PUnit, PProd, List.cons, namedPattern, BEq.beq, instBEq, instDecidableEqString, Lean.MacroScopesView.mk, List.below, List.nil, Lean.Name.mkStr, Lean.Name.mkNum, panic, Lean.instInhabitedName, Lean.instInhabitedMacroScopesView],[Lean.Name, Lean.MacroScopesView]]
[Substring.nextn,[Substring, Nat, String.Pos, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, Substring.next],[Substring, Nat, String.Pos]]
[ExceptT.instMonadLiftExceptT,[Monad, MonadLift.mk, ExceptT, ExceptT.lift],[Monad, MonadLift, ExceptT]]
[Prod.lt_def,[LT, Prod, rfl, LT.lt, instLTProd],[LT, Prod, Eq, LT.lt, instLTProd, Or, Prod.fst, And, Prod.snd]]
[Lean.Meta.Simp.ConfigCtx.mk.inj,[Lean.Meta.Simp.Config, Eq, Lean.Meta.Simp.ConfigCtx, Lean.Meta.Simp.ConfigCtx.mk],[Lean.Meta.Simp.Config, Eq, Lean.Meta.Simp.ConfigCtx, Lean.Meta.Simp.ConfigCtx.mk]]
[instMonadControlExceptT,[Monad, MonadControl.mk, ExceptT, Except, liftM, instMonadLiftT, ExceptT.instMonadLiftExceptT, instMonadLiftT_1, ExceptT.run],[Monad, MonadControl, ExceptT]]
[Fin.lor,[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, Nat.lor, Fin.lor.proof_1],[Nat, Fin]]
[List.getLast.proof_1,[rfl, List, List.nil],[Eq, List, List.nil]]
[getModify,[MonadState, Monad, MonadState.modifyGet, Prod.mk],[MonadState, Monad]]
[Lean.Parser.Tactic.injections,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[StateT.failure,[Alternative, Alternative.failure, Prod],[Alternative, StateT]]
[Fin.div,[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, HDiv.hDiv, instHDiv, Nat.instDivNat, Fin.div.proof_1],[Nat, Fin]]
[UInt32.land,[UInt32, UInt32.mk, Fin.land, UInt32.size, UInt32.val],[UInt32]]
[ByteArray.toUInt64BE!,[ByteArray, ite, UInt64, Eq, Bool, BEq.beq, Nat, instBEq, instDecidableEqNat, ByteArray.size, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, HOr.hOr, instHOr, instOrOpUInt64, HShiftLeft.hShiftLeft, instHShiftLeft, instShiftLeftUInt64, UInt8.toUInt64, ByteArray.get!, instOfNatUInt64, panicWithPosWithDecl, instInhabitedUInt64, HAppend.hAppend, String, instHAppend, String.instAppendString],[ByteArray, UInt64]]
[UInt32.ofNat,[UInt32.mk, Fin.ofNat, OfNat.ofNat, Nat, instOfNatNat],[UInt32]]
[Char.instDecidableLt,[Char, UInt32.decLt, Char.val],[Char, Decidable, LT.lt, Char.instLTChar]]
[Nat.sub_le,[Nat, LE.le, instLENat, HSub.hSub, instHSub, instSubNat, Nat.le_refl, OfNat.ofNat, instOfNatNat, Nat.le_trans, Nat.pred, Nat.pred_le],[Nat, LE.le, instLENat, HSub.hSub, instHSub, instSubNat]]
[ReaderT.instAlternativeReaderT,[Alternative, Monad, Alternative.mk, ReaderT, Monad.toApplicative, ReaderT.instMonadReaderT, ReaderT.failure, ReaderT.orElse],[Alternative, Monad, ReaderT]]
[Lean.Meta.Simp.Config.maxDischargeDepth,[Lean.Meta.Simp.Config],[Lean.Meta.Simp.Config, Nat]]
[BEq.noConfusionType,[BEq, Bool, Eq],[BEq]]
[min,[LE, DecidableRel, LE.le, ite],[LE, DecidableRel, LE.le]]
[false_iff,[propext, Iff, False, Not, Iff.intro, Iff.mpr, False.elim],[Eq, Iff, False, Not]]
[instOrdChar,[Ord.mk, Char, compareOfLessAndEq, Char.instLTChar, Char.instDecidableLt, instDecidableEqChar],[Ord, Char]]
[Lean.Meta.instBEqTransparencyMode,[BEq.mk, Lean.Meta.TransparencyMode, BEq.beq, Nat, instBEq, instDecidableEqNat, Lean.Meta.TransparencyMode.toCtorIdx],[BEq, Lean.Meta.TransparencyMode]]
[Float.mk.inj,[FloatSpec.float, floatSpec, Eq, Float, Float.mk],[FloatSpec.float, floatSpec, Eq, Float, Float.mk]]
[Hashable.noConfusionType,[Hashable, UInt64, Eq],[Hashable]]
[Ordering.lt.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat],[Eq, Nat, SizeOf.sizeOf, Ordering, SizeOf.mk, OfNat.ofNat, instOfNatNat, Ordering.lt]]
[repr,[Repr, Repr.reprPrec, OfNat.ofNat, Nat, instOfNatNat],[Repr, Std.Format]]
[UInt32.xor,[UInt32, UInt32.mk, Fin.xor, UInt32.size, UInt32.val],[UInt32]]
[instReprOption,[Repr, Repr.mk, Option, Nat, Std.Format, Std.Format.text, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, reprArg],[Repr, Option]]
[System.Platform.getNumBits.proof_1,[Or.inr, Eq, Nat, OfNat.ofNat, instOfNatNat, rfl],[Or, Eq, Nat, OfNat.ofNat, instOfNatNat]]
[Function.const,[],[]]
[List.hasDecidableLt.proof_4,[LT, List, Not, LT.lt, List.instLTList, List.cons, False, absurd, List.lt],[LT, List, Not, LT.lt, List.instLTList, List.cons, False]]
[Int.instSubInt,[Sub.mk, Int, Int.sub],[Sub, Int]]
[eqRec_heq,[Eq, HEq, HEq.refl],[Eq, HEq]]
[instMonadExceptOfExceptT_1,[Monad, MonadExceptOf.mk, ExceptT, ExceptT.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, Except, Except.error, ExceptT.tryCatch],[Monad, MonadExceptOf, ExceptT]]
[Option.isNone,[Option, Bool, Bool.false, Unit, Bool.true],[Option, Bool]]
[Array.instToStringArray,[ToString, ToString.mk, Array, HAppend.hAppend, String, instHAppend, String.instAppendString, ToString.toString, List, instToStringList, Array.toList],[ToString, Array]]
[SeqRight.noConfusionType,[SeqRight, Unit, Eq],[SeqRight]]
[coeDecidableEq,[Bool, inferInstanceAs, Decidable, Eq, Bool.true, instDecidableEqBool],[Bool, Decidable, coe, coeOfHTCT, coeOfTC, coeBase, boolToProp]]
[Lean.NameGenerator.mk.sizeOf_spec,[Lean.Name, Nat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfName, instSizeOfNat],[Lean.Name, Nat, Eq, SizeOf.sizeOf, Lean.NameGenerator, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, instSizeOfName, instSizeOfNat, Lean.NameGenerator.mk]]
[Lean.Syntax.mkScientificLit,[String, optParam, Lean.SourceInfo, Lean.SourceInfo.none, Lean.Syntax.mkLit, Lean.scientificLitKind],[String, optParam, Lean.SourceInfo, Lean.SourceInfo.none, Lean.Syntax]]
[instInhabitedArrow,[Inhabited, Inhabited.mk, arbitrary],[Inhabited]]
[UInt8.add,[UInt8, UInt8.mk, HAdd.hAdd, Fin, UInt8.size, instHAdd, Fin.instAddFin, UInt8.val],[UInt8]]
[UInt8.complement,[UInt8, HSub.hSub, instHSub, instSubUInt8, OfNat.ofNat, instOfNatUInt8, HAdd.hAdd, instHAdd, instAddUInt8],[UInt8]]
[Nat.instDivNat,[Div.mk, Nat, Nat.div],[Div, Nat]]
[«term_<&&>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[String.capitalize,[String, String.set, OfNat.ofNat, String.Pos, instOfNatNat, Char.toUpper, String.get],[String]]
[instMonadExceptOfEIO,[inferInstanceAs, MonadExceptOf, EStateM, IO.RealWorld, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable],[MonadExceptOf, EIO]]
[Thunk.bind,[Thunk, Thunk.mk, Unit, Thunk.get],[Thunk]]
[instReprPUnit,[Repr.mk, PUnit, Nat, Std.Format.text],[Repr, PUnit]]
[instCoeDep,[outParam, CoeFun, CoeDep.mk, coeFun],[outParam, CoeFun, CoeDep]]
[Task.Priority.default,[OfNat.ofNat, Task.Priority, instOfNatNat],[Task.Priority]]
[Prod.rprod.proof_1,[WellFoundedRelation, Subrelation, Prod, Prod.RProd, WellFoundedRelation.rel, Prod.Lex, Subrelation.wf, WellFoundedRelation.wf, Prod.lex, Prod.RProdSubLex],[WellFoundedRelation, WellFounded, Prod, Prod.RProd, WellFoundedRelation.rel]]
[IO.FS.instReprMetadata,[Repr.mk, IO.FS.Metadata, Nat, Std.Format.bracket, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.nil, Std.Format.text, repr, IO.FS.SystemTime, IO.FS.instReprSystemTime, IO.FS.Metadata.accessed, Std.Format.line, IO.FS.Metadata.modified, UInt64, instReprUInt64, IO.FS.Metadata.byteSize, IO.FS.FileType, IO.FS.instReprFileType, IO.FS.Metadata.type],[Repr, IO.FS.Metadata]]
[Lean.instEvalIO,[Lean.Eval, Lean.Eval.mk, IO, Unit, optParam, Bool, Bool.true, Bind.bind, Monad.toBind, instMonadEIO, IO.Error, Unit.unit, Lean.Eval.eval],[Lean.Eval, IO]]
[Setoid.r,[Setoid],[Setoid]]
[List.getLast,[List, Ne, List.nil, List.below, absurd, Eq, List.getLast.proof_1, List.cons, PProd.fst, PUnit, PProd, List.getLast.proof_2],[List, Ne, List.nil]]
[Lean.Meta.Simp.ConfigCtx.toConfig,[Lean.Meta.Simp.ConfigCtx],[Lean.Meta.Simp.ConfigCtx, Lean.Meta.Simp.Config]]
[termPrintln!__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat],[Lean.ParserDescr]]
[«term_|||_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[noConfusionEnum.proof_1,[DecidableEq, Eq, Eq.symm, ite, if_pos],[DecidableEq, Eq, ite]]
[Fin.instAndOpFin,[Nat, AndOp.mk, Fin, Fin.land],[Nat, AndOp, Fin]]
[Nat.succ_le_of_lt,[Nat, LT.lt, instLTNat],[Nat, LT.lt, instLTNat, LE.le, instLENat, Nat.succ]]
[Nat.div.proof_1,[WellFoundedRelation.wf, Nat, measure, id],[WellFounded, Nat, WellFoundedRelation.rel, measure, id]]
[StateCpsT.lift,[Monad, Bind.bind, Monad.toBind],[Monad, StateCpsT]]
[Lean.term_Matches_,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Lean.Module.mk.sizeOf_spec,[Lean.Syntax, Array, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Lean.SyntaxNodeKind, instSizeOfName, Lean.SourceInfo, String, instSizeOf, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, Substring, Lean.Name, Prod, String.Pos],[Lean.Syntax, Array, Eq, Nat, SizeOf.sizeOf, Lean.Module, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, List, Lean.SyntaxNodeKind, instSizeOfName, Lean.SourceInfo, String, instSizeOf, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, Substring, Lean.Name, Prod, String.Pos, Lean.Module.mk]]
[ForInStep.noConfusionType,[ForInStep, Eq],[ForInStep]]
[List.intercalate,[List, List.join, List.intersperse],[List]]
[instDecidableEqQuotient.proof_2,[Setoid, Not, HasEquiv.Equiv, instHasEquiv, Eq, Quotient, Quotient.mk, absurd, False, Quotient.exact],[Setoid, Not, HasEquiv.Equiv, instHasEquiv, Eq, Quotient, Quotient.mk, False]]
[ExceptT.finally,[MonadFinally, Monad, MonadFinally.mk, ExceptT, Option, ExceptT.mk, Prod, Bind.bind, Monad.toBind, Except, MonadFinally.tryFinally', Option.some, Option.none, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.ok, Prod.mk, Except.error],[MonadFinally, Monad, ExceptT]]
[«prec(_)»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol],[Lean.ParserDescr]]
[Lean.Syntax.decodeCharLit,[String, OptionM.run, Char, String.get, OfNat.ofNat, String.Pos, instOfNatNat, ite, OptionM, Eq, Bool, BEq.beq, instBEq, instDecidableEqChar, Char.ofNat, Bool.true, instDecidableEqBool, Bind.bind, Monad.toBind, OptionT.instMonadOptionT, Id, Id.instMonadId, Prod, Lean.Syntax.decodeQuotedChar, Pure.pure, Applicative.toPure, Alternative.toApplicative, OptionT.instAlternativeOptionT],[String, Option, Char]]
[withPtrAddrUnsafe,[USize, Eq, ptrAddrUnsafe],[USize, Eq]]
[Lean.interpolatedStrKind,[Lean.Name.mkStr, Lean.Name.anonymous],[Lean.SyntaxNodeKind]]
[unexpandEqRec,[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit],[Lean.PrettyPrinter.Unexpander]]
[charToHex,[Char, Nat, Char.toNat, HDiv.hDiv, instHDiv, Nat.instDivNat, OfNat.ofNat, instOfNatNat, HMod.hMod, instHMod, Nat.instModNat, HAppend.hAppend, String, instHAppend, String.instAppendString, hexDigitRepr],[Char, String]]
[Quot.rec,[Quot, Quot.mk, Eq, Quot.sound, PSigma.fst, Quot.lift, PSigma, Quot.indep, Quot.indepCoherent, Quot.liftIndepPr1, PSigma.snd],[Quot, Quot.mk, Eq, Quot.sound]]
[Array.get!,[Inhabited, Array.getD, arbitrary],[Inhabited]]
[Iff.refl,[Iff.intro],[Iff]]
[UInt8.lt,[UInt8, LT.lt, Fin, UInt8.size, instLTFin, UInt8.val],[UInt8]]
[IO.Error.inappropriateType.sizeOf_spec,[Option, String, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[Option, String, UInt32, Eq, Nat, SizeOf.sizeOf, IO.Error, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.Error.inappropriateType]]
[Array.size_swap,[Array, Fin, Array.size],[Array, Fin, Array.size, Eq, Nat, Array.swap]]
[Lean.instQuoteName,[Lean.Quote.mk, Lean.Name, OptionM, List, String, Lean.Syntax, Lean.Name.below, Unit, Lean.Name.anonymous, Pure.pure, OptionT, Id, Applicative.toPure, Alternative.toApplicative, OptionT.instAlternativeOptionT, Id.instMonadId, UInt64, Lean.Name.str, Bind.bind, Monad.toBind, OptionT.instMonadOptionT, Lean.Name.escapePart, PProd.fst, PUnit, PProd, Nat, List.cons, Lean.Name.num, Option.none, List.nil, Lean.mkNode, Lean.Name.mkStr, List.toArray, Lean.Syntax.mkNameLit, HAppend.hAppend, instHAppend, String.instAppendString, String.intercalate, Lean.SourceInfo.none, Lean.mkCIdent, Lean.Syntax.mkCApp, Lean.Quote.quote, Lean.instQuoteString, Lean.instQuoteNat],[Lean.Quote, Lean.Name]]
[Lean.TrailingParserDescr,[Lean.ParserDescr],[]]
[Subarray.forInUnsafe,[Monad, Subarray, ForInStep, USize, USize.ofNat, Subarray.stop, Subarray.start, Subarray.forInUnsafe.loop],[Monad, Subarray, ForInStep]]
[instLEUInt64,[LE.mk, UInt64, UInt64.le],[LE, UInt64]]
[Nat.pred_lt,[Nat, Ne, OfNat.ofNat, instOfNatNat, LT.lt, instLTNat, Nat.pred, Nat.zero, absurd, Eq, rfl, Nat.succ, Nat.lt_succ_of_le, Nat.le_refl],[Nat, Ne, OfNat.ofNat, instOfNatNat, LT.lt, instLTNat, Nat.pred]]
[Lean.Macro.instInhabitedMethods,[Inhabited.mk, Lean.Macro.Methods, Lean.Macro.Methods.mk, arbitrary, Lean.Syntax, Lean.MacroM, Option, instInhabitedDepArrow, instInhabitedReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, instInhabited, EStateM.instMonadEStateM, instInhabitedOption, Lean.Name, Lean.instInhabitedName, Bool, instInhabitedBool, List, Prod, String, instInhabitedList],[Inhabited, Lean.Macro.Methods]]
[USize.lor,[USize, USize.mk, Fin.lor, USize.size, USize.val],[USize]]
[tryCatchThe,[MonadExceptOf, MonadExceptOf.tryCatch],[MonadExceptOf]]
[PNonScalar.noConfusionType,[PNonScalar, Nat, Eq],[PNonScalar]]
[instToBoolOption,[ToBool.mk, Option, Option.toBool],[ToBool, Option]]
[Array.anyMUnsafe.any,[Monad, Bool, Array, USize, ite, Eq, BEq.beq, instBEq, instDecidableEqUSize, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.false, Bind.bind, Monad.toBind, Array.uget, lcProof, LT.lt, Nat, instLTNat, USize.toNat, Array.size, Array.anyMUnsafe.any, HAdd.hAdd, instHAdd, instAddUSize, OfNat.ofNat, instOfNatUSize],[Monad, Bool, Array, USize]]
[Substring.str,[Substring],[Substring, String]]
[Nat.add_right_comm,[Nat, Eq.mpr, Eq, HAdd.hAdd, instHAdd, instAddNat, Eq.refl, Nat.add_assoc, Nat.add_comm, Eq.symm, rfl],[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat]]
[Lean.mkAtom,[String, Lean.Syntax.atom, Lean.SourceInfo.none],[String, Lean.Syntax]]
[EIO.toIO,[IO.Error, EIO, EStateM.adaptExcept, IO.RealWorld],[IO.Error, EIO, IO]]
[IO.FS.DirEntry.mk.sizeOf_spec,[System.FilePath, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[System.FilePath, String, Eq, Nat, SizeOf.sizeOf, IO.FS.DirEntry, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, IO.FS.DirEntry.mk]]
[USize.mk.sizeOf_spec,[Fin, USize.size, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, LT.lt, instLTNat, instSizeOfNat, instSizeOf],[Fin, USize.size, Eq, Nat, SizeOf.sizeOf, USize, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, LT.lt, instLTNat, instSizeOfNat, instSizeOf, USize.mk]]
[heq_of_eq_of_heq,[Eq, HEq, HEq.trans, heq_of_eq],[Eq, HEq]]
[Int.subNatNat,[Nat, Int, HSub.hSub, instHSub, instSubNat, Unit, Int.ofNat, Int.negSucc],[Nat, Int]]
[«term_×_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Std.Format.join,[List, Std.Format, List.foldl, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text],[List, Std.Format]]
[Array.forInUnsafe.loop,[Monad, Array, ForInStep, USize, ite, LT.lt, instLTUSize, instDecidableLt_4, Array.uget, lcProof, Nat, instLTNat, USize.toNat, Array.size, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.forInUnsafe.loop, HAdd.hAdd, instHAdd, instAddUSize, OfNat.ofNat, instOfNatUSize],[Monad, Array, ForInStep, USize]]
[MonadReader.read,[MonadReader],[MonadReader]]
[List.le,[LT, List, Not, LT.lt, List.instLTList],[LT, List]]
[Char.isValidUInt32,[Nat, Char.isValidCharNat, LT.lt, instLTNat, UInt32.size, OfNat.ofNat, instOfNatNat, Nat.lt_trans, of_decide_eq_true, Nat.decLt, Eq.refl, Bool, Bool.true],[Nat, Char.isValidCharNat, LT.lt, instLTNat, UInt32.size]]
[Quotient.lift₂.proof_1,[Setoid, HasEquiv.Equiv, instHasEquiv, Eq, Setoid.refl],[Setoid, HasEquiv.Equiv, instHasEquiv, Eq]]
[UInt64.lor,[UInt64, UInt64.mk, Fin.lor, UInt64.size, UInt64.val],[UInt64]]
[List.getLast?.proof_1,[List, Eq, List.cons, List.nil, False],[List, Eq, List.cons, List.nil, List.noConfusionType, False]]
[IO.FS.Stream.mk.inj,[IO, Bool, Unit, USize, ByteArray, String, Eq, IO.FS.Stream, IO.FS.Stream.mk, And, And.intro],[IO, Bool, Unit, USize, ByteArray, String, Eq, IO.FS.Stream, IO.FS.Stream.mk, And]]
[StateCpsT.runK_monadLift,[Monad, MonadLiftT, rfl, StateCpsT.runK, MonadLiftT.monadLift, StateCpsT, instMonadLiftT, StateCpsT.instMonadLiftStateCpsT],[Monad, MonadLiftT, Eq, StateCpsT.runK, MonadLiftT.monadLift, StateCpsT, instMonadLiftT, StateCpsT.instMonadLiftStateCpsT, Bind.bind, Monad.toBind]]
[Task.Priority,[Nat],[]]
[Nat.le_antisymm,[Nat, LE.le, instLENat, Eq, rfl, Nat.le, absurd, LT.lt, instLTNat, Nat.lt_of_le_of_lt, Nat.lt_irrefl],[Nat, LE.le, instLENat, Eq]]
[Nat.anyAux,[Nat, Bool, Nat.below, Unit, Bool.false, Nat.succ, or, HSub.hSub, instHSub, instSubNat, PProd.fst, PUnit, PProd],[Nat, Bool]]
[ToStream.noConfusionType,[outParam, ToStream, Eq],[outParam, ToStream]]
[Array.anyM.proof_1,[Array, Nat.le_refl, Array.size],[Array, LE.le, Nat, instLENat, Array.size]]
[withPtrEq,[Unit, Bool, Eq, Unit.unit, Bool.true],[Unit, Bool, Eq, Unit.unit, Bool.true]]
[Nat.le_of_lt_succ,[Nat, Nat.le_of_succ_le_succ],[Nat, LT.lt, instLTNat, Nat.succ, LE.le, instLENat]]
[IO.appDir,[Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, System.FilePath, IO.appPath, Option, Pure.pure, Applicative.toPure, Monad.toApplicative, System.FilePath.parent, IO.FS.realPath, MonadExcept.throw, instMonadExcept, instMonadExceptOfEIO, IO.userError, HAppend.hAppend, String, instHAppend, String.instAppendString, ToString.toString, instToStringString, System.instToStringFilePath],[IO, System.FilePath]]
[monadLift_self,[Monad, rfl, MonadLiftT.monadLift, instMonadLiftT_1],[Monad, Eq, MonadLiftT.monadLift, instMonadLiftT_1]]
[Nat.not_succ_le_zero,[Nat, LE.le, instLENat, Nat.succ, OfNat.ofNat, instOfNatNat, False],[Nat, LE.le, instLENat, Nat.succ, OfNat.ofNat, instOfNatNat, False]]
[List.filterRevM,[Monad, Bool, List, List.filterAuxM, List.reverse, List.nil],[Monad, Bool, List]]
[«term_&&_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[«term_↔_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[ExceptCpsT.run_lift,[Monad, rfl, Except, ExceptCpsT.run, ExceptCpsT.lift],[Monad, Eq, Except, ExceptCpsT.run, ExceptCpsT.lift, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.ok]]
[Lean.Name.num.inj,[Lean.Name, Nat, UInt64, Eq, Lean.Name.num, And, And.intro],[Lean.Name, Nat, UInt64, Eq, Lean.Name.num, And]]
[DoResultPRBC.noConfusionType,[DoResultPRBC, Eq],[DoResultPRBC]]
[Lean.mkIdent,[Lean.Name, Lean.Syntax.ident, Lean.SourceInfo.none, String.toSubstring, ToString.toString, Lean.Name.instToStringName, List.nil, Prod, List, String],[Lean.Name, Lean.Syntax]]
[String.Iterator.remainingBytes,[String.Iterator, Nat, String, String.Pos, HSub.hSub, instHSub, instSubNat, String.bsize],[String.Iterator, Nat]]
[UInt64.size,[OfNat.ofNat, Nat, instOfNatNat],[Nat]]
[IO.Process.SpawnArgs.cwd,[IO.Process.SpawnArgs],[IO.Process.SpawnArgs, Option, System.FilePath]]
[InvImage.wf,[InvImage.wf.proof_1],[WellFounded, InvImage]]
[runST,[ST, EStateM.Result, Empty, Unit, Unit.unit],[ST]]
[instDecidableIte,[Decidable, ite, Not],[Decidable, ite]]
[instDecidableNot,[Decidable, Not, Decidable.isFalse, absurd, False, Decidable.isTrue],[Decidable, Not]]
[Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp,[Trans.mk, Nat, LE.le, instLENat, Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp.proof_1],[Trans, Nat, LE.le, instLENat]]
[noConfusionTypeEnum,[DecidableEq, ite, Eq],[DecidableEq]]
[instInhabitedNonScalar,[Inhabited.mk, NonScalar, NonScalar.mk, arbitrary, Nat, instInhabitedNat],[Inhabited, NonScalar]]
[instReprAtomBool,[ReprAtom.mk, Bool],[ReprAtom, Bool]]
[Classical.byCases,[Not, Decidable.byCases, Classical.propDecidable],[Not]]
[Lean.Name.toStringWithSep.maybeEscape,[Bool, String, ite, Eq, Bool.true, instDecidableEqBool, Option.getD, Lean.Name.escapePart],[Bool, String]]
[String.offsetOfPos,[String, String.Pos, String.offsetOfPosAux, OfNat.ofNat, instOfNatNat, Nat],[String, String.Pos, Nat]]
[instDecidableEqList,[DecidableEq, List.hasDecEq],[DecidableEq, List]]
[String.Iterator.pos,[String.Iterator, String.Pos, String],[String.Iterator, String.Pos]]
[instInhabitedUSize,[Inhabited.mk, USize, USize.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, instInhabitedUSize.proof_1],[Inhabited, USize]]
[Nat.zero_lt_one,[Nat.zero_lt_succ, OfNat.ofNat, Nat, instOfNatNat],[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat]]
[decidableOfDecidableOfEq,[Decidable, Eq],[Decidable, Eq]]
[Lean.Macro.Context.methods,[Lean.Macro.Context],[Lean.Macro.Context, PointedType.type]]
[Nat.foldRev.loop,[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd],[Nat]]
[And.noConfusionType,[And],[And]]
[List.join,[List, List.below, Unit, List.nil, List.cons, HAppend.hAppend, instHAppend, List.instAppendList, PProd.fst, PUnit, PProd],[List]]
[instInhabitedTask,[Inhabited, Inhabited.mk, Task, Task.pure, arbitrary],[Inhabited, Task]]
[Array.«term__[_:]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Array.binInsert,[Inhabited, Bool, Array, Id.run, Array.binInsertM, Id, Id.instMonadId, Unit],[Inhabited, Bool, Array]]
[instCoeNatInt,[Coe.mk, Nat, Int, Int.ofNat],[Coe, Nat, Int]]
[instHModUInt16NatUInt16,[HMod.mk, UInt16, Nat, UInt16.modn],[HMod, UInt16, Nat]]
[Lean.mkAtomFrom,[Lean.Syntax, String, Lean.Syntax.atom, Lean.SourceInfo.fromRef],[Lean.Syntax, String]]
[instToStringChar,[ToString.mk, Char, Char.toString],[ToString, Char]]
[StateRefT'.instAlternativeStateRefT',[Alternative, Monad, inferInstanceAs, ReaderT, ST.Ref, ReaderT.instAlternativeReaderT],[Alternative, Monad, StateRefT']]
[iff_true,[propext, Iff, True, Iff.intro, Iff.mpr, trivial],[Eq, Iff, True]]
[optional,[Alternative, HOrElse.hOrElse, Option, instHOrElse, instOrElse, Functor.map, Applicative.toFunctor, Alternative.toApplicative, Option.some, Unit, Pure.pure, Applicative.toPure, Option.none],[Alternative, Option]]
[Substring.foldl,[Char, Substring, String, String.Pos, String.foldlAux],[Char, Substring]]
[Lean.Syntax.isMissing,[Lean.Syntax, Bool, Unit, Bool.true, Bool.false],[Lean.Syntax, Bool]]
[Array.toList,[Array, Array.foldr, List, List.cons, List.nil, Array.size, OfNat.ofNat, Nat, instOfNatNat],[Array, List]]
[instMonadControlT,[MonadControl, MonadControlT, MonadControlT.mk, MonadControlT.stM, MonadControl.stM, MonadControl.liftWith, MonadControlT.liftWith, Function.comp, MonadControl.restoreM, MonadControlT.restoreM],[MonadControl, MonadControlT]]
[IO.Error.permissionDenied.inj,[Option, String, UInt32, Eq, IO.Error, IO.Error.permissionDenied, And, And.intro],[Option, String, UInt32, Eq, IO.Error, IO.Error.permissionDenied, And]]
[IO.Process.StdioConfig.noConfusionType,[IO.Process.StdioConfig, IO.Process.Stdio, Eq],[IO.Process.StdioConfig]]
[Lean.expandExplicitBinders,[Lean.Name, Lean.Syntax, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.MonadRef.getRef, Lean.Macro.instMonadRefMacroM, Lean.mkIdentFrom, Lean.Syntax.getOp, OfNat.ofNat, Nat, instOfNatNat, ite, Eq, Bool, BEq.beq, Lean.SyntaxNodeKind, Lean.Name.instBEqName, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Array, Lean.Syntax.getArgs, Option, Lean.Syntax.isNone, Option.none, Option.some, Lean.expandExplicitBindersAux, Array.all, Array.size, Lean.expandBrackedBindersAux, Lean.Macro.throwError],[Lean.Name, Lean.Syntax, Lean.MacroM]]
[List.ibelow,[List, True, And],[List]]
[ExceptCpsT.instMonadLiftExceptCpsT,[Monad, MonadLift.mk, ExceptCpsT, ExceptCpsT.lift],[Monad, MonadLift, ExceptCpsT]]
[instHModUInt64NatUInt64,[HMod.mk, UInt64, Nat, UInt64.modn],[HMod, UInt64, Nat]]
[IO.FS.Stream.noConfusionType,[IO.FS.Stream, IO, Bool, Unit, USize, ByteArray, String, Eq],[IO.FS.Stream]]
[Lean.Macro.getCurrNamespace,[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, Lean.Name, Lean.Macro.getMethods, Lean.Macro.Methods.getCurrNamespace],[Lean.MacroM, Lean.Name]]
[instOrdUSize,[Ord.mk, USize, compareOfLessAndEq, instLTUSize, instDecidableLt_4, instDecidableEqUSize],[Ord, USize]]
[Lean.Syntax.find?,[Lean.Syntax, Bool, Lean.Syntax.findAux],[Lean.Syntax, Bool, Option]]
[MonadState.set,[MonadState],[MonadState, PUnit]]
[Lean.Parser.Tactic.simp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpStar, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma, Lean.Parser.Tactic.location],[Lean.ParserDescr]]
[List.instForMList,[ForM.mk, List, Monad, List.forM],[ForM, List]]
[Std.Range.forM,[Monad, Std.Range, Nat, PUnit, Std.Range.stop, Std.Range.start, Std.Range.forM.loop],[Monad, Std.Range, Nat, PUnit]]
[Nat.add_le_add_right,[Nat, LE.le, instLENat, Eq.mpr, HAdd.hAdd, instHAdd, instAddNat, Eq, Eq.refl, Nat.add_comm, Nat.add_le_add_left],[Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat]]
[instMonadST,[inferInstanceAs, Monad, EST, Empty, instMonadEST],[Monad, ST]]
[Std.Range.noConfusionType,[Std.Range, Nat, Eq],[Std.Range]]
[Nat.mul_lt_mul_of_pos_left,[Nat, LT.lt, instLTNat, GT.gt, OfNat.ofNat, instOfNatNat, Nat.lt_of_lt_of_le, HMul.hMul, instHMul, instMulNat, HAdd.hAdd, instHAdd, instAddNat, Nat.mul, Nat.add_lt_add_left, Nat.succ, LE.le, instLENat, Nat.mul_le_mul_left, Nat.succ_le_of_lt, Nat.mul_succ],[Nat, LT.lt, instLTNat, GT.gt, OfNat.ofNat, instOfNatNat, HMul.hMul, instHMul, instMulNat]]
[precArg,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[IO.Error.otherErrorToString,[String, UInt32, Option, HAppend.hAppend, instHAppend, String.instAppendString, String.modify, OfNat.ofNat, String.Pos, instOfNatNat, Char.toLower, ToString.toString, instToStringUInt32, Unit],[String, UInt32, Option]]
[type_eq_of_heq,[type_eq_of_heq.proof_1],[HEq, Eq]]
[cast_heq,[Eq, HEq, cast, HEq.refl],[Eq, HEq, cast]]
[fix2,[Inhabited, fixCore2, arbitrary],[Inhabited]]
[«term_$__»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[Equivalence.symm,[Equivalence],[Equivalence]]
[TC.wf,[TC.wf.proof_1],[WellFounded, TC]]
[Lean.Parser.Tactic.skip,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[StateT.set,[Monad, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod, PUnit, Prod.mk, PUnit.unit],[Monad, StateT, PUnit]]
[IO.Error.mkResourceExhaustedFile,[Function.comp, String, Option, UInt32, IO.Error, IO.Error.resourceExhausted, Option.some],[String, UInt32, IO.Error]]
[List.filterMapM,[Monad, Option, List, List.reverse, List.nil, List.filterMapM.loop],[Monad, Option, List]]
[Std.Range.step,[Std.Range],[Std.Range, Nat]]
[Array.singleton,[Array.mkArray, OfNat.ofNat, Nat, instOfNatNat],[Array]]
[List.eraseIdx,[List, Nat, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd],[List, Nat]]
[Array.swapAt!,[Array, Nat, dite, Prod, LT.lt, instLTNat, Array.size, Nat.decLt, Array.swapAt, Fin.mk, Not],[Array, Nat, Prod]]
[instMonadReaderOf,[MonadLift, MonadReaderOf, MonadReaderOf.mk, liftM, instMonadLiftT, instMonadLiftT_1, MonadReader.read, instMonadReader],[MonadLift, MonadReaderOf]]
[Nat.mul_add,[Nat, Nat.left_distrib],[Nat, Eq, HMul.hMul, instHMul, instMulNat, HAdd.hAdd, instHAdd, instAddNat]]
[not_false,[id, False],[Not, False]]
[Std.Format.instMonadPrettyFormatStateMState,[Std.Format.MonadPrettyFormat.mk, StateM, String, modify, instMonadState, instMonadStateOfStateT, Id, Id.instMonadId, Nat, HAppend.hAppend, instHAppend, String.instAppendString, HAdd.hAdd, instHAdd, instAddNat, String.length, String.pushn, Char.ofNat, Bind.bind, Monad.toBind, StateT.instMonadStateT, MonadState.get, Pure.pure, Applicative.toPure, Monad.toApplicative, Unit, Unit.unit],[Std.Format.MonadPrettyFormat, StateM]]
[instMonadFinallyStateRefT',[MonadFinally, Monad, inferInstanceAs, ReaderT, ST.Ref, ReaderT.tryFinally],[MonadFinally, Monad, StateRefT']]
[instStreamSubstringChar,[Stream.mk, Substring, Char, ite, Option, Prod, LT.lt, String.Pos, instLTNat, Substring.startPos, Substring.stopPos, Nat.decLt, Option.some, Prod.mk, String.get, Substring.str, Substring.mk, String.next, Option.none],[Stream, Substring, Char]]
[instDecidableTrue,[Decidable.isTrue, True, trivial],[Decidable, True]]
[Array.get,[List.get, Array.data, Fin.val, Array.size, Array.get.proof_1],[]]
[Nat.mul_le_mul_right,[Nat, LE.le, instLENat, HMul.hMul, instHMul, instMulNat, Nat.mul_le_mul_left, Nat.mul_comm],[Nat, LE.le, instLENat, HMul.hMul, instHMul, instMulNat]]
[Lean.Syntax.isInterpolatedStrLit?,[Lean.Syntax, Option, String, Lean.Syntax.isLit?, Lean.interpolatedStrLitKind, Unit, Option.none, String.Pos, OptionM, OfNat.ofNat, instOfNatNat],[Lean.Syntax, Option, String]]
[dif_neg,[Decidable, Not, Eq, dite, absurd, Decidable.isTrue, rfl, Decidable.isFalse],[Decidable, Not, Eq, dite]]
[ReaderT,[],[]]
[Lean.mkGroupNode,[optParam, Array, Lean.Syntax, List.toArray, List.nil, Lean.Syntax.node, Lean.groupKind],[optParam, Array, Lean.Syntax, List.toArray, List.nil]]
[instReprSubtype,[Repr, Repr.mk, Subtype, Nat, Repr.reprPrec, Subtype.val],[Repr, Subtype]]
[Substring.isNat,[Substring, Substring.all, Char, Char.isDigit],[Substring, Bool]]
[Task.map,[Task, optParam, Task.Priority, Task.Priority.default, Task.pure, Task.get],[Task, optParam, Task.Priority, Task.Priority.default]]
[Iff.symm,[Iff, Iff.intro, Iff.mpr, Iff.mp],[Iff]]
[Lean.isIdFirst,[Char, or, Char.isAlpha, Decidable.decide, Eq, Char.ofNat, instDecidableEqChar, Lean.isLetterLike],[Char, Bool]]
[HShiftRight.hShiftRight,[HShiftRight],[HShiftRight]]
[List.foldlM,[Monad, List, List.below, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, List.cons, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd],[Monad, List]]
[Lean.Macro.State.traceMsgs,[Lean.Macro.State],[Lean.Macro.State, List, Prod, Lean.Name, String]]
[Fin.mod,[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, Fin.mod.proof_1],[Nat, Fin]]
[heq_of_eqRec_eq,[Eq, HEq, Eq.refl, heq_of_eq],[Eq, HEq]]
[IO.FS.DirEntry.noConfusionType,[IO.FS.DirEntry, System.FilePath, String, Eq],[IO.FS.DirEntry]]
[Nat.superDigitChar,[Nat, ite, Char, Eq, OfNat.ofNat, instOfNatNat, instDecidableEqNat, Char.ofNat],[Nat, Char]]
[IO.Process.run,[IO.Process.SpawnArgs, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.Process.Output, String, IO.Process.output, PUnit, Pure.pure, Applicative.toPure, Monad.toApplicative, IO.Process.Output.stdout, ite, Eq, Bool, bne, UInt32, instBEq, instDecidableEqUInt32, IO.Process.Output.exitCode, OfNat.ofNat, instOfNatUInt32, Bool.true, instDecidableEqBool, MonadExcept.throw, instMonadExcept, instMonadExceptOfEIO, IO.userError, HAppend.hAppend, instHAppend, String.instAppendString, IO.Process.SpawnArgs.cmd, ToString.toString, instToStringUInt32, PUnit.unit],[IO.Process.SpawnArgs, IO, String]]
[instDecidableLt_1,[UInt8, UInt8.decLt],[UInt8, Decidable, LT.lt, instLTUInt8]]
[Sum.noConfusionType,[Sum, Eq],[Sum]]
[Array.toSubarray.proof_1,[Array, Nat.le_refl, Array.size],[Array, LE.le, Nat, instLENat, Array.size]]
[«term_<->_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat],[Lean.TrailingParserDescr]]
[List.intersperse,[List, List.below, Unit, List.nil, List.cons, PProd.fst, PUnit, PProd],[List]]
[Lean.Syntax.atom.sizeOf_spec,[Lean.SourceInfo, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOf, SizeOf.mk, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat],[Lean.SourceInfo, String, Eq, Nat, SizeOf.sizeOf, Lean.Syntax, SizeOf.mk, Array, List, OfNat.ofNat, instOfNatNat, Lean.SyntaxNodeKind, HAdd.hAdd, instHAdd, instAddNat, instSizeOfName, instSizeOf, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, Substring, Lean.Name, Prod, String.Pos, Lean.Syntax.atom]]
[System.FilePath.isDir,[System.FilePath, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, Bool, MonadExcept.tryCatch, instMonadExcept, instMonadExceptOfEIO, IO.FS.Metadata, System.FilePath.metadata, Pure.pure, Applicative.toPure, Monad.toApplicative, BEq.beq, IO.FS.FileType, IO.FS.instBEqFileType, IO.FS.Metadata.type, IO.FS.FileType.dir, Bool.false],[System.FilePath, IO, Bool]]
[USize.shiftRight,[USize, USize.mk, HShiftRight.hShiftRight, Fin, USize.size, instHShiftRight, Fin.instShiftRightFin, USize.val, USize.modn, System.Platform.numBits],[USize]]
[String.isNat,[String, String.all, Char, Char.isDigit],[String, Bool]]
[Nat.mod_le,[Nat, Or, LT.lt, instLTNat, GE.ge, instLENat, Nat.lt_or_ge, LE.le, HMod.hMod, instHMod, Nat.instModNat, Eq.mpr, Eq, Eq.refl, Nat.mod_eq_of_lt, Nat.le_refl, OfNat.ofNat, instOfNatNat, GT.gt, Nat.eq_zero_or_pos, Nat.mod_zero, Nat.le_trans, Nat.le_of_lt, Nat.mod_lt],[Nat, LE.le, instLENat, HMod.hMod, instHMod, Nat.instModNat]]
[UInt16.complement,[UInt16, HSub.hSub, instHSub, instSubUInt16, OfNat.ofNat, instOfNatUInt16, HAdd.hAdd, instHAdd, instAddUInt16],[UInt16]]
[Fin.instSubFin,[Nat, Sub.mk, Fin, Fin.sub],[Nat, Sub, Fin]]
[MonadExcept.noConfusionType,[outParam, MonadExcept, Eq],[outParam, MonadExcept]]
[Fin.instOfNatFinHAdd,[Nat, OfNat.mk, Fin, Fin.ofNat],[Nat, OfNat, Fin]]
[WellFounded.apply.proof_1,[WellFounded, Acc],[WellFounded, Acc]]
[EStateM.Result.noConfusionType,[EStateM.Result, Eq],[EStateM.Result]]
[prioHigh,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false],[Lean.ParserDescr]]
[NonScalar.val,[NonScalar],[NonScalar, Nat]]
[UInt8.size,[OfNat.ofNat, Nat, instOfNatNat],[Nat]]
[Array.anyM,[Monad, Bool, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, LE.le, instLENat, HSub.hSub, instHSub, instSubNat, Array.anyM.loop, dite, Nat.decLe, Not, Array.anyM.proof_1],[Monad, Bool, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size]]
[Lean.instInhabitedSourceInfo,[Inhabited.mk, Lean.SourceInfo, Lean.SourceInfo.none],[Inhabited, Lean.SourceInfo]]
[Fin.instAddFin,[Nat, Add.mk, Fin, Fin.add],[Nat, Add, Fin]]
[StateRefT'.instMonadFunctorStateRefT',[Monad, inferInstanceAs, MonadFunctor, ReaderT, ST.Ref, ReaderT.instMonadFunctorReaderT],[Monad, MonadFunctor, StateRefT']]
[Equivalence.refl,[Equivalence],[Equivalence]]
[UInt16.add,[UInt16, UInt16.mk, HAdd.hAdd, Fin, UInt16.size, instHAdd, Fin.instAddFin, UInt16.val],[UInt16]]
[Lean.Name.ibelow,[Lean.Name, True, String, UInt64, And, Nat],[Lean.Name]]
[instAddUInt32,[Add.mk, UInt32, UInt32.add],[Add, UInt32]]
[Task.pure.sizeOf_spec,[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf],[SizeOf, Eq, Nat, SizeOf.sizeOf, Task, SizeOf.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Task.pure]]
[EIO,[EStateM, IO.RealWorld],[]]
[monadFunctorRefl,[MonadFunctorT.mk],[MonadFunctorT]]
[Lean.Macro.expandMacro?,[Lean.Syntax, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, Option, Lean.Macro.getMethods, Lean.Macro.Methods.expandMacro?],[Lean.Syntax, Lean.MacroM, Option]]
[Lean.Module.noConfusionType,[Lean.Module, Lean.Syntax, Array, Eq],[Lean.Module]]
[Std.instToFormatFormat,[Std.ToFormat.mk, Std.Format],[Std.ToFormat, Std.Format]]
[randBool,[RandomGen, Prod, Nat, randNat, OfNat.ofNat, instOfNatNat, Prod.mk, Bool, Decidable.decide, Eq, instDecidableEqNat],[RandomGen, Prod, Bool]]
[Subarray.instForInSubarray,[ForIn.mk, Subarray, Monad, Subarray.forIn],[ForIn, Subarray]]
[MonadStateOf.set,[MonadStateOf],[MonadStateOf, PUnit]]
[String.prev,[String, String.Pos, List, Char, ite, Eq, OfNat.ofNat, instOfNatNat, instDecidableEqNat, List.below, List.nil, List.cons, Nat, String.csize, HAdd.hAdd, instHAdd, instAddNat, PProd.fst, PUnit, PProd],[String.Pos]]
[dite_true,[True, Not, rfl, dite, instDecidableTrue],[True, Not, Eq, dite, instDecidableTrue, True.intro]]
[Nat.foldM,[Monad, Nat, Nat.foldM.loop],[Monad, Nat]]
[List.reverse,[List, List.reverseAux, List.nil],[List]]
[USize.complement,[USize, HSub.hSub, instHSub, instSubUSize, OfNat.ofNat, instOfNatUSize, HAdd.hAdd, instHAdd, instAddUSize],[USize]]
[String.dropWhile,[String, Char, Bool, Substring.toString, Substring.dropWhile, String.toSubstring],[String, Char, Bool]]
[FloatArray.size,[FloatArray, Nat, Array, Float, Array.size],[Nat]]
[List.hasDecEq.proof_5,[List, Not, Eq, List.cons, False, absurd],[List, Not, Eq, List.cons, False]]
[Array.toArrayLit,[Array, Nat, Eq, Array.size, List.toArray, Array.toListLitAux, Array.toArrayLit.proof_1, List.nil],[Array, Nat, Eq, Array.size]]
[Lean.Name.escapePart,[String, ite, Option, Eq, Bool, and, Decidable.decide, GT.gt, Nat, instLTNat, String.length, OfNat.ofNat, instOfNatNat, Nat.decLt, Lean.isIdFirst, String.getOp, String.Pos, Substring.all, Substring.drop, String.toSubstring, Lean.isIdRest, Bool.true, instDecidableEqBool, Option.some, String.any, Lean.isIdEndEscape, Option.none, HAppend.hAppend, instHAppend, String.instAppendString, Char.toString, Lean.idBeginEscape, Lean.idEndEscape],[String, Option]]
[Lean.Syntax.formatStx,[Lean.Syntax, optParam, Option, Nat, Option.none, Bool, Bool.false, Lean.Syntax.formatStxAux, OfNat.ofNat, instOfNatNat],[Lean.Syntax, optParam, Option, Nat, Option.none, Bool, Bool.false, Std.Format]]
[coeTrans,[Coe, CoeTC, CoeTC.mk, coeB, coeTC],[Coe, CoeTC]]
