[PProd.noConfusionType,[]]
[Id.hasBind,[inferInstance, Bind, Id, Monad.toBind, Id.instMonadId]]
[Lean.identKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[MonadState.noConfusionType,[]]
[ToString.noConfusionType,[]]
[String.Iterator.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, String, SizeOf.mk, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar, String.Pos]]
[Nat.toUInt8,[UInt8.ofNat]]
[ByteArray.noConfusionType,[]]
[ExceptCpsT.run_bind_throw,[rfl, Except, ExceptCpsT.run, Bind.bind, ExceptCpsT, Monad.toBind, ExceptCpsT.instMonadExceptCpsT, MonadExcept.throw, instMonadExcept, ExceptCpsT.instMonadExceptOfExceptCpsT]]
[List.append_eq_appendTR,[funext, List, List.append, List.appendTR, Eq, List.reverseAux, List.nil, rfl, of_eq_true, List.cons, Eq.trans, True, congr, congrArg, List.reverseAux_reverseAux, eq_self]]
[Lean.isIdRest,[or, Char.isAlphanum, Decidable.decide, Eq, Char, Char.ofNat, instDecidableEqChar, BEq.beq, instBEq, Lean.isLetterLike, Lean.isSubScriptAlnum]]
[List.spanAux,[Prod, List, Prod.mk, List.reverse, List.nil, Unit.unit, PProd.fst, PUnit, PProd, List.cons]]
[instInhabitedUSize.proof_1,[Eq, Nat, OfNat.ofNat, instOfNatNat, Or.inl, Eq.refl, Unit.unit, Eq.symm, eq_of_heq, HEq.refl, Or.inr, LT.lt, instLTNat, USize.size, usize_size_eq, of_decide_eq_true, Nat.decLt, Bool, Bool.true]]
[Array.instForInArray,[ForIn.mk, Array, Array.forIn]]
[List.getLastD,[List.getLast, List.cons, List.getLastD.proof_1]]
[Eq.mpr_not,[Not, Eq.symm]]
[Not,[False]]
[OptionT.pure,[OptionT.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, Option, Option.some]]
[Nat.toSuperDigits,[Nat.toSuperDigitsAux, List.nil, Char]]
[EStateM.pure,[EStateM.Result.ok]]
[Subtype.val,[]]
[Functor.mapRev,[Functor.map]]
[Lean.Syntax.getSepArgs,[Array.getSepElems, Lean.Syntax, Lean.Syntax.getArgs]]
[LawfulFunctor.id_map,[]]
[ULift.down_up,[rfl, ULift.down, ULift.up]]
[HMul.noConfusionType,[]]
[instInhabitedFloat,[Inhabited.mk, Float, Float.mk, FloatSpec.val, floatSpec]]
[ExceptCpsT.run_pure,[rfl, Except, ExceptCpsT.run, Pure.pure, ExceptCpsT, Applicative.toPure, Monad.toApplicative, ExceptCpsT.instMonadExceptCpsT]]
[IO.Error.hardwareFault.inj,[And, Eq, UInt32, String, IO.Error.hardwareFault, And.intro]]
[PSum.noConfusionType,[]]
[instOrElse,[OrElse.mk, Alternative.orElse]]
[Array.filterSepElemsM,[OfNat.ofNat, Nat, instOfNatNat, List.toArray, Lean.Syntax, List.nil]]
[USize.le,[LE.le, Fin, USize.size, instLEFin, USize.val]]
[instReprExcept,[Repr.mk, Except, Std.Format, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, reprArg]]
[EStateM,[EStateM.Result]]
[Subrelation.wf,[Subrelation.wf.proof_1]]
[String.intercalate.go,[String, Unit.unit, PProd.fst, PUnit, PProd, HAppend.hAppend, instHAppend, String.instAppendString]]
[Lean.choiceKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Array.toArrayLit_eq,[sorryAx, Eq, Array, Array.toArrayLit, Bool.false]]
[StateT.seqRight_eq,[StateT.ext, SeqRight.seqRight, StateT, Applicative.toSeqRight, Monad.toApplicative, StateT.instMonadStateT, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const, id, Eq.mpr, Eq, Prod, StateT.run, Bind.bind, Monad.toBind, Prod.snd, Pure.pure, Applicative.toPure, Prod.mk, Prod.fst, congr, congrArg, StateT.run_seqRight, Eq.trans, StateT.run_seq, StateT.run_map, map_eq_pure_bind, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, congrFun, id_eq, bind_congr, of_eq_true, True, Prod.ext, bind_pure, eq_self, Eq.symm, Eq.refl]]
[Decidable.of_not_not,[Decidable.byContradiction, absurd, Not, False]]
[instToStringList,[ToString.mk, List, List.toString]]
[Lean.Syntax.isIdOrAtom?,[Lean.Syntax.missing, Lean.Syntax.node, Option, String, Option.some, Substring.toString, Option.none]]
[Nat.le_of_succ_le,[Nat.le_trans, Nat.succ, Nat.le_succ]]
[instOfNatUInt16,[OfNat.mk, UInt16, UInt16.ofNat]]
[Char.le,[LE.le, UInt32, instLEUInt32, Char.val]]
[Std.Format.fill,[Std.Format.group, Std.Format.FlattenBehavior.fill]]
[Nat.toDigitsCore,[List, Char, ite, Eq, Nat, OfNat.ofNat, instOfNatNat, instDecidableEqNat, List.cons, PProd.fst, PUnit, PProd]]
[ST,[EST, Empty]]
[Nat.succ_eq_add_one,[rfl, Nat, Nat.succ]]
[Equivalence.trans,[]]
[String.foldr,[String.foldrAux, String.bsize, OfNat.ofNat, String.Pos, instOfNatNat]]
[instInhabitedEST,[inferInstanceAs, Inhabited, EStateM, EStateM.instInhabitedEStateM]]
[IO.FS.readBinFile,[Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle, ByteArray, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.true, IO.FS.Handle.readBinToEnd]]
[Lean.Parser.Tactic.focus,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[unexpandIte,[ite, Lean.PrettyPrinter.UnexpandM, Lean.Syntax, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.matchesNull, OfNat.ofNat, Nat, instOfNatNat, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
[USize.decLe,[USize.mk, Decidable, LE.le, USize, instLEUSize, inferInstanceAs, Fin, USize.size, instLEFin, Fin.decLe]]
[List.hasDecEq.proof_2,[False, List.cons, List.nil]]
[implies,[]]
[Char.eq_of_val_eq,[Char.mk, UInt32, Char.val, Eq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl, Char, rfl]]
[Subsingleton.helim,[Subsingleton.helim.proof_1]]
[HEq.subst,[HEq.ndrecOn]]
[Subarray.h₂,[]]
[Std.Format.MonadPrettyFormat.noConfusionType,[]]
[Nat.instShiftLeftNat,[ShiftLeft.mk, Nat, Nat.shiftLeft]]
[emptyRelation,[False]]
[bind_pure,[]]
[ST.Prim.Ref.modify,[Bind.bind, ST, Monad.toBind, instMonadST, Unit, ST.Prim.Ref.get, ST.Prim.Ref.set]]
[Nat.lt_of_le_of_lt,[Nat.le_trans, Nat.succ, Nat.succ_le_succ]]
[Lean.monadNameGeneratorLift,[Lean.MonadNameGenerator.mk, liftM, instMonadLiftT, instMonadLiftT_1, Lean.NameGenerator, Lean.MonadNameGenerator.getNGen, Unit, Lean.MonadNameGenerator.setNGen]]
[ExceptCpsT.instMonadExceptOfExceptCpsT,[MonadExceptOf.mk, ExceptCpsT]]
[decidableOfDecidableOfIff,[dite, Decidable, Decidable.isTrue, Iff.mp, Decidable.isFalse, decidableOfDecidableOfIff.proof_1]]
[String.trim,[Substring.toString, Substring.trim, String.toSubstring]]
[instPowFloatFloat,[Pow.mk, Float, Float.pow]]
[Pow.noConfusionType,[]]
[bind_congr,[of_eq_true, Eq, Bind.bind, Eq.trans, True, congrFun, congrArg, funext, eq_self]]
[Nat.decEq.proof_1,[Eq.refl, Bool, Nat.beq]]
[StateCpsT.runK_lift,[rfl, StateCpsT.runK, StateCpsT.lift]]
[EStateM.instMonadEStateM,[Monad.mk, EStateM, Applicative.mk, Functor.mk, EStateM.map, Pure.mk, EStateM.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, EStateM.seqRight, Bind.mk, EStateM.bind]]
[instOrOpUInt8,[OrOp.mk, UInt8, UInt8.lor]]
[Nat.min,[ite, Nat, LE.le, instLENat, Nat.decLe]]
[instReprTuple,[ReprTuple.mk, List.cons, Std.Format, repr]]
[IO.FS.SystemTime.nsec,[]]
[ReaderT.read,[Pure.pure, Applicative.toPure, Monad.toApplicative]]
[FloatArray.toList,[OfNat.ofNat, Nat, instOfNatNat, List.nil, Float, FloatArray.toList.loop]]
[USize.size,[HPow.hPow, Nat, instHPow, instPowNatNat, OfNat.ofNat, instOfNatNat, System.Platform.numBits]]
[And.left,[]]
[«term_<*_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[unexpandUnit,[Bind.bind, Lean.PrettyPrinter.UnexpandM, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.Syntax, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[instMonadFinallyEIO,[inferInstanceAs, MonadFinally, EStateM, IO.RealWorld, EStateM.instMonadFinallyEStateM]]
[IO.FS.Metadata.modified,[]]
[Lean.Syntax.SepArray.ofElems,[Lean.Syntax.SepArray.mk, Lean.mkSepArray, Lean.mkAtom]]
[CoeHTCT.coe,[]]
[Array.reverse,[OfNat.ofNat, Nat, instOfNatNat, Array.reverse.rev]]
[instHashableUInt64,[Hashable.mk, UInt64]]
[Lean.Syntax.isNodeOf,[and, Lean.Syntax.isOfKind, BEq.beq, Nat, instBEq, instDecidableEqNat, Lean.Syntax.getNumArgs]]
[Std.Format.MonadPrettyFormat.pushOutput,[]]
[PProd.snd,[]]
[USize.decEq.proof_2,[False, USize.mk, absurd, Eq, Fin, USize.size]]
[System.FilePath.parent,[Functor.map, Option, Option.instFunctorOption, String, System.FilePath, System.FilePath.mk, String.Pos, String.extract, System.FilePath.toString, OfNat.ofNat, instOfNatNat, String.revFind, List.contains, Char, instBEq, instDecidableEqChar, System.FilePath.pathSeparators]]
[Fin.sub.proof_1,[LT.lt, Nat, instLTNat, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, HAdd.hAdd, instHAdd, instAddNat, HSub.hSub, instHSub, instSubNat]]
[stdSplit,[StdGen.mk, Prod, StdGen, Prod.mk]]
[Stream.noConfusionType,[]]
[Quotient.inductionOn₃,[Quotient.ind, Quotient.mk]]
[Lean.Eval.noConfusionType,[]]
[CoeFun.noConfusionType,[]]
[Stream.forIn,[Stream.forIn.visit]]
[Lean.instInhabitedMacroScopesView,[Inhabited.mk, Lean.MacroScopesView, Lean.MacroScopesView.mk, arbitrary, Lean.Name, Lean.instInhabitedName, List, Lean.MacroScope, instInhabitedList]]
[instOfNatUInt8,[OfNat.mk, UInt8, UInt8.ofNat]]
[Nat.digitChar,[ite, Char, Eq, Nat, OfNat.ofNat, instOfNatNat, instDecidableEqNat, Char.ofNat]]
[IO.Error.inappropriateType.inj,[And, Eq, Option, String, UInt32, IO.Error.inappropriateType, And.intro]]
[ForIn.forIn,[]]
[Complement.complement,[]]
[Lean.Syntax.node.injEq,[Eq.propIntro, Eq, Lean.Syntax, Lean.Syntax.node, And, Lean.SyntaxNodeKind, Array, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Array.noConfusionType,[]]
[IO.FS.Stream.Buffer.mk.injEq,[Eq.propIntro, Eq, IO.FS.Stream.Buffer, IO.FS.Stream.Buffer.mk, And, ByteArray, Nat, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.Conv.lhs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[instReprSourceInfo,[Repr.mk, Lean.SourceInfo, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, Int, GE.ge, Nat, instLENat, OfNat.ofNat, instOfNatNat, Nat.decLe, Int.instOfNatInt, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, Std.Format.line, reprArg, Substring, instReprSubstring, String.Pos, instReprNat, Std.Format.FlattenBehavior.allOrNone]]
[instOrOpUInt16,[OrOp.mk, UInt16, UInt16.lor]]
[fix1,[fixCore1, arbitrary]]
[Lean.Parser.Tactic.tacticRefine_lift'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[instLEFin,[LE.mk, Fin, LE.le, Nat, instLENat, Fin.val]]
[Std.Format.pretty,[Prod.snd, Unit]]
[Char.isWhitespace,[or, Decidable.decide, Eq, Char, Char.ofNat, instDecidableEqChar]]
[StateT.pure,[Pure.pure, Applicative.toPure, Monad.toApplicative, Prod, Prod.mk]]
[StateRefT'.instMonadStateOfStateRefT',[MonadStateOf.mk, StateRefT', StateRefT'.get, StateRefT'.set, StateRefT'.modifyGet]]
[Array.mk.inj,[Eq, List, Array.mk]]
[instToStringUInt8,[ToString.mk, UInt8, ToString.toString, Nat, instToStringNat, UInt8.toNat]]
[IO.Process.Child.stdin,[]]
[IO.Error.invalidArgument.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Option, String, SizeOf.mk, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar]]
[List.get.proof_1,[Nat.le_of_succ_le_succ, Nat.succ, List.length, Nat, List.cons, LT.lt, instLTNat, List.length_cons]]
[ULift.noConfusionType,[]]
[Fin.isLt,[]]
[Lean.Parser.Tactic.tacticTrivial,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[EStateM.instMonadFinallyEStateM,[MonadFinally.mk, EStateM, EStateM.Result, Prod, Option.some, EStateM.Result.ok, Prod.mk, EStateM.Result.error, Option.none]]
[Lean.NameGenerator.idx,[]]
[UInt64.ofNatCore,[UInt64.mk, Fin.mk, UInt64.size]]
[Lean.numLitKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Syntax.mkNameLit,[Lean.Syntax.mkLit, Lean.nameLitKind]]
[congrArg,[Eq, rfl]]
[Array.mapMUnsafe.map,[ite, Array, PNonScalar, LT.lt, USize, instLTUSize, instDecidableLt_4, Bind.bind, Monad.toBind, unsafeCast, NonScalar, Array.mapMUnsafe.map, HAdd.hAdd, instHAdd, instAddUSize, OfNat.ofNat, instOfNatUSize, Array.uset, lcProof, Nat, instLTNat, USize.toNat, Array.size, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[instToStreamSubarraySubarray,[ToStream.mk, Subarray]]
[Char.toNat,[UInt32.toNat, Char.val]]
[Functor.map,[]]
[List.tailD,[List]]
[EStateM.Backtrackable.restore,[]]
[instNonempty,[instNonempty.proof_1]]
[instReprAtomUInt16,[ReprAtom.mk, UInt16]]
[IO.Error.interrupted.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.interrupted, And, String, UInt32, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Syntax.getOptionalIdent?,[Lean.Syntax, Unit.unit, Option, Lean.Name, Lean.Syntax.getOptional?, Option.some, Lean.Syntax.getId, Option.none]]
[List.below,[PUnit, PProd]]
[Iff.noConfusionType,[]]
[coeOfTail,[CoeHTCT.mk, coeTail]]
[invImage,[WellFoundedRelation.mk, InvImage, WellFoundedRelation.rel, invImage.proof_1]]
[IO.FS.instReprFileType,[Repr.mk, IO.FS.FileType, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, Int, GE.ge, Nat, instLENat, OfNat.ofNat, instOfNatNat, Nat.decLe, Int.instOfNatInt, Std.Format.text, Std.Format.FlattenBehavior.allOrNone]]
[Lean.Parser.Attr.simp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.simpPre, Lean.Parser.Tactic.simpPost, Lean.ParserDescr.cat]]
[Quot.inductionOn,[Quot.ind]]
[Lean.Syntax.SepArray.noConfusionType,[]]
[List.findM?,[Option, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.none, Bind.bind, Monad.toBind, Bool, Option.some, PProd.fst, PUnit, PProd]]
[GT.gt,[LT.lt]]
[LE.le,[]]
[Lean.Parser.Tactic.config,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat]]
[Hashable.hash,[]]
[Substring.trimRight,[Substring.dropRightWhile, Char.isWhitespace]]
[instModUInt64,[Mod.mk, UInt64, UInt64.mod]]
[rfl.proof_1,[Eq.refl]]
[coeOfTCOfTail,[CoeHTCT.mk, coeTail, coeTC]]
[EStateM.throw,[EStateM.Result.error]]
[MonadLiftT.noConfusionType,[]]
[Nat.add_le_add_left,[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, LE.le, instLENat, Nat.le.dest]]
[instOfNatFloat,[OfNat.mk, Float, Float.ofNat]]
[UInt16.toUInt8,[Nat.toUInt8, UInt16.toNat]]
[StateCpsT.runK_bind_get,[rfl, StateCpsT.runK, Bind.bind, StateCpsT, Monad.toBind, StateCpsT.instMonadStateCpsT, MonadState.get, instMonadState, StateCpsT.instMonadStateOfStateCpsT]]
[false_and,[propext, And, False, Iff.intro, And.left, False.elim]]
[List.forIn_cons,[rfl, ForIn.forIn, List, List.instForInList, List.cons]]
[Array.extLit,[Array.ext, Eq.trans, Nat, Array.size, Eq.symm, LT.lt, instLTNat]]
[ByteArray.extract,[ByteArray.copySlice, ByteArray.empty, OfNat.ofNat, Nat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Bool.true]]
[FloatArray.get,[Float, Array.get]]
[TC.accessible,[TC.accessible.proof_1]]
[Lean.Meta.Simp.instInhabitedConfig,[Inhabited.mk, Lean.Meta.Simp.Config, Lean.Meta.Simp.Config.mk, arbitrary, Nat, instInhabitedNat, Bool, instInhabitedBool]]
[StateCpsT.instMonadLiftStateCpsT,[MonadLift.mk, StateCpsT, StateCpsT.lift]]
[CoeSort.coe,[]]
[OptionT.tryCatch,[OptionT.mk, Bind.bind, Monad.toBind, Option, Option.none, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.some, Unit.unit]]
[instToStringFormat,[ToString.mk, Std.Format, Std.Format.pretty, Std.Format.defWidth]]
[Fin.modn_lt,[LT.lt, Nat, instLTNat, Fin.val, HMod.hMod, Fin, Fin.instHModFinNatFin, Nat.lt_of_le_of_lt, Fin.mk, instHMod, Nat.instModNat, Nat.mod_le, Nat.mod_lt]]
[Classical.strongIndefiniteDescription,[dite, Subtype, Exists, Classical.propDecidable, Subtype.mk, Classical.choice, Classical.strongIndefiniteDescription.proof_2]]
[IO.Process.Stdio.inherit.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[instMonadLiftT_1,[MonadLiftT.mk]]
[Unit.unit,[PUnit.unit]]
[List.partitionAux,[Prod, List, List.nil, List.cons, Prod.mk, List.reverse, Unit.unit, PProd.fst, PUnit, PProd]]
[Std.Format.nestD,[Std.Format.nest, Int.ofNat, Std.Format.defIndent]]
[Lean.Name.mkNum.proof_1,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt64.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
[String.intercalate,[String, Unit.unit, String.intercalate.go]]
[instInhabitedUInt64,[Inhabited.mk, UInt64, UInt64.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, instInhabitedUInt64.proof_1]]
[Except.ok.injEq,[Eq.propIntro, Eq, Except, Except.ok, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Fin.ofNat,[Fin.mk, Nat.succ, HMod.hMod, Nat, instHMod, Nat.instModNat, Fin.ofNat.proof_1]]
[IO.Process.Child.mk.inj,[And, Eq, IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdin, IO.Process.StdioConfig.stdout, IO.Process.StdioConfig.stderr, IO.Process.Child.mk, And.intro]]
[Ord.noConfusionType,[]]
[instToStringSigma,[ToString.mk, Sigma, String, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString]]
[IO.FS.Stream.read,[]]
[WellFounded.fixFEq,[WellFounded.fixFEq.proof_1]]
[Fin.ofNat',[Fin.mk, HMod.hMod, Nat, instHMod, Nat.instModNat, Nat.mod_lt]]
[Lean.Parser.Tactic.constructor,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Option.instFunctorOption,[Functor.mk, Option, Option.map]]
[Lean.Parser.Tactic.Conv.«convEnter[__]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.ParserDescr.const, Lean.Parser.Tactic.Conv.enterArg]]
[List.rangeAux,[List, Nat, PProd.fst, PUnit, PProd, List.cons]]
[ByteArray.toList,[OfNat.ofNat, Nat, instOfNatNat, List.nil, UInt8, ByteArray.toList.loop]]
[Lean.Parser.Tactic.Conv.pattern,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.Parser.Tactic.Conv.simpMatch,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Macro.resolveGlobalName,[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, List, Prod, Lean.Name, String, Lean.Macro.getMethods, Lean.Macro.Methods.resolveGlobalName]]
[ReaderT.pure,[Pure.pure, Applicative.toPure, Monad.toApplicative]]
[Exists.elim,[]]
[Lean.Macro.Context.currRecDepth,[]]
[Lean.Syntax.getArg,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Array.getD]]
[List.forM,[PUnit, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, Bind.bind, Monad.toBind, PProd.fst, PProd]]
[List.find?,[Option, Unit.unit, Option.none, Option.some, PProd.fst, PUnit, PProd]]
[Int.decEq.proof_6,[False, Int.negSucc, Int.ofNat]]
[USize.lt,[LT.lt, Fin, USize.size, instLTFin, USize.val]]
[instReprList_1,[Repr.mk, List, Std.Format, List.cons, Std.Format.text, Std.Format.bracketFill, Std.Format.joinSep, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.line]]
[termIfThenElse,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.const]]
[ExceptT.lift,[ExceptT.mk, Functor.map, Applicative.toFunctor, Monad.toApplicative, Except, Except.ok]]
[Nat.gcd,[WellFounded.fix, Nat, WellFoundedRelation.rel, measure, id, Nat.gcd.proof_1, Unit.unit, HMod.hMod, instHMod, Nat.instModNat, Nat.succ, Nat.mod_lt, Nat.zero_lt_succ]]
[Char.quote,[HAppend.hAppend, String, instHAppend, String.instAppendString, Char.quoteCore]]
[instToFormatProd,[Std.ToFormat.mk, Prod, Std.Format, Std.Format.paren, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.ToFormat.format, Std.Format.text, Std.Format.line]]
[EIO.catchExceptions,[IO.RealWorld, EStateM.Result, Empty, EStateM.Result.ok]]
[Array.elem,[Array.contains]]
[Lean.isIdBeginEscape,[Decidable.decide, Eq, Char, Lean.idBeginEscape, instDecidableEqChar]]
[FloatArray.mk.injEq,[Eq.propIntro, Eq, FloatArray, FloatArray.mk, Array, Float, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[instToStringUnit,[ToString.mk, Unit]]
[Lean.Parser.Tactic.locationHyp,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[Nat.one_mul,[Nat, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, Eq, Nat.mul_one, Nat.mul_comm]]
[UInt8.decEq.proof_2,[False, UInt8.mk, absurd, Eq, Fin, UInt8.size]]
[Ne.symm,[Eq.symm]]
[Lean.Name.mkNum,[Lean.Name.num, mixHash, Hashable.hash, Lean.Name, Lean.instHashableName, dite, UInt64, LT.lt, Nat, instLTNat, UInt64.size, Nat.decLt, UInt64.ofNatCore, OfNat.ofNat, instOfNatNat, Lean.Name.mkNum.proof_1]]
[Classical.inhabited_of_nonempty,[Inhabited.mk, Classical.choice]]
[ByteArray.mk.injEq,[Eq.propIntro, Eq, ByteArray, ByteArray.mk, Array, UInt8, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Meta.Simp.Config.memoize,[]]
[randNat,[Nat, Prod, Prod.mk]]
[Fin.decLe,[Nat.decLe, Fin.val]]
[Int.toNat,[Nat, OfNat.ofNat, instOfNatNat]]
[Lean.PrettyPrinter.Unexpander,[Lean.PrettyPrinter.UnexpandM, Lean.Syntax]]
[EStateM.instOrElseEStateM,[OrElse.mk, EStateM, EStateM.orElse]]
[Lean.Parser.Tactic.exact,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[«term_++_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[let_body_congr,[]]
[Classical.choose,[Subtype.val, Classical.indefiniteDescription]]
[Int.instHPowIntNatInt,[HPow.mk, Int, Nat, Int.pow]]
[Except.instMonadExcept,[Monad.mk, Except, Applicative.mk, Functor.mk, Except.map, Pure.mk, Except.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk, Except.bind]]
[bne,[not, BEq.beq]]
[flip,[]]
[Subarray.forM,[Array.forM, Subarray.as, Subarray.start, Subarray.stop]]
[Nat.eq_or_lt_of_le,[Or, Eq, Nat, LT.lt, instLTNat, Nat.zero, Nat.succ, Or.inl, rfl, Or.inr, Nat.succ_le_succ, Nat.zero_le, absurd, LE.le, instLENat, Nat.not_succ_le_zero]]
[UInt8.modn,[UInt8.mk, HMod.hMod, Fin, UInt8.size, Nat, Fin.instHModFinNatFin, UInt8.val]]
[Lean.Syntax.getTailInfo,[Option.getD, Lean.SourceInfo, Lean.Syntax.getTailInfo?, Lean.SourceInfo.none]]
[List.range,[List.rangeAux, List.nil, Nat]]
[List.get!,[Nat.zero, List.nil, Nat.succ, PProd.fst, PUnit, PProd, panicWithPosWithDecl, OfNat.ofNat, Nat, instOfNatNat]]
[fixCore1,[bfix1, USize.size]]
[IO.Error.protocolError.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.protocolError, And, UInt32, String, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[String.contains,[String.any, BEq.beq, Char, instBEq, instDecidableEqChar]]
[Std.Range.instForMRangeNat,[ForM.mk, Std.Range, Nat, Std.Range.forM]]
[System.Platform.numBits_eq,[Subtype.property, Nat, Or, Eq, OfNat.ofNat, instOfNatNat, System.Platform.getNumBits, Unit.unit]]
[System.FilePath.noConfusionType,[]]
[Div.noConfusionType,[]]
[Substring.toNat?,[ite, Option, Nat, Eq, Bool, Substring.isNat, Bool.true, instDecidableEqBool, Option.some, Substring.foldl, HAdd.hAdd, instHAdd, instAddNat, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Char.toNat, Char.ofNat, Option.none]]
[IO.Error.resourceExhausted.inj,[And, Eq, Option, String, UInt32, IO.Error.resourceExhausted, And.intro]]
[Nat.add_one,[rfl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
[IO.FS.SystemTime.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Int, SizeOf.mk, instSizeOfNat, UInt32, Fin, UInt32.size, LT.lt, instLTNat, instSizeOf]]
[bfix3,[PProd.fst, PUnit, PProd]]
[Lean.Syntax.ident.inj,[And, Eq, Lean.SourceInfo, Substring, Lean.Name, List, Prod, String, Lean.Syntax.ident, And.intro]]
[Array.concatMapM,[Array.foldlM, Array, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, HAppend.hAppend, instHAppend, Array.instAppendArray, Array.empty, OfNat.ofNat, Nat, instOfNatNat, Array.size]]
[ByteArray.empty,[ByteArray.mkEmpty, OfNat.ofNat, Nat, instOfNatNat]]
[UInt16.decLt,[UInt16.mk, Decidable, LT.lt, UInt16, instLTUInt16, inferInstanceAs, Fin, UInt16.size, instLTFin, Fin.decLt]]
[Int.instOfNatInt,[OfNat.mk, Int, Int.ofNat]]
[Lean.Parser.Tactic.assumption,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Prod.map,[Prod, Prod.mk]]
[coeSortToCoeTail,[CoeTail.mk, CoeSort.coe]]
[Quotient.rec,[Quot.rec, Setoid.r]]
[and_false,[propext, And, False, Iff.intro, And.right, False.elim]]
[Float.le,[FloatSpec.le, floatSpec, Float.val]]
[IO.FileRight.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, IO.AccessRight, SizeOf.mk, Bool]]
[decide_true_eq_true,[True, Eq, Bool, Decidable.decide, Bool.true, rfl, Decidable.isTrue, False.elim, Decidable.isFalse, True.intro]]
[notM,[Functor.map, Applicative.toFunctor, Bool, not]]
[UInt64.decEq.proof_2,[False, UInt64.mk, absurd, Eq, Fin, UInt64.size]]
[Lean.groupKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[UInt64.mod,[UInt64.mk, HMod.hMod, Fin, UInt64.size, instHMod, Fin.instModFin, UInt64.val]]
[StateT.tryFinally,[MonadFinally.mk, StateT, Bind.bind, Monad.toBind, Prod, MonadFinally.tryFinally', Unit.unit, Option.some, Option.none, Prod.mk, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[Lean.Parser.Tactic.simpPost,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol]]
[EStateM.Result.error.inj,[And, Eq, EStateM.Result.error, And.intro]]
[IO.FS.instBEqSystemTime,[BEq.mk, IO.FS.SystemTime, IO.FS.SystemTime.mk, Bool, and, Bool.true, BEq.beq, Int, instBEq, Int.instDecidableEqInt, UInt32, instDecidableEqUInt32, Bool.false]]
[Lean.defaultMaxRecDepth,[OfNat.ofNat, Nat, instOfNatNat]]
[Lean.Syntax.isIdent,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Bool, Bool.true, Bool.false]]
[Array.eraseIdx'.proof_1,[rfl, Nat, Array.size]]
[StateT.bind,[Bind.bind, Monad.toBind, Prod]]
[Substring.any,[Bool, String.anyAux]]
[Int.natMod,[Int.toNat, HMod.hMod, Int, instHMod, Int.instModInt]]
[Measure,[InvImage, Nat, LT.lt, instLTNat]]
[eq_of_heq,[]]
[Lean.Parser.Tactic.simpErase,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Array.swapAt,[Prod.mk, Array]]
[Nat.zero_lt_succ,[Nat.succ_le_succ, OfNat.ofNat, Nat, instOfNatNat, Nat.zero_le]]
[Fin.mod.proof_1,[LT.lt, Nat, instLTNat, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt]]
[Lean.Name.noConfusionType,[]]
[«term_≠_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[SeqRight.seqRight,[]]
[ST.Ref.take,[liftM, ST, ST.Prim.Ref.take]]
[Task.bind,[Task.pure, Task.get]]
[USize.ofNat32.proof_1,[Eq, Nat, OfNat.ofNat, instOfNatNat, Or.inl, Eq.refl, Unit.unit, Eq.symm, eq_of_heq, HEq.refl, Or.inr, LT.lt, instLTNat, USize.size, usize_size_eq, Nat.lt_trans, of_decide_eq_true, Nat.decLt, Bool, Bool.true]]
[UInt32.mod,[UInt32.mk, HMod.hMod, Fin, UInt32.size, instHMod, Fin.instModFin, UInt32.val]]
[Nat.add_lt_add_left,[Nat.lt_of_succ_le, HAdd.hAdd, Nat, instHAdd, instAddNat, Nat.succ, LE.le, instLENat, Nat.add_le_add_left, Nat.succ_le_of_lt, Nat.add_succ]]
[instInhabitedUInt16.proof_1,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt16.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
[Quot.liftBeta,[rfl, Quot.lift, Quot.mk]]
[optParam,[]]
[IO.Process.Stdio.noConfusion,[noConfusionEnum, IO.Process.Stdio, Nat, instDecidableEqNat, IO.Process.Stdio.toCtorIdx]]
[instStreamRangeNat,[Stream.mk, Std.Range, Nat, ite, Option, Prod, LT.lt, instLTNat, Std.Range.start, Std.Range.stop, Nat.decLt, Option.some, Prod.mk, Std.Range.mk, HAdd.hAdd, instHAdd, instAddNat, Std.Range.step, Option.none]]
[bool,[Unit.unit, ToBool.toBool]]
[UInt16.toUInt64,[Nat.toUInt64, UInt16.toNat]]
[instInhabitedEIO,[inferInstanceAs, Inhabited, EStateM, IO.RealWorld, EStateM.instInhabitedEStateM]]
[ByteArray.append,[ByteArray.copySlice, OfNat.ofNat, Nat, instOfNatNat, ByteArray.size, Bool.false]]
[Lean.version.major,[Unit.unit]]
[instMonadEIO,[inferInstanceAs, Monad, EStateM, IO.RealWorld, EStateM.instMonadEStateM]]
[modifyThe,[MonadStateOf.modifyGet, PUnit, Prod.mk, PUnit.unit]]
[LawfulMonad.toLawfulApplicative,[]]
[Prod.snd,[]]
[String.foldlAux,[String.foldlAux.loop]]
[«term_||_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[System.mkFilePath,[System.FilePath.mk, String.intercalate, Char.toString, System.FilePath.pathSeparator]]
[Lean.isLetterLike,[or, and, Decidable.decide, LE.le, UInt32, instLEUInt32, OfNat.ofNat, instOfNatUInt32, Char.val, instDecidableLe, Ne, instDecidableNot, Eq, instDecidableEqUInt32]]
[IO.FS.Stream.write,[]]
[Thunk.mk.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[«term_<&>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instReprList,[Repr.mk, List, Std.Format, List.cons, Std.Format.text, Std.Format.bracket, Std.Format.joinSep, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.line]]
[StdGen.mk.injEq,[Eq.propIntro, Eq, StdGen, StdGen.mk, And, Nat, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[UInt64.div,[UInt64.mk, HDiv.hDiv, Fin, UInt64.size, instHDiv, Fin.instDivFin, UInt64.val]]
[String.back,[String.get, String.prev, String.bsize]]
[tryFinally,[Functor.map, Prod, Prod.fst]]
[List.beq,[Bool, List.nil, Unit.unit, List.cons, Bool.true, and, BEq.beq, PProd.fst, PUnit, PProd, Bool.false]]
[List.length_replicate.aux,[Eq, Nat, List.length, List.replicate.loop, HAdd.hAdd, instHAdd, instAddNat, of_eq_true, Nat.zero, Eq.trans, True, congrArg, OfNat.ofNat, instOfNatNat, congrFun, Nat.zero_eq, Nat.zero_add, eq_self, List.cons, Nat.succ, congr, List.length_cons, Nat.add_succ, Nat.succ_add]]
[FloatArray.empty,[FloatArray.mkEmpty, OfNat.ofNat, Nat, instOfNatNat]]
[Lean.Macro.withIncRecDepth,[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, MonadReader.read, instMonadReader, instMonadReaderOfReaderT, Unit.unit, BEq.beq, Nat, instBEq, instDecidableEqNat, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth, MonadExcept.throw, instMonadExcept, ReaderT.instMonadExceptOfReaderT, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Lean.Macro.Exception.error, Lean.maxRecDepthErrorMessage, MonadWithReader.withReader, instMonadWithReader, instMonadWithReaderOfReaderT, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Lean.Macro.Context.ref]]
[Nat.mod.inductionOn,[Nat.div.inductionOn]]
[instInhabitedDepArrow,[Inhabited.mk, arbitrary]]
[instDecidableEqUInt64,[UInt64.decEq]]
[ExceptT.seqLeft_eq,[]]
[Lean.Parser.Tactic.tacticShow_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[ofBoolUsing_eq_true,[of_decide_eq_true]]
[Lean.instQuoteSyntax,[Lean.Quote.mk, Lean.Syntax, id]]
[SeqLeft.seqLeft,[]]
[Quotient.ind₂,[Quotient.ind, Quotient.mk]]
[Std.Format.text.inj,[Eq, String, Std.Format.text]]
[Lean.Syntax.ident.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Lean.SourceInfo, instSizeOf, Substring, SizeOf.mk, String, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, UInt32.isValidChar, String.Pos, Lean.Name, instSizeOfName, Prod]]
[rfl,[rfl.proof_1]]
[List.length_replicate,[List.nil, List.length_replicate.aux]]
[Except.ok.inj,[Eq, Except.ok]]
[Lean.Parser.Tactic.anyGoals,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[unexpandProdMk,[ite, Lean.PrettyPrinter.UnexpandM, Lean.Syntax, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.matchesNull, OfNat.ofNat, Nat, instOfNatNat, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
[Nat.sub_succ,[rfl, Nat, HSub.hSub, instHSub, instSubNat, Nat.succ]]
[Std.Range.forIn.loop,[ite, GE.ge, Nat, instLENat, Std.Range.stop, Nat.decLe, Pure.pure, Applicative.toPure, Monad.toApplicative, Unit.unit, Bind.bind, Monad.toBind, ForInStep, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, Std.Range.step]]
[ByteArray.size,[Nat, Array.size, UInt8]]
[Nat.decEq,[Decidable, Eq, Nat, Nat.beq, Nat.decEq.proof_1, Decidable.isTrue, Nat.eq_of_beq_eq_true, Decidable.isFalse, Nat.ne_of_beq_eq_false]]
[List.forIn_nil,[rfl, ForIn.forIn, List, List.instForInList, List.nil]]
[Nat.mod_eq,[Nat, dite, And, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HMod.hMod, instHMod, Nat.instModNat, HSub.hSub, instHSub, instSubNat, Eq, congrFun, WellFounded.fix, WellFoundedRelation.rel, measure, id, WellFoundedRelation.wf, Nat.sub_lt, Nat.lt_of_lt_of_le, WellFounded.fix_eq, ite, dif_eq_if]]
[optionCoe,[CoeTail.mk, Option, Option.some]]
[Array.forIn.loop,[Pure.pure, Applicative.toPure, Monad.toApplicative]]
[Int.decLt,[Decidable, Int.NonNeg, Decidable.isTrue, Int.ofNat, Int.NonNeg.mk, Decidable.isFalse, Int.negSucc, Eq.refl, Int, HEq.refl, False, HSub.hSub, instHSub, Int.instSubInt, HAdd.hAdd, instHAdd, Int.instAddInt, OfNat.ofNat, hasOfNatOfCoe, Nat, instCoeNatInt, instOfNatNat]]
[Array.toListLitAux.proof_1,[Nat.le_of_succ_le, Array.size]]
[LawfulFunctor.noConfusionType,[]]
[Lean.Syntax.isAtom,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Bool, Bool.true, Bool.false]]
[ReprTuple.noConfusionType,[]]
[Nat.lt_wfRel,[WellFoundedRelation.mk, Nat, Nat.lt, Nat.lt_wfRel.proof_1]]
[String.str,[String.push]]
[MonadControl.liftWith,[]]
[instMonadState,[MonadState.mk, getThe, MonadStateOf.set, MonadStateOf.modifyGet]]
[UInt8.decEq,[UInt8.mk, Decidable, Eq, UInt8, dite, Fin, UInt8.size, instDecidableEqFin, Decidable.isTrue, UInt8.decEq.proof_1, Decidable.isFalse, UInt8.decEq.proof_2]]
[instAndOpUSize,[AndOp.mk, USize, USize.land]]
[instReprAtomNat,[ReprAtom.mk, Nat]]
[instHashableUInt32,[Hashable.mk, UInt32, UInt32.toUInt64]]
[instComplementUInt8,[Complement.mk, UInt8, UInt8.complement]]
[List.reverse_append,[Eq, List, List.reverse, HAppend.hAppend, instHAppend, List.instAppendList, of_eq_true, List.nil, Eq.trans, True, congr, congrArg, List.nil_append, List.reverse_nil, List.append_nil, eq_self, Eq.mpr, List.cons, List.cons_append, List.reverse_cons, congrFun, Eq.refl, List.append_assoc, rfl]]
[instHashableProd,[Hashable.mk, Prod, UInt64, mixHash, Hashable.hash]]
[IO.FS.instLESystemTime,[leOfOrd, IO.FS.SystemTime, IO.FS.instOrdSystemTime]]
[Lean.Syntax.setArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.node]]
[String.Iterator.mk.injEq,[Eq.propIntro, Eq, String.Iterator, String.Iterator.mk, And, String, String.Pos, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Monad.toBind,[]]
[Eq.mpr_prop,[Eq.symm]]
[IO.Error.mkResourceBusy,[IO.Error.resourceBusy]]
[StateT.instLawfulMonadStateT.proof_1,[LawfulMonad.mk, StateT, StateT.instMonadStateT, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, StateT.ext, Functor.map, id, of_eq_true, Eq, Prod, StateT.run, Eq.trans, True, congrFun, congrArg, Prod.mk, Prod.fst, Prod.snd, StateT.run_map, funext, id_eq, Prod.ext, id_map', LawfulApplicative.toLawfulFunctor, LawfulMonad.toLawfulApplicative, eq_self, StateT.seqLeft_eq, StateT.seqRight_eq, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, congr, Bind.bind, Monad.toBind, StateT.run_seq, StateT.run_pure, LawfulMonad.pure_bind, Function.comp, Eq.mpr, StateT.run_bind, LawfulMonad.bind_pure_comp, LawfulMonad.bind_assoc]]
[Array.findSome!,[Unit.unit, Array.findSome?, panicWithPosWithDecl, OfNat.ofNat, Nat, instOfNatNat]]
[StateRefT'.run',[Bind.bind, Monad.toBind, Prod, StateRefT'.run, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[UInt16.div,[UInt16.mk, HDiv.hDiv, Fin, UInt16.size, instHDiv, Fin.instDivFin, UInt16.val]]
[«term%[_|_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false]]
[Id.pure_eq,[rfl, Id, Pure.pure, Applicative.toPure, Monad.toApplicative, Id.instMonadId]]
[EStateM.orElse,[EStateM.Result.ok, EStateM.Result, Unit.unit, EStateM.Backtrackable.restore]]
[List.drop,[List, Nat.succ, List.nil, PProd.fst, PUnit, PProd]]
[Nat.lt.base.proof_1,[Nat.le_refl, Nat.succ]]
[ptrAddrUnsafe,[OfNat.ofNat, USize, instOfNatUSize]]
[Char.ofNat.proof_1,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
[System.instInhabitedFilePath,[Inhabited.mk, System.FilePath, System.FilePath.mk, arbitrary, String, String.instInhabitedString]]
[Std.Format.below,[PUnit, PProd]]
[Lean.ParserDescr.noConfusionType,[]]
[Classical.propComplete,[Not, Or, Eq, True, False, Classical.em, Or.inl, propext, Iff.intro, True.intro, Or.inr, False.elim]]
[instMonadWithReaderOfReaderT,[MonadWithReaderOf.mk, ReaderT]]
[EStateM.dummySave,[PUnit.unit]]
[Array.shrink,[HSub.hSub, Nat, instHSub, instSubNat, Array.size, Array.shrink.loop]]
[System.FilePath.pathSeparator,[ite, Char, Eq, Bool, System.Platform.isWindows, Bool.true, instDecidableEqBool, Char.ofNat]]
[instBEqOrdering,[BEq.mk, Ordering, BEq.beq, Nat, instBEq, instDecidableEqNat, Ordering.toCtorIdx]]
[EmptyCollection.emptyCollection,[]]
[List.toArray,[List.toArrayAux, Array.mkEmpty, List.redLength]]
[instModUInt8,[Mod.mk, UInt8, UInt8.mod]]
[Array.forIn.loop.proof_2,[Nat.le_of_lt, Array.size, Nat.lt_of_lt_of_le, Nat.succ, Nat.lt_succ_self]]
[«term_<<<_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instToStringProd,[ToString.mk, Prod, String, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString]]
[Array.shrink.loop,[Array, PProd.fst, PUnit, PProd, Array.pop]]
[Lean.Syntax.isFieldIdx?,[String, Option.none, Option, Nat, Lean.Syntax.isLit?, Lean.Syntax.decodeNatLitVal?, Lean.fieldIdxKind]]
[ST.instInhabitedRef.proof_1,[Nonempty.intro, arbitrary]]
[IO.Error.mkIllegalOperation,[IO.Error.illegalOperation]]
[Function.comp,[]]
[Nat.add,[Nat, Nat.succ, PProd.fst, PUnit, PProd]]
[precMin,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Fin.land.proof_1,[LT.lt, Nat, instLTNat, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, Nat.land]]
[Lean.NameGenerator.mk.injEq,[Eq.propIntro, Eq, Lean.NameGenerator, Lean.NameGenerator.mk, And, Lean.Name, Nat, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[instReprChar,[Repr.mk, Char, Std.Format.text, Char.quote]]
[Subsingleton.elim.proof_1,[Subsingleton.allEq]]
[Prod.rprod,[WellFoundedRelation.mk, Prod, Prod.RProd, WellFoundedRelation.rel, Prod.rprod.proof_1]]
[Subrelation.accessible.proof_1,[Acc, Acc.intro]]
[Classical.byContradiction,[Decidable.byContradiction, Classical.propDecidable]]
[Except.pure,[Except.ok]]
[String.trimRight,[Substring.toString, Substring.trimRight, String.toSubstring]]
[IO.Error.unsupportedOperation.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, UInt32, SizeOf.mk, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, String, List, Char, UInt32.isValidChar]]
[Nat.max,[ite, Nat, LE.le, instLENat, Nat.decLe]]
[Std.Range.start,[]]
[Int.mod,[Int.ofNat, Int.negSucc, Int, HMod.hMod, Nat, instHMod, Nat.instModNat, Nat.succ, Neg.neg, Int.instNegInt]]
[Array.mapMUnsafe,[unsafeCast, Array, PNonScalar, OfNat.ofNat, USize, instOfNatUSize, NonScalar, Array.mapMUnsafe.map]]
[Std.Format.MonadPrettyFormat.endTags,[]]
[IO.FS.SystemTime.sec,[]]
[IO.FileRight.mk.injEq,[Eq.propIntro, Eq, IO.FileRight, IO.FileRight.mk, And, IO.AccessRight, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Std.Format.ibelow,[True, And]]
[Lean.Macro.Context.currMacroScope,[]]
[Array.instReprArray,[Repr.mk, Array, Std.Format, ite, Eq, Bool, BEq.beq, Nat, instBEq, instDecidableEqNat, Array.size, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Std.Format.text, Std.Format.bracketFill, Std.Format.joinSep, Array.toList, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.line]]
[FloatSpec.float,[]]
[Acc.brecOn,[Acc.below, Acc.below.intro]]
[instSubsingletonStateM.proof_1,[Subsingleton.intro, StateM, funext, Id, Prod, Prod.mk, Eq, Eq.mpr, Eq.refl, Subsingleton.elim, rfl]]
[Lean.mkNullNode,[Lean.Syntax.node, Lean.nullKind]]
[Lean.expandBrackedBindersAux.loop,[Lean.MacroM, Lean.Syntax, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Bind.bind, Monad.toBind, Lean.expandExplicitBindersAux, Option.some, PProd.fst, PUnit, PProd]]
[MProd.fst,[]]
[IO.Error.mkInvalidArgumentFile,[Function.comp, String, Option, IO.Error, IO.Error.invalidArgument, Option.some]]
[ExceptCpsT.instLawfulMonadExceptCpsT,[ExceptCpsT.instLawfulMonadExceptCpsT.proof_1]]
[instXorUSize,[Xor.mk, USize, USize.xor]]
[instToStringIterator,[ToString.mk, String.Iterator, String.Iterator.remainingToString]]
[Lean.Macro.instMonadRefMacroM,[Lean.MonadRef.mk, Lean.MacroM, Bind.bind, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Syntax, MonadReader.read, instMonadReader, instMonadReaderOfReaderT, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Macro.Context.ref, MonadWithReader.withReader, instMonadWithReader, instMonadWithReaderOfReaderT, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth]]
[Squash.lift.proof_1,[Subsingleton.elim]]
[Std.Format.instCoeStringFormat,[Coe.mk, String, Std.Format, Std.Format.text]]
[ReprTuple.reprTuple,[]]
[instDivUSize,[Div.mk, USize, USize.div]]
[Quotient.mk,[Quot.mk, Setoid.r]]
[instDecidableEqUInt8,[UInt8.decEq]]
[Nat.instAndOpNat,[AndOp.mk, Nat, Nat.land]]
[instReprUInt8,[Repr.mk, UInt8, repr, Nat, instReprNat, UInt8.toNat]]
[IO.Error.resourceExhausted.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Option, String, SizeOf.mk, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar]]
[Lean.Parser.Tactic.Conv.arg,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Option.isSome,[Unit.unit, Bool, Bool.true, Bool.false]]
[ShiftLeft.shiftLeft,[]]
[List.init,[List, Unit.unit, List.cons, List.nil, PProd.fst, PUnit, PProd]]
[IO.println,[IO.print, String, instToStringString, String.push, ToString.toString, Char.ofNat]]
[Array.swap!,[dite, Array, LT.lt, Nat, instLTNat, Array.size, Nat.decLt, Array.swap, Fin.mk, panicWithPosWithDecl, Array.instInhabitedArray, OfNat.ofNat, instOfNatNat]]
[IO.Error.mkNoSuchThingFile,[Function.comp, String, Option, IO.Error, IO.Error.noSuchThing, Option.some]]
[Lean.Syntax.getOptional?,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Option, Lean.Syntax, ite, Eq, Bool, and, BEq.beq, Lean.SyntaxNodeKind, Lean.Name.instBEqName, Lean.nullKind, Nat, instBEq, instDecidableEqNat, Array.size, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Option.some, Array.get!, Lean.instInhabitedSyntax, Option.none]]
[Char.lt,[LT.lt, UInt32, instLTUInt32, Char.val]]
[instAndOpUInt32,[AndOp.mk, UInt32, UInt32.land]]
[FloatSpec.val,[]]
[instHashableString,[Hashable.mk, String, String.hash]]
[IO.Error.mkAlreadyExistsFile,[Function.comp, String, Option, IO.Error, IO.Error.alreadyExists, Option.some]]
[IO.FS.Mode.write.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[ExceptCpsT.instMonadExceptCpsT,[Monad.mk, ExceptCpsT, Applicative.mk, Functor.mk, Pure.mk, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk]]
[instDecidableIff,[dite, Decidable, Iff, Decidable.isTrue, instDecidableIff.proof_1, Decidable.isFalse, instDecidableIff.proof_2, instDecidableIff.proof_3, instDecidableIff.proof_4]]
[String.map,[String.mapAux, OfNat.ofNat, String.Pos, instOfNatNat]]
[Lean.Parser.Tactic.Conv.convRight,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[instLTUInt8,[LT.mk, UInt8, UInt8.lt]]
[DoResultBC.break.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[Lean.expandBrackedBinders,[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Syntax, Lean.MonadRef.getRef, Lean.Macro.instMonadRefMacroM, Lean.expandBrackedBindersAux, List.toArray, List.cons, List.nil]]
[Nat.lt_of_succ_lt,[Nat.le_of_succ_le, HAdd.hAdd, Nat, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
[«term↑_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Name.toString,[Lean.Name.toStringWithSep, and, not, Lean.Name.isInaccessibleUserName, Lean.Name.hasMacroScopes, Lean.Name.toString.maybePseudoSyntax]]
[Nat.succ.injEq,[Eq.propIntro, Eq, Nat, Nat.succ, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Int.neg,[Int, Int.negOfNat, Int.ofNat, Nat.succ]]
[ReaderT.instLawfulMonadReaderT.proof_1,[LawfulMonad.mk, ReaderT, ReaderT.instMonadReaderT, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, ReaderT.ext, Functor.map, id, of_eq_true, Eq, ReaderT.run, Eq.trans, True, congrFun, congrArg, ReaderT.run_map, LawfulFunctor.id_map, LawfulApplicative.toLawfulFunctor, LawfulMonad.toLawfulApplicative, eq_self, SeqLeft.seqLeft, Applicative.toSeqLeft, Seq.seq, Applicative.toSeq, Function.const, Eq.mpr, congr, ReaderT.run_seqLeft, ReaderT.run_seq, LawfulApplicative.seqLeft_eq, SeqRight.seqRight, Applicative.toSeqRight, ReaderT.run_seqRight, LawfulApplicative.seqRight_eq, Pure.pure, Applicative.toPure, ReaderT.run_pure, LawfulApplicative.pure_seq, Bind.bind, Monad.toBind, Function.comp, ReaderT.run_bind, funext, LawfulMonad.bind_pure_comp, LawfulMonad.pure_bind, LawfulMonad.bind_assoc]]
[Lean.MonadRef.withRef,[]]
[Nat.allM.loop,[Bool, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.true, Bind.bind, Monad.toBind, HSub.hSub, Nat, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, PProd.fst, PUnit, PProd, Bool.false]]
[HEq.rfl,[HEq.rfl.proof_1]]
[StateT.run_bind,[bind_congr, Prod, Monad.toBind, Prod.fst, Prod.snd, Eq, Prod.mk, rfl, Eq.symm, Eq.refl]]
[UInt8.toNat,[Fin.val, UInt8.size, UInt8.val]]
[IO.AccessRight.write,[]]
[Lean.Syntax.instToStringSyntax,[ToString.mk, Lean.Syntax, Function.comp, Std.Format, String, ToString.toString, instToStringFormat, Std.ToFormat.format, Lean.Syntax.instToFormatSyntax]]
[«term_>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Name.isInaccessibleUserName,[Bool, Lean.Name.anonymous, or, String.contains, Char.ofNat, BEq.beq, String, instBEq, instDecidableEqString, PProd.fst, PUnit, PProd, Bool.false]]
[UInt32.val,[]]
[List.any,[List.foldr, Bool, or, Bool.false]]
[Nat.toSuperscriptString,[List.asString, Nat.toSuperDigits]]
[Id.finally,[MonadFinally.mk, Id, Pure.pure, Applicative.toPure, Monad.toApplicative, Id.instMonadId, Prod, Prod.mk]]
[EStateM.nonBacktrackable,[EStateM.Backtrackable.mk, PUnit, EStateM.dummySave, EStateM.dummyRestore]]
[UInt64.add,[UInt64.mk, HAdd.hAdd, Fin, UInt64.size, instHAdd, Fin.instAddFin, UInt64.val]]
[instDecidableEqProd,[Decidable, Eq, Prod, Prod.mk, decEq, Decidable.isTrue, instDecidableEqProd.proof_1, Decidable.isFalse, instDecidableEqProd.proof_2, instDecidableEqProd.proof_3]]
[List.unzip,[Prod, List, Unit.unit, List.cons, Prod.mk, List.nil, PProd.fst, PUnit, PProd]]
[Nat.gt_of_not_le,[LT.lt, Nat, instLTNat, GE.ge, instLENat, GT.gt, Nat.lt_or_ge, absurd]]
[Bool.toUInt64,[ite, UInt64, Eq, Bool, Bool.true, instDecidableEqBool, OfNat.ofNat, instOfNatUInt64]]
[emptyWf.proof_1,[WellFounded.intro, emptyRelation, Acc.intro, Acc, Eq.refl]]
[Quot.recOnSubsingleton,[Quot.rec, Quot.recOnSubsingleton.proof_1]]
[StateCpsT.runK_bind_pure,[rfl, StateCpsT.runK, Bind.bind, StateCpsT, Monad.toBind, StateCpsT.instMonadStateCpsT, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[USize.div,[USize.mk, HDiv.hDiv, Fin, USize.size, instHDiv, Fin.instDivFin, USize.val]]
[CoeFun.coe,[]]
[Array.set,[Array.mk, List.set, Array.data, Fin.val, Array.size]]
[Array.map,[Id.run, Array, Array.mapM, Id, Id.instMonadId]]
[instDecidableEqSum.proof_2,[False, Sum.inl, absurd, Eq]]
[Int.instLEInt,[LE.mk, Int, Int.le]]
[FloatSpec.lt,[]]
[OptionT.instMonadExceptOfUnitOptionT,[MonadExceptOf.mk, Unit, OptionT, OptionT.fail, OptionT.tryCatch]]
[Array.mapM,[Array.foldlM, Array, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.push, Array.mkEmpty, Array.size, OfNat.ofNat, Nat, instOfNatNat]]
[Array.getD,[dite, LT.lt, Nat, instLTNat, Array.size, Nat.decLt, Array.get, Fin.mk]]
[System.instDecidableEqFilePath,[System.FilePath.mk, Decidable, Eq, System.FilePath, dite, String, instDecidableEqString, Decidable.isTrue, rfl, Decidable.isFalse, False]]
[Lean.nameLitKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[reprArg,[Repr.reprPrec, OfNat.ofNat, Nat, instOfNatNat]]
[Array.mkEmpty,[Array.mk, List.nil]]
[Or.intro_left,[Or.inl]]
[Ne.elim,[]]
[ST.mkRef,[liftM, ST, ST.Ref, ST.Prim.mkRef]]
[Subarray.start,[]]
[Eq.substr,[Eq.symm]]
[Array.sequenceMap.loop,[Array, dite, LT.lt, Nat, instLTNat, Array.size, Nat.decLt, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Bind.bind, Monad.toBind, Array.get, Fin.mk, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.push]]
[instDecidableEqUInt32,[UInt32.decEq]]
[hasOfNatOfCoe,[OfNat.mk, coe, OfNat.ofNat, coeOfHTCT, coeOfTC, coeBase]]
[String.nextUntil,[String.nextWhile, not]]
[«stx_<|>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Syntax.toNat,[Nat, Unit.unit, Lean.Syntax.isNatLit?, OfNat.ofNat, instOfNatNat]]
[MonadExceptOf.tryCatch,[]]
[PSigma.lexNdepWf.proof_1,[WellFounded.intro, PSigma, PSigma.lexNdep, Acc, PSigma.lexAccessible, WellFounded.apply]]
[IO.Error.unsupportedOperation.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.unsupportedOperation, And, UInt32, String, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[ReaderT.run_monadLift,[rfl, ReaderT.run, MonadLiftT.monadLift, ReaderT, instMonadLiftT, ReaderT.instMonadLiftReaderT]]
[Lean.unbracketedExplicitBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.binderIdent, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat]]
[Fin.decLt,[Nat.decLt, Fin.val]]
[HShiftRight.noConfusionType,[]]
[Lean.Name.num.injEq,[Eq.propIntro, Eq, Lean.Name, Lean.Name.num, And, Nat, UInt64, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[List.filterM,[Bind.bind, Monad.toBind, List, List.filterAuxM, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, List.reverse]]
[instXorUInt16,[Xor.mk, UInt16, UInt16.xor]]
[PSigma.lexAccessible,[PSigma.lexAccessible.proof_1]]
[Nat.forM.loop,[Unit, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Bind.bind, Monad.toBind, HSub.hSub, Nat, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, PProd.fst, PUnit, PProd]]
[PUnit.unit.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[List.isEqv,[Bool, List.nil, List.cons, Bool.true, and, PProd.fst, PUnit, PProd, Bool.false]]
[Nat.mul_lt_mul_of_pos_right,[Nat, HMul.hMul, instHMul, instMulNat, LT.lt, instLTNat, Nat.mul_lt_mul_of_pos_left, Nat.mul_comm]]
[IO.Error.mkAlreadyExists,[IO.Error.alreadyExists, Option.none, String]]
[unexpandSorryAx,[ite, Lean.PrettyPrinter.UnexpandM, Lean.Syntax, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.matchesNull, OfNat.ofNat, Nat, instOfNatNat, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
[Nat.mul,[Nat, OfNat.ofNat, instOfNatNat, Nat.add, PProd.fst, PUnit, PProd]]
[Nat.add_right_cancel,[Nat.add_left_cancel, Eq.mp, Eq, Nat, HAdd.hAdd, instHAdd, instAddNat, Eq.refl, Nat.add_comm]]
[Substring.splitOn,[ite, List, Substring, Eq, Bool, BEq.beq, optParam, String, instBEq, instDecidableEqString, Bool.true, instDecidableEqBool, List.cons, List.nil, OfNat.ofNat, String.Pos, instOfNatNat, Substring.splitOn.loop]]
[Lean.Syntax.decodeNatLitVal?,[ite, Option, Nat, Eq, Bool, BEq.beq, instBEq, instDecidableEqNat, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Option.none, Char, instDecidableEqChar, Char.ofNat, Option.some, or, String.Pos, Char.isDigit]]
[ite_congr,[Not, Eq, ite, Decidable.em, Or, Or.inl, Eq.mpr, Eq.refl, if_pos, Eq.symm, Or.inr, if_neg]]
[Lean.replaceRef,[String.Pos, Option.none, Lean.Syntax, Lean.Syntax.getPos?, Bool.false]]
[instReprUInt64,[Repr.mk, UInt64, repr, Nat, instReprNat, UInt64.toNat]]
[instDecidableEqChar,[Eq, UInt32, Char.val, Decidable, Char, decEq, instDecidableEqUInt32, Decidable.isTrue, Char.eq_of_val_eq, Decidable.isFalse, Char.ne_of_val_ne]]
[instToStringPUnit,[ToString.mk, PUnit]]
[Lean.Meta.Simp.Config.decide,[]]
[OptionT.instMonadOptionT,[Monad.mk, OptionT, Applicative.mk, Functor.mk, Pure.mk, OptionT.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk, OptionT.bind]]
[Lean.Syntax.mkStrLit,[Lean.Syntax.mkLit, Lean.strLitKind, String.quote]]
[instXorUInt8,[Xor.mk, UInt8, UInt8.xor]]
[Lean.nullKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Option.toBool,[Unit.unit, Bool, Bool.true, Bool.false]]
[true_or,[propext, Or, True, Iff.intro, trivial, Or.inl]]
[instTransEq_1,[Trans.mk, Eq, instTransEq_1.proof_1]]
[ForInStep.yield.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[Lean.Name.modifyBase,[ite, Lean.Name, Eq, Bool, Lean.Name.hasMacroScopes, Bool.true, instDecidableEqBool, Lean.MacroScopesView.review, Lean.MacroScopesView.mk, Lean.MacroScopesView.name, Lean.MacroScopesView.imported, Lean.MacroScopesView.mainModule, Lean.MacroScopesView.scopes]]
[IO.Error.mkEofError,[IO.Error.unexpectedEof]]
[Array.data,[]]
[instToStringId_1,[inferInstanceAs, ToString]]
[ST.Ref.ptrEq,[liftM, ST, Bool, ST.Prim.Ref.ptrEq]]
[String.find,[String.findAux, String.bsize, OfNat.ofNat, String.Pos, instOfNatNat]]
[Array.insertionSort.swapLoop.proof_2,[Eq.mpr, LT.lt, Nat, instLTNat, Array.size, Array.swap, Fin.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Nat.lt_trans, Nat.succ, Nat.lt_succ_self, Eq.symm, Eq, Eq.refl, Array.size_swap]]
[Lean.expandExplicitBindersAux,[Array.size, Lean.Syntax, Lean.expandExplicitBindersAux.loop]]
[id_map',[LawfulFunctor.id_map]]
[Lean.Parser.Tactic.refine',[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.Meta.Rewrite.Config.mk.inj,[And, Eq, Lean.Meta.TransparencyMode, Bool, Lean.Meta.Rewrite.Config.mk, And.intro]]
[ExceptT.run_map,[Eq.mpr, Eq, Except, ExceptT.run, Functor.map, ExceptT, Applicative.toFunctor, Monad.toApplicative, ExceptT.instMonadExceptT, Except.map, ExceptT.mk, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Except.ok, Except.error, congrArg, map_eq_pure_bind, bind_congr, of_eq_true, eq_self, Eq.symm, Eq.refl]]
[Array.insertAt,[ite, Array, GT.gt, Nat, instLTNat, Array.size, Nat.decLt, panicWithPosWithDecl, Array.instInhabitedArray, OfNat.ofNat, instOfNatNat, Array.insertAtAux]]
[Lean.MonadRef.noConfusionType,[]]
[instOrdUInt8,[Ord.mk, UInt8, compareOfLessAndEq, instLTUInt8, instDecidableLt_1, instDecidableEqUInt8]]
[Array.foldrM.fold.proof_2,[Nat.le_of_lt, Array.size, Nat.lt_of_lt_of_le, Nat.succ, Nat.lt_succ_self]]
[Nat.toDigits,[Nat.toDigitsCore, HAdd.hAdd, Nat, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, List.nil, Char]]
[UInt8.decEq.proof_1,[Fin, UInt8.size, Eq, UInt8, UInt8.mk, rfl]]
[WellFounded.fixFEq.proof_1,[Eq, WellFounded.fixF, Acc.inv, rfl, Acc.intro]]
[Std.instInhabitedFormat,[Inhabited.mk, Std.Format, Std.Format.nil]]
[instDecidableEqPUnit,[Decidable.isTrue, Eq, PUnit, PUnit.subsingleton]]
[ShiftLeft.noConfusionType,[]]
[UInt8.ofNatCore,[UInt8.mk, Fin.mk, UInt8.size]]
[List.length_concat,[Eq, Nat, List.length, List.concat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, rfl, List.nil, of_eq_true, List.cons, Eq.trans, Nat.succ, True, congr, congrArg, List.length_cons, congrFun, eq_self]]
[System.Platform.isOSX,[System.Platform.getIsOSX, Unit.unit]]
[Lean.Name.toStringWithSep,[String, Unit.unit, Lean.Name.str, Lean.Name.num, Lean.Name.toStringWithSep.maybeEscape, ToString.toString, Nat, instToStringNat, HAppend.hAppend, instHAppend, String.instAppendString, PProd.fst, PUnit, PProd, Nat.repr]]
[EStateM.bind,[EStateM.Result, EStateM.Result.error]]
[Lean.Parser.Tactic.injection,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[USize.land,[USize.mk, Fin.land, USize.size, USize.val]]
[Lean.Parser.Tactic.done,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Parser.Tactic.tacticErw__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.Parser.Tactic.location]]
[IO.Process.SpawnArgs.toStdioConfig,[]]
[Array.ofSubarray,[Bind.bind, Id, Monad.toBind, Id.instMonadId, Array, ForIn.forIn, Subarray, Subarray.instForInSubarray, PUnit, ForInStep, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, ForInStep.yield]]
[instToStringFloatArray,[ToString.mk, FloatArray, List.toString, Float, instToStringFloat, FloatArray.toList]]
[«term~~~_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Array.findIdx?.loop,[Option, Nat, dite, LT.lt, instLTNat, Array.size, Nat.decLt, False.elim, Array.findIdx?.loop.proof_1, ite, Eq, Bool, Array.get, Fin.mk, Bool.true, instDecidableEqBool, Option.some, Option.none]]
[Option.eq_none_of_isNone,[Bool, Option.isNone, Option.some, Bool.true, Bool.false, Eq.refl, HEq.refl, Eq, Option, Option.none, rfl]]
[Sum.inr.inj,[Eq, Sum.inr]]
[PSigma.snd,[]]
[Nat.mod,[WellFounded.fix, Nat, WellFoundedRelation.rel, measure, id, Nat.mod.proof_1, dite, And, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HSub.hSub, instHSub, instSubNat, Nat.sub_lt, Nat.lt_of_lt_of_le]]
[StateRefT'.lift,[]]
[IO.FS.Mode.toCtorIdx,[Nat, OfNat.ofNat, instOfNatNat]]
[Array.pop,[Array.mk, List.dropLast, Array.data]]
[«term¬_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.add_left_comm,[Eq.mpr, Eq, Nat, HAdd.hAdd, instHAdd, instAddNat, Eq.refl, Eq.symm, Nat.add_assoc, Nat.add_comm, rfl]]
[Lean.SourceInfo.getPos?,[Lean.SourceInfo.synthetic, Bool.true, Lean.SourceInfo.none, Option, String.Pos, Option.some, Option.none]]
[CoeDep.noConfusionType,[]]
[Lean.Meta.Simp.ConfigCtx.noConfusionType,[]]
[Std.Format.instInhabitedSpaceResult,[Inhabited.mk, arbitrary, Bool, instInhabitedBool, Nat, instInhabitedNat]]
[Fin.instInhabitedFinHAdd,[Inhabited.mk, Fin, OfNat.ofNat, Fin.instOfNatFinHAdd]]
[Lean.Syntax.node.sizeOf_spec,[congrArg, Nat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, SizeOf.sizeOf, Lean.SyntaxNodeKind, instSizeOfName, Lean.SourceInfo, instSizeOf, String, SizeOf.mk, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, UInt32.isValidChar, Substring, String.Pos, Lean.Name, Prod, Array, Lean.Syntax, Nat.add, Eq, Eq.trans, Array.mk, Eq.refl, List.nil, List.cons, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec]]
[Lean.Parser.Tactic.tacticAdmit,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[type_eq_of_heq.proof_1,[HEq.ndrecOn, Eq, Eq.refl]]
[Prod.anyI,[Nat.anyAux, Prod.snd, Nat, HSub.hSub, instHSub, instSubNat, Prod.fst]]
[Lean.Parser.Tactic.clear,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[Lean.Macro,[Lean.MacroM, Lean.Syntax]]
[UInt32.add,[UInt32.mk, HAdd.hAdd, Fin, UInt32.size, instHAdd, Fin.instAddFin, UInt32.val]]
[Nat.mod_lt,[Nat.mod.inductionOn, LT.lt, Nat, instLTNat, HMod.hMod, instHMod, Nat.instModNat]]
[HasEquiv.Equiv,[]]
[Repr.reprPrec,[]]
[StateT.orElse,[HOrElse.hOrElse, Prod, instHOrElse, instOrElse, Unit.unit]]
[Lean.Parser.Tactic.Conv.convApply_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Except.error.inj,[Eq, Except.error]]
[Lean.instQuoteBool,[Lean.Quote.mk, Bool, Unit.unit, Lean.Syntax, Lean.mkCIdent, Lean.Name.mkStr, Lean.Name.anonymous]]
[Std.Range.«term[_:_:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Char.noConfusionType,[]]
[Int.instAddInt,[Add.mk, Int, Int.add]]
[Array.forRevM,[Array.foldrM, PUnit, PUnit.unit]]
[Classical.typeDecidableEq,[inferInstance, Decidable, Eq, Classical.propDecidable]]
[instForIn,[ForIn.mk, Stream.forIn]]
[Nat.lt_succ_of_le,[Nat.succ_le_succ]]
[instReprAtomUInt32,[ReprAtom.mk, UInt32]]
[Complement.noConfusionType,[]]
[IO.Error.protocolError.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, UInt32, SizeOf.mk, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, String, List, Char, UInt32.isValidChar]]
[IO.mapTasks,[List.nil, IO.mapTasks.go]]
[IO.Error.alreadyExists.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.alreadyExists, And, Option, String, UInt32, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[instOfNatUInt32,[OfNat.mk, UInt32, UInt32.ofNat]]
[instDecidableArrow.proof_3,[absurd]]
[UInt32.toNat,[Fin.val, UInt32.size, UInt32.val]]
[Eq.propIntro,[propext, Iff.intro]]
[LawfulApplicative.noConfusionType,[]]
[Quotient.exact,[Quotient, Quotient.liftOn₂, HasEquiv.Equiv, instHasEquiv, propext, Iff.intro, Setoid.trans, Setoid.symm, Quot.inductionOn, Setoid.r, Setoid.refl, Quotient.mk]]
[Array.swap.proof_1,[Eq.symm, Nat, Array.size, Array.set, Array.get, Array.size_set]]
[«term_>=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Char.instDecidableLe,[UInt32.decLe, Char.val]]
[ByteArray.findIdx?,[ByteArray.findIdx?.loop]]
[Lean.Name.hasMacroScopes,[Bool, Lean.Name.anonymous, BEq.beq, String, instBEq, instDecidableEqString, PProd.fst, PUnit, PProd, Bool.false]]
[Array.instCoeSubarrayArray,[Coe.mk, Subarray, Array, Array.ofSubarray]]
[instMonadLiftT,[MonadLiftT.mk, MonadLift.monadLift, MonadLiftT.monadLift]]
[Std.Format.tag.inj,[And, Eq, Nat, Std.Format, Std.Format.tag, And.intro]]
[Nat.gcd.proof_1,[WellFoundedRelation.wf, Nat, measure, id]]
[Applicative.toPure,[]]
[strictOr,[or]]
[IO.FS.writeFile,[Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle, Unit, IO.FS.Handle.mk, IO.FS.Mode.write, Bool.false, IO.FS.Handle.putStr]]
[Nat.lt_or_ge,[Or, LT.lt, Nat, instLTNat, GE.ge, instLENat, Unit.unit, Or.inr, Nat.zero, Nat.zero_le, Nat.succ, PProd.fst, PUnit, PProd, Or.inl, Nat.le_succ_of_le, Eq, Nat.eq_or_lt_of_le, Nat.le_refl]]
[IO.FS.SystemTime.mk.injEq,[Eq.propIntro, Eq, IO.FS.SystemTime, IO.FS.SystemTime.mk, And, Int, UInt32, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.Parser.Tactic.Conv.conv.quot,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[String.Iterator.mk.inj,[And, Eq, String, String.Pos, String.Iterator.mk, And.intro]]
[instLEUInt8,[LE.mk, UInt8, UInt8.le]]
[Id,[]]
[IO.Error.invalidArgument.inj,[And, Eq, Option, String, UInt32, IO.Error.invalidArgument, And.intro]]
[Add.noConfusionType,[]]
[ne_false_of_eq_true,[Not, Eq, Bool, Bool.false, False, Bool.true]]
[toBoolUsing,[Decidable.decide]]
[Xor.xor,[]]
[Std.Format.noConfusionType,[]]
[Lean.Name.below,[PUnit, PProd]]
[Substring.hasBeq,[BEq.mk, Substring, Substring.beq]]
[Array.appendList,[List.foldl, Array, Array.push]]
[System.FilePath.isRelative,[not, System.FilePath.isAbsolute]]
[Char.toUpper,[ite, Char, And, GE.ge, Nat, instLENat, OfNat.ofNat, instOfNatNat, LE.le, instDecidableAnd, Nat.decLe, Char.ofNat, HSub.hSub, instHSub, instSubNat]]
[IO.print,[Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Stream, Unit, IO.getStdout, IO.FS.Stream.putStr, ToString.toString]]
[Prod.ext,[Eq, Prod, Prod.mk, Prod.fst, Prod.snd, rfl, Eq.symm, Eq.refl]]
[instDecidableEqSum.proof_4,[False, Sum.inr, absurd, Eq]]
[List.toFloatArray.loop,[Float, FloatArray, PProd.fst, PUnit, PProd, FloatArray.push]]
[String.decEq,[String.mk, Decidable, Eq, String, dite, List, Char, instDecidableEqList, instDecidableEqChar, Decidable.isTrue, String.decEq.proof_1, Decidable.isFalse, String.decEq.proof_2]]
[IO.FS.Mode.read.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[id.def,[rfl, id]]
[System.FilePath.mk.injEq,[Eq.propIntro, Eq, System.FilePath, System.FilePath.mk, String, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[StateT.ext,[funext, Prod]]
[Char.ofNat,[dite, Char, Nat.isValidChar, instDecidableOr, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, And, Nat.decLt, instDecidableAnd, Char.mk, UInt32.mk, Fin.mk, UInt32.size, Or.inr, Nat.lt_trans, of_decide_eq_true, Eq.refl, Bool, Bool.true, Char.ofNat.proof_1, Char.ofNat.proof_2]]
[Subarray.anyM,[Array.anyM, Subarray.as, Subarray.start, Subarray.stop]]
[instDecidableLt_2,[UInt16.decLt]]
[Prod.mk.inj,[And, Eq, Prod.mk, And.intro]]
[Array.qsort,[Array.qsort.sort]]
[subtypeCoe,[CoeHead.mk, Subtype, Subtype.val]]
[pure_id_seq,[of_eq_true, Eq, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, id, Eq.trans, True, congrFun, congrArg, Functor.map, Applicative.toFunctor, LawfulApplicative.pure_seq, LawfulFunctor.id_map, LawfulApplicative.toLawfulFunctor, eq_self]]
[Char.ofNat.proof_2,[Or.inl, LT.lt, Nat, instLTNat, UInt32.toNat, UInt32.mk, Fin.mk, UInt32.size, OfNat.ofNat, instOfNatNat, of_decide_eq_true, Nat.decLt, Eq.refl, Bool, Bool.true, And]]
[Subsingleton.helim.proof_1,[HEq, heq_of_eq, Subsingleton.elim]]
[withPtrEqDecEq.proof_3,[ofBoolUsing_eq_false, Eq, Unit.unit]]
[«term_<|>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Parser.Tactic.rwRuleSeq,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.rwRule, Bool.true]]
[instHAnd,[HAnd.mk, AndOp.and]]
[Lean.MacroScope,[Nat]]
[Lean.Parser.Tactic.discharger,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Div.div,[]]
[Std.Format.text.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, String, SizeOf.mk, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar]]
[Nat.below,[PUnit, PProd]]
[String.get,[Char, arbitrary, Char.instInhabitedChar, ite, Eq, String.Pos, instDecidableEqNat, PProd.fst, PUnit, PProd, HAdd.hAdd, Nat, instHAdd, instAddNat, String.csize, OfNat.ofNat, instOfNatNat]]
[map_eq_pure_bind,[Eq.mpr, Eq, Functor.map, Applicative.toFunctor, Monad.toApplicative, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Function.comp, Eq.refl, Eq.symm, LawfulMonad.bind_pure_comp, rfl]]
[Lean.Parser.Tactic.first,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[Classical.«tacticByCases__:_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[List.foldl,[PProd.fst, PUnit, PProd]]
[«stx_,+»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
[ReaderT.run_bind,[rfl, ReaderT.run, Bind.bind, ReaderT, Monad.toBind, ReaderT.instMonadReaderT]]
[instModUInt16,[Mod.mk, UInt16, UInt16.mod]]
[Lean.Meta.instReprTransparencyMode,[Repr.mk, Lean.Meta.TransparencyMode, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, Int, GE.ge, Nat, instLENat, OfNat.ofNat, instOfNatNat, Nat.decLe, Int.instOfNatInt, Std.Format.text, Std.Format.FlattenBehavior.allOrNone]]
[Char.utf8Size.proof_4,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
[Nat.add_lt_add,[Nat.lt_trans, HAdd.hAdd, Nat, instHAdd, instAddNat, Nat.add_lt_add_right, Nat.add_lt_add_left]]
[instInhabitedUInt32.proof_1,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
[Lean.Parser.Tactic.expandRwSeq,[Lean.Parser.Tactic.rwWithRfl, Lean.Name.mkStr, Lean.Name.anonymous]]
[«term_^_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Float.ofInt,[Float, Float.ofNat, Float.neg, Nat.succ]]
[UInt8.le,[LE.le, Fin, UInt8.size, instLEFin, UInt8.val]]
[forall_congr,[]]
[Repr.noConfusionType,[]]
[List.reverseAux_reverseAux,[Eq, List, List.reverseAux, List.nil, rfl, of_eq_true, List.cons, Eq.trans, True, congr, congrArg, eq_self]]
[panicWithPosWithDecl,[panic, HAppend.hAppend, String, instHAppend, String.instAppendString, ToString.toString, Nat, instToStringNat]]
[unsafeCast,[cast, unsafeCast.proof_1, PUnit]]
[ST.Ref.mk.injEq,[Eq.propIntro, Eq, ST.Ref, ST.Ref.mk, PointedType.type, ST.RefPointed, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[PSigma.skipLeft,[WellFoundedRelation.mk, PSigma, PSigma.SkipLeft, WellFoundedRelation.rel, PSigma.skipLeft.proof_1]]
[ExceptCpsT.runCatch_bind_lift,[rfl, ExceptCpsT.runCatch, Bind.bind, ExceptCpsT, Monad.toBind, ExceptCpsT.instMonadExceptCpsT, ExceptCpsT.lift]]
[Nat.mod_eq_of_lt,[]]
[FloatArray.data,[]]
[usize_size_gt_zero,[Nat.pos_pow_of_pos, OfNat.ofNat, Nat, instOfNatNat, System.Platform.numBits, Nat.zero_lt_succ]]
[StateCpsT.run',[StateCpsT.runK, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[LawfulApplicative.map_pure,[]]
[ReaderT.adapt,[]]
[IO.Error.protocolError.inj,[And, Eq, UInt32, String, IO.Error.protocolError, And.intro]]
[UInt32.complement,[HSub.hSub, UInt32, instHSub, instSubUInt32, OfNat.ofNat, instOfNatUInt32, HAdd.hAdd, instHAdd, instAddUInt32]]
[Subtype.eta,[Eq, Subtype, Subtype.mk, Subtype.val, rfl, Eq.symm, Eq.refl]]
[IO.Error.invalidArgument.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.invalidArgument, And, Option, String, UInt32, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Fin.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat, LT.lt, instLTNat, instSizeOf]]
[UInt16.toNat,[Fin.val, UInt16.size, UInt16.val]]
[Array.insertionSort.swapLoop.proof_1,[Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, LT.lt, instLTNat, Array.size, Nat.lt_trans, Nat.succ, Nat.lt_succ_self, Eq.symm]]
[emptyWf,[WellFoundedRelation.mk, emptyRelation, emptyWf.proof_1]]
[Lean.Parser.Tactic.locationWildcard,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol]]
[List.replicate.loop,[List, PProd.fst, PUnit, PProd, List.cons]]
[namedPattern,[]]
[Nat.toUInt32,[UInt32.ofNat]]
[List.getLast!.proof_1,[False, List.cons, List.nil]]
[Lean.evalOptPrio,[Lean.Syntax, Unit.unit, Lean.MacroM, Nat, Lean.evalPrio, Pure.pure, Applicative.toPure, Monad.toApplicative, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, OfNat.ofNat, instOfNatNat]]
[Nat.succ_sub_succ_eq_sub,[Eq, Nat, HSub.hSub, instHSub, instSubNat, Nat.succ, rfl, Nat.zero, congrArg, Nat.pred]]
[instToStringBool,[ToString.mk, Bool, cond, String]]
[ReaderT.run,[]]
[UInt64.decLt,[UInt64.mk, Decidable, LT.lt, UInt64, instLTUInt64, inferInstanceAs, Fin, UInt64.size, instLTFin, Fin.decLt]]
[String.quote,[ite, String, Eq, Bool, String.isEmpty, Bool.true, instDecidableEqBool, HAppend.hAppend, instHAppend, String.instAppendString, String.foldl, Char.quoteCore]]
[IO.FS.Mode.readWrite.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[MonadStateOf.modifyGet,[]]
[UInt8.noConfusionType,[]]
[Lean.Parser.Syntax.addPrio,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Fin.ofNat.proof_1,[Nat.mod_lt, Nat.succ, Nat.zero_lt_succ]]
[Nat.ibelow,[True, And]]
[Lean.MonadRef.getRef,[]]
[CoeT.noConfusionType,[]]
[IO.AccessRight.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Bool, SizeOf.mk]]
[outParam,[]]
[Classical.choose_spec,[Subtype.property, Classical.indefiniteDescription]]
[Lean.«command_Unif_hint___Where_|-⊢_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.unifConstraintElem, Lean.unifConstraint]]
[instToStringUInt32,[ToString.mk, UInt32, ToString.toString, Nat, instToStringNat, UInt32.toNat]]
[Fin.val,[]]
[Quotient.recOn,[Quot.recOn, Setoid.r]]
[UInt64.noConfusionType,[]]
[Nat.succ_lt_succ,[Nat.succ_le_succ, Nat.succ]]
[measure,[invImage, Nat, Nat.lt_wfRel]]
[Lean.Meta.Rewrite.Config.noConfusionType,[]]
[Array.binInsertM,[ite, Array, Eq, Bool, Array.isEmpty, Bool.true, instDecidableEqBool, Bind.bind, Monad.toBind, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.push, Array.get!, OfNat.ofNat, Nat, instOfNatNat, Array.insertAt, not, Array.modifyM, Array.back, HSub.hSub, instHSub, instSubNat, Array.size]]
[Lean.Syntax.expandInterpolatedStr,[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Syntax, Lean.Syntax.expandInterpolatedStrChunks, Lean.Syntax.getArgs, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.Macro.instMonadRefMacroM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Macro.instMonadQuotationMacroM, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[ST.Prim.Ref.modifyUnsafe,[Bind.bind, ST, Monad.toBind, instMonadST, Unit, ST.Prim.Ref.take, ST.Prim.Ref.set]]
[MonadFinally.tryFinally',[]]
[instLawfulMonadStateRefT',[instLawfulMonadStateRefT'.proof_1]]
[Option.format,[Unit.unit, Std.Format, Std.Format.text, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.ToFormat.format]]
[MonadLiftT.monadLift,[]]
[Lean.Quote.quote,[]]
[instCoeTail,[CoeTail.mk, coeFun]]
[ReaderT.run_map,[rfl, ReaderT.run, Functor.map, ReaderT, Applicative.toFunctor, Monad.toApplicative, ReaderT.instMonadReaderT]]
[Char.toLower,[ite, Char, And, GE.ge, Nat, instLENat, OfNat.ofNat, instOfNatNat, LE.le, instDecidableAnd, Nat.decLe, Char.ofNat, HAdd.hAdd, instHAdd, instAddNat]]
[instStreamSubarray,[Stream.mk, Subarray, dite, Option, Prod, LT.lt, Nat, instLTNat, Subarray.start, Subarray.stop, Nat.decLt, Option.none]]
[Sum.inl.inj,[Eq, Sum.inl]]
[instDecidableEqSum.proof_6,[False, Sum.inl, Sum.inr]]
[StateCpsT.instMonadStateCpsT,[Monad.mk, StateCpsT, Applicative.mk, Functor.mk, Pure.mk, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk]]
[Lean.Parser.Tactic.Conv.rhs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[IO.FS.writeBinFile,[Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle, Unit, IO.FS.Handle.mk, IO.FS.Mode.write, Bool.true, IO.FS.Handle.write]]
[Except.tryCatch,[Except, Except.ok]]
[List.all,[List.foldr, Bool, and, Bool.true]]
[ExceptCpsT.runCatch_lift,[of_eq_true, Eq, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Eq.trans, True, congrFun, congrArg, bind_pure, eq_self]]
[Except.bind,[Except, Except.error]]
[Nat.div.inductionOn,[WellFounded.fix, Nat, WellFoundedRelation.rel, measure, id, WellFoundedRelation.wf, dite, And, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HSub.hSub, instHSub, instSubNat, Nat.sub_lt, Nat.lt_of_lt_of_le]]
[ExceptT.bind_throw,[of_eq_true, Eq, ExceptT, Bind.bind, Monad.toBind, Except, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.error, Eq.trans, True, congrFun, congrArg, LawfulMonad.pure_bind, eq_self]]
[Pure.noConfusionType,[]]
[Lean.Parser.Tactic.revert,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[StateT.seqLeft_eq,[StateT.ext, SeqLeft.seqLeft, StateT, Applicative.toSeqLeft, Monad.toApplicative, StateT.instMonadStateT, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const, of_eq_true, Eq, Prod, StateT.run, Eq.trans, Bind.bind, Monad.toBind, Prod.snd, Pure.pure, Applicative.toPure, Prod.mk, Prod.fst, True, congr, congrArg, StateT.run_seqLeft, StateT.run_seq, StateT.run_map, map_eq_pure_bind, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, eq_self]]
[Lean.Name.reprPrec,[Std.Format, Unit.unit, Std.Format.text, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, PProd.fst, PUnit, PProd, OfNat.ofNat, Nat, instOfNatNat, repr, instReprNat, ite, Eq, Bool, Bool.false, Bool.true, instDecidableEqBool, String, instReprString, Lean.Name.toString]]
[instReprAtomUSize,[ReprAtom.mk, USize]]
[Lean.Parser.Tactic.allGoals,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[MonadStateOf.get,[]]
[Lean.Name.mkStr,[Lean.Name.str, mixHash, Hashable.hash, Lean.Name, Lean.instHashableName, String, instHashableString]]
[Lean.Parser.Tactic.traceState,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[«term_-_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instReprAtomUInt64,[ReprAtom.mk, UInt64]]
[Array.getLit.proof_1,[Nat, LT.lt, instLTNat, Array.size, Eq.symm]]
[PLift.down_up,[rfl, PLift.down, PLift.up]]
[String.any,[String.anyAux, String.bsize, OfNat.ofNat, String.Pos, instOfNatNat]]
[Lean.mkCIdentFrom,[Lean.Syntax.ident, Lean.SourceInfo.fromRef, String.toSubstring, ToString.toString, Lean.Name, Lean.Name.instToStringName, List.cons, Prod, List, String, Prod.mk, List.nil]]
[Std.Format.MonadPrettyFormat.currColumn,[]]
[Stream.next?,[]]
[Substring.dropRightWhile,[Substring, Substring.mk]]
[List.noConfusionType,[]]
[IO.Error.mkInvalidArgument,[IO.Error.invalidArgument, Option.none, String]]
[Seq.seq,[]]
[String.revPosOf,[ite, Option, String.Pos, Eq, Bool, BEq.beq, Nat, instBEq, instDecidableEqNat, String.bsize, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Option.none, String.revPosOfAux, String.prev]]
[MonadStateOf.noConfusionType,[]]
[HShiftLeft.noConfusionType,[]]
[Array.eraseIdxSzAuxInstance,[Inhabited.mk, Subtype, Array, Eq, Nat, Array.size, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, Subtype.mk, Array.pop, Array.size_pop]]
[Lean.Name.hash,[Unit.unit, UInt64, UInt64.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, Lean.Name.hash.proof_1]]
[instLEFloat,[LE.mk, Float, Float.le]]
[instLEUInt16,[LE.mk, UInt16, UInt16.le]]
[Lean.Parser.Tactic.Conv.reduce,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[instReprUnit,[Repr.mk, Unit, Std.Format.text]]
[Array.findIdx?,[Array.size, OfNat.ofNat, Nat, instOfNatNat, rfl, HAdd.hAdd, instHAdd, instAddNat, Array.findIdx?.loop]]
[Nat.add_eq,[rfl, Nat, Nat.add]]
[MonadFunctor.monadMap,[]]
[List.eraseRepsAux,[List, List.reverse, List.cons, Unit.unit, BEq.beq, PProd.fst, PUnit, PProd]]
[bfix2,[PProd.fst, PUnit, PProd]]
[IO.Error.noSuchThing.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Option, String, SizeOf.mk, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar]]
[Nat.le_total,[LT.lt, Nat, instLTNat, GE.ge, instLENat, Or, LE.le, Nat.lt_or_ge, Or.inl, Nat.le_of_lt, Or.inr]]
[LawfulApplicative.seq_pure,[]]
[Char.val,[]]
[Alternative.toApplicative,[]]
[String.decEq.proof_2,[False, String.mk, absurd, Eq, List, Char]]
[Bool.and_true,[Eq, Bool, and, Bool.true, Bool.false, rfl, Eq.symm, Eq.refl]]
[Lean.Syntax.getTrailingSize,[Lean.SourceInfo, Option.none, Option.some, Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Nat, Lean.Syntax.getTailInfo?, Substring.bsize, OfNat.ofNat, instOfNatNat]]
[String.Iterator.noConfusionType,[]]
[Lean.Parser.Tactic.paren,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[Array.isEqv,[dite, Bool, Eq, Nat, Array.size, instDecidableEqNat, Array.isEqvAux, OfNat.ofNat, instOfNatNat, Bool.false]]
[precLead,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[UInt16.le,[LE.le, Fin, UInt16.size, instLEFin, UInt16.val]]
[Array.foldrM.fold.proof_1,[Nat.lt_of_lt_of_le, Nat.succ, Array.size, Nat.lt_succ_self]]
[Lean.Syntax.expandInterpolatedStrChunks,[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, MProd, Nat, Lean.Syntax, ForIn.forIn, Array, Array.instForInArray, MProd.mk, String, Unit.unit, ForInStep, Lean.Syntax.isInterpolatedStrLit?, Lean.Syntax.mkStrLit, Lean.SourceInfo.none, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[eq_true_of_decide,[propext, True, Iff.intro, trivial, of_decide_eq_true]]
[Lean.NameGenerator.noConfusionType,[]]
[Array.empty,[Array.mkEmpty, OfNat.ofNat, Nat, instOfNatNat]]
[Array.foldl,[Id.run, Array.foldlM, Id, Id.instMonadId]]
[iff_self,[propext, Iff, True, Iff.intro, trivial, id]]
[Fin.instModFin,[Mod.mk, Fin, Fin.mod]]
[Array.«term__[_:_]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Squash,[Quot, True]]
[List.map,[List, Unit.unit, List.nil, List.cons, PProd.fst, PUnit, PProd]]
[Fin.xor,[Fin.mk, Fin, HMod.hMod, Nat, instHMod, Nat.instModNat, Nat.xor, Fin.xor.proof_1]]
[StateT.run_seqLeft,[]]
[IO.Process.SpawnArgs.cmd,[]]
[Lean.Name.appendAfter,[Lean.Name.modifyBase, Lean.Name.anonymous, Lean.Name.num, Lean.Name, Lean.Name.mkStr, HAppend.hAppend, String, instHAppend, String.instAppendString]]
[FloatArray.instInhabitedFloatArray,[Inhabited.mk, FloatArray, FloatArray.empty]]
[IO.Error.alreadyExists.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Option, String, SizeOf.mk, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar]]
[instReprUSize,[Repr.mk, USize, repr, Nat, instReprNat, USize.toNat]]
[IO.Error.mkResourceExhausted,[IO.Error.resourceExhausted, Option.none, String]]
[Lean.charLitKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Parser.Tactic.contradiction,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[instReprBool,[Repr.mk, Bool, Std.Format, Std.Format.text]]
[String.trimLeft,[Substring.toString, Substring.trimLeft, String.toSubstring]]
[StateT.run_seq,[]]
[Nat.isValidChar,[Or, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, And]]
[Lean.Meta.Simp.Config.singlePass,[]]
[StateT.run_modifyGet,[Eq, Prod, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk, Prod.fst, Prod.snd, rfl, Eq.symm, Eq.refl]]
[«stx_*»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
[fixCore6,[bfix6, USize.size]]
[StateCpsT.runK_bind_modify,[rfl, StateCpsT.runK, Bind.bind, StateCpsT, Monad.toBind, StateCpsT.instMonadStateCpsT, PUnit, modify, instMonadState, StateCpsT.instMonadStateOfStateCpsT]]
[ByteArray.instAppendByteArray,[Append.mk, ByteArray, ByteArray.append]]
[instOrdFin,[Ord.mk, Fin, Ord.compare, Nat, instOrdNat, Fin.val]]
[FloatArray.get?,[dite, Option, Float, LT.lt, Nat, instLTNat, FloatArray.size, Nat.decLt, Option.some, FloatArray.get, Fin.mk, Option.none]]
[Lean.instQuoteString,[Lean.Quote.mk, String, Lean.Syntax.mkStrLit, Lean.SourceInfo.none]]
[Lean.Parser.Tactic.withReducibleAndInstances,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[List.cons_append,[rfl, List, HAppend.hAppend, instHAppend, List.instAppendList, List.cons]]
[Nat.forM,[Nat.forM.loop]]
[USize.toUInt32,[Nat.toUInt32, USize.toNat]]
[SizeOfRef,[Measure, SizeOf.sizeOf]]
[Prod.RProdSubLex.proof_1,[Prod.Lex, Prod, Prod.mk, Prod.RProd, Prod.RProd.intro, Prod.Lex.left, Eq.symm, eq_of_heq, Eq.refl, HEq.refl]]
[instReprAtomInt,[ReprAtom.mk, Int]]
[UInt8.xor,[UInt8.mk, Fin.xor, UInt8.size, UInt8.val]]
[Int.negSucc.inj,[Eq, Nat, Int.negSucc]]
[Std.Range.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat]]
[Substring.posOf,[String.Pos, HSub.hSub, instHSub, instSubNat, String.posOfAux]]
[IO.Error.noFileOrDirectory.inj,[And, Eq, String, UInt32, IO.Error.noFileOrDirectory, And.intro]]
[Lean.instInhabitedName,[Inhabited.mk, Lean.Name, Lean.Name.anonymous]]
[List.map_eq_mapTR,[funext, List, List.map, List.mapTR, of_eq_true, Eq, List.mapTRAux, List.nil, Eq.trans, True, congrArg, HAppend.hAppend, instHAppend, List.instAppendList, List.reverse, List.mapTRAux_eq, congrFun, List.reverse_nil, List.nil_append, eq_self]]
[OptionM,[OptionT, Id]]
[IO.FileRight.group,[]]
[UInt16.shiftLeft,[UInt16.mk, HShiftLeft.hShiftLeft, Fin, UInt16.size, instHShiftLeft, Fin.instShiftLeftFin, UInt16.val, UInt16.modn, OfNat.ofNat, Nat, instOfNatNat]]
[List.erase,[List, List.nil, Unit.unit, BEq.beq, List.cons, PProd.fst, PUnit, PProd]]
[Substring.front,[Substring.get, OfNat.ofNat, String.Pos, instOfNatNat]]
[Nat.land,[Nat.bitwise, and]]
[IO.FS.Stream.Buffer.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, ByteArray, SizeOf.mk, Array, UInt8, List, Fin, UInt8.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf]]
[Int.ofNat.injEq,[Eq.propIntro, Eq, Int, Int.ofNat, Nat, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Array.sequenceMap,[Array.size, OfNat.ofNat, Nat, instOfNatNat, Array.empty, Array.sequenceMap.loop]]
[getThe,[MonadStateOf.get]]
[Nat.eq_zero_of_le_zero,[Nat.le_antisymm, OfNat.ofNat, Nat, instOfNatNat, Nat.zero_le]]
[stdRange,[Prod.mk, Nat, OfNat.ofNat, instOfNatNat]]
[Int.natAbs,[Nat, Nat.succ]]
[Nat.anyM,[Nat.anyM.loop]]
[Nat.mod_one,[]]
[OptionT.instMonadLiftOptionT,[MonadLift.mk, OptionT, OptionT.lift]]
[Array.findM?,[Bind.bind, Monad.toBind, MProd, Option, PUnit, ForIn.forIn, Array, Array.instForInArray, MProd.mk, Option.none, PUnit.unit, Bool, ForInStep, ite, Eq, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, MProd.fst]]
[instDivFloat,[Div.mk, Float, Float.div]]
[Bool.false_or,[Eq, Bool, or, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl]]
[Nat.sub,[Nat, Nat.pred, PProd.fst, PUnit, PProd]]
[Lean.MonadNameGenerator.getNGen,[]]
[Lean.Parser.Tactic.specialize,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[UInt64.xor,[UInt64.mk, Fin.xor, UInt64.size, UInt64.val]]
[Char.isLower,[and, Decidable.decide, GE.ge, UInt32, instLEUInt32, Char.val, OfNat.ofNat, instOfNatUInt32, instDecidableLe, LE.le]]
[instMulUInt64,[Mul.mk, UInt64, UInt64.mul]]
[Lean.Syntax.instBEqSyntax,[BEq.mk, Lean.Syntax, Lean.Syntax.structEq]]
[Squash.lift,[Quot.lift, True, Squash.lift.proof_1]]
[Int.add,[Int.ofNat, Int.negSucc, Int, HAdd.hAdd, Nat, instHAdd, instAddNat, Int.subNatNat, Nat.succ]]
[IO.FS.Stream.Buffer.data,[]]
[Fin.instShiftRightFin,[ShiftRight.mk, Fin, Fin.shiftRight]]
[max,[ite, LT.lt]]
[IO.Error.mkTimeExpired,[IO.Error.timeExpired]]
[String.Iterator.s,[]]
[Lean.binderIdent,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[IO.withStdin,[Bind.bind, Monad.toBind, IO.FS.Stream, liftM, EIO, IO.Error, IO.setStdin, tryFinally, PUnit, Applicative.toFunctor, Monad.toApplicative, Functor.discard]]
[Lean.Syntax.isStrLit?,[String, Option.none, Option, Lean.Syntax.isLit?, Lean.strLitKind, Lean.Syntax.decodeStrLit]]
[Function.Equiv.refl,[rfl]]
[instToStringNat,[ToString.mk, Nat, Nat.repr]]
[Lean.Syntax.instToFormatSyntax,[Std.ToFormat.mk, Lean.Syntax, Lean.Syntax.formatStx, Option.none, Nat, Bool.false]]
[Lean.Parser.Tactic.Conv.convTrace_state,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Subarray.forRevM,[Array.forRevM, Subarray.as, Subarray.stop, Subarray.start]]
[UInt16.toUInt32,[Nat.toUInt32, UInt16.toNat]]
[instInhabitedPointedType,[Inhabited.mk, PointedType, PointedType.mk, PUnit, PUnit.unit]]
[Std.Range.instForInRangeNat,[ForIn.mk, Std.Range, Nat, Std.Range.forIn]]
[instHashableUSize,[Hashable.mk, USize, USize.toUInt64]]
[EStateM.Result.ok.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[GE.ge,[LE.le]]
[List.reverseAux_eq_append,[Eq, List, List.reverseAux, HAppend.hAppend, instHAppend, List.instAppendList, List.nil, of_eq_true, Eq.trans, True, congrArg, List.nil_append, eq_self, Eq.mpr, List.cons, Eq.refl, List.append_assoc, rfl]]
[IO.Error.userError.inj,[Eq, String, IO.Error.userError]]
[Lean.Macro.Methods.resolveNamespace?,[]]
[IO.Error.timeExpired.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.timeExpired, And, UInt32, String, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[ReaderT.instMonadExceptOfReaderT,[MonadExceptOf.mk, ReaderT, liftM, instMonadLiftT, ReaderT.instMonadLiftReaderT, instMonadLiftT_1, MonadExcept.throw, instMonadExcept, tryCatchThe]]
[ExceptT.seq_eq,[rfl, ExceptT, Seq.seq, Applicative.toSeq, Monad.toApplicative, ExceptT.instMonadExceptT]]
[IO.Process.SpawnArgs.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, IO.Process.StdioConfig, SizeOf.mk, IO.Process.Stdio, String, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar, Array, Option, System.FilePath, Prod]]
[StateCpsT.instLawfulMonadStateCpsT,[StateCpsT.instLawfulMonadStateCpsT.proof_1]]
[FloatArray.mkEmpty,[FloatArray.mk, List.toArray, Float, List.nil]]
[«term_*_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.instOrOpNat,[OrOp.mk, Nat, Nat.lor]]
[Nat.add_lt_add_right,[Nat, HAdd.hAdd, instHAdd, instAddNat, LT.lt, instLTNat, Nat.add_lt_add_left, Nat.add_comm]]
[ExceptCpsT.run_bind_lift,[rfl, Except, ExceptCpsT.run, Bind.bind, ExceptCpsT, Monad.toBind, ExceptCpsT.instMonadExceptCpsT, ExceptCpsT.lift]]
[IO.Process.Output.exitCode,[]]
[Lean.Meta.Simp.Config.iota,[]]
[Subarray.foldlM,[Array.foldlM, Subarray.as, Subarray.start, Subarray.stop]]
[HasEquiv.noConfusionType,[]]
[instReprStdGen,[Repr.mk, StdGen, Std.Format, Std.Format.bracket, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, repr, Nat, instReprNat, Std.Format.text]]
[IO.AccessRight.execution,[]]
[Int.instLTInt,[LT.mk, Int, Int.lt]]
[Quotient.lift₂,[Quotient.lift, Quotient.lift₂.proof_1, Quotient.lift₂.proof_2]]
[Lean.Syntax.mkLit,[Lean.Syntax.node, List.toArray, Lean.Syntax, List.cons, List.nil]]
[Lean.Parser.Tactic.«tacticHave'__:=_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instStreamSubarray.proof_1,[Nat.succ_le_of_lt, Subarray.start, Subarray.stop]]
[Bool.or_false,[Eq, Bool, or, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl]]
[Lean.Macro.Methods.getCurrNamespace,[]]
[ne_true_of_not,[]]
[Fin.eq_of_val_eq,[Fin.mk, Nat, Fin.val, Eq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl, Fin, rfl]]
[Sum.inr.injEq,[Eq.propIntro, Eq, Sum, Sum.inr, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[PSigma.mkSkipLeft,[PSigma.mkSkipLeft.proof_1]]
[List.replicate,[List.nil, List.replicate.loop]]
[Lean.Meta.TransparencyMode.noConfusion,[noConfusionEnum, Lean.Meta.TransparencyMode, Nat, instDecidableEqNat, Lean.Meta.TransparencyMode.toCtorIdx]]
[«term_×'_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.bracketedExplicitBinders, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[nonempty_of_exists,[Nonempty, Nonempty.intro]]
[Std.Format.tag.injEq,[Eq.propIntro, Eq, Std.Format, Std.Format.tag, And, Nat, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[instToStringSubstring,[ToString.mk, Substring, Substring.toString]]
[FloatArray.mk.inj,[Eq, Array, Float, FloatArray.mk]]
[ExceptT.instMonadFunctorExceptT,[MonadFunctor.mk, ExceptT, Except]]
[Unit,[PUnit]]
[IO.Error.resourceVanished.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, UInt32, SizeOf.mk, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, String, List, Char, UInt32.isValidChar]]
[List.instListDecidableLe,[inferInstanceAs, Decidable, Not, LT.lt, List, List.instLTList, instDecidableNot, List.hasDecidableLt]]
[precMax,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Meta.Simp.instBEqConfig,[BEq.mk, Lean.Meta.Simp.Config, Lean.Meta.Simp.Config.mk, Bool, and, Bool.true, BEq.beq, Nat, instBEq, instDecidableEqNat, instDecidableEqBool, Bool.false]]
[Lean.Macro.throwError,[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Syntax, Lean.MonadRef.getRef, Lean.Macro.instMonadRefMacroM, MonadExcept.throw, instMonadExcept, ReaderT.instMonadExceptOfReaderT, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Lean.Macro.Exception.error]]
[EStateM.Result.error.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[Nat.all,[not, Nat.any]]
[WellFoundedRelation.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, WellFounded, instSizeOf]]
[ST.Prim.Ref.modifyGet,[Bind.bind, ST, Monad.toBind, instMonadST, ST.Prim.Ref.get, Unit, ST.Prim.Ref.set, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[eq_false',[propext, False, Iff.intro, absurd, False.elim]]
[id,[]]
[String.foldl,[String.foldlAux, String.bsize, OfNat.ofNat, String.Pos, instOfNatNat]]
[Char.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, UInt32, SizeOf.mk, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar]]
[coeOfHead,[CoeHTCT.mk, coeHead]]
[instInhabitedNat,[Inhabited.mk, Nat, Nat.zero]]
[StateT.get,[Pure.pure, Applicative.toPure, Monad.toApplicative, Prod, Prod.mk]]
[SizeOf.sizeOf,[]]
[Lean.Parser.Tactic.withReducible,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[DoResultPR.return.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[FloatSpec.noConfusionType,[]]
[IO.Error.alreadyExists.inj,[And, Eq, Option, String, UInt32, IO.Error.alreadyExists, And.intro]]
[IO.Error.mkInappropriateType,[IO.Error.inappropriateType, Option.none, String]]
[Nat.add_succ,[rfl, Nat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ]]
[EStateM.modifyGet,[EStateM.Result, EStateM.Result.ok]]
[Fin.val_eq_of_eq,[Fin, Eq, Nat, Fin.val, rfl]]
[Fin.mul,[Fin.mk, Fin, HMod.hMod, Nat, instHMod, Nat.instModNat, HMul.hMul, instHMul, instMulNat, Fin.mul.proof_1]]
[instInhabitedStdGen,[Inhabited.mk, StdGen, StdGen.mk, OfNat.ofNat, Nat, instOfNatNat]]
[ReaderT.failure,[Alternative.failure]]
[instDivUInt8,[Div.mk, UInt8, UInt8.div]]
[instMonadControlT_1,[MonadControlT.mk, Pure.pure]]
[CoeTail.noConfusionType,[]]
[instAndOpUInt64,[AndOp.mk, UInt64, UInt64.land]]
[instLawfulMonadStateRefT'.proof_1,[inferInstanceAs, LawfulMonad, ReaderT, ST.Ref, ReaderT.instMonadReaderT, ReaderT.instLawfulMonadReaderT]]
[StateRefT'.instMonadExceptOfStateRefT',[MonadExceptOf.mk, StateRefT', Function.comp, StateRefT'.lift, throwThe, tryCatchThe]]
[Nat.le_add_left,[Nat, HAdd.hAdd, instHAdd, instAddNat, LE.le, instLENat, Nat.le_add_right, Nat.add_comm]]
[Std.Range.«term[:_:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[implies.trans,[]]
[Lean.Meta.Simp.Config.noConfusionType,[]]
[instTransEq_1.proof_1,[]]
[Substring.prevn,[String.Pos, PProd.fst, PUnit, PProd, Substring.prev]]
[StdGen.mk.inj,[And, Eq, Nat, StdGen.mk, And.intro]]
[Lean.Macro.trace,[modify, Lean.Macro.State, Lean.MacroM, instMonadState, instMonadStateOf, EStateM, Lean.Macro.Exception, ReaderT.instMonadLiftReaderT, Lean.Macro.Context, EStateM.instMonadStateOfEStateM, Lean.Macro.State.mk, Lean.Macro.State.macroScope, List.cons, Prod, Lean.Name, String, Prod.mk, Lean.Macro.State.traceMsgs]]
[IO.Process.Child.stderr,[]]
[EStateM.Result.error.injEq,[Eq.propIntro, Eq, EStateM.Result, EStateM.Result.error, And, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[HOr.noConfusionType,[]]
[bfix6,[PProd.fst, PUnit, PProd]]
[WellFoundedRelation.wf,[]]
[Std.Format.defIndent,[OfNat.ofNat, Nat, instOfNatNat]]
[MProd.noConfusionType,[]]
[Int.ofNat.inj,[Eq, Nat, Int.ofNat]]
[Lean.Meta.Simp.Config.maxSteps,[]]
[IO.Error.mkProtocolError,[IO.Error.protocolError]]
[Option.none.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[ReaderT.run_seqRight,[Eq.mpr, Eq, ReaderT.run, SeqRight.seqRight, ReaderT, Applicative.toSeqRight, Monad.toApplicative, ReaderT.instMonadReaderT, Bind.bind, Monad.toBind, Eq.refl, seqRight_eq_bind, rfl]]
[IO.Error.timeExpired.inj,[And, Eq, UInt32, String, IO.Error.timeExpired, And.intro]]
[StateT.instMonadFunctorStateT,[MonadFunctor.mk, StateT, Prod]]
[instReprNat,[Repr.mk, Nat, Std.Format.text, Nat.repr]]
[IO.Process.Child.mk.injEq,[Eq.propIntro, Eq, IO.Process.Child, IO.Process.Child.mk, And, IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdin, IO.Process.StdioConfig.stdout, IO.Process.StdioConfig.stderr, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[ReaderT.instMonadLiftReaderT,[MonadLift.mk, ReaderT]]
[List.zipWith,[List, List.nil, List.cons, PProd.fst, PUnit, PProd]]
[Lean.Syntax.getHeadInfo,[Lean.SourceInfo, Unit.unit, Lean.Syntax.getHeadInfo?, Lean.SourceInfo.none]]
[instShiftLeftUInt64,[ShiftLeft.mk, UInt64, UInt64.shiftLeft]]
[IO.FS.instReprSystemTime,[Repr.mk, IO.FS.SystemTime, Std.Format.bracket, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.nil, Std.Format.text, repr, Int, instReprInt, IO.FS.SystemTime.sec, Std.Format.line, UInt32, instReprUInt32, IO.FS.SystemTime.nsec]]
[List.findSomeM?,[Option, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.none, Bind.bind, Monad.toBind, Option.some, PProd.fst, PUnit, PProd]]
[HMod.noConfusionType,[]]
[String.toSubstring,[Substring.mk, OfNat.ofNat, String.Pos, instOfNatNat, String.bsize]]
[instOrdNat,[Ord.mk, Nat, compareOfLessAndEq, instLTNat, Nat.decLt, instDecidableEqNat]]
[StateT.run_monadMap,[rfl, Prod, StateT.run, MonadFunctorT.monadMap, StateT, instMonadFunctorT, StateT.instMonadFunctorStateT, monadFunctorRefl]]
[Task.Priority.dedicated,[OfNat.ofNat, Task.Priority, instOfNatNat]]
[IO.FS.withIsolatedStreams,[Bind.bind, Monad.toBind, IO.Ref, IO.FS.Stream.Buffer, Prod, String, Except, IO.Error, liftM, EIO, IO.mkRef, IO.FS.Stream.Buffer.mk, IO.withStdin, IO.FS.Stream.ofBuffer, IO.withStdout, IO.withStderr, observing, instMonadExcept, IO, ST.Ref.get, IO.RealWorld, instMonadLiftT, ST, IO.instMonadLiftSTRealWorldEIO, instMonadLiftT_1, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk]]
[Lean.Name.capitalize,[Lean.Name.anonymous, Lean.Name.num, Lean.Name, Lean.Name.mkStr, String.capitalize]]
[Array.foldlMUnsafe,[ite, LT.lt, optParam, Nat, OfNat.ofNat, instOfNatNat, instLTNat, Nat.decLt, LE.le, Array.size, instLENat, Nat.decLe, USize.ofNat, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.foldlMUnsafe.fold]]
[MonadState.modifyGet,[]]
[instDecidableArrow.proof_1,[]]
[Nat.lt_of_le_of_ne,[LT.lt, Nat, instLTNat, GE.ge, instLENat, Nat.lt_or_ge, absurd, Eq, Nat.le_antisymm]]
[ExceptT.run_lift,[rfl, Except, ExceptT.run, ExceptT.lift]]
[instHAndThen,[HAndThen.mk, AndThen.andThen]]
[«term-_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[decPropToBool,[CoeDep.mk, Bool, Decidable.decide]]
[Bool.and_false,[Eq, Bool, and, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl]]
[LawfulApplicative.pure_seq,[]]
[Lean.Name.append,[Lean.Name, Lean.Name.mkStr, PProd.fst, PUnit, PProd, Lean.Name.mkNum]]
[List.hasDecEq.proof_4,[Eq, List, List.cons, rfl]]
[Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat, LT.lt, instLTNat, LE.le, instLENat, Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1]]
[StateRefT',[ReaderT, ST.Ref]]
[StateT.run_bind_lift,[of_eq_true, Eq, Prod, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk, Eq.trans, True, congrFun, congrArg, LawfulMonad.bind_assoc, funext, LawfulMonad.pure_bind, eq_self]]
[StateRefT'.run,[Bind.bind, Monad.toBind, ST.Ref, Prod, ST.mkRef, ST.Ref.get, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk]]
[Lean.Macro.Context.noConfusionType,[]]
[instSubUInt64,[Sub.mk, UInt64, UInt64.sub]]
[Option.bind,[Option, Option.none]]
[«term_>>=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[MonadReaderOf.noConfusionType,[]]
[UInt8.land,[UInt8.mk, Fin.land, UInt8.size, UInt8.val]]
[ReaderT.run_seq,[Eq.mpr, Eq, ReaderT.run, Seq.seq, ReaderT, Applicative.toSeq, Monad.toApplicative, ReaderT.instMonadReaderT, Bind.bind, Monad.toBind, Functor.map, Applicative.toFunctor, Eq.refl, seq_eq_bind, rfl]]
[fixCore,[fixCore1]]
[Lean.Meta.Rewrite.Config.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Lean.Meta.TransparencyMode, SizeOf.mk, Bool]]
[Bool.or_true,[Eq, Bool, or, Bool.true, Bool.false, rfl, Eq.symm, Eq.refl]]
[«term‹_›»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[PSigma.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[False.elim,[]]
[String.next,[HAdd.hAdd, String.Pos, Nat, instHAdd, instAddNat, String.csize]]
[Quot.indep,[PSigma.mk, Quot, Quot.mk]]
[Lean.Parser.Tactic.inductionAlt,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[Alternative.failure,[]]
[instStreamProdProd,[Stream.mk, Prod, Option, Unit.unit, Option.some, Stream.next?, Option.none, Prod.mk]]
[instLEUInt32,[LE.mk, UInt32, LE.le, Fin, UInt32.size, instLEFin, UInt32.val]]
[Quotient.inductionOn,[Quot.inductionOn, Setoid.r]]
[ite_true,[rfl, ite, True, instDecidableTrue]]
[instDecidableEqFin,[Eq, Nat, Fin.val, Decidable, Fin, decEq, instDecidableEqNat, Decidable.isTrue, Fin.eq_of_val_eq, Decidable.isFalse, Fin.ne_of_val_ne]]
[Fin.elim0,[OfNat.ofNat, Nat, instOfNatNat, absurd, LT.lt, instLTNat, Nat.not_lt_zero]]
[USize.xor,[USize.mk, Fin.xor, USize.size, USize.val]]
[Lean.Syntax.SepArray.elemsAndSeps,[]]
[Nat.lt_of_lt_of_eq,[Nat, LT.lt, instLTNat]]
[Prod.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[recSubsingleton,[Subsingleton]]
[IO.Process.Output.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, UInt32, SizeOf.mk, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, String, List, Char, UInt32.isValidChar]]
[ReaderT.run_monadMap,[rfl, ReaderT.run, MonadFunctorT.monadMap, ReaderT, instMonadFunctorT, ReaderT.instMonadFunctorReaderT, monadFunctorRefl]]
[Int.instInhabitedInt,[Inhabited.mk, Int, Int.ofNat, OfNat.ofNat, Nat, instOfNatNat]]
[optParam_eq,[rfl, optParam]]
[instDecidableAnd.proof_2,[And.left]]
[EStateM.orElse',[EStateM.Result.ok, EStateM.Result, EStateM.Backtrackable.restore, EStateM.Result.error, ite, Eq, Bool, Bool.true, instDecidableEqBool]]
[System.SearchPath.separator,[ite, Char, Eq, Bool, System.Platform.isWindows, Bool.true, instDecidableEqBool, Char.ofNat]]
[Array.foldlM.loop,[dite, LT.lt, Nat, instLTNat, Nat.decLt, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Bind.bind, Monad.toBind, Array.get, Fin.mk, Array.size, Array.foldlM.loop.proof_1, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
[Lean.Syntax.getId,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.atom, Lean.Name, Lean.Name.anonymous]]
[MonadControl.restoreM,[]]
[DecidableRel,[Decidable]]
[Id.run,[]]
[Quotient.sound,[Quotient.sound.proof_1]]
[List.anyM,[Bool, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.false, Bind.bind, Monad.toBind, Bool.true, PProd.fst, PUnit, PProd]]
[CoeTC.noConfusionType,[]]
[Lean.Meta.TransparencyMode.default.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[instMonadReaderOfReaderT,[MonadReaderOf.mk, ReaderT, ReaderT.read]]
[fixCore3,[bfix3, USize.size]]
[instReprAtomUInt8,[ReprAtom.mk, UInt8]]
[String.split,[String.splitAux, OfNat.ofNat, String.Pos, instOfNatNat, List.nil, String]]
[Array.erase,[Fin, Array.size, Unit.unit, Array, Array.indexOf?, Array.feraseIdx]]
[Lean.interpolatedStrLitKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Name.instBEqName,[BEq.mk, Lean.Name, Lean.Name.beq]]
[Quot.indBeta,[rfl, Quot.mk, Quot.ind]]
[ReaderT.ext,[funext, id, Eq]]
[UInt16.noConfusionType,[]]
[«term_∘_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Inhabited.default,[]]
[UInt32.decEq.proof_2,[False, UInt32.mk, absurd, Eq, Fin, UInt32.size]]
[«term_<||>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Array.filterSepElems,[Id.run, Array, Lean.Syntax, Array.filterSepElemsM, Id, Id.instMonadId]]
[Lean.Meta.Simp.Config.mk.inj,[And, Eq, Nat, Bool, Lean.Meta.Simp.Config.mk, And.intro]]
[Lean.strLitKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[instShiftRightUInt32,[ShiftRight.mk, UInt32, UInt32.shiftRight]]
[MonadState.get,[]]
[dite_congr,[Not, Eq, dite, Decidable.em, Or, Or.inl, Eq.mpr, Eq.refl, dif_pos, Eq.symm, Or.inr, dif_neg]]
[Lean.Syntax.setHeadInfo,[Lean.Syntax, Unit.unit, Lean.Syntax.setHeadInfoAux]]
[Char.ne_of_val_ne,[absurd, Eq, UInt32, Char.val, False, Char.val_eq_of_eq]]
[instModUInt32,[Mod.mk, UInt32, UInt32.mod]]
[Lean.PrettyPrinter.instMonadQuotationUnexpandM,[Lean.MonadQuotation.mk, Lean.PrettyPrinter.UnexpandM, Lean.MonadRef.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, EStateM.instMonadEStateM, Unit, Lean.Syntax, Lean.Syntax.missing, id, Lean.MacroScope, OfNat.ofNat, instOfNatNat, Lean.Name, Lean.Name.mkStr, Lean.Name.anonymous]]
[USize.add,[USize.mk, HAdd.hAdd, Fin, USize.size, instHAdd, Fin.instAddFin, USize.val]]
[Lean.Parser.Tactic.tacticSuffices_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[NonScalar.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat]]
[termMax_prec,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
[Int.pow,[Int, Unit.unit, OfNat.ofNat, Int.instOfNatInt, HMul.hMul, instHMul, Int.instMulInt, PProd.fst, PUnit, PProd]]
[Option.orElse,[Option, Option.some, Unit.unit]]
[Lean.Syntax.SepArray.getElems,[Array.getSepElems, Lean.Syntax, Lean.Syntax.SepArray.elemsAndSeps]]
[Nat.mul_zero,[rfl, Nat, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat]]
[IO.Process.SpawnArgs.noConfusionType,[]]
[Lean.SourceInfo.fromRef,[String.Pos, Option.none, Option.some, Lean.SourceInfo, Lean.Syntax.getPos?, Bool.false, Lean.Syntax.getTailPos?, Lean.SourceInfo.synthetic, Lean.SourceInfo.none]]
[«term_⊕_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Fin.shiftRight.proof_1,[LT.lt, Nat, instLTNat, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, HShiftRight.hShiftRight, instHShiftRight, Nat.instShiftRightNat]]
[of_eq_true,[True, trivial, Eq.symm]]
[Lean.version.patch,[Unit.unit]]
[Lean.Parser.Tactic.tacticHave'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[System.FilePath.exeExtension,[ite, String, Eq, Bool, System.Platform.isWindows, Bool.true, instDecidableEqBool]]
[Acc.inv,[Acc.inv.proof_1]]
[Monad.noConfusionType,[]]
[UInt64.ofNat,[UInt64.mk, Fin.ofNat, OfNat.ofNat, Nat, instOfNatNat]]
[instMonadExceptOfExceptT,[MonadExceptOf.mk, ExceptT, ExceptT.mk, throwThe, Except, tryCatchThe]]
[Option.filter,[Unit.unit, Option, ite, Eq, Bool, Bool.true, instDecidableEqBool, Option.some, Option.none]]
[List.enumFrom,[List, Prod, Nat, List.nil, List.cons, Prod.mk, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
[instDecidableIff.proof_2,[Iff.mp]]
[UInt64.land,[UInt64.mk, Fin.land, UInt64.size, UInt64.val]]
[instSubUInt16,[Sub.mk, UInt16, UInt16.sub]]
[Lean.Macro.withFreshMacroScope,[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.MacroScope, MonadState.modifyGet, instMonadState, instMonadStateOf, ReaderT.instMonadLiftReaderT, EStateM.instMonadStateOfEStateM, Prod.mk, Lean.Macro.State.macroScope, Lean.Macro.State.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Lean.Macro.State.traceMsgs, MonadWithReader.withReader, instMonadWithReader, instMonadWithReaderOfReaderT, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth, Lean.Macro.Context.ref]]
[Std.Format.bracketFill,[Std.Format.fill, Std.Format.nest, Int.ofNat, String.length, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.text]]
[Nat.lt_of_le_and_ne,[Eq, Nat, LT.lt, instLTNat, Nat.eq_or_lt_of_le, absurd]]
[MonadFunctorT.monadMap,[]]
[Lean.Parser.Tactic.Conv.convSeq,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.Parser.Tactic.Conv.convSeq1Indented, Lean.Parser.Tactic.Conv.convSeqBracketed]]
[Lean.Syntax.decodeScientificLitVal?,[ite, Option, Prod, Nat, Bool, Eq, BEq.beq, instBEq, instDecidableEqNat, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Option.none, Char.isDigit, String.Pos, Lean.Syntax.decodeScientificLitVal?.decodeAfterExp, Lean.Syntax.decodeScientificLitVal?.decodeExp, Lean.Syntax.decodeScientificLitVal?.decodeAfterDot, Lean.Syntax.decodeScientificLitVal?.decode]]
[IO.Error.mkInappropriateTypeFile,[Function.comp, String, Option, IO.Error, IO.Error.inappropriateType, Option.some]]
[eq_true_of_ne_false,[Eq, Bool, Bool.true, rfl, False.elim, Bool.false]]
[DoResultPR.noConfusionType,[]]
[IO.Error.mkHardwareFault,[IO.Error.hardwareFault]]
[Lean.Syntax.setTailInfo,[Lean.Syntax, Unit.unit, Lean.Syntax.setTailInfoAux]]
[Lean.Syntax.matchesNull,[Lean.Syntax.isNodeOf, Lean.nullKind]]
[Char.isAlpha,[or, Char.isUpper, Char.isLower]]
[Monad.toApplicative,[]]
[PUnit.eq_punit,[PUnit.subsingleton, PUnit.unit]]
[List.filterAux,[List, List.reverse, Unit.unit, PProd.fst, PUnit, PProd, List.cons]]
[UInt64.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Fin, UInt64.size, SizeOf.mk, instSizeOfNat, LT.lt, instLTNat, instSizeOf]]
[Substring.atEnd,[Bool, BEq.beq, String.Pos, instBEq, instDecidableEqNat, HAdd.hAdd, instHAdd, instAddNat]]
[Nat.succ_pos,[Nat.zero_lt_succ]]
[Sub.sub,[]]
[instDivUInt64,[Div.mk, UInt64, UInt64.div]]
[Option.get!,[Unit.unit, panicWithPosWithDecl, OfNat.ofNat, Nat, instOfNatNat]]
[if_neg,[Eq, ite, absurd, Decidable.isTrue, rfl, Decidable.isFalse]]
[Lean.Name.str.inj,[And, Eq, Lean.Name, String, UInt64, Lean.Name.str, And.intro]]
[Or.intro_right,[Or.inr]]
[Nat.sub_lt,[Nat.succ, LT.lt, Nat, instLTNat, HSub.hSub, instHSub, instSubNat, absurd, OfNat.ofNat, instOfNatNat, Nat.lt_irrefl, HAdd.hAdd, instHAdd, instAddNat, Eq.symm, Nat.succ_sub_succ_eq_sub]]
[instToStringSum,[ToString.mk, Sum, String, HAppend.hAppend, instHAppend, String.instAppendString, addParenHeuristic, ToString.toString]]
[instToStringUInt16,[ToString.mk, UInt16, ToString.toString, Nat, instToStringNat, UInt16.toNat]]
[USize.sub,[USize.mk, HSub.hSub, Fin, USize.size, instHSub, Fin.instSubFin, USize.val]]
[List.eraseReps,[Unit.unit, List, List.nil, List.eraseRepsAux]]
[Nat.any,[Nat.anyAux]]
[Subarray.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Array, SizeOf.mk, List, instSizeOfNat, LE.le, instLENat, instSizeOf, Array.size]]
[reprStr,[Std.Format.pretty, Repr.reprPrec, OfNat.ofNat, Nat, instOfNatNat, Std.Format.defWidth]]
[Lean.Syntax.below,[PUnit, PProd]]
[StateT.instLawfulMonadStateT,[StateT.instLawfulMonadStateT.proof_1]]
[OfScientific.noConfusionType,[]]
[Subtype.instInhabitedSubtype,[Inhabited.mk, Subtype, Subtype.mk]]
[instReprId_1,[inferInstanceAs, Repr]]
[ExceptT.ext,[id, Eq, Except]]
[List.replace,[List, List.nil, Unit.unit, BEq.beq, List.cons, PProd.fst, PUnit, PProd]]
[Lean.Parser.Tactic.tacticRefine_lift_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Nat.fold,[Nat.foldAux]]
[Lean.Syntax.copyHeadTailInfoFrom,[Lean.Syntax.setTailInfo, Lean.Syntax.setHeadInfo, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo]]
[MonadReaderOf.read,[]]
[BEq.beq,[]]
[instSubsingleton.proof_1,[Subsingleton.intro, proofIrrel]]
[Nat.succ_add,[Eq, Nat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, rfl, OfNat.ofNat, instOfNatNat, congrArg, Nat.add, PProd.fst, PUnit, PProd]]
[Function.Equiv.trans,[Eq.trans]]
[String.Iterator.isPrefixOfRemaining,[String.Iterator.mk, Bool, Decidable.decide, Eq, String, String.extract, String.bsize, HAdd.hAdd, String.Pos, Nat, instHAdd, instAddNat, HSub.hSub, instHSub, instSubNat, instDecidableEqString]]
[List.append_nil,[Eq, List, HAppend.hAppend, instHAppend, List.instAppendList, List.nil, rfl, of_eq_true, List.cons, List.append, Eq.trans, True, congrFun, congrArg, id, eq_self]]
[Bool.false_and,[Eq, Bool, and, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl]]
[Lean.Parser.Tactic.simpPre,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol]]
[Lean.Name.instReprName,[Repr.mk, Lean.Name, Lean.Name.reprPrec]]
[Array.forInUnsafe,[OfNat.ofNat, USize, instOfNatUSize, Array.forInUnsafe.loop]]
[Char.utf8Size,[ite, UInt32, LE.le, instLEUInt32, UInt32.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, Char.utf8Size.proof_1, instDecidableLe, Char.utf8Size.proof_2, Char.utf8Size.proof_3, Char.utf8Size.proof_4, Char.utf8Size.proof_5, Char.utf8Size.proof_6, Char.utf8Size.proof_7]]
[Ordering.isLE,[Unit.unit, Bool, Bool.true, Bool.false]]
[PointedType.type,[]]
[Iff.rfl,[Iff.refl]]
[prodHasDecidableLt,[inferInstanceAs, Decidable, Or, LT.lt, Prod.fst, And, Eq, Prod.snd, instDecidableOr, instDecidableAnd]]
[Substring.toIterator,[String.Iterator, String.Iterator.mk]]
[Float.noConfusionType,[]]
[Array.foldlM.proof_1,[Nat.le_refl, Array.size]]
[dite,[]]
[IO.Process.Output.stderr,[]]
[List.mapM,[List, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, List.nil, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd, List.cons]]
[Task.spawn,[Task.pure, Unit.unit]]
[IO.Error.interrupted.inj,[And, Eq, String, UInt32, IO.Error.interrupted, And.intro]]
[Subarray.foldl,[Id.run, Subarray.foldlM, Id, Id.instMonadId]]
[Int.instDecidableEqInt,[Int.decEq]]
[coeOfHeafOfTCOfTail,[CoeHTCT.mk, coeTail, coeTC, coeHead]]
[instInhabitedOption,[Inhabited.mk, Option, Option.none]]
[List.instLTList,[LT.mk, List, List.lt]]
[List.tail?,[Unit.unit, Option, List, Option.none, Option.some]]
[floatDecLt,[Float.decLt]]
[Bool.noConfusionType,[]]
[Fin.mk.inj,[Eq, Nat, Fin.mk]]
[CoeSort.noConfusionType,[]]
[UInt32.modn,[UInt32.mk, HMod.hMod, Fin, UInt32.size, Nat, Fin.instHModFinNatFin, UInt32.val]]
[«term_::_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instReprString,[Repr.mk, String, Std.Format.text, String.quote]]
[instAddNat,[Add.mk, Nat, Nat.add]]
[USize.ofNat,[USize.mk, Fin.ofNat', USize.size, usize_size_gt_zero]]
[List.reverse_nil,[rfl, List, List.reverse, List.nil]]
[Lean.Parser.Tactic.simpStar,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol]]
[System.instReprFilePath,[Repr.mk, System.FilePath, Repr.addAppParen, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.text, repr, String, instReprString, System.FilePath.toString]]
[PSum.inl.inj,[Eq, PSum.inl]]
[«term_=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[EIO.toIO',[EIO.toIO, Except, panicWithPosWithDecl, IO.Error, IO.instInhabitedError, OfNat.ofNat, Nat, instOfNatNat, observing, EIO, instMonadEIO, instMonadExcept, instMonadExceptOfEIO]]
[Lean.Parser.Tactic.tacticLet'_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Lean.MonadQuotation.addMacroScope,[Bind.bind, Monad.toBind, Lean.Name, Lean.MonadQuotation.getMainModule, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.addMacroScope]]
[instReprUInt16,[Repr.mk, UInt16, repr, Nat, instReprNat, UInt16.toNat]]
[StateT.map,[Bind.bind, Monad.toBind, Prod, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk]]
[Subtype.mk.inj,[Eq, Subtype.mk]]
[instDivUInt32,[Div.mk, UInt32, UInt32.div]]
[ExceptT.map,[ExceptT.mk, Bind.bind, Monad.toBind, Except, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.ok, Except.error]]
[IO.FS.Stream.flush,[]]
[Array.anyMUnsafe,[ite, Bool, LT.lt, optParam, Nat, OfNat.ofNat, instOfNatNat, instLTNat, Nat.decLt, LE.le, Array.size, instLENat, Nat.decLe, USize.ofNat, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.false, Array.anyMUnsafe.any]]
[Lean.Syntax.ibelow,[True, And]]
[ExceptCpsT.runCatch_throw,[rfl, ExceptCpsT.runCatch, MonadExcept.throw, ExceptCpsT, instMonadExcept, ExceptCpsT.instMonadExceptOfExceptCpsT]]
[String.Iterator.extract,[String.Iterator.mk, String, ite, Eq, Bool, or, Decidable.decide, Ne, instDecidableNot, instDecidableEqString, GT.gt, String.Pos, instLTNat, Nat.decLt, Bool.true, instDecidableEqBool, String.extract]]
[Ne,[Not, Eq]]
[IO.Error.permissionDenied.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.permissionDenied, And, Option, String, UInt32, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[HAnd.hAnd,[]]
[List.mapA,[List, Unit.unit, Pure.pure, Applicative.toPure, List.nil, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, List.cons, PProd.fst, PUnit, PProd]]
[Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat.lt_of_lt_of_le]]
[instInhabitedPNonScalar,[Inhabited.mk, PNonScalar, PNonScalar.mk, arbitrary, Nat, instInhabitedNat]]
[UInt16.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Fin, UInt16.size, SizeOf.mk, instSizeOfNat, LT.lt, instLTNat, instSizeOf]]
[Classical.epsilon,[Subtype.val, Classical.strongIndefiniteDescription]]
[instReprId,[inferInstanceAs, Repr]]
[EStateM.map,[EStateM.Result, EStateM.Result.ok, EStateM.Result.error]]
[ExceptT,[Except]]
[EStateM.instToStringResult,[ToString.mk, EStateM.Result, String, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString]]
[guard,[ite, Unit, Pure.pure, Applicative.toPure, Alternative.toApplicative, Unit.unit, Alternative.failure]]
[Decidable.em,[Decidable.byCases, Or, Not, Or.inl, Or.inr]]
[IO.Error.illegalOperation.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, UInt32, SizeOf.mk, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, String, List, Char, UInt32.isValidChar]]
[Array.modifyM.proof_1,[Eq.symm, Nat, Array.size, Array.set, Fin.mk, arbitrary, Array.size_set]]
[unsafeEIO,[IO.RealWorld, Except, EStateM.run, Unit.unit, Except.ok, Except.error]]
[instOrdInt,[Ord.mk, Int, compareOfLessAndEq, Int.instLTInt, Int.decLt, Int.instDecidableEqInt]]
[eq_true,[propext, True, Iff.intro, trivial]]
[Array.eraseIdx,[ite, Array, LT.lt, Nat, instLTNat, Array.size, Nat.decLt, Array.eraseIdxAux, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
[EStateM.run',[Option, EStateM.run, Option.some, Option.none]]
[IO.Error.illegalOperation.inj,[And, Eq, UInt32, String, IO.Error.illegalOperation, And.intro]]
[String.atEnd,[Bool, Decidable.decide, GE.ge, String.Pos, instLENat, String.utf8ByteSize, Nat.decLe]]
[List.hasDecidableLt,[Decidable, LT.lt, List, List.instLTList, List.nil, Unit.unit, List.cons, Decidable.isFalse, List.hasDecidableLt.proof_1, Decidable.isTrue, List.lt.nil, List.hasDecidableLt.proof_2, List.lt.head, List.hasDecidableLt.proof_3, PProd.fst, PUnit, PProd, List.lt.tail, List.hasDecidableLt.proof_4]]
[String.splitOn,[ite, List, String, Eq, Bool, BEq.beq, optParam, instBEq, instDecidableEqString, Bool.true, instDecidableEqBool, List.cons, List.nil, String.splitOnAux, OfNat.ofNat, String.Pos, instOfNatNat]]
[«termΣ'_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
[Thunk.noConfusionType,[]]
[Quotient.recOnSubsingleton₂.proof_1,[Quot.recOnSubsingleton, Setoid.r, Subsingleton, Quot.mk, inferInstance, instSubsingleton]]
[EStateM.adaptExcept,[EStateM.Result, EStateM.Result.error, EStateM.Result.ok]]
[Subrelation.wf.proof_1,[WellFounded.intro, Subrelation.accessible, WellFounded.apply]]
[isValidChar,[Or, LT.lt, UInt32, instLTUInt32, OfNat.ofNat, instOfNatUInt32, And]]
[instSubUInt8,[Sub.mk, UInt8, UInt8.sub]]
[Nat.succ_mul,[Eq, Nat, HMul.hMul, instHMul, instMulNat, Nat.succ, HAdd.hAdd, instHAdd, instAddNat, rfl, Nat.zero, Eq.mpr, Eq.refl, Nat.mul_succ, Nat.add_succ, Nat.add_right_comm]]
[UInt16.decEq,[UInt16.mk, Decidable, Eq, UInt16, dite, Fin, UInt16.size, instDecidableEqFin, Decidable.isTrue, UInt16.decEq.proof_1, Decidable.isFalse, UInt16.decEq.proof_2]]
[Substring.isEmpty,[BEq.beq, Nat, instBEq, instDecidableEqNat, Substring.bsize, OfNat.ofNat, instOfNatNat]]
[String.join,[List.foldl, String, HAppend.hAppend, instHAppend, String.instAppendString]]
[Int.instModInt,[Mod.mk, Int, Int.mod]]
[instToStringSubarray,[ToString.mk, Subarray, ToString.toString, Array, Array.instToStringArray, Subarray.toArray]]
[UInt8.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Fin, UInt8.size, SizeOf.mk, instSizeOfNat, LT.lt, instLTNat, instSizeOf]]
[PSigma.noConfusionType,[]]
[Lean.Syntax.getPos?,[Lean.SourceInfo.getPos?, Lean.Syntax.getHeadInfo]]
[instToStreamArraySubarray,[ToStream.mk, Array, Subarray, Array.toSubarray, OfNat.ofNat, optParam, Nat, instOfNatNat, Array.size]]
[Float.mk.injEq,[Eq.propIntro, Eq, Float, Float.mk, FloatSpec.float, floatSpec, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[instHXor,[HXor.mk, Xor.xor]]
[instHMod,[HMod.mk, Mod.mod]]
[Array.appendCore.loop,[Array, dite, LT.lt, Nat, instLTNat, Array.size, Nat.decLt, Unit.unit, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.push, Array.get, Fin.mk]]
[and_self,[propext, And, Iff.intro, And.left, And.intro]]
[HMul.hMul,[]]
[implies_congr,[Eq, rfl]]
[Lean.version.minor,[Unit.unit]]
[List.reverseAux_reverseAux_nil,[Eq, List, List.reverseAux, List.nil, rfl, of_eq_true, List.cons, Eq.trans, True, congrFun, congrArg, eq_self]]
[List.toArrayAux,[Array, PProd.fst, PUnit, PProd, Array.push]]
[Lean.withRef,[Bind.bind, Monad.toBind, Lean.Syntax, Lean.MonadRef.getRef, Lean.MonadRef.withRef]]
[«termΣ_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
[UInt16.mul,[UInt16.mk, HMul.hMul, Fin, UInt16.size, instHMul, Fin.instMulFin, UInt16.val]]
[String.revFind,[ite, Option, String.Pos, Eq, Bool, BEq.beq, Nat, instBEq, instDecidableEqNat, String.bsize, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Option.none, String.revFindAux, String.prev]]
[Nat.le_step,[Nat.le.step]]
[Lean.unifConstraintElem,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.unifConstraint, Lean.ParserDescr.unary, Lean.ParserDescr.symbol]]
[Nat.mod_zero,[]]
[Char.utf8Size.proof_7,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
[DoResultSBC.break.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[EStateM.dummyRestore,[]]
[instMonadControlStateRefT',[inferInstanceAs, MonadControl, ReaderT, ST.Ref, instMonadControlReaderT]]
[List.allM,[Bool, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.true, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd, Bool.false]]
[Quotient.exists_rep,[Quot.exists_rep, Setoid.r]]
[List.length,[Nat, Unit.unit, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, PProd.fst, PUnit, PProd]]
[Coe.coe,[]]
[IO.FileRight.noConfusionType,[]]
[Std.Format.joinSuffix,[Std.Format, Std.Format.nil, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.ToFormat.format, PProd.fst, PUnit, PProd]]
[Array.mapIdxM.map.proof_1,[Eq.mpr, LT.lt, Nat, instLTNat, Array.size, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Eq, Eq.refl, Eq.symm, Nat.add_assoc, Nat.add_comm, Nat.le_add_right, Nat.succ]]
[StateT.run_set,[rfl, Prod, PUnit, StateT.run, MonadStateOf.set, StateT, instMonadStateOfStateT]]
[Subtype.existsOfSubtype.proof_1,[Exists, Exists.intro]]
[Nat.instModNat,[Mod.mk, Nat, Nat.mod]]
[IO.Process.SpawnArgs.mk.injEq,[Eq.propIntro, Eq, IO.Process.SpawnArgs, IO.Process.SpawnArgs.mk, And, IO.Process.StdioConfig, String, Array, Option, System.FilePath, Prod, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[List.instLEList,[LE.mk, List, List.le]]
[andM,[Bind.bind, Monad.toBind, Unit.unit, ToBool.toBool, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[Std.Format.append.inj,[And, Eq, Std.Format, Std.Format.append, And.intro]]
[Bind.bind,[]]
[Quot.hrecOn.proof_1,[eq_of_heq, Quot.mk, Quot, Quot.sound]]
[Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp.proof_1,[Nat.le_trans]]
[Lean.Macro.instInhabitedState,[Inhabited.mk, Lean.Macro.State, Lean.Macro.State.mk, arbitrary, Lean.MacroScope, instInhabitedNat, List, Prod, Lean.Name, String, instInhabitedList]]
[Array.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, List, SizeOf.mk]]
[Lean.MonadQuotation.toMonadRef,[]]
[bfix4,[PProd.fst, PUnit, PProd]]
[Squash.mk,[Quot.mk, True]]
[Prod.lexAccessible.proof_1,[Acc, Prod, Prod.Lex, Prod.mk, Acc.intro, Prod.Lex.left, Eq.symm, eq_of_heq, Prod.Lex.right, Eq.refl, HEq.refl]]
[StateT.run_lift,[rfl, Prod, StateT.run, StateT.lift]]
[«term_!=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[DoResultBC.continue.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[Lean.MonadQuotation.withFreshMacroScope,[]]
[Fin.instShiftLeftFin,[ShiftLeft.mk, Fin, Fin.shiftLeft]]
[LawfulFunctor.comp_map,[]]
[Nat.toUInt64,[UInt64.ofNat]]
[Lean.Parser.Tactic.tacticRepeat_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[StateT.instMonadStateT,[Monad.mk, StateT, Applicative.mk, Functor.mk, StateT.map, Pure.mk, StateT.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk, StateT.bind]]
[instOrdUInt16,[Ord.mk, UInt16, compareOfLessAndEq, instLTUInt16, instDecidableLt_2, instDecidableEqUInt16]]
[UInt16.shiftRight,[UInt16.mk, HShiftRight.hShiftRight, Fin, UInt16.size, instHShiftRight, Fin.instShiftRightFin, UInt16.val, UInt16.modn, OfNat.ofNat, Nat, instOfNatNat]]
[Char.isValidChar_zero,[Or.inl, LT.lt, UInt32, instLTUInt32, OfNat.ofNat, instOfNatUInt32, And, of_decide_eq_true, instDecidableLt, Eq.refl, Bool, Bool.true]]
[instOrdUInt32,[Ord.mk, UInt32, compareOfLessAndEq, instLTUInt32, instDecidableLt, instDecidableEqUInt32]]
[LawfulApplicative.seqLeft_eq,[]]
[ReaderT.bind,[Bind.bind, Monad.toBind]]
[Squash.ind,[Quot.ind, True]]
[Fin.instMulFin,[Mul.mk, Fin, Fin.mul]]
[EStateM.instInhabitedResult,[Inhabited.mk, EStateM.Result, EStateM.Result.error, arbitrary]]
[Applicative.toSeqRight,[]]
[Std.Format.group.inj,[And, Eq, Std.Format, Std.Format.FlattenBehavior, Std.Format.group, And.intro]]
[Quot.liftOn,[Quot.lift]]
[strictAnd,[and]]
[Nat.right_distrib,[]]
[Array.isPrefixOf,[dite, Bool, LE.le, Nat, instLENat, Array.size, Nat.decLe, Array.isPrefixOfAux, OfNat.ofNat, instOfNatNat, Bool.false]]
[instInhabitedArrow_1,[Inhabited.mk, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[Lean.Parser.Tactic.rotateLeft,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[dif_pos,[Eq, dite, rfl, Decidable.isTrue, absurd, Decidable.isFalse]]
[solve,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[instToStringFin,[ToString.mk, Fin, ToString.toString, Nat, instToStringNat, Fin.val]]
[instCoeTail_1,[CoeTail.mk, coeSort]]
[Lean.Parser.Tactic.tacticTry_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[instOrdString,[Ord.mk, String, compareOfLessAndEq, String.instLTString, String.decLt, instDecidableEqString]]
[instDecidableEqProd.proof_2,[False, Prod.mk, absurd, Eq]]
[throwThe,[MonadExceptOf.throw]]
[WellFounded.apply,[WellFounded.apply.proof_1]]
[fixCore2,[bfix2, USize.size]]
[IO.FileRight.user,[]]
[UInt32.decEq,[UInt32.mk, Decidable, Eq, UInt32, dite, Fin, UInt32.size, instDecidableEqFin, Decidable.isTrue, UInt32.decEq.proof_1, Decidable.isFalse, UInt32.decEq.proof_2]]
[Lean.mkFreshId,[Bind.bind, Monad.toBind, Lean.NameGenerator, Lean.Name, Lean.MonadNameGenerator.getNGen, Unit, Lean.MonadNameGenerator.setNGen, Lean.NameGenerator.next, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[Sigma.noConfusionType,[]]
[List.lengthTRAux,[Nat, PProd.fst, PUnit, PProd, Nat.succ]]
[Nonempty.elim.proof_1,[]]
[Bool.true.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[autoParam,[]]
[IO.FS.instLTSystemTime,[ltOfOrd, IO.FS.SystemTime, IO.FS.instOrdSystemTime]]
[Substring.trim,[Substring, Substring.mk]]
[Subarray.any,[Id.run, Bool, Subarray.anyM, Id, Id.instMonadId]]
[Subsingleton.elim,[Subsingleton.elim.proof_1]]
[IO.FS.FileType.symlink.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[String.Iterator.curr,[Char, String.get]]
[ST.Ref.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, PointedType.type, ST.RefPointed, instSizeOf, Nonempty]]
[MonadWithReader.withReader,[]]
[instHShiftRight,[HShiftRight.mk, ShiftRight.shiftRight]]
[OptionT.bind,[OptionT.mk, Bind.bind, Monad.toBind, Option, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.none]]
[HXor.noConfusionType,[]]
[ite_false,[rfl, ite, False, instDecidableFalse]]
[PLift.up_down,[Eq, PLift, PLift.up, PLift.down, rfl]]
[System.FilePath.fileStem,[Option.map, String, String.Pos, Unit.unit, dite, Option.some, Eq, instDecidableEqNat, Eq.symm, String.revPosOf, Char.ofNat, String.extract, OfNat.ofNat, instOfNatNat, System.FilePath.fileName]]
[Char.val_ne_of_ne,[absurd, Eq, Char, False, Char.eq_of_val_eq]]
[instInhabitedSort,[Inhabited.mk, PUnit]]
[ShiftRight.noConfusionType,[]]
[Array.binSearchContains,[ite, Bool, LT.lt, optParam, Nat, OfNat.ofNat, instOfNatNat, instLTNat, Array.size, Nat.decLt, Array.binSearchAux, instInhabitedBool, Option.isSome, Bool.false]]
[Lean.Parser.Tactic.intros,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[instSubsingletonStateM,[instSubsingletonStateM.proof_1]]
[boolToProp,[Coe.mk, Bool, Eq, Bool.true]]
[«term_≈_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[ReaderT.run_pure,[rfl, ReaderT.run, Pure.pure, ReaderT, Applicative.toPure, Monad.toApplicative, ReaderT.instMonadReaderT]]
[Fin.shiftLeft,[Fin.mk, Fin, HMod.hMod, Nat, instHMod, Nat.instModNat, HShiftLeft.hShiftLeft, instHShiftLeft, Nat.instShiftLeftNat, Fin.shiftLeft.proof_1]]
[Lean.Syntax.getKind,[Unit.unit, Lean.SyntaxNodeKind, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Name.mkSimple, Lean.identKind]]
[Std.Range.mk.injEq,[Eq.propIntro, Eq, Std.Range, Std.Range.mk, And, Nat, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[MonadControlT.stM,[]]
[instShiftLeftUInt8,[ShiftLeft.mk, UInt8, UInt8.shiftLeft]]
[liftCoeM,[Bind.bind, Monad.toBind, liftM, Pure.pure, Applicative.toPure, Monad.toApplicative, coe]]
[String.csize,[UInt32.toNat, Char.utf8Size]]
[Sigma.fst,[]]
[Array.mapSepElemsM,[OfNat.ofNat, Nat, instOfNatNat, List.toArray, Lean.Syntax, List.nil]]
[EStateM.Backtrackable.noConfusionType,[]]
[List.get,[List.cons, absurd, LT.lt, Nat, instLTNat, List.length, List.nil, Nat.not_lt_zero]]
[IO.withStdout,[Bind.bind, Monad.toBind, IO.FS.Stream, liftM, EIO, IO.Error, IO.setStdout, tryFinally, PUnit, Applicative.toFunctor, Monad.toApplicative, Functor.discard]]
[Lean.Parser.Tactic.inductionAlts,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlt]]
[HAdd.noConfusionType,[]]
[USize.noConfusionType,[]]
[instHMul,[HMul.mk, Mul.mul]]
[id_eq,[rfl, id]]
[Append.noConfusionType,[]]
[IO.AccessRight.mk.injEq,[Eq.propIntro, Eq, IO.AccessRight, IO.AccessRight.mk, And, Bool, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Array.modifyOp,[Array.modify]]
[usize_size_eq,[]]
[UInt64.toUInt16,[Nat.toUInt16, UInt64.toNat]]
[Int.instNegInt,[Neg.mk, Int, Int.neg]]
[String.isPrefixOf,[and, Decidable.decide, LE.le, Nat, instLENat, String.length, Nat.decLe, OfNat.ofNat, String.Pos, instOfNatNat, String.isPrefixOf.loop]]
[IO.Process.SpawnArgs.mk.inj,[And, Eq, IO.Process.StdioConfig, String, Array, Option, System.FilePath, Prod, IO.Process.SpawnArgs.mk, And.intro]]
[instInhabitedExceptT,[Inhabited.mk, ExceptT, MonadExcept.throw, instMonadExcept, instMonadExceptOfExceptT_1, arbitrary]]
[Lean.Name.replacePrefix,[Lean.Name, Lean.Name.anonymous, Lean.Name.str, Lean.Name.num, ite, Eq, Bool, BEq.beq, Lean.Name.instBEqName, Bool.true, instDecidableEqBool, Lean.Name.mkStr, PProd.fst, PUnit, PProd, Lean.Name.mkNum]]
[Lean.Syntax.isNatLit?,[String, Option.none, Option, Nat, Lean.Syntax.isLit?, Lean.Syntax.decodeNatLitVal?, Lean.numLitKind]]
[IO.Process.Output.noConfusionType,[]]
[instDecidableLe_2,[UInt16.decLe]]
[instPowNatNat,[Pow.mk, Nat, Nat.pow]]
[Array.foldrMUnsafe.fold,[ite, Eq, Bool, BEq.beq, USize, instBEq, instDecidableEqUSize, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, Bind.bind, Monad.toBind, Array.uget, HSub.hSub, instHSub, instSubUSize, OfNat.ofNat, instOfNatUSize, lcProof, LT.lt, Nat, instLTNat, USize.toNat, Array.size, Array.foldrMUnsafe.fold]]
[calc,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, calcStep, Lean.ParserDescr.const]]
[Option.getD,[]]
[heq_of_heq_of_eq,[HEq.trans, heq_of_eq]]
[Nat.add_comm,[Eq, Nat, HAdd.hAdd, instHAdd, instAddNat, Eq.symm, OfNat.ofNat, instOfNatNat, Nat.zero_add]]
[Std.Format.isNil,[Unit.unit, Std.Format.line, Std.Format.text, Std.Format.nest, Std.Format.append, Std.Format.group, Std.Format.tag, Bool, Bool.true, Bool.false]]
[instToStringExcept,[ToString.mk, Except, String, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString]]
[instSubsingletonPUnit,[Subsingleton.intro, PUnit, PUnit.subsingleton]]
[Std.Format.FlattenBehavior.noConfusionType,[noConfusionTypeEnum, Std.Format.FlattenBehavior, Nat, instDecidableEqNat, Std.Format.FlattenBehavior.toCtorIdx]]
[Char.repr,[Char.quote]]
[Subtype.property,[]]
[Lean.Parser.Tactic.«tactic·._»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[MonadReader.noConfusionType,[]]
[ExceptCpsT.instLawfulMonadExceptCpsT.proof_1,[LawfulMonad.mk, ExceptCpsT, ExceptCpsT.instMonadExceptCpsT, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, Functor.map, id, Function.comp, SeqLeft.seqLeft, Applicative.toSeqLeft, SeqRight.seqRight, Applicative.toSeqRight, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, Bind.bind, Monad.toBind]]
[Lean.Parser.Tactic.rewriteSeq,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq, Lean.Parser.Tactic.location]]
[Array.foldlM,[dite, LE.le, optParam, Nat, Array.size, instLENat, Nat.decLe, Array.foldlM.proof_1]]
[OfNat.ofNat,[]]
[System.FilePath.withFileName,[System.FilePath, Unit.unit, System.FilePath.parent, System.FilePath.mk, HDiv.hDiv, String, System.FilePath.instHDivFilePathStringFilePath]]
[IO.FS.Stream.mk.injEq,[Eq.propIntro, Eq, IO.FS.Stream, IO.FS.Stream.mk, And, IO, Bool, Unit, ByteArray, String, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[UInt64.val,[]]
[Array.append,[Array.foldl, Array, Array.push, OfNat.ofNat, Nat, instOfNatNat, Array.size]]
[instInhabitedUInt16,[Inhabited.mk, UInt16, UInt16.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, instInhabitedUInt16.proof_1]]
[List.span,[List.spanAux, List.nil]]
[Ordering.eq.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[«term_×__1»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.bracketedExplicitBinders, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Function.Equiv.symm,[Eq.symm]]
[Lean.Syntax.unsetTrailing,[Lean.SourceInfo.synthetic, Lean.SourceInfo.none, Lean.Syntax, Lean.Syntax.getTailInfo, Lean.Syntax.setTailInfo, Lean.SourceInfo.original, String.toSubstring]]
[IO.FileRight.mk.inj,[And, Eq, IO.AccessRight, IO.FileRight.mk, And.intro]]
[StateCpsT.runK,[]]
[Int.mul,[Int.ofNat, Int.negSucc, Int, HMul.hMul, Nat, instHMul, instMulNat, Int.negOfNat, Nat.succ]]
[ExceptT.instLawfulMonadExceptT.proof_1,[LawfulMonad.mk, ExceptT, ExceptT.instMonadExceptT, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, ExceptT.ext, Functor.map, id, of_eq_true, Eq, Except, ExceptT.run, Eq.trans, True, congrFun, congrArg, Except.map, ExceptT.run_map, Except.map_id, LawfulFunctor.id_map, LawfulApplicative.toLawfulFunctor, LawfulMonad.toLawfulApplicative, eq_self, ExceptT.seqLeft_eq, ExceptT.seqRight_eq, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, Except.ok, Except.error, congr, Bind.bind, Monad.toBind, ExceptT.seq_eq, ExceptT.run_bind, ExceptT.run_pure, funext, LawfulMonad.pure_bind, ExceptT.bind_pure_comp, Eq.mpr, LawfulMonad.bind_assoc, bind_congr, Eq.symm, Eq.refl]]
[IO.Process.StdioConfig.stderr,[]]
[Substring.startPos,[]]
[Lean.Parser.Tactic.failIfSuccess,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Nat.lt_trans,[Nat.le_trans, Nat.succ, Nat.le_step]]
[observing,[MonadExcept.tryCatch, Except, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.ok, Except.error]]
[Nat.lt_succ_self,[Nat.lt.base]]
[decide_false_eq_false,[False, Eq, Bool, Decidable.decide, Bool.false, rfl, Decidable.isFalse, False.elim, Decidable.isTrue]]
[StateCpsT.runK_modify,[rfl, StateCpsT.runK, PUnit, modify, StateCpsT, instMonadState, StateCpsT.instMonadStateOfStateCpsT]]
[Array.all,[Id.run, Bool, Array.allM, Id, Id.instMonadId]]
[Lean.MacroScopesView.mainModule,[]]
[instDecidableRelLtLtOfOrd,[inferInstanceAs, DecidableRel, Eq, Bool, BEq.beq, Ordering, instBEqOrdering, Ord.compare, Ordering.lt, Bool.true, instDecidableEqBool]]
[mkStdGen,[StdGen.mk, HAdd.hAdd, Nat, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
[unsafeCast.proof_1,[lcProof, Eq]]
[IO.eprint,[Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Stream, Unit, IO.getStderr, IO.FS.Stream.putStr, ToString.toString]]
[Lean.Syntax.atom.injEq,[Eq.propIntro, Eq, Lean.Syntax, Lean.Syntax.atom, And, Lean.SourceInfo, String, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Std.Format.FlattenBehavior.allOrNone.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[Lean.Parser.Syntax.subPrec,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Subsingleton.noConfusionType,[]]
[instComplementUInt64,[Complement.mk, UInt64, UInt64.complement]]
[Iff.subst,[Eq.subst, propext]]
[Decidable.noConfusionType,[]]
[List.forM_nil,[rfl, PUnit, ForM.forM, List, List.instForMList, List.nil]]
[IO.Process.Output.mk.injEq,[Eq.propIntro, Eq, IO.Process.Output, IO.Process.Output.mk, And, UInt32, String, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Applicative.toSeqLeft,[]]
[Option.isEqSome,[Bool, BEq.beq, Bool.false]]
[instInhabitedUInt8.proof_1,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt8.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
[Lean.expandExplicitBindersAux.loop,[Lean.MacroM, Lean.Syntax, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Bool.false, Bool.true, Lean.Syntax.isIdent, Bind.bind, Monad.toBind, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.Macro.instMonadRefMacroM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Macro.instMonadQuotationMacroM, Lean.Name, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[HEq.ndrec,[]]
[Lean.Parser.Tactic.simpAll,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma]]
[coe,[CoeT.coe]]
[UInt8.shiftRight,[UInt8.mk, HShiftRight.hShiftRight, Fin, UInt8.size, instHShiftRight, Fin.instShiftRightFin, UInt8.val, UInt8.modn, OfNat.ofNat, Nat, instOfNatNat]]
[Lean.Syntax.decodeScientificLitVal?.decodeExp,[ite, Option, Prod, Nat, Bool, Eq, BEq.beq, Char, instBEq, instDecidableEqChar, Char.ofNat, Bool.true, instDecidableEqBool, Lean.Syntax.decodeScientificLitVal?.decodeAfterExp, String.next, OfNat.ofNat, instOfNatNat, Bool.false]]
[Classical.indefiniteDescription,[Classical.choice, Subtype, Classical.indefiniteDescription.proof_1]]
[IO.FS.Handle.mk,[IO.FS.Handle.mkPrim, HAppend.hAppend, String, instHAppend, String.instAppendString]]
[ST.Ref.modifyGet,[liftM, ST, ST.Prim.Ref.modifyGet]]
[modify,[MonadState.modifyGet, PUnit, Prod.mk, PUnit.unit]]
[StateT.monadControl,[MonadControl.mk, StateT, Prod, Bind.bind, Monad.toBind, StateT.instMonadStateT, MonadState.get, instMonadState, instMonadStateOfStateT, liftM, instMonadLiftT, StateT.instMonadLiftStateT, instMonadLiftT_1, StateT.run, PUnit, MonadStateOf.set, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[Nat.lt_wfRel.proof_1,[WellFounded.intro, Nat, Nat.lt, Acc, Acc.intro, OfNat.ofNat, instOfNatNat, absurd, Nat.not_lt_zero, Nat.succ]]
[Substring.beq,[and, BEq.beq, Nat, instBEq, instDecidableEqNat, Substring.bsize, String, instDecidableEqString, Substring.toString]]
[instReprFloat,[Repr.mk, Float, Std.Format.text, Float.toString]]
[Std.Format.defWidth,[OfNat.ofNat, Nat, instOfNatNat]]
[IO.FS.Mode.noConfusionType,[noConfusionTypeEnum, IO.FS.Mode, Nat, instDecidableEqNat, IO.FS.Mode.toCtorIdx]]
[PSum.inl.injEq,[Eq.propIntro, Eq, PSum, PSum.inl, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[UInt32.toUInt64,[Nat.toUInt64, UInt32.toNat]]
[Substring.foldr,[String.foldrAux]]
[Nat.sub_zero,[rfl, Nat, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat]]
[Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat, LE.le, instLENat, LT.lt, instLTNat, Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1]]
[String.pushn,[Nat.repeat, String, String.push]]
[FloatArray.isEmpty,[BEq.beq, Nat, instBEq, instDecidableEqNat, FloatArray.size, OfNat.ofNat, instOfNatNat]]
[Fin.val_ne_of_ne,[absurd, Eq, Fin, False, Fin.eq_of_val_eq]]
[instInhabitedUInt64.proof_1,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt64.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
[Nat.repr,[List.asString, Nat.toDigits, OfNat.ofNat, Nat, instOfNatNat]]
[instReprSigma,[Repr.mk, Sigma, Std.Format, Std.Format.bracket, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, repr, Std.Format.text]]
[String.data,[]]
[Lean.Parser.Tactic.Conv.convSkip,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[ST.Ref.swap,[liftM, ST, ST.Prim.Ref.swap]]
[Lean.unifConstraint,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
[Array.foldrM.fold,[ite, Eq, Bool, BEq.beq, Nat, instBEq, instDecidableEqNat, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[IO.FS.FileType.file.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[UInt32.noConfusionType,[]]
[List.isPrefixOf,[Bool, List.nil, List.cons, Bool.true, Bool.false, and, BEq.beq, PProd.fst, PUnit, PProd]]
[IO.Process.StdioConfig.mk.injEq,[Eq.propIntro, Eq, IO.Process.StdioConfig, IO.Process.StdioConfig.mk, And, IO.Process.Stdio, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Array.modify,[Id.run, Array, Array.modifyM, Id, Id.instMonadId]]
[Mod.noConfusionType,[]]
[instDecidableRelLeLeOfOrd,[inferInstanceAs, DecidableRel, Eq, Bool, Ordering.isLE, Ord.compare, Bool.true, instDecidableEqBool]]
[Lean.NameGenerator.curr,[Lean.Name.mkNum, Lean.NameGenerator.namePrefix, Lean.NameGenerator.idx]]
[Except.toBool,[Bool, Bool.true, Bool.false]]
[IO.Error.mkOtherError,[IO.Error.otherError]]
[Classical.typeDecidable,[Nonempty, PSum, False, Classical.propDecidable, PSum.inl, arbitrary, Classical.inhabited_of_nonempty, PSum.inr, Classical.typeDecidable.proof_1]]
[ST.instInhabitedRef,[Inhabited.mk, ST.Ref, ST.Ref.mk, PointedType.val, ST.RefPointed, ST.instInhabitedRef.proof_1]]
[List.map₂,[List, List.nil, List.cons, PProd.fst, PUnit, PProd]]
[List.set,[List, List.cons, PProd.fst, PUnit, PProd, List.nil]]
[HOr.hOr,[]]
[Array.zipWith,[Array.zipWithAux, OfNat.ofNat, Nat, instOfNatNat, List.toArray, List.nil]]
[PProd.fst,[]]
[LawfulMonad.bind_map,[]]
[List.hasDecidableLt.proof_2,[List.cons, List.nil, List, Eq.refl, HEq.refl, LT.lt, List.instLTList, False]]
[Eq.symm,[Eq, rfl]]
[UInt8.sub,[UInt8.mk, HSub.hSub, Fin, UInt8.size, instHSub, Fin.instSubFin, UInt8.val]]
[String.toLower,[String.map, Char.toLower]]
[UInt16.decEq.proof_2,[False, UInt16.mk, absurd, Eq, Fin, UInt16.size]]
[Std.Format.tag.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat, Std.Format, SizeOf.mk, String, List, Char, UInt32, Fin, UInt32.size, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar, Int, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone]]
[ExceptT.run_bind_lift,[of_eq_true, Eq, Except, Bind.bind, Monad.toBind, Functor.map, Applicative.toFunctor, Monad.toApplicative, Except.ok, Pure.pure, Applicative.toPure, Except.error, Eq.trans, True, congrFun, congrArg, map_eq_pure_bind, LawfulMonad.bind_assoc, funext, LawfulMonad.pure_bind, eq_self]]
[unexpandListToArray,[ite, Lean.PrettyPrinter.UnexpandM, Lean.Syntax, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.matchesNull, OfNat.ofNat, Nat, instOfNatNat, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
[instToStringString,[ToString.mk, String]]
[IO.FS.SystemTime.mk.inj,[And, Eq, Int, UInt32, IO.FS.SystemTime.mk, And.intro]]
[InvImage.wf.proof_1,[WellFounded.intro, InvImage, InvImage.accessible, WellFounded.apply]]
[IO.FS.instReprDirEntry,[Repr.mk, IO.FS.DirEntry, Std.Format.bracket, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.nil, Std.Format.text, repr, System.FilePath, System.instReprFilePath, IO.FS.DirEntry.root, Std.Format.line, String, instReprString, IO.FS.DirEntry.fileName]]
[instOfScientificFloat,[OfScientific.mk, Float, Float.ofScientific]]
[Nat.pow_zero,[rfl, Nat, HPow.hPow, instHPow, instPowNatNat, OfNat.ofNat, instOfNatNat]]
[EmptyCollection.noConfusionType,[]]
[Nat.le_of_ble_eq_true,[LE.le, Nat, instLENat, Nat.succ, Bool, Nat.ble, Nat.zero, Bool.true, Bool.false, Eq.refl, HEq.refl, Eq, Nat.zero_le, Nat.succ_le_succ, PProd.fst, PUnit, PProd]]
[Array.binSearch,[ite, Option, LT.lt, optParam, Nat, OfNat.ofNat, instOfNatNat, instLTNat, Array.size, Nat.decLt, Array.binSearchAux, instInhabitedOption, id, Option.none]]
[«term∅»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
[Std.Format.appendEx,[Std.Format.append]]
[dbgTraceVal,[dbgTrace, ToString.toString]]
[Nat.le_succ,[Nat.le.step, Nat.le.refl]]
[instComplementUSize,[Complement.mk, USize, USize.complement]]
[instHOrElse,[HOrElse.mk, OrElse.orElse]]
[DoResultPRBC.break.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.case,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary]]
[ExceptT.bind,[ExceptT.mk, Bind.bind, Monad.toBind, Except, ExceptT.bindCont]]
[instDecidableLt_3,[UInt64.decLt]]
[Ordering.gt.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[Classical.inhabited_of_exists.proof_1,[Exists.elim, Nonempty, Nonempty.intro]]
[MonadExceptOf.noConfusionType,[]]
[ByteArray.mk.inj,[Eq, Array, UInt8, ByteArray.mk]]
[Fin.noConfusionType,[]]
[Option.any,[Unit.unit, Bool, Bool.false]]
[Float.val,[]]
[String.instInhabitedString,[Inhabited.mk, String]]
[mt,[]]
[instAddFloat,[Add.mk, Float, Float.add]]
[Acc.inv.proof_1,[Acc]]
[UInt8.mod,[UInt8.mk, HMod.hMod, Fin, UInt8.size, instHMod, Fin.instModFin, UInt8.val]]
[instInhabitedReaderT,[Inhabited.mk, ReaderT, arbitrary]]
[LT.noConfusionType,[]]
[StdGen.noConfusionType,[]]
[IO.setRandSeed,[ST.Ref.set, IO.RealWorld, IO, instMonadLiftT, ST, IO.instMonadLiftSTRealWorldEIO, IO.Error, instMonadLiftT_1, StdGen, IO.stdGenRef, mkStdGen]]
[Lean.MacroScopesView.imported,[]]
[HDiv.hDiv,[]]
[EStateM.instReprResult,[Repr.mk, EStateM.Result, Std.Format, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, reprArg]]
[instOrOpUInt64,[OrOp.mk, UInt64, UInt64.lor]]
[UInt64.complement,[HSub.hSub, UInt64, instHSub, instSubUInt64, OfNat.ofNat, instOfNatUInt64, HAdd.hAdd, instHAdd, instAddUInt64]]
[IO.FS.Mode.append.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[Lean.Parser.Tactic.Conv.convSeq1Indented,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
[Lean.Macro.mkMethodsImp,[unsafeCast, Lean.Macro.Methods, PointedType.type]]
[Lean.Macro.Methods.hasDecl,[]]
[instHasEquiv,[HasEquiv.mk, Setoid.r]]
[Prod.noConfusionType,[]]
[ReaderT.run_read,[rfl, ReaderT.run, ReaderT.read]]
[ForInStep.done.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[Nat.succ.inj,[Eq, Nat, Nat.succ]]
[Lean.Syntax.getArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Array, Lean.Syntax, Array.empty]]
[IO.Error.otherError.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, UInt32, SizeOf.mk, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, String, List, Char, UInt32.isValidChar]]
[OfNat.noConfusionType,[]]
[IO.Error.resourceVanished.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.resourceVanished, And, UInt32, String, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[List.iota,[List, Nat, Unit.unit, Nat.succ, List.nil, List.cons, PProd.fst, PUnit, PProd]]
[ST.Ref.modify,[liftM, ST, Unit, ST.Prim.Ref.modify]]
[Lean.Name.instReprSyntax,[Repr.mk, Lean.Syntax]]
[«stx_,+,?»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
[String.take,[Substring.toString, Substring.take, String.toSubstring]]
[StateT.instAlternativeStateT,[Alternative.mk, StateT, Monad.toApplicative, StateT.instMonadStateT, StateT.failure, StateT.orElse]]
[unexpandListNil,[Bind.bind, Lean.PrettyPrinter.UnexpandM, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.Syntax, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
[Nat.pred_le,[Unit.unit, LE.le, Nat, instLENat, Nat.pred, Nat.le.refl, Nat.zero, Nat.le_succ, Nat.succ]]
[IO.Error.illegalOperation.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.illegalOperation, And, UInt32, String, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.runEval,[IO.FS.withIsolatedStreams, IO, Unit, instMonadEIO, IO.Error, instMonadFinallyEIO, instMonadExceptOfEIO, instMonadLiftT_1, Lean.Eval.eval, Bool.false]]
[typedExpr,[]]
[List.notElem,[not, List.elem]]
[Subarray.popFront,[dite, Subarray, LT.lt, Nat, instLTNat, Subarray.start, Subarray.stop, Nat.decLt, Subarray.mk, Subarray.as, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Subarray.popFront.proof_1, Subarray.h₂]]
[Array.instBEqArray,[BEq.mk, Array, Array.isEqv, BEq.beq]]
[OptionT.mk,[]]
[instToStreamRangeRange,[ToStream.mk, Std.Range]]
[Std.Format.defUnicode,[Bool.true]]
[Nat.ble_self_eq_true,[Eq, Bool, Nat.ble, Bool.true, Unit.unit, rfl, OfNat.ofNat, Nat, instOfNatNat, PProd.fst, PUnit, PProd]]
[Substring.dropWhile,[Substring, Substring.mk]]
[instMulUInt32,[Mul.mk, UInt32, UInt32.mul]]
[System.FilePath.instHDivFilePathStringFilePath,[HDiv.mk, System.FilePath, String, System.FilePath.join, System.FilePath.mk]]
[Lean.Name.instToStringName,[ToString.mk, Lean.Name, Lean.Name.toString, Bool.true]]
[HShiftLeft.hShiftLeft,[]]
[List.tail!,[Unit.unit, List, panicWithPosWithDecl, instInhabitedList, OfNat.ofNat, Nat, instOfNatNat]]
[HEq.ndrecOn,[]]
[Lean.Meta.Rewrite.Config.transparency,[]]
[instHashableNat,[Hashable.mk, Nat, UInt64.ofNat]]
[MonadExcept.orelse',[MonadExcept.tryCatch, MonadExcept.throw, ite, Eq, Bool, Bool.true, instDecidableEqBool]]
[Quot.exists_rep,[Quot.inductionOn, Exists, Eq, Quot, Quot.mk, Exists.intro, rfl]]
[ne_false_of_self,[False]]
[Lean.instQuoteNat,[Lean.Quote.mk, Nat, Lean.Syntax.mkNumLit, ToString.toString, instToStringNat, Lean.SourceInfo.none]]
[Lean.Parser.Tactic.generalize,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.generalizeArg, Lean.ParserDescr.symbol]]
[String.Iterator.forward,[String.Iterator, PProd.fst, PUnit, PProd, String.Iterator.next]]
[Sum.inhabitedRight,[Inhabited.mk, Sum, Sum.inr, arbitrary]]
[Lean.Name.sizeOf,[Nat, Unit.unit, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, PProd.fst, PUnit, PProd, SizeOf.sizeOf, String, SizeOf.mk, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar]]
[instLTUInt32,[LT.mk, UInt32, LT.lt, Fin, UInt32.size, instLTFin, UInt32.val]]
[Array.getEvenElems,[Prod.snd, Bool, Array, Array.foldl, Prod, ite, Eq, Bool.true, instDecidableEqBool, Prod.mk, Bool.false, Array.push, Array.empty, OfNat.ofNat, Nat, instOfNatNat, Array.size]]
[List.length_append,[Eq, Nat, List.length, HAppend.hAppend, List, instHAppend, List.instAppendList, HAdd.hAdd, instHAdd, instAddNat, of_eq_true, List.nil, Eq.trans, True, congr, congrArg, List.nil_append, OfNat.ofNat, instOfNatNat, congrFun, List.length_nil, Nat.zero_add, eq_self, List.cons, Nat.succ, List.cons_append, List.length_cons, Nat.succ_add]]
[Std.Range.«term[:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[«term_∨_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Array.modifyM,[dite, Array, LT.lt, Nat, instLTNat, Array.size, Nat.decLt, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.set, arbitrary, Array.modifyM.proof_1]]
[Lean.Parser.Tactic.Conv.convSeqBracketed,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat]]
[List.toString,[Unit.unit, String, HAppend.hAppend, instHAppend, String.instAppendString, List.toStringAux, Bool.true, List.cons]]
[MonadControl.stM,[]]
[Array.findIdx?.loop.proof_1,[absurd, LT.lt, Nat, instLTNat, Array.size, False, Eq.mp, Eq, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Nat.zero_add, Nat.lt_irrefl]]
[ReaderT.instLawfulMonadReaderT,[ReaderT.instLawfulMonadReaderT.proof_1]]
[Lean.instEval,[Lean.Eval.mk, IO.println, String, instToStringString, ToString.toString, Unit.unit]]
[Std.Format.nest.inj,[And, Eq, Int, Std.Format, Std.Format.nest, And.intro]]
[OptionT.lift,[OptionT.mk, Bind.bind, Monad.toBind, Option, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.some]]
[Std.Format.FlattenBehavior.toCtorIdx,[Nat, OfNat.ofNat, instOfNatNat]]
[Lean.Meta.Rewrite.Config.mk.injEq,[Eq.propIntro, Eq, Lean.Meta.Rewrite.Config, Lean.Meta.Rewrite.Config.mk, And, Lean.Meta.TransparencyMode, Bool, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.fieldIdxKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[Lean.Option.hasQuote,[Lean.Quote.mk, Option, Unit.unit, Lean.Syntax, Lean.mkIdent, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.mkCApp, List.toArray, List.cons, Lean.Quote.quote, List.nil]]
[«term[_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false]]
[Lean.isSubScriptAlnum,[or, Lean.isNumericSubscript, and, Decidable.decide, LE.le, UInt32, instLEUInt32, OfNat.ofNat, instOfNatUInt32, Char.val, instDecidableLe]]
[List.toFloatArray,[FloatArray.empty, List.toFloatArray.loop]]
[String.getOp,[String.get]]
[Lean.Parser.Tactic.Conv.convIntro___,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[Lean.Parser.Tactic.intro,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Setoid.refl,[Equivalence.refl, Setoid.r, Setoid.iseqv]]
[UInt16.sub,[UInt16.mk, HSub.hSub, Fin, UInt16.size, instHSub, Fin.instSubFin, UInt16.val]]
[String.toUpper,[String.map, Char.toUpper]]
[Lean.Syntax.noConfusionType,[]]
[CoeHead.coe,[]]
[seq_eq_bind,[Eq.mpr, Eq, Seq.seq, Applicative.toSeq, Monad.toApplicative, Bind.bind, Monad.toBind, Functor.map, Applicative.toFunctor, Eq.refl, LawfulMonad.bind_map, rfl]]
[Lean.Syntax.SepArray.instCoeTailSepArrayArraySyntax,[CoeTail.mk, Lean.Syntax.SepArray, Array, Lean.Syntax, Lean.Syntax.SepArray.getElems]]
[PSigma.revLexAccessible.proof_1,[Acc, PSigma, PSigma.RevLex, PSigma.mk, Acc.intro, PSigma.RevLex.left, Eq.symm, eq_of_heq, PSigma.RevLex.right, Eq.refl, HEq.refl]]
[instOfNatUInt64,[OfNat.mk, UInt64, UInt64.ofNat]]
[WellFoundedRelation.noConfusionType,[]]
[instMonadStateOfStateT,[MonadStateOf.mk, StateT, StateT.get, StateT.set, StateT.modifyGet]]
[withPtrEqDecEq.proof_1,[toBoolUsing_eq_true, Eq, Unit.unit]]
[DoResultSBC.pureReturn.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[instReprAtomChar,[ReprAtom.mk, Char]]
[PSigma.skipLeft.proof_1,[PSigma.revLex, emptyRelation, WellFoundedRelation.rel, WellFoundedRelation.wf, emptyWf]]
[instSubUSize,[Sub.mk, USize, USize.sub]]
[instMonadReader,[MonadReader.mk, readThe]]
[Lean.Syntax.matchesIdent,[and, Lean.Syntax.isIdent, BEq.beq, Lean.Name, Lean.Name.instBEqName, Lean.Syntax.getId]]
[HPow.hPow,[]]
[instDecidableEqBool.proof_2,[False, Bool.true, Bool.false]]
[instReprTupleProd,[ReprTuple.mk, Prod, List, Std.Format, ReprTuple.reprTuple, List.cons, repr]]
[instDecidableOr.proof_1,[False]]
[congr,[Eq, rfl]]
[Nat.decLt,[Nat.decLe, Nat.succ]]
[FloatSpec.decLe,[]]
[StateCpsT.runK_pure,[rfl, StateCpsT.runK, Pure.pure, StateCpsT, Applicative.toPure, Monad.toApplicative, StateCpsT.instMonadStateCpsT]]
[withPtrEqDecEq.proof_2,[ofBoolUsing_eq_true, Eq, Unit.unit]]
[«prio(_)»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[IO.Process.StdioConfig.stdout,[]]
[Classical.propDecidable,[Classical.choice, Decidable, Classical.propDecidable.proof_1]]
[String.decLt,[List.hasDecidableLt, Char, Char.instLTChar, Char.instDecidableLt, String.data]]
[noConfusionEnum.proof_2,[congrArg]]
[List.length_reverse,[Eq, Nat, List.length, List.reverse, rfl, List.nil, of_eq_true, List.cons, Eq.trans, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, OfNat.ofNat, instOfNatNat, True, congr, congrArg, HAppend.hAppend, List, instHAppend, List.instAppendList, List.reverse_cons, List.length_append, List.length_cons, List.length_nil, eq_self]]
[Setoid.noConfusionType,[]]
[Lean.expandBrackedBindersAux,[Array.size, Lean.Syntax, Lean.expandBrackedBindersAux.loop]]
[IO.Process.Stdio.null.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[IO.Error.noFileOrDirectory.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, String, SizeOf.mk, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar]]
[PSigma.lexNdep,[PSigma.Lex]]
[StateCpsT.instLawfulMonadStateCpsT.proof_1,[LawfulMonad.mk, StateCpsT, StateCpsT.instMonadStateCpsT, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, Functor.map, id, Function.comp, SeqLeft.seqLeft, Applicative.toSeqLeft, SeqRight.seqRight, Applicative.toSeqRight, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, Bind.bind, Monad.toBind]]
[String.Iterator.next,[String.Iterator, String.Iterator.mk, String.next]]
[Lean.Parser.Syntax.addPrec,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instDecidableLe,[UInt32.decLe]]
[instLTUSize,[LT.mk, USize, USize.lt]]
[instMonadExceptOfExcept,[MonadExceptOf.mk, Except, Except.error, Except.tryCatch]]
[Subarray.stop,[]]
[ForM.forM,[]]
[Char.isValidChar_of_isValidChar_Nat,[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, And, Or.inr, isValidChar, UInt32.ofNat', Char.isValidUInt32, Or.inl, UInt32, instLTUInt32, instOfNatUInt32, And.intro]]
[FloatSpec.mk.injEq,[Eq.propIntro, Eq, FloatSpec, FloatSpec.mk, And, HEq, DecidableRel, And.intro, Eq.refl, HEq.refl, Eq.symm, eq_of_heq]]
[MonadWithReader.noConfusionType,[]]
[fix5,[fixCore5, arbitrary]]
[Nat.toUInt16,[UInt16.ofNat]]
[Lean.idBeginEscape,[Char.ofNat]]
[IO.Process.SpawnArgs.env,[]]
[Classical.propDecidable.proof_1,[Not, Nonempty, Decidable, Classical.em, Nonempty.intro, Decidable.isTrue, Decidable.isFalse]]
[ne_true_of_eq_false,[Not, Eq, Bool, Bool.true, Bool.false, False]]
[EST,[EStateM]]
[IO.lazyPure,[Pure.pure, IO, Applicative.toPure, Monad.toApplicative, instMonadEIO, IO.Error, Unit.unit]]
[ExceptT.instMonadExceptT,[Monad.mk, ExceptT, Applicative.mk, Functor.mk, ExceptT.map, Pure.mk, ExceptT.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk, ExceptT.bind]]
[IO.FS.withFile,[Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle, IO.FS.Handle.mk, Bool.true]]
[floatDecLe,[Float.decLe]]
[instBEq,[BEq.mk, Decidable.decide, Eq]]
[IO.FS.Stream.Buffer.noConfusionType,[]]
[instShiftRightUInt8,[ShiftRight.mk, UInt8, UInt8.shiftRight]]
[Int.sub,[HAdd.hAdd, Int, instHAdd, Int.instAddInt, Neg.neg, Int.instNegInt]]
[IO.FS.Stream.isEof,[]]
[Lean.PrettyPrinter.UnexpandM,[EStateM, Unit]]
[IO.AccessRight.flags,[UInt32.lor]]
[Char.valid,[]]
[StateCpsT.run,[StateCpsT.runK, Prod, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk]]
[List.or,[List.any, Bool, id]]
[Lean.Syntax.setArg,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.node, Array.setD]]
[Lean.«termMacro.trace[__]_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[ULift.up_down,[Eq, ULift, ULift.up, ULift.down, rfl]]
[prioMid,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Or.elim,[]]
[IO.eprintln,[IO.eprint, String, instToStringString, String.push, ToString.toString, Char.ofNat]]
[instHDiv,[HDiv.mk, Div.div]]
[Lean.Parser.Tactic.Conv.nestedTactic,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Nat.lt_of_succ_lt_succ,[Nat.le_of_succ_le_succ, HAdd.hAdd, Nat, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
[Lean.Parser.Tactic.tacticUnhygienic_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Alternative.noConfusionType,[]]
[instToFormatArray,[Std.ToFormat.mk, Array, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.text, Std.ToFormat.format, List, instToFormatList, Array.toList]]
[StateRefT'.set,[ST.Ref.set]]
[Quotient.recOnSubsingleton₂,[Quot.recOnSubsingleton, Setoid.r, Quotient.recOnSubsingleton₂.proof_1, Quot.mk, Quotient.recOnSubsingleton₂.proof_2]]
[Lean.Macro.Context.ref,[]]
[Prod.mk.injEq,[Eq.propIntro, Eq, Prod, Prod.mk, And, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[instDecidableEqSum,[Sum.inl, Sum.inr, Decidable, Eq, Sum, dite, Decidable.isTrue, instDecidableEqSum.proof_1, Decidable.isFalse, instDecidableEqSum.proof_2, instDecidableEqSum.proof_3, instDecidableEqSum.proof_4, instDecidableEqSum.proof_5, instDecidableEqSum.proof_6]]
[instLTUInt64,[LT.mk, UInt64, UInt64.lt]]
[instShiftRightUInt64,[ShiftRight.mk, UInt64, UInt64.shiftRight]]
[Lean.Parser.Tactic.tacticRfl,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[coeHead,[CoeHead.coe]]
[ExceptT.seqRight_eq,[]]
[Lean.termEval_prec_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[IO.toEIO,[EStateM.adaptExcept, IO.Error, IO.RealWorld]]
[instReprUInt32,[Repr.mk, UInt32, repr, Nat, instReprNat, UInt32.toNat]]
[instDivUInt16,[Div.mk, UInt16, UInt16.div]]
[instToStringUSize,[ToString.mk, USize, ToString.toString, Nat, instToStringNat, USize.toNat]]
[System.instCoeStringFilePath,[Coe.mk, String, System.FilePath, System.FilePath.mk]]
[MonadWithReaderOf.noConfusionType,[]]
[List.contains,[List.elem]]
[instDecidableIff.proof_4,[Iff.intro, absurd]]
[Pure.pure,[]]
[IO.Error.noSuchThing.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.noSuchThing, And, Option, String, UInt32, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[instDecidableLe_4,[USize.decLe]]
[Array.ext.extAux,[Eq, List, List.nil, rfl, Eq.symm, List.cons, List.length, Nat.succ, Eq.mp, Nat, Eq.refl, List.length_cons]]
[List.length_cons,[rfl, Nat, List.length, List.cons]]
[Lean.mkNode,[Lean.Syntax.node]]
[Nat.zero_ne_one,[False, OfNat.ofNat, Nat, instOfNatNat]]
[ST.Prim.Ref.modifyGetUnsafe,[Bind.bind, ST, Monad.toBind, instMonadST, ST.Prim.Ref.take, Unit, ST.Prim.Ref.set, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[Classical.strongIndefiniteDescription.proof_1,[Subtype.property, Classical.indefiniteDescription]]
[StateRefT'.modifyGet,[ST.Ref.modifyGet]]
[instSubsingletonDecidable,[instSubsingletonDecidable.proof_1]]
[prioLow,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[IO.Error.resourceVanished.inj,[And, Eq, UInt32, String, IO.Error.resourceVanished, And.intro]]
[IO.Error.otherError.inj,[And, Eq, UInt32, String, IO.Error.otherError, And.intro]]
[List.dropLast,[List, Unit.unit, List.cons, List.nil, PProd.fst, PUnit, PProd]]
[if_pos,[Eq, ite, rfl, Decidable.isTrue, absurd, Decidable.isFalse]]
[Lean.Parser.Tactic.Conv.convLeft,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[List.maximum?,[Unit.unit, Option, Option.none, Option.some, List.foldl, max]]
[Char.utf8Size.proof_3,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
[UInt16.lor,[UInt16.mk, Fin.lor, UInt16.size, UInt16.val]]
[Nat.shiftRight,[Nat, HDiv.hDiv, instHDiv, Nat.instDivNat, PProd.fst, PUnit, PProd, OfNat.ofNat, instOfNatNat]]
[Quotient.liftOn₂,[Quotient.lift₂]]
[Lean.Parser.Tactic.Conv.convRw__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq]]
[modifyGetThe,[MonadStateOf.modifyGet]]
[Lean.evalPrec,[Lean.Macro.withIncRecDepth, Nat, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Syntax, Lean.expandMacros, cond, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.getD, Lean.Syntax.isNatLit?, OfNat.ofNat, instOfNatNat, Lean.Macro.throwErrorAt]]
[Array.findSomeRevM?.find,[Option, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.none]]
[Std.ToFormat.format,[]]
[StateCpsT.runK_bind_set,[rfl, StateCpsT.runK, Bind.bind, StateCpsT, Monad.toBind, StateCpsT.instMonadStateCpsT, PUnit, MonadStateOf.set, StateCpsT.instMonadStateOfStateCpsT]]
[instInhabitedList,[Inhabited.mk, List, List.nil]]
[Std.Format.prefixJoin,[Std.Format, Unit.unit, Std.Format.nil, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.ToFormat.format, PProd.fst, PUnit, PProd]]
[addParenHeuristic,[ite, String, Eq, Bool, or, String.isPrefixOf, Bool.true, instDecidableEqBool, not, String.any, Char.isWhitespace, HAppend.hAppend, instHAppend, String.instAppendString]]
[Setoid.iseqv,[]]
[«term_|>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Id.instMonadId,[Monad.mk, Id, Applicative.mk, Functor.mk, Pure.mk, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk]]
[Iff.mp,[]]
[coeOfTC,[CoeHTCT.mk, coeTC]]
[MonadLift.noConfusionType,[]]
[PSigma.revLexAccessible,[PSigma.revLexAccessible.proof_1]]
[Lean.termEval_prio_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[IO.Error.userError.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, String, SizeOf.mk, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar]]
[String.startsWith,[BEq.beq, Substring, Substring.hasBeq, Substring.take, String.toSubstring, String.length]]
[IO.FS.DirEntry.mk.inj,[And, Eq, System.FilePath, String, IO.FS.DirEntry.mk, And.intro]]
[UInt32.shiftRight,[UInt32.mk, HShiftRight.hShiftRight, Fin, UInt32.size, instHShiftRight, Fin.instShiftRightFin, UInt32.val, UInt32.modn, OfNat.ofNat, Nat, instOfNatNat]]
[Lean.Parser.Tactic.«tactic_<;>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[HAndThen.noConfusionType,[]]
[instMonadFunctorT,[MonadFunctorT.mk, MonadFunctor.monadMap, MonadFunctorT.monadMap]]
[true_iff,[propext, Iff, True, Iff.intro, Iff.mp, trivial]]
[instReprInt,[Repr.mk, Int, Std.Format.text, Int.repr]]
[MonadExcept.orElse,[MonadExcept.tryCatch, Unit.unit]]
[WellFounded.induction,[WellFounded.recursion]]
[«term#[_,]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false]]
[Ordering.toCtorIdx,[Nat, OfNat.ofNat, instOfNatNat]]
[IO.FS.lines,[Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle, Array, String, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.false, List.toArray, List.nil, IO.FS.lines.read]]
[Lean.Parser.Tactic.letrec,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Substring.extract,[Substring, ite, GE.ge, String.Pos, instLENat, Nat.decLe, Substring.mk, OfNat.ofNat, instOfNatNat, Nat.min, HAdd.hAdd, instHAdd, instAddNat]]
[IO.instInhabitedError,[Inhabited.mk, IO.Error, IO.Error.alreadyExists, arbitrary, Option, String, instInhabitedOption, UInt32, instInhabitedUInt32, String.instInhabitedString]]
[Nat.allM,[Nat.allM.loop]]
[panic,[panicCore]]
[IO.FS.Stream.putStr,[]]
[Lean.Parser.Tactic.locationTargets,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[Eq.mpr,[Eq.symm]]
[FloatArray.noConfusionType,[]]
[String.mkIterator,[String.Iterator.mk, OfNat.ofNat, String.Pos, instOfNatNat]]
[Std.Format.append.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Std.Format, SizeOf.mk, String, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar, Int, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone]]
[Substring.prev,[String.Pos, ite, Eq, instDecidableEqNat, HSub.hSub, instHSub, instSubNat, String.prev]]
[System.FilePath.join,[ite, System.FilePath, Eq, Bool, System.FilePath.isAbsolute, Bool.true, instDecidableEqBool, System.FilePath.mk, HAppend.hAppend, String, instHAppend, String.instAppendString, System.FilePath.toString, Char.toString, System.FilePath.pathSeparator]]
[readThe,[MonadReaderOf.read]]
[IO.Process.Stdio.toCtorIdx,[Nat, OfNat.ofNat, instOfNatNat]]
[Lean.mkHole,[Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, Lean.Syntax, List.cons, Lean.mkAtomFrom, List.nil]]
[Lean.Parser.Tactic.change,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.Parser.Tactic.location]]
[List.isSuffixOf,[List.isPrefixOf, List.reverse]]
[StateT.instMonadLiftStateT,[MonadLift.mk, StateT, StateT.lift]]
[Array.zip,[Array.zipWith, Prod, Prod.mk]]
[Prod.lex,[WellFoundedRelation.mk, Prod, Prod.Lex, WellFoundedRelation.rel, Prod.lex.proof_1]]
[Char.instLEChar,[LE.mk, Char, Char.le]]
[Nat.le_add_right,[LE.le, Nat, instLENat, HAdd.hAdd, instHAdd, instAddNat, Nat.le_refl, Nat.le_succ_of_le, Nat.add, PProd.fst, PUnit, PProd]]
[List.nil_append,[rfl, List, HAppend.hAppend, instHAppend, List.instAppendList, List.nil]]
[Array.size_push,[List.length_concat, Array.data]]
[NonScalar.noConfusionType,[]]
[List.hasDecEq,[Decidable, Eq, List, List.nil, Unit.unit, List.cons, Decidable.isTrue, List.hasDecEq.proof_1, Decidable.isFalse, List.hasDecEq.proof_2, List.hasDecEq.proof_3, decEq, PProd.fst, PUnit, PProd, List.hasDecEq.proof_4, List.hasDecEq.proof_5, List.hasDecEq.proof_6]]
[Lean.Module.mk.injEq,[Eq.propIntro, Eq, Lean.Module, Lean.Module.mk, And, Lean.Syntax, Array, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.pred_le_pred,[Nat.zero, LE.le, Nat, instLENat, Nat.le.refl, Eq.symm, eq_of_heq, Nat.succ, Eq.refl, HEq.refl, Nat.le.step, Nat.pred, Nat.le_trans, Nat.le_succ]]
[String.isInt,[ite, Bool, Eq, Char, String.get, OfNat.ofNat, String.Pos, instOfNatNat, Char.ofNat, instDecidableEqChar, Substring.isNat, Substring.drop, String.toSubstring, Nat, String.isNat]]
[«term{}»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol]]
[System.Platform.isWindows,[System.Platform.getIsWindows, Unit.unit]]
[Mod.mod,[]]
[Except.orElseLazy,[Except, Except.ok, Unit.unit]]
[Std.Format.instAppendFormat,[Append.mk, Std.Format, Std.Format.append]]
[Char.val_eq_of_eq,[Char, Eq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl, UInt32, Char.val, rfl]]
[USize.decLt,[USize.mk, Decidable, LT.lt, USize, instLTUSize, inferInstanceAs, Fin, USize.size, instLTFin, Fin.decLt]]
[Lean.Parser.Syntax.subPrio,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[ExceptT.lift_pure,[of_eq_true, Eq, ExceptT, ExceptT.mk, Functor.map, Applicative.toFunctor, Monad.toApplicative, Except, Except.ok, Pure.pure, Applicative.toPure, Eq.trans, True, congrFun, congrArg, LawfulApplicative.map_pure, LawfulMonad.toLawfulApplicative, eq_self]]
[UInt32.toUInt8,[Nat.toUInt8, UInt32.toNat]]
[List.firstM,[Unit.unit, Alternative.failure, HOrElse.hOrElse, instHOrElse, instOrElse, PProd.fst, PUnit, PProd]]
[List.takeWhile,[List, Unit.unit, List.nil, List.cons, PProd.fst, PUnit, PProd]]
[Int.instMulInt,[Mul.mk, Int, Int.mul]]
[Nat.mod_eq_sub_mod,[Eq, Nat, OfNat.ofNat, instOfNatNat, GT.gt, instLTNat, HMod.hMod, instHMod, Nat.instModNat, HSub.hSub, instHSub, instSubNat, Nat.eq_zero_or_pos, rfl, Eq.symm, Nat.sub_zero, ite, And, LT.lt, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, if_pos, And.intro, Nat.mod_eq]]
[withPtrEqUnsafe,[ite, Bool, Eq, BEq.beq, USize, instBEq, instDecidableEqUSize, ptrAddrUnsafe, Bool.true, instDecidableEqBool, Unit.unit]]
[UInt8.ofNat,[UInt8.mk, Fin.ofNat, OfNat.ofNat, Nat, instOfNatNat]]
[List.dropWhile,[List, Unit.unit, List.nil, PProd.fst, PUnit, PProd, List.cons]]
[IO.Error.permissionDenied.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Option, String, SizeOf.mk, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar]]
[PSigma.revLex.proof_1,[WellFounded.intro, PSigma, PSigma.RevLex, Acc, PSigma.revLexAccessible, WellFounded.apply]]
[Lean.Syntax.setKind,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Lean.Syntax, Lean.Syntax.node]]
[MonadFinally.noConfusionType,[]]
[Lean.Parser.Tactic.refine,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Eq.mp,[]]
[Nat.add_zero,[rfl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
[Std.Range.forIn,[Std.Range.stop, Std.Range.start, Std.Range.forIn.loop]]
[System.FilePath.components,[String.splitOn, System.FilePath.toString, System.FilePath.normalize, Bool.false, Char.toString, System.FilePath.pathSeparator]]
[Option.some.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[Lean.Parser.Tactic.induction,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlts]]
[Subrelation.accessible,[Subrelation.accessible.proof_1]]
[List.eraseDups,[List.eraseDupsAux, List.nil]]
[List.mapTR,[List.mapTRAux, List.nil]]
[IO.Error.mkNoSuchThing,[IO.Error.noSuchThing, Option.none, String]]
[Array.size,[List.length, Array.data]]
[Coe.noConfusionType,[]]
[Int.negOfNat,[Unit.unit, Int, OfNat.ofNat, hasOfNatOfCoe, Nat, instCoeNatInt, instOfNatNat, Int.negSucc]]
[Decidable.byContradiction,[Decidable.byCases, id, False.elim]]
[Subarray.noConfusionType,[]]
[Substring.takeRightWhile,[Substring, Substring.mk]]
[false_implies,[propext, True, Iff.intro, trivial, absurd, False, of_decide_eq_false, instDecidableFalse, Eq.refl, Bool, Decidable.decide]]
[String.anyAux,[String.anyAux.loop]]
[instHModUInt8NatUInt8,[HMod.mk, UInt8, Nat, UInt8.modn]]
[IO.Error.resourceBusy.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, UInt32, SizeOf.mk, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, String, List, Char, UInt32.isValidChar]]
[Thunk.get,[Unit.unit]]
[Array.size_pop,[List.length_dropLast, Array.data]]
[leOfOrd,[LE.mk, Eq, Bool, Ordering.isLE, Ord.compare, Bool.true]]
[Applicative.toSeq,[]]
[bfix1,[PProd.fst, PUnit, PProd]]
[Substring.drop,[Substring.mk, Substring, HAdd.hAdd, String.Pos, instHAdd, instAddNat, Substring.nextn, OfNat.ofNat, instOfNatNat]]
[Substring.dropRight,[Substring.mk, Substring, HAdd.hAdd, String.Pos, instHAdd, instAddNat, Substring.prevn, Substring.bsize]]
[Array.get.proof_1,[Fin.isLt, Array.size]]
[System.SearchPath,[List, System.FilePath]]
[Subarray.foldr,[Id.run, Subarray.foldrM, Id, Id.instMonadId]]
[Trans.noConfusionType,[]]
[Equivalence.noConfusionType,[]]
[instInhabitedUInt8,[Inhabited.mk, UInt8, UInt8.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, instInhabitedUInt8.proof_1]]
[«term_≥_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Name.str.injEq,[Eq.propIntro, Eq, Lean.Name, Lean.Name.str, And, String, UInt64, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[List.append_assoc,[Eq, List, HAppend.hAppend, instHAppend, List.instAppendList, rfl, List.nil, of_eq_true, List.cons, Eq.trans, True, congr, congrArg, congrFun, List.cons_append, eq_self]]
[Char.instLTChar,[LT.mk, Char, Char.lt]]
[coeTC,[CoeTC.coe]]
[«term_+_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[«term_<*>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instReprSum,[Repr.mk, Sum, Std.Format, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, reprArg]]
[IO.Error.mkResourceVanished,[IO.Error.resourceVanished]]
[stdNext,[Prod, Nat, StdGen, Prod.mk, Int.toNat, StdGen.mk]]
[instAndOpUInt8,[AndOp.mk, UInt8, UInt8.land]]
[«stx_+»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
[Nat.add_assoc,[Eq, Nat, HAdd.hAdd, instHAdd, instAddNat, rfl, OfNat.ofNat, instOfNatNat, congrArg, Nat.add, Nat.succ, PProd.fst, PUnit, PProd]]
[LawfulApplicative.seq_assoc,[]]
[ExceptCpsT.instInhabitedExceptCpsT,[Inhabited.mk, ExceptCpsT, arbitrary]]
[Nat.forRevM,[Nat.forRevM.loop]]
[StateRefT'.instMonadStateRefT',[inferInstanceAs, Monad, ReaderT, ST.Ref, ReaderT.instMonadReaderT]]
[UInt16.mod,[UInt16.mk, HMod.hMod, Fin, UInt16.size, instHMod, Fin.instModFin, UInt16.val]]
[Decidable.decide,[Bool, Bool.false, Bool.true]]
[ExceptT.instMonadLiftExceptExceptT,[MonadLift.mk, Except, ExceptT, ExceptT.mk, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[Nat.le.brecOn,[Nat.le.below, Nat.le.below.refl, Nat.le.below.step]]
[Std.Format.nil.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[Nat.xor,[Nat.bitwise, bne, Bool, instBEq, instDecidableEqBool]]
[Option.toMonad,[Unit.unit, Alternative.failure, Pure.pure, Applicative.toPure, Alternative.toApplicative]]
[instInhabitedExcept,[Inhabited.mk, Except, Except.error, arbitrary]]
[List.and,[List.all, Bool, id]]
[List.groupBy,[Unit.unit, List, List.nil, List.groupByAux, List.cons]]
[Acc.ndrec,[]]
[UInt8.div,[UInt8.mk, HDiv.hDiv, Fin, UInt8.size, instHDiv, Fin.instDivFin, UInt8.val]]
[Lean.bracketedExplicitBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.binderIdent, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat]]
[Fin.instOrOpFin,[OrOp.mk, Fin, Fin.lor]]
[instLTUInt16,[LT.mk, UInt16, UInt16.lt]]
[Pow.pow,[]]
[Lean.Parser.Tactic.renameI,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[IO.FS.Metadata.byteSize,[]]
[StateCpsT.instMonadStateOfStateCpsT,[MonadStateOf.mk, StateCpsT, PUnit.unit]]
[StateCpsT.runK_bind_lift,[rfl, StateCpsT.runK, Bind.bind, StateCpsT, Monad.toBind, StateCpsT.instMonadStateCpsT, StateCpsT.lift]]
[Array.anyM.loop,[Bool, dite, LT.lt, Nat, instLTNat, Nat.decLt, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.false, Bind.bind, Monad.toBind, Array.get, Fin.mk, Array.size, Array.anyM.loop.proof_1, ite, Eq, Bool.true, instDecidableEqBool, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
[Std.Range.forM.loop,[PUnit, ite, GE.ge, Nat, instLENat, Std.Range.stop, Nat.decLe, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, Unit.unit, Bind.bind, Monad.toBind, PProd.fst, PProd, HAdd.hAdd, instHAdd, instAddNat, Std.Range.step]]
[Nat.div_eq,[Nat, dite, And, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HAdd.hAdd, instHAdd, instAddNat, HDiv.hDiv, instHDiv, Nat.instDivNat, HSub.hSub, instHSub, instSubNat, Eq, congrFun, WellFounded.fix, WellFoundedRelation.rel, measure, id, WellFoundedRelation.wf, Nat.sub_lt, Nat.lt_of_lt_of_le, Nat.zero, WellFounded.fix_eq, ite, dif_eq_if]]
[Setoid.symm,[Equivalence.symm, Setoid.r, Setoid.iseqv]]
[System.FilePath.pathSeparators,[ite, List, Char, Eq, Bool, System.Platform.isWindows, Bool.true, instDecidableEqBool, List.cons, Char.ofNat, List.nil]]
[Float.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, FloatSpec.float, floatSpec, instSizeOf]]
[MProd.mk.inj,[And, Eq, MProd.mk, And.intro]]
[Lean.Parser.Tactic.apply,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Nat.shiftLeft,[Nat, PProd.fst, PUnit, PProd, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat]]
[instHAppend,[HAppend.mk, Append.append]]
[Int.div,[Int.ofNat, Int.negSucc, Int, HDiv.hDiv, Nat, instHDiv, Nat.instDivNat, Neg.neg, Int.instNegInt, Nat.succ]]
[instSubsingletonSquash,[instSubsingletonSquash.proof_1]]
[Char.utf8Size.proof_2,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
[MonadControlT.noConfusionType,[]]
[«term_≤_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[stx_?,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
[Option.eq_of_eq_some,[Option.none, Option.some, Eq, Option, rfl, Iff.mpr, Iff.mp, congrArg]]
[Lean.Name.simpMacroScopes,[Unit.unit, Lean.Name, Lean.Name.hasMacroScopes, Lean.Name.anonymous, Lean.Name.str, Lean.Name.mkNum, PProd.fst, PUnit, PProd, BEq.beq, String, instBEq, instDecidableEqString]]
[Lean.SourceInfo.noConfusionType,[]]
[true_implies,[propext, Iff.intro, trivial]]
[Bool.and_self,[Eq, Bool, and, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl]]
[EStateM.get,[EStateM.Result.ok]]
[Nat.mul_comm,[Eq, Nat, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, rfl, Eq.symm, Nat.mul_zero, Nat.zero_mul, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, PProd.fst, PUnit, PProd, Nat.succ_mul, Nat.mul_succ]]
[Lean.withHeadRefOnly,[Bind.bind, Monad.toBind, Lean.Syntax, Lean.MonadRef.getRef, Unit.unit, Lean.Syntax.getHead?, Lean.withRef]]
[Reader,[ReaderT, Id]]
[Sum.inl.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[UInt32.decLt,[UInt32.mk, Decidable, LT.lt, UInt32, instLTUInt32, inferInstanceAs, Fin, UInt32.size, instLTFin, Fin.decLt]]
[USize.decEq,[USize.mk, Decidable, Eq, USize, dite, Fin, USize.size, instDecidableEqFin, Decidable.isTrue, USize.decEq.proof_1, Decidable.isFalse, USize.decEq.proof_2]]
[congrFun,[Eq, rfl]]
[instMonadControlOptionT,[MonadControl.mk, OptionT, Option, liftM, instMonadLiftT, OptionT.instMonadLiftOptionT, instMonadLiftT_1, OptionT.run]]
[Substring.noConfusionType,[]]
[instAddUInt16,[Add.mk, UInt16, UInt16.add]]
[List.zip,[List.zipWith, Prod, Prod.mk]]
[List.getLast.proof_2,[False, List.cons, List.nil]]
[MonadExcept.tryCatch,[]]
[seq_eq_bind_map,[Eq.mpr, Eq, Seq.seq, Applicative.toSeq, Monad.toApplicative, Bind.bind, Monad.toBind, Functor.map, Applicative.toFunctor, Eq.refl, Eq.symm, LawfulMonad.bind_map, rfl]]
[Array.findIdx?.loop.proof_2,[Eq.mpr, Eq, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Eq.refl, Eq.symm, Nat.add_comm, Nat.add_assoc, rfl]]
[instShiftLeftUInt32,[ShiftLeft.mk, UInt32, UInt32.shiftLeft]]
[Nat.pow_le_pow_of_le_right,[LE.le, Nat, instLENat, HPow.hPow, instHPow, instPowNatNat, Eq, Nat.succ, Nat.lt_or_eq_or_le_succ, Nat.le_refl, Eq.symm]]
[«term_⊕'_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Int.repr,[String, Nat.repr, HAppend.hAppend, instHAppend, String.instAppendString, Nat.succ]]
[List.filter,[List.filterAux, List.nil]]
[Std.Format.group.injEq,[Eq.propIntro, Eq, Std.Format, Std.Format.group, And, Std.Format.FlattenBehavior, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[UInt16.land,[UInt16.mk, Fin.land, UInt16.size, UInt16.val]]
[IO.Error.userError.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.userError, String, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Neg.noConfusionType,[]]
[Lean.Parser.Tactic.cases,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.casesTarget, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlts]]
[Array.filterMap,[Id.run, Array, Array.filterMapM, Id, Id.instMonadId]]
[instAddUInt8,[Add.mk, UInt8, UInt8.add]]
[IO.Error.resourceBusy.inj,[And, Eq, UInt32, String, IO.Error.resourceBusy, And.intro]]
[Lean.Parser.Tactic.Conv.nestedConv,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.Parser.Tactic.Conv.convSeqBracketed]]
[Fin.mul.proof_1,[LT.lt, Nat, instLTNat, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, HMul.hMul, instHMul, instMulNat]]
[Prod.allI,[Nat.anyAux, not, Prod.snd, Nat, HSub.hSub, instHSub, instSubNat, Prod.fst]]
[USize.shiftLeft,[USize.mk, HShiftLeft.hShiftLeft, Fin, USize.size, instHShiftLeft, Fin.instShiftLeftFin, USize.val, USize.modn, System.Platform.numBits]]
[Lean.Parser.Tactic.Conv.conv,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.Conv.convSeq]]
[UInt64.toNat,[Fin.val, UInt64.size, UInt64.val]]
[String.takeWhile,[Substring.toString, Substring.takeWhile, String.toSubstring]]
[IO.withStderr,[Bind.bind, Monad.toBind, IO.FS.Stream, liftM, EIO, IO.Error, IO.setStderr, tryFinally, PUnit, Applicative.toFunctor, Monad.toApplicative, Functor.discard]]
[List.rotateRight,[ite, List, LE.le, Nat, instLENat, OfNat.ofNat, instOfNatNat, Nat.decLe, HAppend.hAppend, instHAppend, List.instAppendList]]
[List.concat,[List, List.cons, List.nil, PProd.fst, PUnit, PProd]]
[Std.Format.group.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Std.Format, SizeOf.mk, String, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar, Int, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone]]
[Nat.mul_le_mul_left,[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, LE.le, instLENat, HMul.hMul, instHMul, instMulNat, Nat.le.dest]]
[instMonadExceptOfEST,[inferInstanceAs, MonadExceptOf, EStateM, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable]]
[List.hasDecEq.proof_3,[False, List.nil, List.cons]]
[String.Iterator.prevn,[String.Iterator, PProd.fst, PUnit, PProd, String.Iterator.prev]]
[DecidablePred,[Decidable]]
[StateT.run_map,[Eq.mpr, Eq, Prod, StateT.run, Functor.map, StateT, Applicative.toFunctor, Monad.toApplicative, StateT.instMonadStateT, Prod.mk, Prod.fst, Prod.snd, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, congrArg, map_eq_pure_bind, bind_congr, rfl, Eq.symm, Eq.refl]]
[Nat.sub_self,[Eq, Nat, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, Unit.unit, Eq.mpr, Eq.refl, Nat.sub_zero, rfl, Nat.succ, Nat.succ_sub_succ, PProd.fst, PUnit, PProd]]
[Array.uset,[Array.set, Fin.mk, Array.size, USize.toNat]]
[Xor.noConfusionType,[]]
[Fin.add,[Fin.mk, Fin, HMod.hMod, Nat, instHMod, Nat.instModNat, HAdd.hAdd, instHAdd, instAddNat, Fin.add.proof_1]]
[calcStep,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary]]
[UInt64.modn,[UInt64.mk, HMod.hMod, Fin, UInt64.size, Nat, Fin.instHModFinNatFin, UInt64.val]]
[Lean.Parser.Tactic.Conv.change,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[ofBoolUsing_eq_false,[of_decide_eq_false]]
[UInt16.ofNatCore,[UInt16.mk, Fin.mk, UInt16.size]]
[Array.setD,[dite, Array, LT.lt, Nat, instLTNat, Array.size, Nat.decLt, Array.set, Fin.mk]]
[Id.instLawfulMonadId.proof_1,[LawfulMonad.mk, Id, Id.instMonadId, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, Functor.map, id, Function.comp, SeqLeft.seqLeft, Applicative.toSeqLeft, SeqRight.seqRight, Applicative.toSeqRight, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, Bind.bind, Monad.toBind]]
[Array.size_set,[List.length_set, Array.data, Fin.val, Array.size]]
[Lean.Meta.Rewrite.Config.offsetCnstrs,[]]
[Int.decEq.proof_3,[Nat, Eq, Int, Int.negSucc, rfl]]
[List.reverse_reverse,[Eq.mpr, Eq, List, List.reverseAux, List.nil, Eq.refl, List.reverseAux_reverseAux_nil, rfl]]
[Array.any,[Id.run, Bool, Array.anyM, Id, Id.instMonadId]]
[instShiftRightUInt16,[ShiftRight.mk, UInt16, UInt16.shiftRight]]
[instDecidableEqString,[String.decEq]]
[Char.utf8Size.proof_6,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
[Nat.zero_mul,[Eq, Nat, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, Unit.unit, rfl, HAdd.hAdd, instHAdd, instAddNat, Eq.symm, PProd.fst, PUnit, PProd, Nat.succ, Nat.mul_succ]]
[Std.Format.instInhabitedFlattenBehavior,[Inhabited.mk, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone]]
[instXorUInt64,[Xor.mk, UInt64, UInt64.xor]]
[UInt32.size,[OfNat.ofNat, Nat, instOfNatNat]]
[UInt64.decLe,[UInt64.mk, Decidable, LE.le, UInt64, instLEUInt64, inferInstanceAs, Fin, UInt64.size, instLEFin, Fin.decLe]]
[Int.noConfusionType,[]]
[Nat.le_of_eq,[Nat, LE.le, instLENat, Nat.le_refl]]
[Char.isDigit,[and, Decidable.decide, GE.ge, UInt32, instLEUInt32, Char.val, OfNat.ofNat, instOfNatUInt32, instDecidableLe, LE.le]]
[Lean.instQuoteList,[Lean.Quote.mk, List, Lean.Syntax, Unit.unit, Lean.mkCIdent, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.mkCApp, List.toArray, List.cons, Lean.Quote.quote, PProd.fst, PUnit, PProd, List.nil]]
[Lean.Parser.Tactic.rwSeq,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq, Lean.Parser.Tactic.location]]
[ExceptT.instLawfulMonadExceptT,[ExceptT.instLawfulMonadExceptT.proof_1]]
[PSum.inr.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[EStateM.set,[EStateM.Result.ok, PUnit, PUnit.unit]]
[Array.swap,[Array.set, Nat, Array.size, Array.swap.proof_1]]
[ExceptT.bind_pure_comp,[rfl, ExceptT, Bind.bind, Monad.toBind, ExceptT.instMonadExceptT, Function.comp, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[orM,[Bind.bind, Monad.toBind, Unit.unit, ToBool.toBool, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[UInt16.decEq.proof_1,[Fin, UInt16.size, Eq, UInt16, UInt16.mk, rfl]]
[Lean.instEval_1,[Lean.Eval.mk, IO.println, Std.Format, instToStringFormat, repr, Unit.unit]]
[Lean.firstFrontendMacroScope,[HAdd.hAdd, Nat, instHAdd, instAddNat, Lean.reservedMacroScope, OfNat.ofNat, instOfNatNat]]
[instHashableOption,[Hashable.mk, Option, Unit.unit, UInt64, OfNat.ofNat, instOfNatUInt64, mixHash, Hashable.hash]]
[CoeTC.coe,[]]
[Repr.addAppParen,[ite, Std.Format, GE.ge, Nat, instLENat, OfNat.ofNat, instOfNatNat, Nat.decLe, Std.Format.paren]]
[List.instForInList,[ForIn.mk, List, List.forIn]]
[false_of_ne,[Ne.irrefl]]
[HPow.noConfusionType,[]]
[Sum.inr.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[instDecidableEqSum.proof_1,[Eq, Sum, Sum.inl, rfl]]
[USize.mul,[USize.mk, HMul.hMul, Fin, USize.size, instHMul, Fin.instMulFin, USize.val]]
[instInhabitedTrue,[Inhabited.mk, True, True.intro]]
[WellFounded.fix_eq,[WellFounded.fixFEq, WellFounded.apply]]
[instSizeOfName,[SizeOf.mk, Lean.Name, Lean.Name.sizeOf]]
[Fin.instDivFin,[Div.mk, Fin, Fin.div]]
[Array.foldrMUnsafe,[ite, LE.le, optParam, Nat, Array.size, instLENat, Nat.decLe, LT.lt, OfNat.ofNat, instOfNatNat, instLTNat, Nat.decLt, USize.ofNat, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.foldrMUnsafe.fold]]
[HAppend.hAppend,[]]
[Functor.discard,[Functor.mapConst, PUnit, PUnit.unit]]
[Subtype.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[Lean.Module.mk.inj,[And, Eq, Lean.Syntax, Array, Lean.Module.mk, And.intro]]
[Subarray.forInUnsafe.loop,[ite, LT.lt, USize, instLTUSize, instDecidableLt_4, Bind.bind, Monad.toBind, ForInStep, Pure.pure, Applicative.toPure, Monad.toApplicative, Subarray.forInUnsafe.loop, HAdd.hAdd, instHAdd, instAddUSize, OfNat.ofNat, instOfNatUSize]]
[Lean.Syntax.setInfo,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax, Lean.Syntax.atom, Lean.Syntax.ident]]
[instComplementUInt16,[Complement.mk, UInt16, UInt16.complement]]
[IO.Error.noSuchThing.inj,[And, Eq, Option, String, UInt32, IO.Error.noSuchThing, And.intro]]
[instToStringByteArray,[ToString.mk, ByteArray, List.toString, UInt8, instToStringUInt8, ByteArray.toList]]
[instSubsingletonSquash.proof_1,[Subsingleton.intro, Squash, Squash.ind, Eq, Squash.mk, Quot.sound, True, True.intro]]
[UInt32.ofNatCore,[UInt32.mk, Fin.mk, UInt32.size]]
[term!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.gcd_zero_right,[Eq, Nat, Nat.gcd, OfNat.ofNat, instOfNatNat, Nat.zero, of_eq_true, Eq.trans, True, congr, congrArg, congrFun, Nat.zero_eq, Nat.gcd_zero_left, eq_true_of_decide, instDecidableEqNat, Eq.refl, Bool, Bool.true, Eq.symm, Nat.succ, HMod.hMod, instHMod, Nat.instModNat, Nat.gcd_succ, Nat.zero_mod, eq_self]]
[System.Platform.numBits,[Subtype.val, Nat, Or, Eq, OfNat.ofNat, instOfNatNat, System.Platform.getNumBits, Unit.unit]]
[instDecidableEqUSize,[USize.decEq]]
[instMulUInt16,[Mul.mk, UInt16, UInt16.mul]]
[instOrdBool,[Ord.mk, Bool, Bool.false, Unit.unit, Bool.true, Ordering, Ordering.lt, Ordering.gt, Ordering.eq]]
[String.append,[String.mk, String, HAppend.hAppend, List, Char, instHAppend, List.instAppendList]]
[instHashableBool,[Hashable.mk, Bool, Unit.unit, UInt64, OfNat.ofNat, instOfNatUInt64]]
[String.Iterator.prev,[String.Iterator, String.Iterator.mk, String.prev]]
[List.appendTR,[List.reverseAux, List.reverse]]
[Nat.decLe,[dite, Decidable, LE.le, Nat, instLENat, Eq, Bool, Nat.ble, Bool.true, instDecidableEqBool, Decidable.isTrue, Nat.le_of_ble_eq_true, Decidable.isFalse, Nat.not_le_of_not_ble_eq_true]]
[IO.Error.hardwareFault.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, UInt32, SizeOf.mk, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, String, List, Char, UInt32.isValidChar]]
[«term_∧_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[AndOp.noConfusionType,[]]
[ByteArray.isEmpty,[BEq.beq, Nat, instBEq, instDecidableEqNat, ByteArray.size, OfNat.ofNat, instOfNatNat]]
[Lean.NameGenerator.mk.inj,[And, Eq, Lean.Name, Nat, Lean.NameGenerator.mk, And.intro]]
[Thunk.pure,[Thunk.mk]]
[Std.Format.joinSep,[Std.Format, List.cons, Std.Format.nil, Std.ToFormat.format, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, PProd.fst, PUnit, PProd]]
[StateCpsT,[]]
[Mul.noConfusionType,[]]
[HEq.trans,[HEq.subst, HEq]]
[instDecidableEqUInt16,[UInt16.decEq]]
[Array.mapIdx,[Id.run, Array, Array.mapIdxM, Id, Id.instMonadId]]
[List.length_nil,[rfl, Nat, List.length, List.nil]]
[Array.mk.injEq,[Eq.propIntro, Eq, Array, Array.mk, List, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[List.partition,[List.partitionAux, Prod.mk, List, List.nil]]
[Lean.instInhabitedParserDescr,[Inhabited.mk, Lean.ParserDescr, Lean.ParserDescr.symbol]]
[Lean.Syntax.ident.injEq,[Eq.propIntro, Eq, Lean.Syntax, Lean.Syntax.ident, And, Lean.SourceInfo, Substring, Lean.Name, List, Prod, String, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.gcd_succ,[rfl, Nat, Nat.gcd, Nat.succ]]
[Option.all,[Unit.unit, Bool, Bool.true]]
[«term_*>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Int.negSucc.injEq,[Eq.propIntro, Eq, Int, Int.negSucc, Nat, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[IO.FS.FileType.dir.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[IO.FS.Handle.putStrLn,[IO.FS.Handle.putStr, String.push, Char.ofNat]]
[instHModUSizeNatUSize,[HMod.mk, USize, Nat, USize.modn]]
[StateT.run,[]]
[Lean.Parser.Tactic.changeWith,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.Parser.Tactic.location]]
[ExceptT.mk,[]]
[Lean.Name.instAppendName,[Append.mk, Lean.Name, Lean.Name.append]]
[String.push,[String, String.mk, HAppend.hAppend, List, Char, instHAppend, List.instAppendList, List.cons, List.nil]]
[Option.instDecidableRelLt,[Option.none, Unit.unit, Option.some, Decidable, Option.lt, Decidable.isTrue, trivial, Decidable.isFalse, not_false]]
[UInt64.shiftRight,[UInt64.mk, HShiftRight.hShiftRight, Fin, UInt64.size, instHShiftRight, Fin.instShiftRightFin, UInt64.val, UInt64.modn, OfNat.ofNat, Nat, instOfNatNat]]
[Char.isUpper,[and, Decidable.decide, GE.ge, UInt32, instLEUInt32, Char.val, OfNat.ofNat, instOfNatUInt32, instDecidableLe, LE.le]]
[String.instLTString,[LT.mk, String, LT.lt, List, Char, List.instLTList, Char.instLTChar, String.data]]
[EStateM.Result.ok.injEq,[Eq.propIntro, Eq, EStateM.Result, EStateM.Result.ok, And, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[List.getD,[Option.getD, List.get?]]
[MProd.snd,[]]
[IO.FS.Stream.ofHandle,[IO.FS.Stream.mk, IO.FS.Handle.isEof, IO.FS.Handle.flush, IO.FS.Handle.read, IO.FS.Handle.write, IO.FS.Handle.getLine, IO.FS.Handle.putStr]]
[IO.Error.fopenErrorToString,[String, Unit.unit, HAppend.hAppend, instHAppend, String.instAppendString, String.modify, OfNat.ofNat, String.Pos, instOfNatNat, Char.toLower, ToString.toString, UInt32, instToStringUInt32]]
[Lean.instQuoteArray,[Lean.Quote.mk, Array, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, Lean.Syntax, List.cons, Lean.Quote.quote, List, Lean.instQuoteList, Array.toList, List.nil]]
[IO.FS.Mode.noConfusion,[noConfusionEnum, IO.FS.Mode, Nat, instDecidableEqNat, IO.FS.Mode.toCtorIdx]]
[ForIn.noConfusionType,[]]
[ToString.toString,[]]
[Array.anyM.loop.proof_1,[Nat.lt_of_lt_of_le, Array.size]]
[Acc.ndrecOn,[]]
[Quot.recOnSubsingleton.proof_1,[Subsingleton.elim, Quot.mk, Quot, Quot.sound]]
[String.utf8ByteSize,[Nat, Char, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, String.csize, OfNat.ofNat, instOfNatNat]]
[UInt32.sub,[UInt32.mk, HSub.hSub, Fin, UInt32.size, instHSub, Fin.instSubFin, UInt32.val]]
[iff_iff_implies_and_implies,[Iff.intro, Iff, And, And.intro, Iff.mp, Iff.mpr, And.left, And.right]]
[StdGen.s1,[]]
[Array.findRevM?,[Array.findSomeRevM?, Bind.bind, Monad.toBind, Bool, Option, Pure.pure, Applicative.toPure, Monad.toApplicative, ite, Eq, Bool.true, instDecidableEqBool, Option.some, Option.none]]
[System.SearchPath.toString,[String.intercalate, Char.toString, System.SearchPath.separator, List.map, System.FilePath, String, System.FilePath.toString]]
[Array.instHAppendArrayListArray,[HAppend.mk, Array, List, Array.appendList]]
[IO.FS.FileType.toCtorIdx,[Nat, OfNat.ofNat, instOfNatNat]]
[Nat.lt,[Nat.le, Nat.succ]]
[of_decide_eq_false,[Not, absurd, Eq, Bool, Decidable.decide, Bool.false, ne_false_of_eq_true, decide_eq_true]]
[StateT.run_monadLift,[rfl, Prod, StateT.run, MonadLiftT.monadLift, StateT, instMonadLiftT, StateT.instMonadLiftStateT]]
[Bool.or_self,[Eq, Bool, or, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl]]
[LawfulMonad.bind_assoc,[]]
[Mul.mul,[]]
[EStateM.instMonadStateOfEStateM,[MonadStateOf.mk, EStateM, EStateM.get, EStateM.set, EStateM.modifyGet]]
[List.instEmptyCollectionList,[EmptyCollection.mk, List, List.nil]]
[UInt16.xor,[UInt16.mk, Fin.xor, UInt16.size, UInt16.val]]
[UInt64.toUInt32,[Nat.toUInt32, UInt64.toNat]]
[instLTFloat,[LT.mk, Float, Float.lt]]
[List.length_eq_lenghtTR,[funext, Nat, List.length, List.lengthTR, List, of_eq_true, Eq, List.lengthTRAux, OfNat.ofNat, instOfNatNat, Eq.trans, True, congrArg, HAdd.hAdd, instHAdd, instAddNat, Eq.symm, List.length_add_eq_lengthTRAux, Nat.add_zero, eq_self]]
[System.FilePath.extSeparator,[Char.ofNat]]
[Lean.Macro.instMonadQuotationMacroM,[Lean.MonadQuotation.mk, Lean.MacroM, Lean.Macro.instMonadRefMacroM, Pure.pure, EStateM, Lean.Macro.Exception, Lean.Macro.State, Applicative.toPure, Monad.toApplicative, EStateM.instMonadEStateM, Lean.MacroScope, Lean.Macro.Context.currMacroScope, Lean.Name, Lean.Macro.Context.mainModule, Lean.Macro.withFreshMacroScope]]
[List.cons.injEq,[Eq.propIntro, Eq, List, List.cons, And, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[instInhabitedProp,[Inhabited.mk, True]]
[ReaderT.instMonadReaderT,[Monad.mk, ReaderT, Applicative.mk, Functor.mk, ReaderT.map, Pure.mk, ReaderT.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk, ReaderT.bind]]
[Lean.Syntax.mkNumLit,[Lean.Syntax.mkLit, Lean.numLitKind]]
[Nat.pow_succ,[rfl, Nat, HPow.hPow, instHPow, instPowNatNat, Nat.succ]]
[Lean.MonadRef.mkInfoFromRefPos,[Bind.bind, Monad.toBind, Lean.Syntax, Lean.SourceInfo, Lean.MonadRef.getRef, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.SourceInfo.fromRef]]
[Std.Format.FlattenBehavior.fill.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[OptionM.run,[]]
[Lean.ParserDescr.ibelow,[True, And]]
[instDecidableEqProd.proof_1,[Eq, Prod, Prod.mk, rfl]]
[instSizeOf,[SizeOf.mk, default.sizeOf]]
[DoResultPRBC.pure.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[Lean.Syntax.decodeQuotedChar,[OptionM.run, Prod, Char, String.Pos, ite, OptionM, Eq, Bool, BEq.beq, instBEq, instDecidableEqChar, Char.ofNat, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Alternative.toApplicative, OptionT.instAlternativeOptionT, Id, Id.instMonadId, Prod.mk, Bind.bind, Monad.toBind, OptionT.instMonadOptionT, Nat, Option, and, Decidable.decide, LE.le, Char.instLEChar, Char.instDecidableLe, Option.some, HSub.hSub, instHSub, instSubNat, Char.toNat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Option.none, HMul.hMul, instHMul, instMulNat]]
[HAndThen.hAndThen,[]]
[String.foldrAux,[String.foldrAux.loop]]
[cond,[Unit.unit]]
[«term_%_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Array.get?,[dite, Option, LT.lt, Nat, instLTNat, Array.size, Nat.decLt, Option.some, Array.get, Fin.mk, Option.none]]
[Substring.bsize,[Nat, Nat.sub]]
[Char.quoteCore,[ite, String, Eq, Char, Char.ofNat, instDecidableEqChar, Or, LE.le, Nat, instLENat, Char.toNat, OfNat.ofNat, instOfNatNat, instDecidableOr, Nat.decLe, HAppend.hAppend, instHAppend, String.instAppendString, charToHex, String.singleton]]
[Lean.Name.hash.proof_1,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt64.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
[Array.findSomeM?,[Bind.bind, Monad.toBind, MProd, Option, PUnit, ForIn.forIn, Array, Array.instForInArray, MProd.mk, Option.none, PUnit.unit, ForInStep, Pure.pure, Applicative.toPure, Monad.toApplicative, ForInStep.done, Option.some, ForInStep.yield, Unit.unit, MProd.fst]]
[«term_>>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Std.Format.bracket,[Std.Format.group, Std.Format.nest, Int.ofNat, String.length, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone]]
[instMonadLiftSTEST,[MonadLift.mk, ST, EST, Empty, EStateM.Result, EStateM.Result.ok]]
[UInt32.decEq.proof_1,[Fin, UInt32.size, Eq, UInt32, UInt32.mk, rfl]]
[OrOp.or,[]]
[trivial,[True.intro]]
[Lean.Meta.Simp.instReprConfig,[Repr.mk, Lean.Meta.Simp.Config, Std.Format.bracket, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.nil, Std.Format.text, repr, Nat, instReprNat, Lean.Meta.Simp.Config.maxSteps, Std.Format.line, Lean.Meta.Simp.Config.maxDischargeDepth, Bool, instReprBool, Lean.Meta.Simp.Config.contextual, Lean.Meta.Simp.Config.memoize, Lean.Meta.Simp.Config.singlePass, Lean.Meta.Simp.Config.zeta, Lean.Meta.Simp.Config.beta, Lean.Meta.Simp.Config.eta, Lean.Meta.Simp.Config.iota, Lean.Meta.Simp.Config.proj, Lean.Meta.Simp.Config.decide]]
[withTheReader,[MonadWithReaderOf.withReader]]
[Lean.Macro.resolveNamespace?,[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, Option, Lean.Name, Lean.Macro.getMethods, Lean.Macro.Methods.resolveNamespace?]]
[Lean.mkOptionalNode,[Lean.Syntax, Unit.unit, Lean.Syntax.node, Lean.nullKind, List.toArray, List.cons, List.nil]]
[Sigma.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[Subarray.as,[]]
[Array.insertionSort.traverse,[Array, Unit.unit, dite, LT.lt, Nat, instLTNat, Array.size, Nat.decLt, PProd.fst, PUnit, PProd, Array.insertionSort.swapLoop, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
[Substring.toString,[String, String.extract]]
[Lean.Meta.Simp.Config.eta,[]]
[ExceptT.run,[]]
[Nat.toFloat,[Float.ofNat]]
[Std.Format.nest.injEq,[Eq.propIntro, Eq, Std.Format, Std.Format.nest, And, Int, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Subarray.allM,[Array.allM, Subarray.as, Subarray.start, Subarray.stop]]
[Lean.Macro.Context.maxRecDepth,[]]
[IO.FS.Handle.readBinToEnd,[ByteArray.empty, IO.FS.Handle.readBinToEnd.loop]]
[Lean.Syntax.hasArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Bool, Decidable.decide, GT.gt, Nat, instLTNat, Array.size, Lean.Syntax, OfNat.ofNat, instOfNatNat, Nat.decLt, Bool.false]]
[String.posOf,[String.posOfAux, String.bsize, OfNat.ofNat, String.Pos, instOfNatNat]]
[Option.lt,[Option.none, Option.some, True, False]]
[Array.forIn.loop.proof_1,[Nat.lt_of_le_of_lt, HSub.hSub, Nat, instHSub, instSubNat, Array.size, OfNat.ofNat, instOfNatNat, Nat.sub_le, Nat.sub_lt, LT.lt, instLTNat, Nat.lt_of_lt_of_le, Nat.succ, Nat.lt_succ_self, of_decide_eq_true, Nat.decLt, Eq.refl, Bool, Bool.true]]
[Array.mkArray,[Array.mk, List.replicate]]
[instDecidableEqQuotient,[Quotient.recOnSubsingleton₂, Decidable, Eq, Quotient, instDecidableEqQuotient.proof_1, HasEquiv.Equiv, instHasEquiv, Quotient.mk, Decidable.isTrue, Quotient.sound, Decidable.isFalse, instDecidableEqQuotient.proof_2]]
[Except.map,[Except, Except.error, Except.ok]]
[List.reverse_cons,[Eq.mpr, Eq, List, List.reverseAux, List.cons, List.nil, HAppend.hAppend, instHAppend, List.instAppendList, Eq.refl, Eq.symm, List.reverseAux_eq_append, rfl]]
[Lean.MonadNameGenerator.noConfusionType,[]]
[Int.instDivInt,[Div.mk, Int, Int.div]]
[CoeTail.coe,[]]
[Nat.not_succ_le_self,[Not, LE.le, Nat, instLENat, Nat.succ, Unit.unit, Nat.not_succ_le_zero, OfNat.ofNat, instOfNatNat, absurd, HAdd.hAdd, instHAdd, instAddNat, False, Nat.le_of_succ_le_succ, PProd.fst, PUnit, PProd]]
[«command_ClassAbbrev__:_:=__,»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[MonadFunctorT.noConfusionType,[]]
[Fin.lor.proof_1,[LT.lt, Nat, instLTNat, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, Nat.lor]]
[Except.toOption,[Option, Option.some, Option.none]]
[String.instAppendString,[Append.mk, String, String.append]]
[Fin.sub,[Fin.mk, Fin, HMod.hMod, Nat, instHMod, Nat.instModNat, HAdd.hAdd, instHAdd, instAddNat, HSub.hSub, instHSub, instSubNat, Fin.sub.proof_1]]
[Char.toString,[String.singleton]]
[MonadLift.monadLift,[]]
[Functor.noConfusionType,[]]
[instHashableInt,[Hashable.mk, Int, UInt64, UInt64.ofNat, HMul.hMul, Nat, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat]]
[AndThen.noConfusionType,[]]
[Lean.Meta.TransparencyMode.noConfusionType,[noConfusionTypeEnum, Lean.Meta.TransparencyMode, Nat, instDecidableEqNat, Lean.Meta.TransparencyMode.toCtorIdx]]
[Except.error.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[List.filterMap,[List, Unit.unit, List.nil, PProd.fst, PUnit, PProd, List.cons]]
[Lean.Parser.Tactic.rename,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[USize.modn_lt,[LT.lt, Nat, instLTNat, USize.toNat, HMod.hMod, USize, instHModUSizeNatUSize, Fin.modn_lt, USize.size]]
[Subtype.existsOfSubtype,[Subtype.existsOfSubtype.proof_1]]
[DecidableEq,[Decidable, Eq]]
[String.dropRightWhile,[Substring.toString, Substring.dropRightWhile, String.toSubstring]]
[UInt32.shiftLeft,[UInt32.mk, HShiftLeft.hShiftLeft, Fin, UInt32.size, instHShiftLeft, Fin.instShiftLeftFin, UInt32.val, UInt32.modn, OfNat.ofNat, Nat, instOfNatNat]]
[instDecidableEqNat,[Nat.decEq]]
[InvImage.accessible,[InvImage.accessible.proof_1]]
[PSigma.eta,[Eq, PSigma, PSigma.mk, Eq.refl, rfl]]
[instComplementUInt32,[Complement.mk, UInt32, UInt32.complement]]
[FloatSpec.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOf]]
[ltOfOrd,[LT.mk, Eq, Bool, BEq.beq, Ordering, instBEqOrdering, Ord.compare, Ordering.lt, Bool.true]]
[instLEUSize,[LE.mk, USize, USize.le]]
[IO.Process.Stdio.piped.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[Nat.le_succ_of_le,[Nat.le_trans, Nat.succ, Nat.le_succ]]
[«termIfLet_:=_Then_Else_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Bool.false.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[Array.insertionSort.swapLoop,[Array, Eq.refl, Nat]]
[ByteArray.data,[]]
[String.noConfusionType,[]]
[Nat.instXorNat,[Xor.mk, Nat, Nat.xor]]
[instLTNat,[LT.mk, Nat, Nat.lt]]
[instDecidableArrow,[dite, Decidable, Decidable.isTrue, instDecidableArrow.proof_1, Decidable.isFalse, instDecidableArrow.proof_2, instDecidableArrow.proof_3]]
[Array.unzip,[Array.foldl, Prod, Array, Prod.mk, Array.push, List.toArray, List.nil, OfNat.ofNat, Nat, instOfNatNat, Array.size]]
[Nat.one_ne_zero,[False, OfNat.ofNat, Nat, instOfNatNat]]
[UInt32.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Fin, UInt32.size, SizeOf.mk, instSizeOfNat, LT.lt, instLTNat, instSizeOf]]
[Quotient.ind,[Quot.ind, Setoid.r]]
[String.front,[String.get, OfNat.ofNat, String.Pos, instOfNatNat]]
[System.FilePath.extension,[Option.bind, String, System.FilePath.fileName, String.Pos, Unit.unit, dite, Option.some, Eq, instDecidableEqNat, Eq.symm, Option, String.revPosOf, Char.ofNat, Option.none, String.extract, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, String.bsize]]
[List.nil.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[IO.Process.output,[Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.Process.Child, IO.Process.SpawnArgs.toStdioConfig, IO.Process.SpawnArgs.mk, IO.Process.StdioConfig.mk, IO.Process.StdioConfig.stdin, IO.Process.Stdio.piped, IO.Process.SpawnArgs.cmd, IO.Process.SpawnArgs.args, IO.Process.SpawnArgs.cwd, IO.Process.SpawnArgs.env, IO.Process.Output, IO.Process.spawn, Task, Except, String, IO.asTask, IO.FS.Handle.readToEnd, IO.Process.Child.stdout, Task.Priority.dedicated, IO.Process.Child.stderr, UInt32, IO.Process.Child.wait, IO.ofExcept, IO.Error.instToStringError, Task.get, Pure.pure, Applicative.toPure, Monad.toApplicative, IO.Process.Output.mk]]
[coeD,[CoeDep.coe]]
[instSTWorld,[STWorld.mk]]
[coeOfHeadOfTC,[CoeHTCT.mk, coeTC, coeHead]]
[StateRefT'.instMonadLiftStateRefT',[MonadLift.mk, StateRefT', StateRefT'.lift]]
[instDecidableLt,[UInt32.decLt]]
[instReprULift,[Repr.mk, ULift, Repr.addAppParen, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.text, reprArg, ULift.down]]
[Lean.Syntax.SepArray.ofElemsUsingRef,[Bind.bind, Monad.toBind, Lean.Syntax, Lean.Syntax.SepArray, Lean.MonadRef.getRef, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.SepArray.mk, Lean.mkSepArray, Lean.mkAtomFrom]]
[Substring.contains,[Substring.any, BEq.beq, Char, instBEq, instDecidableEqChar]]
[StateT.modifyGet,[Pure.pure, Applicative.toPure, Monad.toApplicative, Prod]]
[String.bsize,[String.utf8ByteSize]]
[DoResultPRBC.return.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[Array.instEmptyCollectionArray,[EmptyCollection.mk, Array, Array.empty]]
[Lean.Syntax.isNone,[Unit.unit, Lean.Syntax.atom, Lean.Syntax.ident, Bool, and, BEq.beq, Lean.SyntaxNodeKind, Lean.Name.instBEqName, Lean.nullKind, Nat, instBEq, instDecidableEqNat, Array.size, Lean.Syntax, OfNat.ofNat, instOfNatNat, Bool.true, Bool.false]]
[UInt8.toUInt32,[Nat.toUInt32, UInt8.toNat]]
[String.set,[String, String.mk, Char, List, List.nil, ite, Eq, String.Pos, instDecidableEqNat, List.cons, PProd.fst, PUnit, PProd, HAdd.hAdd, Nat, instHAdd, instAddNat, String.csize, OfNat.ofNat, instOfNatNat]]
[Nat.foldAux,[PProd.fst, PUnit, PProd, HSub.hSub, Nat, instHSub, instSubNat, Nat.succ]]
[MProd.mk.injEq,[Eq.propIntro, Eq, MProd, MProd.mk, And, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Lean.instQuoteSubstring,[Lean.Quote.mk, Substring, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, Lean.Syntax, List.cons, Lean.Quote.quote, String, Lean.instQuoteString, Substring.toString, List.nil]]
[Seq.noConfusionType,[]]
[IO.Process.StdioConfig.stdin,[]]
[Subtype.noConfusionType,[]]
[fix6,[fixCore6, arbitrary]]
[Nat.lor,[Nat.bitwise, or]]
[ByteArray.mkEmpty,[ByteArray.mk, List.toArray, UInt8, List.nil]]
[List.toByteArray,[ByteArray.empty, List.toByteArray.loop]]
[Nat.lt.step.proof_1,[Nat.le_step, Nat.succ]]
[ByteArray.set!,[ByteArray, ByteArray.mk, Array.set!, UInt8]]
[instTransEq,[Trans.mk, Eq, instTransEq.proof_1]]
[PLift.noConfusionType,[]]
[Task.get,[]]
[FloatSpec.mk.inj,[And, Eq, HEq, DecidableRel, FloatSpec.mk, And.intro]]
[UInt64.toUInt8,[Nat.toUInt8, UInt64.toNat]]
[Array.ext,[Array, Array.mk, congrArg, List, Eq.symm, Eq.refl, Array.ext.extAux]]
[FloatSpec.le,[]]
[instShiftLeftUSize,[ShiftLeft.mk, USize, USize.shiftLeft]]
[IO.Process.Child.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdin, instSizeOf, IO.Process.StdioConfig.stdout, IO.Process.StdioConfig.stderr]]
[ExceptCpsT.runCatch,[Pure.pure, Applicative.toPure, Monad.toApplicative]]
[Lean.MonadQuotation.getMainModule,[]]
[IO.Error.unsatisfiedConstraints.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, UInt32, SizeOf.mk, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, String, List, Char, UInt32.isValidChar]]
[DoResultSBC.noConfusionType,[]]
[instSubNat,[Sub.mk, Nat, Nat.sub]]
[instToStreamStringSubstring,[ToStream.mk, String, Substring, String.toSubstring]]
[Lean.Parser.Tactic.rotateRight,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[Fin.div.proof_1,[LT.lt, Nat, instLTNat, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, HDiv.hDiv, instHDiv, Nat.instDivNat]]
[Std.Format.prettyM,[List.cons, Bool.false, Std.Format.FlattenBehavior.allOrNone, Int.ofNat, OfNat.ofNat, Nat, instOfNatNat, List.nil]]
[ite,[]]
[Lean.evalPrio,[Lean.Macro.withIncRecDepth, Nat, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Syntax, Lean.expandMacros, cond, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.getD, Lean.Syntax.isNatLit?, OfNat.ofNat, instOfNatNat, Lean.Macro.throwErrorAt]]
[InvImage.accessible.proof_1,[Acc, InvImage, Acc.intro, rfl]]
[ByteArray.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Array, UInt8, SizeOf.mk, List, Fin, UInt8.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf]]
[Prod.lex.proof_1,[WellFounded.intro, Prod, Prod.Lex, WellFoundedRelation.rel, Acc, Prod.lexAccessible, WellFounded.apply, WellFoundedRelation.wf]]
[decide_eq_false,[Eq, Bool, Decidable.decide, Bool.false, absurd, Decidable.isTrue, rfl, Decidable.isFalse]]
[IO.Error.resourceBusy.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.resourceBusy, And, UInt32, String, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[bind_pure_unit,[]]
[Substring.all,[not, Substring.any]]
[Nat.not_le_of_not_ble_eq_true,[absurd, Eq, Bool, Nat.ble, Bool.true, False, Nat.ble_eq_true_of_le]]
[Nat.div,[WellFounded.fix, Nat, WellFoundedRelation.rel, measure, id, Nat.div.proof_1, dite, And, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HAdd.hAdd, instHAdd, instAddNat, HSub.hSub, instHSub, instSubNat, Nat.sub_lt, Nat.lt_of_lt_of_le, Nat.zero]]
[Array.findSomeRevM?.find.proof_2,[Nat.le_of_lt, Array.size, Nat.lt_of_lt_of_le, Nat.succ, Nat.lt_succ_self]]
[Subtype.mk.injEq,[Eq.propIntro, Eq, Subtype, Subtype.mk, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[IO.RealWorld,[Unit]]
[String.Iterator.i,[]]
[String.toInt!,[Int, Unit.unit, String.toInt?, panic, Int.instInhabitedInt]]
[List.head?,[Unit.unit, Option, Option.none, Option.some]]
[IO.Error.unsatisfiedConstraints.inj,[And, Eq, UInt32, String, IO.Error.unsatisfiedConstraints, And.intro]]
[Nat.gcd_one_left,[Eq.mpr, Eq, Nat, Nat.gcd, OfNat.ofNat, instOfNatNat, HMod.hMod, instHMod, Nat.instModNat, Nat.succ, Eq.refl, Nat.gcd_succ, Nat.mod_one, rfl]]
[ShiftRight.shiftRight,[]]
[Lean.addMacroScope,[Unit.unit, Lean.Name, Lean.Name.hasMacroScopes, BEq.beq, Lean.Name.instBEqName, Lean.MacroScopesView.mainModule, Lean.Name.mkNum, Lean.MacroScopesView.review, Lean.MacroScopesView.mk, Lean.MacroScopesView.name, List.foldl, Nat, HAppend.hAppend, instHAppend, Lean.Name.instAppendName, Lean.MacroScopesView.imported, Lean.MacroScopesView.scopes, List.cons, Lean.MacroScope, List.nil, Lean.Name.mkStr]]
[Function.Equiv.isEquivalence,[Equivalence.mk, Function.Equiv, Function.Equiv.refl, Function.Equiv.symm, Function.Equiv.trans]]
[System.FilePath.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, String, SizeOf.mk, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar]]
[Array.qpartition,[Array.qpartition.loop]]
[List.lt.brecOn,[List.lt.below, List.lt.below.nil, List.lt.below.head, List.lt.below.tail]]
[UInt64.decEq,[UInt64.mk, Decidable, Eq, UInt64, dite, Fin, UInt64.size, instDecidableEqFin, Decidable.isTrue, UInt64.decEq.proof_1, Decidable.isFalse, UInt64.decEq.proof_2]]
[Char.isAlphanum,[or, Char.isAlpha, Char.isDigit]]
[List.forIn,[List.forIn.loop]]
[List.findSome?,[Option, Unit.unit, Option.none, Option.some, PProd.fst, PUnit, PProd]]
[Lean.MonadQuotation.getCurrMacroScope,[]]
[Int.decLe,[Decidable, Int.NonNeg, Decidable.isTrue, Int.ofNat, Int.NonNeg.mk, Decidable.isFalse, Int.negSucc, Eq.refl, Int, HEq.refl, False, HSub.hSub, instHSub, Int.instSubInt]]
[USize.toNat,[Fin.val, USize.size, USize.val]]
[IO.FS.readFile,[Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle, String, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.false, IO.FS.Handle.readToEnd]]
[Function.Equiv,[Eq]]
[String.singleton,[String.push]]
[IO.Process.Output.stdout,[]]
[dif_eq_if,[Eq, dite, ite, rfl, Decidable.isTrue, Decidable.isFalse]]
[LawfulMonad.bind_pure_comp,[]]
[Std.Format.instBEqFlattenBehavior,[BEq.mk, Std.Format.FlattenBehavior, BEq.beq, Nat, instBEq, instDecidableEqNat, Std.Format.FlattenBehavior.toCtorIdx]]
[Array.mapIdxM,[Array.size, OfNat.ofNat, Nat, instOfNatNat, rfl, HAdd.hAdd, instHAdd, instAddNat, Array.mkEmpty, Array.mapIdxM.map]]
[List.rotateLeft,[ite, List, LE.le, Nat, instLENat, OfNat.ofNat, instOfNatNat, Nat.decLe, HAppend.hAppend, instHAppend, List.instAppendList]]
[Lean.instEvalUnit,[Lean.Eval.mk, Unit, ite, IO, Eq, Bool, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, instMonadEIO, IO.Error, Unit.unit, IO.println, Std.Format, instToStringFormat, repr, instReprUnit]]
[IO.Error.interrupted.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, String, SizeOf.mk, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar]]
[Std.Format.line.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[Bind.noConfusionType,[]]
[StateT.run'_eq,[rfl, StateT.run', Applicative.toFunctor, Monad.toApplicative]]
[String.toList,[String.data]]
[WellFoundedRelation.rel,[]]
[of_decide_eq_true,[absurd, Eq, Bool, Decidable.decide, Bool.true, ne_true_of_eq_false, decide_eq_false]]
[Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat.lt_of_le_of_lt]]
[RandomGen.split,[]]
[termDepIfThenElse,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Lean.explicitBinders,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.bracketedExplicitBinders, Lean.unbracketedExplicitBinders]]
[IO.mkRef,[ST.mkRef, IO.RealWorld, IO, instMonadLiftT, ST, IO.instMonadLiftSTRealWorldEIO, IO.Error, instMonadLiftT_1]]
[instAddUInt64,[Add.mk, UInt64, UInt64.add]]
[Lean.reservedMacroScope,[OfNat.ofNat, Nat, instOfNatNat]]
[ByteArray.instInhabitedByteArray,[Inhabited.mk, ByteArray, ByteArray.empty]]
[ByteArray.toUInt64LE!,[ite, UInt64, Eq, Bool, BEq.beq, Nat, instBEq, instDecidableEqNat, ByteArray.size, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, HOr.hOr, instHOr, instOrOpUInt64, HShiftLeft.hShiftLeft, instHShiftLeft, instShiftLeftUInt64, UInt8.toUInt64, ByteArray.get!, instOfNatUInt64, panicWithPosWithDecl, instInhabitedUInt64, HAppend.hAppend, String, instHAppend, String.instAppendString]]
[instLTOption,[LT.mk, Option, Option.lt, LT.lt]]
[eq_false_of_decide,[propext, False, Iff.intro, absurd, of_decide_eq_false, False.elim]]
[Fin.instHModFinNatFin,[HMod.mk, Fin, Nat, Fin.modn]]
[Std.Format.paren,[Std.Format.bracket]]
[instDecidableOr,[Decidable, Or, Decidable.isTrue, Or.inl, Or.inr, Decidable.isFalse, instDecidableOr.proof_1]]
[Lean.Parser.Tactic.subst,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[IO.sleep,[dbgSleep, EStateM.Result, IO.Error, IO.RealWorld, Unit, EStateM.Result.ok, Unit.unit]]
[absurd,[False.elim]]
[Nat.pow,[Nat, Unit.unit, OfNat.ofNat, instOfNatNat, Nat.mul, PProd.fst, PUnit, PProd]]
[IO.Process.StdioConfig.mk.inj,[And, Eq, IO.Process.Stdio, IO.Process.StdioConfig.mk, And.intro]]
[List.foldr,[Unit.unit, PProd.fst, PUnit, PProd]]
[«stx_,*,?»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
[String.takeRight,[Substring.toString, Substring.takeRight, String.toSubstring]]
[List.bind,[List.join, List.map, List]]
[ST.Ref.get,[liftM, ST, ST.Prim.Ref.get]]
[UInt32.mul,[UInt32.mk, HMul.hMul, Fin, UInt32.size, instHMul, Fin.instMulFin, UInt32.val]]
[instDecidableLe_3,[UInt64.decLe]]
[ByteArray.push,[ByteArray, ByteArray.mk, Array.push, UInt8]]
[LawfulMonad.pure_bind,[]]
[CoeHTCT.noConfusionType,[]]
[Lean.Macro.getMethodsImp,[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, MonadReader.read, instMonadReader, instMonadReaderOfReaderT, Pure.pure, Applicative.toPure, Monad.toApplicative, unsafeCast, PointedType.type, Lean.Macro.Context.methods]]
[compareOfLessAndEq,[ite, Ordering, LT.lt, Ordering.lt, Eq, Ordering.eq, Ordering.gt]]
[ExceptCpsT.run,[Except, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.ok, Except.error]]
[List.toByteArray.loop,[UInt8, ByteArray, PProd.fst, PUnit, PProd, ByteArray.push]]
[UInt16.decLe,[UInt16.mk, Decidable, LE.le, UInt16, instLEUInt16, inferInstanceAs, Fin, UInt16.size, instLEFin, Fin.decLe]]
[ReaderT.map,[Functor.map, Applicative.toFunctor, Monad.toApplicative]]
[instSubsingletonForall.proof_1,[Subsingleton.intro, funext, Subsingleton.elim]]
[FloatArray.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Array, Float, SizeOf.mk, List, FloatSpec.float, floatSpec, instSizeOf]]
[Lean.Name.beq,[Bool, Lean.Name.anonymous, Unit.unit, Lean.Name.str, Lean.Name.num, Bool.true, and, BEq.beq, String, instBEq, instDecidableEqString, PProd.fst, PUnit, PProd, Nat, instDecidableEqNat, Bool.false]]
[Prod.lexAccessible,[Prod.lexAccessible.proof_1]]
[instHashableList,[Hashable.mk, List, List.foldl, UInt64, mixHash, Hashable.hash, OfNat.ofNat, instOfNatUInt64]]
[Array.foldlM.loop.proof_1,[Nat.lt_of_lt_of_le, Array.size]]
[instReprSubstring,[Repr.mk, Substring, Std.Format.text, HAppend.hAppend, String, instHAppend, String.instAppendString, String.quote, Substring.toString]]
[Lean.Meta.Simp.ConfigCtx.mk.injEq,[Eq.propIntro, Eq, Lean.Meta.Simp.ConfigCtx, Lean.Meta.Simp.ConfigCtx.mk, Lean.Meta.Simp.Config, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[IO.Process.Child.noConfusionType,[]]
[Lean.instHashableName,[Hashable.mk, Lean.Name, Lean.Name.hash]]
[DoResultPRBC.continue.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[String.Iterator.nextn,[String.Iterator, PProd.fst, PUnit, PProd, String.Iterator.next]]
[Lean.Module.header,[]]
[Subtype.instDecidableEqSubtype.proof_2,[False, Subtype.mk, absurd, Eq]]
[PSigma.lexNdepWf,[PSigma.lexNdepWf.proof_1]]
[String.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, List, Char, SizeOf.mk, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar]]
[Substring.stopPos,[]]
[String.length,[Nat, List.length, Char]]
[Lean.Meta.Simp.defaultMaxSteps,[OfNat.ofNat, Nat, instOfNatNat]]
[MonadExcept.instOrElse,[OrElse.mk, MonadExcept.orElse]]
[Lean.Meta.Simp.Config.proj,[]]
[Lean.Parser.Tactic.location,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.Parser.Tactic.locationWildcard, Lean.Parser.Tactic.locationHyp]]
[OrElse.noConfusionType,[]]
[String.Iterator.remainingToString,[String, String.extract, String.bsize]]
[Char.utf8Size.proof_1,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
[Array.extract,[Array.ofSubarray, Array.toSubarray]]
[Lean.Macro.throwUnsupported,[MonadExcept.throw, Lean.Macro.Exception, Lean.MacroM, instMonadExcept, ReaderT.instMonadExceptOfReaderT, Lean.Macro.Context, EStateM, Lean.Macro.State, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Lean.Macro.Exception.unsupportedSyntax]]
[List.forM_cons,[rfl, PUnit, ForM.forM, List, List.instForMList, List.cons]]
[Lean.instInhabitedSyntax,[Inhabited.mk, Lean.Syntax, Lean.Syntax.missing]]
[List.instAppendList,[Append.mk, List, List.append]]
[funext,[]]
[Lean.Meta.Simp.ConfigCtx.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Lean.Meta.Simp.Config, SizeOf.mk, instSizeOfNat, Bool]]
[tacticCalc_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, calcStep]]
[Array.mapSepElems,[Id.run, Array, Lean.Syntax, Array.mapSepElemsM, Id, Id.instMonadId]]
[Nat.succ_le_succ,[LE.le, Nat, instLENat, Nat.succ, Nat.le.refl, Unit.unit, Eq.symm, eq_of_heq, Nat.le.step, Eq.refl, HEq.refl, PProd.fst, PUnit, PProd]]
[cast_eq,[rfl, cast]]
[Nat.not_le_of_gt,[LT.lt, Nat, instLTNat, GE.ge, instLENat, False, Nat.lt_or_ge, absurd, Nat.lt_trans, Nat.lt_irrefl]]
[instInhabitedOrdering,[Inhabited.mk, Ordering, Ordering.lt]]
[dbgTraceIfShared,[]]
[Option.instOrElseOption,[OrElse.mk, Option, Option.orElse]]
[StateCpsT.runK_get,[rfl, StateCpsT.runK, MonadState.get, StateCpsT, instMonadState, StateCpsT.instMonadStateOfStateCpsT]]
[Nat.le_refl,[Nat.le.refl]]
[instDecidableLt_4,[USize.decLt]]
[Nat.zero_add,[Eq, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Unit.unit, rfl, congrArg, Nat.add, Nat.succ, PProd.fst, PUnit, PProd]]
[ExceptT.run_bind,[rfl, Except, ExceptT.run, Bind.bind, ExceptT, Monad.toBind, ExceptT.instMonadExceptT]]
[Lean.Macro.Methods.expandMacro?,[]]
[coeOfHTCT,[CoeT.mk, CoeHTCT.coe]]
[Subsingleton.allEq,[]]
[Lean.Syntax.isOfKind,[BEq.beq, Lean.SyntaxNodeKind, Lean.Name.instBEqName, Lean.Syntax.getKind]]
[Lean.MacroScopesView.scopes,[]]
[instInhabitedProd,[Inhabited.mk, Prod, Prod.mk, arbitrary]]
[Nat.beq,[Bool, Nat.zero, Unit.unit, Nat.succ, Bool.true, Bool.false, PProd.fst, PUnit, PProd]]
[IO.Error.mkInterrupted,[IO.Error.interrupted]]
[PProd.mk.inj,[And, Eq, PProd.mk, And.intro]]
[Nat.eq_of_beq_eq_true,[Eq, Nat, Nat.zero, Nat.succ, rfl, Nat.beq, Bool.true]]
[Nat.ctor_eq_zero,[rfl, Nat, Nat.zero]]
[Std.Format.indentD,[Std.Format.nestD, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.line]]
[«term_<$>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Nat.pred,[Unit.unit, Nat, OfNat.ofNat, instOfNatNat]]
[CoeDep.coe,[]]
[Lean.ParserDescr.below,[PUnit, PProd]]
[STWorld.noConfusionType,[]]
[Lean.version.isRelease,[Lean.version.getIsRelease, Unit.unit]]
[PSum.inr.inj,[Eq, PSum.inr]]
[PUnit.subsingleton,[Eq, PUnit, PUnit.unit, rfl, Eq.symm, Eq.refl]]
[Quotient.hrecOn,[Quot.hrecOn, Setoid.r]]
[instToStringFloat,[ToString.mk, Float, Float.toString]]
[FloatSpec.decLt,[]]
[Nat.le_trans,[LE.le, Nat, instLENat, Nat.le.refl, Eq.symm, eq_of_heq, Nat.succ, Nat.le.step, Eq.refl, HEq.refl, PProd.fst, PUnit, PProd]]
[instBEqProd,[BEq.mk, Prod, Bool, and, BEq.beq]]
[Subarray.mk.injEq,[Eq.propIntro, Eq, Subarray, Subarray.mk, And, Array, Nat, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[IO.FS.Metadata.type,[]]
[IO.Error.noFileOrDirectory.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.noFileOrDirectory, And, String, UInt32, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[FloatArray.push,[FloatArray, FloatArray.mk, Array.push, Float]]
[ExceptCpsT.runCatch_pure,[rfl, ExceptCpsT.runCatch, Pure.pure, ExceptCpsT, Applicative.toPure, Monad.toApplicative, ExceptCpsT.instMonadExceptCpsT]]
[Sub.noConfusionType,[]]
[instToFormatOption,[Std.ToFormat.mk, Option, Option.format]]
[instHashableFin,[Hashable.mk, Fin, Nat.toUInt64, Fin.val]]
[UInt32.isValidChar,[Nat.isValidChar, UInt32.toNat]]
[precMin1,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Array.instInhabitedArray,[Inhabited.mk, Array, Array.empty]]
[instHOr,[HOr.mk, OrOp.or]]
[IO.FS.Metadata.mk.inj,[And, Eq, IO.FS.SystemTime, UInt64, IO.FS.FileType, IO.FS.Metadata.mk, And.intro]]
[Nat.lt.step,[Nat.lt.step.proof_1]]
[OptionT.run,[]]
[Prod.RProdSubLex,[Prod.RProdSubLex.proof_1]]
[instDecidableEqProd.proof_3,[False, Prod.mk, absurd, Eq]]
[dbgTrace,[Unit.unit]]
[StdGen.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat]]
[List.getLast?,[Unit.unit, Option, Option.none, Option.some, List.getLast, List.cons, List.getLast?.proof_1]]
[ST.Ref.h,[]]
[Append.append,[]]
[IO.FS.DirEntry.path,[HDiv.hDiv, System.FilePath, instHDiv, System.FilePath.instDivFilePath, IO.FS.DirEntry.root, System.FilePath.mk, IO.FS.DirEntry.fileName]]
[Nat.lt_of_lt_of_le,[Nat.le_trans, Nat.succ]]
[FloatArray.set,[FloatArray, FloatArray.mk, Array.set, Float]]
[List.cons.inj,[And, Eq, List, List.cons, And.intro]]
[Array.getSepElems,[Array.getEvenElems]]
[unsafeIO,[unsafeEIO, IO.Error]]
[Nat.anyM.loop,[Bool, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.false, Bind.bind, Monad.toBind, HSub.hSub, Nat, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, Bool.true, PProd.fst, PUnit, PProd]]
[Lean.Meta.Simp.Config.contextual,[]]
[Lean.Parser.Tactic.rwWithRfl,[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.SourceInfo, Lean.Syntax, Lean.MonadRef.mkInfoFromRefPos, Lean.Macro.instMonadRefMacroM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Macro.instMonadQuotationMacroM, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Option.getD, Lean.Syntax.getHeadInfo?, List.nil]]
[Fin.add.proof_1,[LT.lt, Nat, instLTNat, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, HAdd.hAdd, instHAdd, instAddNat]]
[instHShiftLeft,[HShiftLeft.mk, ShiftLeft.shiftLeft]]
[IO.instMonadLiftSTRealWorldEIO,[MonadLift.mk, ST, IO.RealWorld, EIO, Empty, EStateM.Result, EStateM.Result.ok]]
[UInt32.lor,[UInt32.mk, Fin.lor, UInt32.size, UInt32.val]]
[Array.forIn,[Array.size, Nat.le_refl, Array.forIn.loop]]
[Array.«term__[:_]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[IO.FS.Stream.mk.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[and,[Unit.unit, Bool, Bool.false]]
[Lean.Macro.throwErrorAt,[Lean.withRef, Lean.MacroM, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.instMonadRefMacroM, Lean.Macro.throwError]]
[PLift.down,[]]
[toBoolUsing_eq_true,[decide_eq_true]]
[List.format,[Unit.unit, List.cons, Std.Format, Std.Format.text, Std.Format.sbracket, Std.Format.joinSep, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.line]]
[MonadControlT.liftWith,[]]
[ForM.noConfusionType,[]]
[fixCore5,[bfix5, USize.size]]
[IO,[EIO, IO.Error]]
[Nat.foldRev,[Nat.foldRev.loop]]
[Subarray.h₁,[]]
[instSTWorldEST,[STWorld.mk, EST]]
[instMonadWithReader,[MonadWithReader.mk, withTheReader]]
[IO.FS.SystemTime.noConfusionType,[]]
[String.modify,[String.set, String.get]]
[unexpandEqNDRec,[ite, Lean.PrettyPrinter.UnexpandM, Lean.Syntax, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.matchesNull, OfNat.ofNat, Nat, instOfNatNat, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
[IO.AccessRight.mk.inj,[And, Eq, Bool, IO.AccessRight.mk, And.intro]]
[coeTail,[CoeTail.coe]]
[Quot.indepCoherent,[PSigma.eta, Quot, Quot.mk, Quot.sound]]
[InvImage,[]]
[Fin.modn,[Fin, Fin.mk, HMod.hMod, Nat, instHMod, Nat.instModNat, Fin.modn.proof_1]]
[Lean.isNumericSubscript,[and, Decidable.decide, LE.le, UInt32, instLEUInt32, OfNat.ofNat, instOfNatUInt32, Char.val, instDecidableLe]]
[Classical.exists_true_of_nonempty,[Exists, True, Exists.intro, trivial]]
[instReprIterator,[Repr.mk, String.Iterator, Std.Format, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, reprArg, String, instReprString, String.Pos, instReprNat]]
[System.FilePath.isAbsolute,[or, List.contains, Char, instBEq, instDecidableEqChar, System.FilePath.pathSeparators, String.front, System.FilePath.toString, and, System.Platform.isWindows, Decidable.decide, GE.ge, Nat, instLENat, String.bsize, OfNat.ofNat, instOfNatNat, Nat.decLe, BEq.beq, String.getOp, String.Pos, Char.ofNat]]
[Array.split,[Array.foldl, Prod, Array, ite, Eq, Bool, Bool.true, instDecidableEqBool, Prod.mk, Array.push, List.toArray, List.nil, OfNat.ofNat, Nat, instOfNatNat, Array.size]]
[StateT.run_seqRight,[]]
[Id.instOfNatId,[inferInstanceAs, OfNat]]
[Prod.fst,[]]
[HAnd.noConfusionType,[]]
[Classical.inhabited_of_exists,[Classical.inhabited_of_nonempty, Classical.inhabited_of_exists.proof_1]]
[EStateM.Backtrackable.save,[]]
[List.pure,[List.cons, List.nil]]
[String.toFormat,[Std.Format.joinSep, String, Std.instToFormatString, String.splitOn, Std.Format.line]]
[instDecidableArrow.proof_2,[absurd, False]]
[AndThen.andThen,[]]
[Lean.Quote.noConfusionType,[]]
[IO.Error.inappropriateType.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.inappropriateType, And, Option, String, UInt32, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[IO.FS.Metadata.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, IO.FS.SystemTime, SizeOf.mk, Int, instSizeOfNat, UInt32, Fin, UInt32.size, LT.lt, instLTNat, instSizeOf, UInt64, UInt64.size, IO.FS.FileType]]
[instDecidableEqQuotient.proof_1,[instSubsingletonDecidable, Eq, Quotient, Quotient.mk]]
[Option.some.injEq,[Eq.propIntro, Eq, Option, Option.some, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[or_true,[propext, Or, True, Iff.intro, trivial, Or.inr]]
[ExceptT.tryCatch,[ExceptT.mk, Bind.bind, Monad.toBind, Except, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.ok]]
[instDecidableFalse,[Decidable.isFalse, False, not_false]]
[LawfulFunctor.map_const,[]]
[Classical.epsilon_spec,[Classical.epsilon_spec_aux, nonempty_of_exists]]
[Lean.Parser.Tactic.Conv.ext,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
[LE.noConfusionType,[]]
[Decidable.byCases,[]]
[Substring.takeWhile,[Substring, Substring.mk]]
[Nat.repeat.loop,[PProd.fst, PUnit, PProd]]
[coeOfDep,[CoeT.mk, coeD]]
[IO.FS.DirEntry.fileName,[]]
[OptionT.orElse,[OptionT.mk, Bind.bind, Monad.toBind, Option, Option.none, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.some, Unit.unit]]
[instTransEq.proof_1,[Eq.symm]]
[List.hasDecidableLt.proof_3,[List.cons, List.nil, List, LT.lt, List.instLTList, List.lt.head, Eq.symm, eq_of_heq, List.lt.tail, Eq.refl, HEq.refl, False, absurd]]
[UInt64.lt,[LT.lt, Fin, UInt64.size, instLTFin, UInt64.val]]
[IO.FileRight.flags,[UInt32.lor]]
[Lean.idEndEscape,[Char.ofNat]]
[Array.toArrayLit.proof_1,[Nat, Array.size, LE.le, instLENat, Nat.le_refl]]
[instMonadExcept,[MonadExcept.mk, throwThe, tryCatchThe]]
[ReaderT.instMonadFunctorReaderT,[MonadFunctor.mk, ReaderT]]
[System.FilePath.mk.inj,[Eq, String, System.FilePath.mk]]
[IO.setAccessRights,[IO.Prim.setAccessRights, IO.FileRight.flags]]
[instStreamList,[Stream.mk, List, Unit.unit, Option, Prod, Option.none, Option.some, Prod.mk]]
[PSigma.lex.proof_1,[WellFounded.intro, PSigma, PSigma.Lex, Acc, PSigma.lexAccessible, WellFounded.apply]]
[IO.Process.Stdio.toHandleType,[Unit.unit, IO.FS.Handle, Unit]]
[instBEqOption,[BEq.mk, Option, Option.none, Unit.unit, Option.some, Bool, Bool.true, and, BEq.beq, Bool.false]]
[Array.appendCore,[Array.size, OfNat.ofNat, Nat, instOfNatNat, Array.appendCore.loop]]
[instShiftRightUSize,[ShiftRight.mk, USize, USize.shiftRight]]
[IO.Error.timeExpired.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, UInt32, SizeOf.mk, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, String, List, Char, UInt32.isValidChar]]
[WellFoundedRelation.mk.inj,[Eq, WellFoundedRelation.mk]]
[termS!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[HDiv.noConfusionType,[]]
[Applicative.noConfusionType,[]]
[Subtype.instDecidableEqSubtype.proof_1,[Eq, Subtype, Subtype.mk, rfl]]
[MonadControlT.restoreM,[]]
[or_false,[propext, Or, False, Iff.intro, False.elim, Or.inl]]
[Except.mapError,[Except, Except.error, Except.ok]]
[Classical.indefiniteDescription.proof_1,[Nonempty, Subtype, Nonempty.intro, Subtype.mk]]
[Lean.Parser.Tactic.Conv.congr,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Parser.Tactic.tacticInfer_instance,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[USize.val,[]]
[System.FilePath.pathExists,[HOrElse.hOrElse, IO, Bool, instHOrElse, instOrElseEIO, IO.Error, SeqRight.seqRight, Applicative.toSeqRight, Monad.toApplicative, instMonadEIO, IO.FS.Metadata, System.FilePath.metadata, Pure.pure, Applicative.toPure, Bool.true, Bool.false]]
[instOfNatNat,[OfNat.mk, Nat]]
[Lean.Syntax.mkSep,[Lean.mkNullNode, Lean.mkSepArray]]
[«term_<=_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[or,[Unit.unit, Bool, Bool.true]]
[IO.Error.mkPermissionDeniedFile,[Function.comp, String, Option, IO.Error, IO.Error.permissionDenied, Option.some]]
[Lean.Syntax.isNameLit?,[String, Option.none, Option, Lean.Name, Lean.Syntax.isLit?, Lean.nameLitKind, Lean.Syntax.decodeNameLit]]
[Nat.eq_zero_or_pos,[Unit.unit, Or, Eq, Nat, OfNat.ofNat, instOfNatNat, GT.gt, instLTNat, Or.inl, rfl, Or.inr, HAdd.hAdd, instHAdd, instAddNat, Nat.succ_pos]]
[instReprDecidable,[Repr.mk, Decidable, Std.Format, Repr.addAppParen, Std.Format.text]]
[ULift.down,[]]
[instReprSubarray,[Repr.mk, Subarray, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, repr, Array, Array.instReprArray, Subarray.toArray, Std.Format.text]]
[Std.Format.append.injEq,[Eq.propIntro, Eq, Std.Format, Std.Format.append, And, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[LawfulApplicative.seqRight_eq,[]]
[IO.FileRight.other,[]]
[String.Pos,[Nat]]
[TC.wf.proof_1,[WellFounded.intro, TC, TC.accessible, WellFounded.apply]]
[Lean.Syntax.mkCApp,[Lean.Syntax.mkApp, Lean.mkCIdent]]
[Lean.Macro.State.noConfusionType,[]]
[Array.partition,[Bind.bind, Id, Monad.toBind, Id.instMonadId, MProd, Array, Prod, ForIn.forIn, Array.instForInArray, MProd.mk, ite, ForInStep, Eq, Bool, Bool.true, instDecidableEqBool, PUnit, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, ForInStep.yield, Prod.mk]]
[StateRefT'.get,[ST.Ref.get]]
[«term_<_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[ST.Ref.set,[liftM, ST, Unit, ST.Prim.Ref.set]]
[IO.FS.Handle.readToEnd,[IO.FS.Handle.readToEnd.loop]]
[List.headD,[]]
[Lean.Parser.Tactic.Conv.delta,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[instAddUSize,[Add.mk, USize, USize.add]]
[String.drop,[Substring.toString, Substring.drop, String.toSubstring]]
[Lean.Meta.Simp.Config.zeta,[]]
[Array.foldrM,[dite, LE.le, optParam, Nat, Array.size, instLENat, Nat.decLe, ite, LT.lt, OfNat.ofNat, instOfNatNat, instLTNat, Nat.decLt, Pure.pure, Applicative.toPure, Monad.toApplicative, Nat.le_refl, Array.foldrM.fold]]
[Lean.Eval.eval,[]]
[Char.instInhabitedChar,[Inhabited.mk, Char, Char.ofNat]]
[Lean.Macro.instInhabitedMethodsRef,[Inhabited.mk, PointedType.type, Lean.Macro.mkMethods, arbitrary, Lean.Macro.Methods, Lean.Macro.instInhabitedMethods]]
[bfix5,[PProd.fst, PUnit, PProd]]
[Iff.mpr,[]]
[OptionT.fail,[OptionT.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, Option, Option.none]]
[Nat.lt_of_succ_le,[]]
[Array.concatMap,[Array.foldl, Array, HAppend.hAppend, instHAppend, Array.instAppendArray, Array.empty, OfNat.ofNat, Nat, instOfNatNat, Array.size]]
[Nat.ble_succ_eq_true,[Eq, Bool, Nat.ble, Nat.succ, Bool.true, Nat.zero, Bool.false, Eq.refl, HEq.refl, rfl, OfNat.ofNat, Nat, instOfNatNat, PProd.fst, PUnit, PProd]]
[FloatArray.set!,[FloatArray, FloatArray.mk, Array.set!, Float]]
[IO.Process.Stdio.noConfusionType,[noConfusionTypeEnum, IO.Process.Stdio, Nat, instDecidableEqNat, IO.Process.Stdio.toCtorIdx]]
[Lean.Parser.Tactic.existsIntro,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Lean.Parser.Tactic.«tacticNext___=>_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
[HEq.noConfusionType,[]]
[Nat.noConfusionType,[]]
[instSizeOfNat,[SizeOf.mk, Nat]]
[List.hasDecEq.proof_1,[rfl, List, List.nil]]
[LawfulMonad.noConfusionType,[]]
[instSubUInt32,[Sub.mk, UInt32, UInt32.sub]]
[Lean.Name.appendBefore,[Lean.Name.modifyBase, Unit.unit, Lean.Name, Lean.Name.mkStr, Lean.Name.anonymous, HAppend.hAppend, String, instHAppend, String.instAppendString, Lean.Name.mkNum]]
[List.enum,[List.enumFrom, OfNat.ofNat, Nat, instOfNatNat]]
[Std.Format.text.injEq,[Eq.propIntro, Eq, Std.Format, Std.Format.text, String, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.lt_or_eq_or_le_succ,[Decidable.byCases, Eq, Nat, Nat.succ, Or, LE.le, instLENat, instDecidableEqNat, Or.inr]]
[WellFounded.noConfusionType,[]]
[IO.mapTasks.go,[Task, IO, Except, IO.Error, IO.bindTask, PProd.fst, PUnit, PProd, List.cons, IO.asTask, List.reverse]]
[«term_\/_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[«term_/\_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instSubsingletonDecidable.proof_1,[Subsingleton.intro, Decidable, Eq, Decidable.isTrue, rfl, absurd, Decidable.isFalse]]
[Lean.Parser.Tactic.«tacticHave__:=_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Std.Format.sbracket,[Std.Format.bracket]]
[Nat.instShiftRightNat,[ShiftRight.mk, Nat, Nat.shiftRight]]
[Nat.toUSize,[USize.ofNat]]
[Classical.em,[]]
[Array.toSubarray,[dite, Subarray, LE.le, optParam, Nat, Array.size, instLENat, Nat.decLe, OfNat.ofNat, instOfNatNat, Subarray.mk, Nat.le_refl, Array.toSubarray.proof_1]]
[HSub.noConfusionType,[]]
[IO.FS.Stream.ofBuffer,[IO.FS.Stream.mk, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Stream.Buffer, Bool, ST.Ref.get, IO.RealWorld, instMonadLiftT, ST, IO.instMonadLiftSTRealWorldEIO, instMonadLiftT_1, Pure.pure, Applicative.toPure, Monad.toApplicative, Decidable.decide, GE.ge, Nat, instLENat, IO.FS.Stream.Buffer.pos, ByteArray.size, IO.FS.Stream.Buffer.data, Nat.decLe, Unit, Unit.unit, ST.Ref.modifyGet, ByteArray, Prod.mk, IO.FS.Stream.Buffer.mk, HAdd.hAdd, instHAdd, instAddNat, ST.Ref.modify, ByteArray.copySlice, OfNat.ofNat, instOfNatNat, Bool.false, String, String.fromUTF8Unchecked, ByteArray.extract]]
[instOrdUInt64,[Ord.mk, UInt64, compareOfLessAndEq, instLTUInt64, instDecidableLt_3, instDecidableEqUInt64]]
[Option.noConfusionType,[]]
[true_ne_false,[ne_false_of_self, True, trivial]]
[Lean.Syntax.getOp,[Lean.Syntax.getArg]]
[«termExists_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
[instToStringId,[inferInstanceAs, ToString]]
[ExceptT.adapt,[ExceptT.mk, Functor.map, Applicative.toFunctor, Monad.toApplicative, Except, Except.mapError]]
[Classical.axiomOfChoice,[Exists.intro, Classical.choose, Classical.choose_spec]]
[Array.allM,[Bind.bind, Monad.toBind, Bool, Array.anyM, Pure.pure, Applicative.toPure, Monad.toApplicative, not, OfNat.ofNat, Nat, instOfNatNat, Array.size]]
[Lean.Meta.Simp.Config.mk.injEq,[Eq.propIntro, Eq, Lean.Meta.Simp.Config, Lean.Meta.Simp.Config.mk, And, Nat, Bool, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[PSigma.mkSkipLeft.proof_1,[PSigma.RevLex.right, emptyRelation]]
[«stx_,*»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
[StdGen.s2,[]]
[PSigma.revLex,[PSigma.revLex.proof_1]]
[String.decEq.proof_1,[congrArg, List, Char, String, String.mk]]
[AndOp.and,[]]
[Quot.recOn,[Quot.rec]]
[instInhabitedBool,[Inhabited.mk, Bool, Bool.false]]
[instBEqFloat,[BEq.mk, Float, Float.beq]]
[instMonadEST,[inferInstanceAs, Monad, EStateM, EStateM.instMonadEStateM]]
[IO.Error.otherError.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.otherError, And, UInt32, String, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[OptionT,[Option]]
[Std.ToFormat.noConfusionType,[]]
[Subarray.popFront.proof_1,[Nat.le_of_lt_succ, HAdd.hAdd, Nat, instHAdd, instAddNat, Subarray.start, OfNat.ofNat, instOfNatNat, Subarray.stop, Nat.add_lt_add_right]]
[Classical.strongIndefiniteDescription.proof_2,[absurd, Exists, Classical.choice]]
[Sigma.snd,[]]
[List.minimum?,[Unit.unit, Option, Option.none, Option.some, List.foldl, min]]
[String.nextWhile,[String.bsize]]
[Eq.subst,[]]
[inline,[]]
[UInt8.toUInt16,[Nat.toUInt16, UInt8.toNat]]
[instOrOpUSize,[OrOp.mk, USize, USize.lor]]
[Array.uget,[Array.get, Fin.mk, Array.size, USize.toNat]]
[Lean.Parser.Tactic.simpLemma,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.Parser.Tactic.simpPre, Lean.Parser.Tactic.simpPost, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat]]
[not,[Unit.unit, Bool, Bool.false, Bool.true]]
[USize.ofNat32,[USize.mk, Fin.mk, USize.size, USize.ofNat32.proof_1]]
[SeqLeft.noConfusionType,[]]
[HMod.hMod,[]]
[Lean.scientificLitKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[PointedType.noConfusionType,[]]
[ne_eq,[rfl, Ne]]
[System.instToStringFilePath,[ToString.mk, System.FilePath, System.FilePath.toString]]
[Std.Range.mk.inj,[And, Eq, Nat, Std.Range.mk, And.intro]]
[Lean.mkIdentFromRef,[Bind.bind, Monad.toBind, Lean.Syntax, Lean.MonadRef.getRef, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.mkIdentFrom]]
[SizeOf.noConfusionType,[]]
[Lean.Macro.Exception.noConfusionType,[]]
[controlAt,[Bind.bind, MonadControlT.stM, MonadControlT.liftWith, MonadControlT.restoreM]]
[Quotient.lift,[Quot.lift, HasEquiv.Equiv, instHasEquiv]]
[eq_false,[propext, False, Iff.intro, absurd, False.elim]]
[Array.toListLitAux.proof_2,[Nat.lt_of_lt_of_eq, Array.size, Nat.lt_of_lt_of_le, Nat.succ, Nat.lt_succ_self]]
[instOfNatUSize,[OfNat.mk, USize, USize.ofNat]]
[instReprAtomFloat,[ReprAtom.mk, Float]]
[WellFounded.fixF,[]]
[Lean.Parser.Tactic.Conv.«conv·._»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq]]
[UInt64.sub,[UInt64.mk, HSub.hSub, Fin, UInt64.size, instHSub, Fin.instSubFin, UInt64.val]]
[String.endsWith,[BEq.beq, Substring, Substring.hasBeq, Substring.takeRight, String.toSubstring, String.length]]
[termWithout_expected_type_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Int.le,[Int.NonNeg, HSub.hSub, Int, instHSub, Int.instSubInt]]
[true_and,[propext, And, True, Iff.intro, And.right, And.intro, trivial]]
[Lean.MacroScopesView.review,[Lean.MacroScope, Unit.unit, Lean.Name, Lean.MacroScopesView.scopes, Lean.MacroScopesView.name, List.foldl, Nat, Lean.Name.mkNum]]
[Bool.true_or,[Eq, Bool, or, Bool.true, Bool.false, rfl, Eq.symm, Eq.refl]]
[PNonScalar.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat]]
[Fin.shiftLeft.proof_1,[LT.lt, Nat, instLTNat, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, HShiftLeft.hShiftLeft, instHShiftLeft, Nat.instShiftLeftNat]]
[Lean.Meta.Simp.Config.beta,[]]
[ByteArray.get!,[UInt8, Array.get!, instInhabitedUInt8]]
[Lean.Meta.TransparencyMode.all.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[Lean.version.specialDesc,[Lean.version.getSpecialDesc, Unit.unit]]
[dite_false,[rfl, dite, False, instDecidableFalse]]
[«term_/_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[CoeHead.noConfusionType,[]]
[Option.map,[Option.bind, Function.comp, Option, Option.some]]
[Nat.succ_ne_zero,[False, Nat.succ, OfNat.ofNat, Nat, instOfNatNat]]
[Array.filterMapM,[Array.foldlM, Array, Bind.bind, Monad.toBind, Option, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.push, List.toArray, List.nil]]
[instInhabitedUInt32,[Inhabited.mk, UInt32, UInt32.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, instInhabitedUInt32.proof_1]]
[instToStringOption,[ToString.mk, Option, Unit.unit, String, HAppend.hAppend, instHAppend, String.instAppendString, addParenHeuristic, ToString.toString]]
[instMulNat,[Mul.mk, Nat, Nat.mul]]
[StateM,[StateT, Id]]
[«term_&&&_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[IO.Error.unsupportedOperation.inj,[And, Eq, UInt32, String, IO.Error.unsupportedOperation, And.intro]]
[UInt32.ofNat',[UInt32.mk, Fin.mk, UInt32.size]]
[decidableOfDecidableOfIff.proof_1,[absurd, False, Iff.mpr]]
[instMulUInt8,[Mul.mk, UInt8, UInt8.mul]]
[Lean.Name.mkSimple,[Lean.Name.mkStr, Lean.Name.anonymous]]
[String.Iterator.hasNext,[Bool, Decidable.decide, LT.lt, String.Pos, instLTNat, String.utf8ByteSize, Nat.decLt]]
[String.decapitalize,[String.set, OfNat.ofNat, String.Pos, instOfNatNat, Char.toLower, String.get]]
[Array.findSomeRevM?,[Array.size, Nat.le_refl, Array.findSomeRevM?.find]]
[IO.Error.mkPermissionDenied,[IO.Error.permissionDenied, Option.none, String]]
[instMulFloat,[Mul.mk, Float, Float.mul]]
[Nat.ble_eq_true_of_le,[Eq, Bool, Nat.ble, Bool.true, Nat, LE.le, instLENat, Nat.le.refl, Unit.unit, Eq.symm, eq_of_heq, Nat.succ, Nat.le.step, Eq.refl, HEq.refl, Nat.ble_self_eq_true, Nat.ble_succ_eq_true, PProd.fst, PUnit, PProd]]
[coeM,[Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, coe]]
[instDecidableEqOption,[Option.none, Unit.unit, Option.some, Decidable, Eq, Option, Decidable.isTrue, rfl, Decidable.isFalse, False, dite]]
[Lean.instMonadQuotation,[Lean.MonadQuotation.mk, Lean.instMonadRef, Lean.MonadQuotation.toMonadRef, liftM, instMonadLiftT, instMonadLiftT_1, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, MonadFunctorT.monadMap, instMonadFunctorT, monadFunctorRefl, Lean.MonadQuotation.withFreshMacroScope]]
[Lean.Module.commands,[]]
[ExceptT.run_pure,[rfl, Except, ExceptT.run, Pure.pure, ExceptT, Applicative.toPure, Monad.toApplicative, ExceptT.instMonadExceptT]]
[List.lengthTR,[List.lengthTRAux, OfNat.ofNat, Nat, instOfNatNat]]
[instXorUInt32,[Xor.mk, UInt32, UInt32.xor]]
[Fin.xor.proof_1,[LT.lt, Nat, instLTNat, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, Nat.xor]]
[Lean.Parser.Tactic.Conv.simp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpStar, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma]]
[WellFoundedRelation.mk.injEq,[Eq.propIntro, Eq, WellFoundedRelation, WellFoundedRelation.mk, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Array.findSome?,[Id.run, Option, Array.findSomeM?, Id, Id.instMonadId]]
[instToStringULift,[ToString.mk, ULift, ToString.toString, ULift.down]]
[Lean.Syntax.mkApp,[dite, Eq, Nat, Array.size, Lean.Syntax, instDecidableEqNat, Array, List.toArray, List.nil, Unit.unit, Eq.symm, Array.toArrayLit_eq, Eq.refl, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.cons, Lean.mkNullNode]]
[Array.forM,[Array.foldlM, PUnit, PUnit.unit]]
[Lean.Syntax.getNumArgs,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Nat, Array.size, Lean.Syntax, OfNat.ofNat, instOfNatNat]]
[EStateM.run,[]]
[IO.Error.unexpectedEof.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[System.Platform.isEmscripten,[System.Platform.getIsEmscripten, Unit.unit]]
[Classical.skolem,[Iff.intro, Exists, Classical.axiomOfChoice, Exists.intro]]
[instReprFin,[Repr.mk, Fin, repr, Nat, instReprNat, Fin.val]]
[Lean.Parser.Tactic.rwRule,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat]]
[List.redLength,[Nat, Unit.unit, OfNat.ofNat, instOfNatNat, Nat.succ, PProd.fst, PUnit, PProd]]
[List.get?,[Option, Nat.zero, List.nil, Nat.succ, Option.some, PProd.fst, PUnit, PProd, Option.none]]
[Lean.Name.eraseMacroScopes,[Unit.unit, Lean.Name, Lean.Name.hasMacroScopes, BEq.beq, String, instBEq, instDecidableEqString, PProd.fst, PUnit, PProd, Lean.Name.anonymous]]
[IO.userError,[IO.Error.userError]]
[sizeOfWFRel,[measure, SizeOf.sizeOf]]
[Lean.MonadNameGenerator.setNGen,[]]
[Subarray.mk.inj,[And, Eq, Array, Nat, Subarray.mk, And.intro]]
[Nat.mul_pos,[]]
[List.hasDecidableLt.proof_1,[List.nil, List.cons, Eq.refl, List, HEq.refl, LT.lt, List.instLTList, False]]
[IO.Error.instToStringError,[ToString.mk, IO.Error, IO.Error.toString]]
[instToBoolBool,[ToBool.mk, Bool]]
[ExceptCpsT.lift,[Bind.bind, Monad.toBind]]
[default.sizeOf,[OfNat.ofNat, Nat, instOfNatNat]]
[instMulUSize,[Mul.mk, USize, USize.mul]]
[System.FilePath.instDivFilePath,[Div.mk, System.FilePath, System.FilePath.join]]
[Quot.liftIndepPr1,[Quot.ind, Eq, Quot, PSigma.fst, Quot.lift, PSigma, Quot.indep, Quot.indepCoherent, rfl, Quot.mk]]
[«term_^^^_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[IO.FS.Stream.Buffer.pos,[]]
[List.forIn.loop,[Pure.pure, Applicative.toPure, Monad.toApplicative, Bind.bind, Monad.toBind, ForInStep, PProd.fst, PUnit, PProd]]
[Lean.Syntax.node.inj,[And, Eq, Lean.SyntaxNodeKind, Array, Lean.Syntax, Lean.Syntax.node, And.intro]]
[Subrelation,[]]
[IO.Error.mkUnsupportedOperation,[IO.Error.unsupportedOperation]]
[IO.FS.Metadata.noConfusionType,[]]
[Array.set!,[Array.setD]]
[Nonempty.elim,[Nonempty.elim.proof_1]]
[OptionT.instMonadFunctorOptionT,[MonadFunctor.mk, OptionT, Option]]
[DoResultBC.noConfusionType,[]]
[instNegFloat,[Neg.mk, Float, Float.neg]]
[Quotient,[Quot, Setoid.r]]
[RandomGen.range,[]]
[instInhabited,[Inhabited.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, arbitrary]]
[instSubsingletonForall,[instSubsingletonForall.proof_1]]
[Lean.Syntax.isScientificLit?,[String, Option.none, Option, Prod, Nat, Bool, Lean.Syntax.isLit?, Lean.scientificLitKind, Lean.Syntax.decodeScientificLitVal?]]
[Quotient.sound.proof_1,[Quot.sound, HasEquiv.Equiv, instHasEquiv]]
[ExceptT.bindCont,[Except, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.error]]
[IO.AccessRight.read,[]]
[List.getLastD.proof_1,[False, List.cons, List.nil]]
[USize.modn,[USize.mk, HMod.hMod, Fin, USize.size, Nat, Fin.instHModFinNatFin, USize.val]]
[seqLeft_eq_bind,[Eq.mpr, Eq, SeqLeft.seqLeft, Applicative.toSeqLeft, Monad.toApplicative, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const, Eq.refl, LawfulApplicative.seqLeft_eq, LawfulMonad.toLawfulApplicative, of_eq_true, Eq.trans, True, congrFun, congrArg, map_eq_pure_bind, seq_eq_bind_map, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, eq_self]]
[instHModUInt32NatUInt32,[HMod.mk, UInt32, Nat, UInt32.modn]]
[HAdd.hAdd,[]]
[UInt32.decLe,[UInt32.mk, Decidable, LE.le, UInt32, instLEUInt32, inferInstanceAs, Fin, UInt32.size, instLEFin, Fin.decLe]]
[unexpandPSigma,[ite, Lean.PrettyPrinter.UnexpandM, Lean.Syntax, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.matchesNull, OfNat.ofNat, Nat, instOfNatNat, cond, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
[Lean.MacroScopesView.noConfusionType,[]]
[Nat.succ_sub_succ,[Nat.succ_sub_succ_eq_sub]]
[UInt16.val,[]]
[IO.FS.instBEqFileType,[BEq.mk, IO.FS.FileType, BEq.beq, Nat, instBEq, instDecidableEqNat, IO.FS.FileType.toCtorIdx]]
[Subtype.eq,[Subtype.mk, Subtype.val, Eq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl, Subtype, rfl]]
[OptionT.instAlternativeOptionT,[Alternative.mk, OptionT, Monad.toApplicative, OptionT.instMonadOptionT, OptionT.fail, OptionT.orElse]]
[Fin.modn.proof_1,[LT.lt, Nat, instLTNat, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt]]
[Lean.Macro.hasDecl,[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, Bool, Lean.Macro.getMethods, Lean.Macro.Methods.hasDecl]]
[Array.feraseIdx,[Array.eraseIdxAux, HAdd.hAdd, Nat, instHAdd, instAddNat, Fin.val, Array.size, OfNat.ofNat, instOfNatNat]]
[ReaderT.orElse,[HOrElse.hOrElse, instHOrElse, instOrElse, Unit.unit]]
[fixCore4,[bfix4, USize.size]]
[List.hasDecEq.proof_6,[False, List.cons, absurd, Eq]]
[Nat.pow_le_pow_of_le_left,[LE.le, Nat, instLENat, HPow.hPow, instHPow, instPowNatNat, Unit.unit, Nat.le_refl, OfNat.ofNat, instOfNatNat, Nat.mul_le_mul, Nat.pow, PProd.fst, PUnit, PProd]]
[Nat.ne_of_beq_eq_false,[False, Nat.zero, Nat.succ, Nat.beq, Bool.false]]
[MonadFunctor.noConfusionType,[]]
[fix3,[fixCore3, arbitrary]]
[Nat.gcd_self,[Eq, Nat, Nat.gcd, Nat.zero, of_eq_true, Eq.trans, OfNat.ofNat, instOfNatNat, True, congr, congrArg, Nat.zero_eq, Nat.gcd_zero_right, eq_true_of_decide, instDecidableEqNat, Eq.refl, Bool, Bool.true, Eq.symm, Nat.succ, congrFun, HMod.hMod, instHMod, Nat.instModNat, Nat.gcd_succ, Nat.mod_self, Nat.gcd_zero_left, eq_self]]
[Lean.Name.appendIndexAfter,[Lean.Name.modifyBase, Lean.Name.anonymous, Lean.Name.num, Lean.Name, Lean.Name.mkStr, HAppend.hAppend, String, instHAppend, String.instAppendString, ToString.toString, Nat, instToStringNat]]
[String.Iterator.toEnd,[String.Iterator, String.Iterator.mk, String.bsize]]
[coeB,[Coe.coe]]
[Nat.gcd_zero_left,[rfl, Nat, Nat.gcd, OfNat.ofNat, instOfNatNat]]
[Ord.compare,[]]
[ST.Ref.mk.inj,[Eq, PointedType.type, ST.RefPointed, ST.Ref.mk]]
[ST.Ref.noConfusionType,[]]
[ReaderT.run_seqLeft,[Eq.mpr, Eq, ReaderT.run, SeqLeft.seqLeft, ReaderT, Applicative.toSeqLeft, Monad.toApplicative, ReaderT.instMonadReaderT, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Eq.refl, seqLeft_eq_bind, rfl]]
[Nat.lt_irrefl,[Nat.not_succ_le_self]]
[List.filterAuxM,[List, Pure.pure, Applicative.toPure, Monad.toApplicative, Bind.bind, Monad.toBind, Bool, PProd.fst, PUnit, PProd, cond, List.cons]]
[System.FilePath.isCaseInsensitive,[or, System.Platform.isWindows, System.Platform.isOSX]]
[FloatArray.get!,[Float, Array.get!, instInhabitedFloat]]
[Nat.add_mul,[Nat.right_distrib]]
[Lean.Syntax.atom.inj,[And, Eq, Lean.SourceInfo, String, Lean.Syntax.atom, And.intro]]
[Bool.true_and,[Eq, Bool, and, Bool.true, Bool.false, rfl, Eq.symm, Eq.refl]]
[TC.accessible.proof_1,[Acc, TC, Acc.intro, Acc.inv]]
[withPtrAddr,[OfNat.ofNat, USize, instOfNatUSize]]
[Std.Range.«term[_:_]»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[IO.Error.mkUnsatisfiedConstraints,[IO.Error.unsatisfiedConstraints]]
[Lean.Parser.Tactic.Conv.convErw_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq]]
[UInt8.toUInt64,[Nat.toUInt64, UInt8.toNat]]
[List.head!,[Unit.unit, panicWithPosWithDecl, OfNat.ofNat, Nat, instOfNatNat]]
[coeFun,[CoeFun.coe]]
[Array.toListLitAux,[List, PProd.fst, PUnit, PProd, Array.toListLitAux.proof_1, List.cons, Array.getLit, Array.toListLitAux.proof_2]]
[List.isEmpty,[Unit.unit, Bool, Bool.true, Bool.false]]
[List.forA,[PUnit, Unit.unit, Pure.pure, Applicative.toPure, PUnit.unit, SeqRight.seqRight, Applicative.toSeqRight, PProd.fst, PProd]]
[IO.Error.hardwareFault.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.hardwareFault, And, UInt32, String, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[USize.mod,[USize.mk, HMod.hMod, Fin, USize.size, instHMod, Fin.instModFin, USize.val]]
[instAppendSubarray,[Append.mk, Subarray, Array.toSubarray, OfNat.ofNat, optParam, Nat, instOfNatNat, Array.size]]
[Array.filter,[Array.foldl, Array, ite, Eq, Bool, Bool.true, instDecidableEqBool, Array.push, List.toArray, List.nil]]
[DoResultSBC.continue.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[Except.ok.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[IO.Process.Output.mk.inj,[And, Eq, UInt32, String, IO.Process.Output.mk, And.intro]]
[Array.push,[Array.mk, List.concat, Array.data]]
[String.toInt?,[OptionM.run, Int, ite, OptionM, Eq, Char, String.get, OfNat.ofNat, String.Pos, instOfNatNat, Char.ofNat, instDecidableEqChar, Bind.bind, Monad.toBind, OptionT.instMonadOptionT, Id, Id.instMonadId, Nat, Substring.toNat?, Substring.drop, String.toSubstring, Pure.pure, Applicative.toPure, Alternative.toApplicative, OptionT.instAlternativeOptionT, Neg.neg, Int.instNegInt, Int.ofNat, Functor.map, Applicative.toFunctor, String.toNat?]]
[MonadExceptOf.throw,[]]
[Classical.epsilon_spec_aux,[Subtype.property, Classical.strongIndefiniteDescription]]
[liftM,[MonadLiftT.monadLift]]
[Nat.mod.proof_1,[WellFoundedRelation.wf, Nat, measure, id]]
[Nat.left_distrib,[Eq, Nat, HMul.hMul, instHMul, instMulNat, HAdd.hAdd, instHAdd, instAddNat, Eq.mpr, Nat.zero, OfNat.ofNat, instOfNatNat, Eq.refl, Nat.zero_mul, rfl, Nat.succ, congr, congrArg, Eq.trans, Nat.succ_mul, congrFun, Nat.add_assoc, Nat.add_left_comm]]
[Nat.zero_eq,[rfl, Nat, Nat.zero]]
[Lean.instQuoteProd,[Lean.Quote.mk, Prod, Lean.Syntax, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Quote.quote, List.nil]]
[List.groupByAux,[List, List.nil, List.cons, Unit.unit, PProd.fst, PUnit, PProd, List.reverse]]
[Lean.MacroScopesView.name,[]]
[List.cons.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, List, SizeOf.mk]]
[Float.lt,[Float.mk, FloatSpec.lt, floatSpec]]
[runEST,[Unit, Except, Unit.unit, Except.ok, Except.error]]
[instHPow,[HPow.mk, Pow.pow]]
[List.getLast!,[Unit.unit, panicWithPosWithDecl, OfNat.ofNat, Nat, instOfNatNat, List.getLast, List.cons, List.getLast!.proof_1]]
[Nat.mul_one,[Nat.zero_add]]
[CoeT.coe,[]]
[String.Iterator.hasPrev,[Bool, Decidable.decide, GT.gt, String.Pos, instLTNat, OfNat.ofNat, instOfNatNat, Nat.decLt]]
[EStateM.instInhabitedEStateM,[Inhabited.mk, EStateM, EStateM.Result.error, arbitrary]]
[Decidable.not_and_iff_or_not,[Iff.intro, Not, And, Or, Decidable.isFalse, Decidable.isTrue, absurd, And.intro, Or.inr, Or.inl, False]]
[«term_==_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Array.getMax?,[dite, Option, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, Array.size, Nat.decLt, Option.some, Array.foldl, ite, Eq, Bool, Bool.true, instDecidableEqBool, optParam, Option.none]]
[List.elem,[Bool, Unit.unit, Bool.false, BEq.beq, Bool.true, PProd.fst, PUnit, PProd]]
[String.dropRight,[Substring.toString, Substring.dropRight, String.toSubstring]]
[IO.AccessRight.noConfusionType,[]]
[List.reverseAux,[List, PProd.fst, PUnit, PProd, List.cons]]
[IO.Error.noConfusionType,[]]
[System.FilePath.fileName,[ite, Option, String, Eq, Bool, or, String.isEmpty, BEq.beq, instBEq, instDecidableEqString, Bool.true, instDecidableEqBool, Option.none, Option.some]]
[ToStream.toStream,[]]
[unexpandSigma,[ite, Lean.PrettyPrinter.UnexpandM, Lean.Syntax, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.matchesNull, OfNat.ofNat, Nat, instOfNatNat, cond, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
[instToStreamListList,[ToStream.mk, List]]
[let_val_congr,[Eq, rfl]]
[Lean.SyntaxNodeKind,[Lean.Name]]
[ExceptCpsT.run_throw,[rfl, Except, ExceptCpsT.run, MonadExcept.throw, ExceptCpsT, instMonadExcept, ExceptCpsT.instMonadExceptOfExceptCpsT]]
[Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp,[Trans.mk, Nat, LT.lt, instLTNat, Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1]]
[Char.utf8Size.proof_5,[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
[Lean.Parser.Tactic.Conv.whnf,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[«term{__:_//_}»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[instSubsingleton,[instSubsingleton.proof_1]]
[UInt32.div,[UInt32.mk, HDiv.hDiv, Fin, UInt32.size, instHDiv, Fin.instDivFin, UInt32.val]]
[Setoid.trans,[Equivalence.trans, Setoid.r, Setoid.iseqv]]
[Nat.add_left_cancel,[Eq, Nat, Eq.mpr, implies_congr, HAdd.hAdd, instHAdd, instAddNat, Nat.zero, congr, congrArg, Eq.trans, OfNat.ofNat, instOfNatNat, congrFun, Nat.zero_eq, Nat.zero_add, Eq.refl, Nat.succ, Nat.succ_add, Nat.succ.injEq]]
[implies_true,[propext, True, Iff.intro, trivial, True.intro]]
[instMonadStateOf,[MonadStateOf.mk, liftM, instMonadLiftT, instMonadLiftT_1, MonadStateOf.get, PUnit, MonadStateOf.set, MonadLiftT.monadLift, MonadState.modifyGet, instMonadState]]
[instHashable,[Hashable.mk, OfNat.ofNat, UInt64, instOfNatUInt64]]
[HSub.hSub,[]]
[prioDefault,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[List.lookup,[Prod, Option, List.cons, Option.none, Unit.unit, BEq.beq, Option.some, PProd.fst, PUnit, PProd]]
[UInt32.toUInt16,[Nat.toUInt16, UInt32.toNat]]
[Trans.trans,[]]
[Lean.mkCIdent,[Lean.mkCIdentFrom, Lean.Syntax.missing]]
[Lean.instInhabitedNameGenerator,[Inhabited.mk, Lean.NameGenerator, Lean.NameGenerator.mk, arbitrary, Lean.Name, Lean.instInhabitedName, Nat, instInhabitedNat]]
[List.length_set,[Eq, Nat, List.length, List.set, rfl, List.nil, List.cons, Nat.zero, Eq.symm, Nat.succ, of_eq_true, Eq.trans, True, congr, congrArg, List.length_cons, eq_self, Eq.refl]]
[StateT.run_modify,[rfl, Prod, PUnit, StateT.run, modify, StateT, instMonadState, instMonadStateOfStateT]]
[StateCpsT.run'_eq,[rfl, StateCpsT.run']]
[Except.map_id,[funext, Except, Except.map, id, Eq.mpr, Eq, Except.error, Except.ok, congr, congrArg, id_eq, rfl, Eq.symm, Eq.refl]]
[and_true,[propext, And, True, Iff.intro, And.left, And.intro, trivial]]
[Fin.land,[Fin.mk, Fin, HMod.hMod, Nat, instHMod, Nat.instModNat, Nat.land, Fin.land.proof_1]]
[ExceptCpsT.runK,[]]
[MonadWithReaderOf.withReader,[]]
[USize.ofNatCore,[USize.mk, Fin.mk, USize.size]]
[Lean.NameGenerator.namePrefix,[]]
[Array.foldr,[Id.run, Array.foldrM, Id, Id.instMonadId]]
[String.instDecidableEqIterator,[String.Iterator.mk, Decidable, Eq, String.Iterator, dite, String, instDecidableEqString, String.Pos, instDecidableEqNat, Decidable.isTrue, rfl, Decidable.isFalse, False]]
[instToFormatList,[Std.ToFormat.mk, List, List.format]]
[Lean.Syntax.decodeStrLit,[Lean.Syntax.decodeStrLitAux, OfNat.ofNat, String.Pos, instOfNatNat]]
[«term∃_,_»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
[Quotient.lift₂.proof_2,[Quotient.ind, Eq, Quotient.lift, Setoid.refl]]
[HXor.hXor,[]]
[Array.isEmpty,[Decidable.decide, Eq, Nat, Array.size, OfNat.ofNat, instOfNatNat, instDecidableEqNat]]
[UInt32.toUSize,[Nat.toUSize, UInt32.toNat]]
[instCoeStringError,[Coe.mk, String, IO.Error, IO.userError]]
[IO.FS.instInhabitedSystemTime,[Inhabited.mk, IO.FS.SystemTime, IO.FS.SystemTime.mk, arbitrary, Int, Int.instInhabitedInt, UInt32, instInhabitedUInt32]]
[ReprAtom.noConfusionType,[]]
[Eq.trans,[Eq]]
[List.asString,[String.mk]]
[Array.find?,[Id.run, Option, Array.findM?, Id, Id.instMonadId]]
[Array.contains,[Array.any, BEq.beq, OfNat.ofNat, Nat, instOfNatNat, Array.size]]
[proofIrrel,[rfl]]
[instDecidableIff.proof_1,[Iff.intro]]
[withPtrEqDecEq,[Decidable, Eq, Eq.refl, Bool, Decidable.isTrue, withPtrEqDecEq.proof_2, Decidable.isFalse, withPtrEqDecEq.proof_3]]
[List.length_add_eq_lengthTRAux,[Eq, Nat, HAdd.hAdd, instHAdd, instAddNat, List.length, List.lengthTRAux, of_eq_true, OfNat.ofNat, instOfNatNat, Eq.trans, True, congrFun, congrArg, Nat.zero_add, eq_self, Eq.mpr, List.cons, Nat.succ, congr, Nat.succ_add, Eq.symm, rfl]]
[hexDigitRepr,[String.singleton, Nat.digitChar]]
[instDecidableEqSum.proof_3,[Eq, Sum, Sum.inr, rfl]]
[Int.decEq.proof_1,[Nat, Eq, Int, Int.ofNat, rfl]]
[Substring.trimLeft,[Substring.dropWhile, Char.isWhitespace]]
[Lean.Parser.Tactic.Conv.rewrite,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq]]
[Std.Range.stop,[]]
[heq_of_eq,[Eq.subst, HEq, HEq.refl]]
[UInt16.lt,[LT.lt, Fin, UInt16.size, instLTFin, UInt16.val]]
[WellFounded.fix,[WellFounded.fixF, WellFounded.apply]]
[Array.foldlMUnsafe.fold,[ite, Eq, Bool, BEq.beq, USize, instBEq, instDecidableEqUSize, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, Bind.bind, Monad.toBind, Array.uget, lcProof, LT.lt, Nat, instLTNat, USize.toNat, Array.size, Array.foldlMUnsafe.fold, HAdd.hAdd, instHAdd, instAddUSize, OfNat.ofNat, instOfNatUSize]]
[Lean.Parser.Tactic.tacticLet_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[MonadControl.noConfusionType,[]]
[IO.FS.Metadata.accessed,[]]
[Array.findSomeRevM?.find.proof_1,[Nat.lt_of_lt_of_le, Nat.succ, Array.size, Nat.lt_succ_self]]
[Lean.Name.toString.maybePseudoSyntax,[Lean.Name.anonymous, Lean.Name.num, Bool, Lean.Name.getRoot, or, String.isPrefixOf, Bool.false]]
[Array.getLit,[Array.get, Fin.mk, Array.size, Array.getLit.proof_1]]
[IO.rand,[Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, StdGen, Nat, ST.Ref.get, IO.RealWorld, instMonadLiftT, ST, IO.instMonadLiftSTRealWorldEIO, instMonadLiftT_1, IO.stdGenRef, Unit, ST.Ref.set, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[Inhabited.noConfusionType,[]]
[cast,[]]
[Lean.NameGenerator.next,[Lean.NameGenerator.mk, Lean.NameGenerator.namePrefix, HAdd.hAdd, Nat, instHAdd, instAddNat, Lean.NameGenerator.idx, OfNat.ofNat, instOfNatNat]]
[Lean.Macro.Methods.noConfusionType,[]]
[Lean.Parser.Tactic.tacticSorry,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Char.isValidCharNat,[Or, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, And]]
[HOrElse.hOrElse,[]]
[System.FilePath.toString,[]]
[Lean.isGreek,[and, Decidable.decide, LE.le, UInt32, instLEUInt32, OfNat.ofNat, instOfNatUInt32, Char.val, instDecidableLe]]
[Functor.mapConst,[]]
[Array.allDiff,[OfNat.ofNat, Nat, instOfNatNat]]
[Prod.foldI,[Nat.foldAux, Prod.snd, Nat, HSub.hSub, instHSub, instSubNat, Prod.fst]]
[HEq.elim,[eq_of_heq]]
[UInt64.mul,[UInt64.mk, HMul.hMul, Fin, UInt64.size, instHMul, Fin.instMulFin, UInt64.val]]
[Array.eraseIdx',[Array.eraseIdxSzAux, HAdd.hAdd, Nat, instHAdd, instAddNat, Fin.val, Array.size, OfNat.ofNat, instOfNatNat, Array.eraseIdx'.proof_1]]
[Ordering.noConfusion,[noConfusionEnum, Ordering, Nat, instDecidableEqNat, Ordering.toCtorIdx]]
[IO.FS.DirEntry.mk.injEq,[Eq.propIntro, Eq, IO.FS.DirEntry, IO.FS.DirEntry.mk, And, System.FilePath, String, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.foldRevM.loop,[Pure.pure, Applicative.toPure, Monad.toApplicative, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd]]
[Array.getOp,[Array.get!]]
[System.FilePath.normalize,[ite, System.FilePath, Eq, Bool, and, BEq.beq, Nat, instBEq, instDecidableEqNat, List.length, Char, System.FilePath.pathSeparators, OfNat.ofNat, instOfNatNat, not, Bool.true, instDecidableEqBool, System.FilePath.mk, String.map, List.contains, instDecidableEqChar, System.FilePath.pathSeparator, Char.toLower, System.FilePath.toString]]
[ReaderT.tryFinally,[MonadFinally.mk, ReaderT, MonadFinally.tryFinally']]
[StateT.run_get,[rfl, Prod, StateT.run, MonadState.get, StateT, instMonadState, instMonadStateOfStateT]]
[Lean.Meta.TransparencyMode.instances.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[instToStringUInt64,[ToString.mk, UInt64, ToString.toString, Nat, instToStringNat, UInt64.toNat]]
[Acc.noConfusionType,[]]
[OfScientific.ofScientific,[]]
[List.take,[List, Nat.succ, List.nil, List.cons, PProd.fst, PUnit, PProd]]
[Nat.forRevM.loop,[Unit, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd]]
[Lean.Parser.Tactic.generalizeArg,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat]]
[IO.Process.Child.stdout,[]]
[Substring.get,[Char, String.get, HAdd.hAdd, String.Pos, instHAdd, instAddNat]]
[boolToSort,[CoeSort.mk, Bool, Eq, Bool.true]]
[instDecidableIff.proof_3,[Iff.mpr]]
[String.Iterator.setCurr,[String.Iterator, String.Iterator.mk, String.set]]
[List.mapTRAux_eq,[Eq, List, List.mapTRAux, HAppend.hAppend, instHAppend, List.instAppendList, List.reverse, List.map, of_eq_true, List.nil, Eq.trans, True, congrArg, List.append_nil, eq_self, Eq.mpr, List.cons, Eq.refl, List.reverse_cons, List.append_assoc, rfl]]
[Ne.intro,[]]
[instReprAtomString,[ReprAtom.mk, String]]
[PSum.inl.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[ExceptT.pure,[ExceptT.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, Except, Except.ok]]
[tacticFunext__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[UInt64.decEq.proof_1,[Fin, UInt64.size, Eq, UInt64, UInt64.mk, rfl]]
[WellFounded.recursion,[WellFounded.apply]]
[stx!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
[Nat.foldRevM,[Nat.foldRevM.loop]]
[Task.noConfusionType,[]]
[PSum.inr.injEq,[Eq.propIntro, Eq, PSum, PSum.inr, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Quotient.recOnSubsingleton₂.proof_2,[]]
[Nat.le.intro,[Nat, HAdd.hAdd, instHAdd, instAddNat, LE.le, instLENat, Nat.le_add_right]]
[EStateM.Result.ok.inj,[And, Eq, EStateM.Result.ok, And.intro]]
[Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1,[Nat.lt_trans]]
[fix,[fixCore1, arbitrary]]
[IO.FS.instOrdSystemTime,[Ord.mk, IO.FS.SystemTime, IO.FS.SystemTime.mk, Ordering, Unit.unit, Ord.compare, Int, instOrdInt, Ordering.lt, Ordering.gt, UInt32, instOrdUInt32, Ordering.eq]]
[Lean.Macro.Methods.resolveGlobalName,[]]
[Classical.typeDecidable.proof_1,[absurd, Nonempty, False, Nonempty.intro]]
[PSigma.fst,[]]
[Subarray.foldrM,[Array.foldrM, Subarray.as, Subarray.stop, Subarray.start]]
[instToStringSubtype,[ToString.mk, Subtype, ToString.toString, Subtype.val]]
[Array.back?,[Array.get?, HSub.hSub, Nat, instHSub, instSubNat, Array.size, OfNat.ofNat, instOfNatNat]]
[Lean.mkIdentFrom,[Lean.Syntax.ident, Lean.SourceInfo.fromRef, String.toSubstring, ToString.toString, Lean.Name, Lean.Name.instToStringName, List.nil, Prod, List, String]]
[Std.Format.nest.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Int, SizeOf.mk, instSizeOfNat, Std.Format, String, List, Char, UInt32, Fin, UInt32.size, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone]]
[Lean.Syntax.isLit?,[Lean.Syntax.missing, Lean.Syntax.atom, Lean.Syntax.ident, Option, String, ite, Eq, Bool, and, BEq.beq, Lean.SyntaxNodeKind, Lean.Name.instBEqName, Nat, instBEq, instDecidableEqNat, Array.size, Lean.Syntax, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Lean.Syntax.node, Array.get!, Lean.instInhabitedSyntax, Option.some, Option.none]]
[Lean.mkSepArray,[Bind.bind, Id, Monad.toBind, Id.instMonadId, MProd, Array, Lean.Syntax, Nat, ForIn.forIn, Array.instForInArray, MProd.mk, ite, ForInStep, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, Nat.decLt, PUnit, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit]]
[UInt8.val,[]]
[or_self,[propext, Or, Iff.intro, Or.inl]]
[Std.termF!_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[PointedType.val,[]]
[Lean.mkCIdentFromRef,[Bind.bind, Monad.toBind, Lean.Syntax, Lean.MonadRef.getRef, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.mkCIdentFrom]]
[decide_eq_true,[Eq, Bool, Decidable.decide, Bool.true, rfl, Decidable.isTrue, absurd, Decidable.isFalse]]
[Array.insertionSort,[OfNat.ofNat, Nat, instOfNatNat, Array.size, Array.insertionSort.traverse, Array.insertionSort.swapLoop]]
[String.toNat!,[ite, Nat, Eq, Bool, String.isNat, Bool.true, instDecidableEqBool, String.foldl, HAdd.hAdd, instHAdd, instAddNat, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Char.toNat, Char.ofNat, panicWithPosWithDecl, instInhabitedNat]]
[IO.ofExcept,[IO, Pure.pure, Applicative.toPure, Monad.toApplicative, instMonadEIO, IO.Error, MonadExcept.throw, instMonadExcept, instMonadExceptOfEIO, IO.userError, ToString.toString]]
[Id.bind_eq,[rfl, Id, Bind.bind, Monad.toBind, Id.instMonadId]]
[ExceptCpsT.runCatch_bind_throw,[rfl, ExceptCpsT.runCatch, Bind.bind, ExceptCpsT, Monad.toBind, ExceptCpsT.instMonadExceptCpsT, MonadExcept.throw, instMonadExcept, ExceptCpsT.instMonadExceptOfExceptCpsT]]
[inferInstance,[]]
[instMonadControlReaderT,[MonadControl.mk, ReaderT, id]]
[Lean.Parser.Tactic.tacticHave_,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
[Except.noConfusionType,[]]
[Lean.Parser.Tactic.split,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.location]]
[Option.map_id,[funext, Option, Option.map, id, Unit.unit, Eq, rfl, Option.none, Option.some]]
[instSubFloat,[Sub.mk, Float, Float.sub]]
[Subtype.instDecidableEqSubtype,[Decidable, Eq, Subtype, Subtype.mk, dite, Decidable.isTrue, Subtype.instDecidableEqSubtype.proof_1, Decidable.isFalse, Subtype.instDecidableEqSubtype.proof_2]]
[Fin.shiftRight,[Fin.mk, Fin, HMod.hMod, Nat, instHMod, Nat.instModNat, HShiftRight.hShiftRight, instHShiftRight, Nat.instShiftRightNat, Fin.shiftRight.proof_1]]
[String.extract,[String, ite, GE.ge, String.Pos, instLENat, Nat.decLe, String.mk, List.nil, Char, List, List.cons, Eq, instDecidableEqNat, PProd.fst, PUnit, PProd, HAdd.hAdd, Nat, instHAdd, instAddNat, String.csize, OfNat.ofNat, instOfNatNat]]
[RandomGen.next,[]]
[instLTFin,[LT.mk, Fin, LT.lt, Nat, instLTNat, Fin.val]]
[Array.filterM,[Array.foldlM, Array, Bind.bind, Monad.toBind, Bool, ite, Eq, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.push, List.toArray, List.nil]]
[instDecidableEqBool.proof_1,[False, Bool.false, Bool.true]]
[UInt8.mul,[UInt8.mk, HMul.hMul, Fin, UInt8.size, instHMul, Fin.instMulFin, UInt8.val]]
[EStateM.fromStateM,[EStateM.Result, StateT.run, Id, EStateM.Result.ok]]
[Lean.Macro.addMacroScope,[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Name, MonadReader.read, instMonadReader, instMonadReaderOfReaderT, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.addMacroScope, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope]]
[Int.decEq.proof_4,[False, Int.negSucc, absurd, Eq, Nat]]
[implies_congr_ctx,[propext, Iff.intro]]
[List.removeAll,[List.filter, List.notElem]]
[instLENat,[LE.mk, Nat, Nat.le]]
[seqRight_eq_bind,[Eq.mpr, Eq, SeqRight.seqRight, Applicative.toSeqRight, Monad.toApplicative, Bind.bind, Monad.toBind, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const, id, Eq.refl, LawfulApplicative.seqRight_eq, LawfulMonad.toLawfulApplicative, of_eq_true, Eq.trans, True, congrFun, congrArg, Pure.pure, Applicative.toPure, map_eq_pure_bind, seq_eq_bind_map, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, id_eq, bind_pure, eq_self]]
[PSigma.SkipLeft,[PSigma.RevLex, emptyRelation]]
[unexpandExists,[ite, Lean.PrettyPrinter.UnexpandM, Lean.Syntax, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.matchesNull, OfNat.ofNat, Nat, instOfNatNat, cond, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
[invImage.proof_1,[InvImage.wf, WellFoundedRelation.rel, WellFoundedRelation.wf]]
[Task.Priority.max,[OfNat.ofNat, Task.Priority, instOfNatNat]]
[Int.decEq,[Int.ofNat, Int.negSucc, Decidable, Eq, Int, Nat, decEq, instDecidableEqNat, Decidable.isTrue, Int.decEq.proof_1, Decidable.isFalse, Int.decEq.proof_2, Int.decEq.proof_3, Int.decEq.proof_4, Int.decEq.proof_5, Int.decEq.proof_6]]
[Nat.pos_pow_of_pos,[Nat.pow_le_pow_of_le_right, OfNat.ofNat, Nat, instOfNatNat, Nat.zero_le]]
[Iff.trans,[Iff.intro, Iff.mp, Iff.mpr]]
[Option.some.inj,[Eq, Option.some]]
[Lean.Meta.instInhabitedTransparencyMode,[Inhabited.mk, Lean.Meta.TransparencyMode, Lean.Meta.TransparencyMode.all]]
[StateCpsT.run_eq,[rfl, Prod, StateCpsT.run]]
[Ne.irrefl,[rfl]]
[noConfusionEnum,[dite, noConfusionTypeEnum, Eq, cast, noConfusionEnum.proof_1, False.elim, noConfusionEnum.proof_2]]
[Nat.le_of_succ_le_succ,[Nat.pred_le_pred, Nat.succ]]
[OrElse.orElse,[]]
[Quotient.inductionOn₂,[Quotient.ind, Quotient.mk]]
[instDecidableEqSum.proof_5,[False, Sum.inr, Sum.inl]]
[IO.Error.mkNoFileOrDirectory,[IO.Error.noFileOrDirectory]]
[IO.Error.unsatisfiedConstraints.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.unsatisfiedConstraints, And, UInt32, String, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[IO.FS.Stream.putStrLn,[IO.FS.Stream.putStr, String.push, Char.ofNat]]
[Sum.inl.injEq,[Eq.propIntro, Eq, Sum, Sum.inl, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Fin.instXorFin,[Xor.mk, Fin, Fin.xor]]
[instShiftLeftUInt16,[ShiftLeft.mk, UInt16, UInt16.shiftLeft]]
[Lean.Meta.TransparencyMode.reducible.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[iff_false,[propext, Iff, False, Not, Iff.intro, Iff.mp, False.elim]]
[Lean.Parser.Tactic.Conv.enterArg,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const]]
[String.takeRightWhile,[Substring.toString, Substring.takeRightWhile, String.toSubstring]]
[instInhabitedForInStep,[Inhabited.mk, ForInStep, ForInStep.done, arbitrary]]
[panicWithPos,[panic, HAppend.hAppend, String, instHAppend, String.instAppendString, ToString.toString, Nat, instToStringNat]]
[instDecidableEqBool,[Bool.false, Unit.unit, Bool.true, Decidable, Eq, Bool, Decidable.isTrue, rfl, Decidable.isFalse, instDecidableEqBool.proof_1, instDecidableEqBool.proof_2]]
[unexpandSubtype,[ite, Lean.PrettyPrinter.UnexpandM, Lean.Syntax, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.matchesNull, OfNat.ofNat, Nat, instOfNatNat, cond, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
[Array.mapIdxM.map,[Array, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[Except.error.injEq,[Eq.propIntro, Eq, Except, Except.error, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Nat.le_of_lt,[Nat.le_of_succ_le]]
[Lean.Macro.Context.mainModule,[]]
[EStateM.seqRight,[EStateM.Result, Unit.unit, EStateM.Result.error]]
[fix4,[fixCore4, arbitrary]]
[HAppend.noConfusionType,[]]
[Substring.takeRight,[Substring.mk, Substring, HAdd.hAdd, String.Pos, instHAdd, instAddNat, Substring.prevn, Substring.bsize]]
[map_congr,[of_eq_true, Eq, Functor.map, Eq.trans, True, congrFun, congrArg, funext, eq_self]]
[Int.decEq.proof_5,[False, Int.ofNat, Int.negSucc]]
[Nat.repeat,[Nat.repeat.loop]]
[List.append,[List, List.cons, PProd.fst, PUnit, PProd]]
[instDecidableAnd,[Decidable, And, Decidable.isTrue, And.intro, Decidable.isFalse, instDecidableAnd.proof_1, instDecidableAnd.proof_2]]
[Int.negSucc.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat]]
[USize.decEq.proof_1,[Fin, USize.size, Eq, USize, USize.mk, rfl]]
[Array.getIdx?,[Array.findIdx?, BEq.beq]]
[coeId,[CoeT.mk]]
[String.all,[not, String.any]]
[Fin.coeToNat,[Coe.mk, Fin, Nat, Fin.val]]
[PSigma.lex,[PSigma.lex.proof_1]]
[Nat.mul_succ,[rfl, Nat, HMul.hMul, instHMul, instMulNat, Nat.succ]]
[Quotient.liftOn,[Quot.liftOn, Setoid.r]]
[ToBool.noConfusionType,[]]
[Std.Format.MonadPrettyFormat.pushNewline,[]]
[EStateM.instMonadExceptOfEStateM,[MonadExceptOf.mk, EStateM, EStateM.throw, EStateM.tryCatch]]
[Nat.le.dest,[Exists, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.zero, Nat.succ, Exists.intro, OfNat.ofNat, instOfNatNat, rfl, Eq.symm, Nat.add_comm, absurd, LE.le, instLENat, Nat.not_succ_le_zero]]
[Array.findSomeRev?,[Id.run, Option, Array.findSomeRevM?, Id, Id.instMonadId]]
[Alternative.orElse,[]]
[Ordering.noConfusionType,[noConfusionTypeEnum, Ordering, Nat, instDecidableEqNat, Ordering.toCtorIdx]]
[dbgSleep,[Unit.unit]]
[List.foldrM,[Pure.pure, Applicative.toPure, Monad.toApplicative, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd]]
[instHSub,[HSub.mk, Sub.sub]]
[Lean.maxRecDepthErrorMessage,[]]
[DoResultPR.pure.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[String.toNat?,[ite, Option, Nat, Eq, Bool, String.isNat, Bool.true, instDecidableEqBool, Option.some, String.foldl, HAdd.hAdd, instHAdd, instAddNat, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Char.toNat, Char.ofNat, Option.none]]
[Lean.MacroM,[ReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State]]
[Nat.mul_le_mul,[Nat.le_trans, HMul.hMul, Nat, instHMul, instMulNat, Nat.mul_le_mul_right, Nat.mul_le_mul_left]]
[StateCpsT.runK_set,[rfl, StateCpsT.runK, PUnit, MonadStateOf.set, StateCpsT, StateCpsT.instMonadStateOfStateCpsT]]
[Lean.Parser.Tactic.Conv.nestedTacticCore,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[instMonadWithReaderOf,[MonadWithReaderOf.mk, MonadFunctorT.monadMap, instMonadFunctorT, monadFunctorRefl, withTheReader]]
[UInt8.decLe,[UInt8.mk, Decidable, LE.le, UInt8, instLEUInt8, inferInstanceAs, Fin, UInt8.size, instLEFin, Fin.decLe]]
[Lean.Syntax.isToken,[Lean.Syntax.missing, Lean.Syntax.node, Lean.Syntax.ident, Bool, BEq.beq, String, instBEq, instDecidableEqString, String.trim, Bool.false]]
[instRandomGenStdGen,[RandomGen.mk, StdGen, stdRange, stdNext, stdSplit]]
[Nat.lt.base,[Nat.lt.base.proof_1]]
[instModUSize,[Mod.mk, USize, USize.mod]]
[HEq.rfl.proof_1,[HEq.refl]]
[false_or,[propext, Or, False, Iff.intro, False.elim, Or.inr]]
[Nat.zero_le,[LE.le, Nat, instLENat, OfNat.ofNat, instOfNatNat, Unit.unit, Nat.le.refl, Nat.le.step, PProd.fst, PUnit, PProd]]
[instDecidableLe_1,[UInt8.decLe]]
[Int.ofNat.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat]]
[decEq,[]]
[LawfulApplicative.toLawfulFunctor,[]]
[EStateM.tryCatch,[EStateM.Result.ok, EStateM.Result, EStateM.Backtrackable.restore]]
[Array.instAppendArray,[Append.mk, Array, Array.append]]
[not_not_intro,[]]
[unexpandListCons,[ite, Lean.PrettyPrinter.UnexpandM, Lean.Syntax, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.matchesNull, OfNat.ofNat, Nat, instOfNatNat, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Array.append, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
[StateT,[Prod]]
[Array.indexOf?,[Array.indexOfAux, OfNat.ofNat, Nat, instOfNatNat]]
[String.isEmpty,[BEq.beq, Nat, instBEq, instDecidableEqNat, String.bsize, OfNat.ofNat, instOfNatNat]]
[List.mapTRAux,[List, List.reverse, PProd.fst, PUnit, PProd, List.cons]]
[Classical.decidableInhabited,[Inhabited.mk, Decidable, inferInstance, Classical.propDecidable]]
[Lean.Meta.TransparencyMode.toCtorIdx,[Nat, OfNat.ofNat, instOfNatNat]]
[instNonempty.proof_1,[Nonempty.intro, arbitrary]]
[UInt16.modn,[UInt16.mk, HMod.hMod, Fin, UInt16.size, Nat, Fin.instHModFinNatFin, UInt16.val]]
[IO.FS.Stream.getLine,[]]
[Fin.ne_of_val_ne,[absurd, Eq, Nat, Fin.val, False, Fin.val_eq_of_eq]]
[IO.FS.FileType.noConfusion,[noConfusionEnum, IO.FS.FileType, Nat, instDecidableEqNat, IO.FS.FileType.toCtorIdx]]
[coeSort,[CoeSort.coe]]
[List.toStringAux,[String, Bool.false, Bool.true, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString, PProd.fst, PUnit, PProd]]
[instHAdd,[HAdd.mk, Add.add]]
[Applicative.toFunctor,[]]
[inferInstanceAs,[]]
[Lean.Parser.Tactic.casesTarget,[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat]]
[Lean.Parser.Tactic.delta,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.Parser.Tactic.location]]
[Lean.NameGenerator.mkChild,[Prod.mk, Lean.NameGenerator, Lean.NameGenerator.mk, Lean.Name.mkNum, Lean.NameGenerator.namePrefix, Lean.NameGenerator.idx, OfNat.ofNat, Nat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat]]
[Lean.MonadQuotation.noConfusionType,[]]
[LT.lt,[]]
[RandomGen.noConfusionType,[]]
[Substring.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, String, SizeOf.mk, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar, String.Pos]]
[ExceptCpsT,[]]
[Substring.take,[Substring.mk, Substring, HAdd.hAdd, String.Pos, instHAdd, instAddNat, Substring.nextn, OfNat.ofNat, instOfNatNat]]
[«term_<|_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[instOrElseEIO,[OrElse.mk, EIO, MonadExcept.orElse, instMonadExcept, instMonadExceptOfEIO]]
[Nat.foldM.loop,[Pure.pure, Applicative.toPure, Monad.toApplicative, Bind.bind, Monad.toBind, HSub.hSub, Nat, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, PProd.fst, PUnit, PProd]]
[StateT.instMonadExceptOfStateT,[MonadExceptOf.mk, StateT, Function.comp, StateT.lift, throwThe, tryCatchThe, Prod]]
[let_congr,[Eq]]
[Lean.isIdEndEscape,[Decidable.decide, Eq, Char, Lean.idEndEscape, instDecidableEqChar]]
[rawNatLit,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
[Array.findRev?,[Id.run, Option, Array.findRevM?, Id, Id.instMonadId]]
[instToStringDecidable,[ToString.mk, Decidable, String]]
[Substring.next,[String.Pos, ite, Eq, instDecidableEqNat, HSub.hSub, instHSub, instSubNat, String.next]]
[ByteArray.copySlice,[ByteArray.mk, HAppend.hAppend, Array, UInt8, instHAppend, Array.instAppendArray, Array.extract, ByteArray.data, OfNat.ofNat, Nat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Array.size]]
[Std.Format.groupEx,[Std.Format.group, Std.Format.FlattenBehavior.allOrNone]]
[Id.instLawfulMonadId,[Id.instLawfulMonadId.proof_1]]
[instInhabitedPUnit,[Inhabited.mk, PUnit, PUnit.unit]]
[UInt64.shiftLeft,[UInt64.mk, HShiftLeft.hShiftLeft, Fin, UInt64.size, instHShiftLeft, Fin.instShiftLeftFin, UInt64.val, UInt64.modn, OfNat.ofNat, Nat, instOfNatNat]]
[UInt8.decLt,[UInt8.mk, Decidable, LT.lt, UInt8, instLTUInt8, inferInstanceAs, Fin, UInt8.size, instLTFin, Fin.decLt]]
[ToBool.toBool,[]]
[StateT.run',[Functor.map, Prod, Prod.fst]]
[Nat.mod_self,[Eq.mpr, Eq, Nat, HMod.hMod, instHMod, Nat.instModNat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Eq.refl, Nat.mod_eq_sub_mod, Nat.le_refl, Nat.sub_self, Nat.zero_mod, rfl]]
[Lean.Parser.Tactic.Conv.convDone,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[Lean.Macro.State.macroScope,[]]
[ExceptT.run_throw,[rfl, Except, ExceptT.run, MonadExcept.throw, ExceptT, instMonadExcept, instMonadExceptOfExceptT_1]]
[Int.lt,[LE.le, Int, Int.instLEInt, HAdd.hAdd, instHAdd, Int.instAddInt, OfNat.ofNat, hasOfNatOfCoe, Nat, instCoeNatInt, instOfNatNat]]
[Lean.Parser.Tactic.Conv.paren,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.Conv.convSeq, Lean.ParserDescr.symbol]]
[And.right,[]]
[Std.Format.MonadPrettyFormat.startTag,[]]
[Id.map_eq,[rfl, Id, Functor.map, Applicative.toFunctor, Monad.toApplicative, Id.instMonadId]]
[Lean.Syntax.missing.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[List.length_dropLast,[Eq, Nat, List.length, List.dropLast, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, Unit.unit, List.cons, rfl, List.nil]]
[Lean.Meta.Simp.Config.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat, Bool, SizeOf.mk]]
[IO.Error.toString,[String, IO.Error.alreadyExists, IO.Error.invalidArgument, IO.Error.permissionDenied, IO.Error.resourceExhausted, IO.Error.inappropriateType, IO.Error.noSuchThing, Unit.unit, IO.Error.fopenErrorToString, Option.some, IO.Error.otherErrorToString, Option.none]]
[Quotient.recOnSubsingleton,[Quot.recOnSubsingleton, Setoid.r]]
[System.SearchPath.parse,[List.map, String, System.FilePath, System.FilePath.mk, String.split, BEq.beq, Char, instBEq, instDecidableEqChar, System.SearchPath.separator]]
[StateT.run_pure,[rfl, Prod, StateT.run, Pure.pure, StateT, Applicative.toPure, Monad.toApplicative, StateT.instMonadStateT]]
[IO.FS.FileType.noConfusionType,[noConfusionTypeEnum, IO.FS.FileType, Nat, instDecidableEqNat, IO.FS.FileType.toCtorIdx]]
[IO.Process.StdioConfig.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, IO.Process.Stdio, SizeOf.mk]]
[Std.Format.FlattenBehavior.noConfusion,[noConfusionEnum, Std.Format.FlattenBehavior, Nat, instDecidableEqNat, Std.Format.FlattenBehavior.toCtorIdx]]
[Array.size_mkArray,[List.length_replicate]]
[Array.back,[Array.get!, HSub.hSub, Nat, instHSub, instSubNat, Array.size, OfNat.ofNat, instOfNatNat]]
[UInt16.ofNat,[UInt16.mk, Fin.ofNat, OfNat.ofNat, Nat, instOfNatNat]]
[UInt64.le,[LE.le, Fin, UInt64.size, instLEFin, UInt64.val]]
[IO.Process.SpawnArgs.args,[]]
[IO.FS.Metadata.mk.injEq,[Eq.propIntro, Eq, IO.FS.Metadata, IO.FS.Metadata.mk, And, IO.FS.SystemTime, UInt64, IO.FS.FileType, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[IO.FS.FileType.other.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[Add.add,[]]
[HOrElse.noConfusionType,[]]
[StateT.lift,[Bind.bind, Monad.toBind, Prod, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk]]
[Nat.zero_mod,[Eq.mpr, Eq, Nat, HMod.hMod, instHMod, Nat.instModNat, OfNat.ofNat, instOfNatNat, ite, And, LT.lt, instLTNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HSub.hSub, instHSub, instSubNat, Eq.refl, Nat.mod_eq]]
[Lean.Syntax.decodeNameLit,[ite, Option, Lean.Name, Eq, Bool, BEq.beq, Char, instBEq, instDecidableEqChar, String.get, OfNat.ofNat, String.Pos, instOfNatNat, Char.ofNat, Bool.true, instDecidableEqBool, Substring, Unit.unit, List.cons, Substring.drop, String.toSubstring, Nat, List.nil, Option.none, Option.some, List.foldr, Lean.isIdBeginEscape, String.front, Lean.Name.mkStr, String.dropRight, String.drop, Lean.Name.anonymous]]
[System.FilePath.withExtension,[String, Unit.unit, System.FilePath, System.FilePath.fileStem, System.FilePath.withFileName, ite, Eq, Bool, String.isEmpty, Bool.true, instDecidableEqBool, HAppend.hAppend, instHAppend, String.instAppendString]]
[Classical.epsilon_singleton,[Classical.epsilon_spec, Eq, Exists.intro, rfl]]
[PProd.mk.injEq,[Eq.propIntro, Eq, PProd, PProd.mk, And, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[MonadExcept.throw,[]]
[UInt8.lor,[UInt8.mk, Fin.lor, UInt8.size, UInt8.val]]
[Subarray.all,[Id.run, Bool, Subarray.allM, Id, Id.instMonadId]]
[List.eraseDupsAux,[List, List.reverse, Unit.unit, List.elem, PProd.fst, PUnit, PProd, List.cons]]
[Nat.mul_assoc,[Eq, Nat, HMul.hMul, instHMul, instMulNat, rfl, OfNat.ofNat, instOfNatNat]]
[ST.Ref.ref,[]]
[eq_self,[propext, Eq, True, Iff.intro, trivial, rfl]]
[UInt16.size,[OfNat.ofNat, Nat, instOfNatNat]]
[Thunk.map,[Thunk.mk, Thunk.get]]
[Nat.not_lt_zero,[Nat.not_succ_le_zero]]
[Std.instToFormatString,[Std.ToFormat.mk, String, Std.Format.text]]
[Lean.Syntax.isCharLit?,[String, Option.none, Option, Char, Lean.Syntax.isLit?, Lean.charLitKind, Lean.Syntax.decodeCharLit]]
[Neg.neg,[]]
[Sum.inhabitedLeft,[Inhabited.mk, Sum, Sum.inl, arbitrary]]
[PSigma.lexAccessible.proof_1,[Acc, PSigma, PSigma.Lex, PSigma.mk, Acc.intro, PSigma.Lex.left, Eq.symm, eq_of_heq, PSigma.Lex.right, Eq.refl, HEq.refl, WellFounded.apply]]
[Array.mapIdxM.map.proof_2,[Eq.mpr, Eq, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Eq.refl, Eq.symm, Nat.add_comm, Nat.add_assoc, rfl]]
[OrOp.noConfusionType,[]]
[Nat.add_le_add,[Nat.le_trans, HAdd.hAdd, Nat, instHAdd, instAddNat, Nat.add_le_add_right, Nat.add_le_add_left]]
[HEq.symm,[HEq.ndrecOn, HEq, HEq.refl]]
[List.filterMapM.loop,[List, Pure.pure, Applicative.toPure, Monad.toApplicative, Bind.bind, Monad.toBind, Option, Unit.unit, PProd.fst, PUnit, PProd, List.cons]]
[ex_of_PSigma,[Exists, Exists.intro]]
[instToStringInt,[ToString.mk, Int, String, ToString.toString, Nat, instToStringNat, HAppend.hAppend, instHAppend, String.instAppendString, Nat.succ]]
[coeBase,[CoeTC.mk, coeB]]
[List.instBEqList,[BEq.mk, List, List.beq]]
[Nat.ble,[Bool, Nat.zero, Unit.unit, Nat.succ, Bool.true, Bool.false, PProd.fst, PUnit, PProd]]
[instLTProd,[LT.mk, Prod, Or, LT.lt, Prod.fst, And, Eq, Prod.snd]]
[UInt8.shiftLeft,[UInt8.mk, HShiftLeft.hShiftLeft, Fin, UInt8.size, instHShiftLeft, Fin.instShiftLeftFin, UInt8.val, UInt8.modn, OfNat.ofNat, Nat, instOfNatNat]]
[Lean.instMonadRef,[Lean.MonadRef.mk, liftM, instMonadLiftT, instMonadLiftT_1, Lean.Syntax, Lean.MonadRef.getRef, MonadFunctorT.monadMap, instMonadFunctorT, monadFunctorRefl, Lean.MonadRef.withRef]]
[instDecidableAnd.proof_1,[And.right]]
[instOrOpUInt32,[OrOp.mk, UInt32, UInt32.lor]]
[Array.findIdxM?,[Bind.bind, Monad.toBind, MProd, Option, Nat, ForIn.forIn, Array, Array.instForInArray, MProd.mk, Option.none, Bool, ForInStep, ite, Eq, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, ForInStep.done, Option.some, PUnit, PUnit.unit, Unit.unit, MProd.fst]]
[instToFormat,[Std.ToFormat.mk, Function.comp, String, Std.Format, Std.Format.text, ToString.toString]]
[instAndOpUInt16,[AndOp.mk, UInt16, UInt16.land]]
[IO.Ref,[ST.Ref, IO.RealWorld]]
[String.Iterator.toString,[String]]
[Int.decEq.proof_2,[False, Int.ofNat, absurd, Eq, Nat]]
[IO.FS.Stream.Buffer.mk.inj,[And, Eq, ByteArray, Nat, IO.FS.Stream.Buffer.mk, And.intro]]
[Nat.mul_left_comm,[Eq.mpr, Eq, Nat, HMul.hMul, instHMul, instMulNat, Eq.refl, Eq.symm, Nat.mul_assoc, Nat.mul_comm, rfl]]
[Iff.comm,[Iff.intro, Iff, Iff.symm]]
[Fin.mk.injEq,[Eq.propIntro, Eq, Fin, Fin.mk, Nat, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Subarray.toArray,[Array.ofSubarray]]
[OptionT.instMonadExceptOfOptionT,[MonadExceptOf.mk, OptionT, OptionT.mk, throwThe, Option, tryCatchThe]]
[Lean.Parser.Tactic.Conv.convArgs,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[IO.Error.resourceExhausted.injEq,[Eq.propIntro, Eq, IO.Error, IO.Error.resourceExhausted, And, Option, String, UInt32, And.intro, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
[Quot.hrecOn,[Quot.recOn, Quot.hrecOn.proof_1]]
[instReprProd,[Repr.mk, Prod, Std.Format, Std.Format.bracket, Std.Format.joinSep, Std.instToFormatFormat, List.reverse, ReprTuple.reprTuple, List.cons, repr, List.nil, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, Std.Format.line]]
[Lean.Syntax.splitNameLit,[List.reverse, Substring, List.nil]]
[control,[controlAt]]
[Lean.Syntax.instCoeArraySyntaxSepArray,[Coe.mk, Array, Lean.Syntax, Lean.Syntax.SepArray, Lean.Syntax.SepArray.ofElems]]
[eq_false_of_ne_true,[Eq, Bool, Bool.false, False.elim, Bool.true, rfl]]
[«term_>>>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[IO.FS.DirEntry.root,[]]
[instDecidableDite,[Decidable, dite]]
[Lean.Name.getRoot,[Lean.Name, Unit.unit, Lean.Name.str, Lean.Name.anonymous, Lean.Name.num, PProd.fst, PUnit, PProd]]
[Lean.extractMacroScopes,[Unit.unit, Lean.MacroScopesView, Lean.Name.hasMacroScopes, Lean.Name.anonymous, PProd.fst, PUnit, PProd, List.cons, Lean.MacroScope, Lean.Name.str, Lean.Name.num, BEq.beq, String, instBEq, instDecidableEqString, Lean.MacroScopesView.mk, Lean.Name, Lean.Name.mkStr, Lean.Name.mkNum, panic, Lean.instInhabitedName, Lean.instInhabitedMacroScopesView, List.nil]]
[Substring.nextn,[String.Pos, PProd.fst, PUnit, PProd, Substring.next]]
[ExceptT.instMonadLiftExceptT,[MonadLift.mk, ExceptT, ExceptT.lift]]
[Prod.lt_def,[rfl, LT.lt, Prod, instLTProd]]
[Lean.Meta.Simp.ConfigCtx.mk.inj,[Eq, Lean.Meta.Simp.Config, Lean.Meta.Simp.ConfigCtx.mk]]
[instMonadControlExceptT,[MonadControl.mk, ExceptT, Except, liftM, instMonadLiftT, ExceptT.instMonadLiftExceptT, instMonadLiftT_1, ExceptT.run]]
[Fin.lor,[Fin.mk, Fin, HMod.hMod, Nat, instHMod, Nat.instModNat, Nat.lor, Fin.lor.proof_1]]
[List.getLast.proof_1,[rfl, List, List.nil]]
[getModify,[MonadState.modifyGet, Prod.mk]]
[Lean.Parser.Tactic.injections,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[StateT.failure,[Alternative.failure, Prod]]
[Fin.div,[Fin.mk, Fin, HMod.hMod, Nat, instHMod, Nat.instModNat, HDiv.hDiv, instHDiv, Nat.instDivNat, Fin.div.proof_1]]
[UInt32.land,[UInt32.mk, Fin.land, UInt32.size, UInt32.val]]
[ByteArray.toUInt64BE!,[ite, UInt64, Eq, Bool, BEq.beq, Nat, instBEq, instDecidableEqNat, ByteArray.size, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, HOr.hOr, instHOr, instOrOpUInt64, HShiftLeft.hShiftLeft, instHShiftLeft, instShiftLeftUInt64, UInt8.toUInt64, ByteArray.get!, instOfNatUInt64, panicWithPosWithDecl, instInhabitedUInt64, HAppend.hAppend, String, instHAppend, String.instAppendString]]
[UInt32.ofNat,[UInt32.mk, Fin.ofNat, OfNat.ofNat, Nat, instOfNatNat]]
[Char.instDecidableLt,[UInt32.decLt, Char.val]]
[Nat.sub_le,[LE.le, Nat, instLENat, HSub.hSub, instHSub, instSubNat, Nat.le_refl, OfNat.ofNat, instOfNatNat, Nat.le_trans, Nat.pred, Nat.pred_le]]
[ReaderT.instAlternativeReaderT,[Alternative.mk, ReaderT, Monad.toApplicative, ReaderT.instMonadReaderT, ReaderT.failure, ReaderT.orElse]]
[Lean.Meta.Simp.Config.maxDischargeDepth,[]]
[BEq.noConfusionType,[]]
[min,[ite, LE.le]]
[false_iff,[propext, Iff, False, Not, Iff.intro, Iff.mpr, False.elim]]
[instOrdChar,[Ord.mk, Char, compareOfLessAndEq, Char.instLTChar, Char.instDecidableLt, instDecidableEqChar]]
[Lean.Meta.instBEqTransparencyMode,[BEq.mk, Lean.Meta.TransparencyMode, BEq.beq, Nat, instBEq, instDecidableEqNat, Lean.Meta.TransparencyMode.toCtorIdx]]
[Float.mk.inj,[Eq, FloatSpec.float, floatSpec, Float.mk]]
[Hashable.noConfusionType,[]]
[Ordering.lt.sizeOf_spec,[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
[repr,[Repr.reprPrec, OfNat.ofNat, Nat, instOfNatNat]]
[UInt32.xor,[UInt32.mk, Fin.xor, UInt32.size, UInt32.val]]
[instReprOption,[Repr.mk, Option, Std.Format, Std.Format.text, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, reprArg]]
[System.Platform.getNumBits.proof_1,[Or.inr, Eq, Nat, OfNat.ofNat, instOfNatNat, rfl]]
[Function.const,[]]
[List.hasDecidableLt.proof_4,[List.cons, List.nil, List, LT.lt, List.instLTList, List.lt.head, Eq.symm, eq_of_heq, List.lt.tail, Eq.refl, HEq.refl, False, absurd, List.lt]]
[Int.instSubInt,[Sub.mk, Int, Int.sub]]
[eqRec_heq,[Eq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl, HEq]]
[instMonadExceptOfExceptT_1,[MonadExceptOf.mk, ExceptT, ExceptT.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, Except, Except.error, ExceptT.tryCatch]]
[Option.isNone,[Unit.unit, Bool, Bool.false, Bool.true]]
[Array.instToStringArray,[ToString.mk, Array, HAppend.hAppend, String, instHAppend, String.instAppendString, ToString.toString, List, instToStringList, Array.toList]]
[SeqRight.noConfusionType,[]]
[coeDecidableEq,[inferInstanceAs, Decidable, Eq, Bool, Bool.true, instDecidableEqBool]]
[Lean.NameGenerator.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Lean.Name, instSizeOfName, instSizeOfNat]]
[Lean.Syntax.mkScientificLit,[Lean.Syntax.mkLit, Lean.scientificLitKind]]
[instInhabitedArrow,[Inhabited.mk, arbitrary]]
[UInt8.add,[UInt8.mk, HAdd.hAdd, Fin, UInt8.size, instHAdd, Fin.instAddFin, UInt8.val]]
[UInt8.complement,[HSub.hSub, UInt8, instHSub, instSubUInt8, OfNat.ofNat, instOfNatUInt8, HAdd.hAdd, instHAdd, instAddUInt8]]
[Nat.instDivNat,[Div.mk, Nat, Nat.div]]
[«term_<&&>_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[String.capitalize,[String.set, OfNat.ofNat, String.Pos, instOfNatNat, Char.toUpper, String.get]]
[instMonadExceptOfEIO,[inferInstanceAs, MonadExceptOf, EStateM, IO.RealWorld, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable]]
[Thunk.bind,[Thunk.mk, Thunk.get]]
[instReprPUnit,[Repr.mk, PUnit, Std.Format.text]]
[instCoeDep,[CoeDep.mk, coeFun]]
[Task.Priority.default,[OfNat.ofNat, Task.Priority, instOfNatNat]]
[Prod.rprod.proof_1,[Subrelation.wf, Prod, Prod.Lex, WellFoundedRelation.rel, Prod.RProd, WellFoundedRelation.wf, Prod.lex, Prod.RProdSubLex]]
[IO.FS.instReprMetadata,[Repr.mk, IO.FS.Metadata, Std.Format.bracket, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.nil, Std.Format.text, repr, IO.FS.SystemTime, IO.FS.instReprSystemTime, IO.FS.Metadata.accessed, Std.Format.line, IO.FS.Metadata.modified, UInt64, instReprUInt64, IO.FS.Metadata.byteSize, IO.FS.FileType, IO.FS.instReprFileType, IO.FS.Metadata.type]]
[Lean.instEvalIO,[Lean.Eval.mk, IO, Bind.bind, Monad.toBind, instMonadEIO, IO.Error, Unit, Unit.unit, Lean.Eval.eval, Bool.true]]
[Setoid.r,[]]
[List.getLast,[List.cons, absurd, Eq, List, List.nil, List.getLast.proof_1, PProd.fst, PUnit, PProd, List.getLast.proof_2]]
[Lean.Meta.Simp.ConfigCtx.toConfig,[]]
[termPrintln!__,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
[«term_|||_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[noConfusionEnum.proof_1,[Eq.symm, ite, Eq, if_pos]]
[Fin.instAndOpFin,[AndOp.mk, Fin, Fin.land]]
[Nat.succ_le_of_lt,[]]
[Nat.div.proof_1,[WellFoundedRelation.wf, Nat, measure, id]]
[StateCpsT.lift,[Bind.bind, Monad.toBind]]
[Lean.term_Matches_,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Lean.Module.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Lean.Syntax, SizeOf.mk, Lean.SyntaxNodeKind, instSizeOfName, Lean.SourceInfo, instSizeOf, String, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, UInt32.isValidChar, Substring, String.Pos, Lean.Name, Prod, Array]]
[ForInStep.noConfusionType,[]]
[List.intercalate,[List.join, List.intersperse, List]]
[instDecidableEqQuotient.proof_2,[absurd, HasEquiv.Equiv, instHasEquiv, False, Quotient.exact]]
[ExceptT.finally,[MonadFinally.mk, ExceptT, ExceptT.mk, Prod, Bind.bind, Monad.toBind, Except, MonadFinally.tryFinally', Option.none, Option.some, Except.error, Prod.mk, Except.ok, Pure.pure, Applicative.toPure, Monad.toApplicative]]
[«prec(_)»,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
[Lean.Syntax.decodeCharLit,[OptionM.run, Char, ite, OptionM, Eq, Bool, BEq.beq, instBEq, instDecidableEqChar, Char.ofNat, Bool.true, instDecidableEqBool, Bind.bind, Monad.toBind, OptionT.instMonadOptionT, Id, Id.instMonadId, Prod, String.Pos, Lean.Syntax.decodeQuotedChar, OfNat.ofNat, instOfNatNat, Pure.pure, Applicative.toPure, Alternative.toApplicative, OptionT.instAlternativeOptionT]]
[withPtrAddrUnsafe,[ptrAddrUnsafe]]
[Lean.interpolatedStrKind,[Lean.Name.mkStr, Lean.Name.anonymous]]
[unexpandEqRec,[ite, Lean.PrettyPrinter.UnexpandM, Lean.Syntax, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.matchesNull, OfNat.ofNat, Nat, instOfNatNat, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
[charToHex,[HAppend.hAppend, String, instHAppend, String.instAppendString, hexDigitRepr]]
[Quot.rec,[Quot, PSigma.fst, Quot.lift, PSigma, Quot.indep, Quot.indepCoherent, Quot.liftIndepPr1, PSigma.snd]]
[Array.get!,[Array.getD, arbitrary]]
[Iff.refl,[Iff.intro]]
[UInt8.lt,[LT.lt, Fin, UInt8.size, instLTFin, UInt8.val]]
[IO.Error.inappropriateType.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Option, String, SizeOf.mk, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar]]
[Array.size_swap,[]]
[Lean.instQuoteName,[Lean.Quote.mk, Lean.Name, List, String, Unit.unit, Lean.Syntax, OptionM, Pure.pure, OptionT, Id, Applicative.toPure, Alternative.toApplicative, OptionT.instAlternativeOptionT, Id.instMonadId, Bind.bind, Monad.toBind, OptionT.instMonadOptionT, Lean.Name.escapePart, PProd.fst, PUnit, PProd, List.cons, Option.none, List.nil, Lean.mkNode, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, Lean.Syntax.mkNameLit, HAppend.hAppend, instHAppend, String.instAppendString, String.intercalate, Lean.SourceInfo.none, Lean.mkCIdent, Lean.Syntax.mkCApp, Lean.Quote.quote, Lean.instQuoteString, Nat, Lean.instQuoteNat]]
[Lean.TrailingParserDescr,[Lean.ParserDescr]]
[Subarray.forInUnsafe,[USize.ofNat, Subarray.start, Subarray.forInUnsafe.loop]]
[instLEUInt64,[LE.mk, UInt64, UInt64.le]]
[Nat.pred_lt,[LT.lt, Nat, instLTNat, Nat.pred, absurd, Eq, Nat.zero, rfl, Nat.lt_succ_of_le, Nat.succ, Nat.le_refl]]
[Lean.Macro.instInhabitedMethods,[Inhabited.mk, Lean.Macro.Methods, Lean.Macro.Methods.mk, arbitrary, Lean.MacroM, Option, Lean.Syntax, instInhabitedDepArrow, instInhabitedReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, instInhabited, EStateM.instMonadEStateM, instInhabitedOption, Lean.Name, Lean.instInhabitedName, Bool, instInhabitedBool, List, Prod, String, instInhabitedList]]
[USize.lor,[USize.mk, Fin.lor, USize.size, USize.val]]
[tryCatchThe,[MonadExceptOf.tryCatch]]
[PNonScalar.noConfusionType,[]]
[instToBoolOption,[ToBool.mk, Option, Option.toBool]]
[Array.anyMUnsafe.any,[ite, Bool, Eq, BEq.beq, USize, instBEq, instDecidableEqUSize, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.false, Bind.bind, Monad.toBind, Array.uget, lcProof, LT.lt, Nat, instLTNat, USize.toNat, Array.size, Array.anyMUnsafe.any, HAdd.hAdd, instHAdd, instAddUSize, OfNat.ofNat, instOfNatUSize]]
[Substring.str,[]]
[Nat.add_right_comm,[Eq.mpr, Eq, Nat, HAdd.hAdd, instHAdd, instAddNat, Eq.refl, Nat.add_assoc, Nat.add_comm, Eq.symm, rfl]]
[Lean.mkAtom,[Lean.Syntax.atom, Lean.SourceInfo.none]]
[EIO.toIO,[EStateM.adaptExcept, IO.RealWorld, IO.Error]]
[IO.FS.DirEntry.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, System.FilePath, SizeOf.mk, String, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, instSizeOf, UInt32.isValidChar]]
[USize.mk.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Fin, USize.size, SizeOf.mk, instSizeOfNat, LT.lt, instLTNat, instSizeOf]]
[heq_of_eq_of_heq,[HEq.trans, heq_of_eq]]
[Int.subNatNat,[Unit.unit, Int, HSub.hSub, Nat, instHSub, instSubNat, Int.ofNat, Int.negSucc]]
[«term_×_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Std.Format.join,[List.foldl, Std.Format, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text]]
[Array.forInUnsafe.loop,[ite, LT.lt, USize, instLTUSize, instDecidableLt_4, Bind.bind, Monad.toBind, ForInStep, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.forInUnsafe.loop, HAdd.hAdd, instHAdd, instAddUSize, OfNat.ofNat, instOfNatUSize]]
[MonadReader.read,[]]
[List.le,[Not, LT.lt, List, List.instLTList]]
[Char.isValidUInt32,[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, And, Or.inr, UInt32.size, Nat.lt_trans, of_decide_eq_true, Nat.decLt, Eq.refl, Bool, Bool.true]]
[Quotient.lift₂.proof_1,[Setoid.refl]]
[UInt64.lor,[UInt64.mk, Fin.lor, UInt64.size, UInt64.val]]
[List.getLast?.proof_1,[False, List.cons, List.nil]]
[IO.FS.Stream.mk.inj,[And, Eq, IO, Bool, Unit, ByteArray, String, IO.FS.Stream.mk, And.intro]]
[StateCpsT.runK_monadLift,[rfl, StateCpsT.runK, MonadLiftT.monadLift, StateCpsT, instMonadLiftT, StateCpsT.instMonadLiftStateCpsT]]
[Task.Priority,[Nat]]
[Nat.le_antisymm,[Nat, LE.le, instLENat, Nat.le.refl, Eq.symm, eq_of_heq, Nat.succ, Nat.le.step, Eq.refl, HEq.refl, Eq, rfl, absurd, LT.lt, instLTNat, Nat.lt_of_le_of_lt, Nat.lt_irrefl]]
[Nat.anyAux,[Bool, Unit.unit, Bool.false, or, HSub.hSub, Nat, instHSub, instSubNat, Nat.succ, PProd.fst, PUnit, PProd]]
[ToStream.noConfusionType,[]]
[Array.anyM.proof_1,[Nat.le_refl, Array.size]]
[withPtrEq,[Unit.unit]]
[Nat.le_of_lt_succ,[Nat.le_of_succ_le_succ]]
[IO.appDir,[Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, System.FilePath, IO.appPath, Option, Pure.pure, Applicative.toPure, Monad.toApplicative, System.FilePath.parent, Option.none, IO.FS.realPath, MonadExcept.throw, instMonadExcept, instMonadExceptOfEIO, IO.userError, HAppend.hAppend, String, instHAppend, String.instAppendString, ToString.toString, instToStringString, System.instToStringFilePath]]
[monadLift_self,[rfl, MonadLiftT.monadLift, instMonadLiftT_1]]
[Nat.not_succ_le_zero,[False, Nat.succ, OfNat.ofNat, Nat, instOfNatNat, Eq.refl, HEq.refl, LE.le, instLENat]]
[List.filterRevM,[List.filterAuxM, List.reverse, List.nil]]
[«term_&&_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[«term_↔_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[ExceptCpsT.run_lift,[rfl, Except, ExceptCpsT.run, ExceptCpsT.lift]]
[Lean.Name.num.inj,[And, Eq, Lean.Name, Nat, UInt64, Lean.Name.num, And.intro]]
[DoResultPRBC.noConfusionType,[]]
[Lean.mkIdent,[Lean.Syntax.ident, Lean.SourceInfo.none, String.toSubstring, ToString.toString, Lean.Name, Lean.Name.instToStringName, List.nil, Prod, List, String]]
[String.Iterator.remainingBytes,[Nat, HSub.hSub, String.Pos, instHSub, instSubNat, String.bsize]]
[UInt64.size,[OfNat.ofNat, Nat, instOfNatNat]]
[IO.Process.SpawnArgs.cwd,[]]
[InvImage.wf,[InvImage.wf.proof_1]]
[runST,[Empty, Unit, Unit.unit]]
[instDecidableIte,[Decidable, ite]]
[instDecidableNot,[Decidable, Not, Decidable.isFalse, absurd, False, Decidable.isTrue]]
[Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp,[Trans.mk, Nat, LE.le, instLENat, Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp.proof_1]]
[noConfusionTypeEnum,[ite, Eq]]
[instInhabitedNonScalar,[Inhabited.mk, NonScalar, NonScalar.mk, arbitrary, Nat, instInhabitedNat]]
[instReprAtomBool,[ReprAtom.mk, Bool]]
[Classical.byCases,[Decidable.byCases, Classical.propDecidable]]
[Lean.Name.toStringWithSep.maybeEscape,[ite, String, Eq, Bool, Bool.true, instDecidableEqBool, Option.getD, Lean.Name.escapePart]]
[String.offsetOfPos,[String.offsetOfPosAux, OfNat.ofNat, String.Pos, instOfNatNat, Nat]]
[instDecidableEqList,[List.hasDecEq]]
[String.Iterator.pos,[String.Pos]]
[instInhabitedUSize,[Inhabited.mk, USize, USize.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, instInhabitedUSize.proof_1]]
[Nat.zero_lt_one,[Nat.zero_lt_succ, OfNat.ofNat, Nat, instOfNatNat]]
[decidableOfDecidableOfEq,[Decidable]]
[Lean.Macro.Context.methods,[]]
[Nat.foldRev.loop,[PProd.fst, PUnit, PProd]]
[And.noConfusionType,[]]
[List.join,[List, Unit.unit, List.nil, HAppend.hAppend, instHAppend, List.instAppendList, PProd.fst, PUnit, PProd]]
[instInhabitedTask,[Inhabited.mk, Task, Task.pure, arbitrary]]
[Array.«term__[_:]»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[Array.binInsert,[Id.run, Array, Array.binInsertM, Id, Id.instMonadId]]
[instCoeNatInt,[Coe.mk, Nat, Int, Int.ofNat]]
[instHModUInt16NatUInt16,[HMod.mk, UInt16, Nat, UInt16.modn]]
[Lean.mkAtomFrom,[Lean.Syntax.atom, Lean.SourceInfo.fromRef]]
[instToStringChar,[ToString.mk, Char, Char.toString]]
[StateRefT'.instAlternativeStateRefT',[inferInstanceAs, Alternative, ReaderT, ST.Ref, ReaderT.instAlternativeReaderT]]
[iff_true,[propext, Iff, True, Iff.intro, Iff.mpr, trivial]]
[optional,[HOrElse.hOrElse, Option, instHOrElse, instOrElse, Functor.map, Applicative.toFunctor, Alternative.toApplicative, Option.some, Pure.pure, Applicative.toPure, Option.none]]
[Substring.foldl,[String.foldlAux]]
[Lean.Syntax.isMissing,[Unit.unit, Lean.Syntax.node, Lean.Syntax.atom, Lean.Syntax.ident, Bool, Bool.true, Bool.false]]
[Array.toList,[Array.foldr, List, List.cons, List.nil, Array.size, OfNat.ofNat, Nat, instOfNatNat]]
[instMonadControlT,[MonadControlT.mk, MonadControlT.stM, MonadControl.stM, MonadControl.liftWith, MonadControlT.liftWith, Function.comp, MonadControl.restoreM, MonadControlT.restoreM]]
[IO.Error.permissionDenied.inj,[And, Eq, Option, String, UInt32, IO.Error.permissionDenied, And.intro]]
[IO.Process.StdioConfig.noConfusionType,[]]
[Lean.expandExplicitBinders,[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Syntax, Lean.MonadRef.getRef, Lean.Macro.instMonadRefMacroM, ite, Eq, Bool, BEq.beq, Lean.SyntaxNodeKind, Lean.Name.instBEqName, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.expandExplicitBindersAux, Array.all, Lean.Syntax.getArgs, OfNat.ofNat, Nat, instOfNatNat, Array.size, Lean.expandBrackedBindersAux, Lean.Macro.throwError]]
[List.ibelow,[True, And]]
[ExceptCpsT.instMonadLiftExceptCpsT,[MonadLift.mk, ExceptCpsT, ExceptCpsT.lift]]
[instHModUInt64NatUInt64,[HMod.mk, UInt64, Nat, UInt64.modn]]
[IO.FS.Stream.noConfusionType,[]]
[Lean.Macro.getCurrNamespace,[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, Lean.Name, Lean.Macro.getMethods, Lean.Macro.Methods.getCurrNamespace]]
[instOrdUSize,[Ord.mk, USize, compareOfLessAndEq, instLTUSize, instDecidableLt_4, instDecidableEqUSize]]
[Lean.Syntax.find?,[Lean.Syntax.findAux]]
[MonadState.set,[]]
[Lean.Parser.Tactic.simp,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpStar, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma, Lean.Parser.Tactic.location]]
[List.instForMList,[ForM.mk, List, List.forM]]
[Std.Range.forM,[Std.Range.stop, Std.Range.start, Std.Range.forM.loop]]
[Nat.add_le_add_right,[Eq.mpr, LE.le, Nat, instLENat, HAdd.hAdd, instHAdd, instAddNat, Eq, Eq.refl, Nat.add_comm, Nat.add_le_add_left]]
[instMonadST,[inferInstanceAs, Monad, EST, Empty, instMonadEST]]
[Std.Range.noConfusionType,[]]
[Nat.mul_lt_mul_of_pos_left,[Nat.lt_of_lt_of_le, HMul.hMul, Nat, instHMul, instMulNat, HAdd.hAdd, instHAdd, instAddNat, Nat.mul, Nat.add_lt_add_left, OfNat.ofNat, instOfNatNat, Nat.succ, LE.le, instLENat, Nat.mul_le_mul_left, Nat.succ_le_of_lt, Nat.mul_succ]]
[precArg,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[IO.Error.otherErrorToString,[String, Unit.unit, HAppend.hAppend, instHAppend, String.instAppendString, String.modify, OfNat.ofNat, String.Pos, instOfNatNat, Char.toLower, ToString.toString, UInt32, instToStringUInt32]]
[type_eq_of_heq,[type_eq_of_heq.proof_1]]
[cast_heq,[Eq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl, HEq, cast]]
[fix2,[fixCore2, arbitrary]]
[«term_$__»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
[Equivalence.symm,[]]
[TC.wf,[TC.wf.proof_1]]
[Lean.Parser.Tactic.skip,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[StateT.set,[Pure.pure, Applicative.toPure, Monad.toApplicative, Prod, PUnit, Prod.mk, PUnit.unit]]
[IO.Error.mkResourceExhaustedFile,[Function.comp, String, Option, IO.Error, IO.Error.resourceExhausted, Option.some]]
[List.filterMapM,[List.reverse, List.nil, List.filterMapM.loop]]
[Std.Range.step,[]]
[Array.singleton,[Array.mkArray, OfNat.ofNat, Nat, instOfNatNat]]
[List.eraseIdx,[List, List.cons, List.nil, PProd.fst, PUnit, PProd]]
[Array.swapAt!,[dite, Prod, Array, LT.lt, Nat, instLTNat, Array.size, Nat.decLt, Array.swapAt, Fin.mk]]
[instMonadReaderOf,[MonadReaderOf.mk, liftM, instMonadLiftT, instMonadLiftT_1, MonadReader.read, instMonadReader]]
[Nat.mul_add,[Nat.left_distrib]]
[not_false,[id, False]]
[Std.Format.instMonadPrettyFormatStateMState,[Std.Format.MonadPrettyFormat.mk, StateM, modify, instMonadState, instMonadStateOfStateT, Id, Id.instMonadId, HAppend.hAppend, String, instHAppend, String.instAppendString, HAdd.hAdd, Nat, instHAdd, instAddNat, String.length, String.pushn, Char.ofNat, Bind.bind, Monad.toBind, StateT.instMonadStateT, MonadState.get, Pure.pure, Applicative.toPure, Monad.toApplicative, Unit, Unit.unit]]
[instMonadFinallyStateRefT',[inferInstanceAs, MonadFinally, ReaderT, ST.Ref, ReaderT.tryFinally]]
[instStreamSubstringChar,[Stream.mk, Substring, Char, ite, Option, Prod, LT.lt, String.Pos, instLTNat, Substring.startPos, Substring.stopPos, Nat.decLt, Option.some, Prod.mk, String.get, Substring.str, Substring.mk, String.next, Option.none]]
[instDecidableTrue,[Decidable.isTrue, True, trivial]]
[Array.get,[List.get, Array.data, Fin.val, Array.size, Array.get.proof_1]]
[Nat.mul_le_mul_right,[Nat, HMul.hMul, instHMul, instMulNat, LE.le, instLENat, Nat.mul_le_mul_left, Nat.mul_comm]]
[Lean.Syntax.isInterpolatedStrLit?,[String, Unit.unit, Option, Lean.Syntax.isLit?, Lean.interpolatedStrLitKind, Option.none, OfNat.ofNat, String.Pos, instOfNatNat]]
[dif_neg,[Eq, dite, absurd, Decidable.isTrue, rfl, Decidable.isFalse]]
[ReaderT,[]]
[Lean.mkGroupNode,[Lean.Syntax.node, Lean.groupKind]]
[instReprSubtype,[Repr.mk, Subtype, Repr.reprPrec, Subtype.val]]
[Substring.isNat,[Substring.all, Char.isDigit]]
[Task.map,[Task.pure, Task.get]]
[Iff.symm,[Iff.intro, Iff.mpr, Iff.mp]]
[Lean.isIdFirst,[or, Char.isAlpha, Decidable.decide, Eq, Char, Char.ofNat, instDecidableEqChar, Lean.isLetterLike]]
[HShiftRight.hShiftRight,[]]
[List.foldlM,[Pure.pure, Applicative.toPure, Monad.toApplicative, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd]]
[Lean.Macro.State.traceMsgs,[]]
[Fin.mod,[Fin.mk, Fin, HMod.hMod, Nat, instHMod, Nat.instModNat, Fin.mod.proof_1]]
[heq_of_eqRec_eq,[HEq, heq_of_eq]]
[IO.FS.DirEntry.noConfusionType,[]]
[Nat.superDigitChar,[ite, Char, Eq, Nat, OfNat.ofNat, instOfNatNat, instDecidableEqNat, Char.ofNat]]
[IO.Process.run,[Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.Process.Output, String, IO.Process.output, ite, Eq, Bool, bne, UInt32, instBEq, instDecidableEqUInt32, IO.Process.Output.exitCode, OfNat.ofNat, instOfNatUInt32, Bool.true, instDecidableEqBool, PUnit, MonadExcept.throw, instMonadExcept, instMonadExceptOfEIO, IO.userError, HAppend.hAppend, instHAppend, String.instAppendString, IO.Process.SpawnArgs.cmd, ToString.toString, instToStringUInt32, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit]]
[instDecidableLt_1,[UInt8.decLt]]
[Sum.noConfusionType,[]]
[Array.toSubarray.proof_1,[Nat.le_refl, Array.size]]
[«term_<->_»,[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
[List.intersperse,[List, Unit.unit, List.cons, List.nil, PProd.fst, PUnit, PProd]]
[Lean.Syntax.atom.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, Lean.SourceInfo, instSizeOf, String, SizeOf.mk, List, Char, UInt32, Fin, UInt32.size, instSizeOfNat, LT.lt, instLTNat, UInt32.isValidChar]]
[System.FilePath.isDir,[Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, Bool, MonadExcept.tryCatch, instMonadExcept, instMonadExceptOfEIO, IO.FS.Metadata, System.FilePath.metadata, Pure.pure, Applicative.toPure, Monad.toApplicative, BEq.beq, IO.FS.FileType, IO.FS.instBEqFileType, IO.FS.Metadata.type, IO.FS.FileType.dir, Bool.false]]
[USize.shiftRight,[USize.mk, HShiftRight.hShiftRight, Fin, USize.size, instHShiftRight, Fin.instShiftRightFin, USize.val, USize.modn, System.Platform.numBits]]
[String.isNat,[String.all, Char.isDigit]]
[Nat.mod_le,[LT.lt, Nat, instLTNat, GE.ge, instLENat, LE.le, HMod.hMod, instHMod, Nat.instModNat, Nat.lt_or_ge, Eq.mpr, Eq, Eq.refl, Nat.mod_eq_of_lt, Nat.le_refl, OfNat.ofNat, instOfNatNat, GT.gt, Nat.eq_zero_or_pos, Nat.mod_zero, Nat.le_trans, Nat.le_of_lt, Nat.mod_lt]]
[UInt16.complement,[HSub.hSub, UInt16, instHSub, instSubUInt16, OfNat.ofNat, instOfNatUInt16, HAdd.hAdd, instHAdd, instAddUInt16]]
[Fin.instSubFin,[Sub.mk, Fin, Fin.sub]]
[MonadExcept.noConfusionType,[]]
[Fin.instOfNatFinHAdd,[OfNat.mk, Fin, Fin.ofNat]]
[WellFounded.apply.proof_1,[Acc]]
[EStateM.Result.noConfusionType,[]]
[prioHigh,[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
[NonScalar.val,[]]
[UInt8.size,[OfNat.ofNat, Nat, instOfNatNat]]
[Array.anyM,[dite, Bool, LE.le, optParam, Nat, Array.size, instLENat, Nat.decLe, Array.anyM.proof_1]]
[Lean.instInhabitedSourceInfo,[Inhabited.mk, Lean.SourceInfo, Lean.SourceInfo.none]]
[Fin.instAddFin,[Add.mk, Fin, Fin.add]]
[StateRefT'.instMonadFunctorStateRefT',[inferInstanceAs, MonadFunctor, ReaderT, ST.Ref, ReaderT.instMonadFunctorReaderT]]
[Equivalence.refl,[]]
[UInt16.add,[UInt16.mk, HAdd.hAdd, Fin, UInt16.size, instHAdd, Fin.instAddFin, UInt16.val]]
[Lean.Name.ibelow,[True, And]]
[instAddUInt32,[Add.mk, UInt32, UInt32.add]]
[Task.pure.sizeOf_spec,[Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
[EIO,[EStateM, IO.RealWorld]]
[monadFunctorRefl,[MonadFunctorT.mk]]
[Lean.Macro.expandMacro?,[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, Option, Lean.Syntax, Lean.Macro.getMethods, Lean.Macro.Methods.expandMacro?]]
[Lean.Module.noConfusionType,[]]
[Std.instToFormatFormat,[Std.ToFormat.mk, Std.Format]]
[randBool,[Nat, Prod, Bool, Prod.mk, Decidable.decide, Eq, OfNat.ofNat, instOfNatNat, instDecidableEqNat]]
[Subarray.instForInSubarray,[ForIn.mk, Subarray, Subarray.forIn]]
[MonadStateOf.set,[]]
[String.prev,[String.Pos, ite, Eq, OfNat.ofNat, instOfNatNat, instDecidableEqNat, Char, PProd.fst, PUnit, PProd]]
[dite_true,[rfl, dite, True, instDecidableTrue]]
[Nat.foldM,[Nat.foldM.loop]]
[List.reverse,[List.reverseAux, List.nil]]
[USize.complement,[HSub.hSub, USize, instHSub, instSubUSize, OfNat.ofNat, instOfNatUSize, HAdd.hAdd, instHAdd, instAddUSize]]
[String.dropWhile,[Substring.toString, Substring.dropWhile, String.toSubstring]]
[FloatArray.size,[Nat, Array.size, Float]]
[List.hasDecEq.proof_5,[False, List.cons, absurd, Eq, List]]
[Array.toArrayLit,[List.toArray, Array.toListLitAux, Array.toArrayLit.proof_1, List.nil]]
[Lean.Name.escapePart,[ite, Option, String, Eq, Bool, and, Decidable.decide, GT.gt, Nat, instLTNat, String.length, OfNat.ofNat, instOfNatNat, Nat.decLt, Lean.isIdFirst, String.getOp, String.Pos, Substring.all, Substring.drop, String.toSubstring, Lean.isIdRest, Bool.true, instDecidableEqBool, Option.some, String.any, Lean.isIdEndEscape, Option.none, HAppend.hAppend, instHAppend, String.instAppendString, Char.toString, Lean.idBeginEscape, Lean.idEndEscape]]
[Lean.Syntax.formatStx,[Lean.Syntax.formatStxAux, OfNat.ofNat, Nat, instOfNatNat]]
[coeTrans,[CoeTC.mk, coeB, coeTC]]
