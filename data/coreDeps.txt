["PProd.noConfusionType",[PProd, Eq]]
["Id.hasBind",[inferInstance, Bind, Id, Monad.toBind, Id.instMonadId]]
["Lean.identKind",[Lean.Name.mkStr, Lean.Name.anonymous]]
["MonadState.noConfusionType",[outParam, MonadState, PUnit, Prod, Eq]]
["ToString.noConfusionType",[ToString, String, Eq]]
["String.Iterator.mk.sizeOf_spec",[String, String.Pos, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["Nat.toUInt8",[UInt8.ofNat]]
["ByteArray.noConfusionType",[ByteArray, Array, UInt8, Eq]]
["ExceptCpsT.run_bind_throw",[Monad, ExceptCpsT, rfl, Except, ExceptCpsT.run, Bind.bind, Monad.toBind, ExceptCpsT.instMonadExceptCpsT, MonadExcept.throw, instMonadExcept, ExceptCpsT.instMonadExceptOfExceptCpsT]]
["List.append_eq_appendTR",[funext, List, List.append, List.appendTR, Eq, List.reverseAux, List.nil, rfl, of_eq_true, List.cons, Eq.trans, True, congr, congrArg, List.reverseAux_reverseAux, eq_self]]
["Lean.isIdRest",[Char, or, Char.isAlphanum, Decidable.decide, Eq, Char.ofNat, instDecidableEqChar, BEq.beq, instBEq, Lean.isLetterLike, Lean.isSubScriptAlnum]]
["List.spanAux",[Bool, List, Prod, List.below, List.nil, Prod.mk, List.reverse, List.cons, Unit, PProd.fst, PUnit, PProd]]
["instInhabitedUSize.proof_1",[Nat, USize.size, Or, Eq, OfNat.ofNat, instOfNatNat, usize_size_eq, LT.lt, instLTNat, Unit, of_decide_eq_true, Nat.decLt, Eq.refl, Bool, Bool.true]]
["Array.instForInArray",[ForIn.mk, Array, Monad, Array.forIn]]
["List.getLastD",[List, List.getLast, List.cons, List.getLastD.proof_1]]
["Eq.mpr_not",[Eq, Not, Eq.symm]]
["Not",[False]]
["OptionT.pure",[Monad, OptionT.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, Option, Option.some]]
["Nat.toSuperDigits",[Nat, Nat.toSuperDigitsAux, List.nil, Char]]
["EStateM.pure",[EStateM.Result.ok]]
["Subtype.val",[Subtype]]
["Functor.mapRev",[Functor, Functor.map]]
["Lean.Syntax.getSepArgs",[Lean.Syntax, Array.getSepElems, Lean.Syntax.getArgs]]
["LawfulFunctor.id_map",[Functor, LawfulFunctor]]
["ULift.down_up",[rfl, ULift.down, ULift.up]]
["HMul.noConfusionType",[outParam, HMul, Eq]]
["instInhabitedFloat",[Inhabited.mk, Float, Float.mk, FloatSpec.val, floatSpec]]
["ExceptCpsT.run_pure",[Monad, rfl, Except, ExceptCpsT.run, Pure.pure, ExceptCpsT, Applicative.toPure, Monad.toApplicative, ExceptCpsT.instMonadExceptCpsT]]
["IO.Error.hardwareFault.inj",[UInt32, String, Eq, IO.Error, IO.Error.hardwareFault, And, And.intro]]
["PSum.noConfusionType",[PSum, Eq]]
["instOrElse",[Alternative, OrElse.mk, Alternative.orElse]]
["Array.filterSepElemsM",[Monad, Array, Lean.Syntax, Bool, OfNat.ofNat, Nat, instOfNatNat, List.toArray, List.nil]]
["USize.le",[USize, LE.le, Fin, USize.size, instLEFin, USize.val]]
["instReprExcept",[Repr, Repr.mk, Except, Nat, Std.Format, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, reprArg]]
["EStateM",[EStateM.Result]]
["Subrelation.wf",[Subrelation.wf.proof_1]]
["String.intercalate.go",[String, List, List.below, List.cons, PProd.fst, PUnit, PProd, HAppend.hAppend, instHAppend, String.instAppendString, Unit, List.nil]]
["Lean.choiceKind",[Lean.Name.mkStr, Lean.Name.anonymous]]
["Array.toArrayLit_eq",[Array, Nat, Eq, Array.size, sorryAx, Array.toArrayLit, Bool.false]]
["StateT.seqRight_eq",[Monad, LawfulMonad, StateT, StateT.ext, SeqRight.seqRight, Applicative.toSeqRight, Monad.toApplicative, StateT.instMonadStateT, Unit, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const, id, Eq.mpr, Eq, Prod, StateT.run, Bind.bind, Monad.toBind, Prod.snd, Pure.pure, Applicative.toPure, Prod.mk, Prod.fst, congr, congrArg, StateT.run_seqRight, Eq.trans, StateT.run_seq, StateT.run_map, map_eq_pure_bind, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, congrFun, id_eq, bind_congr, of_eq_true, True, Prod.ext, bind_pure, eq_self, Eq.symm, Eq.refl]]
["Decidable.of_not_not",[Decidable, Not, Decidable.byContradiction, absurd, False]]
["instToStringList",[ToString, ToString.mk, List, List.toString]]
["Lean.Syntax.isIdOrAtom?",[Lean.Syntax, Option, String, Lean.SourceInfo, Option.some, Substring, Lean.Name, List, Prod, Substring.toString, Option.none]]
["Nat.le_of_succ_le",[Nat, LE.le, instLENat, Nat.succ, Nat.le_trans, Nat.le_succ]]
["instOfNatUInt16",[Nat, OfNat.mk, UInt16, UInt16.ofNat]]
["Char.le",[Char, LE.le, UInt32, instLEUInt32, Char.val]]
["Std.Format.fill",[Std.Format, Std.Format.group, Std.Format.FlattenBehavior.fill]]
["Nat.toDigitsCore",[Nat, List, Char, Nat.below, Nat.succ, Nat.digitChar, HMod.hMod, instHMod, Nat.instModNat, HDiv.hDiv, instHDiv, Nat.instDivNat, ite, Eq, OfNat.ofNat, instOfNatNat, instDecidableEqNat, List.cons, PProd.fst, PUnit, PProd]]
["ST",[EST, Empty]]
["Nat.succ_eq_add_one",[Nat, rfl, Nat.succ]]
["Equivalence.trans",[Equivalence]]
["String.foldr",[Char, String, String.foldrAux, String.bsize, OfNat.ofNat, String.Pos, instOfNatNat]]
["instInhabitedEST",[Inhabited, inferInstanceAs, EStateM, EStateM.instInhabitedEStateM]]
["IO.FS.readBinFile",[System.FilePath, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle, ByteArray, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.true, IO.FS.Handle.readBinToEnd]]
["Lean.Parser.Tactic.focus",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["unexpandIte",[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
["USize.decLe",[USize, Decidable, LE.le, instLEUSize, Fin, USize.size, inferInstanceAs, instLEFin, Fin.decLe]]
["List.hasDecEq.proof_2",[List, Eq, List.cons, List.nil, False]]
["implies",[]]
["Char.eq_of_val_eq",[Char, Eq, UInt32, Char.val, UInt32.isValidChar, rfl, Char.mk]]
["Subsingleton.helim",[Subsingleton.helim.proof_1]]
["HEq.subst",[HEq, HEq.ndrecOn]]
["Subarray.h₂",[Subarray]]
["Std.Format.MonadPrettyFormat.noConfusionType",[Std.Format.MonadPrettyFormat, String, Unit, Nat, Eq]]
["Nat.instShiftLeftNat",[ShiftLeft.mk, Nat, Nat.shiftLeft]]
["emptyRelation",[False]]
["bind_pure",[Monad, LawfulMonad]]
["ST.Prim.Ref.modify",[ST.Ref, Bind.bind, ST, Monad.toBind, instMonadST, Unit, ST.Prim.Ref.get, ST.Prim.Ref.set]]
["Nat.lt_of_le_of_lt",[Nat, LE.le, instLENat, LT.lt, instLTNat, Nat.le_trans, Nat.succ, Nat.succ_le_succ]]
["Lean.monadNameGeneratorLift",[MonadLift, Lean.MonadNameGenerator, Lean.MonadNameGenerator.mk, liftM, instMonadLiftT, instMonadLiftT_1, Lean.NameGenerator, Lean.MonadNameGenerator.getNGen, Unit, Lean.MonadNameGenerator.setNGen]]
["ExceptCpsT.instMonadExceptOfExceptCpsT",[MonadExceptOf.mk, ExceptCpsT]]
["decidableOfDecidableOfIff",[Decidable, Iff, dite, Decidable.isTrue, Iff.mp, Not, Decidable.isFalse, decidableOfDecidableOfIff.proof_1]]
["String.trim",[String, Substring.toString, Substring.trim, String.toSubstring]]
["instPowFloatFloat",[Pow.mk, Float, Float.pow]]
["Pow.noConfusionType",[Pow, Eq]]
["bind_congr",[Bind, Eq, of_eq_true, Bind.bind, Eq.trans, True, congrFun, congrArg, funext, eq_self]]
["Nat.decEq.proof_1",[Eq.refl, Bool, Nat.beq]]
["StateCpsT.runK_lift",[Monad, rfl, StateCpsT.runK, StateCpsT.lift]]
["EStateM.instMonadEStateM",[Monad.mk, EStateM, Applicative.mk, Functor.mk, EStateM.map, Pure.mk, EStateM.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, EStateM.seqRight, Bind.mk, EStateM.bind]]
["instOrOpUInt8",[OrOp.mk, UInt8, UInt8.lor]]
["Nat.min",[Nat, ite, LE.le, instLENat, Nat.decLe]]
["instReprTuple",[Repr, ReprTuple.mk, List, Std.Format, List.cons, repr]]
["IO.FS.SystemTime.nsec",[IO.FS.SystemTime]]
["ReaderT.read",[Monad, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["FloatArray.toList",[FloatArray, Nat, List, Float, OfNat.ofNat, instOfNatNat, List.nil, FloatArray.toList.loop]]
["USize.size",[HPow.hPow, Nat, instHPow, instPowNatNat, OfNat.ofNat, instOfNatNat, System.Platform.numBits]]
["And.left",[And]]
["«term_<*_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["unexpandUnit",[Lean.Syntax, Bind.bind, Lean.PrettyPrinter.UnexpandM, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
["instMonadFinallyEIO",[inferInstanceAs, MonadFinally, EStateM, IO.RealWorld, EStateM.instMonadFinallyEStateM]]
["IO.FS.Metadata.modified",[IO.FS.Metadata]]
["Lean.Syntax.SepArray.ofElems",[String, Array, Lean.Syntax, Lean.Syntax.SepArray.mk, Lean.mkSepArray, Lean.mkAtom]]
["CoeHTCT.coe",[CoeHTCT]]
["Array.reverse",[Array, Nat, Array.size, HDiv.hDiv, instHDiv, Nat.instDivNat, OfNat.ofNat, instOfNatNat, Array.reverse.rev]]
["instHashableUInt64",[Hashable.mk, UInt64]]
["Lean.Syntax.isNodeOf",[Lean.Syntax, Lean.SyntaxNodeKind, Nat, and, Lean.Syntax.isOfKind, BEq.beq, instBEq, instDecidableEqNat, Lean.Syntax.getNumArgs]]
["Std.Format.MonadPrettyFormat.pushOutput",[Std.Format.MonadPrettyFormat]]
["PProd.snd",[PProd]]
["USize.decEq.proof_2",[Fin, USize.size, Not, Eq, USize, USize.mk, False, absurd]]
["System.FilePath.parent",[System.FilePath, Functor.map, Option, Option.instFunctorOption, String, System.FilePath.mk, String.Pos, String.extract, System.FilePath.toString, OfNat.ofNat, instOfNatNat, String.revFind, List.contains, Char, instBEq, instDecidableEqChar, System.FilePath.pathSeparators]]
["Fin.sub.proof_1",[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, HSub.hSub, instHSub, instSubNat]]
["stdSplit",[StdGen, Prod, Nat, ite, Eq, OfNat.ofNat, instOfNatNat, instDecidableEqNat, HAdd.hAdd, instHAdd, instAddNat, HSub.hSub, instHSub, instSubNat, Prod.snd, stdNext, StdGen.mk, StdGen.s2, StdGen.s1, Prod.mk]]
["Stream.noConfusionType",[outParam, Stream, Option, Prod, Eq]]
["Quotient.inductionOn₃",[Setoid, Quotient, Quotient.mk, Quotient.ind]]
["Lean.Eval.noConfusionType",[Lean.Eval, Unit, optParam, Bool, Bool.true, IO, Eq]]
["CoeFun.noConfusionType",[outParam, CoeFun, Eq]]
["Stream.forIn",[outParam, Stream, Monad, ForInStep, Stream.forIn.visit]]
["Lean.instInhabitedMacroScopesView",[Inhabited.mk, Lean.MacroScopesView, Lean.MacroScopesView.mk, arbitrary, Lean.Name, Lean.instInhabitedName, List, Lean.MacroScope, instInhabitedList]]
["instOfNatUInt8",[Nat, OfNat.mk, UInt8, UInt8.ofNat]]
["Nat.digitChar",[Nat, ite, Char, Eq, OfNat.ofNat, instOfNatNat, instDecidableEqNat, Char.ofNat]]
["IO.Error.inappropriateType.inj",[Option, String, UInt32, Eq, IO.Error, IO.Error.inappropriateType, And, And.intro]]
["ForIn.forIn",[ForIn]]
["Complement.complement",[Complement]]
["Lean.Syntax.node.injEq",[Lean.SyntaxNodeKind, Array, Lean.Syntax, Eq.propIntro, Eq, Lean.Syntax.node, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Array.noConfusionType",[Array, List, Eq]]
["IO.FS.Stream.Buffer.mk.injEq",[ByteArray, Nat, Eq.propIntro, Eq, IO.FS.Stream.Buffer, IO.FS.Stream.Buffer.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Lean.Parser.Tactic.Conv.lhs",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["instReprSourceInfo",[Repr.mk, Lean.SourceInfo, Nat, Substring, String.Pos, Lean.SourceInfo.original, Lean.SourceInfo.synthetic, Unit, Lean.SourceInfo.none, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, Int, GE.ge, instLENat, OfNat.ofNat, instOfNatNat, Nat.decLe, Int.instOfNatInt, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, Std.Format.line, reprArg, instReprSubstring, instReprNat, Std.Format.FlattenBehavior.allOrNone]]
["instOrOpUInt16",[OrOp.mk, UInt16, UInt16.lor]]
["fix1",[Inhabited, fixCore1, arbitrary]]
["Lean.Parser.Tactic.tacticRefine_lift'_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
["instLEFin",[Nat, LE.mk, Fin, LE.le, instLENat, Fin.val]]
["Std.Format.pretty",[Std.Format, optParam, Nat, Std.Format.defWidth, StateM, Unit, Std.Format.prettyM, OfNat.ofNat, instOfNatNat, StateT.instMonadStateT, Id, Id.instMonadId, Std.Format.instMonadPrettyFormatStateMState, Prod.snd]]
["Char.isWhitespace",[Char, or, Decidable.decide, Eq, Char.ofNat, instDecidableEqChar]]
["StateT.pure",[Monad, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod, Prod.mk]]
["StateRefT'.instMonadStateOfStateRefT'",[MonadLiftT, ST, Monad, MonadStateOf.mk, StateRefT', StateRefT'.get, StateRefT'.set, StateRefT'.modifyGet]]
["Array.mk.inj",[List, Eq, Array, Array.mk]]
["instToStringUInt8",[ToString.mk, UInt8, ToString.toString, Nat, instToStringNat, UInt8.toNat]]
["IO.Process.Child.stdin",[IO.Process.StdioConfig, IO.Process.Child]]
["IO.Error.invalidArgument.sizeOf_spec",[Option, String, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["List.get.proof_1",[List, Nat, LT.lt, instLTNat, Nat.succ, List.length, List.cons, Nat.le_of_succ_le_succ, List.length_cons]]
["ULift.noConfusionType",[ULift, Eq]]
["Fin.isLt",[Nat, Fin]]
["Lean.Parser.Tactic.tacticTrivial",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["EStateM.instMonadFinallyEStateM",[MonadFinally.mk, EStateM, Option, EStateM.Result, Prod, Option.some, EStateM.Result.ok, Prod.mk, EStateM.Result.error, Option.none]]
["Lean.NameGenerator.idx",[Lean.NameGenerator]]
["UInt64.ofNatCore",[LT.lt, Nat, instLTNat, UInt64.size, UInt64.mk, Fin.mk]]
["Lean.numLitKind",[Lean.Name.mkStr, Lean.Name.anonymous]]
["Lean.Syntax.mkNameLit",[String, optParam, Lean.SourceInfo, Lean.SourceInfo.none, Lean.Syntax.mkLit, Lean.nameLitKind]]
["congrArg",[Eq, rfl]]
["Array.mapMUnsafe.map",[Monad, USize, Array, NonScalar, ite, PNonScalar, LT.lt, instLTUSize, instDecidableLt_4, Array.uget, lcProof, Nat, instLTNat, USize.toNat, Array.size, Array.uset, arbitrary, instInhabitedNonScalar, Bind.bind, Monad.toBind, unsafeCast, Array.mapMUnsafe.map, HAdd.hAdd, instHAdd, instAddUSize, OfNat.ofNat, instOfNatUSize, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["instToStreamSubarraySubarray",[ToStream.mk, Subarray]]
["Char.toNat",[Char, UInt32.toNat, Char.val]]
["Functor.map",[Functor]]
["List.tailD",[List]]
["EStateM.Backtrackable.restore",[EStateM.Backtrackable]]
["instNonempty",[instNonempty.proof_1]]
["instReprAtomUInt16",[ReprAtom.mk, UInt16]]
["IO.Error.interrupted.injEq",[String, UInt32, Eq.propIntro, Eq, IO.Error, IO.Error.interrupted, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Lean.Syntax.getOptionalIdent?",[Lean.Syntax, Option, Lean.Name, Lean.Syntax.getOptional?, Option.some, Lean.Syntax.getId, Unit, Option.none]]
["List.below",[List, PUnit, PProd]]
["Iff.noConfusionType",[Iff]]
["coeOfTail",[CoeTail, CoeHTCT.mk, coeTail]]
["invImage",[WellFoundedRelation, WellFoundedRelation.mk, InvImage, WellFoundedRelation.rel, invImage.proof_1]]
["IO.FS.instReprFileType",[Repr.mk, IO.FS.FileType, Nat, Unit, IO.FS.FileType.dir, IO.FS.FileType.file, IO.FS.FileType.symlink, IO.FS.FileType.other, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, Int, GE.ge, instLENat, OfNat.ofNat, instOfNatNat, Nat.decLe, Int.instOfNatInt, Std.Format.text, Std.Format.FlattenBehavior.allOrNone]]
["Lean.Parser.Attr.simp",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.simpPre, Lean.Parser.Tactic.simpPost, Lean.ParserDescr.cat]]
["Quot.inductionOn",[Quot, Quot.mk, Quot.ind]]
["Lean.Syntax.SepArray.noConfusionType",[String, Lean.Syntax.SepArray, Array, Lean.Syntax, Eq]]
["List.findM?",[Monad, Bool, List, Option, List.below, Unit, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.none, List.cons, Bind.bind, Monad.toBind, Option.some, PProd.fst, PUnit, PProd]]
["GT.gt",[LT, LT.lt]]
["LE.le",[LE]]
["Lean.Parser.Tactic.config",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat]]
["Hashable.hash",[Hashable]]
["Substring.trimRight",[Substring, Substring.dropRightWhile, Char.isWhitespace]]
["instModUInt64",[Mod.mk, UInt64, UInt64.mod]]
["rfl.proof_1",[Eq.refl]]
["coeOfTCOfTail",[CoeTail, CoeTC, CoeHTCT.mk, coeTail, coeTC]]
["EStateM.throw",[EStateM.Result.error]]
["MonadLiftT.noConfusionType",[MonadLiftT, Eq]]
["Nat.add_le_add_left",[Nat, LE.le, instLENat, Exists, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.le.dest]]
["instOfNatFloat",[Nat, OfNat.mk, Float, Float.ofNat]]
["UInt16.toUInt8",[UInt16, Nat.toUInt8, UInt16.toNat]]
["StateCpsT.runK_bind_get",[Monad, StateCpsT, rfl, StateCpsT.runK, Bind.bind, Monad.toBind, StateCpsT.instMonadStateCpsT, MonadState.get, instMonadState, StateCpsT.instMonadStateOfStateCpsT]]
["false_and",[propext, And, False, Iff.intro, And.left, False.elim]]
["List.forIn_cons",[Monad, ForInStep, List, rfl, ForIn.forIn, List.instForInList, List.cons]]
["Array.extLit",[Nat, Array, Eq, Array.size, LT.lt, instLTNat, Array.getLit, Array.ext, Eq.trans, Eq.symm]]
["ByteArray.extract",[ByteArray, Nat, ByteArray.copySlice, ByteArray.empty, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Bool.true]]
["FloatArray.get",[Float, Array, Fin, FloatArray.size, FloatArray.mk, Array.get]]
["TC.accessible",[TC.accessible.proof_1]]
["Lean.Meta.Simp.instInhabitedConfig",[Inhabited.mk, Lean.Meta.Simp.Config, Lean.Meta.Simp.Config.mk, arbitrary, Nat, instInhabitedNat, Bool, instInhabitedBool]]
["StateCpsT.instMonadLiftStateCpsT",[Monad, MonadLift.mk, StateCpsT, StateCpsT.lift]]
["CoeSort.coe",[CoeSort]]
["OptionT.tryCatch",[Monad, OptionT, Unit, OptionT.mk, Bind.bind, Monad.toBind, Option, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.some, Unit.unit]]
["instToStringFormat",[ToString.mk, Std.Format, Std.Format.pretty, Std.Format.defWidth]]
["Fin.modn_lt",[Nat, Fin, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, LT.lt, Fin.val, HMod.hMod, Fin.instHModFinNatFin, Nat.lt_of_le_of_lt, Fin.mk, instHMod, Nat.instModNat, Nat.mod_le, Nat.mod_lt]]
["Classical.strongIndefiniteDescription",[Nonempty, dite, Subtype, Exists, Classical.propDecidable, Not, Subtype.mk, Classical.choice, Classical.strongIndefiniteDescription.proof_2]]
["IO.Process.Stdio.inherit.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["instMonadLiftT_1",[MonadLiftT.mk]]
["Unit.unit",[PUnit.unit]]
["List.partitionAux",[Bool, List, Prod, List.below, List.nil, Prod.mk, List.reverse, List.cons, Unit, PProd.fst, PUnit, PProd]]
["Std.Format.nestD",[Std.Format, Std.Format.nest, Int.ofNat, Std.Format.defIndent]]
["Lean.Name.mkNum.proof_1",[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt64.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
["String.intercalate",[String, List, Unit, String.intercalate.go]]
["instInhabitedUInt64",[Inhabited.mk, UInt64, UInt64.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, instInhabitedUInt64.proof_1]]
["Except.ok.injEq",[Eq.propIntro, Eq, Except, Except.ok, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Fin.ofNat",[Nat, Fin.mk, Nat.succ, HMod.hMod, instHMod, Nat.instModNat, Fin.ofNat.proof_1]]
["IO.Process.Child.mk.inj",[IO.Process.StdioConfig, IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdin, IO.Process.StdioConfig.stdout, IO.Process.StdioConfig.stderr, Eq, IO.Process.Child, IO.Process.Child.mk, And, And.intro]]
["Ord.noConfusionType",[Ord, Ordering, Eq]]
["instToStringSigma",[ToString, ToString.mk, Sigma, String, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString]]
["IO.FS.Stream.read",[IO.FS.Stream]]
["WellFounded.fixFEq",[WellFounded.fixFEq.proof_1]]
["Fin.ofNat'",[Nat, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt]]
["Lean.Parser.Tactic.constructor",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["Option.instFunctorOption",[Functor.mk, Option, Option.map]]
["Lean.Parser.Tactic.Conv.«convEnter[__]»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.ParserDescr.const, Lean.Parser.Tactic.Conv.enterArg]]
["List.rangeAux",[Nat, List, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, List.cons]]
["ByteArray.toList",[ByteArray, Nat, List, UInt8, OfNat.ofNat, instOfNatNat, List.nil, ByteArray.toList.loop]]
["Lean.Parser.Tactic.Conv.pattern",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
["Lean.Parser.Tactic.Conv.simpMatch",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["Lean.Macro.resolveGlobalName",[Lean.Name, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, List, Prod, String, Lean.Macro.getMethods, Lean.Macro.Methods.resolveGlobalName]]
["ReaderT.pure",[Monad, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["Exists.elim",[Exists]]
["Lean.Macro.Context.currRecDepth",[Lean.Macro.Context]]
["Lean.Syntax.getArg",[Lean.Syntax, Nat, Lean.SyntaxNodeKind, Array, Array.getD, Lean.Syntax.missing]]
["List.forM",[Monad, List, PUnit, List.below, Unit, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, List.cons, Bind.bind, Monad.toBind, PProd.fst, PProd]]
["List.find?",[Bool, List, Option, List.below, Unit, List.nil, Option.none, List.cons, Option.some, PProd.fst, PUnit, PProd]]
["Int.decEq.proof_6",[Nat, Eq, Int, Int.negSucc, Int.ofNat, False]]
["USize.lt",[USize, LT.lt, Fin, USize.size, instLTFin, USize.val]]
["instReprList_1",[Repr, ReprAtom, Repr.mk, List, Nat, Std.ToFormat, Std.ToFormat.mk, repr, Std.Format, Std.Format.text, Std.Format.bracketFill, Std.Format.joinSep, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.line]]
["termIfThenElse",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, Lean.ParserDescr.const]]
["ExceptT.lift",[Monad, ExceptT.mk, Functor.map, Applicative.toFunctor, Monad.toApplicative, Except, Except.ok]]
["Nat.gcd",[WellFounded.fix, Nat, WellFoundedRelation.rel, measure, id, Nat.gcd.proof_1, Unit, Nat.succ, Unit.unit, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, Nat.zero_lt_succ]]
["Char.quote",[Char, HAppend.hAppend, String, instHAppend, String.instAppendString, Char.quoteCore]]
["instToFormatProd",[Std.ToFormat, Std.ToFormat.mk, Prod, Std.Format, Std.Format.paren, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.ToFormat.format, Std.Format.text, Std.Format.line]]
["EIO.catchExceptions",[EIO, Empty, IO.RealWorld, EStateM.Result, EStateM.Result.ok]]
["Array.elem",[BEq, Array, Array.contains]]
["Lean.isIdBeginEscape",[Char, Decidable.decide, Eq, Lean.idBeginEscape, instDecidableEqChar]]
["FloatArray.mk.injEq",[Array, Float, Eq.propIntro, Eq, FloatArray, FloatArray.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["instToStringUnit",[ToString.mk, Unit]]
["Lean.Parser.Tactic.locationHyp",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
["Nat.one_mul",[Nat, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, Eq, Nat.mul_one, Nat.mul_comm]]
["UInt8.decEq.proof_2",[Fin, UInt8.size, Not, Eq, UInt8, UInt8.mk, False, absurd]]
["Ne.symm",[Ne, Eq, Eq.symm]]
["Lean.Name.mkNum",[Lean.Name, Nat, Lean.Name.num, mixHash, Hashable.hash, Lean.instHashableName, dite, UInt64, LT.lt, instLTNat, UInt64.size, Nat.decLt, UInt64.ofNatCore, Not, OfNat.ofNat, instOfNatNat, Lean.Name.mkNum.proof_1]]
["Classical.inhabited_of_nonempty",[Nonempty, Inhabited.mk, Classical.choice]]
["ByteArray.mk.injEq",[Array, UInt8, Eq.propIntro, Eq, ByteArray, ByteArray.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Lean.Meta.Simp.Config.memoize",[Lean.Meta.Simp.Config]]
["randNat",[RandomGen, Nat, ite, GT.gt, instLTNat, Nat.decLt, Prod, RandomGen.range, HAdd.hAdd, instHAdd, instAddNat, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, HMul.hMul, instHMul, instMulNat, Prod.mk, HMod.hMod, instHMod, Nat.instModNat]]
["Fin.decLe",[Nat, Fin, Nat.decLe, Fin.val]]
["Int.toNat",[Int, Nat, OfNat.ofNat, instOfNatNat]]
["Lean.PrettyPrinter.Unexpander",[Lean.Syntax, Lean.PrettyPrinter.UnexpandM]]
["EStateM.instOrElseEStateM",[outParam, EStateM.Backtrackable, OrElse.mk, EStateM, EStateM.orElse]]
["Lean.Parser.Tactic.exact",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
["«term_++_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["let_body_congr",[Eq]]
["Classical.choose",[Exists, Subtype.val, Classical.indefiniteDescription]]
["Int.instHPowIntNatInt",[HPow.mk, Int, Nat, Int.pow]]
["Except.instMonadExcept",[Monad.mk, Except, Applicative.mk, Functor.mk, Except.map, Pure.mk, Except.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk, Except.bind]]
["bne",[BEq, not, BEq.beq]]
["flip",[]]
["Subarray.forM",[Monad, PUnit, Subarray, Array.forM, Subarray.as, Subarray.start, Subarray.stop]]
["Nat.eq_or_lt_of_le",[Nat, LE.le, instLENat, Or, Eq, LT.lt, instLTNat, Nat.below, Nat.zero, Or.inl, rfl, Nat.succ, Or.inr, Nat.succ_le_succ, Nat.zero_le, absurd, Nat.not_succ_le_zero]]
["UInt8.modn",[UInt8, UInt8.mk, HMod.hMod, Fin, UInt8.size, Nat, Fin.instHModFinNatFin, UInt8.val]]
["Lean.Syntax.getTailInfo",[Lean.Syntax, Option.getD, Lean.SourceInfo, Lean.Syntax.getTailInfo?, Lean.SourceInfo.none]]
["List.range",[Nat, List.rangeAux, List.nil]]
["List.get!",[Inhabited, Nat, List, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, panicWithPosWithDecl, OfNat.ofNat, instOfNatNat]]
["fixCore1",[bfix1, USize.size]]
["IO.Error.protocolError.injEq",[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.protocolError, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["String.contains",[String, Char, String.any, BEq.beq, instBEq, instDecidableEqChar]]
["Std.Range.instForMRangeNat",[ForM.mk, Std.Range, Nat, Monad, Std.Range.forM]]
["System.Platform.numBits_eq",[Subtype.property, Nat, Or, Eq, OfNat.ofNat, instOfNatNat, System.Platform.getNumBits, Unit.unit]]
["System.FilePath.noConfusionType",[System.FilePath, String, Eq]]
["Div.noConfusionType",[Div, Eq]]
["Substring.toNat?",[Substring, ite, Option, Nat, Eq, Bool, Substring.isNat, Bool.true, instDecidableEqBool, Option.some, Substring.foldl, Char, HAdd.hAdd, instHAdd, instAddNat, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Char.toNat, Char.ofNat, Option.none]]
["IO.Error.resourceExhausted.inj",[Option, String, UInt32, Eq, IO.Error, IO.Error.resourceExhausted, And, And.intro]]
["Nat.add_one",[Nat, rfl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
["IO.FS.SystemTime.mk.sizeOf_spec",[Int, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, instSizeOfNat, Fin, UInt32.size, LT.lt, instLTNat, instSizeOf]]
["bfix3",[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd]]
["Lean.Syntax.ident.inj",[Lean.SourceInfo, Substring, Lean.Name, List, Prod, String, Eq, Lean.Syntax, Lean.Syntax.ident, And, And.intro]]
["Array.concatMapM",[Monad, Array, Array.foldlM, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, HAppend.hAppend, instHAppend, Array.instAppendArray, Array.empty, OfNat.ofNat, Nat, instOfNatNat, Array.size]]
["ByteArray.empty",[ByteArray.mkEmpty, OfNat.ofNat, Nat, instOfNatNat]]
["UInt16.decLt",[UInt16, Decidable, LT.lt, instLTUInt16, Fin, UInt16.size, inferInstanceAs, instLTFin, Fin.decLt]]
["Int.instOfNatInt",[Nat, OfNat.mk, Int, Int.ofNat]]
["Lean.Parser.Tactic.assumption",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["Prod.map",[Prod, Prod.mk]]
["coeSortToCoeTail",[outParam, CoeSort, CoeTail.mk, CoeSort.coe]]
["Quotient.rec",[Setoid, Quotient, Quotient.mk, HasEquiv.Equiv, instHasEquiv, Eq, Quotient.sound, Quot.rec, Setoid.r]]
["and_false",[propext, And, False, Iff.intro, And.right, False.elim]]
["Float.le",[Float, FloatSpec.le, floatSpec, Float.val]]
["IO.FileRight.mk.sizeOf_spec",[IO.AccessRight, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Bool]]
["decide_true_eq_true",[Decidable, True, Eq, Bool, Decidable.decide, Bool.true, rfl, Decidable.isTrue, Not, False.elim, Decidable.isFalse, True.intro]]
["notM",[Applicative, Bool, Functor.map, Applicative.toFunctor, not]]
["UInt64.decEq.proof_2",[Fin, UInt64.size, Not, Eq, UInt64, UInt64.mk, False, absurd]]
["Lean.groupKind",[Lean.Name.mkStr, Lean.Name.anonymous]]
["UInt64.mod",[UInt64, UInt64.mk, HMod.hMod, Fin, UInt64.size, instHMod, Fin.instModFin, UInt64.val]]
["StateT.tryFinally",[MonadFinally, Monad, MonadFinally.mk, StateT, Option, Bind.bind, Monad.toBind, Prod, MonadFinally.tryFinally', Option.some, Unit, Option.none, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk]]
["Lean.Parser.Tactic.simpPost",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol]]
["EStateM.Result.error.inj",[Eq, EStateM.Result, EStateM.Result.error, And, And.intro]]
["IO.FS.instBEqSystemTime",[BEq.mk, IO.FS.SystemTime, Int, UInt32, IO.FS.SystemTime.mk, Bool, and, Bool.true, BEq.beq, instBEq, Int.instDecidableEqInt, instDecidableEqUInt32, Bool.false]]
["Lean.defaultMaxRecDepth",[OfNat.ofNat, Nat, instOfNatNat]]
["Lean.Syntax.isIdent",[Lean.Syntax, Bool, Lean.SourceInfo, Substring, Lean.Name, List, Prod, String, Bool.true, Bool.false]]
["Array.eraseIdx'.proof_1",[Array, rfl, Nat, Array.size]]
["StateT.bind",[Monad, StateT, Bind.bind, Monad.toBind, Prod]]
["Substring.any",[Substring, Char, Bool, String, String.Pos, String.anyAux]]
["Int.natMod",[Int, Int.toNat, HMod.hMod, instHMod, Int.instModInt]]
["Measure",[InvImage, Nat, LT.lt, instLTNat]]
["eq_of_heq",[HEq]]
["Lean.Parser.Tactic.simpErase",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
["Array.swapAt",[Array, Fin, Array.size, Array.get, Array.set, Prod.mk]]
["Nat.zero_lt_succ",[Nat, Nat.succ_le_succ, OfNat.ofNat, instOfNatNat, Nat.zero_le]]
["Fin.mod.proof_1",[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt]]
["Lean.Name.noConfusionType",[Lean.Name, String, UInt64, Nat, Eq]]
["«term_≠_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["SeqRight.seqRight",[SeqRight]]
["ST.Ref.take",[MonadLiftT, ST, ST.Ref, liftM, ST.Prim.Ref.take]]
["Task.bind",[Task, optParam, Task.Priority, Task.Priority.default, Task.pure, Task.get]]
["USize.ofNat32.proof_1",[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, USize.size, Or, Eq, usize_size_eq, Unit, Nat.lt_trans, of_decide_eq_true, Nat.decLt, Eq.refl, Bool, Bool.true]]
["UInt32.mod",[UInt32, UInt32.mk, HMod.hMod, Fin, UInt32.size, instHMod, Fin.instModFin, UInt32.val]]
["Nat.add_lt_add_left",[Nat, LT.lt, instLTNat, Nat.lt_of_succ_le, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, LE.le, instLENat, Nat.add_le_add_left, Nat.succ_le_of_lt, Nat.add_succ]]
["instInhabitedUInt16.proof_1",[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt16.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
["Quot.liftBeta",[Eq, rfl, Quot.lift, Quot.mk]]
["optParam",[]]
["IO.Process.Stdio.noConfusion",[IO.Process.Stdio, Eq, noConfusionEnum, Nat, instDecidableEqNat, IO.Process.Stdio.toCtorIdx]]
["instStreamRangeNat",[Stream.mk, Std.Range, Nat, ite, Option, Prod, LT.lt, instLTNat, Std.Range.start, Std.Range.stop, Nat.decLt, Option.some, Prod.mk, Std.Range.mk, HAdd.hAdd, instHAdd, instAddNat, Std.Range.step, Option.none]]
["bool",[ToBool, Bool, ToBool.toBool, Unit]]
["UInt16.toUInt64",[UInt16, Nat.toUInt64, UInt16.toNat]]
["instInhabitedEIO",[Inhabited, inferInstanceAs, EStateM, IO.RealWorld, EStateM.instInhabitedEStateM]]
["ByteArray.append",[ByteArray, ByteArray.copySlice, OfNat.ofNat, Nat, instOfNatNat, ByteArray.size, Bool.false]]
["Lean.version.major",[Unit.unit]]
["instMonadEIO",[inferInstanceAs, Monad, EStateM, IO.RealWorld, EStateM.instMonadEStateM]]
["modifyThe",[MonadStateOf, MonadStateOf.modifyGet, PUnit, Prod.mk, PUnit.unit]]
["LawfulMonad.toLawfulApplicative",[Monad, LawfulMonad]]
["Prod.snd",[Prod]]
["String.foldlAux",[Char, String, String.Pos, String.foldlAux.loop]]
["«term_||_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["System.mkFilePath",[List, String, System.FilePath.mk, String.intercalate, Char.toString, System.FilePath.pathSeparator]]
["Lean.isLetterLike",[Char, or, and, Decidable.decide, LE.le, UInt32, instLEUInt32, OfNat.ofNat, instOfNatUInt32, Char.val, instDecidableLe, Ne, instDecidableNot, Eq, instDecidableEqUInt32]]
["IO.FS.Stream.write",[IO.FS.Stream]]
["Thunk.mk.sizeOf_spec",[SizeOf, Unit, Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["«term_<&>_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["instReprList",[Repr, Repr.mk, List, Nat, Std.ToFormat, Std.ToFormat.mk, repr, Std.Format, Std.Format.text, Std.Format.bracket, Std.Format.joinSep, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.line]]
["StdGen.mk.injEq",[Nat, Eq.propIntro, Eq, StdGen, StdGen.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["UInt64.div",[UInt64, UInt64.mk, HDiv.hDiv, Fin, UInt64.size, instHDiv, Fin.instDivFin, UInt64.val]]
["String.back",[String, String.get, String.prev, String.bsize]]
["tryFinally",[MonadFinally, Functor, Prod, MonadFinally.tryFinally', Option, Functor.map, Prod.fst]]
["List.beq",[BEq, List, Bool, List.below, Unit, List.nil, Bool.true, List.cons, and, BEq.beq, PProd.fst, PUnit, PProd, Bool.false]]
["List.length_replicate.aux",[Nat, List, Eq, List.length, List.replicate.loop, HAdd.hAdd, instHAdd, instAddNat, of_eq_true, Nat.zero, Eq.trans, True, congrArg, OfNat.ofNat, instOfNatNat, congrFun, Nat.zero_eq, Nat.zero_add, eq_self, List.cons, Nat.succ, congr, List.length_cons, Nat.add_succ, Nat.succ_add]]
["FloatArray.empty",[FloatArray.mkEmpty, OfNat.ofNat, Nat, instOfNatNat]]
["Lean.Macro.withIncRecDepth",[Lean.Syntax, Lean.MacroM, Bind.bind, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, MonadReader.read, instMonadReader, instMonadReaderOfReaderT, Bool, BEq.beq, Nat, instBEq, instDecidableEqNat, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth, Unit, MonadExcept.throw, instMonadExcept, ReaderT.instMonadExceptOfReaderT, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Lean.Macro.Exception.error, Lean.maxRecDepthErrorMessage, MonadWithReader.withReader, instMonadWithReader, instMonadWithReaderOfReaderT, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Lean.Macro.Context.ref]]
["Nat.mod.inductionOn",[Nat, And, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, HSub.hSub, instHSub, instSubNat, Not, Nat.div.inductionOn]]
["instInhabitedDepArrow",[Inhabited, Inhabited.mk, arbitrary]]
["instDecidableEqUInt64",[UInt64.decEq]]
["ExceptT.seqLeft_eq",[Monad, LawfulMonad, ExceptT]]
["Lean.Parser.Tactic.tacticShow_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
["ofBoolUsing_eq_true",[Decidable, Eq, Bool, toBoolUsing, Bool.true, of_decide_eq_true]]
["Lean.instQuoteSyntax",[Lean.Quote.mk, Lean.Syntax, id]]
["SeqLeft.seqLeft",[SeqLeft]]
["Quotient.ind₂",[Setoid, Quotient, Quotient.mk, Quotient.ind]]
["Std.Format.text.inj",[String, Eq, Std.Format, Std.Format.text]]
["Lean.Syntax.ident.sizeOf_spec",[Lean.SourceInfo, Substring, Lean.Name, List, Prod, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOf, SizeOf.mk, String.Pos, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOfName]]
["rfl",[rfl.proof_1]]
["List.length_replicate",[Nat, List, Eq, List.length, List.replicate.loop, HAdd.hAdd, instHAdd, instAddNat, List.nil, List.length_replicate.aux]]
["Except.ok.inj",[Eq, Except, Except.ok]]
["Lean.Parser.Tactic.anyGoals",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["unexpandProdMk",[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, Lean.Syntax.SepArray, Lean.Syntax.SepArray.mk, Lean.Syntax.getArgs, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
["Nat.sub_succ",[Nat, rfl, HSub.hSub, instHSub, instSubNat, Nat.succ]]
["Std.Range.forIn.loop",[Monad, Std.Range, Nat, ForInStep, Nat.below, ite, GE.ge, instLENat, Std.Range.stop, Nat.decLe, Pure.pure, Applicative.toPure, Monad.toApplicative, Unit, Nat.succ, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, Std.Range.step]]
["ByteArray.size",[ByteArray, Nat, Array, UInt8, Array.size]]
["Nat.decEq",[Bool, Eq, Nat.beq, Decidable, Nat, Nat.decEq.proof_1, Bool.true, Decidable.isTrue, Nat.eq_of_beq_eq_true, Bool.false, Decidable.isFalse, Nat.ne_of_beq_eq_false]]
["List.forIn_nil",[Monad, ForInStep, rfl, ForIn.forIn, List, List.instForInList, List.nil]]
["Nat.mod_eq",[Nat, dite, And, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HMod.hMod, instHMod, Nat.instModNat, HSub.hSub, instHSub, instSubNat, Not, Eq, congrFun, WellFounded.fix, WellFoundedRelation.rel, measure, id, WellFoundedRelation.wf, And.intro, Nat.sub_lt, Nat.lt_of_lt_of_le, WellFounded.fix_eq, ite, dif_eq_if]]
["optionCoe",[CoeTail.mk, Option, Option.some]]
["Array.forIn.loop",[Monad, Array, ForInStep, Nat, LE.le, instLENat, Array.size, Nat.below, OfNat.ofNat, instOfNatNat, Pure.pure, Applicative.toPure, Monad.toApplicative, HAdd.hAdd, instHAdd, instAddNat, Nat.succ]]
["Int.decLt",[Decidable, Int.NonNeg, Nat, Decidable.isTrue, Int.ofNat, Int.NonNeg.mk, Decidable.isFalse, Int.negSucc, Int, Eq, HEq, Eq.refl, HEq.refl, False, HSub.hSub, instHSub, Int.instSubInt, HAdd.hAdd, instHAdd, Int.instAddInt, OfNat.ofNat, hasOfNatOfCoe, instCoeNatInt, instOfNatNat]]
["Array.toListLitAux.proof_1",[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Nat.le_of_succ_le]]
["LawfulFunctor.noConfusionType",[Functor, LawfulFunctor, Eq, Functor.mapConst, Function.comp, Functor.map, Function.const, id]]
["Lean.Syntax.isAtom",[Lean.Syntax, Bool, Lean.SourceInfo, String, Bool.true, Bool.false]]
["ReprTuple.noConfusionType",[ReprTuple, List, Std.Format, Eq]]
["Nat.lt_wfRel",[WellFoundedRelation.mk, Nat, Nat.lt, Nat.lt_wfRel.proof_1]]
["String.str",[String.push]]
["MonadControl.liftWith",[MonadControl]]
["instMonadState",[MonadStateOf, MonadState.mk, getThe, MonadStateOf.set, Prod, MonadStateOf.modifyGet]]
["UInt8.decEq",[UInt8, Decidable, Eq, Fin, UInt8.size, dite, UInt8.mk, instDecidableEqFin, Decidable.isTrue, UInt8.decEq.proof_1, Not, Decidable.isFalse, UInt8.decEq.proof_2]]
["instAndOpUSize",[AndOp.mk, USize, USize.land]]
["instReprAtomNat",[ReprAtom.mk, Nat]]
["instHashableUInt32",[Hashable.mk, UInt32, UInt32.toUInt64]]
["instComplementUInt8",[Complement.mk, UInt8, UInt8.complement]]
["List.reverse_append",[List, Eq, List.reverse, HAppend.hAppend, instHAppend, List.instAppendList, of_eq_true, List.nil, Eq.trans, True, congr, congrArg, List.nil_append, List.reverse_nil, List.append_nil, eq_self, Eq.mpr, List.cons, List.cons_append, List.reverse_cons, congrFun, Eq.refl, List.append_assoc, rfl]]
["instHashableProd",[Hashable, Hashable.mk, Prod, UInt64, mixHash, Hashable.hash]]
["IO.FS.instLESystemTime",[leOfOrd, IO.FS.SystemTime, IO.FS.instOrdSystemTime]]
["Lean.Syntax.setArgs",[Lean.Syntax, Array, Lean.SyntaxNodeKind, Lean.Syntax.node]]
["String.Iterator.mk.injEq",[String, String.Pos, Eq.propIntro, Eq, String.Iterator, String.Iterator.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Monad.toBind",[Monad]]
["Eq.mpr_prop",[Eq, Eq.symm]]
["IO.Error.mkResourceBusy",[IO.Error.resourceBusy]]
["StateT.instLawfulMonadStateT.proof_1",[Monad, LawfulMonad, LawfulMonad.mk, StateT, StateT.instMonadStateT, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, StateT.ext, Functor.map, id, of_eq_true, Eq, Prod, StateT.run, Eq.trans, True, congrFun, congrArg, Prod.mk, Prod.fst, Prod.snd, StateT.run_map, funext, id_eq, Prod.ext, id_map', LawfulApplicative.toLawfulFunctor, LawfulMonad.toLawfulApplicative, eq_self, StateT.seqLeft_eq, StateT.seqRight_eq, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, Unit, congr, Bind.bind, Monad.toBind, StateT.run_seq, StateT.run_pure, LawfulMonad.pure_bind, Function.comp, Eq.mpr, StateT.run_bind, LawfulMonad.bind_pure_comp, LawfulMonad.bind_assoc]]
["Array.findSome!",[Inhabited, Array, Option, Array.findSome?, Unit, panicWithPosWithDecl, OfNat.ofNat, Nat, instOfNatNat]]
["StateRefT'.run'",[Monad, MonadLiftT, ST, StateRefT', Bind.bind, Monad.toBind, Prod, StateRefT'.run, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["UInt16.div",[UInt16, UInt16.mk, HDiv.hDiv, Fin, UInt16.size, instHDiv, Fin.instDivFin, UInt16.val]]
["«term%[_|_]»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false]]
["Id.pure_eq",[rfl, Id, Pure.pure, Applicative.toPure, Monad.toApplicative, Id.instMonadId]]
["EStateM.orElse",[outParam, EStateM.Backtrackable, EStateM, Unit, EStateM.Backtrackable.save, EStateM.Result, Unit.unit, EStateM.Backtrackable.restore]]
["List.drop",[Nat, List, Nat.below, Nat.succ, List.nil, PProd.fst, PUnit, PProd]]
["Nat.lt.base.proof_1",[Nat, Nat.le_refl, Nat.succ]]
["ptrAddrUnsafe",[OfNat.ofNat, USize, instOfNatUSize]]
["Char.ofNat.proof_1",[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
["System.instInhabitedFilePath",[Inhabited.mk, System.FilePath, System.FilePath.mk, arbitrary, String, String.instInhabitedString]]
["Std.Format.below",[Std.Format, PUnit, String, Int, PProd, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone, Nat]]
["Lean.ParserDescr.noConfusionType",[Lean.ParserDescr, Lean.Name, Eq, Lean.SyntaxNodeKind, Nat, String, Bool, optParam, Bool.false]]
["Classical.propComplete",[Or, Not, Classical.em, Eq, True, False, Or.inl, propext, Iff.intro, True.intro, Or.inr, False.elim]]
["instMonadWithReaderOfReaderT",[Monad, MonadWithReaderOf.mk, ReaderT]]
["EStateM.dummySave",[PUnit.unit]]
["Array.shrink",[Array, Nat, HSub.hSub, instHSub, instSubNat, Array.size, Array.shrink.loop]]
["System.FilePath.pathSeparator",[ite, Char, Eq, Bool, System.Platform.isWindows, Bool.true, instDecidableEqBool, Char.ofNat]]
["instBEqOrdering",[BEq.mk, Ordering, BEq.beq, Nat, instBEq, instDecidableEqNat, Ordering.toCtorIdx]]
["EmptyCollection.emptyCollection",[EmptyCollection]]
["List.toArray",[List, List.toArrayAux, Array.mkEmpty, List.redLength]]
["instModUInt8",[Mod.mk, UInt8, UInt8.mod]]
["Array.forIn.loop.proof_2",[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.succ, Nat.lt_succ_self]]
["«term_<<<_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["instToStringProd",[ToString, ToString.mk, Prod, String, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString]]
["Array.shrink.loop",[Nat, Array, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, Array.pop]]
["Lean.Syntax.isFieldIdx?",[Lean.Syntax, Lean.SyntaxNodeKind, Option, String, Option.some, Option.none, Nat, Lean.Syntax.isLit?, Lean.Syntax.decodeNatLitVal?, Lean.fieldIdxKind]]
["ST.instInhabitedRef.proof_1",[Inhabited, Nonempty.intro, arbitrary]]
["IO.Error.mkIllegalOperation",[IO.Error.illegalOperation]]
["Function.comp",[]]
["Nat.add",[Nat, Nat.below, Nat.zero, Nat.succ, PProd.fst, PUnit, PProd]]
["precMin",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["Fin.land.proof_1",[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, Nat.land]]
["Lean.NameGenerator.mk.injEq",[Lean.Name, Nat, Eq.propIntro, Eq, Lean.NameGenerator, Lean.NameGenerator.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["instReprChar",[Repr.mk, Char, Nat, Std.Format.text, Char.quote]]
["Subsingleton.elim.proof_1",[Subsingleton, Subsingleton.allEq]]
["Prod.rprod",[WellFoundedRelation, WellFoundedRelation.mk, Prod, Prod.RProd, WellFoundedRelation.rel, Prod.rprod.proof_1]]
["Subrelation.accessible.proof_1",[Subrelation, Acc, Acc.intro]]
["Classical.byContradiction",[Not, False, Decidable.byContradiction, Classical.propDecidable]]
["Except.pure",[Except.ok]]
["String.trimRight",[String, Substring.toString, Substring.trimRight, String.toSubstring]]
["IO.Error.unsupportedOperation.sizeOf_spec",[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar]]
["Nat.max",[Nat, ite, LE.le, instLENat, Nat.decLe]]
["Std.Range.start",[Std.Range]]
["Int.mod",[Int, Nat, Int.ofNat, HMod.hMod, instHMod, Nat.instModNat, Nat.succ, Neg.neg, Int.instNegInt]]
["Array.mapMUnsafe",[Monad, Array, USize, USize.ofNat, Array.size, NonScalar, PNonScalar, unsafeCast, OfNat.ofNat, instOfNatUSize, Array.mapMUnsafe.map]]
["Std.Format.MonadPrettyFormat.endTags",[Std.Format.MonadPrettyFormat]]
["IO.FS.SystemTime.sec",[IO.FS.SystemTime]]
["IO.FileRight.mk.injEq",[IO.AccessRight, Eq.propIntro, Eq, IO.FileRight, IO.FileRight.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Std.Format.ibelow",[Std.Format, True, String, Int, And, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone, Nat]]
["Lean.Macro.Context.currMacroScope",[Lean.Macro.Context]]
["Array.instReprArray",[Repr, Repr.mk, Array, Nat, Std.ToFormat, Std.ToFormat.mk, repr, Std.Format, ite, Eq, Bool, BEq.beq, instBEq, instDecidableEqNat, Array.size, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Std.Format.text, Std.Format.bracketFill, Std.Format.joinSep, Array.toList, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.line]]
["FloatSpec.float",[FloatSpec]]
["Acc.brecOn",[Acc, Acc.below, Acc.below.intro]]
["instSubsingletonStateM.proof_1",[Subsingleton, Subsingleton.intro, StateM, funext, Id, Prod, Eq, Eq.mpr, Prod.mk, Eq.refl, Subsingleton.elim, rfl]]
["Lean.mkNullNode",[optParam, Array, Lean.Syntax, List.toArray, List.nil, Lean.Syntax.node, Lean.nullKind]]
["Lean.expandBrackedBindersAux.loop",[Lean.Syntax, Array, Nat, Lean.MacroM, Nat.below, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Nat.succ, Lean.Syntax.getArgs, Lean.Syntax.getOp, Array.getOp, Lean.instInhabitedSyntax, OfNat.ofNat, instOfNatNat, Bind.bind, Monad.toBind, Lean.expandExplicitBindersAux, Option.some, PProd.fst, PUnit, PProd]]
["MProd.fst",[MProd]]
["IO.Error.mkInvalidArgumentFile",[Function.comp, String, Option, UInt32, IO.Error, IO.Error.invalidArgument, Option.some]]
["ExceptCpsT.instLawfulMonadExceptCpsT",[ExceptCpsT.instLawfulMonadExceptCpsT.proof_1]]
["instXorUSize",[Xor.mk, USize, USize.xor]]
["instToStringIterator",[ToString.mk, String.Iterator, String.Iterator.remainingToString]]
["Lean.Macro.instMonadRefMacroM",[Lean.MonadRef.mk, Lean.MacroM, Bind.bind, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Syntax, MonadReader.read, instMonadReader, instMonadReaderOfReaderT, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Macro.Context.ref, MonadWithReader.withReader, instMonadWithReader, instMonadWithReaderOfReaderT, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth]]
["Squash.lift.proof_1",[Subsingleton, True, Subsingleton.elim]]
["Std.Format.instCoeStringFormat",[Coe.mk, String, Std.Format, Std.Format.text]]
["ReprTuple.reprTuple",[ReprTuple]]
["instDivUSize",[Div.mk, USize, USize.div]]
["Quotient.mk",[Setoid, Quot.mk, Setoid.r]]
["instDecidableEqUInt8",[UInt8.decEq]]
["Nat.instAndOpNat",[AndOp.mk, Nat, Nat.land]]
["instReprUInt8",[Repr.mk, UInt8, Nat, repr, instReprNat, UInt8.toNat]]
["IO.Error.resourceExhausted.sizeOf_spec",[Option, String, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["Lean.Parser.Tactic.Conv.arg",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["Option.isSome",[Option, Bool, Bool.true, Unit, Bool.false]]
["ShiftLeft.shiftLeft",[ShiftLeft]]
["List.init",[List, List.below, Unit, List.nil, List.cons, PProd.fst, PUnit, PProd]]
["IO.println",[ToString, IO.print, String, instToStringString, String.push, ToString.toString, Char.ofNat]]
["Array.swap!",[Array, dite, LT.lt, Nat, instLTNat, Array.size, Nat.decLt, Array.swap, Fin.mk, Not, panicWithPosWithDecl, Array.instInhabitedArray, OfNat.ofNat, instOfNatNat]]
["IO.Error.mkNoSuchThingFile",[Function.comp, String, Option, UInt32, IO.Error, IO.Error.noSuchThing, Option.some]]
["Lean.Syntax.getOptional?",[Lean.Syntax, Option, Lean.SyntaxNodeKind, Array, ite, Eq, Bool, and, BEq.beq, Lean.Name.instBEqName, Lean.nullKind, Nat, instBEq, instDecidableEqNat, Array.size, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Option.some, Array.get!, Lean.instInhabitedSyntax, Option.none]]
["Char.lt",[Char, LT.lt, UInt32, instLTUInt32, Char.val]]
["instAndOpUInt32",[AndOp.mk, UInt32, UInt32.land]]
["FloatSpec.val",[FloatSpec]]
["instHashableString",[Hashable.mk, String, String.hash]]
["IO.Error.mkAlreadyExistsFile",[Function.comp, String, Option, UInt32, IO.Error, IO.Error.alreadyExists, Option.some]]
["IO.FS.Mode.write.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["ExceptCpsT.instMonadExceptCpsT",[Monad.mk, ExceptCpsT, Applicative.mk, Functor.mk, Pure.mk, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk]]
["instDecidableIff",[Decidable, dite, Iff, Decidable.isTrue, instDecidableIff.proof_1, Not, Decidable.isFalse, instDecidableIff.proof_2, instDecidableIff.proof_3, instDecidableIff.proof_4]]
["String.map",[Char, String, String.mapAux, OfNat.ofNat, String.Pos, instOfNatNat]]
["Lean.Parser.Tactic.Conv.convRight",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["instLTUInt8",[LT.mk, UInt8, UInt8.lt]]
["DoResultBC.break.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["Lean.expandBrackedBinders",[Lean.Name, Lean.Syntax, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.MonadRef.getRef, Lean.Macro.instMonadRefMacroM, Lean.mkIdentFrom, Lean.expandBrackedBindersAux, List.toArray, List.cons, List.nil]]
["Nat.lt_of_succ_lt",[Nat, Nat.le_of_succ_le, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
["«term↑_»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Lean.Name.toString",[Lean.Name, optParam, Bool, Bool.true, Lean.Name.toStringWithSep, and, not, Lean.Name.isInaccessibleUserName, Lean.Name.hasMacroScopes, Lean.Name.toString.maybePseudoSyntax]]
["Nat.succ.injEq",[Nat, Eq.propIntro, Eq, Nat.succ, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Int.neg",[Int, Nat, Int.negOfNat, Int.ofNat, Nat.succ]]
["ReaderT.instLawfulMonadReaderT.proof_1",[Monad, LawfulMonad, LawfulMonad.mk, ReaderT, ReaderT.instMonadReaderT, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, ReaderT.ext, Functor.map, id, of_eq_true, Eq, ReaderT.run, Eq.trans, True, congrFun, congrArg, ReaderT.run_map, LawfulFunctor.id_map, LawfulApplicative.toLawfulFunctor, LawfulMonad.toLawfulApplicative, eq_self, SeqLeft.seqLeft, Applicative.toSeqLeft, Unit, Seq.seq, Applicative.toSeq, Function.const, Eq.mpr, congr, ReaderT.run_seqLeft, ReaderT.run_seq, LawfulApplicative.seqLeft_eq, SeqRight.seqRight, Applicative.toSeqRight, ReaderT.run_seqRight, LawfulApplicative.seqRight_eq, Pure.pure, Applicative.toPure, ReaderT.run_pure, LawfulApplicative.pure_seq, Bind.bind, Monad.toBind, Function.comp, ReaderT.run_bind, funext, LawfulMonad.bind_pure_comp, LawfulMonad.pure_bind, LawfulMonad.bind_assoc]]
["Lean.MonadRef.withRef",[Lean.MonadRef]]
["Nat.allM.loop",[Monad, Nat, Bool, Nat.below, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.true, Nat.succ, Bind.bind, Monad.toBind, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, PProd.fst, PUnit, PProd, Bool.false]]
["HEq.rfl",[HEq.rfl.proof_1]]
["StateT.run_bind",[Monad, StateT, bind_congr, Prod, Monad.toBind, Prod.fst, Prod.snd, Eq, Prod.mk, rfl, Eq.symm, Eq.refl]]
["UInt8.toNat",[UInt8, Fin.val, UInt8.size, UInt8.val]]
["IO.AccessRight.write",[IO.AccessRight]]
["Lean.Syntax.instToStringSyntax",[ToString.mk, Lean.Syntax, Function.comp, Std.Format, String, ToString.toString, instToStringFormat, Std.ToFormat.format, Lean.Syntax.instToFormatSyntax]]
["«term_>_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Lean.Name.isInaccessibleUserName",[Lean.Name, Bool, Lean.Name.below, String, UInt64, Lean.Name.str, or, String.contains, Char.ofNat, BEq.beq, instBEq, instDecidableEqString, Nat, Lean.Name.num, PProd.fst, PUnit, PProd, Bool.false]]
["UInt32.val",[UInt32]]
["List.any",[List, Bool, List.foldr, or, Bool.false]]
["Nat.toSuperscriptString",[Nat, List.asString, Nat.toSuperDigits]]
["Id.finally",[MonadFinally.mk, Id, Option, Option.some, Pure.pure, Applicative.toPure, Monad.toApplicative, Id.instMonadId, Prod, Prod.mk]]
["EStateM.nonBacktrackable",[EStateM.Backtrackable.mk, PUnit, EStateM.dummySave, EStateM.dummyRestore]]
["UInt64.add",[UInt64, UInt64.mk, HAdd.hAdd, Fin, UInt64.size, instHAdd, Fin.instAddFin, UInt64.val]]
["instDecidableEqProd",[DecidableEq, Prod, Decidable, Eq, Prod.mk, decEq, Decidable.isTrue, instDecidableEqProd.proof_1, Not, Decidable.isFalse, instDecidableEqProd.proof_2, instDecidableEqProd.proof_3]]
["List.unzip",[List, Prod, List.below, Unit, List.nil, Prod.mk, List.cons, PProd.fst, PUnit, PProd]]
["Nat.gt_of_not_le",[Nat, Not, LE.le, instLENat, Or, LT.lt, instLTNat, GE.ge, Nat.lt_or_ge, GT.gt, absurd]]
["Bool.toUInt64",[Bool, ite, UInt64, Eq, Bool.true, instDecidableEqBool, OfNat.ofNat, instOfNatUInt64]]
["emptyWf.proof_1",[WellFounded.intro, emptyRelation, Acc.intro, False, Eq, Acc, Eq.refl]]
["Quot.recOnSubsingleton",[Quot, Subsingleton, Quot.mk, Quot.rec, Quot.recOnSubsingleton.proof_1]]
["StateCpsT.runK_bind_pure",[Monad, StateCpsT, rfl, StateCpsT.runK, Bind.bind, Monad.toBind, StateCpsT.instMonadStateCpsT, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["USize.div",[USize, USize.mk, HDiv.hDiv, Fin, USize.size, instHDiv, Fin.instDivFin, USize.val]]
["CoeFun.coe",[CoeFun]]
["Array.set",[Array, Array.mk, List.set, Array.data, Fin.val, Array.size]]
["Array.map",[Array, Id.run, Array.mapM, Id, Id.instMonadId]]
["instDecidableEqSum.proof_2",[Not, Eq, Sum, Sum.inl, False, absurd]]
["Int.instLEInt",[LE.mk, Int, Int.le]]
["FloatSpec.lt",[FloatSpec]]
["OptionT.instMonadExceptOfUnitOptionT",[Monad, MonadExceptOf.mk, Unit, OptionT, OptionT.fail, OptionT.tryCatch]]
["Array.mapM",[Monad, Array, Array.foldlM, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.push, Array.mkEmpty, Array.size, OfNat.ofNat, Nat, instOfNatNat]]
["Array.getD",[Array, Nat, dite, LT.lt, instLTNat, Array.size, Nat.decLt, Array.get, Fin.mk, Not]]
["System.instDecidableEqFilePath",[System.FilePath, String, System.FilePath.mk, Decidable, Eq, dite, instDecidableEqString, Decidable.isTrue, rfl, Not, Decidable.isFalse, False]]
["Lean.nameLitKind",[Lean.Name.mkStr, Lean.Name.anonymous]]
["reprArg",[Repr, Repr.reprPrec, OfNat.ofNat, Nat, instOfNatNat]]
["Array.mkEmpty",[Array.mk, List.nil]]
["Or.intro_left",[Or.inl]]
["Ne.elim",[Ne]]
["ST.mkRef",[MonadLiftT, ST, liftM, ST.Ref, ST.Prim.mkRef]]
["Subarray.start",[Subarray]]
["Eq.substr",[Eq, Eq.symm]]
["Array.sequenceMap.loop",[Monad, Array, Nat, Nat.below, dite, LT.lt, instLTNat, Array.size, Nat.decLt, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Nat.succ, Bind.bind, Monad.toBind, Array.get, Fin.mk, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.push, Not]]
["instDecidableEqUInt32",[UInt32.decEq]]
["hasOfNatOfCoe",[Nat, Coe, OfNat, OfNat.mk, coe, OfNat.ofNat, coeOfHTCT, coeOfTC, coeBase]]
["String.nextUntil",[String, Char, Bool, String.Pos, String.nextWhile, not]]
["«stx_<|>_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Lean.Syntax.toNat",[Lean.Syntax, Option, Nat, Lean.Syntax.isNatLit?, Unit, OfNat.ofNat, instOfNatNat]]
["MonadExceptOf.tryCatch",[MonadExceptOf]]
["PSigma.lexNdepWf.proof_1",[WellFounded, WellFounded.intro, PSigma, PSigma.lexNdep, Acc, PSigma.lexAccessible, WellFounded.apply]]
["IO.Error.unsupportedOperation.injEq",[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.unsupportedOperation, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["ReaderT.run_monadLift",[MonadLiftT, rfl, ReaderT.run, MonadLiftT.monadLift, ReaderT, instMonadLiftT, ReaderT.instMonadLiftReaderT]]
["Lean.unbracketedExplicitBinders",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.binderIdent, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat]]
["Fin.decLt",[Nat, Fin, Nat.decLt, Fin.val]]
["HShiftRight.noConfusionType",[outParam, HShiftRight, Eq]]
["Lean.Name.num.injEq",[Lean.Name, Nat, UInt64, Eq.propIntro, Eq, Lean.Name.num, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["List.filterM",[Monad, Bool, List, Bind.bind, Monad.toBind, List.filterAuxM, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, List.reverse]]
["instXorUInt16",[Xor.mk, UInt16, UInt16.xor]]
["PSigma.lexAccessible",[PSigma.lexAccessible.proof_1]]
["Nat.forM.loop",[Monad, Nat, Unit, Nat.below, Pure.pure, Applicative.toPure, Monad.toApplicative, Unit.unit, Nat.succ, Bind.bind, Monad.toBind, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, PUnit, PProd.fst, PProd]]
["PUnit.unit.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["List.isEqv",[List, Bool, List.below, List.nil, Bool.true, List.cons, and, PProd.fst, PUnit, PProd, Bool.false]]
["Nat.mul_lt_mul_of_pos_right",[Nat, LT.lt, instLTNat, GT.gt, OfNat.ofNat, instOfNatNat, HMul.hMul, instHMul, instMulNat, Nat.mul_lt_mul_of_pos_left, Nat.mul_comm]]
["IO.Error.mkAlreadyExists",[IO.Error.alreadyExists, Option.none, String]]
["unexpandSorryAx",[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
["Nat.mul",[Nat, Nat.below, OfNat.ofNat, instOfNatNat, Nat.succ, Nat.add, PProd.fst, PUnit, PProd]]
["Nat.add_right_cancel",[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.add_left_cancel, Eq.mp, Eq.refl, Nat.add_comm]]
["Substring.splitOn",[Substring, optParam, String, ite, List, Eq, Bool, BEq.beq, instBEq, instDecidableEqString, Bool.true, instDecidableEqBool, List.cons, List.nil, String.Pos, OfNat.ofNat, instOfNatNat, Substring.splitOn.loop]]
["Lean.Syntax.decodeNatLitVal?",[String, Nat, String.length, ite, Option, Eq, Bool, BEq.beq, instBEq, instDecidableEqNat, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Option.none, Char, String.get, String.Pos, instDecidableEqChar, Char.ofNat, Option.some, or, Char.isDigit]]
["ite_congr",[Decidable, Eq, Not, Or, Decidable.em, ite, Or.inl, Eq.mpr, Eq.refl, if_pos, Eq.symm, Or.inr, if_neg]]
["Lean.replaceRef",[Lean.Syntax, Option, String.Pos, Lean.Syntax.getPos?, Bool.false]]
["instReprUInt64",[Repr.mk, UInt64, Nat, repr, instReprNat, UInt64.toNat]]
["instDecidableEqChar",[Char, Decidable, Eq, UInt32, Char.val, decEq, instDecidableEqUInt32, Decidable.isTrue, Char.eq_of_val_eq, Not, Decidable.isFalse, Char.ne_of_val_ne]]
["instToStringPUnit",[ToString.mk, PUnit]]
["Lean.Meta.Simp.Config.decide",[Lean.Meta.Simp.Config]]
["OptionT.instMonadOptionT",[Monad, Monad.mk, OptionT, Applicative.mk, Functor.mk, Pure.mk, OptionT.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk, OptionT.bind]]
["Lean.Syntax.mkStrLit",[String, optParam, Lean.SourceInfo, Lean.SourceInfo.none, Lean.Syntax.mkLit, Lean.strLitKind, String.quote]]
["instXorUInt8",[Xor.mk, UInt8, UInt8.xor]]
["Lean.nullKind",[Lean.Name.mkStr, Lean.Name.anonymous]]
["Option.toBool",[Option, Bool, Bool.true, Unit, Bool.false]]
["true_or",[propext, Or, True, Iff.intro, trivial, Or.inl]]
["instTransEq_1",[Trans.mk, Eq, instTransEq_1.proof_1]]
["ForInStep.yield.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["Lean.Name.modifyBase",[Lean.Name, ite, Eq, Bool, Lean.Name.hasMacroScopes, Bool.true, instDecidableEqBool, Lean.MacroScopesView, Lean.extractMacroScopes, Lean.MacroScopesView.review, Lean.MacroScopesView.mk, Lean.MacroScopesView.name, Lean.MacroScopesView.imported, Lean.MacroScopesView.mainModule, Lean.MacroScopesView.scopes]]
["IO.Error.mkEofError",[Unit, IO.Error.unexpectedEof]]
["Array.data",[Array]]
["instToStringId_1",[ToString, inferInstanceAs]]
["ST.Ref.ptrEq",[MonadLiftT, ST, ST.Ref, liftM, Bool, ST.Prim.Ref.ptrEq]]
["String.find",[String, Char, Bool, String.findAux, String.bsize, OfNat.ofNat, String.Pos, instOfNatNat]]
["Array.insertionSort.swapLoop.proof_2",[Nat, Array, LT.lt, instLTNat, Array.size, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Eq.mpr, Array.swap, Fin.mk, Nat.lt_trans, Nat.succ, Nat.lt_succ_self, Eq.symm, Eq.refl, Array.size_swap]]
["Lean.expandExplicitBindersAux",[Lean.Syntax, Array, Option, Nat, Lean.MacroM, Array.size, Lean.expandExplicitBindersAux.loop]]
["id_map'",[Functor, LawfulFunctor, LawfulFunctor.id_map]]
["Lean.Parser.Tactic.refine'",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
["Lean.Meta.Rewrite.Config.mk.inj",[Lean.Meta.TransparencyMode, Bool, Eq, Lean.Meta.Rewrite.Config, Lean.Meta.Rewrite.Config.mk, And, And.intro]]
["ExceptT.run_map",[Monad, LawfulMonad, ExceptT, Eq.mpr, Eq, Except, ExceptT.run, Functor.map, Applicative.toFunctor, Monad.toApplicative, ExceptT.instMonadExceptT, Except.map, ExceptT.mk, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Except.ok, Except.error, congrArg, map_eq_pure_bind, bind_congr, of_eq_true, eq_self, Eq.symm, Eq.refl]]
["Array.insertAt",[Array, Nat, ite, GT.gt, instLTNat, Array.size, Nat.decLt, panicWithPosWithDecl, Array.instInhabitedArray, OfNat.ofNat, instOfNatNat, Array.push, Array.insertAtAux]]
["Lean.MonadRef.noConfusionType",[Lean.MonadRef, Lean.Syntax, Eq]]
["instOrdUInt8",[Ord.mk, UInt8, compareOfLessAndEq, instLTUInt8, instDecidableLt_1, instDecidableEqUInt8]]
["Array.foldrM.fold.proof_2",[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.succ, Nat.lt_succ_self]]
["Nat.toDigits",[Nat, Nat.toDigitsCore, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, List.nil, Char]]
["UInt8.decEq.proof_1",[Fin, UInt8.size, Eq, UInt8, UInt8.mk, rfl]]
["WellFounded.fixFEq.proof_1",[Acc, Eq, WellFounded.fixF, Acc.inv, rfl, Acc.intro]]
["Std.instInhabitedFormat",[Inhabited.mk, Std.Format, Std.Format.nil]]
["instDecidableEqPUnit",[PUnit, Decidable.isTrue, Eq, PUnit.subsingleton]]
["ShiftLeft.noConfusionType",[ShiftLeft, Eq]]
["UInt8.ofNatCore",[LT.lt, Nat, instLTNat, UInt8.size, UInt8.mk, Fin.mk]]
["List.length_concat",[List, Eq, Nat, List.length, List.concat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, rfl, List.nil, of_eq_true, List.cons, Eq.trans, Nat.succ, True, congr, congrArg, List.length_cons, congrFun, eq_self]]
["System.Platform.isOSX",[System.Platform.getIsOSX, Unit.unit]]
["Lean.Name.toStringWithSep",[String, Bool, Lean.Name, Lean.Name.below, Unit, Lean.Name.anonymous, UInt64, Lean.Name.str, Lean.Name.toStringWithSep.maybeEscape, Nat, Lean.Name.num, ToString.toString, instToStringNat, HAppend.hAppend, instHAppend, String.instAppendString, PProd.fst, PUnit, PProd, Nat.repr]]
["EStateM.bind",[EStateM, EStateM.Result, EStateM.Result.error]]
["Lean.Parser.Tactic.injection",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
["USize.land",[USize, USize.mk, Fin.land, USize.size, USize.val]]
["Lean.Parser.Tactic.done",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["Lean.Parser.Tactic.tacticErw__",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq, Lean.ParserDescr.unary, Lean.Parser.Tactic.location]]
["IO.Process.SpawnArgs.toStdioConfig",[IO.Process.SpawnArgs]]
["Array.ofSubarray",[Subarray, Array, Array.mkEmpty, HSub.hSub, Nat, instHSub, instSubNat, Subarray.stop, Subarray.start, Bind.bind, Id, Monad.toBind, Id.instMonadId, ForIn.forIn, Subarray.instForInSubarray, Array.push, PUnit, ForInStep, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, ForInStep.yield]]
["instToStringFloatArray",[ToString.mk, FloatArray, List.toString, Float, instToStringFloat, FloatArray.toList]]
["«term~~~_»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Array.findIdx?.loop",[Array, Bool, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Array.size, Option, Nat.below, dite, LT.lt, instLTNat, Nat.decLt, OfNat.ofNat, instOfNatNat, False.elim, Array.findIdx?.loop.proof_1, Nat.succ, ite, Array.get, Fin.mk, Bool.true, instDecidableEqBool, Option.some, Not, Option.none]]
["Option.eq_none_of_isNone",[Option, Eq, Bool, Option.isNone, Bool.true, Option.none, rfl]]
["Sum.inr.inj",[Eq, Sum, Sum.inr]]
["PSigma.snd",[PSigma]]
["Nat.mod",[WellFounded.fix, Nat, WellFoundedRelation.rel, measure, id, Nat.mod.proof_1, LT.lt, instLTNat, dite, And, OfNat.ofNat, instOfNatNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HSub.hSub, instHSub, instSubNat, And.intro, Nat.sub_lt, Nat.lt_of_lt_of_le, Not]]
["StateRefT'.lift",[ST.Ref]]
["IO.FS.Mode.toCtorIdx",[IO.FS.Mode, Nat, OfNat.ofNat, instOfNatNat]]
["Array.pop",[Array, Array.mk, List.dropLast, Array.data]]
["«term¬_»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Nat.add_left_comm",[Nat, Eq.mpr, Eq, HAdd.hAdd, instHAdd, instAddNat, Eq.refl, Eq.symm, Nat.add_assoc, Nat.add_comm, rfl]]
["Lean.SourceInfo.getPos?",[Lean.SourceInfo, optParam, Bool, Bool.false, Option, String.Pos, Substring, Option.some, Option.none]]
["CoeDep.noConfusionType",[CoeDep, Eq]]
["Lean.Meta.Simp.ConfigCtx.noConfusionType",[Lean.Meta.Simp.ConfigCtx, Lean.Meta.Simp.Config, Eq]]
["Std.Format.instInhabitedSpaceResult",[Inhabited.mk, arbitrary, Bool, instInhabitedBool, Nat, instInhabitedNat]]
["Fin.instInhabitedFinHAdd",[Nat, Inhabited.mk, Fin, OfNat.ofNat, Fin.instOfNatFinHAdd]]
["Lean.Syntax.node.sizeOf_spec",[Lean.SyntaxNodeKind, Array, Lean.Syntax, congrArg, Nat, List, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, SizeOf.sizeOf, instSizeOfName, Lean.SourceInfo, String, instSizeOf, SizeOf.mk, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, Substring, Lean.Name, Prod, String.Pos, Nat.add, Eq, Eq.trans, Array.mk, Eq.refl, List.nil, List.cons, Eq.symm, List.cons.sizeOf_spec, Array.mk.sizeOf_spec]]
["Lean.Parser.Tactic.tacticAdmit",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["type_eq_of_heq.proof_1",[HEq, HEq.ndrecOn, Eq, Eq.refl]]
["Prod.anyI",[Nat, Bool, Prod, Nat.anyAux, Prod.snd, HSub.hSub, instHSub, instSubNat, Prod.fst]]
["Lean.Parser.Tactic.clear",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
["Lean.Macro",[Lean.Syntax, Lean.MacroM]]
["UInt32.add",[UInt32, UInt32.mk, HAdd.hAdd, Fin, UInt32.size, instHAdd, Fin.instAddFin, UInt32.val]]
["Nat.mod_lt",[Nat, Nat.mod.inductionOn, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, LT.lt, HMod.hMod, instHMod, Nat.instModNat, And, LE.le, instLENat, HSub.hSub, instHSub, instSubNat, Not]]
["HasEquiv.Equiv",[HasEquiv]]
["Repr.reprPrec",[Repr]]
["StateT.orElse",[Alternative, StateT, Unit, HOrElse.hOrElse, Prod, instHOrElse, instOrElse, Unit.unit]]
["Lean.Parser.Tactic.Conv.convApply_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
["Except.error.inj",[Eq, Except, Except.error]]
["Lean.instQuoteBool",[Lean.Quote.mk, Bool, Lean.Syntax, Unit, Lean.mkCIdent, Lean.Name.mkStr, Lean.Name.anonymous]]
["Std.Range.«term[_:_:_]»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Char.noConfusionType",[Char, UInt32, UInt32.isValidChar, Eq]]
["Int.instAddInt",[Add.mk, Int, Int.add]]
["Array.forRevM",[Monad, PUnit, Array, optParam, Nat, Array.size, OfNat.ofNat, instOfNatNat, Array.foldrM, PUnit.unit]]
["Classical.typeDecidableEq",[inferInstance, Decidable, Eq, Classical.propDecidable]]
["instForIn",[outParam, Stream, ForIn.mk, Monad, Stream.forIn]]
["Nat.lt_succ_of_le",[Nat, Nat.succ_le_succ]]
["instReprAtomUInt32",[ReprAtom.mk, UInt32]]
["Complement.noConfusionType",[Complement, Eq]]
["IO.Error.protocolError.sizeOf_spec",[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar]]
["IO.mapTasks",[List, IO, Task, optParam, Task.Priority, Task.Priority.default, Except, IO.Error, List.nil, IO.mapTasks.go]]
["IO.Error.alreadyExists.injEq",[Option, String, UInt32, Eq.propIntro, Eq, IO.Error, IO.Error.alreadyExists, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["instOfNatUInt32",[Nat, OfNat.mk, UInt32, UInt32.ofNat]]
["instDecidableArrow.proof_3",[Not, absurd]]
["UInt32.toNat",[UInt32, Fin.val, UInt32.size, UInt32.val]]
["Eq.propIntro",[propext, Iff.intro]]
["LawfulApplicative.noConfusionType",[Applicative, LawfulApplicative, LawfulFunctor, Applicative.toFunctor, Eq, SeqLeft.seqLeft, Applicative.toSeqLeft, Unit, Seq.seq, Applicative.toSeq, Functor.map, Function.const, SeqRight.seqRight, Applicative.toSeqRight, id, Pure.pure, Applicative.toPure, Function.comp]]
["Quotient.exact",[Setoid, Eq, Quotient, Quotient.mk, Quotient.liftOn₂, HasEquiv.Equiv, instHasEquiv, propext, Iff.intro, Setoid.trans, Setoid.symm, Quot.inductionOn, Setoid.r, Quot, Setoid.refl]]
["Array.swap.proof_1",[Array, Eq.symm, Nat, Array.size, Array.set, Array.get, Array.size_set]]
["«term_>=_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Char.instDecidableLe",[Char, UInt32.decLe, Char.val]]
["ByteArray.findIdx?",[ByteArray, UInt8, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, Option, ByteArray.findIdx?.loop]]
["Lean.Name.hasMacroScopes",[Lean.Name, Bool, Lean.Name.below, String, UInt64, Lean.Name.str, BEq.beq, instBEq, instDecidableEqString, Nat, Lean.Name.num, PProd.fst, PUnit, PProd, Bool.false]]
["Array.instCoeSubarrayArray",[Coe.mk, Subarray, Array, Array.ofSubarray]]
["instMonadLiftT",[MonadLift, MonadLiftT, MonadLiftT.mk, MonadLift.monadLift, MonadLiftT.monadLift]]
["Std.Format.tag.inj",[Nat, Std.Format, Eq, Std.Format.tag, And, And.intro]]
["Nat.gcd.proof_1",[WellFoundedRelation.wf, Nat, measure, id]]
["Applicative.toPure",[Applicative]]
["strictOr",[Bool, or]]
["IO.FS.writeFile",[System.FilePath, String, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle, Unit, IO.FS.Handle.mk, IO.FS.Mode.write, Bool.false, IO.FS.Handle.putStr]]
["Nat.lt_or_ge",[Nat, Or, LT.lt, instLTNat, GE.ge, instLENat, Nat.below, Unit, Nat.zero, Or.inr, Nat.zero_le, Nat.succ, PProd.fst, PUnit, PProd, Or.inl, Nat.le_succ_of_le, Eq, Nat.eq_or_lt_of_le, Nat.le_refl]]
["IO.FS.SystemTime.mk.injEq",[Int, UInt32, Eq.propIntro, Eq, IO.FS.SystemTime, IO.FS.SystemTime.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Lean.Parser.Tactic.Conv.conv.quot",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
["String.Iterator.mk.inj",[String, String.Pos, Eq, String.Iterator, String.Iterator.mk, And, And.intro]]
["instLEUInt8",[LE.mk, UInt8, UInt8.le]]
["Id",[]]
["IO.Error.invalidArgument.inj",[Option, String, UInt32, Eq, IO.Error, IO.Error.invalidArgument, And, And.intro]]
["Add.noConfusionType",[Add, Eq]]
["ne_false_of_eq_true",[Bool, Eq, Bool.true, Not, Bool.false, False]]
["toBoolUsing",[Decidable, Decidable.decide]]
["Xor.xor",[Xor]]
["Std.Format.noConfusionType",[Std.Format, String, Int, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone, Nat, Eq]]
["Lean.Name.below",[Lean.Name, PUnit, String, UInt64, PProd, Nat]]
["Substring.hasBeq",[BEq.mk, Substring, Substring.beq]]
["Array.appendList",[Array, List, List.foldl, Array.push]]
["System.FilePath.isRelative",[System.FilePath, not, System.FilePath.isAbsolute]]
["Char.toUpper",[Char, Nat, Char.toNat, ite, And, GE.ge, instLENat, OfNat.ofNat, instOfNatNat, LE.le, instDecidableAnd, Nat.decLe, Char.ofNat, HSub.hSub, instHSub, instSubNat]]
["IO.print",[ToString, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Stream, Unit, IO.getStdout, IO.FS.Stream.putStr, ToString.toString]]
["Prod.ext",[Prod, Eq, Prod.mk, Prod.fst, Prod.snd, rfl, Eq.symm, Eq.refl]]
["instDecidableEqSum.proof_4",[Not, Eq, Sum, Sum.inr, False, absurd]]
["List.toFloatArray.loop",[List, Float, FloatArray, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd, FloatArray.push]]
["String.decEq",[Decidable, Eq, String, List, Char, dite, String.mk, instDecidableEqList, instDecidableEqChar, Decidable.isTrue, String.decEq.proof_1, Not, Decidable.isFalse, String.decEq.proof_2]]
["IO.FS.Mode.read.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["id.def",[rfl, id]]
["System.FilePath.mk.injEq",[String, Eq.propIntro, Eq, System.FilePath, System.FilePath.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["StateT.ext",[StateT, Eq, Prod, StateT.run, funext]]
["Char.ofNat",[Nat, dite, Char, Nat.isValidChar, instDecidableOr, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, And, Nat.decLt, instDecidableAnd, Char.mk, UInt32.mk, Fin.mk, UInt32.size, Or.inl, Or.inr, And.intro, Nat.lt_trans, of_decide_eq_true, Eq.refl, Bool, Bool.true, Not, Char.ofNat.proof_1, Char.ofNat.proof_2]]
["Subarray.anyM",[Monad, Bool, Subarray, Array.anyM, Subarray.as, Subarray.start, Subarray.stop]]
["instDecidableLt_2",[UInt16, UInt16.decLt]]
["Prod.mk.inj",[Eq, Prod, Prod.mk, And, And.intro]]
["Array.qsort",[Inhabited, Array, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Array.size, Array.qsort.sort]]
["subtypeCoe",[CoeHead.mk, Subtype, Subtype.val]]
["pure_id_seq",[Applicative, LawfulApplicative, of_eq_true, Eq, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, id, Unit, Eq.trans, True, congrFun, congrArg, Functor.map, Applicative.toFunctor, LawfulApplicative.pure_seq, LawfulFunctor.id_map, LawfulApplicative.toLawfulFunctor, eq_self]]
["Char.ofNat.proof_2",[Or.inl, LT.lt, Nat, instLTNat, UInt32.toNat, UInt32.mk, Fin.mk, UInt32.size, OfNat.ofNat, instOfNatNat, of_decide_eq_true, Nat.decLt, Eq.refl, Bool, Bool.true, And]]
["Subsingleton.helim.proof_1",[Subsingleton, Eq, HEq, heq_of_eq, Subsingleton.elim]]
["withPtrEqDecEq.proof_3",[Unit, Decidable, Eq, Bool, withPtrEq, toBoolUsing, Unit.unit, withPtrEqDecEq.proof_1, Bool.false, ofBoolUsing_eq_false]]
["«term_<|>_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Lean.Parser.Tactic.rwRuleSeq",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.rwRule, Bool.true]]
["instHAnd",[AndOp, HAnd.mk, AndOp.and]]
["Lean.MacroScope",[Nat]]
["Lean.Parser.Tactic.discharger",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["Div.div",[Div]]
["Std.Format.text.sizeOf_spec",[String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["Nat.below",[Nat, PUnit, PProd]]
["String.get",[String, String.Pos, Char, List, List.below, List.nil, List.cons, arbitrary, Char.instInhabitedChar, ite, Eq, instDecidableEqNat, PProd.fst, PUnit, PProd, HAdd.hAdd, Nat, instHAdd, instAddNat, String.csize, OfNat.ofNat, instOfNatNat]]
["map_eq_pure_bind",[Monad, LawfulMonad, Eq.mpr, Eq, Functor.map, Applicative.toFunctor, Monad.toApplicative, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Function.comp, Eq.refl, Eq.symm, LawfulMonad.bind_pure_comp, rfl]]
["Lean.Parser.Tactic.first",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
["Classical.«tacticByCases__:_»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["List.foldl",[List, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd]]
["«stx_,+»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
["ReaderT.run_bind",[Monad, ReaderT, rfl, ReaderT.run, Bind.bind, Monad.toBind, ReaderT.instMonadReaderT]]
["instModUInt16",[Mod.mk, UInt16, UInt16.mod]]
["Lean.Meta.instReprTransparencyMode",[Repr.mk, Lean.Meta.TransparencyMode, Nat, Unit, Lean.Meta.TransparencyMode.all, Lean.Meta.TransparencyMode.default, Lean.Meta.TransparencyMode.reducible, Lean.Meta.TransparencyMode.instances, Unit.unit, Std.Format, Repr.addAppParen, Std.Format.group, Std.Format.nest, ite, Int, GE.ge, instLENat, OfNat.ofNat, instOfNatNat, Nat.decLe, Int.instOfNatInt, Std.Format.text, Std.Format.FlattenBehavior.allOrNone]]
["Char.utf8Size.proof_4",[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
["Nat.add_lt_add",[Nat, LT.lt, instLTNat, Nat.lt_trans, HAdd.hAdd, instHAdd, instAddNat, Nat.add_lt_add_right, Nat.add_lt_add_left]]
["instInhabitedUInt32.proof_1",[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
["Lean.Parser.Tactic.expandRwSeq",[Lean.Parser.Tactic.rwWithRfl, Lean.Name.mkStr, Lean.Name.anonymous]]
["«term_^_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Float.ofInt",[Int, Float, Nat, Float.ofNat, Float.neg, Nat.succ]]
["UInt8.le",[UInt8, LE.le, Fin, UInt8.size, instLEFin, UInt8.val]]
["forall_congr",[Eq]]
["Repr.noConfusionType",[Repr, Nat, Std.Format, Eq]]
["List.reverseAux_reverseAux",[List, Eq, List.reverseAux, List.nil, rfl, of_eq_true, List.cons, Eq.trans, True, congr, congrArg, eq_self]]
["panicWithPosWithDecl",[Inhabited, String, Nat, panic, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString, instToStringNat]]
["unsafeCast",[cast, unsafeCast.proof_1, PUnit]]
["ST.Ref.mk.injEq",[PointedType.type, ST.RefPointed, Nonempty, Eq.propIntro, Eq, ST.Ref, ST.Ref.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["PSigma.skipLeft",[WellFoundedRelation, WellFoundedRelation.mk, PSigma, PSigma.SkipLeft, WellFoundedRelation.rel, PSigma.skipLeft.proof_1]]
["ExceptCpsT.runCatch_bind_lift",[Monad, ExceptCpsT, rfl, ExceptCpsT.runCatch, Bind.bind, Monad.toBind, ExceptCpsT.instMonadExceptCpsT, ExceptCpsT.lift]]
["Nat.mod_eq_of_lt",[Nat, LT.lt, instLTNat]]
["FloatArray.data",[FloatArray]]
["usize_size_gt_zero",[Nat.pos_pow_of_pos, OfNat.ofNat, Nat, instOfNatNat, System.Platform.numBits, Nat.zero_lt_succ]]
["StateCpsT.run'",[Monad, StateCpsT, StateCpsT.runK, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["LawfulApplicative.map_pure",[Applicative, LawfulApplicative]]
["ReaderT.adapt",[Monad, ReaderT]]
["IO.Error.protocolError.inj",[UInt32, String, Eq, IO.Error, IO.Error.protocolError, And, And.intro]]
["UInt32.complement",[UInt32, HSub.hSub, instHSub, instSubUInt32, OfNat.ofNat, instOfNatUInt32, HAdd.hAdd, instHAdd, instAddUInt32]]
["Subtype.eta",[Subtype, Subtype.val, Eq, Subtype.mk, rfl, Eq.symm, Eq.refl]]
["IO.Error.invalidArgument.injEq",[Option, String, UInt32, Eq.propIntro, Eq, IO.Error, IO.Error.invalidArgument, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Fin.mk.sizeOf_spec",[Nat, LT.lt, instLTNat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat, instSizeOf]]
["UInt16.toNat",[UInt16, Fin.val, UInt16.size, UInt16.val]]
["Array.insertionSort.swapLoop.proof_1",[Nat, Array, LT.lt, instLTNat, Array.size, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Nat.lt_trans, Nat.succ, Nat.lt_succ_self, Eq.symm]]
["emptyWf",[WellFoundedRelation.mk, emptyRelation, emptyWf.proof_1]]
["Lean.Parser.Tactic.locationWildcard",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol]]
["List.replicate.loop",[Nat, List, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, List.cons]]
["namedPattern",[]]
["Nat.toUInt32",[UInt32.ofNat]]
["List.getLast!.proof_1",[List, Eq, List.cons, List.nil, False]]
["Lean.evalOptPrio",[Option, Lean.Syntax, Lean.MacroM, Nat, Lean.evalPrio, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, OfNat.ofNat, instOfNatNat]]
["Nat.succ_sub_succ_eq_sub",[Nat, Eq, HSub.hSub, instHSub, instSubNat, Nat.succ, rfl, Nat.zero, congrArg, Nat.pred]]
["instToStringBool",[ToString.mk, Bool, cond, String]]
["ReaderT.run",[ReaderT]]
["UInt64.decLt",[UInt64, Decidable, LT.lt, instLTUInt64, Fin, UInt64.size, inferInstanceAs, instLTFin, Fin.decLt]]
["String.quote",[String, ite, Eq, Bool, String.isEmpty, Bool.true, instDecidableEqBool, HAppend.hAppend, instHAppend, String.instAppendString, String.foldl, Char, Char.quoteCore]]
["IO.FS.Mode.readWrite.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["MonadStateOf.modifyGet",[MonadStateOf]]
["UInt8.noConfusionType",[UInt8, Fin, UInt8.size, Eq]]
["Lean.Parser.Syntax.addPrio",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Fin.ofNat.proof_1",[Nat, Nat.mod_lt, Nat.succ, Nat.zero_lt_succ]]
["Nat.ibelow",[Nat, True, And]]
["Lean.MonadRef.getRef",[Lean.MonadRef]]
["CoeT.noConfusionType",[CoeT, Eq]]
["IO.AccessRight.mk.sizeOf_spec",[Bool, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk]]
["outParam",[]]
["Classical.choose_spec",[Exists, Subtype.property, Classical.indefiniteDescription]]
["Lean.«command_Unif_hint___Where_|-⊢_»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.unifConstraintElem, Lean.unifConstraint]]
["instToStringUInt32",[ToString.mk, UInt32, ToString.toString, Nat, instToStringNat, UInt32.toNat]]
["Fin.val",[Nat, Fin]]
["Quotient.recOn",[Setoid, Quotient, Quotient.mk, HasEquiv.Equiv, instHasEquiv, Eq, Quotient.sound, Quot.recOn, Setoid.r]]
["UInt64.noConfusionType",[UInt64, Fin, UInt64.size, Eq]]
["Nat.succ_lt_succ",[Nat, Nat.succ_le_succ, Nat.succ]]
["measure",[Nat, invImage, Nat.lt_wfRel]]
["Lean.Meta.Rewrite.Config.noConfusionType",[Lean.Meta.Rewrite.Config, Lean.Meta.TransparencyMode, Bool, Eq]]
["Array.binInsertM",[Monad, Inhabited, Bool, Unit, Array, ite, Eq, Array.isEmpty, Bool.true, instDecidableEqBool, Bind.bind, Monad.toBind, Unit.unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.push, Array.get!, OfNat.ofNat, Nat, instOfNatNat, Array.insertAt, not, Array.modifyM, Array.back, HSub.hSub, instHSub, instSubNat, Array.size]]
["Lean.Syntax.expandInterpolatedStr",[Lean.Syntax, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Syntax.expandInterpolatedStrChunks, Lean.Syntax.getArgs, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.Macro.instMonadRefMacroM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Macro.instMonadQuotationMacroM, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
["ST.Prim.Ref.modifyUnsafe",[ST.Ref, Bind.bind, ST, Monad.toBind, instMonadST, Unit, ST.Prim.Ref.take, ST.Prim.Ref.set]]
["MonadFinally.tryFinally'",[MonadFinally]]
["instLawfulMonadStateRefT'",[instLawfulMonadStateRefT'.proof_1]]
["Option.format",[Std.ToFormat, Option, Std.Format, Unit, Std.Format.text, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.ToFormat.format]]
["MonadLiftT.monadLift",[MonadLiftT]]
["Lean.Quote.quote",[Lean.Quote]]
["instCoeTail",[CoeFun, CoeTail.mk, coeFun]]
["ReaderT.run_map",[Monad, ReaderT, rfl, ReaderT.run, Functor.map, Applicative.toFunctor, Monad.toApplicative, ReaderT.instMonadReaderT]]
["Char.toLower",[Char, Nat, Char.toNat, ite, And, GE.ge, instLENat, OfNat.ofNat, instOfNatNat, LE.le, instDecidableAnd, Nat.decLe, Char.ofNat, HAdd.hAdd, instHAdd, instAddNat]]
["instStreamSubarray",[Stream.mk, Subarray, dite, Option, Prod, LT.lt, Nat, instLTNat, Subarray.start, Subarray.stop, Nat.decLt, Not, Option.none]]
["Sum.inl.inj",[Eq, Sum, Sum.inl]]
["instDecidableEqSum.proof_6",[Eq, Sum, Sum.inl, Sum.inr, False]]
["StateCpsT.instMonadStateCpsT",[Monad.mk, StateCpsT, Applicative.mk, Functor.mk, Pure.mk, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk]]
["Lean.Parser.Tactic.Conv.rhs",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["IO.FS.writeBinFile",[System.FilePath, ByteArray, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle, Unit, IO.FS.Handle.mk, IO.FS.Mode.write, Bool.true, IO.FS.Handle.write]]
["Except.tryCatch",[Except, Except.ok]]
["List.all",[List, Bool, List.foldr, and, Bool.true]]
["ExceptCpsT.runCatch_lift",[Monad, LawfulMonad, of_eq_true, Eq, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Eq.trans, True, congrFun, congrArg, bind_pure, eq_self]]
["Except.bind",[Except, Except.error]]
["Nat.div.inductionOn",[Nat, And, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, HSub.hSub, instHSub, instSubNat, Not, WellFounded.fix, WellFoundedRelation.rel, measure, id, WellFoundedRelation.wf, dite, instDecidableAnd, Nat.decLt, Nat.decLe, And.intro, Nat.sub_lt, Nat.lt_of_lt_of_le]]
["ExceptT.bind_throw",[Monad, LawfulMonad, ExceptT, of_eq_true, Eq, Bind.bind, Monad.toBind, Except, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.error, Eq.trans, True, congrFun, congrArg, LawfulMonad.pure_bind, eq_self]]
["Pure.noConfusionType",[Pure, Eq]]
["Lean.Parser.Tactic.revert",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
["StateT.seqLeft_eq",[Monad, LawfulMonad, StateT, StateT.ext, SeqLeft.seqLeft, Applicative.toSeqLeft, Monad.toApplicative, StateT.instMonadStateT, Unit, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const, of_eq_true, Eq, Prod, StateT.run, Eq.trans, Bind.bind, Monad.toBind, Prod.snd, Pure.pure, Applicative.toPure, Prod.mk, Prod.fst, True, congr, congrArg, StateT.run_seqLeft, StateT.run_seq, StateT.run_map, map_eq_pure_bind, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, eq_self]]
["Lean.Name.reprPrec",[Lean.Name, Nat, Std.Format, Lean.Name.below, Unit, Lean.Name.anonymous, UInt64, Lean.Name.num, String, Lean.Name.str, Unit.unit, Std.Format.text, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, PProd.fst, PUnit, PProd, OfNat.ofNat, instOfNatNat, repr, instReprNat, ite, Eq, Bool, Bool.false, Bool.true, instDecidableEqBool, instReprString, Lean.Name.toString]]
["instReprAtomUSize",[ReprAtom.mk, USize]]
["Lean.Parser.Tactic.allGoals",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["MonadStateOf.get",[MonadStateOf]]
["Lean.Name.mkStr",[Lean.Name, String, Lean.Name.str, mixHash, Hashable.hash, Lean.instHashableName, instHashableString]]
["Lean.Parser.Tactic.traceState",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["«term_-_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["instReprAtomUInt64",[ReprAtom.mk, UInt64]]
["Array.getLit.proof_1",[Nat, Array, Eq, Array.size, LT.lt, instLTNat, Eq.symm]]
["PLift.down_up",[rfl, PLift.down, PLift.up]]
["String.any",[String, Char, Bool, String.anyAux, String.bsize, OfNat.ofNat, String.Pos, instOfNatNat]]
["Lean.mkCIdentFrom",[Lean.Syntax, Lean.Name, Lean.addMacroScope, Lean.Name.mkStr, Lean.Name.anonymous, Lean.reservedMacroScope, Lean.Syntax.ident, Lean.SourceInfo.fromRef, String.toSubstring, ToString.toString, Lean.Name.instToStringName, List.cons, Prod, List, String, Prod.mk, List.nil]]
["Std.Format.MonadPrettyFormat.currColumn",[Std.Format.MonadPrettyFormat]]
["Stream.next?",[Stream]]
["Substring.dropRightWhile",[Substring, Char, Bool, String, String.Pos, Substring.mk]]
["List.noConfusionType",[List, Eq]]
["IO.Error.mkInvalidArgument",[IO.Error.invalidArgument, Option.none, String]]
["Seq.seq",[Seq]]
["String.revPosOf",[String, Char, ite, Option, String.Pos, Eq, Bool, BEq.beq, Nat, instBEq, instDecidableEqNat, String.bsize, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Option.none, String.revPosOfAux, String.prev]]
["MonadStateOf.noConfusionType",[MonadStateOf, PUnit, Prod, Eq]]
["HShiftLeft.noConfusionType",[outParam, HShiftLeft, Eq]]
["Array.eraseIdxSzAuxInstance",[Array, Inhabited.mk, Subtype, Eq, Nat, Array.size, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, Subtype.mk, Array.pop, Array.size_pop]]
["Lean.Name.hash",[Lean.Name, UInt64, Unit, UInt64.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, Lean.Name.hash.proof_1, String]]
["instLEFloat",[LE.mk, Float, Float.le]]
["instLEUInt16",[LE.mk, UInt16, UInt16.le]]
["Lean.Parser.Tactic.Conv.reduce",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["instReprUnit",[Repr.mk, Unit, Nat, Std.Format.text]]
["Array.findIdx?",[Array, Bool, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Array.size, Option, OfNat.ofNat, instOfNatNat, rfl, Array.findIdx?.loop]]
["Nat.add_eq",[Nat, rfl, Nat.add]]
["MonadFunctor.monadMap",[MonadFunctor]]
["List.eraseRepsAux",[BEq, List, List.below, List.nil, List.reverse, List.cons, Bool, BEq.beq, Unit, PProd.fst, PUnit, PProd]]
["bfix2",[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd]]
["IO.Error.noSuchThing.sizeOf_spec",[Option, String, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["Nat.le_total",[Nat, Or, LT.lt, instLTNat, GE.ge, instLENat, Nat.lt_or_ge, LE.le, Or.inl, Nat.le_of_lt, Or.inr]]
["LawfulApplicative.seq_pure",[Applicative, LawfulApplicative]]
["Char.val",[Char]]
["Alternative.toApplicative",[Alternative]]
["String.decEq.proof_2",[List, Char, Not, Eq, String, String.mk, False, absurd]]
["Bool.and_true",[Bool, Eq, and, Bool.true, Bool.false, rfl, Eq.symm, Eq.refl]]
["Lean.Syntax.getTrailingSize",[Lean.Syntax, Option, Lean.SourceInfo, Nat, Lean.Syntax.getTailInfo?, Substring, String.Pos, Substring.bsize, OfNat.ofNat, instOfNatNat]]
["String.Iterator.noConfusionType",[String.Iterator, String, String.Pos, Eq]]
["Lean.Parser.Tactic.paren",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
["Array.isEqv",[Array, Bool, dite, Eq, Nat, Array.size, instDecidableEqNat, Array.isEqvAux, OfNat.ofNat, instOfNatNat, Not, Bool.false]]
["precLead",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["UInt16.le",[UInt16, LE.le, Fin, UInt16.size, instLEFin, UInt16.val]]
["Array.foldrM.fold.proof_1",[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Nat.lt_of_lt_of_le, Nat.succ, Nat.lt_succ_self]]
["Lean.Syntax.expandInterpolatedStrChunks",[Array, Lean.Syntax, Lean.MacroM, Nat, OfNat.ofNat, instOfNatNat, Lean.Syntax.missing, Bind.bind, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, MProd, ForIn.forIn, Array.instForInArray, MProd.mk, MProd.fst, MProd.snd, ForInStep, PUnit, HAdd.hAdd, instHAdd, instAddNat, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, ForInStep.yield, ite, Eq, Bool, BEq.beq, instBEq, instDecidableEqNat, Bool.true, instDecidableEqBool, Option, String, Lean.Syntax.isInterpolatedStrLit?, Unit, Lean.Syntax.mkStrLit, Lean.SourceInfo.none]]
["eq_true_of_decide",[Decidable, Eq, Bool, Decidable.decide, Bool.true, propext, True, Iff.intro, trivial, of_decide_eq_true]]
["Lean.NameGenerator.noConfusionType",[Lean.NameGenerator, Lean.Name, Nat, Eq]]
["Array.empty",[Array.mkEmpty, OfNat.ofNat, Nat, instOfNatNat]]
["Array.foldl",[Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Id.run, Array.foldlM, Id, Id.instMonadId]]
["iff_self",[propext, Iff, True, Iff.intro, trivial, id]]
["Fin.instModFin",[Nat, Mod.mk, Fin, Fin.mod]]
["Array.«term__[_:_]»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Squash",[Quot, True]]
["List.map",[List, List.below, Unit, List.nil, List.cons, PProd.fst, PUnit, PProd]]
["Fin.xor",[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, Nat.xor, Fin.xor.proof_1]]
["StateT.run_seqLeft",[Monad, LawfulMonad, StateT]]
["IO.Process.SpawnArgs.cmd",[IO.Process.SpawnArgs]]
["Lean.Name.appendAfter",[Lean.Name, String, Lean.Name.modifyBase, UInt64, Lean.Name.mkStr, HAppend.hAppend, instHAppend, String.instAppendString]]
["FloatArray.instInhabitedFloatArray",[Inhabited.mk, FloatArray, FloatArray.empty]]
["IO.Error.alreadyExists.sizeOf_spec",[Option, String, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["instReprUSize",[Repr.mk, USize, Nat, repr, instReprNat, USize.toNat]]
["IO.Error.mkResourceExhausted",[IO.Error.resourceExhausted, Option.none, String]]
["Lean.charLitKind",[Lean.Name.mkStr, Lean.Name.anonymous]]
["Lean.Parser.Tactic.contradiction",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["instReprBool",[Repr.mk, Bool, Nat, Std.Format, Std.Format.text]]
["String.trimLeft",[String, Substring.toString, Substring.trimLeft, String.toSubstring]]
["StateT.run_seq",[Monad, LawfulMonad, StateT]]
["Nat.isValidChar",[Nat, Or, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, And]]
["Lean.Meta.Simp.Config.singlePass",[Lean.Meta.Simp.Config]]
["StateT.run_modifyGet",[Monad, Prod, Eq, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk, Prod.fst, Prod.snd, rfl, Eq.symm, Eq.refl]]
["«stx_*»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
["fixCore6",[bfix6, USize.size]]
["StateCpsT.runK_bind_modify",[Monad, PUnit, StateCpsT, rfl, StateCpsT.runK, Bind.bind, Monad.toBind, StateCpsT.instMonadStateCpsT, modify, instMonadState, StateCpsT.instMonadStateOfStateCpsT]]
["ByteArray.instAppendByteArray",[Append.mk, ByteArray, ByteArray.append]]
["instOrdFin",[Nat, Ord.mk, Fin, Ord.compare, instOrdNat, Fin.val]]
["FloatArray.get?",[FloatArray, Nat, dite, Option, Float, LT.lt, instLTNat, FloatArray.size, Nat.decLt, Option.some, FloatArray.get, Fin.mk, Not, Option.none]]
["Lean.instQuoteString",[Lean.Quote.mk, String, Lean.Syntax.mkStrLit, Lean.SourceInfo.none]]
["Lean.Parser.Tactic.withReducibleAndInstances",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["List.cons_append",[List, rfl, HAppend.hAppend, instHAppend, List.instAppendList, List.cons]]
["Nat.forM",[Monad, Nat, Unit, Nat.forM.loop]]
["USize.toUInt32",[USize, Nat.toUInt32, USize.toNat]]
["SizeOfRef",[SizeOf, Measure, SizeOf.sizeOf]]
["Prod.RProdSubLex.proof_1",[Prod, Prod.RProd, Eq, HEq, Prod.Lex, Prod.mk, Prod.RProd.intro, Prod.Lex.left, Eq.symm, eq_of_heq, Eq.refl, HEq.refl]]
["instReprAtomInt",[ReprAtom.mk, Int]]
["UInt8.xor",[UInt8, UInt8.mk, Fin.xor, UInt8.size, UInt8.val]]
["Int.negSucc.inj",[Nat, Eq, Int, Int.negSucc]]
["Std.Range.mk.sizeOf_spec",[Nat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat]]
["Substring.posOf",[Substring, Char, String.Pos, String, HSub.hSub, instHSub, instSubNat, String.posOfAux]]
["IO.Error.noFileOrDirectory.inj",[String, UInt32, Eq, IO.Error, IO.Error.noFileOrDirectory, And, And.intro]]
["Lean.instInhabitedName",[Inhabited.mk, Lean.Name, Lean.Name.anonymous]]
["List.map_eq_mapTR",[funext, List, List.map, List.mapTR, of_eq_true, Eq, List.mapTRAux, List.nil, Eq.trans, True, congrArg, HAppend.hAppend, instHAppend, List.instAppendList, List.reverse, List.mapTRAux_eq, congrFun, List.reverse_nil, List.nil_append, eq_self]]
["OptionM",[OptionT, Id]]
["IO.FileRight.group",[IO.FileRight]]
["UInt16.shiftLeft",[UInt16, UInt16.mk, HShiftLeft.hShiftLeft, Fin, UInt16.size, instHShiftLeft, Fin.instShiftLeftFin, UInt16.val, UInt16.modn, OfNat.ofNat, Nat, instOfNatNat]]
["List.erase",[BEq, List, List.below, List.nil, List.cons, Bool, BEq.beq, Unit, PProd.fst, PUnit, PProd]]
["Substring.front",[Substring, Substring.get, OfNat.ofNat, String.Pos, instOfNatNat]]
["Nat.land",[Nat.bitwise, and]]
["IO.FS.Stream.Buffer.mk.sizeOf_spec",[ByteArray, Nat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Array, UInt8, SizeOf, List, Fin, UInt8.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["Int.ofNat.injEq",[Nat, Eq.propIntro, Eq, Int, Int.ofNat, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Array.sequenceMap",[Monad, Array, Nat, Array.size, OfNat.ofNat, instOfNatNat, Array.empty, Array.sequenceMap.loop]]
["getThe",[MonadStateOf, MonadStateOf.get]]
["Nat.eq_zero_of_le_zero",[Nat, LE.le, instLENat, OfNat.ofNat, instOfNatNat, Nat.le_antisymm, Nat.zero_le]]
["stdRange",[Prod.mk, Nat, OfNat.ofNat, instOfNatNat]]
["Int.natAbs",[Nat, Nat.succ]]
["Nat.anyM",[Monad, Nat, Bool, Nat.anyM.loop]]
["Nat.mod_one",[Nat]]
["OptionT.instMonadLiftOptionT",[Monad, MonadLift.mk, OptionT, OptionT.lift]]
["Array.findM?",[Monad, Array, Bool, Bind.bind, Monad.toBind, MProd, Option, PUnit, ForIn.forIn, Array.instForInArray, MProd.mk, Option.none, PUnit.unit, ForInStep, ite, Eq, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, ForInStep.done, Option.some, ForInStep.yield, MProd.fst, Unit]]
["instDivFloat",[Div.mk, Float, Float.div]]
["Bool.false_or",[Bool, Eq, or, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl]]
["Nat.sub",[Nat, Nat.below, Nat.succ, Nat.pred, PProd.fst, PUnit, PProd]]
["Lean.MonadNameGenerator.getNGen",[Lean.MonadNameGenerator]]
["Lean.Parser.Tactic.specialize",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
["UInt64.xor",[UInt64, UInt64.mk, Fin.xor, UInt64.size, UInt64.val]]
["Char.isLower",[Char, and, Decidable.decide, GE.ge, UInt32, instLEUInt32, Char.val, OfNat.ofNat, instOfNatUInt32, instDecidableLe, LE.le]]
["instMulUInt64",[Mul.mk, UInt64, UInt64.mul]]
["Lean.Syntax.instBEqSyntax",[BEq.mk, Lean.Syntax, Lean.Syntax.structEq]]
["Squash.lift",[Subsingleton, Squash, Quot.lift, True, Squash.lift.proof_1]]
["Int.add",[Int, Nat, Int.ofNat, HAdd.hAdd, instHAdd, instAddNat, Int.subNatNat, Nat.succ, Int.negSucc]]
["IO.FS.Stream.Buffer.data",[IO.FS.Stream.Buffer]]
["Fin.instShiftRightFin",[Nat, ShiftRight.mk, Fin, Fin.shiftRight]]
["max",[LT, DecidableRel, LT.lt, ite]]
["IO.Error.mkTimeExpired",[IO.Error.timeExpired]]
["String.Iterator.s",[String.Iterator]]
["Lean.binderIdent",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
["IO.withStdin",[Monad, MonadFinally, MonadLiftT, IO, IO.FS.Stream, Bind.bind, Monad.toBind, liftM, EIO, IO.Error, IO.setStdin, tryFinally, PUnit, Applicative.toFunctor, Monad.toApplicative, Functor.discard]]
["Lean.Syntax.isStrLit?",[Lean.Syntax, Option, String, Option.some, Option.none, Lean.Syntax.isLit?, Lean.strLitKind, Lean.Syntax.decodeStrLit]]
["Function.Equiv.refl",[rfl]]
["instToStringNat",[ToString.mk, Nat, Nat.repr]]
["Lean.Syntax.instToFormatSyntax",[Std.ToFormat.mk, Lean.Syntax, Lean.Syntax.formatStx, Option.none, Nat, Bool.false]]
["Lean.Parser.Tactic.Conv.convTrace_state",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["Subarray.forRevM",[Monad, PUnit, Subarray, Array.forRevM, Subarray.as, Subarray.stop, Subarray.start]]
["UInt16.toUInt32",[UInt16, Nat.toUInt32, UInt16.toNat]]
["instInhabitedPointedType",[Inhabited.mk, PointedType, PointedType.mk, PUnit, PUnit.unit]]
["Std.Range.instForInRangeNat",[ForIn.mk, Std.Range, Nat, Monad, Std.Range.forIn]]
["instHashableUSize",[Hashable.mk, USize, USize.toUInt64]]
["EStateM.Result.ok.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["GE.ge",[LE, LE.le]]
["List.reverseAux_eq_append",[List, Eq, List.reverseAux, HAppend.hAppend, instHAppend, List.instAppendList, List.nil, of_eq_true, Eq.trans, True, congrArg, List.nil_append, eq_self, Eq.mpr, List.cons, Eq.refl, List.append_assoc, rfl]]
["IO.Error.userError.inj",[String, Eq, IO.Error, IO.Error.userError]]
["Lean.Macro.Methods.resolveNamespace?",[Lean.Macro.Methods]]
["IO.Error.timeExpired.injEq",[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.timeExpired, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["ReaderT.instMonadExceptOfReaderT",[MonadExceptOf, MonadExceptOf.mk, ReaderT, liftM, instMonadLiftT, ReaderT.instMonadLiftReaderT, instMonadLiftT_1, MonadExcept.throw, instMonadExcept, tryCatchThe]]
["ExceptT.seq_eq",[Monad, ExceptT, rfl, Seq.seq, Applicative.toSeq, Monad.toApplicative, ExceptT.instMonadExceptT, Unit]]
["IO.Process.SpawnArgs.mk.sizeOf_spec",[IO.Process.StdioConfig, String, Array, Option, System.FilePath, Prod, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, IO.Process.Stdio, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["StateCpsT.instLawfulMonadStateCpsT",[StateCpsT.instLawfulMonadStateCpsT.proof_1]]
["FloatArray.mkEmpty",[FloatArray.mk, List.toArray, Float, List.nil]]
["«term_*_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Nat.instOrOpNat",[OrOp.mk, Nat, Nat.lor]]
["Nat.add_lt_add_right",[Nat, LT.lt, instLTNat, HAdd.hAdd, instHAdd, instAddNat, Nat.add_lt_add_left, Nat.add_comm]]
["ExceptCpsT.run_bind_lift",[Monad, ExceptCpsT, rfl, Except, ExceptCpsT.run, Bind.bind, Monad.toBind, ExceptCpsT.instMonadExceptCpsT, ExceptCpsT.lift]]
["IO.Process.Output.exitCode",[IO.Process.Output]]
["Lean.Meta.Simp.Config.iota",[Lean.Meta.Simp.Config]]
["Subarray.foldlM",[Monad, Subarray, Array.foldlM, Subarray.as, Subarray.start, Subarray.stop]]
["HasEquiv.noConfusionType",[HasEquiv, Eq]]
["instReprStdGen",[Repr.mk, StdGen, Nat, Std.Format, Std.Format.bracket, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, repr, instReprNat, Std.Format.text]]
["IO.AccessRight.execution",[IO.AccessRight]]
["Int.instLTInt",[LT.mk, Int, Int.lt]]
["Quotient.lift₂",[Setoid, HasEquiv.Equiv, instHasEquiv, Eq, Quotient, Quotient.lift, Quotient.lift₂.proof_1, Quotient.lift₂.proof_2]]
["Lean.Syntax.mkLit",[Lean.SyntaxNodeKind, String, optParam, Lean.SourceInfo, Lean.SourceInfo.none, Lean.Syntax, Lean.Syntax.atom, Lean.Syntax.node, List.toArray, List.cons, List.nil]]
["Lean.Parser.Tactic.«tacticHave'__:=_»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["instStreamSubarray.proof_1",[Subarray, LT.lt, Nat, instLTNat, Subarray.start, Subarray.stop, Nat.succ_le_of_lt]]
["Bool.or_false",[Bool, Eq, or, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl]]
["Lean.Macro.Methods.getCurrNamespace",[Lean.Macro.Methods]]
["ne_true_of_not",[Not, Eq, True]]
["Fin.eq_of_val_eq",[Nat, Fin, Eq, Fin.val, LT.lt, instLTNat, rfl, Fin.mk]]
["Sum.inr.injEq",[Eq.propIntro, Eq, Sum, Sum.inr, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["PSigma.mkSkipLeft",[PSigma.mkSkipLeft.proof_1]]
["List.replicate",[Nat, List, List.nil, List.replicate.loop]]
["Lean.Meta.TransparencyMode.noConfusion",[Lean.Meta.TransparencyMode, Eq, noConfusionEnum, Nat, instDecidableEqNat, Lean.Meta.TransparencyMode.toCtorIdx]]
["«term_×'_»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.bracketedExplicitBinders, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["nonempty_of_exists",[Exists, Nonempty, Nonempty.intro]]
["Std.Format.tag.injEq",[Nat, Std.Format, Eq.propIntro, Eq, Std.Format.tag, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["instToStringSubstring",[ToString.mk, Substring, Substring.toString]]
["FloatArray.mk.inj",[Array, Float, Eq, FloatArray, FloatArray.mk]]
["ExceptT.instMonadFunctorExceptT",[MonadFunctor.mk, ExceptT, Except]]
["Unit",[PUnit]]
["IO.Error.resourceVanished.sizeOf_spec",[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar]]
["List.instListDecidableLe",[LT, DecidableRel, LT.lt, List, inferInstanceAs, Decidable, Not, List.instLTList, instDecidableNot, List.hasDecidableLt]]
["precMax",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["Lean.Meta.Simp.instBEqConfig",[BEq.mk, Lean.Meta.Simp.Config, Nat, Bool, Lean.Meta.Simp.Config.mk, and, Bool.true, BEq.beq, instBEq, instDecidableEqNat, instDecidableEqBool, Bool.false]]
["Lean.Macro.throwError",[String, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Syntax, Lean.MonadRef.getRef, Lean.Macro.instMonadRefMacroM, MonadExcept.throw, instMonadExcept, ReaderT.instMonadExceptOfReaderT, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Lean.Macro.Exception.error]]
["EStateM.Result.error.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["Nat.all",[Nat, Bool, not, Nat.any]]
["WellFoundedRelation.mk.sizeOf_spec",[SizeOf, WellFounded, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOf]]
["ST.Prim.Ref.modifyGet",[ST.Ref, Prod, Bind.bind, ST, Monad.toBind, instMonadST, ST.Prim.Ref.get, Unit, ST.Prim.Ref.set, PUnit, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["eq_false'",[False, propext, Iff.intro, absurd, False.elim]]
["id",[]]
["String.foldl",[Char, String, String.foldlAux, String.bsize, OfNat.ofNat, String.Pos, instOfNatNat]]
["Char.mk.sizeOf_spec",[UInt32, UInt32.isValidChar, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["coeOfHead",[CoeHead, CoeHTCT.mk, coeHead]]
["instInhabitedNat",[Inhabited.mk, Nat, Nat.zero]]
["StateT.get",[Monad, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod, Prod.mk]]
["SizeOf.sizeOf",[SizeOf]]
["Lean.Parser.Tactic.withReducible",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["DoResultPR.return.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["FloatSpec.noConfusionType",[FloatSpec, DecidableRel, Eq, HEq]]
["IO.Error.alreadyExists.inj",[Option, String, UInt32, Eq, IO.Error, IO.Error.alreadyExists, And, And.intro]]
["IO.Error.mkInappropriateType",[IO.Error.inappropriateType, Option.none, String]]
["Nat.add_succ",[Nat, rfl, HAdd.hAdd, instHAdd, instAddNat, Nat.succ]]
["EStateM.modifyGet",[Prod, EStateM.Result, EStateM.Result.ok]]
["Fin.val_eq_of_eq",[Nat, Fin, Eq, Fin.val, rfl]]
["Fin.mul",[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, HMul.hMul, instHMul, instMulNat, Fin.mul.proof_1]]
["instInhabitedStdGen",[Inhabited.mk, StdGen, StdGen.mk, OfNat.ofNat, Nat, instOfNatNat]]
["ReaderT.failure",[Alternative, Alternative.failure]]
["instDivUInt8",[Div.mk, UInt8, UInt8.div]]
["instMonadControlT_1",[Pure, MonadControlT.mk, Pure.pure]]
["CoeTail.noConfusionType",[CoeTail, Eq]]
["instAndOpUInt64",[AndOp.mk, UInt64, UInt64.land]]
["instLawfulMonadStateRefT'.proof_1",[Monad, LawfulMonad, inferInstanceAs, ReaderT, ST.Ref, ReaderT.instMonadReaderT, ReaderT.instLawfulMonadReaderT]]
["StateRefT'.instMonadExceptOfStateRefT'",[MonadExceptOf, MonadExceptOf.mk, StateRefT', Function.comp, StateRefT'.lift, throwThe, ST.Ref, tryCatchThe]]
["Nat.le_add_left",[Nat, HAdd.hAdd, instHAdd, instAddNat, LE.le, instLENat, Nat.le_add_right, Nat.add_comm]]
["Std.Range.«term[:_:_]»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["implies.trans",[implies]]
["Lean.Meta.Simp.Config.noConfusionType",[Lean.Meta.Simp.Config, Nat, Bool, Eq]]
["instTransEq_1.proof_1",[Eq]]
["Substring.prevn",[Substring, String.Pos, Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, Substring.prev]]
["StdGen.mk.inj",[Nat, Eq, StdGen, StdGen.mk, And, And.intro]]
["Lean.Macro.trace",[Lean.Name, String, modify, Lean.Macro.State, Lean.MacroM, instMonadState, instMonadStateOf, EStateM, Lean.Macro.Exception, ReaderT.instMonadLiftReaderT, Lean.Macro.Context, EStateM.instMonadStateOfEStateM, Lean.Macro.State.mk, Lean.Macro.State.macroScope, List.cons, Prod, Prod.mk, Lean.Macro.State.traceMsgs]]
["IO.Process.Child.stderr",[IO.Process.StdioConfig, IO.Process.Child]]
["EStateM.Result.error.injEq",[Eq.propIntro, Eq, EStateM.Result, EStateM.Result.error, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["HOr.noConfusionType",[outParam, HOr, Eq]]
["bfix6",[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd]]
["WellFoundedRelation.wf",[WellFoundedRelation]]
["Std.Format.defIndent",[OfNat.ofNat, Nat, instOfNatNat]]
["MProd.noConfusionType",[MProd, Eq]]
["Int.ofNat.inj",[Nat, Eq, Int, Int.ofNat]]
["Lean.Meta.Simp.Config.maxSteps",[Lean.Meta.Simp.Config]]
["IO.Error.mkProtocolError",[IO.Error.protocolError]]
["Option.none.sizeOf_spec",[SizeOf, Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["ReaderT.run_seqRight",[Monad, LawfulMonad, ReaderT, Eq.mpr, Eq, ReaderT.run, SeqRight.seqRight, Applicative.toSeqRight, Monad.toApplicative, ReaderT.instMonadReaderT, Unit, Bind.bind, Monad.toBind, Eq.refl, seqRight_eq_bind, rfl]]
["IO.Error.timeExpired.inj",[UInt32, String, Eq, IO.Error, IO.Error.timeExpired, And, And.intro]]
["StateT.instMonadFunctorStateT",[Monad, MonadFunctor.mk, StateT, Prod]]
["instReprNat",[Repr.mk, Nat, Std.Format.text, Nat.repr]]
["IO.Process.Child.mk.injEq",[IO.Process.StdioConfig, IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdin, IO.Process.StdioConfig.stdout, IO.Process.StdioConfig.stderr, Eq.propIntro, Eq, IO.Process.Child, IO.Process.Child.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["ReaderT.instMonadLiftReaderT",[MonadLift.mk, ReaderT]]
["List.zipWith",[List, List.below, List.cons, PProd.fst, PUnit, PProd, List.nil]]
["Lean.Syntax.getHeadInfo",[Lean.Syntax, Option, Lean.SourceInfo, Lean.Syntax.getHeadInfo?, Unit, Lean.SourceInfo.none]]
["instShiftLeftUInt64",[ShiftLeft.mk, UInt64, UInt64.shiftLeft]]
["IO.FS.instReprSystemTime",[Repr.mk, IO.FS.SystemTime, Nat, Std.Format.bracket, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.nil, Std.Format.text, repr, Int, instReprInt, IO.FS.SystemTime.sec, Std.Format.line, UInt32, instReprUInt32, IO.FS.SystemTime.nsec]]
["List.findSomeM?",[Monad, Option, List, List.below, Unit, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.none, List.cons, Bind.bind, Monad.toBind, Option.some, PProd.fst, PUnit, PProd]]
["HMod.noConfusionType",[outParam, HMod, Eq]]
["String.toSubstring",[String, Substring.mk, OfNat.ofNat, String.Pos, instOfNatNat, String.bsize]]
["instOrdNat",[Ord.mk, Nat, compareOfLessAndEq, instLTNat, Nat.decLt, instDecidableEqNat]]
["StateT.run_monadMap",[Monad, MonadFunctor, StateT, rfl, Prod, StateT.run, MonadFunctorT.monadMap, instMonadFunctorT, StateT.instMonadFunctorStateT, monadFunctorRefl]]
["Task.Priority.dedicated",[OfNat.ofNat, Task.Priority, instOfNatNat]]
["IO.FS.withIsolatedStreams",[Monad, MonadFinally, MonadExceptOf, IO.Error, MonadLiftT, IO, Bind.bind, Monad.toBind, IO.Ref, IO.FS.Stream.Buffer, Prod, String, Except, liftM, EIO, IO.mkRef, IO.FS.Stream.Buffer.mk, IO.withStdin, IO.FS.Stream.ofBuffer, IO.withStdout, IO.withStderr, observing, instMonadExcept, ST.Ref.get, IO.RealWorld, instMonadLiftT, ST, IO.instMonadLiftSTRealWorldEIO, instMonadLiftT_1, String.fromUTF8Unchecked, IO.FS.Stream.Buffer.data, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk]]
["Lean.Name.capitalize",[Lean.Name, String, UInt64, Lean.Name.mkStr, String.capitalize]]
["Array.foldlMUnsafe",[Monad, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, USize, ite, LT.lt, instLTNat, Nat.decLt, LE.le, instLENat, Nat.decLe, USize.ofNat, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.foldlMUnsafe.fold]]
["MonadState.modifyGet",[MonadState]]
["instDecidableArrow.proof_1",[]]
["Nat.lt_of_le_of_ne",[Nat, LE.le, instLENat, Not, Eq, Or, LT.lt, instLTNat, GE.ge, Nat.lt_or_ge, absurd, Nat.le_antisymm]]
["ExceptT.run_lift",[Monad, rfl, Except, ExceptT.run, ExceptT.lift]]
["instHAndThen",[AndThen, HAndThen.mk, Unit, AndThen.andThen]]
["«term-_»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["decPropToBool",[Decidable, CoeDep.mk, Bool, Decidable.decide]]
["Bool.and_false",[Bool, Eq, and, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl]]
["LawfulApplicative.pure_seq",[Applicative, LawfulApplicative]]
["Lean.Name.append",[Lean.Name, Lean.Name.below, Lean.Name.anonymous, String, UInt64, Lean.Name.str, Lean.Name.mkStr, PProd.fst, PUnit, PProd, Nat, Lean.Name.num, Lean.Name.mkNum]]
["List.hasDecEq.proof_4",[List, Eq, List.cons, rfl]]
["Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp",[Trans.mk, Nat, LT.lt, instLTNat, LE.le, instLENat, Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1]]
["StateRefT'",[ReaderT, ST.Ref]]
["StateT.run_bind_lift",[Monad, LawfulMonad, StateT, of_eq_true, Eq, Prod, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk, Eq.trans, True, congrFun, congrArg, LawfulMonad.bind_assoc, funext, LawfulMonad.pure_bind, eq_self]]
["StateRefT'.run",[Monad, MonadLiftT, ST, StateRefT', Bind.bind, Monad.toBind, ST.Ref, Prod, ST.mkRef, ST.Ref.get, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk]]
["Lean.Macro.Context.noConfusionType",[Lean.Macro.Context, PointedType.type, Lean.Name, Lean.MacroScope, Nat, Lean.Syntax, Eq]]
["instSubUInt64",[Sub.mk, UInt64, UInt64.sub]]
["Option.bind",[Option, Option.none]]
["«term_>>=_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["MonadReaderOf.noConfusionType",[MonadReaderOf, Eq]]
["UInt8.land",[UInt8, UInt8.mk, Fin.land, UInt8.size, UInt8.val]]
["ReaderT.run_seq",[Monad, LawfulMonad, ReaderT, Eq.mpr, Eq, ReaderT.run, Seq.seq, Applicative.toSeq, Monad.toApplicative, ReaderT.instMonadReaderT, Unit, Bind.bind, Monad.toBind, Functor.map, Applicative.toFunctor, Eq.refl, seq_eq_bind, rfl]]
["fixCore",[fixCore1]]
["Lean.Meta.Rewrite.Config.mk.sizeOf_spec",[Lean.Meta.TransparencyMode, Bool, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk]]
["Bool.or_true",[Bool, Eq, or, Bool.true, Bool.false, rfl, Eq.symm, Eq.refl]]
["«term‹_›»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["PSigma.mk.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["False.elim",[False]]
["String.next",[Char, String.get, HAdd.hAdd, String.Pos, Nat, instHAdd, instAddNat, String.csize]]
["Quot.indep",[Quot, Quot.mk, PSigma.mk]]
["Lean.Parser.Tactic.inductionAlt",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
["Alternative.failure",[Alternative]]
["instStreamProdProd",[outParam, Stream, Stream.mk, Prod, Option, Stream.next?, Unit, Option.none, Option.some, Prod.mk]]
["instLEUInt32",[LE.mk, UInt32, LE.le, Fin, UInt32.size, instLEFin, UInt32.val]]
["Quotient.inductionOn",[Setoid, Quotient, Quotient.mk, Quot.inductionOn, Setoid.r]]
["ite_true",[rfl, ite, True, instDecidableTrue]]
["instDecidableEqFin",[Nat, Fin, Decidable, Eq, Fin.val, decEq, instDecidableEqNat, Decidable.isTrue, Fin.eq_of_val_eq, Not, Decidable.isFalse, Fin.ne_of_val_ne]]
["Fin.elim0",[Fin, OfNat.ofNat, Nat, instOfNatNat, LT.lt, instLTNat, absurd, Nat.not_lt_zero]]
["USize.xor",[USize, USize.mk, Fin.xor, USize.size, USize.val]]
["Lean.Syntax.SepArray.elemsAndSeps",[String, Lean.Syntax.SepArray]]
["Nat.lt_of_lt_of_eq",[Nat, LT.lt, instLTNat, Eq]]
["Prod.mk.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["recSubsingleton",[Decidable, Not, Subsingleton]]
["IO.Process.Output.mk.sizeOf_spec",[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar]]
["ReaderT.run_monadMap",[Monad, MonadFunctor, ReaderT, rfl, ReaderT.run, MonadFunctorT.monadMap, instMonadFunctorT, ReaderT.instMonadFunctorReaderT, monadFunctorRefl]]
["Int.instInhabitedInt",[Inhabited.mk, Int, Int.ofNat, OfNat.ofNat, Nat, instOfNatNat]]
["optParam_eq",[rfl, optParam]]
["instDecidableAnd.proof_2",[Not, And, And.left]]
["EStateM.orElse'",[outParam, EStateM.Backtrackable, EStateM, optParam, Bool, Bool.true, EStateM.Backtrackable.save, EStateM.Result, EStateM.Backtrackable.restore, EStateM.Result.error, ite, Eq, instDecidableEqBool]]
["System.SearchPath.separator",[ite, Char, Eq, Bool, System.Platform.isWindows, Bool.true, instDecidableEqBool, Char.ofNat]]
["Array.foldlM.loop",[Monad, Array, Nat, LE.le, instLENat, Array.size, Nat.below, dite, LT.lt, instLTNat, Nat.decLt, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Nat.succ, Bind.bind, Monad.toBind, Array.get, Fin.mk, Array.foldlM.loop.proof_1, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Not]]
["Lean.Syntax.getId",[Lean.Syntax, Lean.Name, Lean.SourceInfo, Substring, List, Prod, String, Lean.Name.anonymous]]
["MonadControl.restoreM",[MonadControl]]
["DecidableRel",[Decidable]]
["Id.run",[Id]]
["Quotient.sound",[Quotient.sound.proof_1]]
["List.anyM",[Monad, Bool, List, List.below, Unit, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.false, List.cons, Bind.bind, Monad.toBind, Bool.true, PProd.fst, PUnit, PProd]]
["CoeTC.noConfusionType",[CoeTC, Eq]]
["Lean.Meta.TransparencyMode.default.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["instMonadReaderOfReaderT",[Monad, MonadReaderOf.mk, ReaderT, ReaderT.read]]
["fixCore3",[bfix3, USize.size]]
["instReprAtomUInt8",[ReprAtom.mk, UInt8]]
["String.split",[String, Char, Bool, String.splitAux, OfNat.ofNat, String.Pos, instOfNatNat, List.nil]]
["Array.erase",[BEq, Array, Option, Fin, Array.size, Array.indexOf?, Unit, Array.feraseIdx]]
["Lean.interpolatedStrLitKind",[Lean.Name.mkStr, Lean.Name.anonymous]]
["Lean.Name.instBEqName",[BEq.mk, Lean.Name, Lean.Name.beq]]
["Quot.indBeta",[Quot, Quot.mk, rfl, Quot.ind]]
["ReaderT.ext",[Monad, ReaderT, Eq, ReaderT.run, funext, id]]
["UInt16.noConfusionType",[UInt16, Fin, UInt16.size, Eq]]
["«term_∘_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Inhabited.default",[Inhabited]]
["UInt32.decEq.proof_2",[Fin, UInt32.size, Not, Eq, UInt32, UInt32.mk, False, absurd]]
["«term_<||>_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Array.filterSepElems",[Array, Lean.Syntax, Bool, Id.run, Array.filterSepElemsM, Id, Id.instMonadId]]
["Lean.Meta.Simp.Config.mk.inj",[Nat, Bool, Eq, Lean.Meta.Simp.Config, Lean.Meta.Simp.Config.mk, And, And.intro]]
["Lean.strLitKind",[Lean.Name.mkStr, Lean.Name.anonymous]]
["instShiftRightUInt32",[ShiftRight.mk, UInt32, UInt32.shiftRight]]
["MonadState.get",[MonadState]]
["dite_congr",[Decidable, Not, Eq, Eq.mpr_prop, Eq.mpr_not, Or, Decidable.em, dite, Or.inl, Eq.mpr, Eq.refl, dif_pos, Eq.symm, Or.inr, dif_neg]]
["Lean.Syntax.setHeadInfo",[Lean.Syntax, Lean.SourceInfo, Option, Lean.Syntax.setHeadInfoAux, Unit]]
["Char.ne_of_val_ne",[Char, Not, Eq, UInt32, Char.val, absurd, False, Char.val_eq_of_eq]]
["instModUInt32",[Mod.mk, UInt32, UInt32.mod]]
["Lean.PrettyPrinter.instMonadQuotationUnexpandM",[Lean.MonadQuotation.mk, Lean.PrettyPrinter.UnexpandM, Lean.MonadRef.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, EStateM.instMonadEStateM, Unit, Lean.Syntax, Lean.Syntax.missing, id, Lean.MacroScope, OfNat.ofNat, instOfNatNat, Lean.Name, Lean.Name.mkStr, Lean.Name.anonymous]]
["USize.add",[USize, USize.mk, HAdd.hAdd, Fin, USize.size, instHAdd, Fin.instAddFin, USize.val]]
["Lean.Parser.Tactic.tacticSuffices_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["NonScalar.mk.sizeOf_spec",[Nat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat]]
["termMax_prec",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
["Int.pow",[Int, Nat, Nat.below, Unit, OfNat.ofNat, Int.instOfNatInt, Nat.succ, HMul.hMul, instHMul, Int.instMulInt, PProd.fst, PUnit, PProd]]
["Option.orElse",[Option, Unit, Option.some, Unit.unit]]
["Lean.Syntax.SepArray.getElems",[String, Lean.Syntax.SepArray, Array.getSepElems, Lean.Syntax, Lean.Syntax.SepArray.elemsAndSeps]]
["Nat.mul_zero",[Nat, rfl, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat]]
["IO.Process.SpawnArgs.noConfusionType",[IO.Process.SpawnArgs, IO.Process.StdioConfig, String, Array, Option, System.FilePath, Prod, Eq]]
["Lean.SourceInfo.fromRef",[Lean.Syntax, Option, String.Pos, Lean.SourceInfo, Lean.Syntax.getPos?, Bool.false, Lean.Syntax.getTailPos?, Lean.SourceInfo.synthetic, Lean.SourceInfo.none]]
["«term_⊕_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Fin.shiftRight.proof_1",[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, HShiftRight.hShiftRight, instHShiftRight, Nat.instShiftRightNat]]
["of_eq_true",[Eq, True, trivial, Eq.symm]]
["Lean.version.patch",[Unit.unit]]
["Lean.Parser.Tactic.tacticHave'_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["System.FilePath.exeExtension",[ite, String, Eq, Bool, System.Platform.isWindows, Bool.true, instDecidableEqBool]]
["Acc.inv",[Acc.inv.proof_1]]
["Monad.noConfusionType",[Monad, Applicative, Bind, Eq]]
["UInt64.ofNat",[UInt64.mk, Fin.ofNat, OfNat.ofNat, Nat, instOfNatNat]]
["instMonadExceptOfExceptT",[Monad, MonadExceptOf, MonadExceptOf.mk, ExceptT, ExceptT.mk, throwThe, Except, tryCatchThe]]
["Option.filter",[Bool, Option, ite, Eq, Bool.true, instDecidableEqBool, Option.some, Option.none, Unit]]
["List.enumFrom",[Nat, List, Prod, List.below, List.nil, List.cons, Prod.mk, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
["instDecidableIff.proof_2",[Not, Iff, Iff.mp]]
["UInt64.land",[UInt64, UInt64.mk, Fin.land, UInt64.size, UInt64.val]]
["instSubUInt16",[Sub.mk, UInt16, UInt16.sub]]
["Lean.Macro.withFreshMacroScope",[Lean.MacroM, Bind.bind, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.MacroScope, MonadState.modifyGet, instMonadState, instMonadStateOf, ReaderT.instMonadLiftReaderT, EStateM.instMonadStateOfEStateM, Prod.mk, Lean.Macro.State.macroScope, Lean.Macro.State.mk, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Lean.Macro.State.traceMsgs, MonadWithReader.withReader, instMonadWithReader, instMonadWithReaderOfReaderT, Lean.Macro.Context.mk, Lean.Macro.Context.methods, Lean.Macro.Context.mainModule, Lean.Macro.Context.currRecDepth, Lean.Macro.Context.maxRecDepth, Lean.Macro.Context.ref]]
["Std.Format.bracketFill",[String, Std.Format, Std.Format.fill, Std.Format.nest, Int.ofNat, String.length, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text]]
["Nat.lt_of_le_and_ne",[Nat, LE.le, instLENat, Ne, Or, Eq, LT.lt, instLTNat, Nat.eq_or_lt_of_le, absurd]]
["MonadFunctorT.monadMap",[MonadFunctorT]]
["Lean.Parser.Tactic.Conv.convSeq",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.Parser.Tactic.Conv.convSeq1Indented, Lean.Parser.Tactic.Conv.convSeqBracketed]]
["Lean.Syntax.decodeScientificLitVal?",[String, String.Pos, Nat, Bool, Option, Prod, String.length, ite, Eq, BEq.beq, instBEq, instDecidableEqNat, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Option.none, Char, String.get, Char.isDigit, Lean.Syntax.decodeScientificLitVal?.decodeAfterExp, Lean.Syntax.decodeScientificLitVal?.decodeExp, Lean.Syntax.decodeScientificLitVal?.decodeAfterDot, Lean.Syntax.decodeScientificLitVal?.decode]]
["IO.Error.mkInappropriateTypeFile",[Function.comp, String, Option, UInt32, IO.Error, IO.Error.inappropriateType, Option.some]]
["eq_true_of_ne_false",[Bool, Not, Eq, Bool.false, Bool.true, rfl, False.elim]]
["DoResultPR.noConfusionType",[DoResultPR, Eq]]
["IO.Error.mkHardwareFault",[IO.Error.hardwareFault]]
["Lean.Syntax.setTailInfo",[Lean.Syntax, Lean.SourceInfo, Option, Lean.Syntax.setTailInfoAux, Unit]]
["Lean.Syntax.matchesNull",[Lean.Syntax, Nat, Lean.Syntax.isNodeOf, Lean.nullKind]]
["Char.isAlpha",[Char, or, Char.isUpper, Char.isLower]]
["Monad.toApplicative",[Monad]]
["PUnit.eq_punit",[PUnit, PUnit.subsingleton, PUnit.unit]]
["List.filterAux",[Bool, List, List.below, List.nil, List.reverse, List.cons, Unit, PProd.fst, PUnit, PProd]]
["UInt64.mk.sizeOf_spec",[Fin, UInt64.size, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["Substring.atEnd",[Substring, String.Pos, Bool, String, BEq.beq, instBEq, instDecidableEqNat, HAdd.hAdd, instHAdd, instAddNat]]
["Nat.succ_pos",[Nat, Nat.zero_lt_succ]]
["Sub.sub",[Sub]]
["instDivUInt64",[Div.mk, UInt64, UInt64.div]]
["Option.get!",[Inhabited, Option, Unit, panicWithPosWithDecl, OfNat.ofNat, Nat, instOfNatNat]]
["if_neg",[Decidable, Not, Eq, ite, absurd, Decidable.isTrue, rfl, Decidable.isFalse]]
["Lean.Name.str.inj",[Lean.Name, String, UInt64, Eq, Lean.Name.str, And, And.intro]]
["Or.intro_right",[Or.inr]]
["Nat.sub_lt",[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, absurd, Nat.lt_irrefl, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Eq.symm, Nat.succ_sub_succ_eq_sub]]
["instToStringSum",[ToString, ToString.mk, Sum, String, HAppend.hAppend, instHAppend, String.instAppendString, addParenHeuristic, ToString.toString]]
["instToStringUInt16",[ToString.mk, UInt16, ToString.toString, Nat, instToStringNat, UInt16.toNat]]
["USize.sub",[USize, USize.mk, HSub.hSub, Fin, USize.size, instHSub, Fin.instSubFin, USize.val]]
["List.eraseReps",[BEq, List, Unit, List.nil, List.eraseRepsAux]]
["Nat.any",[Nat, Bool, Nat.anyAux]]
["Subarray.mk.sizeOf_spec",[SizeOf, Array, Nat, LE.le, instLENat, Array.size, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, instSizeOfNat, instSizeOf]]
["reprStr",[Repr, Std.Format.pretty, Repr.reprPrec, OfNat.ofNat, Nat, instOfNatNat, Std.Format.defWidth]]
["Lean.Syntax.below",[Lean.Syntax, Array, List, PUnit, Lean.SyntaxNodeKind, PProd, Lean.SourceInfo, String, Substring, Lean.Name, Prod]]
["StateT.instLawfulMonadStateT",[StateT.instLawfulMonadStateT.proof_1]]
["OfScientific.noConfusionType",[OfScientific, Nat, Bool, Eq]]
["Subtype.instInhabitedSubtype",[Inhabited.mk, Subtype, Subtype.mk]]
["instReprId_1",[Repr, inferInstanceAs]]
["ExceptT.ext",[Monad, ExceptT, Eq, Except, ExceptT.run, id]]
["List.replace",[BEq, List, List.below, List.nil, List.cons, Bool, BEq.beq, Unit, PProd.fst, PUnit, PProd]]
["Lean.Parser.Tactic.tacticRefine_lift_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
["Nat.fold",[Nat, Nat.foldAux]]
["Lean.Syntax.copyHeadTailInfoFrom",[Lean.Syntax, Lean.Syntax.setTailInfo, Lean.Syntax.setHeadInfo, Lean.Syntax.getHeadInfo, Lean.Syntax.getTailInfo]]
["MonadReaderOf.read",[MonadReaderOf]]
["BEq.beq",[BEq]]
["instSubsingleton.proof_1",[Subsingleton.intro, proofIrrel]]
["Nat.succ_add",[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.below, rfl, OfNat.ofNat, instOfNatNat, congrArg, Nat.add, PProd.fst, PUnit, PProd]]
["Function.Equiv.trans",[Function.Equiv, Eq.trans]]
["String.Iterator.isPrefixOfRemaining",[String.Iterator, String, String.Pos, String.Iterator.mk, Bool, Decidable.decide, Eq, String.extract, String.bsize, HAdd.hAdd, Nat, instHAdd, instAddNat, HSub.hSub, instHSub, instSubNat, instDecidableEqString]]
["List.append_nil",[List, Eq, HAppend.hAppend, instHAppend, List.instAppendList, List.nil, rfl, of_eq_true, List.cons, List.append, Eq.trans, True, congrFun, congrArg, id, eq_self]]
["Bool.false_and",[Bool, Eq, and, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl]]
["Lean.Parser.Tactic.simpPre",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol]]
["Lean.Name.instReprName",[Repr.mk, Lean.Name, Lean.Name.reprPrec]]
["Array.forInUnsafe",[Monad, Array, ForInStep, USize, USize.ofNat, Array.size, OfNat.ofNat, instOfNatUSize, Array.forInUnsafe.loop]]
["Char.utf8Size",[Char, UInt32, Char.val, ite, LE.le, instLEUInt32, UInt32.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, Char.utf8Size.proof_1, instDecidableLe, Char.utf8Size.proof_2, Char.utf8Size.proof_3, Char.utf8Size.proof_4, Char.utf8Size.proof_5, Char.utf8Size.proof_6, Char.utf8Size.proof_7]]
["Ordering.isLE",[Ordering, Bool, Unit, Bool.true, Bool.false]]
["PointedType.type",[PointedType]]
["Iff.rfl",[Iff.refl]]
["prodHasDecidableLt",[LT, DecidableEq, Decidable, LT.lt, Prod, inferInstanceAs, Or, Prod.fst, And, Eq, Prod.snd, instDecidableOr, instDecidableAnd]]
["Substring.toIterator",[Substring, String.Iterator, String, String.Pos, String.Iterator.mk]]
["Float.noConfusionType",[Float, FloatSpec.float, floatSpec, Eq]]
["Array.foldlM.proof_1",[Array, Nat.le_refl, Array.size]]
["dite",[Decidable, Not]]
["IO.Process.Output.stderr",[IO.Process.Output]]
["List.mapM",[Monad, List, List.below, Unit, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, List.cons, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd]]
["Task.spawn",[Unit, optParam, Task.Priority, Task.Priority.default, Task.pure, Unit.unit]]
["IO.Error.interrupted.inj",[String, UInt32, Eq, IO.Error, IO.Error.interrupted, And, And.intro]]
["Subarray.foldl",[Subarray, Id.run, Subarray.foldlM, Id, Id.instMonadId]]
["Int.instDecidableEqInt",[Int.decEq]]
["coeOfHeafOfTCOfTail",[CoeHead, CoeTail, CoeTC, CoeHTCT.mk, coeTail, coeTC, coeHead]]
["instInhabitedOption",[Inhabited.mk, Option, Option.none]]
["List.instLTList",[LT, LT.mk, List, List.lt]]
["List.tail?",[List, Option, Unit, Option.none, Option.some]]
["floatDecLt",[Float, Float.decLt]]
["Bool.noConfusionType",[Bool]]
["Fin.mk.inj",[Nat, LT.lt, instLTNat, Eq, Fin, Fin.mk]]
["CoeSort.noConfusionType",[outParam, CoeSort, Eq]]
["UInt32.modn",[UInt32, UInt32.mk, HMod.hMod, Fin, UInt32.size, Nat, Fin.instHModFinNatFin, UInt32.val]]
["«term_::_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["instReprString",[Repr.mk, String, Nat, Std.Format.text, String.quote]]
["instAddNat",[Add.mk, Nat, Nat.add]]
["USize.ofNat",[USize.mk, Fin.ofNat', USize.size, usize_size_gt_zero]]
["List.reverse_nil",[rfl, List, List.reverse, List.nil]]
["Lean.Parser.Tactic.simpStar",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.symbol]]
["System.instReprFilePath",[Repr.mk, System.FilePath, Repr.addAppParen, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.text, repr, String, instReprString, System.FilePath.toString]]
["PSum.inl.inj",[Eq, PSum, PSum.inl]]
["«term_=_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["EIO.toIO'",[EIO, EIO.toIO, Except, panicWithPosWithDecl, IO.Error, IO.instInhabitedError, OfNat.ofNat, Nat, instOfNatNat, observing, instMonadEIO, instMonadExcept, instMonadExceptOfEIO]]
["Lean.Parser.Tactic.tacticLet'_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["Lean.MonadQuotation.addMacroScope",[Lean.MonadQuotation, Monad, Lean.Name, Bind.bind, Monad.toBind, Lean.MonadQuotation.getMainModule, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.addMacroScope]]
["instReprUInt16",[Repr.mk, UInt16, Nat, repr, instReprNat, UInt16.toNat]]
["StateT.map",[Monad, StateT, Bind.bind, Monad.toBind, Prod, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk]]
["Subtype.mk.inj",[Eq, Subtype, Subtype.mk]]
["instDivUInt32",[Div.mk, UInt32, UInt32.div]]
["ExceptT.map",[Monad, ExceptT, ExceptT.mk, Bind.bind, Monad.toBind, Except, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.ok, Except.error]]
["IO.FS.Stream.flush",[IO.FS.Stream]]
["Array.anyMUnsafe",[Monad, Bool, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, USize, ite, LT.lt, instLTNat, Nat.decLt, LE.le, instLENat, Nat.decLe, USize.ofNat, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.false, Array.anyMUnsafe.any]]
["Lean.Syntax.ibelow",[Lean.Syntax, Array, List, True, Lean.SyntaxNodeKind, And, Lean.SourceInfo, String, Substring, Lean.Name, Prod]]
["ExceptCpsT.runCatch_throw",[Monad, rfl, ExceptCpsT.runCatch, MonadExcept.throw, ExceptCpsT, instMonadExcept, ExceptCpsT.instMonadExceptOfExceptCpsT]]
["String.Iterator.extract",[String.Iterator, String, String.Pos, String.Iterator.mk, ite, Eq, Bool, or, Decidable.decide, Ne, instDecidableNot, instDecidableEqString, GT.gt, instLTNat, Nat.decLt, Bool.true, instDecidableEqBool, String.extract]]
["Ne",[Not, Eq]]
["IO.Error.permissionDenied.injEq",[Option, String, UInt32, Eq.propIntro, Eq, IO.Error, IO.Error.permissionDenied, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["HAnd.hAnd",[HAnd]]
["List.mapA",[Applicative, List, List.below, Unit, List.nil, Pure.pure, Applicative.toPure, List.cons, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, PProd.fst, PUnit, PProd]]
["Nat.instTransLtArrowNatArrowNatPropLeArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1",[Nat, Nat.lt_of_lt_of_le]]
["instInhabitedPNonScalar",[Inhabited.mk, PNonScalar, PNonScalar.mk, arbitrary, Nat, instInhabitedNat]]
["UInt16.mk.sizeOf_spec",[Fin, UInt16.size, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["Classical.epsilon",[Nonempty, Subtype.val, Exists, Classical.strongIndefiniteDescription]]
["instReprId",[Repr, inferInstanceAs]]
["EStateM.map",[EStateM, EStateM.Result, EStateM.Result.ok, EStateM.Result.error]]
["ExceptT",[Except]]
["EStateM.instToStringResult",[ToString, ToString.mk, EStateM.Result, String, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString]]
["guard",[Alternative, Decidable, ite, Unit, Pure.pure, Applicative.toPure, Alternative.toApplicative, Unit.unit, Alternative.failure]]
["Decidable.em",[Decidable, Decidable.byCases, Or, Not, Or.inl, Or.inr]]
["IO.Error.illegalOperation.sizeOf_spec",[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar]]
["Array.modifyM.proof_1",[Inhabited, Array, Nat, LT.lt, instLTNat, Array.size, Eq.symm, Array.set, Fin.mk, arbitrary, Array.size_set]]
["unsafeEIO",[EIO, EStateM.Result, IO.RealWorld, Except, EStateM.run, Unit.unit, Except.ok, Except.error]]
["instOrdInt",[Ord.mk, Int, compareOfLessAndEq, Int.instLTInt, Int.decLt, Int.instDecidableEqInt]]
["eq_true",[propext, True, Iff.intro, trivial]]
["Array.eraseIdx",[Array, Nat, ite, LT.lt, instLTNat, Array.size, Nat.decLt, Array.eraseIdxAux, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
["EStateM.run'",[EStateM, EStateM.Result, Option, EStateM.run, Option.some, Option.none]]
["IO.Error.illegalOperation.inj",[UInt32, String, Eq, IO.Error, IO.Error.illegalOperation, And, And.intro]]
["String.atEnd",[String, String.Pos, Bool, Decidable.decide, GE.ge, instLENat, String.utf8ByteSize, Nat.decLe]]
["List.hasDecidableLt",[LT, DecidableRel, LT.lt, List, Decidable, List.instLTList, List.below, Unit, List.nil, Decidable.isFalse, List.hasDecidableLt.proof_1, Decidable.isTrue, List.cons, List.lt.nil, List.hasDecidableLt.proof_2, List.lt.head, Not, List.hasDecidableLt.proof_3, PProd.fst, PUnit, PProd, List.lt.tail, List.hasDecidableLt.proof_4]]
["String.splitOn",[String, optParam, ite, List, Eq, Bool, BEq.beq, instBEq, instDecidableEqString, Bool.true, instDecidableEqBool, List.cons, List.nil, String.splitOnAux, OfNat.ofNat, String.Pos, instOfNatNat]]
["«termΣ'_,_»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
["Thunk.noConfusionType",[Thunk, Unit, Eq]]
["Quotient.recOnSubsingleton₂.proof_1",[Setoid, Quotient, Subsingleton, Quotient.mk, Quot.recOnSubsingleton, Setoid.r, Quot.mk, inferInstance, instSubsingleton]]
["EStateM.adaptExcept",[EStateM, EStateM.Result, EStateM.Result.error, EStateM.Result.ok]]
["Subrelation.wf.proof_1",[Subrelation, WellFounded, WellFounded.intro, Subrelation.accessible, WellFounded.apply]]
["isValidChar",[UInt32, Or, LT.lt, instLTUInt32, OfNat.ofNat, instOfNatUInt32, And]]
["instSubUInt8",[Sub.mk, UInt8, UInt8.sub]]
["Nat.succ_mul",[Nat, Eq, HMul.hMul, instHMul, instMulNat, Nat.succ, HAdd.hAdd, instHAdd, instAddNat, rfl, Nat.zero, Eq.mpr, Eq.refl, Nat.mul_succ, Nat.add_succ, Nat.add_right_comm]]
["UInt16.decEq",[UInt16, Decidable, Eq, Fin, UInt16.size, dite, UInt16.mk, instDecidableEqFin, Decidable.isTrue, UInt16.decEq.proof_1, Not, Decidable.isFalse, UInt16.decEq.proof_2]]
["Substring.isEmpty",[Substring, BEq.beq, Nat, instBEq, instDecidableEqNat, Substring.bsize, OfNat.ofNat, instOfNatNat]]
["String.join",[List, String, List.foldl, HAppend.hAppend, instHAppend, String.instAppendString]]
["Int.instModInt",[Mod.mk, Int, Int.mod]]
["instToStringSubarray",[ToString, ToString.mk, Subarray, ToString.toString, Array, Array.instToStringArray, Subarray.toArray]]
["UInt8.mk.sizeOf_spec",[Fin, UInt8.size, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["PSigma.noConfusionType",[PSigma, Eq, HEq]]
["Lean.Syntax.getPos?",[Lean.Syntax, optParam, Bool, Bool.false, Lean.SourceInfo.getPos?, Lean.Syntax.getHeadInfo]]
["instToStreamArraySubarray",[ToStream.mk, Array, Subarray, Array.toSubarray, OfNat.ofNat, optParam, Nat, instOfNatNat, Array.size]]
["Float.mk.injEq",[FloatSpec.float, floatSpec, Eq.propIntro, Eq, Float, Float.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["instHXor",[Xor, HXor.mk, Xor.xor]]
["instHMod",[Mod, HMod.mk, Mod.mod]]
["Array.appendCore.loop",[Array, Nat, Nat.below, dite, LT.lt, instLTNat, Array.size, Nat.decLt, Unit, Nat.succ, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.push, Array.get, Fin.mk, Not]]
["and_self",[propext, And, Iff.intro, And.left, And.intro]]
["HMul.hMul",[HMul]]
["implies_congr",[Eq, rfl]]
["Lean.version.minor",[Unit.unit]]
["List.reverseAux_reverseAux_nil",[List, Eq, List.reverseAux, List.nil, rfl, of_eq_true, List.cons, Eq.trans, True, congrFun, congrArg, eq_self]]
["List.toArrayAux",[List, Array, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd, Array.push]]
["Lean.withRef",[Monad, Lean.MonadRef, Lean.Syntax, Bind.bind, Monad.toBind, Lean.MonadRef.getRef, Lean.replaceRef, Lean.MonadRef.withRef]]
["«termΣ_,_»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
["UInt16.mul",[UInt16, UInt16.mk, HMul.hMul, Fin, UInt16.size, instHMul, Fin.instMulFin, UInt16.val]]
["String.revFind",[String, Char, Bool, ite, Option, String.Pos, Eq, BEq.beq, Nat, instBEq, instDecidableEqNat, String.bsize, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Option.none, String.revFindAux, String.prev]]
["Nat.le_step",[Nat, LE.le, instLENat, Nat.le.step]]
["Lean.unifConstraintElem",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.unifConstraint, Lean.ParserDescr.unary, Lean.ParserDescr.symbol]]
["Nat.mod_zero",[Nat]]
["Char.utf8Size.proof_7",[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
["DoResultSBC.break.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["EStateM.dummyRestore",[PUnit]]
["instMonadControlStateRefT'",[inferInstanceAs, MonadControl, ReaderT, ST.Ref, instMonadControlReaderT]]
["List.allM",[Monad, Bool, List, List.below, Unit, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.true, List.cons, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd, Bool.false]]
["Quotient.exists_rep",[Setoid, Quotient, Quot.exists_rep, Setoid.r]]
["List.length",[List, Nat, List.below, Unit, List.nil, OfNat.ofNat, instOfNatNat, List.cons, HAdd.hAdd, instHAdd, instAddNat, PProd.fst, PUnit, PProd]]
["Coe.coe",[Coe]]
["IO.FileRight.noConfusionType",[IO.FileRight, IO.AccessRight, Eq]]
["Std.Format.joinSuffix",[Std.ToFormat, List, Std.Format, List.below, List.nil, Std.Format.nil, List.cons, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.ToFormat.format, PProd.fst, PUnit, PProd]]
["Array.mapIdxM.map.proof_1",[Array, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Eq.mpr, LT.lt, instLTNat, Eq.refl, Eq.symm, Nat.add_assoc, Nat.add_comm, Nat.le_add_right, Nat.succ]]
["StateT.run_set",[Monad, rfl, Prod, PUnit, StateT.run, MonadStateOf.set, StateT, instMonadStateOfStateT]]
["Subtype.existsOfSubtype.proof_1",[Subtype, Exists, Exists.intro]]
["Nat.instModNat",[Mod.mk, Nat, Nat.mod]]
["IO.Process.SpawnArgs.mk.injEq",[IO.Process.StdioConfig, String, Array, Option, System.FilePath, Prod, Eq.propIntro, Eq, IO.Process.SpawnArgs, IO.Process.SpawnArgs.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["List.instLEList",[LT, LE.mk, List, List.le]]
["andM",[Monad, ToBool, Bind.bind, Monad.toBind, Bool, ToBool.toBool, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["Std.Format.append.inj",[Std.Format, Eq, Std.Format.append, And, And.intro]]
["Bind.bind",[Bind]]
["Quot.hrecOn.proof_1",[Quot, Quot.mk, HEq, eq_of_heq, Quot.sound]]
["Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp.proof_1",[Nat, Nat.le_trans]]
["Lean.Macro.instInhabitedState",[Inhabited.mk, Lean.Macro.State, Lean.Macro.State.mk, arbitrary, Lean.MacroScope, instInhabitedNat, List, Prod, Lean.Name, String, instInhabitedList]]
["Array.mk.sizeOf_spec",[SizeOf, List, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk]]
["Lean.MonadQuotation.toMonadRef",[Lean.MonadQuotation]]
["bfix4",[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd]]
["Squash.mk",[Quot.mk, True]]
["Prod.lexAccessible.proof_1",[Acc, Prod, Prod.Lex, Prod.mk, Acc.intro, Eq, HEq, Prod.Lex.left, Eq.symm, eq_of_heq, Prod.Lex.right, Eq.refl, HEq.refl]]
["StateT.run_lift",[Monad, rfl, Prod, StateT.run, StateT.lift]]
["«term_!=_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["DoResultBC.continue.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["Lean.MonadQuotation.withFreshMacroScope",[Lean.MonadQuotation]]
["Fin.instShiftLeftFin",[Nat, ShiftLeft.mk, Fin, Fin.shiftLeft]]
["LawfulFunctor.comp_map",[Functor, LawfulFunctor]]
["Nat.toUInt64",[UInt64.ofNat]]
["Lean.Parser.Tactic.tacticRepeat_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["StateT.instMonadStateT",[Monad, Monad.mk, StateT, Applicative.mk, Functor.mk, StateT.map, Pure.mk, StateT.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk, StateT.bind]]
["instOrdUInt16",[Ord.mk, UInt16, compareOfLessAndEq, instLTUInt16, instDecidableLt_2, instDecidableEqUInt16]]
["UInt16.shiftRight",[UInt16, UInt16.mk, HShiftRight.hShiftRight, Fin, UInt16.size, instHShiftRight, Fin.instShiftRightFin, UInt16.val, UInt16.modn, OfNat.ofNat, Nat, instOfNatNat]]
["Char.isValidChar_zero",[Or.inl, LT.lt, UInt32, instLTUInt32, OfNat.ofNat, instOfNatUInt32, And, of_decide_eq_true, instDecidableLt, Eq.refl, Bool, Bool.true]]
["instOrdUInt32",[Ord.mk, UInt32, compareOfLessAndEq, instLTUInt32, instDecidableLt, instDecidableEqUInt32]]
["LawfulApplicative.seqLeft_eq",[Applicative, LawfulApplicative]]
["ReaderT.bind",[Monad, ReaderT, Bind.bind, Monad.toBind]]
["Squash.ind",[Squash, Squash.mk, Quot.ind, True]]
["Fin.instMulFin",[Nat, Mul.mk, Fin, Fin.mul]]
["EStateM.instInhabitedResult",[Inhabited, Inhabited.mk, EStateM.Result, EStateM.Result.error, arbitrary]]
["Applicative.toSeqRight",[Applicative]]
["Std.Format.group.inj",[Std.Format, Std.Format.FlattenBehavior, Eq, Std.Format.group, And, optParam, Std.Format.FlattenBehavior.allOrNone, And.intro]]
["Quot.liftOn",[Quot, Eq, Quot.lift]]
["strictAnd",[Bool, and]]
["Nat.right_distrib",[Nat]]
["Array.isPrefixOf",[BEq, Array, dite, Bool, LE.le, Nat, instLENat, Array.size, Nat.decLe, Array.isPrefixOfAux, OfNat.ofNat, instOfNatNat, Not, Bool.false]]
["instInhabitedArrow_1",[Monad, Inhabited.mk, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["Lean.Parser.Tactic.rotateLeft",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
["dif_pos",[Decidable, Not, Eq, dite, rfl, Decidable.isTrue, absurd, Decidable.isFalse]]
["solve",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
["instToStringFin",[Nat, ToString.mk, Fin, ToString.toString, instToStringNat, Fin.val]]
["instCoeTail_1",[outParam, CoeSort, CoeTail.mk, coeSort]]
["Lean.Parser.Tactic.tacticTry_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["instOrdString",[Ord.mk, String, compareOfLessAndEq, String.instLTString, String.decLt, instDecidableEqString]]
["instDecidableEqProd.proof_2",[Not, Eq, Prod, Prod.mk, False, absurd]]
["throwThe",[MonadExceptOf, MonadExceptOf.throw]]
["WellFounded.apply",[WellFounded.apply.proof_1]]
["fixCore2",[bfix2, USize.size]]
["IO.FileRight.user",[IO.FileRight]]
["UInt32.decEq",[UInt32, Decidable, Eq, Fin, UInt32.size, dite, UInt32.mk, instDecidableEqFin, Decidable.isTrue, UInt32.decEq.proof_1, Not, Decidable.isFalse, UInt32.decEq.proof_2]]
["Lean.mkFreshId",[Monad, Lean.MonadNameGenerator, Bind.bind, Monad.toBind, Lean.NameGenerator, Lean.Name, Lean.MonadNameGenerator.getNGen, Lean.NameGenerator.curr, Unit, Lean.MonadNameGenerator.setNGen, Lean.NameGenerator.next, PUnit, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["Sigma.noConfusionType",[Sigma, Eq, HEq]]
["List.lengthTRAux",[List, Nat, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd, Nat.succ]]
["Nonempty.elim.proof_1",[Nonempty]]
["Bool.true.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["autoParam",[Lean.Syntax]]
["IO.FS.instLTSystemTime",[ltOfOrd, IO.FS.SystemTime, IO.FS.instOrdSystemTime]]
["Substring.trim",[Substring, String, String.Pos, Char.isWhitespace, Substring.mk]]
["Subarray.any",[Bool, Subarray, Id.run, Subarray.anyM, Id, Id.instMonadId]]
["Subsingleton.elim",[Subsingleton.elim.proof_1]]
["IO.FS.FileType.symlink.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["String.Iterator.curr",[String.Iterator, Char, String, String.Pos, String.get]]
["ST.Ref.mk.sizeOf_spec",[SizeOf, PointedType.type, ST.RefPointed, Nonempty, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOf]]
["MonadWithReader.withReader",[MonadWithReader]]
["instHShiftRight",[ShiftRight, HShiftRight.mk, ShiftRight.shiftRight]]
["OptionT.bind",[Monad, OptionT, OptionT.mk, Bind.bind, Monad.toBind, Option, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.none]]
["HXor.noConfusionType",[outParam, HXor, Eq]]
["ite_false",[rfl, ite, False, instDecidableFalse]]
["PLift.up_down",[PLift, Eq, PLift.up, PLift.down, rfl]]
["System.FilePath.fileStem",[System.FilePath, Option.map, String, Option, String.Pos, String.revPosOf, Char.ofNat, Unit, String.extract, OfNat.ofNat, instOfNatNat, System.FilePath.fileName]]
["Char.val_ne_of_ne",[Char, Not, Eq, UInt32, Char.val, absurd, False, Char.eq_of_val_eq]]
["instInhabitedSort",[Inhabited.mk, PUnit]]
["ShiftRight.noConfusionType",[ShiftRight, Eq]]
["Array.binSearchContains",[Inhabited, Array, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Array.size, ite, LT.lt, instLTNat, Nat.decLt, Array.binSearchAux, instInhabitedBool, Option.isSome, Bool.false]]
["Lean.Parser.Tactic.intros",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
["instSubsingletonStateM",[instSubsingletonStateM.proof_1]]
["boolToProp",[Coe.mk, Bool, Eq, Bool.true]]
["«term_≈_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["ReaderT.run_pure",[Monad, rfl, ReaderT.run, Pure.pure, ReaderT, Applicative.toPure, Monad.toApplicative, ReaderT.instMonadReaderT]]
["Fin.shiftLeft",[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, HShiftLeft.hShiftLeft, instHShiftLeft, Nat.instShiftLeftNat, Fin.shiftLeft.proof_1]]
["Lean.Syntax.getKind",[Lean.Syntax, Lean.SyntaxNodeKind, Array, Unit, Lean.Name.mkStr, Lean.Name.anonymous, Lean.SourceInfo, String, Lean.Name.mkSimple, Substring, Lean.Name, List, Prod, Lean.identKind]]
["Std.Range.mk.injEq",[Nat, Eq.propIntro, Eq, Std.Range, Std.Range.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["MonadControlT.stM",[MonadControlT]]
["instShiftLeftUInt8",[ShiftLeft.mk, UInt8, UInt8.shiftLeft]]
["liftCoeM",[MonadLiftT, CoeT, Monad, Bind.bind, Monad.toBind, liftM, Pure.pure, Applicative.toPure, Monad.toApplicative, coe]]
["String.csize",[Char, UInt32.toNat, Char.utf8Size]]
["Sigma.fst",[Sigma]]
["Array.mapSepElemsM",[Monad, Array, Lean.Syntax, OfNat.ofNat, Nat, instOfNatNat, List.toArray, List.nil]]
["EStateM.Backtrackable.noConfusionType",[outParam, EStateM.Backtrackable, Eq]]
["List.get",[List, Nat, LT.lt, instLTNat, List.length, List.below, List.nil, absurd, Nat.not_lt_zero, OfNat.ofNat, instOfNatNat, List.cons, Nat.succ]]
["IO.withStdout",[Monad, MonadFinally, MonadLiftT, IO, IO.FS.Stream, Bind.bind, Monad.toBind, liftM, EIO, IO.Error, IO.setStdout, tryFinally, PUnit, Applicative.toFunctor, Monad.toApplicative, Functor.discard]]
["Lean.Parser.Tactic.inductionAlts",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlt]]
["HAdd.noConfusionType",[outParam, HAdd, Eq]]
["USize.noConfusionType",[USize, Fin, USize.size, Eq]]
["instHMul",[Mul, HMul.mk, Mul.mul]]
["id_eq",[rfl, id]]
["Append.noConfusionType",[Append, Eq]]
["IO.AccessRight.mk.injEq",[Bool, Eq.propIntro, Eq, IO.AccessRight, IO.AccessRight.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Array.modifyOp",[Inhabited, Array, Nat, Array.modify]]
["usize_size_eq",[]]
["UInt64.toUInt16",[UInt64, Nat.toUInt16, UInt64.toNat]]
["Int.instNegInt",[Neg.mk, Int, Int.neg]]
["String.isPrefixOf",[String, String.Pos, Bool, and, Decidable.decide, LE.le, Nat, instLENat, String.length, Nat.decLe, OfNat.ofNat, instOfNatNat, String.isPrefixOf.loop]]
["IO.Process.SpawnArgs.mk.inj",[IO.Process.StdioConfig, String, Array, Option, System.FilePath, Prod, Eq, IO.Process.SpawnArgs, IO.Process.SpawnArgs.mk, And, And.intro]]
["instInhabitedExceptT",[Monad, Inhabited, Inhabited.mk, ExceptT, MonadExcept.throw, instMonadExcept, instMonadExceptOfExceptT_1, arbitrary]]
["Lean.Name.replacePrefix",[Lean.Name, Lean.Name.below, Lean.Name.anonymous, String, UInt64, namedPattern, Lean.Name.str, ite, Eq, Bool, BEq.beq, Lean.Name.instBEqName, Bool.true, instDecidableEqBool, Lean.Name.mkStr, PProd.fst, PUnit, PProd, Nat, Lean.Name.num, Lean.Name.mkNum]]
["Lean.Syntax.isNatLit?",[Lean.Syntax, Lean.SyntaxNodeKind, Option, String, Option.some, Option.none, Nat, Lean.Syntax.isLit?, Lean.Syntax.decodeNatLitVal?, Lean.numLitKind]]
["IO.Process.Output.noConfusionType",[IO.Process.Output, UInt32, String, Eq]]
["instDecidableLe_2",[UInt16, UInt16.decLe]]
["instPowNatNat",[Pow.mk, Nat, Nat.pow]]
["Array.foldrMUnsafe.fold",[Monad, Array, USize, ite, Eq, Bool, BEq.beq, instBEq, instDecidableEqUSize, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, Bind.bind, Monad.toBind, Array.uget, HSub.hSub, instHSub, instSubUSize, OfNat.ofNat, instOfNatUSize, lcProof, LT.lt, Nat, instLTNat, USize.toNat, Array.size, Array.foldrMUnsafe.fold]]
["calc",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, calcStep, Lean.ParserDescr.const]]
["Option.getD",[Option]]
["heq_of_heq_of_eq",[HEq, Eq, HEq.trans, heq_of_eq]]
["Nat.add_comm",[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.below, Eq.symm, OfNat.ofNat, instOfNatNat, Nat.zero_add, Nat.succ]]
["Std.Format.isNil",[Std.Format, Bool, Unit, Bool.true, Bool.false]]
["instToStringExcept",[ToString, ToString.mk, Except, String, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString]]
["instSubsingletonPUnit",[Subsingleton.intro, PUnit, PUnit.subsingleton]]
["Std.Format.FlattenBehavior.noConfusionType",[Std.Format.FlattenBehavior, noConfusionTypeEnum, Nat, instDecidableEqNat, Std.Format.FlattenBehavior.toCtorIdx]]
["Char.repr",[Char, Char.quote]]
["Subtype.property",[Subtype]]
["Lean.Parser.Tactic.«tactic·._»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
["MonadReader.noConfusionType",[outParam, MonadReader, Eq]]
["ExceptCpsT.instLawfulMonadExceptCpsT.proof_1",[LawfulMonad.mk, ExceptCpsT, ExceptCpsT.instMonadExceptCpsT, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, Functor.map, id, Function.comp, SeqLeft.seqLeft, Applicative.toSeqLeft, Unit, SeqRight.seqRight, Applicative.toSeqRight, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, Bind.bind, Monad.toBind]]
["Lean.Parser.Tactic.rewriteSeq",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq, Lean.Parser.Tactic.location]]
["Array.foldlM",[Monad, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, LE.le, instLENat, HSub.hSub, instHSub, instSubNat, Array.foldlM.loop, dite, Nat.decLe, Not, Array.foldlM.proof_1]]
["OfNat.ofNat",[Nat, OfNat]]
["System.FilePath.withFileName",[System.FilePath, String, Option, System.FilePath.parent, Unit, System.FilePath.mk, HDiv.hDiv, System.FilePath.instHDivFilePathStringFilePath]]
["IO.FS.Stream.mk.injEq",[IO, Bool, Unit, USize, ByteArray, String, Eq.propIntro, Eq, IO.FS.Stream, IO.FS.Stream.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["UInt64.val",[UInt64]]
["Array.append",[Array, Array.foldl, Array.push, OfNat.ofNat, Nat, instOfNatNat, Array.size]]
["instInhabitedUInt16",[Inhabited.mk, UInt16, UInt16.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, instInhabitedUInt16.proof_1]]
["List.span",[Bool, List, List.spanAux, List.nil]]
["Ordering.eq.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["«term_×__1»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.bracketedExplicitBinders, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Function.Equiv.symm",[Function.Equiv, Eq.symm]]
["Lean.Syntax.unsetTrailing",[Lean.Syntax, Lean.SourceInfo, Lean.Syntax.getTailInfo, Substring, String.Pos, Lean.Syntax.setTailInfo, Lean.SourceInfo.original, String.toSubstring]]
["IO.FileRight.mk.inj",[IO.AccessRight, Eq, IO.FileRight, IO.FileRight.mk, And, And.intro]]
["StateCpsT.runK",[StateCpsT]]
["Int.mul",[Int, Nat, Int.ofNat, HMul.hMul, instHMul, instMulNat, Int.negOfNat, Nat.succ]]
["ExceptT.instLawfulMonadExceptT.proof_1",[Monad, LawfulMonad, LawfulMonad.mk, ExceptT, ExceptT.instMonadExceptT, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, ExceptT.ext, Functor.map, id, of_eq_true, Eq, Except, ExceptT.run, Eq.trans, True, congrFun, congrArg, Except.map, ExceptT.run_map, Except.map_id, LawfulFunctor.id_map, LawfulApplicative.toLawfulFunctor, LawfulMonad.toLawfulApplicative, eq_self, ExceptT.seqLeft_eq, ExceptT.seqRight_eq, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, Unit, Except.ok, Except.error, congr, Bind.bind, Monad.toBind, ExceptT.seq_eq, ExceptT.run_bind, ExceptT.run_pure, funext, LawfulMonad.pure_bind, ExceptT.bind_pure_comp, Eq.mpr, LawfulMonad.bind_assoc, bind_congr, Eq.symm, Eq.refl]]
["IO.Process.StdioConfig.stderr",[IO.Process.StdioConfig]]
["Substring.startPos",[Substring]]
["Lean.Parser.Tactic.failIfSuccess",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["Nat.lt_trans",[Nat, LT.lt, instLTNat, Nat.le_trans, Nat.succ, Nat.le_step]]
["observing",[Monad, MonadExcept, MonadExcept.tryCatch, Except, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.ok, Except.error]]
["Nat.lt_succ_self",[Nat, Nat.lt.base]]
["decide_false_eq_false",[Decidable, False, Eq, Bool, Decidable.decide, Bool.false, Not, rfl, Decidable.isFalse, False.elim, Decidable.isTrue]]
["StateCpsT.runK_modify",[PUnit, rfl, StateCpsT.runK, modify, StateCpsT, instMonadState, StateCpsT.instMonadStateOfStateCpsT]]
["Array.all",[Array, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Id.run, Array.allM, Id, Id.instMonadId]]
["Lean.MacroScopesView.mainModule",[Lean.MacroScopesView]]
["instDecidableRelLtLtOfOrd",[Ord, inferInstanceAs, DecidableRel, Eq, Bool, BEq.beq, Ordering, instBEqOrdering, Ord.compare, Ordering.lt, Bool.true, instDecidableEqBool]]
["mkStdGen",[optParam, Nat, OfNat.ofNat, instOfNatNat, HDiv.hDiv, instHDiv, Nat.instDivNat, HMod.hMod, instHMod, Nat.instModNat, StdGen.mk, HAdd.hAdd, instHAdd, instAddNat]]
["unsafeCast.proof_1",[lcProof, Eq]]
["IO.eprint",[ToString, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Stream, Unit, IO.getStderr, IO.FS.Stream.putStr, ToString.toString]]
["Lean.Syntax.atom.injEq",[Lean.SourceInfo, String, Eq.propIntro, Eq, Lean.Syntax, Lean.Syntax.atom, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Std.Format.FlattenBehavior.allOrNone.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["Lean.Parser.Syntax.subPrec",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Subsingleton.noConfusionType",[Subsingleton, Eq]]
["instComplementUInt64",[Complement.mk, UInt64, UInt64.complement]]
["Iff.subst",[Iff, Eq.subst, propext]]
["Decidable.noConfusionType",[Decidable, Not]]
["List.forM_nil",[Monad, PUnit, rfl, ForM.forM, List, List.instForMList, List.nil]]
["IO.Process.Output.mk.injEq",[UInt32, String, Eq.propIntro, Eq, IO.Process.Output, IO.Process.Output.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Applicative.toSeqLeft",[Applicative]]
["Option.isEqSome",[BEq, Option, Bool, BEq.beq, Bool.false]]
["instInhabitedUInt8.proof_1",[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt8.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
["Lean.expandExplicitBindersAux.loop",[Lean.Syntax, Array, Option, Nat, Lean.MacroM, Nat.below, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Nat.succ, Lean.Syntax.getOp, Array.getOp, Lean.instInhabitedSyntax, OfNat.ofNat, instOfNatNat, PProd.fst, PUnit, PProd, Bool, Lean.Syntax.isIdent, Bind.bind, Monad.toBind, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.Macro.instMonadRefMacroM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Macro.instMonadQuotationMacroM, Lean.Name, Lean.MonadQuotation.getMainModule, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
["HEq.ndrec",[HEq]]
["Lean.Parser.Tactic.simpAll",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma]]
["coe",[CoeT, CoeT.coe]]
["UInt8.shiftRight",[UInt8, UInt8.mk, HShiftRight.hShiftRight, Fin, UInt8.size, instHShiftRight, Fin.instShiftRightFin, UInt8.val, UInt8.modn, OfNat.ofNat, Nat, instOfNatNat]]
["Lean.Syntax.decodeScientificLitVal?.decodeExp",[String, String.Pos, Nat, Char, String.get, ite, Option, Prod, Bool, Eq, BEq.beq, instBEq, instDecidableEqChar, Char.ofNat, Bool.true, instDecidableEqBool, Lean.Syntax.decodeScientificLitVal?.decodeAfterExp, String.next, OfNat.ofNat, instOfNatNat, Bool.false]]
["Classical.indefiniteDescription",[Exists, Classical.choice, Subtype, Classical.indefiniteDescription.proof_1]]
["IO.FS.Handle.mk",[System.FilePath, IO.FS.Mode, optParam, Bool, Bool.true, IO.FS.Handle.mkPrim, String, Unit, IO.FS.Mode.read, IO.FS.Mode.write, IO.FS.Mode.readWrite, IO.FS.Mode.append, Unit.unit, ite, Eq, instDecidableEqBool, HAppend.hAppend, instHAppend, String.instAppendString]]
["ST.Ref.modifyGet",[MonadLiftT, ST, ST.Ref, Prod, liftM, ST.Prim.Ref.modifyGet]]
["modify",[MonadState, MonadState.modifyGet, PUnit, Prod.mk, PUnit.unit]]
["StateT.monadControl",[Monad, MonadControl.mk, StateT, Prod, Bind.bind, Monad.toBind, StateT.instMonadStateT, MonadState.get, instMonadState, instMonadStateOfStateT, liftM, instMonadLiftT, StateT.instMonadLiftStateT, instMonadLiftT_1, StateT.run, PUnit, MonadStateOf.set, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["Nat.lt_wfRel.proof_1",[WellFounded.intro, Nat, Nat.lt, Acc, Acc.intro, OfNat.ofNat, instOfNatNat, absurd, Nat.not_lt_zero, Nat.succ]]
["Substring.beq",[Substring, and, BEq.beq, Nat, instBEq, instDecidableEqNat, Substring.bsize, String, instDecidableEqString, Substring.toString]]
["instReprFloat",[Repr.mk, Float, Nat, Std.Format.text, Float.toString]]
["Std.Format.defWidth",[OfNat.ofNat, Nat, instOfNatNat]]
["IO.FS.Mode.noConfusionType",[IO.FS.Mode, noConfusionTypeEnum, Nat, instDecidableEqNat, IO.FS.Mode.toCtorIdx]]
["PSum.inl.injEq",[Eq.propIntro, Eq, PSum, PSum.inl, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["UInt32.toUInt64",[UInt32, Nat.toUInt64, UInt32.toNat]]
["Substring.foldr",[Char, Substring, String, String.Pos, String.foldrAux]]
["Nat.sub_zero",[Nat, rfl, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat]]
["Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp",[Trans.mk, Nat, LE.le, instLENat, LT.lt, instLTNat, Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1]]
["String.pushn",[String, Char, Nat, Nat.repeat, String.push]]
["FloatArray.isEmpty",[FloatArray, BEq.beq, Nat, instBEq, instDecidableEqNat, FloatArray.size, OfNat.ofNat, instOfNatNat]]
["Fin.val_ne_of_ne",[Nat, Fin, Ne, Eq, Fin.val, absurd, False, Fin.eq_of_val_eq]]
["instInhabitedUInt64.proof_1",[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt64.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
["Nat.repr",[Nat, List.asString, Nat.toDigits, OfNat.ofNat, instOfNatNat]]
["instReprSigma",[Repr, Repr.mk, Sigma, Nat, Std.Format, Std.Format.bracket, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, repr, Std.Format.text]]
["String.data",[String]]
["Lean.Parser.Tactic.Conv.convSkip",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["ST.Ref.swap",[MonadLiftT, ST, ST.Ref, liftM, ST.Prim.Ref.swap]]
["Lean.unifConstraint",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
["Array.foldrM.fold",[Monad, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, Array.size, Nat.below, ite, Eq, Bool, BEq.beq, instBEq, instDecidableEqNat, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, HAdd.hAdd, instHAdd, instAddNat, Nat.succ]]
["IO.FS.FileType.file.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["UInt32.noConfusionType",[UInt32, Fin, UInt32.size, Eq]]
["List.isPrefixOf",[BEq, List, Bool, List.below, List.nil, Bool.true, Bool.false, List.cons, and, BEq.beq, PProd.fst, PUnit, PProd]]
["IO.Process.StdioConfig.mk.injEq",[IO.Process.Stdio, Eq.propIntro, Eq, IO.Process.StdioConfig, IO.Process.StdioConfig.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Array.modify",[Inhabited, Array, Nat, Id.run, Array.modifyM, Id, Id.instMonadId]]
["Mod.noConfusionType",[Mod, Eq]]
["instDecidableRelLeLeOfOrd",[Ord, inferInstanceAs, DecidableRel, Eq, Bool, Ordering.isLE, Ord.compare, Bool.true, instDecidableEqBool]]
["Lean.NameGenerator.curr",[Lean.NameGenerator, Lean.Name.mkNum, Lean.NameGenerator.namePrefix, Lean.NameGenerator.idx]]
["Except.toBool",[Except, Bool, Bool.true, Bool.false]]
["IO.Error.mkOtherError",[IO.Error.otherError]]
["Classical.typeDecidable",[Decidable, Nonempty, PSum, False, Classical.propDecidable, PSum.inl, arbitrary, Classical.inhabited_of_nonempty, Not, PSum.inr, Classical.typeDecidable.proof_1]]
["ST.instInhabitedRef",[Inhabited, Inhabited.mk, ST.Ref, ST.Ref.mk, PointedType.val, ST.RefPointed, ST.instInhabitedRef.proof_1]]
["List.map₂",[List, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd]]
["List.set",[List, Nat, List.below, List.cons, PProd.fst, PUnit, PProd, List.nil]]
["HOr.hOr",[HOr]]
["Array.zipWith",[Array, Array.zipWithAux, OfNat.ofNat, Nat, instOfNatNat, List.toArray, List.nil]]
["PProd.fst",[PProd]]
["LawfulMonad.bind_map",[Monad, LawfulMonad]]
["List.hasDecidableLt.proof_2",[LT, List, LT.lt, List.instLTList, List.cons, List.nil, False]]
["Eq.symm",[Eq, rfl]]
["UInt8.sub",[UInt8, UInt8.mk, HSub.hSub, Fin, UInt8.size, instHSub, Fin.instSubFin, UInt8.val]]
["String.toLower",[String, String.map, Char.toLower]]
["UInt16.decEq.proof_2",[Fin, UInt16.size, Not, Eq, UInt16, UInt16.mk, False, absurd]]
["Std.Format.tag.sizeOf_spec",[Nat, Std.Format, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat, SizeOf.mk, String, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOf, Int, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone]]
["ExceptT.run_bind_lift",[Monad, LawfulMonad, ExceptT, of_eq_true, Eq, Except, Bind.bind, Monad.toBind, Functor.map, Applicative.toFunctor, Monad.toApplicative, Except.ok, Pure.pure, Applicative.toPure, Except.error, Eq.trans, True, congrFun, congrArg, map_eq_pure_bind, LawfulMonad.bind_assoc, funext, LawfulMonad.pure_bind, eq_self]]
["unexpandListToArray",[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, Lean.Syntax.SepArray, Lean.Syntax.SepArray.mk, Lean.Syntax.getArgs, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
["instToStringString",[ToString.mk, String]]
["IO.FS.SystemTime.mk.inj",[Int, UInt32, Eq, IO.FS.SystemTime, IO.FS.SystemTime.mk, And, And.intro]]
["InvImage.wf.proof_1",[WellFounded, WellFounded.intro, InvImage, InvImage.accessible, WellFounded.apply]]
["IO.FS.instReprDirEntry",[Repr.mk, IO.FS.DirEntry, Nat, Std.Format.bracket, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.nil, Std.Format.text, repr, System.FilePath, System.instReprFilePath, IO.FS.DirEntry.root, Std.Format.line, String, instReprString, IO.FS.DirEntry.fileName]]
["instOfScientificFloat",[OfScientific.mk, Float, Nat, Bool, Float.ofScientific]]
["Nat.pow_zero",[Nat, rfl, HPow.hPow, instHPow, instPowNatNat, OfNat.ofNat, instOfNatNat]]
["EmptyCollection.noConfusionType",[EmptyCollection, Eq]]
["Nat.le_of_ble_eq_true",[Nat, Eq, Bool, Nat.ble, Bool.true, LE.le, instLENat, Nat.below, OfNat.ofNat, instOfNatNat, Nat.zero_le, Nat.succ, Nat.succ_le_succ, PProd.fst, PUnit, PProd]]
["Array.binSearch",[Inhabited, Array, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Array.size, ite, Option, LT.lt, instLTNat, Nat.decLt, Array.binSearchAux, instInhabitedOption, id, Option.none]]
["«term∅»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
["Std.Format.appendEx",[Std.Format, Std.Format.append]]
["dbgTraceVal",[ToString, dbgTrace, ToString.toString, Unit]]
["Nat.le_succ",[Nat, Nat.le.step, Nat.le.refl]]
["instComplementUSize",[Complement.mk, USize, USize.complement]]
["instHOrElse",[OrElse, HOrElse.mk, Unit, OrElse.orElse]]
["DoResultPRBC.break.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["Lean.Parser.Tactic.case",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary]]
["ExceptT.bind",[Monad, ExceptT, ExceptT.mk, Bind.bind, Monad.toBind, Except, ExceptT.bindCont]]
["instDecidableLt_3",[UInt64, UInt64.decLt]]
["Ordering.gt.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["Classical.inhabited_of_exists.proof_1",[Exists, Exists.elim, Nonempty, Nonempty.intro]]
["MonadExceptOf.noConfusionType",[MonadExceptOf, Eq]]
["ByteArray.mk.inj",[Array, UInt8, Eq, ByteArray, ByteArray.mk]]
["Fin.noConfusionType",[Nat, Fin, LT.lt, instLTNat, Eq]]
["Option.any",[Bool, Option, Unit, Bool.false]]
["Float.val",[Float]]
["String.instInhabitedString",[Inhabited.mk, String]]
["mt",[Not]]
["instAddFloat",[Add.mk, Float, Float.add]]
["Acc.inv.proof_1",[Acc]]
["UInt8.mod",[UInt8, UInt8.mk, HMod.hMod, Fin, UInt8.size, instHMod, Fin.instModFin, UInt8.val]]
["instInhabitedReaderT",[Inhabited, Inhabited.mk, ReaderT, arbitrary]]
["LT.noConfusionType",[LT, Eq]]
["StdGen.noConfusionType",[StdGen, Nat, Eq]]
["IO.setRandSeed",[Nat, ST.Ref.set, IO.RealWorld, IO, instMonadLiftT, ST, IO.instMonadLiftSTRealWorldEIO, IO.Error, instMonadLiftT_1, StdGen, IO.stdGenRef, mkStdGen]]
["Lean.MacroScopesView.imported",[Lean.MacroScopesView]]
["HDiv.hDiv",[HDiv]]
["EStateM.instReprResult",[Repr, Repr.mk, EStateM.Result, Nat, Std.Format, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, reprArg]]
["instOrOpUInt64",[OrOp.mk, UInt64, UInt64.lor]]
["UInt64.complement",[UInt64, HSub.hSub, instHSub, instSubUInt64, OfNat.ofNat, instOfNatUInt64, HAdd.hAdd, instHAdd, instAddUInt64]]
["IO.FS.Mode.append.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["Lean.Parser.Tactic.Conv.convSeq1Indented",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
["Lean.Macro.mkMethodsImp",[Lean.Macro.Methods, unsafeCast, PointedType.type]]
["Lean.Macro.Methods.hasDecl",[Lean.Macro.Methods]]
["instHasEquiv",[Setoid, HasEquiv.mk, Setoid.r]]
["Prod.noConfusionType",[Prod, Eq]]
["ReaderT.run_read",[Monad, rfl, ReaderT.run, ReaderT.read]]
["ForInStep.done.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["Nat.succ.inj",[Nat, Eq, Nat.succ]]
["Lean.Syntax.getArgs",[Lean.Syntax, Array, Lean.SyntaxNodeKind, Array.empty]]
["IO.Error.otherError.sizeOf_spec",[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar]]
["OfNat.noConfusionType",[Nat, OfNat, Eq]]
["IO.Error.resourceVanished.injEq",[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.resourceVanished, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["List.iota",[Nat, List, Nat.below, Unit, List.nil, namedPattern, Nat.succ, List.cons, PProd.fst, PUnit, PProd]]
["ST.Ref.modify",[MonadLiftT, ST, ST.Ref, liftM, Unit, ST.Prim.Ref.modify]]
["Lean.Name.instReprSyntax",[Repr.mk, Lean.Syntax]]
["«stx_,+,?»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
["String.take",[String, Nat, Substring.toString, Substring.take, String.toSubstring]]
["StateT.instAlternativeStateT",[Monad, Alternative, Alternative.mk, StateT, Monad.toApplicative, StateT.instMonadStateT, StateT.failure, StateT.orElse]]
["unexpandListNil",[Lean.Syntax, Bind.bind, Lean.PrettyPrinter.UnexpandM, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, List.nil]]
["Nat.pred_le",[Nat, LE.le, instLENat, Nat.pred, Unit, Nat.le.refl, Nat.zero, Nat.le_succ, Nat.succ]]
["IO.Error.illegalOperation.injEq",[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.illegalOperation, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Lean.runEval",[Lean.Eval, Unit, IO.FS.withIsolatedStreams, IO, instMonadEIO, IO.Error, instMonadFinallyEIO, instMonadExceptOfEIO, instMonadLiftT_1, Lean.Eval.eval, Bool.false]]
["typedExpr",[]]
["List.notElem",[BEq, List, not, List.elem]]
["Subarray.popFront",[Subarray, dite, LT.lt, Nat, instLTNat, Subarray.start, Subarray.stop, Nat.decLt, Subarray.mk, Subarray.as, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Subarray.popFront.proof_1, Subarray.h₂, Not]]
["Array.instBEqArray",[BEq, BEq.mk, Array, Array.isEqv, BEq.beq]]
["OptionT.mk",[Option]]
["instToStreamRangeRange",[ToStream.mk, Std.Range]]
["Std.Format.defUnicode",[Bool.true]]
["Nat.ble_self_eq_true",[Nat, Eq, Bool, Nat.ble, Bool.true, Nat.below, Unit, rfl, OfNat.ofNat, instOfNatNat, Nat.succ, PProd.fst, PUnit, PProd]]
["Substring.dropWhile",[Substring, Char, Bool, String, String.Pos, Substring.mk]]
["instMulUInt32",[Mul.mk, UInt32, UInt32.mul]]
["System.FilePath.instHDivFilePathStringFilePath",[HDiv.mk, System.FilePath, String, System.FilePath.join, System.FilePath.mk]]
["Lean.Name.instToStringName",[ToString.mk, Lean.Name, Lean.Name.toString, Bool.true]]
["HShiftLeft.hShiftLeft",[HShiftLeft]]
["List.tail!",[List, Unit, panicWithPosWithDecl, instInhabitedList, OfNat.ofNat, Nat, instOfNatNat]]
["HEq.ndrecOn",[HEq]]
["Lean.Meta.Rewrite.Config.transparency",[Lean.Meta.Rewrite.Config]]
["instHashableNat",[Hashable.mk, Nat, UInt64.ofNat]]
["MonadExcept.orelse'",[MonadExcept, optParam, Bool, Bool.true, MonadExcept.tryCatch, MonadExcept.throw, ite, Eq, instDecidableEqBool]]
["Quot.exists_rep",[Quot, Quot.inductionOn, Exists, Eq, Quot.mk, Exists.intro, rfl]]
["ne_false_of_self",[Eq, False]]
["Lean.instQuoteNat",[Lean.Quote.mk, Nat, Lean.Syntax.mkNumLit, ToString.toString, instToStringNat, Lean.SourceInfo.none]]
["Lean.Parser.Tactic.generalize",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.generalizeArg, Lean.ParserDescr.symbol]]
["String.Iterator.forward",[String.Iterator, Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, String.Iterator.next]]
["Sum.inhabitedRight",[Inhabited, Inhabited.mk, Sum, Sum.inr, arbitrary]]
["Lean.Name.sizeOf",[Lean.Name, Nat, Lean.Name.below, Unit, Lean.Name.anonymous, OfNat.ofNat, instOfNatNat, String, UInt64, Lean.Name.str, HAdd.hAdd, instHAdd, instAddNat, PProd.fst, PUnit, PProd, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, Lean.Name.num]]
["instLTUInt32",[LT.mk, UInt32, LT.lt, Fin, UInt32.size, instLTFin, UInt32.val]]
["Array.getEvenElems",[Array, Prod, Bool, Prod.snd, Array.foldl, ite, Eq, Bool.true, instDecidableEqBool, Prod.mk, Bool.false, Array.push, Array.empty, OfNat.ofNat, Nat, instOfNatNat, Array.size]]
["List.length_append",[List, Eq, Nat, List.length, HAppend.hAppend, instHAppend, List.instAppendList, HAdd.hAdd, instHAdd, instAddNat, of_eq_true, List.nil, Eq.trans, True, congr, congrArg, List.nil_append, OfNat.ofNat, instOfNatNat, congrFun, List.length_nil, Nat.zero_add, eq_self, List.cons, Nat.succ, List.cons_append, List.length_cons, Nat.succ_add]]
["Std.Range.«term[:_]»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["«term_∨_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Array.modifyM",[Monad, Inhabited, Array, Nat, dite, LT.lt, instLTNat, Array.size, Nat.decLt, Fin, Fin.mk, Array.get, Array.set, arbitrary, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.modifyM.proof_1, Not]]
["Lean.Parser.Tactic.Conv.convSeqBracketed",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat]]
["List.toString",[ToString, List, String, Unit, HAppend.hAppend, instHAppend, String.instAppendString, List.toStringAux, Bool.true, List.cons]]
["MonadControl.stM",[MonadControl]]
["Array.findIdx?.loop.proof_1",[Array, Nat, LT.lt, instLTNat, Array.size, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, absurd, False, Eq.mp, Eq.refl, Nat.zero_add, Nat.lt_irrefl]]
["ReaderT.instLawfulMonadReaderT",[ReaderT.instLawfulMonadReaderT.proof_1]]
["Lean.instEval",[ToString, Lean.Eval.mk, Unit, optParam, Bool, Bool.true, IO.println, String, instToStringString, ToString.toString, Unit.unit]]
["Std.Format.nest.inj",[Int, Std.Format, Eq, Std.Format.nest, And, And.intro]]
["OptionT.lift",[Monad, OptionT.mk, Bind.bind, Monad.toBind, Option, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.some]]
["Std.Format.FlattenBehavior.toCtorIdx",[Std.Format.FlattenBehavior, Nat, OfNat.ofNat, instOfNatNat]]
["Lean.Meta.Rewrite.Config.mk.injEq",[Lean.Meta.TransparencyMode, Bool, Eq.propIntro, Eq, Lean.Meta.Rewrite.Config, Lean.Meta.Rewrite.Config.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Lean.fieldIdxKind",[Lean.Name.mkStr, Lean.Name.anonymous]]
["Lean.Option.hasQuote",[Lean.Quote, Lean.Quote.mk, Option, Unit, Option.none, Option.some, Unit.unit, Lean.Syntax, Lean.mkIdent, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.mkCApp, List.toArray, List.cons, Lean.Quote.quote, List.nil]]
["«term[_]»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false]]
["Lean.isSubScriptAlnum",[Char, or, Lean.isNumericSubscript, and, Decidable.decide, LE.le, UInt32, instLEUInt32, OfNat.ofNat, instOfNatUInt32, Char.val, instDecidableLe]]
["List.toFloatArray",[List, Float, FloatArray, FloatArray.empty, List.toFloatArray.loop]]
["String.getOp",[String, String.Pos, String.get]]
["Lean.Parser.Tactic.Conv.convIntro___",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
["Lean.Parser.Tactic.intro",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
["Setoid.refl",[Setoid, Equivalence.refl, Setoid.r, Setoid.iseqv]]
["UInt16.sub",[UInt16, UInt16.mk, HSub.hSub, Fin, UInt16.size, instHSub, Fin.instSubFin, UInt16.val]]
["String.toUpper",[String, String.map, Char.toUpper]]
["Lean.Syntax.noConfusionType",[Lean.Syntax, Lean.SyntaxNodeKind, Array, Lean.SourceInfo, String, Substring, Lean.Name, List, Prod, Eq]]
["CoeHead.coe",[CoeHead]]
["seq_eq_bind",[Monad, LawfulMonad, Eq.mpr, Eq, Seq.seq, Applicative.toSeq, Monad.toApplicative, Unit, Bind.bind, Monad.toBind, Functor.map, Applicative.toFunctor, Eq.refl, LawfulMonad.bind_map, rfl]]
["Lean.Syntax.SepArray.instCoeTailSepArrayArraySyntax",[String, CoeTail.mk, Lean.Syntax.SepArray, Array, Lean.Syntax, Lean.Syntax.SepArray.getElems]]
["PSigma.revLexAccessible.proof_1",[Acc, PSigma, PSigma.RevLex, PSigma.mk, Acc.intro, Eq, HEq, PSigma.RevLex.left, Eq.symm, eq_of_heq, PSigma.RevLex.right, Eq.refl, HEq.refl]]
["instOfNatUInt64",[Nat, OfNat.mk, UInt64, UInt64.ofNat]]
["WellFoundedRelation.noConfusionType",[WellFoundedRelation, WellFounded, Eq]]
["instMonadStateOfStateT",[Monad, MonadStateOf.mk, StateT, StateT.get, StateT.set, StateT.modifyGet]]
["withPtrEqDecEq.proof_1",[Unit, Decidable, Eq, toBoolUsing_eq_true, Unit.unit]]
["DoResultSBC.pureReturn.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["instReprAtomChar",[ReprAtom.mk, Char]]
["PSigma.skipLeft.proof_1",[WellFoundedRelation, PSigma.revLex, emptyRelation, WellFoundedRelation.rel, WellFoundedRelation.wf, emptyWf]]
["instSubUSize",[Sub.mk, USize, USize.sub]]
["instMonadReader",[MonadReaderOf, MonadReader.mk, readThe]]
["Lean.Syntax.matchesIdent",[Lean.Syntax, Lean.Name, and, Lean.Syntax.isIdent, BEq.beq, Lean.Name.instBEqName, Lean.Syntax.getId]]
["HPow.hPow",[HPow]]
["instDecidableEqBool.proof_2",[Eq, Bool, Bool.true, Bool.false, False]]
["instReprTupleProd",[Repr, ReprTuple, ReprTuple.mk, Prod, List, Std.Format, ReprTuple.reprTuple, List.cons, repr]]
["instDecidableOr.proof_1",[Not, Or, False]]
["congr",[Eq, rfl]]
["Nat.decLt",[Nat.decLe, Nat.succ]]
["FloatSpec.decLe",[FloatSpec]]
["StateCpsT.runK_pure",[rfl, StateCpsT.runK, Pure.pure, StateCpsT, Applicative.toPure, Monad.toApplicative, StateCpsT.instMonadStateCpsT]]
["withPtrEqDecEq.proof_2",[Unit, Decidable, Eq, Bool, withPtrEq, toBoolUsing, Unit.unit, withPtrEqDecEq.proof_1, Bool.true, ofBoolUsing_eq_true]]
["«prio(_)»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
["IO.Process.StdioConfig.stdout",[IO.Process.StdioConfig]]
["Classical.propDecidable",[Classical.choice, Decidable, Classical.propDecidable.proof_1]]
["String.decLt",[List.hasDecidableLt, Char, Char.instLTChar, Char.instDecidableLt, String.data]]
["noConfusionEnum.proof_2",[Eq, Not, congrArg]]
["List.length_reverse",[List, Eq, Nat, List.length, List.reverse, rfl, List.nil, of_eq_true, List.cons, Eq.trans, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, OfNat.ofNat, instOfNatNat, True, congr, congrArg, HAppend.hAppend, instHAppend, List.instAppendList, List.reverse_cons, List.length_append, List.length_cons, List.length_nil, eq_self]]
["Setoid.noConfusionType",[Setoid, Equivalence, Eq]]
["Lean.expandBrackedBindersAux",[Lean.Syntax, Array, Nat, Lean.MacroM, Array.size, Lean.expandBrackedBindersAux.loop]]
["IO.Process.Stdio.null.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["IO.Error.noFileOrDirectory.sizeOf_spec",[String, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["PSigma.lexNdep",[PSigma.Lex]]
["StateCpsT.instLawfulMonadStateCpsT.proof_1",[LawfulMonad.mk, StateCpsT, StateCpsT.instMonadStateCpsT, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, Functor.map, id, Function.comp, SeqLeft.seqLeft, Applicative.toSeqLeft, Unit, SeqRight.seqRight, Applicative.toSeqRight, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, Bind.bind, Monad.toBind]]
["String.Iterator.next",[String.Iterator, String, String.Pos, String.Iterator.mk, String.next]]
["Lean.Parser.Syntax.addPrec",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["instDecidableLe",[UInt32, UInt32.decLe]]
["instLTUSize",[LT.mk, USize, USize.lt]]
["instMonadExceptOfExcept",[MonadExceptOf.mk, Except, Except.error, Except.tryCatch]]
["Subarray.stop",[Subarray]]
["ForM.forM",[ForM]]
["Char.isValidChar_of_isValidChar_Nat",[Nat, Char.isValidCharNat, isValidChar, UInt32.ofNat', Char.isValidUInt32, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, Or.inl, UInt32, instLTUInt32, And, instOfNatUInt32, Or.inr, And.intro]]
["FloatSpec.mk.injEq",[DecidableRel, Eq.propIntro, Eq, FloatSpec, FloatSpec.mk, And, HEq, And.intro, Eq.refl, HEq.refl, Eq.symm, eq_of_heq]]
["MonadWithReader.noConfusionType",[outParam, MonadWithReader, Eq]]
["fix5",[Inhabited, fixCore5, arbitrary]]
["Nat.toUInt16",[UInt16.ofNat]]
["Lean.idBeginEscape",[Char.ofNat]]
["IO.Process.SpawnArgs.env",[IO.Process.SpawnArgs]]
["Classical.propDecidable.proof_1",[Or, Not, Classical.em, Nonempty, Decidable, Nonempty.intro, Decidable.isTrue, Decidable.isFalse]]
["ne_true_of_eq_false",[Bool, Eq, Bool.false, Not, Bool.true, False]]
["EST",[EStateM]]
["IO.lazyPure",[Unit, Pure.pure, IO, Applicative.toPure, Monad.toApplicative, instMonadEIO, IO.Error, Unit.unit]]
["ExceptT.instMonadExceptT",[Monad, Monad.mk, ExceptT, Applicative.mk, Functor.mk, ExceptT.map, Pure.mk, ExceptT.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk, ExceptT.bind]]
["IO.FS.withFile",[System.FilePath, IO.FS.Mode, IO.FS.Handle, IO, Bind.bind, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle.mk, Bool.true]]
["floatDecLe",[Float, Float.decLe]]
["instBEq",[DecidableEq, BEq.mk, Decidable.decide, Eq]]
["IO.FS.Stream.Buffer.noConfusionType",[IO.FS.Stream.Buffer, ByteArray, Nat, Eq]]
["instShiftRightUInt8",[ShiftRight.mk, UInt8, UInt8.shiftRight]]
["Int.sub",[HAdd.hAdd, Int, instHAdd, Int.instAddInt, Neg.neg, Int.instNegInt]]
["IO.FS.Stream.isEof",[IO.FS.Stream]]
["Lean.PrettyPrinter.UnexpandM",[EStateM, Unit]]
["IO.AccessRight.flags",[IO.AccessRight, UInt32, ite, Eq, Bool, IO.AccessRight.read, Bool.true, instDecidableEqBool, OfNat.ofNat, instOfNatUInt32, IO.AccessRight.write, IO.AccessRight.execution, UInt32.lor]]
["Char.valid",[Char]]
["StateCpsT.run",[Monad, StateCpsT, StateCpsT.runK, Prod, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk]]
["List.or",[List, Bool, List.any, id]]
["Lean.Syntax.setArg",[Lean.Syntax, Nat, Lean.SyntaxNodeKind, Array, Lean.Syntax.node, Array.setD]]
["Lean.«termMacro.trace[__]_»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
["ULift.up_down",[ULift, Eq, ULift.up, ULift.down, rfl]]
["prioMid",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["Or.elim",[Or]]
["IO.eprintln",[ToString, IO.eprint, String, instToStringString, String.push, ToString.toString, Char.ofNat]]
["instHDiv",[Div, HDiv.mk, Div.div]]
["Lean.Parser.Tactic.Conv.nestedTactic",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
["Nat.lt_of_succ_lt_succ",[Nat, Nat.le_of_succ_le_succ, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
["Lean.Parser.Tactic.tacticUnhygienic_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["Alternative.noConfusionType",[Alternative, Applicative, Unit, Eq]]
["instToFormatArray",[Std.ToFormat, Std.ToFormat.mk, Array, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.text, Std.ToFormat.format, List, instToFormatList, Array.toList]]
["StateRefT'.set",[Monad, MonadLiftT, ST, ST.Ref, ST.Ref.set]]
["Quotient.recOnSubsingleton₂",[Setoid, Quotient, Subsingleton, Quotient.mk, Quot.recOnSubsingleton, Setoid.r, Quotient.recOnSubsingleton₂.proof_1, Quot.mk, Quotient.recOnSubsingleton₂.proof_2]]
["Lean.Macro.Context.ref",[Lean.Macro.Context]]
["Prod.mk.injEq",[Eq.propIntro, Eq, Prod, Prod.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["instDecidableEqSum",[DecidableEq, Sum, Decidable, Eq, dite, Sum.inl, Decidable.isTrue, instDecidableEqSum.proof_1, Not, Decidable.isFalse, instDecidableEqSum.proof_2, Sum.inr, instDecidableEqSum.proof_3, instDecidableEqSum.proof_4, instDecidableEqSum.proof_5, instDecidableEqSum.proof_6]]
["instLTUInt64",[LT.mk, UInt64, UInt64.lt]]
["instShiftRightUInt64",[ShiftRight.mk, UInt64, UInt64.shiftRight]]
["Lean.Parser.Tactic.tacticRfl",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["coeHead",[CoeHead, CoeHead.coe]]
["ExceptT.seqRight_eq",[Monad, LawfulMonad, ExceptT]]
["Lean.termEval_prec_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["IO.toEIO",[IO.Error, IO, EStateM.adaptExcept, IO.RealWorld]]
["instReprUInt32",[Repr.mk, UInt32, Nat, repr, instReprNat, UInt32.toNat]]
["instDivUInt16",[Div.mk, UInt16, UInt16.div]]
["instToStringUSize",[ToString.mk, USize, ToString.toString, Nat, instToStringNat, USize.toNat]]
["System.instCoeStringFilePath",[Coe.mk, String, System.FilePath, System.FilePath.mk]]
["MonadWithReaderOf.noConfusionType",[MonadWithReaderOf, Eq]]
["List.contains",[BEq, List, List.elem]]
["instDecidableIff.proof_4",[Not, Iff.intro, absurd]]
["Pure.pure",[Pure]]
["IO.Error.noSuchThing.injEq",[Option, String, UInt32, Eq.propIntro, Eq, IO.Error, IO.Error.noSuchThing, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["instDecidableLe_4",[USize, USize.decLe]]
["Array.ext.extAux",[List, Eq, Nat, List.length, LT.lt, instLTNat, List.get, List.nil, rfl, Eq.symm, List.cons, Nat.succ, Eq.mp, Eq.refl, List.length_cons]]
["List.length_cons",[List, rfl, Nat, List.length, List.cons]]
["Lean.mkNode",[Lean.SyntaxNodeKind, Array, Lean.Syntax, Lean.Syntax.node]]
["Nat.zero_ne_one",[Eq, Nat, OfNat.ofNat, instOfNatNat, False]]
["ST.Prim.Ref.modifyGetUnsafe",[ST.Ref, Prod, Bind.bind, ST, Monad.toBind, instMonadST, ST.Prim.Ref.take, Unit, ST.Prim.Ref.set, PUnit, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["Classical.strongIndefiniteDescription.proof_1",[Exists, Subtype.property, Classical.indefiniteDescription]]
["StateRefT'.modifyGet",[Monad, MonadLiftT, ST, Prod, ST.Ref, ST.Ref.modifyGet]]
["instSubsingletonDecidable",[instSubsingletonDecidable.proof_1]]
["prioLow",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["IO.Error.resourceVanished.inj",[UInt32, String, Eq, IO.Error, IO.Error.resourceVanished, And, And.intro]]
["IO.Error.otherError.inj",[UInt32, String, Eq, IO.Error, IO.Error.otherError, And, And.intro]]
["List.dropLast",[List, List.below, Unit, List.nil, List.cons, PProd.fst, PUnit, PProd]]
["if_pos",[Decidable, Eq, ite, rfl, Decidable.isTrue, Not, absurd, Decidable.isFalse]]
["Lean.Parser.Tactic.Conv.convLeft",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["List.maximum?",[LT, DecidableRel, LT.lt, List, Option, Unit, Option.none, Option.some, List.foldl, max]]
["Char.utf8Size.proof_3",[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
["UInt16.lor",[UInt16, UInt16.mk, Fin.lor, UInt16.size, UInt16.val]]
["Nat.shiftRight",[Nat, Nat.below, Nat.succ, HDiv.hDiv, instHDiv, Nat.instDivNat, PProd.fst, PUnit, PProd, OfNat.ofNat, instOfNatNat]]
["Quotient.liftOn₂",[Setoid, Quotient, HasEquiv.Equiv, instHasEquiv, Eq, Quotient.lift₂]]
["Lean.Parser.Tactic.Conv.convRw__",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq]]
["modifyGetThe",[MonadStateOf, Prod, MonadStateOf.modifyGet]]
["Lean.evalPrec",[Lean.Syntax, Lean.Macro.withIncRecDepth, Nat, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.expandMacros, cond, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.getD, Lean.Syntax.isNatLit?, OfNat.ofNat, instOfNatNat, Lean.Macro.throwErrorAt]]
["Array.findSomeRevM?.find",[Monad, Array, Option, Nat, LE.le, instLENat, Array.size, Nat.below, OfNat.ofNat, instOfNatNat, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.none, HAdd.hAdd, instHAdd, instAddNat, Nat.succ]]
["Std.ToFormat.format",[Std.ToFormat]]
["StateCpsT.runK_bind_set",[Monad, PUnit, StateCpsT, rfl, StateCpsT.runK, Bind.bind, Monad.toBind, StateCpsT.instMonadStateCpsT, MonadStateOf.set, StateCpsT.instMonadStateOfStateCpsT]]
["instInhabitedList",[Inhabited.mk, List, List.nil]]
["Std.Format.prefixJoin",[Std.ToFormat, Std.Format, List, List.below, Unit, List.nil, Std.Format.nil, List.cons, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.ToFormat.format, PProd.fst, PUnit, PProd]]
["addParenHeuristic",[String, ite, Eq, Bool, or, String.isPrefixOf, Bool.true, instDecidableEqBool, not, String.any, Char.isWhitespace, HAppend.hAppend, instHAppend, String.instAppendString]]
["Setoid.iseqv",[Setoid]]
["«term_|>_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Id.instMonadId",[Monad.mk, Id, Applicative.mk, Functor.mk, Pure.mk, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk]]
["Iff.mp",[Iff]]
["coeOfTC",[CoeTC, CoeHTCT.mk, coeTC]]
["MonadLift.noConfusionType",[MonadLift, Eq]]
["PSigma.revLexAccessible",[PSigma.revLexAccessible.proof_1]]
["Lean.termEval_prio_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["IO.Error.userError.sizeOf_spec",[String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["String.startsWith",[String, BEq.beq, Substring, Substring.hasBeq, Substring.take, String.toSubstring, String.length]]
["IO.FS.DirEntry.mk.inj",[System.FilePath, String, Eq, IO.FS.DirEntry, IO.FS.DirEntry.mk, And, And.intro]]
["UInt32.shiftRight",[UInt32, UInt32.mk, HShiftRight.hShiftRight, Fin, UInt32.size, instHShiftRight, Fin.instShiftRightFin, UInt32.val, UInt32.modn, OfNat.ofNat, Nat, instOfNatNat]]
["Lean.Parser.Tactic.«tactic_<;>_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["HAndThen.noConfusionType",[outParam, HAndThen, Unit, Eq]]
["instMonadFunctorT",[MonadFunctor, MonadFunctorT, MonadFunctorT.mk, MonadFunctor.monadMap, MonadFunctorT.monadMap]]
["true_iff",[propext, Iff, True, Iff.intro, Iff.mp, trivial]]
["instReprInt",[Repr.mk, Int, Nat, Std.Format.text, Int.repr]]
["MonadExcept.orElse",[MonadExcept, Unit, MonadExcept.tryCatch, Unit.unit]]
["WellFounded.induction",[WellFounded, WellFounded.recursion]]
["«term#[_,]»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.ParserDescr.cat, Bool.false]]
["Ordering.toCtorIdx",[Ordering, Nat, OfNat.ofNat, instOfNatNat]]
["IO.FS.lines",[System.FilePath, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle, Array, String, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.false, List.toArray, List.nil, IO.FS.lines.read]]
["Lean.Parser.Tactic.letrec",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["Substring.extract",[Substring, String.Pos, String, ite, GE.ge, instLENat, Nat.decLe, Substring.mk, OfNat.ofNat, instOfNatNat, Nat.min, HAdd.hAdd, instHAdd, instAddNat]]
["IO.instInhabitedError",[Inhabited.mk, IO.Error, IO.Error.alreadyExists, arbitrary, Option, String, instInhabitedOption, UInt32, instInhabitedUInt32, String.instInhabitedString]]
["Nat.allM",[Monad, Nat, Bool, Nat.allM.loop]]
["panic",[Inhabited, String, panicCore]]
["IO.FS.Stream.putStr",[IO.FS.Stream]]
["Lean.Parser.Tactic.locationTargets",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
["Eq.mpr",[Eq, Eq.symm]]
["FloatArray.noConfusionType",[FloatArray, Array, Float, Eq]]
["String.mkIterator",[String, String.Iterator.mk, OfNat.ofNat, String.Pos, instOfNatNat]]
["Std.Format.append.sizeOf_spec",[Std.Format, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, String, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, Int, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone]]
["Substring.prev",[Substring, String.Pos, String, HAdd.hAdd, instHAdd, instAddNat, ite, Eq, instDecidableEqNat, HSub.hSub, instHSub, instSubNat, String.prev]]
["System.FilePath.join",[System.FilePath, ite, Eq, Bool, System.FilePath.isAbsolute, Bool.true, instDecidableEqBool, System.FilePath.mk, HAppend.hAppend, String, instHAppend, String.instAppendString, System.FilePath.toString, Char.toString, System.FilePath.pathSeparator]]
["readThe",[MonadReaderOf, MonadReaderOf.read]]
["IO.Process.Stdio.toCtorIdx",[IO.Process.Stdio, Nat, OfNat.ofNat, instOfNatNat]]
["Lean.mkHole",[Lean.Syntax, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkAtomFrom, List.nil]]
["Lean.Parser.Tactic.change",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.unary, Lean.Parser.Tactic.location]]
["List.isSuffixOf",[BEq, List, List.isPrefixOf, List.reverse]]
["StateT.instMonadLiftStateT",[Monad, MonadLift.mk, StateT, StateT.lift]]
["Array.zip",[Array, Array.zipWith, Prod, Prod.mk]]
["Prod.lex",[WellFoundedRelation, WellFoundedRelation.mk, Prod, Prod.Lex, WellFoundedRelation.rel, Prod.lex.proof_1]]
["Char.instLEChar",[LE.mk, Char, Char.le]]
["Nat.le_add_right",[Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, Nat.below, Nat.le_refl, Nat.succ, Nat.le_succ_of_le, Nat.add, PProd.fst, PUnit, PProd]]
["List.nil_append",[List, rfl, HAppend.hAppend, instHAppend, List.instAppendList, List.nil]]
["Array.size_push",[Array, List.length_concat, Array.data]]
["NonScalar.noConfusionType",[NonScalar, Nat, Eq]]
["List.hasDecEq",[DecidableEq, List, Decidable, Eq, List.below, Unit, List.nil, Decidable.isTrue, List.hasDecEq.proof_1, List.cons, Decidable.isFalse, List.hasDecEq.proof_2, List.hasDecEq.proof_3, decEq, PProd.fst, PUnit, PProd, List.hasDecEq.proof_4, Not, List.hasDecEq.proof_5, List.hasDecEq.proof_6]]
["Lean.Module.mk.injEq",[Lean.Syntax, Array, Eq.propIntro, Eq, Lean.Module, Lean.Module.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Nat.pred_le_pred",[Nat, LE.le, instLENat, Nat.pred, Nat.le.refl, Nat.le, OfNat.ofNat, instOfNatNat, Nat.succ, Nat.le_trans, Nat.le_succ]]
["String.isInt",[String, ite, Bool, Eq, Char, String.get, OfNat.ofNat, String.Pos, instOfNatNat, Char.ofNat, instDecidableEqChar, Substring.isNat, Substring.drop, String.toSubstring, Nat, String.isNat]]
["«term{}»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol]]
["System.Platform.isWindows",[System.Platform.getIsWindows, Unit.unit]]
["Mod.mod",[Mod]]
["Except.orElseLazy",[Except, Unit, Except.ok, Unit.unit]]
["Std.Format.instAppendFormat",[Append.mk, Std.Format, Std.Format.append]]
["Char.val_eq_of_eq",[Char, Eq, UInt32, Char.val, rfl]]
["USize.decLt",[USize, Decidable, LT.lt, instLTUSize, Fin, USize.size, inferInstanceAs, instLTFin, Fin.decLt]]
["Lean.Parser.Syntax.subPrio",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["ExceptT.lift_pure",[Monad, LawfulMonad, of_eq_true, Eq, ExceptT, ExceptT.mk, Functor.map, Applicative.toFunctor, Monad.toApplicative, Except, Except.ok, Pure.pure, Applicative.toPure, Eq.trans, True, congrFun, congrArg, LawfulApplicative.map_pure, LawfulMonad.toLawfulApplicative, eq_self]]
["UInt32.toUInt8",[UInt32, Nat.toUInt8, UInt32.toNat]]
["List.firstM",[Monad, Alternative, List, List.below, Unit, List.nil, Alternative.failure, List.cons, HOrElse.hOrElse, instHOrElse, instOrElse, PProd.fst, PUnit, PProd]]
["List.takeWhile",[Bool, List, List.below, Unit, List.nil, List.cons, PProd.fst, PUnit, PProd]]
["Int.instMulInt",[Mul.mk, Int, Int.mul]]
["Nat.mod_eq_sub_mod",[Nat, GE.ge, instLENat, Or, Eq, OfNat.ofNat, instOfNatNat, GT.gt, instLTNat, Nat.eq_zero_or_pos, HMod.hMod, instHMod, Nat.instModNat, HSub.hSub, instHSub, instSubNat, rfl, Eq.symm, Nat.sub_zero, ite, And, LT.lt, LE.le, instDecidableAnd, Nat.decLt, Nat.decLe, if_pos, And.intro, Nat.mod_eq]]
["withPtrEqUnsafe",[Unit, Bool, Eq, Unit.unit, Bool.true, ite, BEq.beq, USize, instBEq, instDecidableEqUSize, ptrAddrUnsafe, instDecidableEqBool]]
["UInt8.ofNat",[UInt8.mk, Fin.ofNat, OfNat.ofNat, Nat, instOfNatNat]]
["List.dropWhile",[Bool, List, List.below, Unit, List.nil, List.cons, PProd.fst, PUnit, PProd]]
["IO.Error.permissionDenied.sizeOf_spec",[Option, String, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["PSigma.revLex.proof_1",[WellFounded, WellFounded.intro, PSigma, PSigma.RevLex, Acc, PSigma.revLexAccessible, WellFounded.apply]]
["Lean.Syntax.setKind",[Lean.Syntax, Lean.SyntaxNodeKind, Array, Lean.Syntax.node]]
["MonadFinally.noConfusionType",[MonadFinally, Option, Prod, Eq]]
["Lean.Parser.Tactic.refine",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
["Eq.mp",[Eq]]
["Nat.add_zero",[Nat, rfl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat]]
["Std.Range.forIn",[Monad, Std.Range, Nat, ForInStep, Std.Range.stop, Std.Range.start, Std.Range.forIn.loop]]
["System.FilePath.components",[System.FilePath, String.splitOn, System.FilePath.toString, System.FilePath.normalize, Bool.false, Char.toString, System.FilePath.pathSeparator]]
["Option.some.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["Lean.Parser.Tactic.induction",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlts]]
["Subrelation.accessible",[Subrelation.accessible.proof_1]]
["List.eraseDups",[BEq, List, List.eraseDupsAux, List.nil]]
["List.mapTR",[List, List.mapTRAux, List.nil]]
["IO.Error.mkNoSuchThing",[IO.Error.noSuchThing, Option.none, String]]
["Array.size",[List.length, Array.data]]
["Coe.noConfusionType",[Coe, Eq]]
["Int.negOfNat",[Nat, Int, Unit, OfNat.ofNat, hasOfNatOfCoe, instCoeNatInt, instOfNatNat, Int.negSucc]]
["Decidable.byContradiction",[Decidable, Not, False, Decidable.byCases, id, False.elim]]
["Subarray.noConfusionType",[Subarray, Array, Nat, LE.le, instLENat, Array.size, Eq]]
["Substring.takeRightWhile",[Substring, Char, Bool, String, String.Pos, Substring.mk]]
["false_implies",[propext, False, True, Iff.intro, trivial, absurd, of_decide_eq_false, instDecidableFalse, Eq.refl, Bool, Decidable.decide]]
["String.anyAux",[String, String.Pos, Char, Bool, String.anyAux.loop]]
["instHModUInt8NatUInt8",[HMod.mk, UInt8, Nat, UInt8.modn]]
["IO.Error.resourceBusy.sizeOf_spec",[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar]]
["Thunk.get",[Thunk, Unit.unit]]
["Array.size_pop",[Array, List.length_dropLast, Array.data]]
["leOfOrd",[Ord, LE.mk, Eq, Bool, Ordering.isLE, Ord.compare, Bool.true]]
["Applicative.toSeq",[Applicative]]
["bfix1",[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd]]
["Substring.drop",[Substring, Nat, String, String.Pos, Substring.mk, HAdd.hAdd, instHAdd, instAddNat, Substring.nextn, OfNat.ofNat, instOfNatNat]]
["Substring.dropRight",[Substring, Nat, String, String.Pos, Substring.mk, HAdd.hAdd, instHAdd, instAddNat, Substring.prevn, Substring.bsize]]
["Array.get.proof_1",[Fin.isLt, Array.size]]
["System.SearchPath",[List, System.FilePath]]
["Subarray.foldr",[Subarray, Id.run, Subarray.foldrM, Id, Id.instMonadId]]
["Trans.noConfusionType",[outParam, Trans]]
["Equivalence.noConfusionType",[Equivalence]]
["instInhabitedUInt8",[Inhabited.mk, UInt8, UInt8.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, instInhabitedUInt8.proof_1]]
["«term_≥_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Lean.Name.str.injEq",[Lean.Name, String, UInt64, Eq.propIntro, Eq, Lean.Name.str, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["List.append_assoc",[List, Eq, HAppend.hAppend, instHAppend, List.instAppendList, rfl, List.nil, of_eq_true, List.cons, Eq.trans, True, congr, congrArg, congrFun, List.cons_append, eq_self]]
["Char.instLTChar",[LT.mk, Char, Char.lt]]
["coeTC",[CoeTC, CoeTC.coe]]
["«term_+_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["«term_<*>_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["instReprSum",[Repr, Repr.mk, Sum, Nat, Std.Format, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, reprArg]]
["IO.Error.mkResourceVanished",[IO.Error.resourceVanished]]
["stdNext",[StdGen, Prod, Nat, Int, Int.ofNat, HDiv.hDiv, instHDiv, Int.instDivInt, OfNat.ofNat, Int.instOfNatInt, HSub.hSub, instHSub, Int.instSubInt, HMul.hMul, instHMul, Int.instMulInt, ite, LT.lt, Int.instLTInt, Int.decLt, HAdd.hAdd, instHAdd, Int.instAddInt, HMod.hMod, instHMod, Int.instModInt, Prod.mk, Int.toNat, StdGen.mk]]
["instAndOpUInt8",[AndOp.mk, UInt8, UInt8.land]]
["«stx_+»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
["Nat.add_assoc",[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.below, rfl, OfNat.ofNat, instOfNatNat, Nat.succ, congrArg, Nat.add, PProd.fst, PUnit, PProd]]
["LawfulApplicative.seq_assoc",[Applicative, LawfulApplicative]]
["ExceptCpsT.instInhabitedExceptCpsT",[Inhabited, Inhabited.mk, ExceptCpsT, arbitrary]]
["Nat.forRevM",[Monad, Nat, Unit, Nat.forRevM.loop]]
["StateRefT'.instMonadStateRefT'",[Monad, inferInstanceAs, ReaderT, ST.Ref, ReaderT.instMonadReaderT]]
["UInt16.mod",[UInt16, UInt16.mk, HMod.hMod, Fin, UInt16.size, instHMod, Fin.instModFin, UInt16.val]]
["Decidable.decide",[Decidable, Bool, Not, Bool.false, Bool.true]]
["ExceptT.instMonadLiftExceptExceptT",[Monad, MonadLift.mk, Except, ExceptT, ExceptT.mk, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["Nat.le.brecOn",[Nat, Nat.le, Nat.le.below, Nat.le.below.refl, Nat.le.below.step]]
["Std.Format.nil.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["Nat.xor",[Nat.bitwise, bne, Bool, instBEq, instDecidableEqBool]]
["Option.toMonad",[Monad, Alternative, Option, Unit, Alternative.failure, Pure.pure, Applicative.toPure, Alternative.toApplicative]]
["instInhabitedExcept",[Inhabited, Inhabited.mk, Except, Except.error, arbitrary]]
["List.and",[List, Bool, List.all, id]]
["List.groupBy",[Bool, List, Unit, List.nil, List.groupByAux, List.cons]]
["Acc.ndrec",[Acc]]
["UInt8.div",[UInt8, UInt8.mk, HDiv.hDiv, Fin, UInt8.size, instHDiv, Fin.instDivFin, UInt8.val]]
["Lean.bracketedExplicitBinders",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.binderIdent, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat]]
["Fin.instOrOpFin",[Nat, OrOp.mk, Fin, Fin.lor]]
["instLTUInt16",[LT.mk, UInt16, UInt16.lt]]
["Pow.pow",[Pow]]
["Lean.Parser.Tactic.renameI",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
["IO.FS.Metadata.byteSize",[IO.FS.Metadata]]
["StateCpsT.instMonadStateOfStateCpsT",[MonadStateOf.mk, StateCpsT, PUnit, PUnit.unit, Prod]]
["StateCpsT.runK_bind_lift",[Monad, StateCpsT, rfl, StateCpsT.runK, Bind.bind, Monad.toBind, StateCpsT.instMonadStateCpsT, StateCpsT.lift]]
["Array.anyM.loop",[Monad, Bool, Array, Nat, LE.le, instLENat, Array.size, Nat.below, dite, LT.lt, instLTNat, Nat.decLt, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.false, Nat.succ, Bind.bind, Monad.toBind, Array.get, Fin.mk, Array.anyM.loop.proof_1, ite, Eq, Bool.true, instDecidableEqBool, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Not]]
["Std.Range.forM.loop",[Monad, Std.Range, Nat, PUnit, Nat.below, ite, GE.ge, instLENat, Std.Range.stop, Nat.decLe, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, Unit, Nat.succ, Bind.bind, Monad.toBind, PProd.fst, PProd, HAdd.hAdd, instHAdd, instAddNat, Std.Range.step]]
["Nat.div_eq",[Nat, dite, And, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HAdd.hAdd, instHAdd, instAddNat, HDiv.hDiv, instHDiv, Nat.instDivNat, HSub.hSub, instHSub, instSubNat, Not, Eq, congrFun, WellFounded.fix, WellFoundedRelation.rel, measure, id, WellFoundedRelation.wf, And.intro, Nat.sub_lt, Nat.lt_of_lt_of_le, Nat.zero, WellFounded.fix_eq, ite, dif_eq_if]]
["Setoid.symm",[Setoid, HasEquiv.Equiv, instHasEquiv, Equivalence.symm, Setoid.r, Setoid.iseqv]]
["System.FilePath.pathSeparators",[ite, List, Char, Eq, Bool, System.Platform.isWindows, Bool.true, instDecidableEqBool, List.cons, Char.ofNat, List.nil]]
["Float.mk.sizeOf_spec",[FloatSpec.float, floatSpec, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOf]]
["MProd.mk.inj",[Eq, MProd, MProd.mk, And, And.intro]]
["Lean.Parser.Tactic.apply",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
["Nat.shiftLeft",[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat]]
["instHAppend",[Append, HAppend.mk, Append.append]]
["Int.div",[Int, Nat, Int.ofNat, HDiv.hDiv, instHDiv, Nat.instDivNat, Neg.neg, Int.instNegInt, Nat.succ]]
["instSubsingletonSquash",[instSubsingletonSquash.proof_1]]
["Char.utf8Size.proof_2",[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
["MonadControlT.noConfusionType",[MonadControlT, Eq, HEq]]
["«term_≤_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["stx_?",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
["Option.eq_of_eq_some",[Option, Iff, Eq, Option.some, Option.none, rfl, Iff.mpr, Iff.mp, congrArg]]
["Lean.Name.simpMacroScopes",[Lean.Name, Bool, Lean.Name.hasMacroScopes, Unit, Lean.Name.below, Nat, UInt64, Lean.Name.num, Lean.Name.anonymous, String, Lean.Name.str, Lean.Name.mkNum, PProd.fst, PUnit, PProd, Unit.unit, BEq.beq, instBEq, instDecidableEqString]]
["Lean.SourceInfo.noConfusionType",[Lean.SourceInfo, Substring, String.Pos, Eq]]
["true_implies",[propext, True, Iff.intro, trivial]]
["Bool.and_self",[Bool, Eq, and, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl]]
["EStateM.get",[EStateM.Result.ok]]
["Nat.mul_comm",[Nat, Eq, HMul.hMul, instHMul, instMulNat, Nat.below, OfNat.ofNat, instOfNatNat, rfl, Eq.symm, Nat.mul_zero, Nat.zero_mul, Nat.succ, HAdd.hAdd, instHAdd, instAddNat, PProd.fst, PUnit, PProd, Nat.succ_mul, Nat.mul_succ]]
["Lean.withHeadRefOnly",[Monad, Lean.MonadRef, Bind.bind, Monad.toBind, Lean.Syntax, Lean.MonadRef.getRef, Option, Lean.Syntax.getHead?, Unit, Lean.withRef]]
["Reader",[ReaderT, Id]]
["Sum.inl.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["UInt32.decLt",[UInt32, Decidable, LT.lt, instLTUInt32, Fin, UInt32.size, inferInstanceAs, instLTFin, Fin.decLt]]
["USize.decEq",[USize, Decidable, Eq, Fin, USize.size, dite, USize.mk, instDecidableEqFin, Decidable.isTrue, USize.decEq.proof_1, Not, Decidable.isFalse, USize.decEq.proof_2]]
["congrFun",[Eq, rfl]]
["instMonadControlOptionT",[Monad, MonadControl.mk, OptionT, Option, liftM, instMonadLiftT, OptionT.instMonadLiftOptionT, instMonadLiftT_1, OptionT.run]]
["Substring.noConfusionType",[Substring, String, String.Pos, Eq]]
["instAddUInt16",[Add.mk, UInt16, UInt16.add]]
["List.zip",[List.zipWith, Prod, Prod.mk]]
["List.getLast.proof_2",[List, Eq, List.cons, List.nil, False]]
["MonadExcept.tryCatch",[MonadExcept]]
["seq_eq_bind_map",[Monad, LawfulMonad, Eq.mpr, Eq, Seq.seq, Applicative.toSeq, Monad.toApplicative, Unit, Bind.bind, Monad.toBind, Functor.map, Applicative.toFunctor, Eq.refl, Eq.symm, LawfulMonad.bind_map, rfl]]
["Array.findIdx?.loop.proof_2",[Array, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Eq.mpr, Eq.refl, Eq.symm, Nat.add_comm, Nat.add_assoc, rfl]]
["instShiftLeftUInt32",[ShiftLeft.mk, UInt32, UInt32.shiftLeft]]
["Nat.pow_le_pow_of_le_right",[Nat, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, LE.le, instLENat, HPow.hPow, instHPow, instPowNatNat, Nat.below, Nat.succ, Or, Eq, Nat.lt_or_eq_or_le_succ, Nat.le_refl, Eq.symm]]
["«term_⊕'_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Int.repr",[Int, String, Nat, Nat.repr, HAppend.hAppend, instHAppend, String.instAppendString, Nat.succ]]
["List.filter",[Bool, List, List.filterAux, List.nil]]
["Std.Format.group.injEq",[Std.Format, Std.Format.FlattenBehavior, Eq.propIntro, Eq, Std.Format.group, And, optParam, Std.Format.FlattenBehavior.allOrNone, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["UInt16.land",[UInt16, UInt16.mk, Fin.land, UInt16.size, UInt16.val]]
["IO.Error.userError.injEq",[String, Eq.propIntro, Eq, IO.Error, IO.Error.userError, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Neg.noConfusionType",[Neg, Eq]]
["Lean.Parser.Tactic.cases",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.sepBy1, Lean.Parser.Tactic.casesTarget, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.Parser.Tactic.inductionAlts]]
["Array.filterMap",[Option, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Id.run, Array.filterMapM, Id, Id.instMonadId]]
["instAddUInt8",[Add.mk, UInt8, UInt8.add]]
["IO.Error.resourceBusy.inj",[UInt32, String, Eq, IO.Error, IO.Error.resourceBusy, And, And.intro]]
["Lean.Parser.Tactic.Conv.nestedConv",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.Parser.Tactic.Conv.convSeqBracketed]]
["Fin.mul.proof_1",[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, HMul.hMul, instHMul, instMulNat]]
["Prod.allI",[Nat, Bool, Prod, Nat.anyAux, not, Prod.snd, HSub.hSub, instHSub, instSubNat, Prod.fst]]
["USize.shiftLeft",[USize, USize.mk, HShiftLeft.hShiftLeft, Fin, USize.size, instHShiftLeft, Fin.instShiftLeftFin, USize.val, USize.modn, System.Platform.numBits]]
["Lean.Parser.Tactic.Conv.conv",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.Conv.convSeq]]
["UInt64.toNat",[UInt64, Fin.val, UInt64.size, UInt64.val]]
["String.takeWhile",[String, Char, Bool, Substring.toString, Substring.takeWhile, String.toSubstring]]
["IO.withStderr",[Monad, MonadFinally, MonadLiftT, IO, IO.FS.Stream, Bind.bind, Monad.toBind, liftM, EIO, IO.Error, IO.setStderr, tryFinally, PUnit, Applicative.toFunctor, Monad.toApplicative, Functor.discard]]
["List.rotateRight",[List, optParam, Nat, OfNat.ofNat, instOfNatNat, List.length, ite, LE.le, instLENat, Nat.decLe, HSub.hSub, instHSub, instSubNat, HMod.hMod, instHMod, Nat.instModNat, List.take, List.drop, HAppend.hAppend, instHAppend, List.instAppendList]]
["List.concat",[List, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd]]
["Std.Format.group.sizeOf_spec",[Std.Format, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, String, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, Int]]
["Nat.mul_le_mul_left",[Nat, LE.le, instLENat, Exists, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.le.dest, HMul.hMul, instHMul, instMulNat]]
["instMonadExceptOfEST",[inferInstanceAs, MonadExceptOf, EStateM, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable]]
["List.hasDecEq.proof_3",[List, Eq, List.nil, List.cons, False]]
["String.Iterator.prevn",[String.Iterator, Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, String.Iterator.prev]]
["DecidablePred",[Decidable]]
["StateT.run_map",[Monad, LawfulMonad, StateT, Eq.mpr, Eq, Prod, StateT.run, Functor.map, Applicative.toFunctor, Monad.toApplicative, StateT.instMonadStateT, Prod.mk, Prod.fst, Prod.snd, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, congrArg, map_eq_pure_bind, bind_congr, rfl, Eq.symm, Eq.refl]]
["Nat.sub_self",[Nat, Eq, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, Nat.below, Unit, Eq.mpr, Eq.refl, Nat.sub_zero, rfl, Nat.succ, Nat.succ_sub_succ, PProd.fst, PUnit, PProd]]
["Array.uset",[Array, USize, LT.lt, Nat, instLTNat, USize.toNat, Array.size, Array.set, Fin.mk]]
["Xor.noConfusionType",[Xor, Eq]]
["Fin.add",[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, HAdd.hAdd, instHAdd, instAddNat, Fin.add.proof_1]]
["calcStep",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary]]
["UInt64.modn",[UInt64, UInt64.mk, HMod.hMod, Fin, UInt64.size, Nat, Fin.instHModFinNatFin, UInt64.val]]
["Lean.Parser.Tactic.Conv.change",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
["ofBoolUsing_eq_false",[Decidable, Eq, Bool, toBoolUsing, Bool.false, of_decide_eq_false]]
["UInt16.ofNatCore",[LT.lt, Nat, instLTNat, UInt16.size, UInt16.mk, Fin.mk]]
["Array.setD",[Array, Nat, dite, LT.lt, instLTNat, Array.size, Nat.decLt, Array.set, Fin.mk, Not]]
["Id.instLawfulMonadId.proof_1",[LawfulMonad.mk, Id, Id.instMonadId, LawfulApplicative.mk, Monad.toApplicative, LawfulFunctor.mk, Applicative.toFunctor, rfl, Functor.mapConst, Functor.map, id, Function.comp, SeqLeft.seqLeft, Applicative.toSeqLeft, Unit, SeqRight.seqRight, Applicative.toSeqRight, Seq.seq, Applicative.toSeq, Pure.pure, Applicative.toPure, Bind.bind, Monad.toBind]]
["Array.size_set",[Array, Fin, Array.size, List.length_set, Array.data, Fin.val]]
["Lean.Meta.Rewrite.Config.offsetCnstrs",[Lean.Meta.Rewrite.Config]]
["Int.decEq.proof_3",[Nat, Eq, Int, Int.negSucc, rfl]]
["List.reverse_reverse",[List, Eq.mpr, Eq, List.reverseAux, List.nil, Eq.refl, List.reverseAux_reverseAux_nil, rfl]]
["Array.any",[Array, Bool, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Id.run, Array.anyM, Id, Id.instMonadId]]
["instShiftRightUInt16",[ShiftRight.mk, UInt16, UInt16.shiftRight]]
["instDecidableEqString",[String.decEq]]
["Char.utf8Size.proof_6",[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
["Nat.zero_mul",[Nat, Eq, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, Nat.below, Unit, rfl, Nat.succ, HAdd.hAdd, instHAdd, instAddNat, Eq.symm, PProd.fst, PUnit, PProd, Nat.mul_succ]]
["Std.Format.instInhabitedFlattenBehavior",[Inhabited.mk, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone]]
["instXorUInt64",[Xor.mk, UInt64, UInt64.xor]]
["UInt32.size",[OfNat.ofNat, Nat, instOfNatNat]]
["UInt64.decLe",[UInt64, Decidable, LE.le, instLEUInt64, Fin, UInt64.size, inferInstanceAs, instLEFin, Fin.decLe]]
["Int.noConfusionType",[Int, Nat, Eq]]
["Nat.le_of_eq",[Nat, Eq, LE.le, instLENat, Nat.le_refl]]
["Char.isDigit",[Char, and, Decidable.decide, GE.ge, UInt32, instLEUInt32, Char.val, OfNat.ofNat, instOfNatUInt32, instDecidableLe, LE.le]]
["Lean.instQuoteList",[Lean.Quote, Lean.Quote.mk, List, Lean.Syntax, List.below, Unit, List.nil, List.cons, Unit.unit, Lean.mkCIdent, Lean.Name.mkStr, Lean.Name.anonymous, Lean.Syntax.mkCApp, List.toArray, Lean.Quote.quote, PProd.fst, PUnit, PProd]]
["Lean.Parser.Tactic.rwSeq",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq, Lean.Parser.Tactic.location]]
["ExceptT.instLawfulMonadExceptT",[ExceptT.instLawfulMonadExceptT.proof_1]]
["PSum.inr.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["EStateM.set",[EStateM.Result.ok, PUnit, PUnit.unit]]
["Array.swap",[Array, Array.get, Array.set, Nat, Array.size, Array.swap.proof_1]]
["ExceptT.bind_pure_comp",[Monad, LawfulMonad, ExceptT, rfl, Bind.bind, Monad.toBind, ExceptT.instMonadExceptT, Function.comp, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["orM",[Monad, ToBool, Bind.bind, Monad.toBind, Bool, ToBool.toBool, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["UInt16.decEq.proof_1",[Fin, UInt16.size, Eq, UInt16, UInt16.mk, rfl]]
["Lean.instEval_1",[Repr, Lean.Eval.mk, Unit, optParam, Bool, Bool.true, IO.println, Std.Format, instToStringFormat, repr, Unit.unit]]
["Lean.firstFrontendMacroScope",[HAdd.hAdd, Nat, instHAdd, instAddNat, Lean.reservedMacroScope, OfNat.ofNat, instOfNatNat]]
["instHashableOption",[Hashable, Hashable.mk, Option, UInt64, Unit, OfNat.ofNat, instOfNatUInt64, mixHash, Hashable.hash]]
["CoeTC.coe",[CoeTC]]
["Repr.addAppParen",[Std.Format, Nat, ite, GE.ge, instLENat, OfNat.ofNat, instOfNatNat, Nat.decLe, Std.Format.paren]]
["List.instForInList",[ForIn.mk, List, Monad, List.forIn]]
["false_of_ne",[Ne.irrefl]]
["HPow.noConfusionType",[outParam, HPow, Eq]]
["Sum.inr.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["instDecidableEqSum.proof_1",[Eq, Sum, Sum.inl, rfl]]
["USize.mul",[USize, USize.mk, HMul.hMul, Fin, USize.size, instHMul, Fin.instMulFin, USize.val]]
["instInhabitedTrue",[Inhabited.mk, True, True.intro]]
["WellFounded.fix_eq",[WellFounded, WellFounded.fixFEq, WellFounded.apply]]
["instSizeOfName",[SizeOf.mk, Lean.Name, Lean.Name.sizeOf]]
["Fin.instDivFin",[Nat, Div.mk, Fin, Fin.div]]
["Array.foldrMUnsafe",[Monad, Array, optParam, Nat, Array.size, OfNat.ofNat, instOfNatNat, USize, ite, LE.le, instLENat, Nat.decLe, LT.lt, instLTNat, Nat.decLt, USize.ofNat, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.foldrMUnsafe.fold]]
["HAppend.hAppend",[HAppend]]
["Functor.discard",[Functor, Functor.mapConst, PUnit, PUnit.unit]]
["Subtype.mk.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["Lean.Module.mk.inj",[Lean.Syntax, Array, Eq, Lean.Module, Lean.Module.mk, And, And.intro]]
["Subarray.forInUnsafe.loop",[Monad, Subarray, ForInStep, USize, ite, LT.lt, instLTUSize, instDecidableLt_4, Array.uget, Subarray.as, lcProof, Nat, instLTNat, USize.toNat, Array.size, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Subarray.forInUnsafe.loop, HAdd.hAdd, instHAdd, instAddUSize, OfNat.ofNat, instOfNatUSize]]
["Lean.Syntax.setInfo",[Lean.SourceInfo, Lean.Syntax, String, Lean.Syntax.atom, Substring, Lean.Name, List, Prod, Lean.Syntax.ident]]
["instComplementUInt16",[Complement.mk, UInt16, UInt16.complement]]
["IO.Error.noSuchThing.inj",[Option, String, UInt32, Eq, IO.Error, IO.Error.noSuchThing, And, And.intro]]
["instToStringByteArray",[ToString.mk, ByteArray, List.toString, UInt8, instToStringUInt8, ByteArray.toList]]
["instSubsingletonSquash.proof_1",[Subsingleton.intro, Squash, Squash.ind, Eq, Squash.mk, Quot.sound, True, True.intro]]
["UInt32.ofNatCore",[LT.lt, Nat, instLTNat, UInt32.size, UInt32.mk, Fin.mk]]
["term!_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Nat.gcd_zero_right",[Nat, Eq, Nat.gcd, OfNat.ofNat, instOfNatNat, Nat.zero, of_eq_true, Eq.trans, True, congr, congrArg, congrFun, Nat.zero_eq, Nat.gcd_zero_left, eq_true_of_decide, instDecidableEqNat, Eq.refl, Bool, Bool.true, Eq.symm, Nat.succ, HMod.hMod, instHMod, Nat.instModNat, Nat.gcd_succ, Nat.zero_mod, eq_self]]
["System.Platform.numBits",[Subtype.val, Nat, Or, Eq, OfNat.ofNat, instOfNatNat, System.Platform.getNumBits, Unit.unit]]
["instDecidableEqUSize",[USize.decEq]]
["instMulUInt16",[Mul.mk, UInt16, UInt16.mul]]
["instOrdBool",[Ord.mk, Bool, Ordering, Unit, Ordering.lt, Ordering.gt, Ordering.eq]]
["String.append",[String, List, Char, String.mk, HAppend.hAppend, instHAppend, List.instAppendList]]
["instHashableBool",[Hashable.mk, Bool, UInt64, Unit, OfNat.ofNat, instOfNatUInt64]]
["String.Iterator.prev",[String.Iterator, String, String.Pos, String.Iterator.mk, String.prev]]
["List.appendTR",[List, List.reverseAux, List.reverse]]
["Nat.decLe",[dite, Decidable, LE.le, Nat, instLENat, Eq, Bool, Nat.ble, Bool.true, instDecidableEqBool, Decidable.isTrue, Nat.le_of_ble_eq_true, Not, Decidable.isFalse, Nat.not_le_of_not_ble_eq_true]]
["IO.Error.hardwareFault.sizeOf_spec",[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar]]
["«term_∧_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["AndOp.noConfusionType",[AndOp, Eq]]
["ByteArray.isEmpty",[ByteArray, BEq.beq, Nat, instBEq, instDecidableEqNat, ByteArray.size, OfNat.ofNat, instOfNatNat]]
["Lean.NameGenerator.mk.inj",[Lean.Name, Nat, Eq, Lean.NameGenerator, Lean.NameGenerator.mk, And, And.intro]]
["Thunk.pure",[Thunk.mk, Unit]]
["Std.Format.joinSep",[Std.ToFormat, List, Std.Format, List.below, List.nil, Std.Format.nil, List.cons, Std.ToFormat.format, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, PProd.fst, PUnit, PProd]]
["StateCpsT",[]]
["Mul.noConfusionType",[Mul, Eq]]
["HEq.trans",[HEq, HEq.subst]]
["instDecidableEqUInt16",[UInt16.decEq]]
["Array.mapIdx",[Array, Fin, Array.size, Id.run, Array.mapIdxM, Id, Id.instMonadId]]
["List.length_nil",[rfl, Nat, List.length, List.nil]]
["Array.mk.injEq",[List, Eq.propIntro, Eq, Array, Array.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["List.partition",[Bool, List, List.partitionAux, Prod.mk, List.nil]]
["Lean.instInhabitedParserDescr",[Inhabited.mk, Lean.ParserDescr, Lean.ParserDescr.symbol]]
["Lean.Syntax.ident.injEq",[Lean.SourceInfo, Substring, Lean.Name, List, Prod, String, Eq.propIntro, Eq, Lean.Syntax, Lean.Syntax.ident, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Nat.gcd_succ",[Nat, rfl, Nat.gcd, Nat.succ]]
["Option.all",[Bool, Option, Unit, Bool.true]]
["«term_*>_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Int.negSucc.injEq",[Nat, Eq.propIntro, Eq, Int, Int.negSucc, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["IO.FS.FileType.dir.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["IO.FS.Handle.putStrLn",[IO.FS.Handle, String, IO.FS.Handle.putStr, String.push, Char.ofNat]]
["instHModUSizeNatUSize",[HMod.mk, USize, Nat, USize.modn]]
["StateT.run",[StateT]]
["Lean.Parser.Tactic.changeWith",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.Parser.Tactic.location]]
["ExceptT.mk",[Except]]
["Lean.Name.instAppendName",[Append.mk, Lean.Name, Lean.Name.append]]
["String.push",[String, Char, List, String.mk, HAppend.hAppend, instHAppend, List.instAppendList, List.cons, List.nil]]
["Option.instDecidableRelLt",[DecidableRel, Option, Decidable, Option.lt, Decidable.isTrue, Option.none, Option.some, trivial, Decidable.isFalse, not_false, Unit]]
["UInt64.shiftRight",[UInt64, UInt64.mk, HShiftRight.hShiftRight, Fin, UInt64.size, instHShiftRight, Fin.instShiftRightFin, UInt64.val, UInt64.modn, OfNat.ofNat, Nat, instOfNatNat]]
["Char.isUpper",[Char, and, Decidable.decide, GE.ge, UInt32, instLEUInt32, Char.val, OfNat.ofNat, instOfNatUInt32, instDecidableLe, LE.le]]
["String.instLTString",[LT.mk, String, LT.lt, List, Char, List.instLTList, Char.instLTChar, String.data]]
["EStateM.Result.ok.injEq",[Eq.propIntro, Eq, EStateM.Result, EStateM.Result.ok, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["List.getD",[Nat, List, Option.getD, List.get?]]
["MProd.snd",[MProd]]
["IO.FS.Stream.ofHandle",[IO.FS.Handle, IO.FS.Stream.mk, IO.FS.Handle.isEof, IO.FS.Handle.flush, IO.FS.Handle.read, IO.FS.Handle.write, IO.FS.Handle.getLine, IO.FS.Handle.putStr]]
["IO.Error.fopenErrorToString",[String, UInt32, Option, HAppend.hAppend, instHAppend, String.instAppendString, String.modify, OfNat.ofNat, String.Pos, instOfNatNat, Char.toLower, ToString.toString, instToStringUInt32, Unit]]
["Lean.instQuoteArray",[Lean.Quote, Lean.Quote.mk, Array, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, Lean.Syntax, List.cons, Lean.Quote.quote, List, Lean.instQuoteList, Array.toList, List.nil]]
["IO.FS.Mode.noConfusion",[IO.FS.Mode, Eq, noConfusionEnum, Nat, instDecidableEqNat, IO.FS.Mode.toCtorIdx]]
["ForIn.noConfusionType",[outParam, ForIn, Monad, ForInStep, Eq]]
["ToString.toString",[ToString]]
["Array.anyM.loop.proof_1",[Array, Nat, LE.le, instLENat, Array.size, LT.lt, instLTNat, Nat.lt_of_lt_of_le]]
["Acc.ndrecOn",[Acc]]
["Quot.recOnSubsingleton.proof_1",[Quot, Subsingleton, Quot.mk, Subsingleton.elim, Quot.sound]]
["String.utf8ByteSize",[String, Nat, List, Char, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd, HAdd.hAdd, instHAdd, instAddNat, String.csize, OfNat.ofNat, instOfNatNat]]
["UInt32.sub",[UInt32, UInt32.mk, HSub.hSub, Fin, UInt32.size, instHSub, Fin.instSubFin, UInt32.val]]
["iff_iff_implies_and_implies",[Iff.intro, Iff, And, And.intro, Iff.mp, Iff.mpr, And.left, And.right]]
["StdGen.s1",[StdGen]]
["Array.findRevM?",[Monad, Array, Bool, Array.findSomeRevM?, Bind.bind, Monad.toBind, Option, Pure.pure, Applicative.toPure, Monad.toApplicative, ite, Eq, Bool.true, instDecidableEqBool, Option.some, Option.none]]
["System.SearchPath.toString",[System.SearchPath, String.intercalate, Char.toString, System.SearchPath.separator, List.map, System.FilePath, String, System.FilePath.toString]]
["Array.instHAppendArrayListArray",[HAppend.mk, Array, List, Array.appendList]]
["IO.FS.FileType.toCtorIdx",[IO.FS.FileType, Nat, OfNat.ofNat, instOfNatNat]]
["Nat.lt",[Nat, Nat.le, Nat.succ]]
["of_decide_eq_false",[Decidable, Eq, Bool, Decidable.decide, Bool.false, Not, absurd, ne_false_of_eq_true, decide_eq_true]]
["StateT.run_monadLift",[Monad, MonadLiftT, rfl, Prod, StateT.run, MonadLiftT.monadLift, StateT, instMonadLiftT, StateT.instMonadLiftStateT]]
["Bool.or_self",[Bool, Eq, or, Bool.false, rfl, Eq.symm, Bool.true, Eq.refl]]
["LawfulMonad.bind_assoc",[Monad, LawfulMonad]]
["Mul.mul",[Mul]]
["EStateM.instMonadStateOfEStateM",[MonadStateOf.mk, EStateM, EStateM.get, EStateM.set, EStateM.modifyGet]]
["List.instEmptyCollectionList",[EmptyCollection.mk, List, List.nil]]
["UInt16.xor",[UInt16, UInt16.mk, Fin.xor, UInt16.size, UInt16.val]]
["UInt64.toUInt32",[UInt64, Nat.toUInt32, UInt64.toNat]]
["instLTFloat",[LT.mk, Float, Float.lt]]
["List.length_eq_lenghtTR",[funext, List, Nat, List.length, List.lengthTR, of_eq_true, Eq, List.lengthTRAux, OfNat.ofNat, instOfNatNat, Eq.trans, True, congrArg, HAdd.hAdd, instHAdd, instAddNat, Eq.symm, List.length_add_eq_lengthTRAux, Nat.add_zero, eq_self]]
["System.FilePath.extSeparator",[Char.ofNat]]
["Lean.Macro.instMonadQuotationMacroM",[Lean.MonadQuotation.mk, Lean.MacroM, Lean.Macro.instMonadRefMacroM, Lean.Macro.Context, Pure.pure, EStateM, Lean.Macro.Exception, Lean.Macro.State, Applicative.toPure, Monad.toApplicative, EStateM.instMonadEStateM, Lean.MacroScope, Lean.Macro.Context.currMacroScope, Lean.Name, Lean.Macro.Context.mainModule, Lean.Macro.withFreshMacroScope]]
["List.cons.injEq",[List, Eq.propIntro, Eq, List.cons, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["instInhabitedProp",[Inhabited.mk, True]]
["ReaderT.instMonadReaderT",[Monad, Monad.mk, ReaderT, Applicative.mk, Functor.mk, ReaderT.map, Pure.mk, ReaderT.pure, Seq.mk, SeqLeft.mk, SeqRight.mk, Bind.mk, ReaderT.bind]]
["Lean.Syntax.mkNumLit",[String, optParam, Lean.SourceInfo, Lean.SourceInfo.none, Lean.Syntax.mkLit, Lean.numLitKind]]
["Nat.pow_succ",[Nat, rfl, HPow.hPow, instHPow, instPowNatNat, Nat.succ]]
["Lean.MonadRef.mkInfoFromRefPos",[Monad, Lean.MonadRef, Bind.bind, Monad.toBind, Lean.Syntax, Lean.SourceInfo, Lean.MonadRef.getRef, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.SourceInfo.fromRef]]
["Std.Format.FlattenBehavior.fill.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["OptionM.run",[OptionM]]
["Lean.ParserDescr.ibelow",[Lean.ParserDescr, Lean.Name, True, And, Lean.SyntaxNodeKind, Nat, String, Bool, optParam, Bool.false]]
["instDecidableEqProd.proof_1",[Eq, Prod, Prod.mk, rfl]]
["instSizeOf",[SizeOf.mk, default.sizeOf]]
["DoResultPRBC.pure.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["Lean.Syntax.decodeQuotedChar",[String, String.Pos, OptionM.run, Prod, Char, String.get, String.next, ite, OptionM, Eq, Bool, BEq.beq, instBEq, instDecidableEqChar, Char.ofNat, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Alternative.toApplicative, OptionT.instAlternativeOptionT, Id, Id.instMonadId, Prod.mk, Bind.bind, Monad.toBind, OptionT.instMonadOptionT, Nat, Option, and, Decidable.decide, LE.le, Char.instLEChar, Char.instDecidableLe, Option.some, HSub.hSub, instHSub, instSubNat, Char.toNat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Option.none, HMul.hMul, instHMul, instMulNat]]
["HAndThen.hAndThen",[HAndThen]]
["String.foldrAux",[Char, String, String.Pos, String.foldrAux.loop]]
["cond",[Bool, Unit]]
["«term_%_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Array.get?",[Array, Nat, dite, Option, LT.lt, instLTNat, Array.size, Nat.decLt, Option.some, Array.get, Fin.mk, Not, Option.none]]
["Substring.bsize",[Substring, Nat, String, String.Pos, Nat.sub]]
["Char.quoteCore",[Char, ite, String, Eq, Char.ofNat, instDecidableEqChar, Or, LE.le, Nat, instLENat, Char.toNat, OfNat.ofNat, instOfNatNat, instDecidableOr, Nat.decLe, HAppend.hAppend, instHAppend, String.instAppendString, charToHex, String.singleton]]
["Lean.Name.hash.proof_1",[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt64.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
["Array.findSomeM?",[Monad, Array, Option, Bind.bind, Monad.toBind, MProd, PUnit, ForIn.forIn, Array.instForInArray, MProd.mk, Option.none, PUnit.unit, ForInStep, Pure.pure, Applicative.toPure, Monad.toApplicative, ForInStep.done, Option.some, ForInStep.yield, MProd.fst, Unit]]
["«term_>>_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Std.Format.bracket",[String, Std.Format, Std.Format.group, Std.Format.nest, Int.ofNat, String.length, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, Std.Format.FlattenBehavior.allOrNone]]
["instMonadLiftSTEST",[MonadLift.mk, ST, EST, EStateM.Result, Empty, EStateM.Result.ok]]
["UInt32.decEq.proof_1",[Fin, UInt32.size, Eq, UInt32, UInt32.mk, rfl]]
["OrOp.or",[OrOp]]
["trivial",[True.intro]]
["Lean.Meta.Simp.instReprConfig",[Repr.mk, Lean.Meta.Simp.Config, Nat, Std.Format.bracket, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.nil, Std.Format.text, repr, instReprNat, Lean.Meta.Simp.Config.maxSteps, Std.Format.line, Lean.Meta.Simp.Config.maxDischargeDepth, Bool, instReprBool, Lean.Meta.Simp.Config.contextual, Lean.Meta.Simp.Config.memoize, Lean.Meta.Simp.Config.singlePass, Lean.Meta.Simp.Config.zeta, Lean.Meta.Simp.Config.beta, Lean.Meta.Simp.Config.eta, Lean.Meta.Simp.Config.iota, Lean.Meta.Simp.Config.proj, Lean.Meta.Simp.Config.decide]]
["withTheReader",[MonadWithReaderOf, MonadWithReaderOf.withReader]]
["Lean.Macro.resolveNamespace?",[Lean.Name, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, Option, Lean.Macro.getMethods, Lean.Macro.Methods.resolveNamespace?]]
["Lean.mkOptionalNode",[Option, Lean.Syntax, Lean.Syntax.node, Lean.nullKind, List.toArray, List.cons, List.nil, Unit]]
["Sigma.mk.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["Subarray.as",[Subarray]]
["Array.insertionSort.traverse",[Bool, Array, Nat, Nat.below, Unit, Nat.succ, dite, LT.lt, instLTNat, Array.size, Nat.decLt, PProd.fst, PUnit, PProd, Array.insertionSort.swapLoop, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Not]]
["Substring.toString",[Substring, String, String.Pos, String.extract]]
["Lean.Meta.Simp.Config.eta",[Lean.Meta.Simp.Config]]
["ExceptT.run",[ExceptT]]
["Nat.toFloat",[Nat, Float.ofNat]]
["Std.Format.nest.injEq",[Int, Std.Format, Eq.propIntro, Eq, Std.Format.nest, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Subarray.allM",[Monad, Bool, Subarray, Array.allM, Subarray.as, Subarray.start, Subarray.stop]]
["Lean.Macro.Context.maxRecDepth",[Lean.Macro.Context]]
["IO.FS.Handle.readBinToEnd",[IO.FS.Handle, ByteArray, IO, ByteArray.empty, IO.FS.Handle.readBinToEnd.loop]]
["Lean.Syntax.hasArgs",[Lean.Syntax, Bool, Lean.SyntaxNodeKind, Array, Decidable.decide, GT.gt, Nat, instLTNat, Array.size, OfNat.ofNat, instOfNatNat, Nat.decLt, Bool.false]]
["String.posOf",[String, Char, String.posOfAux, String.bsize, OfNat.ofNat, String.Pos, instOfNatNat]]
["Option.lt",[Option, True, False]]
["Array.forIn.loop.proof_1",[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Nat.lt_of_le_of_lt, HSub.hSub, instHSub, instSubNat, Nat.sub_le, Nat.sub_lt, LT.lt, instLTNat, Nat.below, Nat.succ, Nat.zero, Nat.lt_of_lt_of_le, Nat.lt_succ_self, of_decide_eq_true, Nat.decLt, Eq.refl, Bool, Bool.true]]
["Array.mkArray",[Nat, Array.mk, List.replicate]]
["instDecidableEqQuotient",[Setoid, Decidable, HasEquiv.Equiv, instHasEquiv, Quotient, Quotient.recOnSubsingleton₂, Eq, instDecidableEqQuotient.proof_1, Quotient.mk, Decidable.isTrue, Quotient.sound, Not, Decidable.isFalse, instDecidableEqQuotient.proof_2]]
["Except.map",[Except, Except.error, Except.ok]]
["List.reverse_cons",[List, Eq.mpr, Eq, List.reverseAux, List.cons, List.nil, HAppend.hAppend, instHAppend, List.instAppendList, Eq.refl, Eq.symm, List.reverseAux_eq_append, rfl]]
["Lean.MonadNameGenerator.noConfusionType",[Lean.MonadNameGenerator, Lean.NameGenerator, Unit, Eq]]
["Int.instDivInt",[Div.mk, Int, Int.div]]
["CoeTail.coe",[CoeTail]]
["Nat.not_succ_le_self",[Nat, Not, LE.le, instLENat, Nat.succ, Nat.below, Unit, Nat.not_succ_le_zero, OfNat.ofNat, instOfNatNat, absurd, HAdd.hAdd, instHAdd, instAddNat, False, Nat.le_of_succ_le_succ, PProd.fst, PUnit, PProd]]
["«command_ClassAbbrev__:_:=__,»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
["MonadFunctorT.noConfusionType",[MonadFunctorT, Eq]]
["Fin.lor.proof_1",[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, Nat.lor]]
["Except.toOption",[Except, Option, Option.some, Option.none]]
["String.instAppendString",[Append.mk, String, String.append]]
["Fin.sub",[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, HAdd.hAdd, instHAdd, instAddNat, HSub.hSub, instHSub, instSubNat, Fin.sub.proof_1]]
["Char.toString",[Char, String.singleton]]
["MonadLift.monadLift",[MonadLift]]
["Functor.noConfusionType",[Functor, Eq]]
["instHashableInt",[Hashable.mk, Int, UInt64, Nat, UInt64.ofNat, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat]]
["AndThen.noConfusionType",[AndThen, Unit, Eq]]
["Lean.Meta.TransparencyMode.noConfusionType",[Lean.Meta.TransparencyMode, noConfusionTypeEnum, Nat, instDecidableEqNat, Lean.Meta.TransparencyMode.toCtorIdx]]
["Except.error.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["List.filterMap",[Option, List, List.below, Unit, List.nil, List.cons, PProd.fst, PUnit, PProd]]
["Lean.Parser.Tactic.rename",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
["USize.modn_lt",[Nat, USize, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, LT.lt, USize.toNat, HMod.hMod, instHModUSizeNatUSize, Fin, USize.size, Fin.modn_lt]]
["Subtype.existsOfSubtype",[Subtype.existsOfSubtype.proof_1]]
["DecidableEq",[Decidable, Eq]]
["String.dropRightWhile",[String, Char, Bool, Substring.toString, Substring.dropRightWhile, String.toSubstring]]
["UInt32.shiftLeft",[UInt32, UInt32.mk, HShiftLeft.hShiftLeft, Fin, UInt32.size, instHShiftLeft, Fin.instShiftLeftFin, UInt32.val, UInt32.modn, OfNat.ofNat, Nat, instOfNatNat]]
["instDecidableEqNat",[Nat.decEq]]
["InvImage.accessible",[InvImage.accessible.proof_1]]
["PSigma.eta",[Eq, PSigma, PSigma.mk, Eq.refl, rfl]]
["instComplementUInt32",[Complement.mk, UInt32, UInt32.complement]]
["FloatSpec.mk.sizeOf_spec",[DecidableRel, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOf]]
["ltOfOrd",[Ord, LT.mk, Eq, Bool, BEq.beq, Ordering, instBEqOrdering, Ord.compare, Ordering.lt, Bool.true]]
["instLEUSize",[LE.mk, USize, USize.le]]
["IO.Process.Stdio.piped.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["Nat.le_succ_of_le",[Nat, LE.le, instLENat, Nat.le_trans, Nat.succ, Nat.le_succ]]
["«termIfLet_:=_Then_Else_»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Bool.false.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["Array.insertionSort.swapLoop",[Bool, Array, Nat, LT.lt, instLTNat, Array.size, Nat.below, Eq, Eq.refl, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ]]
["ByteArray.data",[ByteArray]]
["String.noConfusionType",[String, List, Char, Eq]]
["Nat.instXorNat",[Xor.mk, Nat, Nat.xor]]
["instLTNat",[LT.mk, Nat, Nat.lt]]
["instDecidableArrow",[Decidable, dite, Decidable.isTrue, instDecidableArrow.proof_1, Not, Decidable.isFalse, instDecidableArrow.proof_2, instDecidableArrow.proof_3]]
["Array.unzip",[Array, Prod, Array.foldl, Prod.mk, Array.push, List.toArray, List.nil, OfNat.ofNat, Nat, instOfNatNat, Array.size]]
["Nat.one_ne_zero",[Eq, Nat, OfNat.ofNat, instOfNatNat, False]]
["UInt32.mk.sizeOf_spec",[Fin, UInt32.size, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["Quotient.ind",[Setoid, Quotient, Quot.ind, Setoid.r]]
["String.front",[String, String.get, OfNat.ofNat, String.Pos, instOfNatNat]]
["System.FilePath.extension",[System.FilePath, Option.bind, String, System.FilePath.fileName, Option, String.Pos, String.revPosOf, Char.ofNat, Unit, Option.none, Option.some, String.extract, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, String.bsize]]
["List.nil.sizeOf_spec",[SizeOf, Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["IO.Process.output",[IO.Process.SpawnArgs, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.Process.Child, IO.Process.SpawnArgs.toStdioConfig, IO.Process.SpawnArgs.mk, IO.Process.StdioConfig.mk, IO.Process.StdioConfig.stdin, IO.Process.Stdio.piped, IO.Process.SpawnArgs.cmd, IO.Process.SpawnArgs.args, IO.Process.SpawnArgs.cwd, IO.Process.SpawnArgs.env, IO.Process.Output, IO.Process.spawn, Task, Except, String, IO.asTask, IO.FS.Handle.readToEnd, IO.Process.Child.stdout, Task.Priority.dedicated, IO.Process.Child.stderr, UInt32, IO.Process.Child.wait, IO.ofExcept, IO.Error.instToStringError, Task.get, Pure.pure, Applicative.toPure, Monad.toApplicative, IO.Process.Output.mk]]
["coeD",[CoeDep, CoeDep.coe]]
["instSTWorld",[outParam, MonadLift, STWorld, STWorld.mk]]
["coeOfHeadOfTC",[CoeHead, CoeTC, CoeHTCT.mk, coeTC, coeHead]]
["StateRefT'.instMonadLiftStateRefT'",[MonadLift.mk, StateRefT', StateRefT'.lift]]
["instDecidableLt",[UInt32, UInt32.decLt]]
["instReprULift",[Repr, Repr.mk, ULift, Nat, Repr.addAppParen, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.text, reprArg, ULift.down]]
["Lean.Syntax.SepArray.ofElemsUsingRef",[Monad, Lean.MonadRef, String, Array, Lean.Syntax, Bind.bind, Monad.toBind, Lean.Syntax.SepArray, Lean.MonadRef.getRef, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.SepArray.mk, Lean.mkSepArray, Lean.mkAtomFrom]]
["Substring.contains",[Substring, Char, Substring.any, BEq.beq, instBEq, instDecidableEqChar]]
["StateT.modifyGet",[Monad, Prod, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["String.bsize",[String, String.utf8ByteSize]]
["DoResultPRBC.return.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["Array.instEmptyCollectionArray",[EmptyCollection.mk, Array, Array.empty]]
["Lean.Syntax.isNone",[Lean.Syntax, Bool, Lean.SyntaxNodeKind, Array, and, BEq.beq, Lean.Name.instBEqName, Lean.nullKind, Nat, instBEq, instDecidableEqNat, Array.size, OfNat.ofNat, instOfNatNat, Unit, Bool.true, Bool.false]]
["UInt8.toUInt32",[UInt8, Nat.toUInt32, UInt8.toNat]]
["String.set",[String, String.Pos, Char, List, String.mk, List.below, List.nil, List.cons, ite, Eq, instDecidableEqNat, PProd.fst, PUnit, PProd, HAdd.hAdd, Nat, instHAdd, instAddNat, String.csize, OfNat.ofNat, instOfNatNat]]
["Nat.foldAux",[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, HSub.hSub, instHSub, instSubNat]]
["MProd.mk.injEq",[Eq.propIntro, Eq, MProd, MProd.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Lean.instQuoteSubstring",[Lean.Quote.mk, Substring, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, Lean.Syntax, List.cons, Lean.Quote.quote, String, Lean.instQuoteString, Substring.toString, List.nil]]
["Seq.noConfusionType",[Seq, Unit, Eq]]
["IO.Process.StdioConfig.stdin",[IO.Process.StdioConfig]]
["Subtype.noConfusionType",[Subtype, Eq]]
["fix6",[Inhabited, fixCore6, arbitrary]]
["Nat.lor",[Nat.bitwise, or]]
["ByteArray.mkEmpty",[ByteArray.mk, List.toArray, UInt8, List.nil]]
["List.toByteArray",[List, UInt8, ByteArray, ByteArray.empty, List.toByteArray.loop]]
["Nat.lt.step.proof_1",[Nat, Nat.le_step, Nat.succ]]
["ByteArray.set!",[ByteArray, Nat, UInt8, Array, ByteArray.mk, Array.set!]]
["instTransEq",[Trans.mk, Eq, instTransEq.proof_1]]
["PLift.noConfusionType",[PLift, Eq]]
["Task.get",[Task]]
["FloatSpec.mk.inj",[DecidableRel, Eq, FloatSpec, FloatSpec.mk, And, HEq, And.intro]]
["UInt64.toUInt8",[UInt64, Nat.toUInt8, UInt64.toNat]]
["Array.ext",[Array, Eq, Nat, Array.size, LT.lt, instLTNat, Array.get, Fin.mk, List, List.length, List.get, Array.mk, congrArg, Eq.symm, Eq.refl, Array.ext.extAux]]
["FloatSpec.le",[FloatSpec]]
["instShiftLeftUSize",[ShiftLeft.mk, USize, USize.shiftLeft]]
["IO.Process.Child.mk.sizeOf_spec",[IO.Process.StdioConfig, IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdin, IO.Process.StdioConfig.stdout, IO.Process.StdioConfig.stderr, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOf]]
["ExceptCpsT.runCatch",[Monad, ExceptCpsT, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["Lean.MonadQuotation.getMainModule",[Lean.MonadQuotation]]
["IO.Error.unsatisfiedConstraints.sizeOf_spec",[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar]]
["DoResultSBC.noConfusionType",[DoResultSBC, Eq]]
["instSubNat",[Sub.mk, Nat, Nat.sub]]
["instToStreamStringSubstring",[ToStream.mk, String, Substring, String.toSubstring]]
["Lean.Parser.Tactic.rotateRight",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
["Fin.div.proof_1",[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, HDiv.hDiv, instHDiv, Nat.instDivNat]]
["Std.Format.prettyM",[Std.Format, Nat, optParam, OfNat.ofNat, instOfNatNat, Monad, Std.Format.MonadPrettyFormat, List.cons, Bool.false, Std.Format.FlattenBehavior.allOrNone, Int.ofNat, List.nil]]
["ite",[Decidable, Not]]
["Lean.evalPrio",[Lean.Syntax, Lean.Macro.withIncRecDepth, Nat, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.expandMacros, cond, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.getD, Lean.Syntax.isNatLit?, OfNat.ofNat, instOfNatNat, Lean.Macro.throwErrorAt]]
["InvImage.accessible.proof_1",[Acc, Eq, InvImage, Acc.intro, rfl]]
["ByteArray.mk.sizeOf_spec",[Array, UInt8, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, List, Fin, UInt8.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["Prod.lex.proof_1",[WellFoundedRelation, WellFounded.intro, Prod, Prod.Lex, WellFoundedRelation.rel, Acc, Prod.lexAccessible, WellFounded.apply, WellFoundedRelation.wf]]
["decide_eq_false",[Decidable, Not, Eq, Bool, Decidable.decide, Bool.false, absurd, Decidable.isTrue, rfl, Decidable.isFalse]]
["IO.Error.resourceBusy.injEq",[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.resourceBusy, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["bind_pure_unit",[Monad, LawfulMonad, PUnit]]
["Substring.all",[Substring, Char, Bool, not, Substring.any]]
["Nat.not_le_of_not_ble_eq_true",[Nat, Not, Eq, Bool, Nat.ble, Bool.true, LE.le, instLENat, absurd, False, Nat.ble_eq_true_of_le]]
["Nat.div",[WellFounded.fix, Nat, WellFoundedRelation.rel, measure, id, Nat.div.proof_1, LT.lt, instLTNat, dite, And, OfNat.ofNat, instOfNatNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HAdd.hAdd, instHAdd, instAddNat, HSub.hSub, instHSub, instSubNat, And.intro, Nat.sub_lt, Nat.lt_of_lt_of_le, Not, Nat.zero]]
["Array.findSomeRevM?.find.proof_2",[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Nat.le_of_lt, Nat.lt_of_lt_of_le, Nat.succ, Nat.lt_succ_self]]
["Subtype.mk.injEq",[Eq.propIntro, Eq, Subtype, Subtype.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["IO.RealWorld",[Unit]]
["String.Iterator.i",[String.Iterator]]
["String.toInt!",[String, Option, Int, String.toInt?, Unit, panic, Int.instInhabitedInt]]
["List.head?",[List, Option, Unit, Option.none, Option.some]]
["IO.Error.unsatisfiedConstraints.inj",[UInt32, String, Eq, IO.Error, IO.Error.unsatisfiedConstraints, And, And.intro]]
["Nat.gcd_one_left",[Nat, Eq.mpr, Eq, Nat.gcd, OfNat.ofNat, instOfNatNat, HMod.hMod, instHMod, Nat.instModNat, Nat.succ, Eq.refl, Nat.gcd_succ, Nat.mod_one, rfl]]
["ShiftRight.shiftRight",[ShiftRight]]
["Lean.addMacroScope",[Lean.Name, Lean.MacroScope, Bool, Lean.Name.hasMacroScopes, Unit, Lean.MacroScopesView, Lean.extractMacroScopes, BEq.beq, Lean.Name.instBEqName, Lean.MacroScopesView.mainModule, Lean.Name.mkNum, Lean.MacroScopesView.review, Lean.MacroScopesView.mk, Lean.MacroScopesView.name, List.foldl, Nat, HAppend.hAppend, instHAppend, Lean.Name.instAppendName, Lean.MacroScopesView.imported, Lean.MacroScopesView.scopes, List.cons, List.nil, Lean.Name.mkStr]]
["Function.Equiv.isEquivalence",[Equivalence.mk, Function.Equiv, Function.Equiv.refl, Function.Equiv.symm, Function.Equiv.trans]]
["System.FilePath.mk.sizeOf_spec",[String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["Array.qpartition",[Inhabited, Array, Bool, Nat, HDiv.hDiv, instHDiv, Nat.instDivNat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, ite, Eq, Array.get!, Bool.true, instDecidableEqBool, Array.swap!, Prod, Array.qpartition.loop]]
["List.lt.brecOn",[LT, List, List.lt, List.lt.below, List.lt.below.nil, LT.lt, List.lt.below.head, Not, List.lt.below.tail]]
["UInt64.decEq",[UInt64, Decidable, Eq, Fin, UInt64.size, dite, UInt64.mk, instDecidableEqFin, Decidable.isTrue, UInt64.decEq.proof_1, Not, Decidable.isFalse, UInt64.decEq.proof_2]]
["Char.isAlphanum",[Char, or, Char.isAlpha, Char.isDigit]]
["List.forIn",[Monad, List, ForInStep, List.forIn.loop]]
["List.findSome?",[Option, List, List.below, Unit, List.nil, Option.none, List.cons, Option.some, PProd.fst, PUnit, PProd]]
["Lean.MonadQuotation.getCurrMacroScope",[Lean.MonadQuotation]]
["Int.decLe",[Decidable, Int.NonNeg, Nat, Decidable.isTrue, Int.ofNat, Int.NonNeg.mk, Decidable.isFalse, Int.negSucc, Int, Eq, HEq, Eq.refl, HEq.refl, False, HSub.hSub, instHSub, Int.instSubInt]]
["USize.toNat",[USize, Fin.val, USize.size, USize.val]]
["IO.FS.readFile",[System.FilePath, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.FS.Handle, String, IO.FS.Handle.mk, IO.FS.Mode.read, Bool.false, IO.FS.Handle.readToEnd]]
["Function.Equiv",[Eq]]
["String.singleton",[Char, String.push]]
["IO.Process.Output.stdout",[IO.Process.Output]]
["dif_eq_if",[Decidable, Eq, dite, Not, ite, rfl, Decidable.isTrue, Decidable.isFalse]]
["LawfulMonad.bind_pure_comp",[Monad, LawfulMonad]]
["Std.Format.instBEqFlattenBehavior",[BEq.mk, Std.Format.FlattenBehavior, BEq.beq, Nat, instBEq, instDecidableEqNat, Std.Format.FlattenBehavior.toCtorIdx]]
["Array.mapIdxM",[Monad, Array, Fin, Array.size, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, rfl, Array.mkEmpty, Array.mapIdxM.map]]
["List.rotateLeft",[List, optParam, Nat, OfNat.ofNat, instOfNatNat, List.length, ite, LE.le, instLENat, Nat.decLe, HMod.hMod, instHMod, Nat.instModNat, List.take, List.drop, HAppend.hAppend, instHAppend, List.instAppendList]]
["Lean.instEvalUnit",[Lean.Eval.mk, Unit, optParam, Bool, Bool.true, ite, IO, Eq, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, instMonadEIO, IO.Error, Unit.unit, IO.println, Std.Format, instToStringFormat, repr, instReprUnit]]
["IO.Error.interrupted.sizeOf_spec",[String, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["Std.Format.line.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["Bind.noConfusionType",[Bind, Eq]]
["StateT.run'_eq",[Monad, StateT, rfl, StateT.run', Applicative.toFunctor, Monad.toApplicative]]
["String.toList",[String, String.data]]
["WellFoundedRelation.rel",[WellFoundedRelation]]
["of_decide_eq_true",[Decidable, Eq, Bool, Decidable.decide, Bool.true, Not, absurd, ne_true_of_eq_false, decide_eq_false]]
["Nat.instTransLeArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1",[Nat, Nat.lt_of_le_of_lt]]
["RandomGen.split",[RandomGen]]
["termDepIfThenElse",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
["Lean.explicitBinders",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.bracketedExplicitBinders, Lean.unbracketedExplicitBinders]]
["IO.mkRef",[ST.mkRef, IO.RealWorld, IO, instMonadLiftT, ST, IO.instMonadLiftSTRealWorldEIO, IO.Error, instMonadLiftT_1]]
["instAddUInt64",[Add.mk, UInt64, UInt64.add]]
["Lean.reservedMacroScope",[OfNat.ofNat, Nat, instOfNatNat]]
["ByteArray.instInhabitedByteArray",[Inhabited.mk, ByteArray, ByteArray.empty]]
["ByteArray.toUInt64LE!",[ByteArray, ite, UInt64, Eq, Bool, BEq.beq, Nat, instBEq, instDecidableEqNat, ByteArray.size, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, HOr.hOr, instHOr, instOrOpUInt64, HShiftLeft.hShiftLeft, instHShiftLeft, instShiftLeftUInt64, UInt8.toUInt64, ByteArray.get!, instOfNatUInt64, panicWithPosWithDecl, instInhabitedUInt64, HAppend.hAppend, String, instHAppend, String.instAppendString]]
["instLTOption",[LT, LT.mk, Option, Option.lt, LT.lt]]
["eq_false_of_decide",[Decidable, Eq, Bool, Decidable.decide, Bool.false, propext, False, Iff.intro, absurd, of_decide_eq_false, False.elim]]
["Fin.instHModFinNatFin",[Nat, HMod.mk, Fin, Fin.modn]]
["Std.Format.paren",[Std.Format, Std.Format.bracket]]
["instDecidableOr",[Decidable, Or, Decidable.isTrue, Or.inl, Not, Or.inr, Decidable.isFalse, instDecidableOr.proof_1]]
["Lean.Parser.Tactic.subst",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
["IO.sleep",[UInt32, IO.RealWorld, dbgSleep, EStateM.Result, IO.Error, Unit, EStateM.Result.ok, Unit.unit]]
["absurd",[Not, False.elim]]
["Nat.pow",[Nat, Nat.below, Unit, OfNat.ofNat, instOfNatNat, Nat.succ, Nat.mul, PProd.fst, PUnit, PProd]]
["IO.Process.StdioConfig.mk.inj",[IO.Process.Stdio, Eq, IO.Process.StdioConfig, IO.Process.StdioConfig.mk, And, And.intro]]
["List.foldr",[List, List.below, Unit, List.nil, List.cons, PProd.fst, PUnit, PProd]]
["«stx_,*,?»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
["String.takeRight",[String, Nat, Substring.toString, Substring.takeRight, String.toSubstring]]
["List.bind",[List, List.join, List.map]]
["ST.Ref.get",[MonadLiftT, ST, ST.Ref, liftM, ST.Prim.Ref.get]]
["UInt32.mul",[UInt32, UInt32.mk, HMul.hMul, Fin, UInt32.size, instHMul, Fin.instMulFin, UInt32.val]]
["instDecidableLe_3",[UInt64, UInt64.decLe]]
["ByteArray.push",[ByteArray, UInt8, Array, ByteArray.mk, Array.push]]
["LawfulMonad.pure_bind",[Monad, LawfulMonad]]
["CoeHTCT.noConfusionType",[CoeHTCT, Eq]]
["Lean.Macro.getMethodsImp",[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, MonadReader.read, instMonadReader, instMonadReaderOfReaderT, Pure.pure, Applicative.toPure, Monad.toApplicative, unsafeCast, PointedType.type, Lean.Macro.Context.methods]]
["compareOfLessAndEq",[LT, Decidable, LT.lt, DecidableEq, ite, Ordering, Ordering.lt, Eq, Ordering.eq, Ordering.gt]]
["ExceptCpsT.run",[Monad, ExceptCpsT, Except, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.ok, Except.error]]
["List.toByteArray.loop",[List, UInt8, ByteArray, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd, ByteArray.push]]
["UInt16.decLe",[UInt16, Decidable, LE.le, instLEUInt16, Fin, UInt16.size, inferInstanceAs, instLEFin, Fin.decLe]]
["ReaderT.map",[Monad, ReaderT, Functor.map, Applicative.toFunctor, Monad.toApplicative]]
["instSubsingletonForall.proof_1",[Subsingleton, Subsingleton.intro, funext, Subsingleton.elim]]
["FloatArray.mk.sizeOf_spec",[Array, Float, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, List, FloatSpec.float, floatSpec, instSizeOf]]
["Lean.Name.beq",[Lean.Name, Bool, Lean.Name.below, Unit, Lean.Name.anonymous, Bool.true, String, UInt64, Lean.Name.str, and, BEq.beq, instBEq, instDecidableEqString, PProd.fst, PUnit, PProd, Nat, Lean.Name.num, instDecidableEqNat, Bool.false]]
["Prod.lexAccessible",[Prod.lexAccessible.proof_1]]
["instHashableList",[Hashable, Hashable.mk, List, List.foldl, UInt64, mixHash, Hashable.hash, OfNat.ofNat, instOfNatUInt64]]
["Array.foldlM.loop.proof_1",[Array, Nat, LE.le, instLENat, Array.size, LT.lt, instLTNat, Nat.lt_of_lt_of_le]]
["instReprSubstring",[Repr.mk, Substring, Nat, Std.Format.text, HAppend.hAppend, String, instHAppend, String.instAppendString, String.quote, Substring.toString]]
["Lean.Meta.Simp.ConfigCtx.mk.injEq",[Lean.Meta.Simp.Config, Eq.propIntro, Eq, Lean.Meta.Simp.ConfigCtx, Lean.Meta.Simp.ConfigCtx.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["IO.Process.Child.noConfusionType",[IO.Process.StdioConfig, IO.Process.Child, IO.Process.Stdio.toHandleType, IO.Process.StdioConfig.stdin, IO.Process.StdioConfig.stdout, IO.Process.StdioConfig.stderr, Eq]]
["Lean.instHashableName",[Hashable.mk, Lean.Name, Lean.Name.hash]]
["DoResultPRBC.continue.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["String.Iterator.nextn",[String.Iterator, Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, String.Iterator.next]]
["Lean.Module.header",[Lean.Module]]
["Subtype.instDecidableEqSubtype.proof_2",[Not, Eq, Subtype, Subtype.mk, False, absurd]]
["PSigma.lexNdepWf",[PSigma.lexNdepWf.proof_1]]
["String.mk.sizeOf_spec",[List, Char, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["Substring.stopPos",[Substring]]
["String.length",[String, Nat, List, Char, List.length]]
["Lean.Meta.Simp.defaultMaxSteps",[OfNat.ofNat, Nat, instOfNatNat]]
["MonadExcept.instOrElse",[MonadExcept, OrElse.mk, MonadExcept.orElse]]
["Lean.Meta.Simp.Config.proj",[Lean.Meta.Simp.Config]]
["Lean.Parser.Tactic.location",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.unary, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.Parser.Tactic.locationWildcard, Lean.Parser.Tactic.locationHyp]]
["OrElse.noConfusionType",[OrElse, Unit, Eq]]
["String.Iterator.remainingToString",[String.Iterator, String, String.Pos, String.extract, String.bsize]]
["Char.utf8Size.proof_1",[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
["Array.extract",[Array, Nat, Array.ofSubarray, Array.toSubarray]]
["Lean.Macro.throwUnsupported",[MonadExcept.throw, Lean.Macro.Exception, Lean.MacroM, instMonadExcept, ReaderT.instMonadExceptOfReaderT, Lean.Macro.Context, EStateM, Lean.Macro.State, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Lean.Macro.Exception.unsupportedSyntax]]
["List.forM_cons",[Monad, PUnit, List, rfl, ForM.forM, List.instForMList, List.cons]]
["Lean.instInhabitedSyntax",[Inhabited.mk, Lean.Syntax, Lean.Syntax.missing]]
["List.instAppendList",[Append.mk, List, List.append]]
["funext",[Eq]]
["Lean.Meta.Simp.ConfigCtx.mk.sizeOf_spec",[Lean.Meta.Simp.Config, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Bool, instSizeOfNat]]
["tacticCalc_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, calcStep]]
["Array.mapSepElems",[Array, Lean.Syntax, Id.run, Array.mapSepElemsM, Id, Id.instMonadId]]
["Nat.succ_le_succ",[Nat, LE.le, instLENat, Nat.succ, Nat.below, Unit, Nat.le.refl, Nat.le, Nat.le.step, PProd.fst, PUnit, PProd]]
["cast_eq",[Eq, rfl, cast]]
["Nat.not_le_of_gt",[Nat, GT.gt, instLTNat, LE.le, instLENat, Or, LT.lt, GE.ge, Nat.lt_or_ge, False, absurd, Nat.lt_trans, Nat.lt_irrefl]]
["instInhabitedOrdering",[Inhabited.mk, Ordering, Ordering.lt]]
["dbgTraceIfShared",[String]]
["Option.instOrElseOption",[OrElse.mk, Option, Option.orElse]]
["StateCpsT.runK_get",[rfl, StateCpsT.runK, MonadState.get, StateCpsT, instMonadState, StateCpsT.instMonadStateOfStateCpsT]]
["Nat.le_refl",[Nat, Nat.le.refl]]
["instDecidableLt_4",[USize, USize.decLt]]
["Nat.zero_add",[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Nat.below, Unit, rfl, Nat.succ, congrArg, Nat.add, PProd.fst, PUnit, PProd]]
["ExceptT.run_bind",[ExceptT, Monad, rfl, Except, ExceptT.run, Bind.bind, Monad.toBind, ExceptT.instMonadExceptT]]
["Lean.Macro.Methods.expandMacro?",[Lean.Macro.Methods]]
["coeOfHTCT",[CoeHTCT, CoeT.mk, CoeHTCT.coe]]
["Subsingleton.allEq",[Subsingleton]]
["Lean.Syntax.isOfKind",[Lean.Syntax, Lean.SyntaxNodeKind, BEq.beq, Lean.Name.instBEqName, Lean.Syntax.getKind]]
["Lean.MacroScopesView.scopes",[Lean.MacroScopesView]]
["instInhabitedProd",[Inhabited, Inhabited.mk, Prod, Prod.mk, arbitrary]]
["Nat.beq",[Nat, Bool, Nat.below, Unit, Nat.zero, Bool.true, Bool.false, Nat.succ, PProd.fst, PUnit, PProd]]
["IO.Error.mkInterrupted",[IO.Error.interrupted]]
["PProd.mk.inj",[Eq, PProd, PProd.mk, And, And.intro]]
["Nat.eq_of_beq_eq_true",[Nat, Eq, Bool, Nat.beq, Bool.true, Nat.below, Nat.zero, rfl, Nat.succ]]
["Nat.ctor_eq_zero",[rfl, Nat, Nat.zero]]
["Std.Format.indentD",[Std.Format, Std.Format.nestD, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.line]]
["«term_<$>_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Nat.pred",[Nat, Unit, OfNat.ofNat, instOfNatNat]]
["CoeDep.coe",[CoeDep]]
["Lean.ParserDescr.below",[Lean.ParserDescr, Lean.Name, PUnit, PProd, Lean.SyntaxNodeKind, Nat, String, Bool, optParam, Bool.false]]
["STWorld.noConfusionType",[outParam, STWorld]]
["Lean.version.isRelease",[Lean.version.getIsRelease, Unit.unit]]
["PSum.inr.inj",[Eq, PSum, PSum.inr]]
["PUnit.subsingleton",[PUnit, Eq, PUnit.unit, rfl, Eq.symm, Eq.refl]]
["Quotient.hrecOn",[Setoid, Quotient, Quotient.mk, HasEquiv.Equiv, instHasEquiv, HEq, Quot.hrecOn, Setoid.r]]
["instToStringFloat",[ToString.mk, Float, Float.toString]]
["FloatSpec.decLt",[FloatSpec]]
["Nat.le_trans",[Nat, LE.le, instLENat, Nat.below, Nat.le, Nat.le.step, PProd.fst, PUnit, PProd]]
["instBEqProd",[BEq, BEq.mk, Prod, Bool, and, BEq.beq]]
["Subarray.mk.injEq",[Array, Nat, LE.le, instLENat, Array.size, Eq.propIntro, Eq, Subarray, Subarray.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["IO.FS.Metadata.type",[IO.FS.Metadata]]
["IO.Error.noFileOrDirectory.injEq",[String, UInt32, Eq.propIntro, Eq, IO.Error, IO.Error.noFileOrDirectory, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["FloatArray.push",[FloatArray, Float, Array, FloatArray.mk, Array.push]]
["ExceptCpsT.runCatch_pure",[Monad, rfl, ExceptCpsT.runCatch, Pure.pure, ExceptCpsT, Applicative.toPure, Monad.toApplicative, ExceptCpsT.instMonadExceptCpsT]]
["Sub.noConfusionType",[Sub, Eq]]
["instToFormatOption",[Std.ToFormat, Std.ToFormat.mk, Option, Option.format]]
["instHashableFin",[Nat, Hashable.mk, Fin, Nat.toUInt64, Fin.val]]
["UInt32.isValidChar",[UInt32, Nat.isValidChar, UInt32.toNat]]
["precMin1",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["Array.instInhabitedArray",[Inhabited.mk, Array, Array.empty]]
["instHOr",[OrOp, HOr.mk, OrOp.or]]
["IO.FS.Metadata.mk.inj",[IO.FS.SystemTime, UInt64, IO.FS.FileType, Eq, IO.FS.Metadata, IO.FS.Metadata.mk, And, And.intro]]
["Nat.lt.step",[Nat.lt.step.proof_1]]
["OptionT.run",[OptionT]]
["Prod.RProdSubLex",[Prod.RProdSubLex.proof_1]]
["instDecidableEqProd.proof_3",[Not, Eq, Prod, Prod.mk, False, absurd]]
["dbgTrace",[String, Unit, Unit.unit]]
["StdGen.mk.sizeOf_spec",[Nat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat]]
["List.getLast?",[List, Option, Unit, Option.none, Option.some, List.getLast, List.cons, List.getLast?.proof_1]]
["ST.Ref.h",[ST.Ref]]
["Append.append",[Append]]
["IO.FS.DirEntry.path",[IO.FS.DirEntry, HDiv.hDiv, System.FilePath, instHDiv, System.FilePath.instDivFilePath, IO.FS.DirEntry.root, System.FilePath.mk, IO.FS.DirEntry.fileName]]
["Nat.lt_of_lt_of_le",[Nat, Nat.le_trans, Nat.succ]]
["FloatArray.set",[FloatArray, Float, Array, Fin, FloatArray.size, FloatArray.mk, Array.set]]
["List.cons.inj",[List, Eq, List.cons, And, And.intro]]
["Array.getSepElems",[Array.getEvenElems]]
["unsafeIO",[IO, unsafeEIO, IO.Error]]
["Nat.anyM.loop",[Monad, Nat, Bool, Nat.below, Unit, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.false, Nat.succ, Bind.bind, Monad.toBind, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, Bool.true, PProd.fst, PUnit, PProd]]
["Lean.Meta.Simp.Config.contextual",[Lean.Meta.Simp.Config]]
["Lean.Parser.Tactic.rwWithRfl",[Lean.SyntaxNodeKind, String, Lean.Syntax, Lean.Syntax.getOp, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.setArg, Lean.mkAtom, Lean.Syntax.setKind, Lean.mkAtomFrom, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.Macro.instMonadRefMacroM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Macro.instMonadQuotationMacroM, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Syntax.atom, Option.getD, Lean.Syntax.getHeadInfo?, List.nil]]
["Fin.add.proof_1",[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt]]
["instHShiftLeft",[ShiftLeft, HShiftLeft.mk, ShiftLeft.shiftLeft]]
["IO.instMonadLiftSTRealWorldEIO",[MonadLift.mk, ST, IO.RealWorld, EIO, EStateM.Result, Empty, EStateM.Result.ok]]
["UInt32.lor",[UInt32, UInt32.mk, Fin.lor, UInt32.size, UInt32.val]]
["Array.forIn",[Monad, Array, ForInStep, Nat, LE.le, instLENat, Array.size, Nat.le_refl, Array.forIn.loop]]
["Array.«term__[:_]»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["IO.FS.Stream.mk.sizeOf_spec",[IO, Bool, Unit, USize, ByteArray, String, Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["and",[Bool, Unit, Bool.false]]
["Lean.Macro.throwErrorAt",[Lean.Syntax, String, Lean.withRef, Lean.MacroM, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.instMonadRefMacroM, Lean.Macro.throwError]]
["PLift.down",[PLift]]
["toBoolUsing_eq_true",[Decidable, decide_eq_true]]
["List.format",[Std.ToFormat, List, Std.Format, Unit, Std.Format.text, Std.Format.sbracket, Std.Format.joinSep, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.line]]
["MonadControlT.liftWith",[MonadControlT]]
["ForM.noConfusionType",[outParam, ForM, Monad, PUnit, Eq]]
["fixCore5",[bfix5, USize.size]]
["IO",[EIO, IO.Error]]
["Nat.foldRev",[Nat, Nat.foldRev.loop]]
["Subarray.h₁",[Subarray]]
["instSTWorldEST",[outParam, STWorld.mk, EST]]
["instMonadWithReader",[MonadWithReaderOf, MonadWithReader.mk, withTheReader]]
["IO.FS.SystemTime.noConfusionType",[IO.FS.SystemTime, Int, UInt32, Eq]]
["String.modify",[String, String.Pos, Char, String.set, String.get]]
["unexpandEqNDRec",[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
["IO.AccessRight.mk.inj",[Bool, Eq, IO.AccessRight, IO.AccessRight.mk, And, And.intro]]
["coeTail",[CoeTail, CoeTail.coe]]
["Quot.indepCoherent",[Quot, Quot.mk, Eq, Quot.sound, PSigma.eta]]
["InvImage",[]]
["Fin.modn",[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, Fin.modn.proof_1]]
["Lean.isNumericSubscript",[Char, and, Decidable.decide, LE.le, UInt32, instLEUInt32, OfNat.ofNat, instOfNatUInt32, Char.val, instDecidableLe]]
["Classical.exists_true_of_nonempty",[Nonempty, Exists, True, Exists.intro, trivial]]
["instReprIterator",[Repr.mk, String.Iterator, Nat, Std.Format, String, String.Pos, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, reprArg, instReprString, instReprNat]]
["System.FilePath.isAbsolute",[System.FilePath, or, List.contains, Char, instBEq, instDecidableEqChar, System.FilePath.pathSeparators, String.front, System.FilePath.toString, and, System.Platform.isWindows, Decidable.decide, GE.ge, Nat, instLENat, String.bsize, OfNat.ofNat, instOfNatNat, Nat.decLe, BEq.beq, String.getOp, String.Pos, Char.ofNat]]
["Array.split",[Array, Bool, Array.foldl, Prod, ite, Eq, Bool.true, instDecidableEqBool, Prod.mk, Array.push, List.toArray, List.nil, OfNat.ofNat, Nat, instOfNatNat, Array.size]]
["StateT.run_seqRight",[Monad, LawfulMonad, StateT]]
["Id.instOfNatId",[Nat, OfNat, inferInstanceAs]]
["Prod.fst",[Prod]]
["HAnd.noConfusionType",[outParam, HAnd, Eq]]
["Classical.inhabited_of_exists",[Exists, Classical.inhabited_of_nonempty, Classical.inhabited_of_exists.proof_1]]
["EStateM.Backtrackable.save",[EStateM.Backtrackable]]
["List.pure",[List.cons, List.nil]]
["String.toFormat",[String, Std.Format.joinSep, Std.instToFormatString, String.splitOn, Std.Format.line]]
["instDecidableArrow.proof_2",[Not, absurd, False]]
["AndThen.andThen",[AndThen]]
["Lean.Quote.noConfusionType",[Lean.Quote, Lean.Syntax, Eq]]
["IO.Error.inappropriateType.injEq",[Option, String, UInt32, Eq.propIntro, Eq, IO.Error, IO.Error.inappropriateType, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["IO.FS.Metadata.mk.sizeOf_spec",[IO.FS.SystemTime, UInt64, IO.FS.FileType, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Int, UInt32, instSizeOfNat, Fin, UInt32.size, LT.lt, instLTNat, instSizeOf, UInt64.size]]
["instDecidableEqQuotient.proof_1",[Setoid, instSubsingletonDecidable, Eq, Quotient, Quotient.mk]]
["Option.some.injEq",[Eq.propIntro, Eq, Option, Option.some, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["or_true",[propext, Or, True, Iff.intro, trivial, Or.inr]]
["ExceptT.tryCatch",[Monad, ExceptT, ExceptT.mk, Bind.bind, Monad.toBind, Except, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.ok]]
["instDecidableFalse",[Decidable.isFalse, False, not_false]]
["LawfulFunctor.map_const",[Functor, LawfulFunctor]]
["Classical.epsilon_spec",[Exists, Classical.epsilon_spec_aux, nonempty_of_exists]]
["Lean.Parser.Tactic.Conv.ext",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const]]
["LE.noConfusionType",[LE, Eq]]
["Decidable.byCases",[Decidable, Not]]
["Substring.takeWhile",[Substring, Char, Bool, String, String.Pos, Substring.mk]]
["Nat.repeat.loop",[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd]]
["coeOfDep",[CoeDep, CoeT.mk, coeD]]
["IO.FS.DirEntry.fileName",[IO.FS.DirEntry]]
["OptionT.orElse",[Monad, OptionT, Unit, OptionT.mk, Bind.bind, Monad.toBind, Option, Pure.pure, Applicative.toPure, Monad.toApplicative, Option.some, Unit.unit]]
["instTransEq.proof_1",[Eq, Eq.symm]]
["List.hasDecidableLt.proof_3",[LT, List, Not, LT.lt, List.instLTList, List.cons, False, absurd, List.lt]]
["UInt64.lt",[UInt64, LT.lt, Fin, UInt64.size, instLTFin, UInt64.val]]
["IO.FileRight.flags",[IO.FileRight, UInt32, UInt32.shiftLeft, IO.AccessRight.flags, IO.FileRight.user, OfNat.ofNat, instOfNatUInt32, IO.FileRight.group, IO.FileRight.other, UInt32.lor]]
["Lean.idEndEscape",[Char.ofNat]]
["Array.toArrayLit.proof_1",[Array, Nat, Eq, Array.size, LE.le, instLENat, Nat.le_refl]]
["instMonadExcept",[outParam, MonadExceptOf, MonadExcept.mk, throwThe, tryCatchThe]]
["ReaderT.instMonadFunctorReaderT",[Monad, MonadFunctor.mk, ReaderT]]
["System.FilePath.mk.inj",[String, Eq, System.FilePath, System.FilePath.mk]]
["IO.setAccessRights",[System.FilePath, IO.FileRight, IO.Prim.setAccessRights, IO.FileRight.flags]]
["instStreamList",[Stream.mk, List, Option, Prod, Unit, Option.none, Option.some, Prod.mk]]
["PSigma.lex.proof_1",[WellFounded, WellFounded.intro, PSigma, PSigma.Lex, Acc, PSigma.lexAccessible, WellFounded.apply]]
["IO.Process.Stdio.toHandleType",[IO.Process.Stdio, Unit, IO.FS.Handle]]
["instBEqOption",[BEq, BEq.mk, Option, Unit, Option.none, Option.some, Unit.unit, Bool, Bool.true, and, BEq.beq, Bool.false]]
["Array.appendCore",[Array, Nat, Array.size, OfNat.ofNat, instOfNatNat, Array.appendCore.loop]]
["instShiftRightUSize",[ShiftRight.mk, USize, USize.shiftRight]]
["IO.Error.timeExpired.sizeOf_spec",[UInt32, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf, List, Char, SizeOf, UInt32.isValidChar]]
["WellFoundedRelation.mk.inj",[WellFounded, Eq, WellFoundedRelation, WellFoundedRelation.mk]]
["termS!_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
["HDiv.noConfusionType",[outParam, HDiv, Eq]]
["Applicative.noConfusionType",[Applicative, Functor, Pure, Seq, SeqLeft, SeqRight, Eq]]
["Subtype.instDecidableEqSubtype.proof_1",[Eq, Subtype, Subtype.mk, rfl]]
["MonadControlT.restoreM",[MonadControlT]]
["or_false",[propext, Or, False, Iff.intro, False.elim, Or.inl]]
["Except.mapError",[Except, Except.error, Except.ok]]
["Classical.indefiniteDescription.proof_1",[Exists, Nonempty, Subtype, Nonempty.intro, Subtype.mk]]
["Lean.Parser.Tactic.Conv.congr",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["Lean.Parser.Tactic.tacticInfer_instance",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["USize.val",[USize]]
["System.FilePath.pathExists",[System.FilePath, HOrElse.hOrElse, IO, Bool, instHOrElse, instOrElseEIO, IO.Error, SeqRight.seqRight, Applicative.toSeqRight, Monad.toApplicative, instMonadEIO, IO.FS.Metadata, System.FilePath.metadata, Unit, Pure.pure, Applicative.toPure, Bool.true, Bool.false]]
["instOfNatNat",[Nat, OfNat.mk]]
["Lean.Syntax.mkSep",[Array, Lean.Syntax, Lean.mkNullNode, Lean.mkSepArray]]
["«term_<=_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["or",[Bool, Unit, Bool.true]]
["IO.Error.mkPermissionDeniedFile",[Function.comp, String, Option, UInt32, IO.Error, IO.Error.permissionDenied, Option.some]]
["Lean.Syntax.isNameLit?",[Lean.Syntax, Option, String, Option.some, Option.none, Lean.Name, Lean.Syntax.isLit?, Lean.nameLitKind, Lean.Syntax.decodeNameLit]]
["Nat.eq_zero_or_pos",[Nat, Or, Eq, OfNat.ofNat, instOfNatNat, GT.gt, instLTNat, Unit, Or.inl, rfl, Or.inr, HAdd.hAdd, instHAdd, instAddNat, Nat.succ_pos]]
["instReprDecidable",[Repr.mk, Decidable, Nat, Std.Format, Repr.addAppParen, Std.Format.text, Not]]
["ULift.down",[ULift]]
["instReprSubarray",[Repr, Repr.mk, Subarray, Nat, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, repr, Array, Array.instReprArray, Subarray.toArray, Std.Format.text]]
["Std.Format.append.injEq",[Std.Format, Eq.propIntro, Eq, Std.Format.append, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["LawfulApplicative.seqRight_eq",[Applicative, LawfulApplicative]]
["IO.FileRight.other",[IO.FileRight]]
["String.Pos",[Nat]]
["TC.wf.proof_1",[WellFounded, WellFounded.intro, TC, TC.accessible, WellFounded.apply]]
["Lean.Syntax.mkCApp",[Lean.Name, Array, Lean.Syntax, Lean.Syntax.mkApp, Lean.mkCIdent]]
["Lean.Macro.State.noConfusionType",[Lean.Macro.State, Lean.MacroScope, List, Prod, Lean.Name, String, Eq]]
["Array.partition",[Bool, Array, List.toArray, List.nil, Bind.bind, Id, Monad.toBind, Id.instMonadId, MProd, Prod, ForIn.forIn, Array.instForInArray, MProd.mk, MProd.fst, MProd.snd, ite, ForInStep, Eq, Bool.true, instDecidableEqBool, Array.push, PUnit, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, ForInStep.yield, Prod.mk]]
["StateRefT'.get",[Monad, MonadLiftT, ST, ST.Ref, ST.Ref.get]]
["«term_<_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["ST.Ref.set",[MonadLiftT, ST, ST.Ref, liftM, Unit, ST.Prim.Ref.set]]
["IO.FS.Handle.readToEnd",[IO.FS.Handle, String, IO, IO.FS.Handle.readToEnd.loop]]
["List.headD",[List]]
["Lean.Parser.Tactic.Conv.delta",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["instAddUSize",[Add.mk, USize, USize.add]]
["String.drop",[String, Nat, Substring.toString, Substring.drop, String.toSubstring]]
["Lean.Meta.Simp.Config.zeta",[Lean.Meta.Simp.Config]]
["Array.foldrM",[Monad, Array, optParam, Nat, Array.size, OfNat.ofNat, instOfNatNat, LE.le, instLENat, dite, Nat.decLe, ite, LT.lt, instLTNat, Nat.decLt, Pure.pure, Applicative.toPure, Monad.toApplicative, Not, Nat.le_refl, Array.foldrM.fold]]
["Lean.Eval.eval",[Lean.Eval]]
["Char.instInhabitedChar",[Inhabited.mk, Char, Char.ofNat]]
["Lean.Macro.instInhabitedMethodsRef",[Inhabited.mk, PointedType.type, Lean.Macro.mkMethods, arbitrary, Lean.Macro.Methods, Lean.Macro.instInhabitedMethods]]
["bfix5",[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd]]
["Iff.mpr",[Iff]]
["OptionT.fail",[Monad, OptionT.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, Option, Option.none]]
["Nat.lt_of_succ_le",[Nat, LE.le, instLENat, Nat.succ]]
["Array.concatMap",[Array, Array.foldl, HAppend.hAppend, instHAppend, Array.instAppendArray, Array.empty, OfNat.ofNat, Nat, instOfNatNat, Array.size]]
["Nat.ble_succ_eq_true",[Nat, Eq, Bool, Nat.ble, Bool.true, Nat.succ, Nat.below, OfNat.ofNat, instOfNatNat, rfl, PProd.fst, PUnit, PProd]]
["FloatArray.set!",[FloatArray, Nat, Float, Array, FloatArray.mk, Array.set!]]
["IO.Process.Stdio.noConfusionType",[IO.Process.Stdio, noConfusionTypeEnum, Nat, instDecidableEqNat, IO.Process.Stdio.toCtorIdx]]
["Lean.Parser.Tactic.existsIntro",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
["Lean.Parser.Tactic.«tacticNext___=>_»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol]]
["HEq.noConfusionType",[HEq]]
["Nat.noConfusionType",[Nat, Eq]]
["instSizeOfNat",[SizeOf.mk, Nat]]
["List.hasDecEq.proof_1",[rfl, List, List.nil]]
["LawfulMonad.noConfusionType",[Monad, LawfulMonad, LawfulApplicative, Monad.toApplicative, Eq, Bind.bind, Monad.toBind, Function.comp, Pure.pure, Applicative.toPure, Functor.map, Applicative.toFunctor, Seq.seq, Applicative.toSeq, Unit]]
["instSubUInt32",[Sub.mk, UInt32, UInt32.sub]]
["Lean.Name.appendBefore",[Lean.Name, String, Lean.Name.modifyBase, Unit, Lean.Name.mkStr, Lean.Name.anonymous, UInt64, HAppend.hAppend, instHAppend, String.instAppendString, Nat, Lean.Name.mkNum]]
["List.enum",[List.enumFrom, OfNat.ofNat, Nat, instOfNatNat]]
["Std.Format.text.injEq",[String, Eq.propIntro, Eq, Std.Format, Std.Format.text, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Nat.lt_or_eq_or_le_succ",[Nat, LE.le, instLENat, Nat.succ, Decidable.byCases, Eq, Or, instDecidableEqNat, Or.inr, Ne]]
["WellFounded.noConfusionType",[WellFounded, Acc]]
["IO.mapTasks.go",[List, IO, optParam, Task.Priority, Task.Priority.default, Task, Except, IO.Error, List.below, List.cons, IO.bindTask, PProd.fst, PUnit, PProd, List.nil, IO.asTask, List.reverse]]
["«term_\/_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["«term_/\_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["instSubsingletonDecidable.proof_1",[Subsingleton.intro, Decidable, Eq, Decidable.isTrue, rfl, Not, absurd, Decidable.isFalse]]
["Lean.Parser.Tactic.«tacticHave__:=_»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Std.Format.sbracket",[Std.Format, Std.Format.bracket]]
["Nat.instShiftRightNat",[ShiftRight.mk, Nat, Nat.shiftRight]]
["Nat.toUSize",[USize.ofNat]]
["Classical.em",[Or, Eq, True, False]]
["Array.toSubarray",[Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, dite, Subarray, LE.le, instLENat, Nat.decLe, Subarray.mk, Not, Nat.le_refl, Array.toSubarray.proof_1]]
["HSub.noConfusionType",[outParam, HSub, Eq]]
["IO.FS.Stream.ofBuffer",[IO.Ref, IO.FS.Stream.Buffer, IO.FS.Stream.mk, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, Bool, ST.Ref.get, IO.RealWorld, instMonadLiftT, ST, IO.instMonadLiftSTRealWorldEIO, instMonadLiftT_1, Pure.pure, Applicative.toPure, Monad.toApplicative, Decidable.decide, GE.ge, Nat, instLENat, IO.FS.Stream.Buffer.pos, ByteArray.size, IO.FS.Stream.Buffer.data, Nat.decLe, Unit, Unit.unit, USize, ST.Ref.modifyGet, ByteArray, ByteArray.extract, HAdd.hAdd, instHAdd, instAddNat, USize.toNat, Prod.mk, IO.FS.Stream.Buffer.mk, ST.Ref.modify, ByteArray.copySlice, OfNat.ofNat, instOfNatNat, Bool.false, String, Option, ByteArray.findIdx?, UInt8, or, BEq.beq, instBEq, instDecidableEqUInt8, instOfNatUInt8, Eq, Nat.toUInt8, Char.toNat, Char.ofNat, ite, ByteArray.get!, Bool.true, instDecidableEqBool, String.fromUTF8Unchecked, String.toUTF8]]
["instOrdUInt64",[Ord.mk, UInt64, compareOfLessAndEq, instLTUInt64, instDecidableLt_3, instDecidableEqUInt64]]
["Option.noConfusionType",[Option, Eq]]
["true_ne_false",[ne_false_of_self, True, trivial]]
["Lean.Syntax.getOp",[Lean.Syntax, Nat, Lean.Syntax.getArg]]
["«termExists_,_»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
["instToStringId",[ToString, inferInstanceAs]]
["ExceptT.adapt",[Monad, ExceptT, ExceptT.mk, Functor.map, Applicative.toFunctor, Monad.toApplicative, Except, Except.mapError]]
["Classical.axiomOfChoice",[Exists, Exists.intro, Classical.choose, Classical.choose_spec]]
["Array.allM",[Monad, Bool, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Bind.bind, Monad.toBind, Array.anyM, Pure.pure, Applicative.toPure, Monad.toApplicative, not]]
["Lean.Meta.Simp.Config.mk.injEq",[Nat, Bool, Eq.propIntro, Eq, Lean.Meta.Simp.Config, Lean.Meta.Simp.Config.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["PSigma.mkSkipLeft.proof_1",[PSigma.RevLex.right, emptyRelation]]
["«stx_,*»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.symbol]]
["StdGen.s2",[StdGen]]
["PSigma.revLex",[PSigma.revLex.proof_1]]
["String.decEq.proof_1",[List, Char, Eq, congrArg, String, String.mk]]
["AndOp.and",[AndOp]]
["Quot.recOn",[Quot, Quot.mk, Eq, Quot.sound, Quot.rec]]
["instInhabitedBool",[Inhabited.mk, Bool, Bool.false]]
["instBEqFloat",[BEq.mk, Float, Float.beq]]
["instMonadEST",[inferInstanceAs, Monad, EStateM, EStateM.instMonadEStateM]]
["IO.Error.otherError.injEq",[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.otherError, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["OptionT",[Option]]
["Std.ToFormat.noConfusionType",[Std.ToFormat, Std.Format, Eq]]
["Subarray.popFront.proof_1",[Subarray, LT.lt, Nat, instLTNat, Subarray.start, Subarray.stop, Nat.le_of_lt_succ, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Nat.add_lt_add_right]]
["Classical.strongIndefiniteDescription.proof_2",[Nonempty, Not, Exists, absurd, Classical.choice]]
["Sigma.snd",[Sigma]]
["List.minimum?",[LE, DecidableRel, LE.le, List, Option, Unit, Option.none, Option.some, List.foldl, min]]
["String.nextWhile",[String, Char, Bool, String.Pos, String.bsize]]
["Eq.subst",[Eq]]
["inline",[]]
["UInt8.toUInt16",[UInt8, Nat.toUInt16, UInt8.toNat]]
["instOrOpUSize",[OrOp.mk, USize, USize.lor]]
["Array.uget",[USize, LT.lt, Nat, instLTNat, USize.toNat, Array.size, Array.get, Fin.mk]]
["Lean.Parser.Tactic.simpLemma",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.Parser.Tactic.simpPre, Lean.Parser.Tactic.simpPost, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat]]
["not",[Bool, Unit, Bool.false, Bool.true]]
["USize.ofNat32",[LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, USize.mk, Fin.mk, USize.size, USize.ofNat32.proof_1]]
["SeqLeft.noConfusionType",[SeqLeft, Unit, Eq]]
["HMod.hMod",[HMod]]
["Lean.scientificLitKind",[Lean.Name.mkStr, Lean.Name.anonymous]]
["PointedType.noConfusionType",[PointedType, Eq, HEq]]
["ne_eq",[rfl, Ne]]
["System.instToStringFilePath",[ToString.mk, System.FilePath, System.FilePath.toString]]
["Std.Range.mk.inj",[Nat, Eq, Std.Range, Std.Range.mk, And, And.intro]]
["Lean.mkIdentFromRef",[Monad, Lean.MonadRef, Lean.Name, Bind.bind, Monad.toBind, Lean.Syntax, Lean.MonadRef.getRef, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.mkIdentFrom]]
["SizeOf.noConfusionType",[SizeOf, Nat, Eq]]
["Lean.Macro.Exception.noConfusionType",[Lean.Macro.Exception, Lean.Syntax, String, Eq]]
["controlAt",[MonadControlT, Bind, MonadControlT.stM, Bind.bind, MonadControlT.liftWith, MonadControlT.restoreM]]
["Quotient.lift",[Setoid, Quot.lift, HasEquiv.Equiv, instHasEquiv]]
["eq_false",[Not, propext, False, Iff.intro, absurd, False.elim]]
["Array.toListLitAux.proof_2",[Array, Nat, Eq, Array.size, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Nat.lt_of_lt_of_eq, Nat.lt_of_lt_of_le, Nat.succ, Nat.lt_succ_self]]
["instOfNatUSize",[Nat, OfNat.mk, USize, USize.ofNat]]
["instReprAtomFloat",[ReprAtom.mk, Float]]
["WellFounded.fixF",[Acc]]
["Lean.Parser.Tactic.Conv.«conv·._»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.Parser.Tactic.Conv.convSeq]]
["UInt64.sub",[UInt64, UInt64.mk, HSub.hSub, Fin, UInt64.size, instHSub, Fin.instSubFin, UInt64.val]]
["String.endsWith",[String, BEq.beq, Substring, Substring.hasBeq, Substring.takeRight, String.toSubstring, String.length]]
["termWithout_expected_type_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Int.le",[Int, Int.NonNeg, HSub.hSub, instHSub, Int.instSubInt]]
["true_and",[propext, And, True, Iff.intro, And.right, And.intro, trivial]]
["Lean.MacroScopesView.review",[Lean.MacroScopesView, List, Lean.MacroScope, Lean.Name, Lean.MacroScopesView.scopes, Unit, Lean.MacroScopesView.name, Lean.Name.mkStr, HAppend.hAppend, instHAppend, Lean.Name.instAppendName, Lean.MacroScopesView.imported, Lean.MacroScopesView.mainModule, List.foldl, Nat, Lean.Name.mkNum]]
["Bool.true_or",[Bool, Eq, or, Bool.true, Bool.false, rfl, Eq.symm, Eq.refl]]
["PNonScalar.mk.sizeOf_spec",[Nat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat]]
["Fin.shiftLeft.proof_1",[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, HShiftLeft.hShiftLeft, instHShiftLeft, Nat.instShiftLeftNat]]
["Lean.Meta.Simp.Config.beta",[Lean.Meta.Simp.Config]]
["ByteArray.get!",[ByteArray, Nat, UInt8, Array, Array.get!, instInhabitedUInt8]]
["Lean.Meta.TransparencyMode.all.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["Lean.version.specialDesc",[Lean.version.getSpecialDesc, Unit.unit]]
["dite_false",[False, Not, rfl, dite, instDecidableFalse]]
["«term_/_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["CoeHead.noConfusionType",[CoeHead, Eq]]
["Option.map",[Option, Option.bind, Function.comp, Option.some]]
["Nat.succ_ne_zero",[Nat, Eq, Nat.succ, OfNat.ofNat, instOfNatNat, False]]
["Array.filterMapM",[Monad, Option, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Array.foldlM, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.push, Unit, List.toArray, List.nil]]
["instInhabitedUInt32",[Inhabited.mk, UInt32, UInt32.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, instInhabitedUInt32.proof_1]]
["instToStringOption",[ToString, ToString.mk, Option, String, Unit, HAppend.hAppend, instHAppend, String.instAppendString, addParenHeuristic, ToString.toString]]
["instMulNat",[Mul.mk, Nat, Nat.mul]]
["StateM",[StateT, Id]]
["«term_&&&_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["IO.Error.unsupportedOperation.inj",[UInt32, String, Eq, IO.Error, IO.Error.unsupportedOperation, And, And.intro]]
["UInt32.ofNat'",[Nat, LT.lt, instLTNat, UInt32.size, UInt32.mk, Fin.mk]]
["decidableOfDecidableOfIff.proof_1",[Iff, Not, absurd, False, Iff.mpr]]
["instMulUInt8",[Mul.mk, UInt8, UInt8.mul]]
["Lean.Name.mkSimple",[String, Lean.Name.mkStr, Lean.Name.anonymous]]
["String.Iterator.hasNext",[String.Iterator, Bool, String, String.Pos, Decidable.decide, LT.lt, instLTNat, String.utf8ByteSize, Nat.decLt]]
["String.decapitalize",[String, String.set, OfNat.ofNat, String.Pos, instOfNatNat, Char.toLower, String.get]]
["Array.findSomeRevM?",[Monad, Array, Option, Nat, LE.le, instLENat, Array.size, Nat.le_refl, Array.findSomeRevM?.find]]
["IO.Error.mkPermissionDenied",[IO.Error.permissionDenied, Option.none, String]]
["instMulFloat",[Mul.mk, Float, Float.mul]]
["Nat.ble_eq_true_of_le",[Nat, LE.le, instLENat, Eq, Bool, Nat.ble, Bool.true, Nat.below, Unit, Nat.ble_self_eq_true, Nat.le, Nat.ble_succ_eq_true, PProd.fst, PUnit, PProd]]
["coeM",[CoeT, Monad, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, coe]]
["instDecidableEqOption",[DecidableEq, Option, Unit, Option.none, Option.some, Unit.unit, Decidable, Eq, Decidable.isTrue, rfl, Decidable.isFalse, False, dite, Not]]
["Lean.instMonadQuotation",[MonadFunctor, MonadLift, Lean.MonadQuotation, Lean.MonadQuotation.mk, Lean.instMonadRef, Lean.MonadQuotation.toMonadRef, liftM, instMonadLiftT, instMonadLiftT_1, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, MonadFunctorT.monadMap, instMonadFunctorT, monadFunctorRefl, Lean.MonadQuotation.withFreshMacroScope]]
["Lean.Module.commands",[Lean.Module]]
["ExceptT.run_pure",[Monad, rfl, Except, ExceptT.run, Pure.pure, ExceptT, Applicative.toPure, Monad.toApplicative, ExceptT.instMonadExceptT]]
["List.lengthTR",[List, List.lengthTRAux, OfNat.ofNat, Nat, instOfNatNat]]
["instXorUInt32",[Xor.mk, UInt32, UInt32.xor]]
["Fin.xor.proof_1",[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt, Nat.xor]]
["Lean.Parser.Tactic.Conv.simp",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpStar, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma]]
["WellFoundedRelation.mk.injEq",[WellFounded, Eq.propIntro, Eq, WellFoundedRelation, WellFoundedRelation.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Array.findSome?",[Array, Option, Id.run, Array.findSomeM?, Id, Id.instMonadId]]
["instToStringULift",[ToString, ToString.mk, ULift, ToString.toString, ULift.down]]
["Lean.Syntax.mkApp",[Lean.Syntax, Array, Unit, Lean.Syntax.node, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.mkNullNode, List.nil]]
["Array.forM",[Monad, PUnit, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Array.foldlM, PUnit.unit]]
["Lean.Syntax.getNumArgs",[Lean.Syntax, Nat, Lean.SyntaxNodeKind, Array, Array.size, OfNat.ofNat, instOfNatNat]]
["EStateM.run",[EStateM]]
["IO.Error.unexpectedEof.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["System.Platform.isEmscripten",[System.Platform.getIsEmscripten, Unit.unit]]
["Classical.skolem",[Iff.intro, Exists, Classical.axiomOfChoice, Exists.intro]]
["instReprFin",[Nat, Repr.mk, Fin, repr, instReprNat, Fin.val]]
["Lean.Parser.Tactic.rwRule",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat]]
["List.redLength",[List, Nat, List.below, Unit, List.nil, OfNat.ofNat, instOfNatNat, List.cons, Nat.succ, PProd.fst, PUnit, PProd]]
["List.get?",[Nat, List, Option, Nat.below, Option.some, Nat.succ, PProd.fst, PUnit, PProd, Option.none]]
["Lean.Name.eraseMacroScopes",[Lean.Name, Bool, Lean.Name.hasMacroScopes, Unit, Lean.Name.below, String, UInt64, Lean.Name.str, Nat, Lean.Name.num, Lean.Name.anonymous, Unit.unit, BEq.beq, instBEq, instDecidableEqString, PProd.fst, PUnit, PProd]]
["IO.userError",[String, IO.Error.userError]]
["sizeOfWFRel",[SizeOf, measure, SizeOf.sizeOf]]
["Lean.MonadNameGenerator.setNGen",[Lean.MonadNameGenerator]]
["Subarray.mk.inj",[Array, Nat, LE.le, instLENat, Array.size, Eq, Subarray, Subarray.mk, And, And.intro]]
["Nat.mul_pos",[Nat, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat]]
["List.hasDecidableLt.proof_1",[LT, LT.lt, List, List.instLTList, List.nil, False]]
["IO.Error.instToStringError",[ToString.mk, IO.Error, IO.Error.toString]]
["instToBoolBool",[ToBool.mk, Bool]]
["ExceptCpsT.lift",[Monad, Bind.bind, Monad.toBind]]
["default.sizeOf",[OfNat.ofNat, Nat, instOfNatNat]]
["instMulUSize",[Mul.mk, USize, USize.mul]]
["System.FilePath.instDivFilePath",[Div.mk, System.FilePath, System.FilePath.join]]
["Quot.liftIndepPr1",[Quot, Quot.mk, Eq, Quot.sound, Quot.ind, PSigma.fst, Quot.lift, PSigma, Quot.indep, Quot.indepCoherent, rfl]]
["«term_^^^_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["IO.FS.Stream.Buffer.pos",[IO.FS.Stream.Buffer]]
["List.forIn.loop",[Monad, ForInStep, List, List.below, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, List.cons, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd]]
["Lean.Syntax.node.inj",[Lean.SyntaxNodeKind, Array, Lean.Syntax, Eq, Lean.Syntax.node, And, And.intro]]
["Subrelation",[]]
["IO.Error.mkUnsupportedOperation",[IO.Error.unsupportedOperation]]
["IO.FS.Metadata.noConfusionType",[IO.FS.Metadata, IO.FS.SystemTime, UInt64, IO.FS.FileType, Eq]]
["Array.set!",[Array, Array.setD]]
["Nonempty.elim",[Nonempty.elim.proof_1]]
["OptionT.instMonadFunctorOptionT",[MonadFunctor.mk, OptionT, Option]]
["DoResultBC.noConfusionType",[DoResultBC, Eq]]
["instNegFloat",[Neg.mk, Float, Float.neg]]
["Quotient",[Setoid, Quot, Setoid.r]]
["RandomGen.range",[RandomGen]]
["instInhabited",[Monad, Inhabited, Inhabited.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, arbitrary]]
["instSubsingletonForall",[instSubsingletonForall.proof_1]]
["Lean.Syntax.isScientificLit?",[Lean.Syntax, Option, String, Option.some, Option.none, Prod, Nat, Bool, Lean.Syntax.isLit?, Lean.scientificLitKind, Lean.Syntax.decodeScientificLitVal?]]
["Quotient.sound.proof_1",[Setoid, Quot.sound, HasEquiv.Equiv, instHasEquiv]]
["ExceptT.bindCont",[Monad, ExceptT, Except, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.error]]
["IO.AccessRight.read",[IO.AccessRight]]
["List.getLastD.proof_1",[List, Eq, List.cons, List.nil, False]]
["USize.modn",[USize, USize.mk, HMod.hMod, Fin, USize.size, Nat, Fin.instHModFinNatFin, USize.val]]
["seqLeft_eq_bind",[Monad, LawfulMonad, Eq.mpr, Eq, SeqLeft.seqLeft, Applicative.toSeqLeft, Monad.toApplicative, Unit, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const, Eq.refl, LawfulApplicative.seqLeft_eq, LawfulMonad.toLawfulApplicative, of_eq_true, Eq.trans, True, congrFun, congrArg, map_eq_pure_bind, seq_eq_bind_map, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, eq_self]]
["instHModUInt32NatUInt32",[HMod.mk, UInt32, Nat, UInt32.modn]]
["HAdd.hAdd",[HAdd]]
["UInt32.decLe",[UInt32, Decidable, LE.le, instLEUInt32, Fin, UInt32.size, inferInstanceAs, instLEFin, Fin.decLe]]
["unexpandPSigma",[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, cond, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
["Lean.MacroScopesView.noConfusionType",[Lean.MacroScopesView, Lean.Name, List, Lean.MacroScope, Eq]]
["Nat.succ_sub_succ",[Nat, Nat.succ_sub_succ_eq_sub]]
["UInt16.val",[UInt16]]
["IO.FS.instBEqFileType",[BEq.mk, IO.FS.FileType, BEq.beq, Nat, instBEq, instDecidableEqNat, IO.FS.FileType.toCtorIdx]]
["Subtype.eq",[Subtype, Eq, Subtype.val, rfl, Subtype.mk]]
["OptionT.instAlternativeOptionT",[Monad, Alternative.mk, OptionT, Monad.toApplicative, OptionT.instMonadOptionT, OptionT.fail, OptionT.orElse]]
["Fin.modn.proof_1",[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, Nat.zero, HMod.hMod, instHMod, Nat.instModNat, Nat.mod_lt]]
["Lean.Macro.hasDecl",[Lean.Name, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, Bool, Lean.Macro.getMethods, Lean.Macro.Methods.hasDecl]]
["Array.feraseIdx",[Array, Fin, Array.size, Array.eraseIdxAux, HAdd.hAdd, Nat, instHAdd, instAddNat, Fin.val, OfNat.ofNat, instOfNatNat]]
["ReaderT.orElse",[Alternative, ReaderT, Unit, HOrElse.hOrElse, instHOrElse, instOrElse, Unit.unit]]
["fixCore4",[bfix4, USize.size]]
["List.hasDecEq.proof_6",[List, Not, Eq, List.cons, False, absurd]]
["Nat.pow_le_pow_of_le_left",[Nat, LE.le, instLENat, HPow.hPow, instHPow, instPowNatNat, Nat.below, Unit, Nat.le_refl, OfNat.ofNat, instOfNatNat, Nat.succ, Nat.mul_le_mul, Nat.pow, PProd.fst, PUnit, PProd]]
["Nat.ne_of_beq_eq_false",[Nat, Eq, Bool, Nat.beq, Bool.false, False, Nat.below, Nat.zero, Nat.succ]]
["MonadFunctor.noConfusionType",[MonadFunctor, Eq]]
["fix3",[Inhabited, fixCore3, arbitrary]]
["Nat.gcd_self",[Nat, Eq, Nat.gcd, Nat.zero, of_eq_true, Eq.trans, OfNat.ofNat, instOfNatNat, True, congr, congrArg, Nat.zero_eq, Nat.gcd_zero_right, eq_true_of_decide, instDecidableEqNat, Eq.refl, Bool, Bool.true, Eq.symm, Nat.succ, congrFun, HMod.hMod, instHMod, Nat.instModNat, Nat.gcd_succ, Nat.mod_self, Nat.gcd_zero_left, eq_self]]
["Lean.Name.appendIndexAfter",[Lean.Name, Nat, Lean.Name.modifyBase, String, UInt64, Lean.Name.mkStr, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString, instToStringNat]]
["String.Iterator.toEnd",[String.Iterator, String, String.Pos, String.Iterator.mk, String.bsize]]
["coeB",[Coe, Coe.coe]]
["Nat.gcd_zero_left",[Nat, rfl, Nat.gcd, OfNat.ofNat, instOfNatNat]]
["Ord.compare",[Ord]]
["ST.Ref.mk.inj",[PointedType.type, ST.RefPointed, Nonempty, Eq, ST.Ref, ST.Ref.mk]]
["ST.Ref.noConfusionType",[ST.Ref, PointedType.type, ST.RefPointed, Nonempty, Eq]]
["ReaderT.run_seqLeft",[Monad, LawfulMonad, ReaderT, Eq.mpr, Eq, ReaderT.run, SeqLeft.seqLeft, Applicative.toSeqLeft, Monad.toApplicative, ReaderT.instMonadReaderT, Unit, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Eq.refl, seqLeft_eq_bind, rfl]]
["Nat.lt_irrefl",[Nat, Nat.not_succ_le_self]]
["List.filterAuxM",[Monad, Bool, List, List.below, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, List.cons, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd, cond]]
["System.FilePath.isCaseInsensitive",[or, System.Platform.isWindows, System.Platform.isOSX]]
["FloatArray.get!",[FloatArray, Nat, Float, Array, Array.get!, instInhabitedFloat]]
["Nat.add_mul",[Nat, Nat.right_distrib]]
["Lean.Syntax.atom.inj",[Lean.SourceInfo, String, Eq, Lean.Syntax, Lean.Syntax.atom, And, And.intro]]
["Bool.true_and",[Bool, Eq, and, Bool.true, Bool.false, rfl, Eq.symm, Eq.refl]]
["TC.accessible.proof_1",[Acc, TC, Acc.intro, Acc.inv]]
["withPtrAddr",[USize, Eq, OfNat.ofNat, instOfNatUSize]]
["Std.Range.«term[_:_]»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["IO.Error.mkUnsatisfiedConstraints",[IO.Error.unsatisfiedConstraints]]
["Lean.Parser.Tactic.Conv.convErw_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.rwRuleSeq]]
["UInt8.toUInt64",[UInt8, Nat.toUInt64, UInt8.toNat]]
["List.head!",[Inhabited, List, Unit, panicWithPosWithDecl, OfNat.ofNat, Nat, instOfNatNat]]
["coeFun",[CoeFun, CoeFun.coe]]
["Array.toListLitAux",[Array, Nat, Eq, Array.size, LE.le, instLENat, List, Nat.below, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Nat.succ, PProd.fst, PUnit, PProd, Array.toListLitAux.proof_1, List.cons, Array.getLit, Array.toListLitAux.proof_2]]
["List.isEmpty",[List, Bool, Unit, Bool.true, Bool.false]]
["List.forA",[Applicative, List, PUnit, List.below, Unit, List.nil, Pure.pure, Applicative.toPure, PUnit.unit, List.cons, SeqRight.seqRight, Applicative.toSeqRight, PProd.fst, PProd]]
["IO.Error.hardwareFault.injEq",[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.hardwareFault, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["USize.mod",[USize, USize.mk, HMod.hMod, Fin, USize.size, instHMod, Fin.instModFin, USize.val]]
["instAppendSubarray",[Append.mk, Subarray, Array, HAppend.hAppend, instHAppend, Array.instAppendArray, Subarray.toArray, Array.toSubarray, OfNat.ofNat, optParam, Nat, instOfNatNat, Array.size]]
["Array.filter",[Bool, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Array.foldl, ite, Eq, Bool.true, instDecidableEqBool, Array.push, List.toArray, List.nil]]
["DoResultSBC.continue.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["Except.ok.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["IO.Process.Output.mk.inj",[UInt32, String, Eq, IO.Process.Output, IO.Process.Output.mk, And, And.intro]]
["Array.push",[Array, Array.mk, List.concat, Array.data]]
["String.toInt?",[String, OptionM.run, Int, ite, OptionM, Eq, Char, String.get, OfNat.ofNat, String.Pos, instOfNatNat, Char.ofNat, instDecidableEqChar, Bind.bind, Monad.toBind, OptionT.instMonadOptionT, Id, Id.instMonadId, Nat, Substring.toNat?, Substring.drop, String.toSubstring, Pure.pure, Applicative.toPure, Alternative.toApplicative, OptionT.instAlternativeOptionT, Neg.neg, Int.instNegInt, Int.ofNat, Functor.map, Applicative.toFunctor, String.toNat?]]
["MonadExceptOf.throw",[MonadExceptOf]]
["Classical.epsilon_spec_aux",[Nonempty, Subtype.property, Exists, Classical.strongIndefiniteDescription]]
["liftM",[MonadLiftT.monadLift]]
["Nat.mod.proof_1",[WellFoundedRelation.wf, Nat, measure, id]]
["Nat.left_distrib",[Nat, Eq, HMul.hMul, instHMul, instMulNat, HAdd.hAdd, instHAdd, instAddNat, Eq.mpr, Nat.zero, OfNat.ofNat, instOfNatNat, Eq.refl, Nat.zero_mul, rfl, Nat.succ, congr, congrArg, Eq.trans, Nat.succ_mul, congrFun, Nat.add_assoc, Nat.add_left_comm]]
["Nat.zero_eq",[rfl, Nat, Nat.zero]]
["Lean.instQuoteProd",[Lean.Quote, Lean.Quote.mk, Prod, Lean.Syntax, Lean.Syntax.mkCApp, Lean.Name.mkStr, Lean.Name.anonymous, List.toArray, List.cons, Lean.Quote.quote, List.nil]]
["List.groupByAux",[Bool, List, List.below, List.cons, Unit, PProd.fst, PUnit, PProd, List.nil, List.reverse]]
["Lean.MacroScopesView.name",[Lean.MacroScopesView]]
["List.cons.sizeOf_spec",[SizeOf, List, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk]]
["Float.lt",[Float, FloatSpec.float, floatSpec, FloatSpec.lt]]
["runEST",[EST, EStateM.Result, Unit, Except, Unit.unit, Except.ok, Except.error]]
["instHPow",[Pow, HPow.mk, Pow.pow]]
["List.getLast!",[Inhabited, List, Unit, panicWithPosWithDecl, OfNat.ofNat, Nat, instOfNatNat, List.getLast, List.cons, List.getLast!.proof_1]]
["Nat.mul_one",[Nat.zero_add]]
["CoeT.coe",[CoeT]]
["String.Iterator.hasPrev",[String.Iterator, Bool, String, String.Pos, Decidable.decide, GT.gt, instLTNat, OfNat.ofNat, instOfNatNat, Nat.decLt]]
["EStateM.instInhabitedEStateM",[Inhabited, Inhabited.mk, EStateM, EStateM.Result.error, arbitrary]]
["Decidable.not_and_iff_or_not",[Decidable, Iff.intro, Not, And, Or, absurd, And.intro, Or.inr, Or.inl, False]]
["«term_==_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Array.getMax?",[Array, Bool, dite, Option, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, Array.size, Nat.decLt, Array.get, Fin.mk, Option.some, Array.foldl, ite, Eq, Bool.true, instDecidableEqBool, optParam, Not, Option.none]]
["List.elem",[BEq, List, Bool, List.below, Unit, List.nil, Bool.false, List.cons, BEq.beq, Bool.true, PProd.fst, PUnit, PProd]]
["String.dropRight",[String, Nat, Substring.toString, Substring.dropRight, String.toSubstring]]
["IO.AccessRight.noConfusionType",[IO.AccessRight, Bool, Eq]]
["List.reverseAux",[List, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd]]
["IO.Error.noConfusionType",[IO.Error, Option, String, UInt32, Eq]]
["System.FilePath.fileName",[System.FilePath, String, Option, String.Pos, String.revFind, System.FilePath.toString, List.contains, Char, instBEq, instDecidableEqChar, System.FilePath.pathSeparators, String.extract, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, String.bsize, Unit, ite, Eq, Bool, or, String.isEmpty, BEq.beq, instDecidableEqString, Bool.true, instDecidableEqBool, Option.none, Option.some]]
["ToStream.toStream",[ToStream]]
["unexpandSigma",[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, cond, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
["instToStreamListList",[ToStream.mk, List]]
["let_val_congr",[Eq, rfl]]
["Lean.SyntaxNodeKind",[Lean.Name]]
["ExceptCpsT.run_throw",[Monad, rfl, Except, ExceptCpsT.run, MonadExcept.throw, ExceptCpsT, instMonadExcept, ExceptCpsT.instMonadExceptOfExceptCpsT]]
["Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp",[Trans.mk, Nat, LT.lt, instLTNat, Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1]]
["Char.utf8Size.proof_5",[of_decide_eq_true, LT.lt, Nat, instLTNat, OfNat.ofNat, instOfNatNat, UInt32.size, Nat.decLt, Eq.refl, Bool, Bool.true]]
["Lean.Parser.Tactic.Conv.whnf",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["«term{__:_//_}»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
["instSubsingleton",[instSubsingleton.proof_1]]
["UInt32.div",[UInt32, UInt32.mk, HDiv.hDiv, Fin, UInt32.size, instHDiv, Fin.instDivFin, UInt32.val]]
["Setoid.trans",[Setoid, HasEquiv.Equiv, instHasEquiv, Equivalence.trans, Setoid.r, Setoid.iseqv]]
["Nat.add_left_cancel",[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Eq.mpr, Nat.zero, implies_congr, congr, congrArg, Eq.trans, OfNat.ofNat, instOfNatNat, congrFun, Nat.zero_eq, Nat.zero_add, Eq.refl, Nat.succ, Nat.succ_add, Nat.succ.injEq]]
["implies_true",[propext, True, Iff.intro, trivial, True.intro]]
["instMonadStateOf",[MonadLift, MonadStateOf, MonadStateOf.mk, liftM, instMonadLiftT, instMonadLiftT_1, MonadStateOf.get, PUnit, MonadStateOf.set, Prod, MonadLiftT.monadLift, MonadState.modifyGet, instMonadState]]
["instHashable",[Hashable.mk, OfNat.ofNat, UInt64, instOfNatUInt64]]
["HSub.hSub",[HSub]]
["prioDefault",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["List.lookup",[BEq, List, Prod, Option, List.below, List.nil, Option.none, List.cons, Prod.mk, Bool, BEq.beq, Unit, Option.some, PProd.fst, PUnit, PProd]]
["UInt32.toUInt16",[UInt32, Nat.toUInt16, UInt32.toNat]]
["Trans.trans",[Trans]]
["Lean.mkCIdent",[Lean.Name, Lean.mkCIdentFrom, Lean.Syntax.missing]]
["Lean.instInhabitedNameGenerator",[Inhabited.mk, Lean.NameGenerator, Lean.NameGenerator.mk, arbitrary, Lean.Name, Lean.instInhabitedName, Nat, instInhabitedNat]]
["List.length_set",[List, Nat, Eq, List.length, List.set, rfl, List.nil, List.cons, Nat.zero, Eq.symm, Nat.succ, of_eq_true, Eq.trans, True, congr, congrArg, List.length_cons, eq_self, Eq.refl]]
["StateT.run_modify",[Monad, rfl, Prod, PUnit, StateT.run, modify, StateT, instMonadState, instMonadStateOfStateT]]
["StateCpsT.run'_eq",[Monad, StateCpsT, rfl, StateCpsT.run']]
["Except.map_id",[funext, Except, Except.map, id, Eq.mpr, Eq, Except.error, Except.ok, congr, congrArg, id_eq, rfl, Eq.symm, Eq.refl]]
["and_true",[propext, And, True, Iff.intro, And.left, And.intro, trivial]]
["Fin.land",[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, Nat.land, Fin.land.proof_1]]
["ExceptCpsT.runK",[ExceptCpsT]]
["MonadWithReaderOf.withReader",[MonadWithReaderOf]]
["USize.ofNatCore",[LT.lt, Nat, instLTNat, USize.size, USize.mk, Fin.mk]]
["Lean.NameGenerator.namePrefix",[Lean.NameGenerator]]
["Array.foldr",[Array, optParam, Nat, Array.size, OfNat.ofNat, instOfNatNat, Id.run, Array.foldrM, Id, Id.instMonadId]]
["String.instDecidableEqIterator",[String.Iterator, String, String.Pos, String.Iterator.mk, Decidable, Eq, dite, instDecidableEqString, instDecidableEqNat, Decidable.isTrue, rfl, Not, Decidable.isFalse, False]]
["instToFormatList",[Std.ToFormat, Std.ToFormat.mk, List, List.format]]
["Lean.Syntax.decodeStrLit",[String, Lean.Syntax.decodeStrLitAux, OfNat.ofNat, String.Pos, instOfNatNat]]
["«term∃_,_»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.explicitBinders, Lean.ParserDescr.cat]]
["Quotient.lift₂.proof_2",[Setoid, HasEquiv.Equiv, instHasEquiv, Eq, Quotient, Quotient.ind, Quotient.lift, Setoid.refl]]
["HXor.hXor",[HXor]]
["Array.isEmpty",[Array, Decidable.decide, Eq, Nat, Array.size, OfNat.ofNat, instOfNatNat, instDecidableEqNat]]
["UInt32.toUSize",[UInt32, Nat.toUSize, UInt32.toNat]]
["instCoeStringError",[Coe.mk, String, IO.Error, IO.userError]]
["IO.FS.instInhabitedSystemTime",[Inhabited.mk, IO.FS.SystemTime, IO.FS.SystemTime.mk, arbitrary, Int, Int.instInhabitedInt, UInt32, instInhabitedUInt32]]
["ReprAtom.noConfusionType",[ReprAtom]]
["Eq.trans",[Eq]]
["List.asString",[List, Char, String.mk]]
["Array.find?",[Array, Bool, Id.run, Option, Array.findM?, Id, Id.instMonadId]]
["Array.contains",[BEq, Array, Array.any, BEq.beq, OfNat.ofNat, Nat, instOfNatNat, Array.size]]
["proofIrrel",[rfl]]
["instDecidableIff.proof_1",[Iff.intro]]
["withPtrEqDecEq",[Unit, Decidable, Eq, Bool, withPtrEq, toBoolUsing, Unit.unit, withPtrEqDecEq.proof_1, Eq.refl, Bool.true, Decidable.isTrue, withPtrEqDecEq.proof_2, Bool.false, Decidable.isFalse, withPtrEqDecEq.proof_3]]
["List.length_add_eq_lengthTRAux",[List, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, List.length, List.lengthTRAux, of_eq_true, OfNat.ofNat, instOfNatNat, Eq.trans, True, congrFun, congrArg, Nat.zero_add, eq_self, Eq.mpr, List.cons, Nat.succ, congr, Nat.succ_add, Eq.symm, rfl]]
["hexDigitRepr",[Nat, String.singleton, Nat.digitChar]]
["instDecidableEqSum.proof_3",[Eq, Sum, Sum.inr, rfl]]
["Int.decEq.proof_1",[Nat, Eq, Int, Int.ofNat, rfl]]
["Substring.trimLeft",[Substring, Substring.dropWhile, Char.isWhitespace]]
["Lean.Parser.Tactic.Conv.rewrite",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.rwRuleSeq]]
["Std.Range.stop",[Std.Range]]
["heq_of_eq",[Eq, Eq.subst, HEq, HEq.refl]]
["UInt16.lt",[UInt16, LT.lt, Fin, UInt16.size, instLTFin, UInt16.val]]
["WellFounded.fix",[WellFounded, WellFounded.fixF, WellFounded.apply]]
["Array.foldlMUnsafe.fold",[Monad, Array, USize, ite, Eq, Bool, BEq.beq, instBEq, instDecidableEqUSize, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, Bind.bind, Monad.toBind, Array.uget, lcProof, LT.lt, Nat, instLTNat, USize.toNat, Array.size, Array.foldlMUnsafe.fold, HAdd.hAdd, instHAdd, instAddUSize, OfNat.ofNat, instOfNatUSize]]
["Lean.Parser.Tactic.tacticLet_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["MonadControl.noConfusionType",[MonadControl, Eq, HEq]]
["IO.FS.Metadata.accessed",[IO.FS.Metadata]]
["Array.findSomeRevM?.find.proof_1",[Array, Nat, LE.le, instLENat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Nat.lt_of_lt_of_le, Nat.succ, Nat.lt_succ_self]]
["Lean.Name.toString.maybePseudoSyntax",[Lean.Name, Bool, Lean.Name.getRoot, String, UInt64, or, String.isPrefixOf, Bool.false]]
["Array.getLit",[Nat, Array, Eq, Array.size, LT.lt, instLTNat, Array.get, Fin.mk, Array.getLit.proof_1]]
["IO.rand",[Nat, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, StdGen, ST.Ref.get, IO.RealWorld, instMonadLiftT, ST, IO.instMonadLiftSTRealWorldEIO, instMonadLiftT_1, IO.stdGenRef, Prod, randNat, instRandomGenStdGen, Unit, ST.Ref.set, PUnit, Pure.pure, Applicative.toPure, Monad.toApplicative]]
["Inhabited.noConfusionType",[Inhabited, Eq]]
["cast",[Eq]]
["Lean.NameGenerator.next",[Lean.NameGenerator, Lean.NameGenerator.mk, Lean.NameGenerator.namePrefix, HAdd.hAdd, Nat, instHAdd, instAddNat, Lean.NameGenerator.idx, OfNat.ofNat, instOfNatNat]]
["Lean.Macro.Methods.noConfusionType",[Lean.Macro.Methods, Lean.Syntax, Lean.MacroM, Option, Lean.Name, Bool, List, Prod, String, Eq]]
["Lean.Parser.Tactic.tacticSorry",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["Char.isValidCharNat",[Nat, Or, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, And]]
["HOrElse.hOrElse",[HOrElse]]
["System.FilePath.toString",[System.FilePath]]
["Lean.isGreek",[Char, and, Decidable.decide, LE.le, UInt32, instLEUInt32, OfNat.ofNat, instOfNatUInt32, Char.val, instDecidableLe]]
["Functor.mapConst",[Functor]]
["Array.allDiff",[BEq, Array, OfNat.ofNat, Nat, instOfNatNat]]
["Prod.foldI",[Nat, Prod, Nat.foldAux, Prod.snd, HSub.hSub, instHSub, instSubNat, Prod.fst]]
["HEq.elim",[HEq, eq_of_heq]]
["UInt64.mul",[UInt64, UInt64.mk, HMul.hMul, Fin, UInt64.size, instHMul, Fin.instMulFin, UInt64.val]]
["Array.eraseIdx'",[Array, Fin, Array.size, Array.eraseIdxSzAux, HAdd.hAdd, Nat, instHAdd, instAddNat, Fin.val, OfNat.ofNat, instOfNatNat, Array.eraseIdx'.proof_1]]
["Ordering.noConfusion",[Ordering, Eq, noConfusionEnum, Nat, instDecidableEqNat, Ordering.toCtorIdx]]
["IO.FS.DirEntry.mk.injEq",[System.FilePath, String, Eq.propIntro, Eq, IO.FS.DirEntry, IO.FS.DirEntry.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Nat.foldRevM.loop",[Monad, Nat, Nat.below, Pure.pure, Applicative.toPure, Monad.toApplicative, Nat.succ, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd]]
["Array.getOp",[Inhabited, Array, Nat, Array.get!]]
["System.FilePath.normalize",[System.FilePath, optParam, Bool, System.FilePath.isCaseInsensitive, ite, Eq, and, BEq.beq, Nat, instBEq, instDecidableEqNat, List.length, Char, System.FilePath.pathSeparators, OfNat.ofNat, instOfNatNat, not, Bool.true, instDecidableEqBool, System.FilePath.mk, String.map, List.contains, instDecidableEqChar, System.FilePath.pathSeparator, Char.toLower, System.FilePath.toString]]
["ReaderT.tryFinally",[MonadFinally, Monad, MonadFinally.mk, ReaderT, Option, MonadFinally.tryFinally']]
["StateT.run_get",[Monad, rfl, Prod, StateT.run, MonadState.get, StateT, instMonadState, instMonadStateOfStateT]]
["Lean.Meta.TransparencyMode.instances.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["instToStringUInt64",[ToString.mk, UInt64, ToString.toString, Nat, instToStringNat, UInt64.toNat]]
["Acc.noConfusionType",[Acc, Eq]]
["OfScientific.ofScientific",[OfScientific]]
["List.take",[Nat, List, Nat.below, List.nil, Nat.succ, List.cons, PProd.fst, PUnit, PProd]]
["Nat.forRevM.loop",[Monad, Nat, Unit, Nat.below, Pure.pure, Applicative.toPure, Monad.toApplicative, Unit.unit, Nat.succ, Bind.bind, Monad.toBind, PUnit, PProd.fst, PProd]]
["Lean.Parser.Tactic.generalizeArg",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat]]
["IO.Process.Child.stdout",[IO.Process.StdioConfig, IO.Process.Child]]
["Substring.get",[Substring, String.Pos, Char, String, String.get, HAdd.hAdd, instHAdd, instAddNat]]
["boolToSort",[CoeSort.mk, Bool, Eq, Bool.true]]
["instDecidableIff.proof_3",[Not, Iff, Iff.mpr]]
["String.Iterator.setCurr",[String.Iterator, Char, String, String.Pos, String.Iterator.mk, String.set]]
["List.mapTRAux_eq",[List, Eq, List.mapTRAux, HAppend.hAppend, instHAppend, List.instAppendList, List.reverse, List.map, of_eq_true, List.nil, Eq.trans, True, congrArg, List.append_nil, eq_self, Eq.mpr, List.cons, Eq.refl, List.reverse_cons, List.append_assoc, rfl]]
["Ne.intro",[Eq, False]]
["instReprAtomString",[ReprAtom.mk, String]]
["PSum.inl.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["ExceptT.pure",[Monad, ExceptT.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, Except, Except.ok]]
["tacticFunext__",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
["UInt64.decEq.proof_1",[Fin, UInt64.size, Eq, UInt64, UInt64.mk, rfl]]
["WellFounded.recursion",[WellFounded, Acc, WellFounded.apply]]
["stx!_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat]]
["Nat.foldRevM",[Monad, Nat, Nat.foldRevM.loop]]
["Task.noConfusionType",[Task, Eq]]
["PSum.inr.injEq",[Eq.propIntro, Eq, PSum, PSum.inr, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Quotient.recOnSubsingleton₂.proof_2",[Setoid, Quotient, Subsingleton, Quotient.mk]]
["Nat.le.intro",[Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, LE.le, instLENat, Nat.le_add_right]]
["EStateM.Result.ok.inj",[Eq, EStateM.Result, EStateM.Result.ok, And, And.intro]]
["Nat.instTransLtArrowNatArrowNatPropLtArrowNatArrowNatPropLtArrowNatArrowNatProp.proof_1",[Nat, Nat.lt_trans]]
["fix",[Inhabited, fixCore1, arbitrary]]
["IO.FS.instOrdSystemTime",[Ord.mk, IO.FS.SystemTime, Int, UInt32, IO.FS.SystemTime.mk, Ordering, Unit, Ordering.lt, Ordering.gt, Ordering.eq, Unit.unit, Ord.compare, instOrdInt, instOrdUInt32]]
["Lean.Macro.Methods.resolveGlobalName",[Lean.Macro.Methods]]
["Classical.typeDecidable.proof_1",[Not, Nonempty, absurd, False, Nonempty.intro]]
["PSigma.fst",[PSigma]]
["Subarray.foldrM",[Monad, Subarray, Array.foldrM, Subarray.as, Subarray.stop, Subarray.start]]
["instToStringSubtype",[ToString, ToString.mk, Subtype, ToString.toString, Subtype.val]]
["Array.back?",[Array, Array.get?, HSub.hSub, Nat, instHSub, instSubNat, Array.size, OfNat.ofNat, instOfNatNat]]
["Lean.mkIdentFrom",[Lean.Syntax, Lean.Name, Lean.Syntax.ident, Lean.SourceInfo.fromRef, String.toSubstring, ToString.toString, Lean.Name.instToStringName, List.nil, Prod, List, String]]
["Std.Format.nest.sizeOf_spec",[Int, Std.Format, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, instSizeOfNat, String, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOf, optParam, Std.Format.FlattenBehavior, Std.Format.FlattenBehavior.allOrNone]]
["Lean.Syntax.isLit?",[Lean.SyntaxNodeKind, Lean.Syntax, Option, String, Array, ite, Eq, Bool, and, BEq.beq, Lean.Name.instBEqName, Nat, instBEq, instDecidableEqNat, Array.size, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, Array.get!, Lean.instInhabitedSyntax, Lean.SourceInfo, Option.some, Option.none]]
["Lean.mkSepArray",[Array, Lean.Syntax, Nat, OfNat.ofNat, instOfNatNat, List.toArray, List.nil, Bind.bind, Id, Monad.toBind, Id.instMonadId, MProd, ForIn.forIn, Array.instForInArray, MProd.mk, MProd.fst, MProd.snd, PUnit, ForInStep, HAdd.hAdd, instHAdd, instAddNat, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, ForInStep.yield, ite, GT.gt, instLTNat, Nat.decLt, Array.push]]
["UInt8.val",[UInt8]]
["or_self",[propext, Or, Iff.intro, Or.inl]]
["Std.termF!_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
["PointedType.val",[PointedType]]
["Lean.mkCIdentFromRef",[Monad, Lean.MonadRef, Lean.Name, Bind.bind, Monad.toBind, Lean.Syntax, Lean.MonadRef.getRef, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.mkCIdentFrom]]
["decide_eq_true",[Decidable, Eq, Bool, Decidable.decide, Bool.true, rfl, Decidable.isTrue, Not, absurd, Decidable.isFalse]]
["Array.insertionSort",[Array, Bool, Nat, LT.lt, instLTNat, Array.size, OfNat.ofNat, instOfNatNat, Array.insertionSort.traverse, Array.insertionSort.swapLoop]]
["String.toNat!",[String, ite, Nat, Eq, Bool, String.isNat, Bool.true, instDecidableEqBool, String.foldl, Char, HAdd.hAdd, instHAdd, instAddNat, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Char.toNat, Char.ofNat, panicWithPosWithDecl, instInhabitedNat]]
["IO.ofExcept",[ToString, Except, IO, Pure.pure, Applicative.toPure, Monad.toApplicative, instMonadEIO, IO.Error, MonadExcept.throw, instMonadExcept, instMonadExceptOfEIO, IO.userError, ToString.toString]]
["Id.bind_eq",[Id, id, rfl, Bind.bind, Monad.toBind, Id.instMonadId]]
["ExceptCpsT.runCatch_bind_throw",[Monad, ExceptCpsT, rfl, ExceptCpsT.runCatch, Bind.bind, Monad.toBind, ExceptCpsT.instMonadExceptCpsT, MonadExcept.throw, instMonadExcept, ExceptCpsT.instMonadExceptOfExceptCpsT]]
["inferInstance",[]]
["instMonadControlReaderT",[MonadControl.mk, ReaderT, id]]
["Lean.Parser.Tactic.tacticHave_",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const]]
["Except.noConfusionType",[Except, Eq]]
["Lean.Parser.Tactic.split",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.cat, Lean.Parser.Tactic.location]]
["Option.map_id",[funext, Option, Option.map, id, Eq, Unit, rfl, Option.none, Option.some]]
["instSubFloat",[Sub.mk, Float, Float.sub]]
["Subtype.instDecidableEqSubtype",[DecidableEq, Subtype, Decidable, Eq, Subtype.mk, dite, Decidable.isTrue, Subtype.instDecidableEqSubtype.proof_1, Not, Decidable.isFalse, Subtype.instDecidableEqSubtype.proof_2]]
["Fin.shiftRight",[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, HShiftRight.hShiftRight, instHShiftRight, Nat.instShiftRightNat, Fin.shiftRight.proof_1]]
["String.extract",[String, String.Pos, List, Char, ite, GE.ge, instLENat, Nat.decLe, String.mk, List.nil, List.below, namedPattern, List.cons, Eq, instDecidableEqNat, PProd.fst, PUnit, PProd, HAdd.hAdd, Nat, instHAdd, instAddNat, String.csize, OfNat.ofNat, instOfNatNat]]
["RandomGen.next",[RandomGen]]
["instLTFin",[Nat, LT.mk, Fin, LT.lt, instLTNat, Fin.val]]
["Array.filterM",[Monad, Bool, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, Array.foldlM, Bind.bind, Monad.toBind, ite, Eq, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.push, List.toArray, List.nil]]
["instDecidableEqBool.proof_1",[Eq, Bool, Bool.false, Bool.true, False]]
["UInt8.mul",[UInt8, UInt8.mk, HMul.hMul, Fin, UInt8.size, instHMul, Fin.instMulFin, UInt8.val]]
["EStateM.fromStateM",[StateM, Id, Prod, EStateM.Result, StateT.run, EStateM.Result.ok]]
["Lean.Macro.addMacroScope",[Lean.Name, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, MonadReader.read, instMonadReader, instMonadReaderOfReaderT, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.addMacroScope, Lean.Macro.Context.mainModule, Lean.Macro.Context.currMacroScope]]
["Int.decEq.proof_4",[Nat, Not, Eq, Int, Int.negSucc, False, absurd]]
["implies_congr_ctx",[Eq, propext, Iff.intro]]
["List.removeAll",[BEq, List, List.filter, List.notElem]]
["instLENat",[LE.mk, Nat, Nat.le]]
["seqRight_eq_bind",[Monad, LawfulMonad, Eq.mpr, Eq, SeqRight.seqRight, Applicative.toSeqRight, Monad.toApplicative, Unit, Bind.bind, Monad.toBind, Seq.seq, Applicative.toSeq, Functor.map, Applicative.toFunctor, Function.const, id, Eq.refl, LawfulApplicative.seqRight_eq, LawfulMonad.toLawfulApplicative, of_eq_true, Eq.trans, True, congrFun, congrArg, Pure.pure, Applicative.toPure, map_eq_pure_bind, seq_eq_bind_map, funext, LawfulMonad.bind_assoc, LawfulMonad.pure_bind, id_eq, bind_pure, eq_self]]
["PSigma.SkipLeft",[PSigma.RevLex, emptyRelation]]
["unexpandExists",[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, cond, Array, Lean.Syntax.getArgs, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, Array.append, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
["invImage.proof_1",[WellFoundedRelation, InvImage.wf, WellFoundedRelation.rel, WellFoundedRelation.wf]]
["Task.Priority.max",[OfNat.ofNat, Task.Priority, instOfNatNat]]
["Int.decEq",[Decidable, Eq, Int, Nat, Int.ofNat, decEq, instDecidableEqNat, Decidable.isTrue, Int.decEq.proof_1, Not, Decidable.isFalse, Int.decEq.proof_2, Int.negSucc, Int.decEq.proof_3, Int.decEq.proof_4, Int.decEq.proof_5, Int.decEq.proof_6]]
["Nat.pos_pow_of_pos",[Nat, LT.lt, instLTNat, OfNat.ofNat, instOfNatNat, Nat.pow_le_pow_of_le_right, Nat.zero_le]]
["Iff.trans",[Iff, Iff.intro, Iff.mp, Iff.mpr]]
["Option.some.inj",[Eq, Option, Option.some]]
["Lean.Meta.instInhabitedTransparencyMode",[Inhabited.mk, Lean.Meta.TransparencyMode, Lean.Meta.TransparencyMode.all]]
["StateCpsT.run_eq",[Monad, StateCpsT, rfl, Prod, StateCpsT.run]]
["Ne.irrefl",[Ne, rfl]]
["noConfusionEnum",[DecidableEq, Eq, dite, noConfusionTypeEnum, cast, noConfusionEnum.proof_1, Not, False.elim, noConfusionEnum.proof_2]]
["Nat.le_of_succ_le_succ",[Nat, Nat.pred_le_pred, Nat.succ]]
["OrElse.orElse",[OrElse]]
["Quotient.inductionOn₂",[Setoid, Quotient, Quotient.mk, Quotient.ind]]
["instDecidableEqSum.proof_5",[Eq, Sum, Sum.inr, Sum.inl, False]]
["IO.Error.mkNoFileOrDirectory",[IO.Error.noFileOrDirectory]]
["IO.Error.unsatisfiedConstraints.injEq",[UInt32, String, Eq.propIntro, Eq, IO.Error, IO.Error.unsatisfiedConstraints, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["IO.FS.Stream.putStrLn",[IO.FS.Stream, String, IO.FS.Stream.putStr, String.push, Char.ofNat]]
["Sum.inl.injEq",[Eq.propIntro, Eq, Sum, Sum.inl, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Fin.instXorFin",[Nat, Xor.mk, Fin, Fin.xor]]
["instShiftLeftUInt16",[ShiftLeft.mk, UInt16, UInt16.shiftLeft]]
["Lean.Meta.TransparencyMode.reducible.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["iff_false",[propext, Iff, False, Not, Iff.intro, Iff.mp, False.elim]]
["Lean.Parser.Tactic.Conv.enterArg",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.const]]
["String.takeRightWhile",[String, Char, Bool, Substring.toString, Substring.takeRightWhile, String.toSubstring]]
["instInhabitedForInStep",[Inhabited, Inhabited.mk, ForInStep, ForInStep.done, arbitrary]]
["panicWithPos",[Inhabited, String, Nat, panic, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString, instToStringNat]]
["instDecidableEqBool",[Bool, Decidable, Eq, Unit, Decidable.isTrue, Bool.false, rfl, Decidable.isFalse, Bool.true, instDecidableEqBool.proof_1, instDecidableEqBool.proof_2]]
["unexpandSubtype",[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, cond, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
["Array.mapIdxM.map",[Monad, Array, Fin, Array.size, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.below, OfNat.ofNat, instOfNatNat, Pure.pure, Applicative.toPure, Monad.toApplicative, Nat.succ]]
["Except.error.injEq",[Eq.propIntro, Eq, Except, Except.error, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Nat.le_of_lt",[Nat, LT.lt, instLTNat, Nat.le_of_succ_le]]
["Lean.Macro.Context.mainModule",[Lean.Macro.Context]]
["EStateM.seqRight",[EStateM, Unit, EStateM.Result, Unit.unit, EStateM.Result.error]]
["fix4",[Inhabited, fixCore4, arbitrary]]
["HAppend.noConfusionType",[outParam, HAppend, Eq]]
["Substring.takeRight",[Substring, Nat, String, String.Pos, Substring.mk, HAdd.hAdd, instHAdd, instAddNat, Substring.prevn, Substring.bsize]]
["map_congr",[Functor, Eq, of_eq_true, Functor.map, Eq.trans, True, congrFun, congrArg, funext, eq_self]]
["Int.decEq.proof_5",[Nat, Eq, Int, Int.ofNat, Int.negSucc, False]]
["Nat.repeat",[Nat, Nat.repeat.loop]]
["List.append",[List, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd]]
["instDecidableAnd",[Decidable, And, Decidable.isTrue, And.intro, Not, Decidable.isFalse, instDecidableAnd.proof_1, instDecidableAnd.proof_2]]
["Int.negSucc.sizeOf_spec",[Nat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat]]
["USize.decEq.proof_1",[Fin, USize.size, Eq, USize, USize.mk, rfl]]
["Array.getIdx?",[BEq, Array, Array.findIdx?, BEq.beq]]
["coeId",[CoeT.mk]]
["String.all",[String, Char, Bool, not, String.any]]
["Fin.coeToNat",[Nat, Coe.mk, Fin, Fin.val]]
["PSigma.lex",[PSigma.lex.proof_1]]
["Nat.mul_succ",[Nat, rfl, HMul.hMul, instHMul, instMulNat, Nat.succ]]
["Quotient.liftOn",[Setoid, Quotient, HasEquiv.Equiv, instHasEquiv, Eq, Quot.liftOn, Setoid.r]]
["ToBool.noConfusionType",[ToBool, Bool, Eq]]
["Std.Format.MonadPrettyFormat.pushNewline",[Std.Format.MonadPrettyFormat]]
["EStateM.instMonadExceptOfEStateM",[outParam, EStateM.Backtrackable, MonadExceptOf.mk, EStateM, EStateM.throw, EStateM.tryCatch]]
["Nat.le.dest",[Nat, LE.le, instLENat, Exists, Eq, HAdd.hAdd, instHAdd, instAddNat, Nat.below, Nat.zero, Exists.intro, OfNat.ofNat, instOfNatNat, rfl, Nat.succ, Eq.symm, Nat.add_comm, absurd, Nat.not_succ_le_zero]]
["Array.findSomeRev?",[Array, Option, Id.run, Array.findSomeRevM?, Id, Id.instMonadId]]
["Alternative.orElse",[Alternative]]
["Ordering.noConfusionType",[Ordering, noConfusionTypeEnum, Nat, instDecidableEqNat, Ordering.toCtorIdx]]
["dbgSleep",[UInt32, Unit, Unit.unit]]
["List.foldrM",[Monad, List, List.below, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, List.cons, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd]]
["instHSub",[Sub, HSub.mk, Sub.sub]]
["Lean.maxRecDepthErrorMessage",[]]
["DoResultPR.pure.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["String.toNat?",[String, ite, Option, Nat, Eq, Bool, String.isNat, Bool.true, instDecidableEqBool, Option.some, String.foldl, Char, HAdd.hAdd, instHAdd, instAddNat, HMul.hMul, instHMul, instMulNat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Char.toNat, Char.ofNat, Option.none]]
["Lean.MacroM",[ReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State]]
["Nat.mul_le_mul",[Nat, LE.le, instLENat, Nat.le_trans, HMul.hMul, instHMul, instMulNat, Nat.mul_le_mul_right, Nat.mul_le_mul_left]]
["StateCpsT.runK_set",[PUnit, rfl, StateCpsT.runK, MonadStateOf.set, StateCpsT, StateCpsT.instMonadStateOfStateCpsT]]
["Lean.Parser.Tactic.Conv.nestedTacticCore",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
["instMonadWithReaderOf",[MonadFunctor, MonadWithReaderOf, MonadWithReaderOf.mk, MonadFunctorT.monadMap, instMonadFunctorT, monadFunctorRefl, withTheReader]]
["UInt8.decLe",[UInt8, Decidable, LE.le, instLEUInt8, Fin, UInt8.size, inferInstanceAs, instLEFin, Fin.decLe]]
["Lean.Syntax.isToken",[String, Lean.Syntax, Bool, Lean.SourceInfo, BEq.beq, instBEq, instDecidableEqString, String.trim, Bool.false]]
["instRandomGenStdGen",[RandomGen.mk, StdGen, stdRange, stdNext, stdSplit]]
["Nat.lt.base",[Nat.lt.base.proof_1]]
["instModUSize",[Mod.mk, USize, USize.mod]]
["HEq.rfl.proof_1",[HEq.refl]]
["false_or",[propext, Or, False, Iff.intro, False.elim, Or.inr]]
["Nat.zero_le",[Nat, LE.le, instLENat, OfNat.ofNat, instOfNatNat, Nat.below, Unit, Nat.zero, Nat.le.refl, Nat.succ, Nat.le.step, PProd.fst, PUnit, PProd]]
["instDecidableLe_1",[UInt8, UInt8.decLe]]
["Int.ofNat.sizeOf_spec",[Nat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat]]
["decEq",[DecidableEq]]
["LawfulApplicative.toLawfulFunctor",[Applicative, LawfulApplicative]]
["EStateM.tryCatch",[outParam, EStateM.Backtrackable, EStateM, EStateM.Backtrackable.save, EStateM.Result, EStateM.Backtrackable.restore]]
["Array.instAppendArray",[Append.mk, Array, Array.append]]
["not_not_intro",[Not]]
["unexpandListCons",[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, Lean.Syntax.SepArray, Lean.Syntax.SepArray.mk, Lean.Syntax.getArgs, Array.append, Lean.Syntax.SepArray.elemsAndSeps, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
["StateT",[Prod]]
["Array.indexOf?",[BEq, Array, Array.indexOfAux, OfNat.ofNat, Nat, instOfNatNat]]
["String.isEmpty",[String, BEq.beq, Nat, instBEq, instDecidableEqNat, String.bsize, OfNat.ofNat, instOfNatNat]]
["List.mapTRAux",[List, List.below, List.nil, List.reverse, List.cons, PProd.fst, PUnit, PProd]]
["Classical.decidableInhabited",[Inhabited.mk, Decidable, inferInstance, Classical.propDecidable]]
["Lean.Meta.TransparencyMode.toCtorIdx",[Lean.Meta.TransparencyMode, Nat, OfNat.ofNat, instOfNatNat]]
["instNonempty.proof_1",[Inhabited, Nonempty.intro, arbitrary]]
["UInt16.modn",[UInt16, UInt16.mk, HMod.hMod, Fin, UInt16.size, Nat, Fin.instHModFinNatFin, UInt16.val]]
["IO.FS.Stream.getLine",[IO.FS.Stream]]
["Fin.ne_of_val_ne",[Nat, Fin, Not, Eq, Fin.val, absurd, False, Fin.val_eq_of_eq]]
["IO.FS.FileType.noConfusion",[IO.FS.FileType, Eq, noConfusionEnum, Nat, instDecidableEqNat, IO.FS.FileType.toCtorIdx]]
["coeSort",[CoeSort, CoeSort.coe]]
["List.toStringAux",[ToString, Bool, List, String, List.below, List.nil, List.cons, HAppend.hAppend, instHAppend, String.instAppendString, ToString.toString, PProd.fst, PUnit, PProd, Bool.false]]
["instHAdd",[Add, HAdd.mk, Add.add]]
["Applicative.toFunctor",[Applicative]]
["inferInstanceAs",[]]
["Lean.Parser.Tactic.casesTarget",[Lean.ParserDescr.nodeWithAntiquot, Lean.Name.mkStr, Lean.Name.anonymous, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat, OfNat.ofNat, Nat, instOfNatNat]]
["Lean.Parser.Tactic.delta",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.const, Lean.ParserDescr.unary, Lean.Parser.Tactic.location]]
["Lean.NameGenerator.mkChild",[Lean.NameGenerator, Prod.mk, Lean.NameGenerator.mk, Lean.Name.mkNum, Lean.NameGenerator.namePrefix, Lean.NameGenerator.idx, OfNat.ofNat, Nat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat]]
["Lean.MonadQuotation.noConfusionType",[Lean.MonadQuotation, Lean.MonadRef, Lean.MacroScope, Lean.Name, Eq]]
["LT.lt",[LT]]
["RandomGen.noConfusionType",[RandomGen, Prod, Nat, Eq]]
["Substring.mk.sizeOf_spec",[String, String.Pos, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["ExceptCpsT",[]]
["Substring.take",[Substring, Nat, String, String.Pos, Substring.mk, HAdd.hAdd, instHAdd, instAddNat, Substring.nextn, OfNat.ofNat, instOfNatNat]]
["«term_<|_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["instOrElseEIO",[OrElse.mk, EIO, MonadExcept.orElse, instMonadExcept, instMonadExceptOfEIO]]
["Nat.foldM.loop",[Monad, Nat, Nat.below, Pure.pure, Applicative.toPure, Monad.toApplicative, Nat.succ, Bind.bind, Monad.toBind, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, PProd.fst, PUnit, PProd]]
["StateT.instMonadExceptOfStateT",[Monad, MonadExceptOf, MonadExceptOf.mk, StateT, Function.comp, StateT.lift, throwThe, tryCatchThe, Prod]]
["let_congr",[Eq]]
["Lean.isIdEndEscape",[Char, Decidable.decide, Eq, Lean.idEndEscape, instDecidableEqChar]]
["rawNatLit",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.const]]
["Array.findRev?",[Array, Bool, Id.run, Option, Array.findRevM?, Id, Id.instMonadId]]
["instToStringDecidable",[ToString.mk, Decidable, String, Not]]
["Substring.next",[Substring, String.Pos, String, HAdd.hAdd, instHAdd, instAddNat, ite, Eq, instDecidableEqNat, HSub.hSub, instHSub, instSubNat, String.next]]
["ByteArray.copySlice",[Nat, ByteArray, optParam, Bool, Bool.true, ByteArray.mk, HAppend.hAppend, Array, UInt8, instHAppend, Array.instAppendArray, Array.extract, ByteArray.data, OfNat.ofNat, instOfNatNat, HAdd.hAdd, instHAdd, instAddNat, Array.size]]
["Std.Format.groupEx",[Std.Format, Std.Format.group, Std.Format.FlattenBehavior.allOrNone]]
["Id.instLawfulMonadId",[Id.instLawfulMonadId.proof_1]]
["instInhabitedPUnit",[Inhabited.mk, PUnit, PUnit.unit]]
["UInt64.shiftLeft",[UInt64, UInt64.mk, HShiftLeft.hShiftLeft, Fin, UInt64.size, instHShiftLeft, Fin.instShiftLeftFin, UInt64.val, UInt64.modn, OfNat.ofNat, Nat, instOfNatNat]]
["UInt8.decLt",[UInt8, Decidable, LT.lt, instLTUInt8, Fin, UInt8.size, inferInstanceAs, instLTFin, Fin.decLt]]
["ToBool.toBool",[ToBool]]
["StateT.run'",[Functor, StateT, Functor.map, Prod, Prod.fst]]
["Nat.mod_self",[Nat, Eq.mpr, Eq, HMod.hMod, instHMod, Nat.instModNat, OfNat.ofNat, instOfNatNat, HSub.hSub, instHSub, instSubNat, Eq.refl, Nat.mod_eq_sub_mod, Nat.le_refl, Nat.sub_self, Nat.zero_mod, rfl]]
["Lean.Parser.Tactic.Conv.convDone",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["Lean.Macro.State.macroScope",[Lean.Macro.State]]
["ExceptT.run_throw",[Monad, rfl, Except, ExceptT.run, MonadExcept.throw, ExceptT, instMonadExcept, instMonadExceptOfExceptT_1]]
["Int.lt",[Int, LE.le, Int.instLEInt, HAdd.hAdd, instHAdd, Int.instAddInt, OfNat.ofNat, hasOfNatOfCoe, Nat, instCoeNatInt, instOfNatNat]]
["Lean.Parser.Tactic.Conv.paren",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.Parser.Tactic.Conv.convSeq, Lean.ParserDescr.symbol]]
["And.right",[And]]
["Std.Format.MonadPrettyFormat.startTag",[Std.Format.MonadPrettyFormat]]
["Id.map_eq",[Id, rfl, Functor.map, Applicative.toFunctor, Monad.toApplicative, Id.instMonadId]]
["Lean.Syntax.missing.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["List.length_dropLast",[List, Eq, Nat, List.length, List.dropLast, HSub.hSub, instHSub, instSubNat, OfNat.ofNat, instOfNatNat, List.below, Unit, List.nil, rfl, List.cons]]
["Lean.Meta.Simp.Config.mk.sizeOf_spec",[Nat, Bool, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfNat, SizeOf.mk]]
["IO.Error.toString",[IO.Error, String, Unit, UInt32, IO.Error.fopenErrorToString, Option.some, IO.Error.otherErrorToString, Option.none]]
["Quotient.recOnSubsingleton",[Setoid, Quotient, Subsingleton, Quotient.mk, Quot.recOnSubsingleton, Setoid.r]]
["System.SearchPath.parse",[String, List.map, System.FilePath, System.FilePath.mk, String.split, Char, BEq.beq, instBEq, instDecidableEqChar, System.SearchPath.separator]]
["StateT.run_pure",[Monad, rfl, Prod, StateT.run, Pure.pure, StateT, Applicative.toPure, Monad.toApplicative, StateT.instMonadStateT]]
["IO.FS.FileType.noConfusionType",[IO.FS.FileType, noConfusionTypeEnum, Nat, instDecidableEqNat, IO.FS.FileType.toCtorIdx]]
["IO.Process.StdioConfig.mk.sizeOf_spec",[IO.Process.Stdio, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk]]
["Std.Format.FlattenBehavior.noConfusion",[Std.Format.FlattenBehavior, Eq, noConfusionEnum, Nat, instDecidableEqNat, Std.Format.FlattenBehavior.toCtorIdx]]
["Array.size_mkArray",[Nat, List.length_replicate]]
["Array.back",[Inhabited, Array, Array.get!, HSub.hSub, Nat, instHSub, instSubNat, Array.size, OfNat.ofNat, instOfNatNat]]
["UInt16.ofNat",[UInt16.mk, Fin.ofNat, OfNat.ofNat, Nat, instOfNatNat]]
["UInt64.le",[UInt64, LE.le, Fin, UInt64.size, instLEFin, UInt64.val]]
["IO.Process.SpawnArgs.args",[IO.Process.SpawnArgs]]
["IO.FS.Metadata.mk.injEq",[IO.FS.SystemTime, UInt64, IO.FS.FileType, Eq.propIntro, Eq, IO.FS.Metadata, IO.FS.Metadata.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["IO.FS.FileType.other.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["Add.add",[Add]]
["HOrElse.noConfusionType",[outParam, HOrElse, Unit, Eq]]
["StateT.lift",[Monad, Bind.bind, Monad.toBind, Prod, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod.mk]]
["Nat.zero_mod",[Nat, Eq.mpr, Eq, HMod.hMod, instHMod, Nat.instModNat, OfNat.ofNat, instOfNatNat, ite, And, LT.lt, instLTNat, LE.le, instLENat, instDecidableAnd, Nat.decLt, Nat.decLe, HSub.hSub, instHSub, instSubNat, Eq.refl, Nat.mod_eq]]
["Lean.Syntax.decodeNameLit",[String, ite, Option, Lean.Name, Eq, Bool, BEq.beq, Char, instBEq, instDecidableEqChar, String.get, OfNat.ofNat, String.Pos, instOfNatNat, Char.ofNat, Bool.true, instDecidableEqBool, List, Substring, Substring.drop, String.toSubstring, Nat, List.nil, Unit, Option.none, Option.some, List.foldr, Substring.toString, Lean.isIdBeginEscape, String.front, Lean.Name.mkStr, String.dropRight, String.drop, Lean.Name.anonymous]]
["System.FilePath.withExtension",[System.FilePath, String, Option, System.FilePath.fileStem, Unit, System.FilePath.withFileName, ite, Eq, Bool, String.isEmpty, Bool.true, instDecidableEqBool, HAppend.hAppend, instHAppend, String.instAppendString]]
["Classical.epsilon_singleton",[Classical.epsilon_spec, Eq, Exists.intro, rfl]]
["PProd.mk.injEq",[Eq.propIntro, Eq, PProd, PProd.mk, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["MonadExcept.throw",[MonadExcept]]
["UInt8.lor",[UInt8, UInt8.mk, Fin.lor, UInt8.size, UInt8.val]]
["Subarray.all",[Bool, Subarray, Id.run, Subarray.allM, Id, Id.instMonadId]]
["List.eraseDupsAux",[BEq, List, List.below, List.nil, List.reverse, List.cons, Bool, List.elem, Unit, PProd.fst, PUnit, PProd]]
["Nat.mul_assoc",[Nat, Eq, HMul.hMul, instHMul, instMulNat, Nat.below, rfl, OfNat.ofNat, instOfNatNat, Nat.succ]]
["ST.Ref.ref",[ST.Ref]]
["eq_self",[propext, Eq, True, Iff.intro, trivial, rfl]]
["UInt16.size",[OfNat.ofNat, Nat, instOfNatNat]]
["Thunk.map",[Thunk, Thunk.mk, Unit, Thunk.get]]
["Nat.not_lt_zero",[Nat, Nat.not_succ_le_zero]]
["Std.instToFormatString",[Std.ToFormat.mk, String, Std.Format.text]]
["Lean.Syntax.isCharLit?",[Lean.Syntax, Option, String, Option.some, Option.none, Char, Lean.Syntax.isLit?, Lean.charLitKind, Lean.Syntax.decodeCharLit]]
["Neg.neg",[Neg]]
["Sum.inhabitedLeft",[Inhabited, Inhabited.mk, Sum, Sum.inl, arbitrary]]
["PSigma.lexAccessible.proof_1",[Acc, WellFounded, PSigma, PSigma.Lex, PSigma.mk, Acc.intro, Eq, HEq, PSigma.Lex.left, Eq.symm, eq_of_heq, PSigma.Lex.right, Eq.refl, HEq.refl, WellFounded.apply]]
["Array.mapIdxM.map.proof_2",[Array, Nat, Eq, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, Array.size, Eq.mpr, Eq.refl, Eq.symm, Nat.add_comm, Nat.add_assoc, rfl]]
["OrOp.noConfusionType",[OrOp, Eq]]
["Nat.add_le_add",[Nat, LE.le, instLENat, Nat.le_trans, HAdd.hAdd, instHAdd, instAddNat, Nat.add_le_add_right, Nat.add_le_add_left]]
["HEq.symm",[HEq, HEq.ndrecOn, HEq.refl]]
["List.filterMapM.loop",[Monad, Option, List, List.below, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, List.cons, Bind.bind, Monad.toBind, Unit, PProd.fst, PUnit, PProd]]
["ex_of_PSigma",[PSigma, Exists, Exists.intro]]
["instToStringInt",[ToString.mk, Int, String, Nat, ToString.toString, instToStringNat, HAppend.hAppend, instHAppend, String.instAppendString, Nat.succ]]
["coeBase",[Coe, CoeTC.mk, coeB]]
["List.instBEqList",[BEq, BEq.mk, List, List.beq]]
["Nat.ble",[Nat, Bool, Nat.below, Unit, Nat.zero, Bool.true, Nat.succ, Bool.false, PProd.fst, PUnit, PProd]]
["instLTProd",[LT, LT.mk, Prod, Or, LT.lt, Prod.fst, And, Eq, Prod.snd]]
["UInt8.shiftLeft",[UInt8, UInt8.mk, HShiftLeft.hShiftLeft, Fin, UInt8.size, instHShiftLeft, Fin.instShiftLeftFin, UInt8.val, UInt8.modn, OfNat.ofNat, Nat, instOfNatNat]]
["Lean.instMonadRef",[MonadLift, MonadFunctor, Lean.MonadRef, Lean.MonadRef.mk, liftM, instMonadLiftT, instMonadLiftT_1, Lean.Syntax, Lean.MonadRef.getRef, MonadFunctorT.monadMap, instMonadFunctorT, monadFunctorRefl, Lean.MonadRef.withRef]]
["instDecidableAnd.proof_1",[Not, And, And.right]]
["instOrOpUInt32",[OrOp.mk, UInt32, UInt32.lor]]
["Array.findIdxM?",[Monad, Array, Bool, Nat, OfNat.ofNat, instOfNatNat, Bind.bind, Monad.toBind, MProd, Option, ForIn.forIn, Array.instForInArray, MProd.mk, Option.none, MProd.snd, ForInStep, PUnit, HAdd.hAdd, instHAdd, instAddNat, Pure.pure, Applicative.toPure, Monad.toApplicative, PUnit.unit, ForInStep.yield, ite, Eq, Bool.true, instDecidableEqBool, ForInStep.done, Option.some, MProd.fst, Unit]]
["instToFormat",[ToString, Std.ToFormat.mk, Function.comp, String, Std.Format, Std.Format.text, ToString.toString]]
["instAndOpUInt16",[AndOp.mk, UInt16, UInt16.land]]
["IO.Ref",[ST.Ref, IO.RealWorld]]
["String.Iterator.toString",[String.Iterator, String, String.Pos]]
["Int.decEq.proof_2",[Nat, Not, Eq, Int, Int.ofNat, False, absurd]]
["IO.FS.Stream.Buffer.mk.inj",[ByteArray, Nat, Eq, IO.FS.Stream.Buffer, IO.FS.Stream.Buffer.mk, And, And.intro]]
["Nat.mul_left_comm",[Nat, Eq.mpr, Eq, HMul.hMul, instHMul, instMulNat, Eq.refl, Eq.symm, Nat.mul_assoc, Nat.mul_comm, rfl]]
["Iff.comm",[Iff.intro, Iff, Iff.symm]]
["Fin.mk.injEq",[Nat, LT.lt, instLTNat, Eq.propIntro, Eq, Fin, Fin.mk, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Subarray.toArray",[Subarray, Array.ofSubarray]]
["OptionT.instMonadExceptOfOptionT",[Monad, MonadExceptOf, MonadExceptOf.mk, OptionT, OptionT.mk, throwThe, Option, tryCatchThe]]
["Lean.Parser.Tactic.Conv.convArgs",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["IO.Error.resourceExhausted.injEq",[Option, String, UInt32, Eq.propIntro, Eq, IO.Error, IO.Error.resourceExhausted, And, And.intro, HEq, Eq.refl, Eq.symm, eq_of_heq, HEq.refl]]
["Quot.hrecOn",[Quot, Quot.mk, HEq, Quot.recOn, Quot.hrecOn.proof_1]]
["instReprProd",[Repr, ReprTuple, Repr.mk, Prod, Nat, Std.Format, Std.Format.bracket, Std.Format.joinSep, Std.instToFormatFormat, List.reverse, ReprTuple.reprTuple, List.cons, repr, List.nil, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text, Std.Format.line]]
["Lean.Syntax.splitNameLit",[Substring, List.reverse, List.nil]]
["control",[MonadControlT, Bind, MonadControlT.stM, controlAt]]
["Lean.Syntax.instCoeArraySyntaxSepArray",[String, Coe.mk, Array, Lean.Syntax, Lean.Syntax.SepArray, Lean.Syntax.SepArray.ofElems]]
["eq_false_of_ne_true",[Bool, Not, Eq, Bool.true, Bool.false, False.elim, rfl]]
["«term_>>>_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["IO.FS.DirEntry.root",[IO.FS.DirEntry]]
["instDecidableDite",[Not, Decidable, dite]]
["Lean.Name.getRoot",[Lean.Name, Lean.Name.below, Unit, Lean.Name.anonymous, String, UInt64, namedPattern, Lean.Name.str, Nat, Lean.Name.num, PProd.fst, PUnit, PProd]]
["Lean.extractMacroScopes",[Lean.Name, Bool, Lean.MacroScopesView, Lean.Name.hasMacroScopes, Unit, List, Lean.MacroScope, Lean.Name.below, Nat, UInt64, Lean.Name.num, String, Lean.Name.str, Lean.Name.anonymous, PProd.fst, PUnit, PProd, List.cons, namedPattern, BEq.beq, instBEq, instDecidableEqString, Lean.MacroScopesView.mk, List.below, List.nil, Lean.Name.mkStr, Lean.Name.mkNum, panic, Lean.instInhabitedName, Lean.instInhabitedMacroScopesView]]
["Substring.nextn",[Substring, Nat, String.Pos, Nat.below, Nat.succ, PProd.fst, PUnit, PProd, Substring.next]]
["ExceptT.instMonadLiftExceptT",[Monad, MonadLift.mk, ExceptT, ExceptT.lift]]
["Prod.lt_def",[LT, Prod, rfl, LT.lt, instLTProd]]
["Lean.Meta.Simp.ConfigCtx.mk.inj",[Lean.Meta.Simp.Config, Eq, Lean.Meta.Simp.ConfigCtx, Lean.Meta.Simp.ConfigCtx.mk]]
["instMonadControlExceptT",[Monad, MonadControl.mk, ExceptT, Except, liftM, instMonadLiftT, ExceptT.instMonadLiftExceptT, instMonadLiftT_1, ExceptT.run]]
["Fin.lor",[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, Nat.lor, Fin.lor.proof_1]]
["List.getLast.proof_1",[rfl, List, List.nil]]
["getModify",[MonadState, Monad, MonadState.modifyGet, Prod.mk]]
["Lean.Parser.Tactic.injections",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["StateT.failure",[Alternative, Alternative.failure, Prod]]
["Fin.div",[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, HDiv.hDiv, instHDiv, Nat.instDivNat, Fin.div.proof_1]]
["UInt32.land",[UInt32, UInt32.mk, Fin.land, UInt32.size, UInt32.val]]
["ByteArray.toUInt64BE!",[ByteArray, ite, UInt64, Eq, Bool, BEq.beq, Nat, instBEq, instDecidableEqNat, ByteArray.size, OfNat.ofNat, instOfNatNat, Bool.true, instDecidableEqBool, HOr.hOr, instHOr, instOrOpUInt64, HShiftLeft.hShiftLeft, instHShiftLeft, instShiftLeftUInt64, UInt8.toUInt64, ByteArray.get!, instOfNatUInt64, panicWithPosWithDecl, instInhabitedUInt64, HAppend.hAppend, String, instHAppend, String.instAppendString]]
["UInt32.ofNat",[UInt32.mk, Fin.ofNat, OfNat.ofNat, Nat, instOfNatNat]]
["Char.instDecidableLt",[Char, UInt32.decLt, Char.val]]
["Nat.sub_le",[Nat, LE.le, instLENat, HSub.hSub, instHSub, instSubNat, Nat.le_refl, OfNat.ofNat, instOfNatNat, Nat.le_trans, Nat.pred, Nat.pred_le]]
["ReaderT.instAlternativeReaderT",[Alternative, Monad, Alternative.mk, ReaderT, Monad.toApplicative, ReaderT.instMonadReaderT, ReaderT.failure, ReaderT.orElse]]
["Lean.Meta.Simp.Config.maxDischargeDepth",[Lean.Meta.Simp.Config]]
["BEq.noConfusionType",[BEq, Bool, Eq]]
["min",[LE, DecidableRel, LE.le, ite]]
["false_iff",[propext, Iff, False, Not, Iff.intro, Iff.mpr, False.elim]]
["instOrdChar",[Ord.mk, Char, compareOfLessAndEq, Char.instLTChar, Char.instDecidableLt, instDecidableEqChar]]
["Lean.Meta.instBEqTransparencyMode",[BEq.mk, Lean.Meta.TransparencyMode, BEq.beq, Nat, instBEq, instDecidableEqNat, Lean.Meta.TransparencyMode.toCtorIdx]]
["Float.mk.inj",[FloatSpec.float, floatSpec, Eq, Float, Float.mk]]
["Hashable.noConfusionType",[Hashable, UInt64, Eq]]
["Ordering.lt.sizeOf_spec",[Eq.refl, Nat, OfNat.ofNat, instOfNatNat]]
["repr",[Repr, Repr.reprPrec, OfNat.ofNat, Nat, instOfNatNat]]
["UInt32.xor",[UInt32, UInt32.mk, Fin.xor, UInt32.size, UInt32.val]]
["instReprOption",[Repr, Repr.mk, Option, Nat, Std.Format, Std.Format.text, Repr.addAppParen, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, reprArg]]
["System.Platform.getNumBits.proof_1",[Or.inr, Eq, Nat, OfNat.ofNat, instOfNatNat, rfl]]
["Function.const",[]]
["List.hasDecidableLt.proof_4",[LT, List, Not, LT.lt, List.instLTList, List.cons, False, absurd, List.lt]]
["Int.instSubInt",[Sub.mk, Int, Int.sub]]
["eqRec_heq",[Eq, HEq, HEq.refl]]
["instMonadExceptOfExceptT_1",[Monad, MonadExceptOf.mk, ExceptT, ExceptT.mk, Pure.pure, Applicative.toPure, Monad.toApplicative, Except, Except.error, ExceptT.tryCatch]]
["Option.isNone",[Option, Bool, Bool.false, Unit, Bool.true]]
["Array.instToStringArray",[ToString, ToString.mk, Array, HAppend.hAppend, String, instHAppend, String.instAppendString, ToString.toString, List, instToStringList, Array.toList]]
["SeqRight.noConfusionType",[SeqRight, Unit, Eq]]
["coeDecidableEq",[Bool, inferInstanceAs, Decidable, Eq, Bool.true, instDecidableEqBool]]
["Lean.NameGenerator.mk.sizeOf_spec",[Lean.Name, Nat, Eq.refl, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOfName, instSizeOfNat]]
["Lean.Syntax.mkScientificLit",[String, optParam, Lean.SourceInfo, Lean.SourceInfo.none, Lean.Syntax.mkLit, Lean.scientificLitKind]]
["instInhabitedArrow",[Inhabited, Inhabited.mk, arbitrary]]
["UInt8.add",[UInt8, UInt8.mk, HAdd.hAdd, Fin, UInt8.size, instHAdd, Fin.instAddFin, UInt8.val]]
["UInt8.complement",[UInt8, HSub.hSub, instHSub, instSubUInt8, OfNat.ofNat, instOfNatUInt8, HAdd.hAdd, instHAdd, instAddUInt8]]
["Nat.instDivNat",[Div.mk, Nat, Nat.div]]
["«term_<&&>_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["String.capitalize",[String, String.set, OfNat.ofNat, String.Pos, instOfNatNat, Char.toUpper, String.get]]
["instMonadExceptOfEIO",[inferInstanceAs, MonadExceptOf, EStateM, IO.RealWorld, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable]]
["Thunk.bind",[Thunk, Thunk.mk, Unit, Thunk.get]]
["instReprPUnit",[Repr.mk, PUnit, Nat, Std.Format.text]]
["instCoeDep",[outParam, CoeFun, CoeDep.mk, coeFun]]
["Task.Priority.default",[OfNat.ofNat, Task.Priority, instOfNatNat]]
["Prod.rprod.proof_1",[WellFoundedRelation, Subrelation, Prod, Prod.RProd, WellFoundedRelation.rel, Prod.Lex, Subrelation.wf, WellFoundedRelation.wf, Prod.lex, Prod.RProdSubLex]]
["IO.FS.instReprMetadata",[Repr.mk, IO.FS.Metadata, Nat, Std.Format.bracket, HAppend.hAppend, Std.Format, instHAppend, Std.Format.instAppendFormat, Std.Format.nil, Std.Format.text, repr, IO.FS.SystemTime, IO.FS.instReprSystemTime, IO.FS.Metadata.accessed, Std.Format.line, IO.FS.Metadata.modified, UInt64, instReprUInt64, IO.FS.Metadata.byteSize, IO.FS.FileType, IO.FS.instReprFileType, IO.FS.Metadata.type]]
["Lean.instEvalIO",[Lean.Eval, Lean.Eval.mk, IO, Unit, optParam, Bool, Bool.true, Bind.bind, Monad.toBind, instMonadEIO, IO.Error, Unit.unit, Lean.Eval.eval]]
["Setoid.r",[Setoid]]
["List.getLast",[List, Ne, List.nil, List.below, absurd, Eq, List.getLast.proof_1, List.cons, PProd.fst, PUnit, PProd, List.getLast.proof_2]]
["Lean.Meta.Simp.ConfigCtx.toConfig",[Lean.Meta.Simp.ConfigCtx]]
["termPrintln!__",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.unary, Lean.ParserDescr.cat]]
["«term_|||_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["noConfusionEnum.proof_1",[DecidableEq, Eq, Eq.symm, ite, if_pos]]
["Fin.instAndOpFin",[Nat, AndOp.mk, Fin, Fin.land]]
["Nat.succ_le_of_lt",[Nat, LT.lt, instLTNat]]
["Nat.div.proof_1",[WellFoundedRelation.wf, Nat, measure, id]]
["StateCpsT.lift",[Monad, Bind.bind, Monad.toBind]]
["Lean.term_Matches_",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Lean.Module.mk.sizeOf_spec",[Lean.Syntax, Array, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Lean.SyntaxNodeKind, instSizeOfName, Lean.SourceInfo, String, instSizeOf, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, Substring, Lean.Name, Prod, String.Pos]]
["ForInStep.noConfusionType",[ForInStep, Eq]]
["List.intercalate",[List, List.join, List.intersperse]]
["instDecidableEqQuotient.proof_2",[Setoid, Not, HasEquiv.Equiv, instHasEquiv, Eq, Quotient, Quotient.mk, absurd, False, Quotient.exact]]
["ExceptT.finally",[MonadFinally, Monad, MonadFinally.mk, ExceptT, Option, ExceptT.mk, Prod, Bind.bind, Monad.toBind, Except, MonadFinally.tryFinally', Option.some, Option.none, Pure.pure, Applicative.toPure, Monad.toApplicative, Except.ok, Prod.mk, Except.error]]
["«prec(_)»",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.cat, Lean.ParserDescr.symbol]]
["Lean.Syntax.decodeCharLit",[String, OptionM.run, Char, String.get, OfNat.ofNat, String.Pos, instOfNatNat, ite, OptionM, Eq, Bool, BEq.beq, instBEq, instDecidableEqChar, Char.ofNat, Bool.true, instDecidableEqBool, Bind.bind, Monad.toBind, OptionT.instMonadOptionT, Id, Id.instMonadId, Prod, Lean.Syntax.decodeQuotedChar, Pure.pure, Applicative.toPure, Alternative.toApplicative, OptionT.instAlternativeOptionT]]
["withPtrAddrUnsafe",[USize, Eq, ptrAddrUnsafe]]
["Lean.interpolatedStrKind",[Lean.Name.mkStr, Lean.Name.anonymous]]
["unexpandEqRec",[Lean.Syntax, ite, Lean.PrettyPrinter.UnexpandM, Eq, Bool, Lean.Syntax.isOfKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Lean.Syntax.getArg, OfNat.ofNat, Nat, instOfNatNat, Lean.Syntax.matchesNull, Bind.bind, Monad.toBind, EStateM.instMonadEStateM, Unit, Lean.SourceInfo, Lean.MonadRef.mkInfoFromRefPos, Lean.MonadQuotation.toMonadRef, Lean.PrettyPrinter.instMonadQuotationUnexpandM, Lean.MacroScope, Lean.MonadQuotation.getCurrMacroScope, Lean.Name, Lean.MonadQuotation.getMainModule, Pure.pure, Applicative.toPure, Monad.toApplicative, Lean.Syntax.node, List.toArray, List.cons, Lean.Syntax.atom, List.nil, MonadExcept.throw, instMonadExcept, EStateM.instMonadExceptOfEStateM, PUnit, EStateM.nonBacktrackable, Unit.unit]]
["charToHex",[Char, Nat, Char.toNat, HDiv.hDiv, instHDiv, Nat.instDivNat, OfNat.ofNat, instOfNatNat, HMod.hMod, instHMod, Nat.instModNat, HAppend.hAppend, String, instHAppend, String.instAppendString, hexDigitRepr]]
["Quot.rec",[Quot, Quot.mk, Eq, Quot.sound, PSigma.fst, Quot.lift, PSigma, Quot.indep, Quot.indepCoherent, Quot.liftIndepPr1, PSigma.snd]]
["Array.get!",[Inhabited, Array.getD, arbitrary]]
["Iff.refl",[Iff.intro]]
["UInt8.lt",[UInt8, LT.lt, Fin, UInt8.size, instLTFin, UInt8.val]]
["IO.Error.inappropriateType.sizeOf_spec",[Option, String, UInt32, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf, SizeOf.mk, List, Char, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["Array.size_swap",[Array, Fin, Array.size]]
["Lean.instQuoteName",[Lean.Quote.mk, Lean.Name, OptionM, List, String, Lean.Syntax, Lean.Name.below, Unit, Lean.Name.anonymous, Pure.pure, OptionT, Id, Applicative.toPure, Alternative.toApplicative, OptionT.instAlternativeOptionT, Id.instMonadId, UInt64, Lean.Name.str, Bind.bind, Monad.toBind, OptionT.instMonadOptionT, Lean.Name.escapePart, PProd.fst, PUnit, PProd, Nat, List.cons, Lean.Name.num, Option.none, List.nil, Lean.mkNode, Lean.Name.mkStr, List.toArray, Lean.Syntax.mkNameLit, HAppend.hAppend, instHAppend, String.instAppendString, String.intercalate, Lean.SourceInfo.none, Lean.mkCIdent, Lean.Syntax.mkCApp, Lean.Quote.quote, Lean.instQuoteString, Lean.instQuoteNat]]
["Lean.TrailingParserDescr",[Lean.ParserDescr]]
["Subarray.forInUnsafe",[Monad, Subarray, ForInStep, USize, USize.ofNat, Subarray.stop, Subarray.start, Subarray.forInUnsafe.loop]]
["instLEUInt64",[LE.mk, UInt64, UInt64.le]]
["Nat.pred_lt",[Nat, Ne, OfNat.ofNat, instOfNatNat, LT.lt, instLTNat, Nat.pred, Nat.zero, absurd, Eq, rfl, Nat.succ, Nat.lt_succ_of_le, Nat.le_refl]]
["Lean.Macro.instInhabitedMethods",[Inhabited.mk, Lean.Macro.Methods, Lean.Macro.Methods.mk, arbitrary, Lean.Syntax, Lean.MacroM, Option, instInhabitedDepArrow, instInhabitedReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, instInhabited, EStateM.instMonadEStateM, instInhabitedOption, Lean.Name, Lean.instInhabitedName, Bool, instInhabitedBool, List, Prod, String, instInhabitedList]]
["USize.lor",[USize, USize.mk, Fin.lor, USize.size, USize.val]]
["tryCatchThe",[MonadExceptOf, MonadExceptOf.tryCatch]]
["PNonScalar.noConfusionType",[PNonScalar, Nat, Eq]]
["instToBoolOption",[ToBool.mk, Option, Option.toBool]]
["Array.anyMUnsafe.any",[Monad, Bool, Array, USize, ite, Eq, BEq.beq, instBEq, instDecidableEqUSize, Bool.true, instDecidableEqBool, Pure.pure, Applicative.toPure, Monad.toApplicative, Bool.false, Bind.bind, Monad.toBind, Array.uget, lcProof, LT.lt, Nat, instLTNat, USize.toNat, Array.size, Array.anyMUnsafe.any, HAdd.hAdd, instHAdd, instAddUSize, OfNat.ofNat, instOfNatUSize]]
["Substring.str",[Substring]]
["Nat.add_right_comm",[Nat, Eq.mpr, Eq, HAdd.hAdd, instHAdd, instAddNat, Eq.refl, Nat.add_assoc, Nat.add_comm, Eq.symm, rfl]]
["Lean.mkAtom",[String, Lean.Syntax.atom, Lean.SourceInfo.none]]
["EIO.toIO",[IO.Error, EIO, EStateM.adaptExcept, IO.RealWorld]]
["IO.FS.DirEntry.mk.sizeOf_spec",[System.FilePath, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["USize.mk.sizeOf_spec",[Fin, USize.size, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, SizeOf.mk, LT.lt, instLTNat, instSizeOfNat, instSizeOf]]
["heq_of_eq_of_heq",[Eq, HEq, HEq.trans, heq_of_eq]]
["Int.subNatNat",[Nat, Int, HSub.hSub, instHSub, instSubNat, Unit, Int.ofNat, Int.negSucc]]
["«term_×_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Std.Format.join",[List, Std.Format, List.foldl, HAppend.hAppend, instHAppend, Std.Format.instAppendFormat, Std.Format.text]]
["Array.forInUnsafe.loop",[Monad, Array, ForInStep, USize, ite, LT.lt, instLTUSize, instDecidableLt_4, Array.uget, lcProof, Nat, instLTNat, USize.toNat, Array.size, Bind.bind, Monad.toBind, Pure.pure, Applicative.toPure, Monad.toApplicative, Array.forInUnsafe.loop, HAdd.hAdd, instHAdd, instAddUSize, OfNat.ofNat, instOfNatUSize]]
["MonadReader.read",[MonadReader]]
["List.le",[LT, List, Not, LT.lt, List.instLTList]]
["Char.isValidUInt32",[Nat, Char.isValidCharNat, LT.lt, instLTNat, UInt32.size, OfNat.ofNat, instOfNatNat, Nat.lt_trans, of_decide_eq_true, Nat.decLt, Eq.refl, Bool, Bool.true]]
["Quotient.lift₂.proof_1",[Setoid, HasEquiv.Equiv, instHasEquiv, Eq, Setoid.refl]]
["UInt64.lor",[UInt64, UInt64.mk, Fin.lor, UInt64.size, UInt64.val]]
["List.getLast?.proof_1",[List, Eq, List.cons, List.nil, False]]
["IO.FS.Stream.mk.inj",[IO, Bool, Unit, USize, ByteArray, String, Eq, IO.FS.Stream, IO.FS.Stream.mk, And, And.intro]]
["StateCpsT.runK_monadLift",[Monad, MonadLiftT, rfl, StateCpsT.runK, MonadLiftT.monadLift, StateCpsT, instMonadLiftT, StateCpsT.instMonadLiftStateCpsT]]
["Task.Priority",[Nat]]
["Nat.le_antisymm",[Nat, LE.le, instLENat, Eq, rfl, Nat.le, absurd, LT.lt, instLTNat, Nat.lt_of_le_of_lt, Nat.lt_irrefl]]
["Nat.anyAux",[Nat, Bool, Nat.below, Unit, Bool.false, Nat.succ, or, HSub.hSub, instHSub, instSubNat, PProd.fst, PUnit, PProd]]
["ToStream.noConfusionType",[outParam, ToStream, Eq]]
["Array.anyM.proof_1",[Array, Nat.le_refl, Array.size]]
["withPtrEq",[Unit, Bool, Eq, Unit.unit, Bool.true]]
["Nat.le_of_lt_succ",[Nat, Nat.le_of_succ_le_succ]]
["IO.appDir",[Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, System.FilePath, IO.appPath, Option, Pure.pure, Applicative.toPure, Monad.toApplicative, System.FilePath.parent, IO.FS.realPath, MonadExcept.throw, instMonadExcept, instMonadExceptOfEIO, IO.userError, HAppend.hAppend, String, instHAppend, String.instAppendString, ToString.toString, instToStringString, System.instToStringFilePath]]
["monadLift_self",[Monad, rfl, MonadLiftT.monadLift, instMonadLiftT_1]]
["Nat.not_succ_le_zero",[Nat, LE.le, instLENat, Nat.succ, OfNat.ofNat, instOfNatNat, False]]
["List.filterRevM",[Monad, Bool, List, List.filterAuxM, List.reverse, List.nil]]
["«term_&&_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["«term_↔_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["ExceptCpsT.run_lift",[Monad, rfl, Except, ExceptCpsT.run, ExceptCpsT.lift]]
["Lean.Name.num.inj",[Lean.Name, Nat, UInt64, Eq, Lean.Name.num, And, And.intro]]
["DoResultPRBC.noConfusionType",[DoResultPRBC, Eq]]
["Lean.mkIdent",[Lean.Name, Lean.Syntax.ident, Lean.SourceInfo.none, String.toSubstring, ToString.toString, Lean.Name.instToStringName, List.nil, Prod, List, String]]
["String.Iterator.remainingBytes",[String.Iterator, Nat, String, String.Pos, HSub.hSub, instHSub, instSubNat, String.bsize]]
["UInt64.size",[OfNat.ofNat, Nat, instOfNatNat]]
["IO.Process.SpawnArgs.cwd",[IO.Process.SpawnArgs]]
["InvImage.wf",[InvImage.wf.proof_1]]
["runST",[ST, EStateM.Result, Empty, Unit, Unit.unit]]
["instDecidableIte",[Decidable, ite, Not]]
["instDecidableNot",[Decidable, Not, Decidable.isFalse, absurd, False, Decidable.isTrue]]
["Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp",[Trans.mk, Nat, LE.le, instLENat, Nat.instTransLeArrowNatArrowNatPropLeArrowNatArrowNatPropLeArrowNatArrowNatProp.proof_1]]
["noConfusionTypeEnum",[DecidableEq, ite, Eq]]
["instInhabitedNonScalar",[Inhabited.mk, NonScalar, NonScalar.mk, arbitrary, Nat, instInhabitedNat]]
["instReprAtomBool",[ReprAtom.mk, Bool]]
["Classical.byCases",[Not, Decidable.byCases, Classical.propDecidable]]
["Lean.Name.toStringWithSep.maybeEscape",[Bool, String, ite, Eq, Bool.true, instDecidableEqBool, Option.getD, Lean.Name.escapePart]]
["String.offsetOfPos",[String, String.Pos, String.offsetOfPosAux, OfNat.ofNat, instOfNatNat, Nat]]
["instDecidableEqList",[DecidableEq, List.hasDecEq]]
["String.Iterator.pos",[String.Iterator, String.Pos, String]]
["instInhabitedUSize",[Inhabited.mk, USize, USize.ofNatCore, OfNat.ofNat, Nat, instOfNatNat, instInhabitedUSize.proof_1]]
["Nat.zero_lt_one",[Nat.zero_lt_succ, OfNat.ofNat, Nat, instOfNatNat]]
["decidableOfDecidableOfEq",[Decidable, Eq]]
["Lean.Macro.Context.methods",[Lean.Macro.Context]]
["Nat.foldRev.loop",[Nat, Nat.below, Nat.succ, PProd.fst, PUnit, PProd]]
["And.noConfusionType",[And]]
["List.join",[List, List.below, Unit, List.nil, List.cons, HAppend.hAppend, instHAppend, List.instAppendList, PProd.fst, PUnit, PProd]]
["instInhabitedTask",[Inhabited, Inhabited.mk, Task, Task.pure, arbitrary]]
["Array.«term__[_:]»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.const, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["Array.binInsert",[Inhabited, Bool, Array, Id.run, Array.binInsertM, Id, Id.instMonadId, Unit]]
["instCoeNatInt",[Coe.mk, Nat, Int, Int.ofNat]]
["instHModUInt16NatUInt16",[HMod.mk, UInt16, Nat, UInt16.modn]]
["Lean.mkAtomFrom",[Lean.Syntax, String, Lean.Syntax.atom, Lean.SourceInfo.fromRef]]
["instToStringChar",[ToString.mk, Char, Char.toString]]
["StateRefT'.instAlternativeStateRefT'",[Alternative, Monad, inferInstanceAs, ReaderT, ST.Ref, ReaderT.instAlternativeReaderT]]
["iff_true",[propext, Iff, True, Iff.intro, Iff.mpr, trivial]]
["optional",[Alternative, HOrElse.hOrElse, Option, instHOrElse, instOrElse, Functor.map, Applicative.toFunctor, Alternative.toApplicative, Option.some, Unit, Pure.pure, Applicative.toPure, Option.none]]
["Substring.foldl",[Char, Substring, String, String.Pos, String.foldlAux]]
["Lean.Syntax.isMissing",[Lean.Syntax, Bool, Unit, Bool.true, Bool.false]]
["Array.toList",[Array, Array.foldr, List, List.cons, List.nil, Array.size, OfNat.ofNat, Nat, instOfNatNat]]
["instMonadControlT",[MonadControl, MonadControlT, MonadControlT.mk, MonadControlT.stM, MonadControl.stM, MonadControl.liftWith, MonadControlT.liftWith, Function.comp, MonadControl.restoreM, MonadControlT.restoreM]]
["IO.Error.permissionDenied.inj",[Option, String, UInt32, Eq, IO.Error, IO.Error.permissionDenied, And, And.intro]]
["IO.Process.StdioConfig.noConfusionType",[IO.Process.StdioConfig, IO.Process.Stdio, Eq]]
["Lean.expandExplicitBinders",[Lean.Name, Lean.Syntax, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.MonadRef.getRef, Lean.Macro.instMonadRefMacroM, Lean.mkIdentFrom, Lean.Syntax.getOp, OfNat.ofNat, Nat, instOfNatNat, ite, Eq, Bool, BEq.beq, Lean.SyntaxNodeKind, Lean.Name.instBEqName, Lean.Syntax.getKind, Lean.Name.mkStr, Lean.Name.anonymous, Bool.true, instDecidableEqBool, Array, Lean.Syntax.getArgs, Option, Lean.Syntax.isNone, Option.none, Option.some, Lean.expandExplicitBindersAux, Array.all, Array.size, Lean.expandBrackedBindersAux, Lean.Macro.throwError]]
["List.ibelow",[List, True, And]]
["ExceptCpsT.instMonadLiftExceptCpsT",[Monad, MonadLift.mk, ExceptCpsT, ExceptCpsT.lift]]
["instHModUInt64NatUInt64",[HMod.mk, UInt64, Nat, UInt64.modn]]
["IO.FS.Stream.noConfusionType",[IO.FS.Stream, IO, Bool, Unit, USize, ByteArray, String, Eq]]
["Lean.Macro.getCurrNamespace",[Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, Lean.Name, Lean.Macro.getMethods, Lean.Macro.Methods.getCurrNamespace]]
["instOrdUSize",[Ord.mk, USize, compareOfLessAndEq, instLTUSize, instDecidableLt_4, instDecidableEqUSize]]
["Lean.Syntax.find?",[Lean.Syntax, Bool, Lean.Syntax.findAux]]
["MonadState.set",[MonadState]]
["Lean.Parser.Tactic.simp",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.nonReservedSymbol, Bool.false, Lean.ParserDescr.unary, Lean.Parser.Tactic.config, Lean.Parser.Tactic.discharger, Lean.ParserDescr.symbol, Lean.ParserDescr.sepBy, Lean.Parser.Tactic.simpStar, Lean.Parser.Tactic.simpErase, Lean.Parser.Tactic.simpLemma, Lean.Parser.Tactic.location]]
["List.instForMList",[ForM.mk, List, Monad, List.forM]]
["Std.Range.forM",[Monad, Std.Range, Nat, PUnit, Std.Range.stop, Std.Range.start, Std.Range.forM.loop]]
["Nat.add_le_add_right",[Nat, LE.le, instLENat, Eq.mpr, HAdd.hAdd, instHAdd, instAddNat, Eq, Eq.refl, Nat.add_comm, Nat.add_le_add_left]]
["instMonadST",[inferInstanceAs, Monad, EST, Empty, instMonadEST]]
["Std.Range.noConfusionType",[Std.Range, Nat, Eq]]
["Nat.mul_lt_mul_of_pos_left",[Nat, LT.lt, instLTNat, GT.gt, OfNat.ofNat, instOfNatNat, Nat.lt_of_lt_of_le, HMul.hMul, instHMul, instMulNat, HAdd.hAdd, instHAdd, instAddNat, Nat.mul, Nat.add_lt_add_left, Nat.succ, LE.le, instLENat, Nat.mul_le_mul_left, Nat.succ_le_of_lt, Nat.mul_succ]]
["precArg",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["IO.Error.otherErrorToString",[String, UInt32, Option, HAppend.hAppend, instHAppend, String.instAppendString, String.modify, OfNat.ofNat, String.Pos, instOfNatNat, Char.toLower, ToString.toString, instToStringUInt32, Unit]]
["type_eq_of_heq",[type_eq_of_heq.proof_1]]
["cast_heq",[Eq, HEq, cast, HEq.refl]]
["fix2",[Inhabited, fixCore2, arbitrary]]
["«term_$__»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.unary, Lean.ParserDescr.symbol, Lean.ParserDescr.const, Lean.ParserDescr.cat]]
["Equivalence.symm",[Equivalence]]
["TC.wf",[TC.wf.proof_1]]
["Lean.Parser.Tactic.skip",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["StateT.set",[Monad, Pure.pure, Applicative.toPure, Monad.toApplicative, Prod, PUnit, Prod.mk, PUnit.unit]]
["IO.Error.mkResourceExhaustedFile",[Function.comp, String, Option, UInt32, IO.Error, IO.Error.resourceExhausted, Option.some]]
["List.filterMapM",[Monad, Option, List, List.reverse, List.nil, List.filterMapM.loop]]
["Std.Range.step",[Std.Range]]
["Array.singleton",[Array.mkArray, OfNat.ofNat, Nat, instOfNatNat]]
["List.eraseIdx",[List, Nat, List.below, List.nil, List.cons, PProd.fst, PUnit, PProd]]
["Array.swapAt!",[Array, Nat, dite, Prod, LT.lt, instLTNat, Array.size, Nat.decLt, Array.swapAt, Fin.mk, Not]]
["instMonadReaderOf",[MonadLift, MonadReaderOf, MonadReaderOf.mk, liftM, instMonadLiftT, instMonadLiftT_1, MonadReader.read, instMonadReader]]
["Nat.mul_add",[Nat, Nat.left_distrib]]
["not_false",[id, False]]
["Std.Format.instMonadPrettyFormatStateMState",[Std.Format.MonadPrettyFormat.mk, StateM, String, modify, instMonadState, instMonadStateOfStateT, Id, Id.instMonadId, Nat, HAppend.hAppend, instHAppend, String.instAppendString, HAdd.hAdd, instHAdd, instAddNat, String.length, String.pushn, Char.ofNat, Bind.bind, Monad.toBind, StateT.instMonadStateT, MonadState.get, Pure.pure, Applicative.toPure, Monad.toApplicative, Unit, Unit.unit]]
["instMonadFinallyStateRefT'",[MonadFinally, Monad, inferInstanceAs, ReaderT, ST.Ref, ReaderT.tryFinally]]
["instStreamSubstringChar",[Stream.mk, Substring, Char, ite, Option, Prod, LT.lt, String.Pos, instLTNat, Substring.startPos, Substring.stopPos, Nat.decLt, Option.some, Prod.mk, String.get, Substring.str, Substring.mk, String.next, Option.none]]
["instDecidableTrue",[Decidable.isTrue, True, trivial]]
["Array.get",[List.get, Array.data, Fin.val, Array.size, Array.get.proof_1]]
["Nat.mul_le_mul_right",[Nat, LE.le, instLENat, HMul.hMul, instHMul, instMulNat, Nat.mul_le_mul_left, Nat.mul_comm]]
["Lean.Syntax.isInterpolatedStrLit?",[Lean.Syntax, Option, String, Lean.Syntax.isLit?, Lean.interpolatedStrLitKind, Unit, Option.none, String.Pos, OptionM, OfNat.ofNat, instOfNatNat]]
["dif_neg",[Decidable, Not, Eq, dite, absurd, Decidable.isTrue, rfl, Decidable.isFalse]]
["ReaderT",[]]
["Lean.mkGroupNode",[optParam, Array, Lean.Syntax, List.toArray, List.nil, Lean.Syntax.node, Lean.groupKind]]
["instReprSubtype",[Repr, Repr.mk, Subtype, Nat, Repr.reprPrec, Subtype.val]]
["Substring.isNat",[Substring, Substring.all, Char, Char.isDigit]]
["Task.map",[Task, optParam, Task.Priority, Task.Priority.default, Task.pure, Task.get]]
["Iff.symm",[Iff, Iff.intro, Iff.mpr, Iff.mp]]
["Lean.isIdFirst",[Char, or, Char.isAlpha, Decidable.decide, Eq, Char.ofNat, instDecidableEqChar, Lean.isLetterLike]]
["HShiftRight.hShiftRight",[HShiftRight]]
["List.foldlM",[Monad, List, List.below, List.nil, Pure.pure, Applicative.toPure, Monad.toApplicative, List.cons, Bind.bind, Monad.toBind, PProd.fst, PUnit, PProd]]
["Lean.Macro.State.traceMsgs",[Lean.Macro.State]]
["Fin.mod",[Nat, Fin, LT.lt, instLTNat, Fin.mk, HMod.hMod, instHMod, Nat.instModNat, Fin.mod.proof_1]]
["heq_of_eqRec_eq",[Eq, HEq, Eq.refl, heq_of_eq]]
["IO.FS.DirEntry.noConfusionType",[IO.FS.DirEntry, System.FilePath, String, Eq]]
["Nat.superDigitChar",[Nat, ite, Char, Eq, OfNat.ofNat, instOfNatNat, instDecidableEqNat, Char.ofNat]]
["IO.Process.run",[IO.Process.SpawnArgs, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, IO.Process.Output, String, IO.Process.output, PUnit, Pure.pure, Applicative.toPure, Monad.toApplicative, IO.Process.Output.stdout, ite, Eq, Bool, bne, UInt32, instBEq, instDecidableEqUInt32, IO.Process.Output.exitCode, OfNat.ofNat, instOfNatUInt32, Bool.true, instDecidableEqBool, MonadExcept.throw, instMonadExcept, instMonadExceptOfEIO, IO.userError, HAppend.hAppend, instHAppend, String.instAppendString, IO.Process.SpawnArgs.cmd, ToString.toString, instToStringUInt32, PUnit.unit]]
["instDecidableLt_1",[UInt8, UInt8.decLt]]
["Sum.noConfusionType",[Sum, Eq]]
["Array.toSubarray.proof_1",[Array, Nat.le_refl, Array.size]]
["«term_<->_»",[Lean.ParserDescr.trailingNode, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.binary, Lean.ParserDescr.symbol, Lean.ParserDescr.cat]]
["List.intersperse",[List, List.below, Unit, List.nil, List.cons, PProd.fst, PUnit, PProd]]
["Lean.Syntax.atom.sizeOf_spec",[Lean.SourceInfo, String, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf, instSizeOf, SizeOf.mk, List, Char, SizeOf, UInt32, UInt32.isValidChar, Fin, UInt32.size, LT.lt, instLTNat, instSizeOfNat]]
["System.FilePath.isDir",[System.FilePath, Bind.bind, IO, Monad.toBind, instMonadEIO, IO.Error, Bool, MonadExcept.tryCatch, instMonadExcept, instMonadExceptOfEIO, IO.FS.Metadata, System.FilePath.metadata, Pure.pure, Applicative.toPure, Monad.toApplicative, BEq.beq, IO.FS.FileType, IO.FS.instBEqFileType, IO.FS.Metadata.type, IO.FS.FileType.dir, Bool.false]]
["USize.shiftRight",[USize, USize.mk, HShiftRight.hShiftRight, Fin, USize.size, instHShiftRight, Fin.instShiftRightFin, USize.val, USize.modn, System.Platform.numBits]]
["String.isNat",[String, String.all, Char, Char.isDigit]]
["Nat.mod_le",[Nat, Or, LT.lt, instLTNat, GE.ge, instLENat, Nat.lt_or_ge, LE.le, HMod.hMod, instHMod, Nat.instModNat, Eq.mpr, Eq, Eq.refl, Nat.mod_eq_of_lt, Nat.le_refl, OfNat.ofNat, instOfNatNat, GT.gt, Nat.eq_zero_or_pos, Nat.mod_zero, Nat.le_trans, Nat.le_of_lt, Nat.mod_lt]]
["UInt16.complement",[UInt16, HSub.hSub, instHSub, instSubUInt16, OfNat.ofNat, instOfNatUInt16, HAdd.hAdd, instHAdd, instAddUInt16]]
["Fin.instSubFin",[Nat, Sub.mk, Fin, Fin.sub]]
["MonadExcept.noConfusionType",[outParam, MonadExcept, Eq]]
["Fin.instOfNatFinHAdd",[Nat, OfNat.mk, Fin, Fin.ofNat]]
["WellFounded.apply.proof_1",[WellFounded, Acc]]
["EStateM.Result.noConfusionType",[EStateM.Result, Eq]]
["prioHigh",[Lean.ParserDescr.node, Lean.Name.mkStr, Lean.Name.anonymous, OfNat.ofNat, Nat, instOfNatNat, Lean.ParserDescr.nonReservedSymbol, Bool.false]]
["NonScalar.val",[NonScalar]]
["UInt8.size",[OfNat.ofNat, Nat, instOfNatNat]]
["Array.anyM",[Monad, Bool, Array, optParam, Nat, OfNat.ofNat, instOfNatNat, Array.size, LE.le, instLENat, HSub.hSub, instHSub, instSubNat, Array.anyM.loop, dite, Nat.decLe, Not, Array.anyM.proof_1]]
["Lean.instInhabitedSourceInfo",[Inhabited.mk, Lean.SourceInfo, Lean.SourceInfo.none]]
["Fin.instAddFin",[Nat, Add.mk, Fin, Fin.add]]
["StateRefT'.instMonadFunctorStateRefT'",[Monad, inferInstanceAs, MonadFunctor, ReaderT, ST.Ref, ReaderT.instMonadFunctorReaderT]]
["Equivalence.refl",[Equivalence]]
["UInt16.add",[UInt16, UInt16.mk, HAdd.hAdd, Fin, UInt16.size, instHAdd, Fin.instAddFin, UInt16.val]]
["Lean.Name.ibelow",[Lean.Name, True, String, UInt64, And, Nat]]
["instAddUInt32",[Add.mk, UInt32, UInt32.add]]
["Task.pure.sizeOf_spec",[SizeOf, Eq.refl, Nat, HAdd.hAdd, instHAdd, instAddNat, OfNat.ofNat, instOfNatNat, SizeOf.sizeOf]]
["EIO",[EStateM, IO.RealWorld]]
["monadFunctorRefl",[MonadFunctorT.mk]]
["Lean.Macro.expandMacro?",[Lean.Syntax, Bind.bind, Lean.MacroM, Monad.toBind, ReaderT.instMonadReaderT, Lean.Macro.Context, EStateM, Lean.Macro.Exception, Lean.Macro.State, EStateM.instMonadEStateM, Lean.Macro.Methods, Option, Lean.Macro.getMethods, Lean.Macro.Methods.expandMacro?]]
["Lean.Module.noConfusionType",[Lean.Module, Lean.Syntax, Array, Eq]]
["Std.instToFormatFormat",[Std.ToFormat.mk, Std.Format]]
["randBool",[RandomGen, Prod, Nat, randNat, OfNat.ofNat, instOfNatNat, Prod.mk, Bool, Decidable.decide, Eq, instDecidableEqNat]]
["Subarray.instForInSubarray",[ForIn.mk, Subarray, Monad, Subarray.forIn]]
["MonadStateOf.set",[MonadStateOf]]
["String.prev",[String, String.Pos, List, Char, ite, Eq, OfNat.ofNat, instOfNatNat, instDecidableEqNat, List.below, List.nil, List.cons, Nat, String.csize, HAdd.hAdd, instHAdd, instAddNat, PProd.fst, PUnit, PProd]]
["dite_true",[True, Not, rfl, dite, instDecidableTrue]]
["Nat.foldM",[Monad, Nat, Nat.foldM.loop]]
["List.reverse",[List, List.reverseAux, List.nil]]
["USize.complement",[USize, HSub.hSub, instHSub, instSubUSize, OfNat.ofNat, instOfNatUSize, HAdd.hAdd, instHAdd, instAddUSize]]
["String.dropWhile",[String, Char, Bool, Substring.toString, Substring.dropWhile, String.toSubstring]]
["FloatArray.size",[FloatArray, Nat, Array, Float, Array.size]]
["List.hasDecEq.proof_5",[List, Not, Eq, List.cons, False, absurd]]
["Array.toArrayLit",[Array, Nat, Eq, Array.size, List.toArray, Array.toListLitAux, Array.toArrayLit.proof_1, List.nil]]
["Lean.Name.escapePart",[String, ite, Option, Eq, Bool, and, Decidable.decide, GT.gt, Nat, instLTNat, String.length, OfNat.ofNat, instOfNatNat, Nat.decLt, Lean.isIdFirst, String.getOp, String.Pos, Substring.all, Substring.drop, String.toSubstring, Lean.isIdRest, Bool.true, instDecidableEqBool, Option.some, String.any, Lean.isIdEndEscape, Option.none, HAppend.hAppend, instHAppend, String.instAppendString, Char.toString, Lean.idBeginEscape, Lean.idEndEscape]]
["Lean.Syntax.formatStx",[Lean.Syntax, optParam, Option, Nat, Option.none, Bool, Bool.false, Lean.Syntax.formatStxAux, OfNat.ofNat, instOfNatNat]]
["coeTrans",[Coe, CoeTC, CoeTC.mk, coeB, coeTC]]
